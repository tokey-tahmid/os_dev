
cosc562.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000080010000 <_memory_start>:
    80010000:	fe22                	sd	s0,312(sp)
    80010002:	f1ca                	sd	s2,224(sp)
    80010004:	0bee                	slli	s7,s7,0x1b
    80010006:	dead                	beqz	a3,8000ff80 <i+0x8000ff60>
    80010008:	4670                	lw	a2,76(a2)
    8001000a:	8001                	c.srli64	s0
	...

0000000080010102 <copy_from>:

unsigned long copy_from(void *dst, 
                        const struct page_table *from_table, 
                        const void *from, 
                        unsigned long size)
{
    80010102:	7139                	addi	sp,sp,-64
    80010104:	fc22                	sd	s0,56(sp)
    80010106:	0080                	addi	s0,sp,64
    80010108:	fca43c23          	sd	a0,-40(s0)
    8001010c:	fcb43823          	sd	a1,-48(s0)
    80010110:	fcc43423          	sd	a2,-56(s0)
    80010114:	fcd43023          	sd	a3,-64(s0)
    (void)dst;
    (void)from_table;
    (void)from;
    (void)size;

    unsigned long bytes_copied = 0;
    80010118:	fe043423          	sd	zero,-24(s0)

    return bytes_copied;
    8001011c:	fe843783          	ld	a5,-24(s0)
}
    80010120:	853e                	mv	a0,a5
    80010122:	7462                	ld	s0,56(sp)
    80010124:	6121                	addi	sp,sp,64
    80010126:	8082                	ret

0000000080010128 <copy_to>:

unsigned long copy_to(void *to, 
                      const struct page_table *to_table, 
                      const void *src, 
                      unsigned long size)
{
    80010128:	7139                	addi	sp,sp,-64
    8001012a:	fc22                	sd	s0,56(sp)
    8001012c:	0080                	addi	s0,sp,64
    8001012e:	fca43c23          	sd	a0,-40(s0)
    80010132:	fcb43823          	sd	a1,-48(s0)
    80010136:	fcc43423          	sd	a2,-56(s0)
    8001013a:	fcd43023          	sd	a3,-64(s0)
    (void)to;
    (void)to_table;
    (void)src;
    (void)size;

    unsigned long bytes_copied = 0;
    8001013e:	fe043423          	sd	zero,-24(s0)

    return bytes_copied;
    80010142:	fe843783          	ld	a5,-24(s0)
    80010146:	853e                	mv	a0,a5
    80010148:	7462                	ld	s0,56(sp)
    8001014a:	6121                	addi	sp,sp,64
    8001014c:	8082                	ret

000000008001014e <syscall_exit>:
    (void)hart;         \
    (void)epc;          \
    (void)scratch

SYSCALL(exit)
{
    8001014e:	7179                	addi	sp,sp,-48
    80010150:	f422                	sd	s0,40(sp)
    80010152:	1800                	addi	s0,sp,48
    80010154:	87aa                	mv	a5,a0
    80010156:	feb43023          	sd	a1,-32(s0)
    8001015a:	fcc43c23          	sd	a2,-40(s0)
    8001015e:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Kill the current process on this HART and schedule the next
    // one.
}
    80010162:	0001                	nop
    80010164:	7422                	ld	s0,40(sp)
    80010166:	6145                	addi	sp,sp,48
    80010168:	8082                	ret

000000008001016a <syscall_putchar>:

SYSCALL(putchar)
{
    8001016a:	7179                	addi	sp,sp,-48
    8001016c:	f406                	sd	ra,40(sp)
    8001016e:	f022                	sd	s0,32(sp)
    80010170:	1800                	addi	s0,sp,48
    80010172:	87aa                	mv	a5,a0
    80010174:	feb43023          	sd	a1,-32(s0)
    80010178:	fcc43c23          	sd	a2,-40(s0)
    8001017c:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    sbi_putchar(XREG(A0));
    80010180:	fd843783          	ld	a5,-40(s0)
    80010184:	05078793          	addi	a5,a5,80
    80010188:	639c                	ld	a5,0(a5)
    8001018a:	0ff7f793          	andi	a5,a5,255
    8001018e:	853e                	mv	a0,a5
    80010190:	067010ef          	jal	ra,800119f6 <sbi_putchar>
}
    80010194:	0001                	nop
    80010196:	70a2                	ld	ra,40(sp)
    80010198:	7402                	ld	s0,32(sp)
    8001019a:	6145                	addi	sp,sp,48
    8001019c:	8082                	ret

000000008001019e <syscall_getchar>:

SYSCALL(getchar)
{
    8001019e:	7179                	addi	sp,sp,-48
    800101a0:	f406                	sd	ra,40(sp)
    800101a2:	f022                	sd	s0,32(sp)
    800101a4:	1800                	addi	s0,sp,48
    800101a6:	87aa                	mv	a5,a0
    800101a8:	feb43023          	sd	a1,-32(s0)
    800101ac:	fcc43c23          	sd	a2,-40(s0)
    800101b0:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    XREG(A0) = sbi_getchar();
    800101b4:	065010ef          	jal	ra,80011a18 <sbi_getchar>
    800101b8:	87aa                	mv	a5,a0
    800101ba:	873e                	mv	a4,a5
    800101bc:	fd843783          	ld	a5,-40(s0)
    800101c0:	05078793          	addi	a5,a5,80
    800101c4:	e398                	sd	a4,0(a5)
}
    800101c6:	0001                	nop
    800101c8:	70a2                	ld	ra,40(sp)
    800101ca:	7402                	ld	s0,32(sp)
    800101cc:	6145                	addi	sp,sp,48
    800101ce:	8082                	ret

00000000800101d0 <syscall_yield>:

SYSCALL(yield)
{
    800101d0:	7179                	addi	sp,sp,-48
    800101d2:	f422                	sd	s0,40(sp)
    800101d4:	1800                	addi	s0,sp,48
    800101d6:	87aa                	mv	a5,a0
    800101d8:	feb43023          	sd	a1,-32(s0)
    800101dc:	fcc43c23          	sd	a2,-40(s0)
    800101e0:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // sched_invoke(hart);
}
    800101e4:	0001                	nop
    800101e6:	7422                	ld	s0,40(sp)
    800101e8:	6145                	addi	sp,sp,48
    800101ea:	8082                	ret

00000000800101ec <syscall_sleep>:

SYSCALL(sleep)
{
    800101ec:	7179                	addi	sp,sp,-48
    800101ee:	f422                	sd	s0,40(sp)
    800101f0:	1800                	addi	s0,sp,48
    800101f2:	87aa                	mv	a5,a0
    800101f4:	feb43023          	sd	a1,-32(s0)
    800101f8:	fcc43c23          	sd	a2,-40(s0)
    800101fc:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Sleep the process. VIRT_TIMER_FREQ is 10MHz, divided by 1000, we get 10KHz
    //     p->sleep_until = sbi_get_time() + XREG(A0) * VIRT_TIMER_FREQ / 1000;
    //     p->state = PS_SLEEPING;
}
    80010200:	0001                	nop
    80010202:	7422                	ld	s0,40(sp)
    80010204:	6145                	addi	sp,sp,48
    80010206:	8082                	ret

0000000080010208 <syscall_events>:

SYSCALL(events)
{
    80010208:	7179                	addi	sp,sp,-48
    8001020a:	f422                	sd	s0,40(sp)
    8001020c:	1800                	addi	s0,sp,48
    8001020e:	87aa                	mv	a5,a0
    80010210:	feb43023          	sd	a1,-32(s0)
    80010214:	fcc43c23          	sd	a2,-40(s0)
    80010218:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    
}
    8001021c:	0001                	nop
    8001021e:	7422                	ld	s0,40(sp)
    80010220:	6145                	addi	sp,sp,48
    80010222:	8082                	ret

0000000080010224 <syscall_handle>:

static const int NUM_SYSCALLS = sizeof(SYSCALLS) / sizeof(SYSCALLS[0]);

// We get here from the trap.c if this is an ECALL from U-MODE
void syscall_handle(int hart, uint64_t epc, int64_t *scratch)
{
    80010224:	7179                	addi	sp,sp,-48
    80010226:	f406                	sd	ra,40(sp)
    80010228:	f022                	sd	s0,32(sp)
    8001022a:	1800                	addi	s0,sp,48
    8001022c:	87aa                	mv	a5,a0
    8001022e:	feb43023          	sd	a1,-32(s0)
    80010232:	fcc43c23          	sd	a2,-40(s0)
    80010236:	fef42623          	sw	a5,-20(s0)
    // Sched invoke will save sepc, so we want it to resume
    // 4 bytes ahead, which will be the next instruction.
    CSR_WRITE("sepc", epc + 4);
    8001023a:	fe043783          	ld	a5,-32(s0)
    8001023e:	0791                	addi	a5,a5,4
    80010240:	14179073          	csrw	sepc,a5

    if (XREG(A7) >= NUM_SYSCALLS || SYSCALLS[XREG(A7)] == NULL) {
    80010244:	fd843783          	ld	a5,-40(s0)
    80010248:	08878793          	addi	a5,a5,136
    8001024c:	639c                	ld	a5,0(a5)
    8001024e:	4719                	li	a4,6
    80010250:	00e7df63          	bge	a5,a4,8001026e <syscall_handle+0x4a>
    80010254:	fd843783          	ld	a5,-40(s0)
    80010258:	08878793          	addi	a5,a5,136
    8001025c:	639c                	ld	a5,0(a5)
    8001025e:	00009717          	auipc	a4,0x9
    80010262:	da270713          	addi	a4,a4,-606 # 80019000 <SYSCALLS>
    80010266:	078e                	slli	a5,a5,0x3
    80010268:	97ba                	add	a5,a5,a4
    8001026a:	639c                	ld	a5,0(a5)
    8001026c:	eb81                	bnez	a5,8001027c <syscall_handle+0x58>
        // Invalid syscall
        XREG(A0) = -EINVAL;
    8001026e:	fd843783          	ld	a5,-40(s0)
    80010272:	05078793          	addi	a5,a5,80
    80010276:	5729                	li	a4,-22
    80010278:	e398                	sd	a4,0(a5)
    8001027a:	a035                	j	800102a6 <syscall_handle+0x82>
    }
    else {
        SYSCALL_EXEC(XREG(A7));
    8001027c:	fd843783          	ld	a5,-40(s0)
    80010280:	08878793          	addi	a5,a5,136
    80010284:	639c                	ld	a5,0(a5)
    80010286:	00009717          	auipc	a4,0x9
    8001028a:	d7a70713          	addi	a4,a4,-646 # 80019000 <SYSCALLS>
    8001028e:	078e                	slli	a5,a5,0x3
    80010290:	97ba                	add	a5,a5,a4
    80010292:	6398                	ld	a4,0(a5)
    80010294:	fec42783          	lw	a5,-20(s0)
    80010298:	fd843603          	ld	a2,-40(s0)
    8001029c:	fe043583          	ld	a1,-32(s0)
    800102a0:	853e                	mv	a0,a5
    800102a2:	9702                	jalr	a4
    }
}
    800102a4:	0001                	nop
    800102a6:	0001                	nop
    800102a8:	70a2                	ld	ra,40(sp)
    800102aa:	7402                	ld	s0,32(sp)
    800102ac:	6145                	addi	sp,sp,48
    800102ae:	8082                	ret

00000000800102b0 <mmu_table_create>:
#define ADDR_0_BIT   12
#define ADDR_1_BIT   21
#define ADDR_2_BIT   30

struct page_table *mmu_table_create(void)
{
    800102b0:	1141                	addi	sp,sp,-16
    800102b2:	e406                	sd	ra,8(sp)
    800102b4:	e022                	sd	s0,0(sp)
    800102b6:	0800                	addi	s0,sp,16
    return page_zalloc();
    800102b8:	4505                	li	a0,1
    800102ba:	1fa020ef          	jal	ra,800124b4 <page_znalloc>
    800102be:	87aa                	mv	a5,a0
}
    800102c0:	853e                	mv	a0,a5
    800102c2:	60a2                	ld	ra,8(sp)
    800102c4:	6402                	ld	s0,0(sp)
    800102c6:	0141                	addi	sp,sp,16
    800102c8:	8082                	ret

00000000800102ca <mmu_map>:

bool mmu_map(struct page_table *tab, uint64_t vaddr, uint64_t paddr, uint8_t lvl, uint64_t bits)
{
    800102ca:	7159                	addi	sp,sp,-112
    800102cc:	f4a2                	sd	s0,104(sp)
    800102ce:	1880                	addi	s0,sp,112
    800102d0:	faa43c23          	sd	a0,-72(s0)
    800102d4:	fab43823          	sd	a1,-80(s0)
    800102d8:	fac43423          	sd	a2,-88(s0)
    800102dc:	87b6                	mv	a5,a3
    800102de:	f8e43c23          	sd	a4,-104(s0)
    800102e2:	faf403a3          	sb	a5,-89(s0)
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    800102e6:	fb043783          	ld	a5,-80(s0)
    800102ea:	83b1                	srli	a5,a5,0xc
    800102ec:	1ff7f793          	andi	a5,a5,511
    800102f0:	fcf43c23          	sd	a5,-40(s0)
    800102f4:	fb043783          	ld	a5,-80(s0)
    800102f8:	83d5                	srli	a5,a5,0x15
    800102fa:	1ff7f793          	andi	a5,a5,511
    800102fe:	fef43023          	sd	a5,-32(s0)
                            (vaddr >> ADDR_2_BIT) & 0x1FF};
    80010302:	fb043783          	ld	a5,-80(s0)
    80010306:	83f9                	srli	a5,a5,0x1e
    80010308:	1ff7f793          	andi	a5,a5,511
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    8001030c:	fef43423          	sd	a5,-24(s0)
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80010310:	fa843783          	ld	a5,-88(s0)
    80010314:	83b1                	srli	a5,a5,0xc
    80010316:	1ff7f793          	andi	a5,a5,511
    8001031a:	fcf43023          	sd	a5,-64(s0)
    8001031e:	fa843783          	ld	a5,-88(s0)
    80010322:	83d5                	srli	a5,a5,0x15
    80010324:	1ff7f793          	andi	a5,a5,511
    80010328:	fcf43423          	sd	a5,-56(s0)
                            (paddr >> ADDR_2_BIT) & 0x3FFFFFF};
    8001032c:	fa843783          	ld	a5,-88(s0)
    80010330:	01e7d713          	srli	a4,a5,0x1e
    80010334:	040007b7          	lui	a5,0x4000
    80010338:	17fd                	addi	a5,a5,-1
    8001033a:	8ff9                	and	a5,a5,a4
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    8001033c:	fcf43823          	sd	a5,-48(s0)
    (void)vpn;
    (void)ppn;
    (void)bits;
    (void)tab;

    if (lvl > MMU_LEVEL_1G) {
    80010340:	fa744783          	lbu	a5,-89(s0)
    80010344:	0ff7f713          	andi	a4,a5,255
    80010348:	4789                	li	a5,2
    8001034a:	00e7f463          	bgeu	a5,a4,80010352 <mmu_map+0x88>
        return false;
    8001034e:	4781                	li	a5,0
    80010350:	a011                	j	80010354 <mmu_map+0x8a>
    }

    return false;
    80010352:	4781                	li	a5,0
}
    80010354:	853e                	mv	a0,a5
    80010356:	7426                	ld	s0,104(sp)
    80010358:	6165                	addi	sp,sp,112
    8001035a:	8082                	ret

000000008001035c <mmu_free>:

void mmu_free(struct page_table *tab)
{
    8001035c:	1101                	addi	sp,sp,-32
    8001035e:	ec22                	sd	s0,24(sp)
    80010360:	1000                	addi	s0,sp,32
    80010362:	fea43423          	sd	a0,-24(s0)
    if (tab == NULL) {
        return;
    }
    // Unmap all pages and free pages.
}
    80010366:	6462                	ld	s0,24(sp)
    80010368:	6105                	addi	sp,sp,32
    8001036a:	8082                	ret

000000008001036c <mmu_translate>:

uint64_t mmu_translate(const struct page_table *tab, uint64_t vaddr)
{
    8001036c:	7139                	addi	sp,sp,-64
    8001036e:	fc22                	sd	s0,56(sp)
    80010370:	0080                	addi	s0,sp,64
    80010372:	fca43423          	sd	a0,-56(s0)
    80010376:	fcb43023          	sd	a1,-64(s0)
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    8001037a:	fc043783          	ld	a5,-64(s0)
    8001037e:	83b1                	srli	a5,a5,0xc
    80010380:	1ff7f793          	andi	a5,a5,511
    80010384:	fcf43c23          	sd	a5,-40(s0)
    80010388:	fc043783          	ld	a5,-64(s0)
    8001038c:	83d5                	srli	a5,a5,0x15
    8001038e:	1ff7f793          	andi	a5,a5,511
    80010392:	fef43023          	sd	a5,-32(s0)
                      (vaddr >> ADDR_2_BIT) & 0x1FF};
    80010396:	fc043783          	ld	a5,-64(s0)
    8001039a:	83f9                	srli	a5,a5,0x1e
    8001039c:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    800103a0:	fef43423          	sd	a5,-24(s0)


    // Delete the following line. This is to get rid of the "unused" warning.
    (void)vpn;
    // Can't translate without a table.
    if (tab == NULL) {
    800103a4:	fc843783          	ld	a5,-56(s0)
    800103a8:	e399                	bnez	a5,800103ae <mmu_translate+0x42>
        return MMU_TRANSLATE_PAGE_FAULT;
    800103aa:	57fd                	li	a5,-1
    800103ac:	a011                	j	800103b0 <mmu_translate+0x44>
    }
    return MMU_TRANSLATE_PAGE_FAULT;
    800103ae:	57fd                	li	a5,-1
}
    800103b0:	853e                	mv	a0,a5
    800103b2:	7462                	ld	s0,56(sp)
    800103b4:	6121                	addi	sp,sp,64
    800103b6:	8082                	ret

00000000800103b8 <mmu_map_range>:
                       uint64_t start_virt, 
                       uint64_t end_virt, 
                       uint64_t start_phys,
                       uint8_t lvl, 
                       uint64_t bits)
{
    800103b8:	711d                	addi	sp,sp,-96
    800103ba:	ec86                	sd	ra,88(sp)
    800103bc:	e8a2                	sd	s0,80(sp)
    800103be:	1080                	addi	s0,sp,96
    800103c0:	fca43423          	sd	a0,-56(s0)
    800103c4:	fcb43023          	sd	a1,-64(s0)
    800103c8:	fac43c23          	sd	a2,-72(s0)
    800103cc:	fad43823          	sd	a3,-80(s0)
    800103d0:	faf43023          	sd	a5,-96(s0)
    800103d4:	87ba                	mv	a5,a4
    800103d6:	faf407a3          	sb	a5,-81(s0)
    start_virt            = ALIGN_DOWN_POT(start_virt, PAGE_SIZE_AT_LVL(lvl));
    800103da:	faf44783          	lbu	a5,-81(s0)
    800103de:	2781                	sext.w	a5,a5
    800103e0:	873e                	mv	a4,a5
    800103e2:	87ba                	mv	a5,a4
    800103e4:	0037979b          	slliw	a5,a5,0x3
    800103e8:	9fb9                	addw	a5,a5,a4
    800103ea:	2781                	sext.w	a5,a5
    800103ec:	27b1                	addiw	a5,a5,12
    800103ee:	2781                	sext.w	a5,a5
    800103f0:	4705                	li	a4,1
    800103f2:	00f717bb          	sllw	a5,a4,a5
    800103f6:	2781                	sext.w	a5,a5
    800103f8:	40f007bb          	negw	a5,a5
    800103fc:	2781                	sext.w	a5,a5
    800103fe:	873e                	mv	a4,a5
    80010400:	fc043783          	ld	a5,-64(s0)
    80010404:	8ff9                	and	a5,a5,a4
    80010406:	fcf43023          	sd	a5,-64(s0)
    end_virt              = ALIGN_UP_POT(end_virt, PAGE_SIZE_AT_LVL(lvl));
    8001040a:	faf44783          	lbu	a5,-81(s0)
    8001040e:	2781                	sext.w	a5,a5
    80010410:	873e                	mv	a4,a5
    80010412:	87ba                	mv	a5,a4
    80010414:	0037979b          	slliw	a5,a5,0x3
    80010418:	9fb9                	addw	a5,a5,a4
    8001041a:	2781                	sext.w	a5,a5
    8001041c:	27b1                	addiw	a5,a5,12
    8001041e:	2781                	sext.w	a5,a5
    80010420:	4705                	li	a4,1
    80010422:	00f717bb          	sllw	a5,a4,a5
    80010426:	2781                	sext.w	a5,a5
    80010428:	873e                	mv	a4,a5
    8001042a:	fb843783          	ld	a5,-72(s0)
    8001042e:	97ba                	add	a5,a5,a4
    80010430:	fff78713          	addi	a4,a5,-1 # 3ffffff <i+0x3ffffdf>
    80010434:	faf44783          	lbu	a5,-81(s0)
    80010438:	2781                	sext.w	a5,a5
    8001043a:	86be                	mv	a3,a5
    8001043c:	87b6                	mv	a5,a3
    8001043e:	0037979b          	slliw	a5,a5,0x3
    80010442:	9fb5                	addw	a5,a5,a3
    80010444:	2781                	sext.w	a5,a5
    80010446:	27b1                	addiw	a5,a5,12
    80010448:	2781                	sext.w	a5,a5
    8001044a:	4685                	li	a3,1
    8001044c:	00f697bb          	sllw	a5,a3,a5
    80010450:	2781                	sext.w	a5,a5
    80010452:	40f007bb          	negw	a5,a5
    80010456:	2781                	sext.w	a5,a5
    80010458:	8ff9                	and	a5,a5,a4
    8001045a:	faf43c23          	sd	a5,-72(s0)
    uint64_t num_bytes    = end_virt - start_virt;
    8001045e:	fb843703          	ld	a4,-72(s0)
    80010462:	fc043783          	ld	a5,-64(s0)
    80010466:	40f707b3          	sub	a5,a4,a5
    8001046a:	fcf43c23          	sd	a5,-40(s0)
    uint64_t pages_mapped = 0;
    8001046e:	fe043423          	sd	zero,-24(s0)

    uint64_t i;
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80010472:	fe043023          	sd	zero,-32(s0)
    80010476:	a0ad                	j	800104e0 <mmu_map_range+0x128>
        if (!mmu_map(tab, start_virt + i, start_phys + i, lvl, bits)) {
    80010478:	fc043703          	ld	a4,-64(s0)
    8001047c:	fe043783          	ld	a5,-32(s0)
    80010480:	00f705b3          	add	a1,a4,a5
    80010484:	fb043703          	ld	a4,-80(s0)
    80010488:	fe043783          	ld	a5,-32(s0)
    8001048c:	97ba                	add	a5,a5,a4
    8001048e:	faf44683          	lbu	a3,-81(s0)
    80010492:	fa043703          	ld	a4,-96(s0)
    80010496:	863e                	mv	a2,a5
    80010498:	fc843503          	ld	a0,-56(s0)
    8001049c:	e2fff0ef          	jal	ra,800102ca <mmu_map>
    800104a0:	87aa                	mv	a5,a0
    800104a2:	0017c793          	xori	a5,a5,1
    800104a6:	0ff7f793          	andi	a5,a5,255
    800104aa:	e3b1                	bnez	a5,800104ee <mmu_map_range+0x136>
            break;
        }
        pages_mapped += 1;
    800104ac:	fe843783          	ld	a5,-24(s0)
    800104b0:	0785                	addi	a5,a5,1
    800104b2:	fef43423          	sd	a5,-24(s0)
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    800104b6:	faf44783          	lbu	a5,-81(s0)
    800104ba:	2781                	sext.w	a5,a5
    800104bc:	873e                	mv	a4,a5
    800104be:	87ba                	mv	a5,a4
    800104c0:	0037979b          	slliw	a5,a5,0x3
    800104c4:	9fb9                	addw	a5,a5,a4
    800104c6:	2781                	sext.w	a5,a5
    800104c8:	27b1                	addiw	a5,a5,12
    800104ca:	2781                	sext.w	a5,a5
    800104cc:	4705                	li	a4,1
    800104ce:	00f717bb          	sllw	a5,a4,a5
    800104d2:	2781                	sext.w	a5,a5
    800104d4:	873e                	mv	a4,a5
    800104d6:	fe043783          	ld	a5,-32(s0)
    800104da:	97ba                	add	a5,a5,a4
    800104dc:	fef43023          	sd	a5,-32(s0)
    800104e0:	fe043703          	ld	a4,-32(s0)
    800104e4:	fd843783          	ld	a5,-40(s0)
    800104e8:	f8f768e3          	bltu	a4,a5,80010478 <mmu_map_range+0xc0>
    800104ec:	a011                	j	800104f0 <mmu_map_range+0x138>
            break;
    800104ee:	0001                	nop
    }
    return pages_mapped;
    800104f0:	fe843783          	ld	a5,-24(s0)
}
    800104f4:	853e                	mv	a0,a5
    800104f6:	60e6                	ld	ra,88(sp)
    800104f8:	6446                	ld	s0,80(sp)
    800104fa:	6125                	addi	sp,sp,96
    800104fc:	8082                	ret

00000000800104fe <c_trap_handler>:
// From src/syscall.c
void syscall_handle(int hart, uint64_t epc, int64_t *scratch);

// Called from asm/spawn.S: _spawn_trap
void c_trap_handler(void)
{
    800104fe:	7139                	addi	sp,sp,-64
    80010500:	fc06                	sd	ra,56(sp)
    80010502:	f822                	sd	s0,48(sp)
    80010504:	0080                	addi	s0,sp,64
    unsigned long cause;
    long *scratch;
    unsigned long epc;
    unsigned long tval;
    CSR_READ(cause, "scause");
    80010506:	142027f3          	csrr	a5,scause
    8001050a:	fef43423          	sd	a5,-24(s0)
    CSR_READ(scratch, "sscratch");
    8001050e:	140027f3          	csrr	a5,sscratch
    80010512:	fef43023          	sd	a5,-32(s0)
    CSR_READ(epc, "sepc");
    80010516:	141027f3          	csrr	a5,sepc
    8001051a:	fcf43c23          	sd	a5,-40(s0)
    CSR_READ(tval, "stval");
    8001051e:	143027f3          	csrr	a5,stval
    80010522:	fcf43823          	sd	a5,-48(s0)
    
    int hart = sbi_whoami();
    80010526:	666010ef          	jal	ra,80011b8c <sbi_whoami>
    8001052a:	87aa                	mv	a5,a0
    8001052c:	fcf42623          	sw	a5,-52(s0)

    if (SCAUSE_IS_ASYNC(cause)) {
    80010530:	fe843783          	ld	a5,-24(s0)
    80010534:	0407d563          	bgez	a5,8001057e <c_trap_handler+0x80>
        cause = SCAUSE_NUM(cause);
    80010538:	fe843783          	ld	a5,-24(s0)
    8001053c:	0ff7f793          	andi	a5,a5,255
    80010540:	fef43423          	sd	a5,-24(s0)
        switch (cause) {
    80010544:	fe843703          	ld	a4,-24(s0)
    80010548:	4795                	li	a5,5
    8001054a:	00f70863          	beq	a4,a5,8001055a <c_trap_handler+0x5c>
    8001054e:	fe843703          	ld	a4,-24(s0)
    80010552:	47a5                	li	a5,9
    80010554:	00f70663          	beq	a4,a5,80010560 <c_trap_handler+0x62>
    80010558:	a811                	j	8001056c <c_trap_handler+0x6e>
            case CAUSE_STIP:
                // Ack timer will reset the timer to INFINITE
                // In src/sbi.c
                sbi_ack_timer();
    8001055a:	5fc010ef          	jal	ra,80011b56 <sbi_ack_timer>
                // We typically invoke our scheduler if we get a timer
                // sched_invoke(hart);
                break;
    8001055e:	a08d                	j	800105c0 <c_trap_handler+0xc2>
            case CAUSE_SEIP:
                // Forward to src/plic.c
                plic_handle_irq(hart);
    80010560:	fcc42783          	lw	a5,-52(s0)
    80010564:	853e                	mv	a0,a5
    80010566:	0db010ef          	jal	ra,80011e40 <plic_handle_irq>
                break;
    8001056a:	a899                	j	800105c0 <c_trap_handler+0xc2>
            default:
                debugf("Unhandled Asynchronous interrupt %ld\n", cause);
    8001056c:	fe843583          	ld	a1,-24(s0)
    80010570:	00009517          	auipc	a0,0x9
    80010574:	ac050513          	addi	a0,a0,-1344 # 80019030 <SYSCALLS+0x30>
    80010578:	366010ef          	jal	ra,800118de <debugf>
                break;
    8001057c:	a091                	j	800105c0 <c_trap_handler+0xc2>
        }
    }
    else {
        switch (cause) {
    8001057e:	fe843703          	ld	a4,-24(s0)
    80010582:	47a1                	li	a5,8
    80010584:	00f71c63          	bne	a4,a5,8001059c <c_trap_handler+0x9e>
            case CAUSE_ECALL_U_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                syscall_handle(hart, epc, scratch);
    80010588:	fcc42783          	lw	a5,-52(s0)
    8001058c:	fe043603          	ld	a2,-32(s0)
    80010590:	fd843583          	ld	a1,-40(s0)
    80010594:	853e                	mv	a0,a5
    80010596:	c8fff0ef          	jal	ra,80010224 <syscall_handle>
                break;
    8001059a:	a01d                	j	800105c0 <c_trap_handler+0xc2>
            default:
                debugf(
    8001059c:	fcc42783          	lw	a5,-52(s0)
    800105a0:	873e                	mv	a4,a5
    800105a2:	fd043683          	ld	a3,-48(s0)
    800105a6:	fd843603          	ld	a2,-40(s0)
    800105aa:	fe843583          	ld	a1,-24(s0)
    800105ae:	00009517          	auipc	a0,0x9
    800105b2:	aaa50513          	addi	a0,a0,-1366 # 80019058 <SYSCALLS+0x58>
    800105b6:	328010ef          	jal	ra,800118de <debugf>
                    "Unhandled Synchronous interrupt %ld @ 0x%08lx [0x%08lx]. "
                    "Hanging hart %d\n",
                    cause, epc, tval, hart);
                WFI_LOOP();
    800105ba:	10500073          	wfi
    800105be:	bff5                	j	800105ba <c_trap_handler+0xbc>
                break;
        }
    }
}
    800105c0:	0001                	nop
    800105c2:	70e2                	ld	ra,56(sp)
    800105c4:	7442                	ld	s0,48(sp)
    800105c6:	6121                	addi	sp,sp,64
    800105c8:	8082                	ret

00000000800105ca <pci_init>:
#include <pci.h>

void pci_init(void)
{
    800105ca:	1141                	addi	sp,sp,-16
    800105cc:	e422                	sd	s0,8(sp)
    800105ce:	0800                	addi	s0,sp,16
    // Initialize and enumerate all PCI bridges and devices.

    // This should forward all virtio devices to the virtio drivers.
}
    800105d0:	0001                	nop
    800105d2:	6422                	ld	s0,8(sp)
    800105d4:	0141                	addi	sp,sp,16
    800105d6:	8082                	ret

00000000800105d8 <pci_dispatch_irq>:

void pci_dispatch_irq(int irq)
{
    800105d8:	1101                	addi	sp,sp,-32
    800105da:	ec22                	sd	s0,24(sp)
    800105dc:	1000                	addi	s0,sp,32
    800105de:	87aa                	mv	a5,a0
    800105e0:	fef42623          	sw	a5,-20(s0)
    (void)irq;

    // An IRQ came from the PLIC, but recall PCI devices
    // share IRQs. So, you need to check the ISR register
    // of potential virtio devices.
}
    800105e4:	0001                	nop
    800105e6:	6462                	ld	s0,24(sp)
    800105e8:	6105                	addi	sp,sp,32
    800105ea:	8082                	ret

00000000800105ec <mutex_trylock>:
#include <config.h>
#include <lock.h>
#include <compiler.h>

bool mutex_trylock(Mutex *mutex)
{
    800105ec:	7179                	addi	sp,sp,-48
    800105ee:	f422                	sd	s0,40(sp)
    800105f0:	1800                	addi	s0,sp,48
    800105f2:	fca43c23          	sd	a0,-40(s0)
    int old;
    asm volatile("amoswap.w.aq %0, %1, (%2)" : "=r"(old) : "r"(MUTEX_LOCKED), "r"(mutex));
    800105f6:	4785                	li	a5,1
    800105f8:	fd843703          	ld	a4,-40(s0)
    800105fc:	0cf727af          	amoswap.w.aq	a5,a5,(a4)
    80010600:	fef42623          	sw	a5,-20(s0)
    // If old == MUTEX_LOCKED, that means the mutex was already
    // locked when we tried to lock it. That means we didn't acquire
    // it.
    return old != MUTEX_LOCKED;
    80010604:	fec42783          	lw	a5,-20(s0)
    80010608:	0007871b          	sext.w	a4,a5
    8001060c:	4785                	li	a5,1
    8001060e:	40f707b3          	sub	a5,a4,a5
    80010612:	00f037b3          	snez	a5,a5
    80010616:	0ff7f793          	andi	a5,a5,255
}
    8001061a:	853e                	mv	a0,a5
    8001061c:	7422                	ld	s0,40(sp)
    8001061e:	6145                	addi	sp,sp,48
    80010620:	8082                	ret

0000000080010622 <mutex_spinlock>:

void mutex_spinlock(Mutex *mutex)
{
    80010622:	1101                	addi	sp,sp,-32
    80010624:	ec06                	sd	ra,24(sp)
    80010626:	e822                	sd	s0,16(sp)
    80010628:	1000                	addi	s0,sp,32
    8001062a:	fea43423          	sd	a0,-24(s0)
    while (!mutex_trylock(mutex))
    8001062e:	0001                	nop
    80010630:	fe843503          	ld	a0,-24(s0)
    80010634:	fb9ff0ef          	jal	ra,800105ec <mutex_trylock>
    80010638:	87aa                	mv	a5,a0
    8001063a:	0017c793          	xori	a5,a5,1
    8001063e:	0ff7f793          	andi	a5,a5,255
    80010642:	f7fd                	bnez	a5,80010630 <mutex_spinlock+0xe>
        ;
}
    80010644:	0001                	nop
    80010646:	0001                	nop
    80010648:	60e2                	ld	ra,24(sp)
    8001064a:	6442                	ld	s0,16(sp)
    8001064c:	6105                	addi	sp,sp,32
    8001064e:	8082                	ret

0000000080010650 <mutex_unlock>:

void mutex_unlock(Mutex *mutex)
{
    80010650:	1101                	addi	sp,sp,-32
    80010652:	ec22                	sd	s0,24(sp)
    80010654:	1000                	addi	s0,sp,32
    80010656:	fea43423          	sd	a0,-24(s0)
    asm volatile("amoswap.w.rl zero, zero, (%0)" : : "r"(mutex));
    8001065a:	fe843783          	ld	a5,-24(s0)
    8001065e:	0a07a02f          	amoswap.w.rl	zero,zero,(a5)
}
    80010662:	0001                	nop
    80010664:	6462                	ld	s0,24(sp)
    80010666:	6105                	addi	sp,sp,32
    80010668:	8082                	ret

000000008001066a <insert_block>:
 * into free list, sorted by addr.
 * If disabled, add block has new head of
 * the free list.
 */
static void insert_block(Block *block)
{
    8001066a:	7179                	addi	sp,sp,-48
    8001066c:	f422                	sd	s0,40(sp)
    8001066e:	1800                	addi	s0,sp,48
    80010670:	fca43c23          	sd	a0,-40(s0)
    Block *ptr  = heap->free;
    80010674:	00008797          	auipc	a5,0x8
    80010678:	9b478793          	addi	a5,a5,-1612 # 80018028 <heap>
    8001067c:	639c                	ld	a5,0(a5)
    8001067e:	639c                	ld	a5,0(a5)
    80010680:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    80010684:	fe043023          	sd	zero,-32(s0)
    while (ptr != NULL) {
    80010688:	a01d                	j	800106ae <insert_block+0x44>
        if ((size_t)block->addr <= (size_t)ptr->addr) {
    8001068a:	fd843783          	ld	a5,-40(s0)
    8001068e:	639c                	ld	a5,0(a5)
    80010690:	873e                	mv	a4,a5
    80010692:	fe843783          	ld	a5,-24(s0)
    80010696:	639c                	ld	a5,0(a5)
    80010698:	00e7ff63          	bgeu	a5,a4,800106b6 <insert_block+0x4c>
            break;
        }
        prev = ptr;
    8001069c:	fe843783          	ld	a5,-24(s0)
    800106a0:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    800106a4:	fe843783          	ld	a5,-24(s0)
    800106a8:	679c                	ld	a5,8(a5)
    800106aa:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    800106ae:	fe843783          	ld	a5,-24(s0)
    800106b2:	ffe1                	bnez	a5,8001068a <insert_block+0x20>
    800106b4:	a011                	j	800106b8 <insert_block+0x4e>
            break;
    800106b6:	0001                	nop
    }
    if (prev != NULL) {
    800106b8:	fe043783          	ld	a5,-32(s0)
    800106bc:	c799                	beqz	a5,800106ca <insert_block+0x60>
        prev->next = block;
    800106be:	fe043783          	ld	a5,-32(s0)
    800106c2:	fd843703          	ld	a4,-40(s0)
    800106c6:	e798                	sd	a4,8(a5)
    800106c8:	a809                	j	800106da <insert_block+0x70>
    }
    else {
        heap->free = block;
    800106ca:	00008797          	auipc	a5,0x8
    800106ce:	95e78793          	addi	a5,a5,-1698 # 80018028 <heap>
    800106d2:	639c                	ld	a5,0(a5)
    800106d4:	fd843703          	ld	a4,-40(s0)
    800106d8:	e398                	sd	a4,0(a5)
    }
    block->next = ptr;
    800106da:	fd843783          	ld	a5,-40(s0)
    800106de:	fe843703          	ld	a4,-24(s0)
    800106e2:	e798                	sd	a4,8(a5)
}
    800106e4:	0001                	nop
    800106e6:	7422                	ld	s0,40(sp)
    800106e8:	6145                	addi	sp,sp,48
    800106ea:	8082                	ret

00000000800106ec <release_blocks>:

#ifndef TA_DISABLE_COMPACT
static void release_blocks(Block *scan, Block *to)
{
    800106ec:	7179                	addi	sp,sp,-48
    800106ee:	f422                	sd	s0,40(sp)
    800106f0:	1800                	addi	s0,sp,48
    800106f2:	fca43c23          	sd	a0,-40(s0)
    800106f6:	fcb43823          	sd	a1,-48(s0)
    Block *scan_next;
    while (scan != to) {
    800106fa:	a099                	j	80010740 <release_blocks+0x54>
        scan_next   = scan->next;
    800106fc:	fd843783          	ld	a5,-40(s0)
    80010700:	679c                	ld	a5,8(a5)
    80010702:	fef43423          	sd	a5,-24(s0)
        scan->next  = heap->fresh;
    80010706:	00008797          	auipc	a5,0x8
    8001070a:	92278793          	addi	a5,a5,-1758 # 80018028 <heap>
    8001070e:	639c                	ld	a5,0(a5)
    80010710:	6b98                	ld	a4,16(a5)
    80010712:	fd843783          	ld	a5,-40(s0)
    80010716:	e798                	sd	a4,8(a5)
        heap->fresh = scan;
    80010718:	00008797          	auipc	a5,0x8
    8001071c:	91078793          	addi	a5,a5,-1776 # 80018028 <heap>
    80010720:	639c                	ld	a5,0(a5)
    80010722:	fd843703          	ld	a4,-40(s0)
    80010726:	eb98                	sd	a4,16(a5)
        scan->addr  = 0;
    80010728:	fd843783          	ld	a5,-40(s0)
    8001072c:	0007b023          	sd	zero,0(a5)
        scan->size  = 0;
    80010730:	fd843783          	ld	a5,-40(s0)
    80010734:	0007b823          	sd	zero,16(a5)
        scan        = scan_next;
    80010738:	fe843783          	ld	a5,-24(s0)
    8001073c:	fcf43c23          	sd	a5,-40(s0)
    while (scan != to) {
    80010740:	fd843703          	ld	a4,-40(s0)
    80010744:	fd043783          	ld	a5,-48(s0)
    80010748:	faf71ae3          	bne	a4,a5,800106fc <release_blocks+0x10>
    }
}
    8001074c:	0001                	nop
    8001074e:	0001                	nop
    80010750:	7422                	ld	s0,40(sp)
    80010752:	6145                	addi	sp,sp,48
    80010754:	8082                	ret

0000000080010756 <compact>:

static void compact()
{
    80010756:	7139                	addi	sp,sp,-64
    80010758:	fc06                	sd	ra,56(sp)
    8001075a:	f822                	sd	s0,48(sp)
    8001075c:	0080                	addi	s0,sp,64
    Block *ptr = heap->free;
    8001075e:	00008797          	auipc	a5,0x8
    80010762:	8ca78793          	addi	a5,a5,-1846 # 80018028 <heap>
    80010766:	639c                	ld	a5,0(a5)
    80010768:	639c                	ld	a5,0(a5)
    8001076a:	fef43423          	sd	a5,-24(s0)
    Block *prev;
    Block *scan;
    while (ptr != NULL) {
    8001076e:	a075                	j	8001081a <compact+0xc4>
        prev = ptr;
    80010770:	fe843783          	ld	a5,-24(s0)
    80010774:	fef43023          	sd	a5,-32(s0)
        scan = ptr->next;
    80010778:	fe843783          	ld	a5,-24(s0)
    8001077c:	679c                	ld	a5,8(a5)
    8001077e:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    80010782:	a811                	j	80010796 <compact+0x40>
            prev = scan;
    80010784:	fd843783          	ld	a5,-40(s0)
    80010788:	fef43023          	sd	a5,-32(s0)
            scan = scan->next;
    8001078c:	fd843783          	ld	a5,-40(s0)
    80010790:	679c                	ld	a5,8(a5)
    80010792:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    80010796:	fd843783          	ld	a5,-40(s0)
    8001079a:	cf91                	beqz	a5,800107b6 <compact+0x60>
    8001079c:	fe043783          	ld	a5,-32(s0)
    800107a0:	639c                	ld	a5,0(a5)
    800107a2:	873e                	mv	a4,a5
    800107a4:	fe043783          	ld	a5,-32(s0)
    800107a8:	6b9c                	ld	a5,16(a5)
    800107aa:	97ba                	add	a5,a5,a4
    800107ac:	fd843703          	ld	a4,-40(s0)
    800107b0:	6318                	ld	a4,0(a4)
    800107b2:	fce789e3          	beq	a5,a4,80010784 <compact+0x2e>
        }
        if (prev != ptr) {
    800107b6:	fe043703          	ld	a4,-32(s0)
    800107ba:	fe843783          	ld	a5,-24(s0)
    800107be:	04f70963          	beq	a4,a5,80010810 <compact+0xba>
            size_t new_size = (size_t)prev->addr - (size_t)ptr->addr + prev->size;
    800107c2:	fe043783          	ld	a5,-32(s0)
    800107c6:	639c                	ld	a5,0(a5)
    800107c8:	873e                	mv	a4,a5
    800107ca:	fe843783          	ld	a5,-24(s0)
    800107ce:	639c                	ld	a5,0(a5)
    800107d0:	8f1d                	sub	a4,a4,a5
    800107d2:	fe043783          	ld	a5,-32(s0)
    800107d6:	6b9c                	ld	a5,16(a5)
    800107d8:	97ba                	add	a5,a5,a4
    800107da:	fcf43823          	sd	a5,-48(s0)
            ptr->size       = new_size;
    800107de:	fe843783          	ld	a5,-24(s0)
    800107e2:	fd043703          	ld	a4,-48(s0)
    800107e6:	eb98                	sd	a4,16(a5)
            Block *next     = prev->next;
    800107e8:	fe043783          	ld	a5,-32(s0)
    800107ec:	679c                	ld	a5,8(a5)
    800107ee:	fcf43423          	sd	a5,-56(s0)
            // make merged blocks available
            release_blocks(ptr->next, prev->next);
    800107f2:	fe843783          	ld	a5,-24(s0)
    800107f6:	6798                	ld	a4,8(a5)
    800107f8:	fe043783          	ld	a5,-32(s0)
    800107fc:	679c                	ld	a5,8(a5)
    800107fe:	85be                	mv	a1,a5
    80010800:	853a                	mv	a0,a4
    80010802:	eebff0ef          	jal	ra,800106ec <release_blocks>
            // relink
            ptr->next = next;
    80010806:	fe843783          	ld	a5,-24(s0)
    8001080a:	fc843703          	ld	a4,-56(s0)
    8001080e:	e798                	sd	a4,8(a5)
        }
        ptr = ptr->next;
    80010810:	fe843783          	ld	a5,-24(s0)
    80010814:	679c                	ld	a5,8(a5)
    80010816:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    8001081a:	fe843783          	ld	a5,-24(s0)
    8001081e:	fba9                	bnez	a5,80010770 <compact+0x1a>
    }
}
    80010820:	0001                	nop
    80010822:	0001                	nop
    80010824:	70e2                	ld	ra,56(sp)
    80010826:	7442                	ld	s0,48(sp)
    80010828:	6121                	addi	sp,sp,64
    8001082a:	8082                	ret

000000008001082c <init>:
#endif

static bool init(const void *base, const void *limit, const size_t heap_blocks,
                 const size_t split_thresh, const size_t alignment)
{
    8001082c:	715d                	addi	sp,sp,-80
    8001082e:	e4a2                	sd	s0,72(sp)
    80010830:	0880                	addi	s0,sp,80
    80010832:	fca43c23          	sd	a0,-40(s0)
    80010836:	fcb43823          	sd	a1,-48(s0)
    8001083a:	fcc43423          	sd	a2,-56(s0)
    8001083e:	fcd43023          	sd	a3,-64(s0)
    80010842:	fae43c23          	sd	a4,-72(s0)
    heap              = (Heap *)base;
    80010846:	00007797          	auipc	a5,0x7
    8001084a:	7e278793          	addi	a5,a5,2018 # 80018028 <heap>
    8001084e:	fd843703          	ld	a4,-40(s0)
    80010852:	e398                	sd	a4,0(a5)
    heap_limit        = limit;
    80010854:	00007797          	auipc	a5,0x7
    80010858:	7dc78793          	addi	a5,a5,2012 # 80018030 <heap_limit>
    8001085c:	fd043703          	ld	a4,-48(s0)
    80010860:	e398                	sd	a4,0(a5)
    heap_split_thresh = split_thresh;
    80010862:	00007797          	auipc	a5,0x7
    80010866:	7d678793          	addi	a5,a5,2006 # 80018038 <heap_split_thresh>
    8001086a:	fc043703          	ld	a4,-64(s0)
    8001086e:	e398                	sd	a4,0(a5)
    heap_alignment    = alignment;
    80010870:	00007797          	auipc	a5,0x7
    80010874:	7d078793          	addi	a5,a5,2000 # 80018040 <heap_alignment>
    80010878:	fb843703          	ld	a4,-72(s0)
    8001087c:	e398                	sd	a4,0(a5)
    heap_max_blocks   = heap_blocks;
    8001087e:	00007797          	auipc	a5,0x7
    80010882:	7ca78793          	addi	a5,a5,1994 # 80018048 <heap_max_blocks>
    80010886:	fc843703          	ld	a4,-56(s0)
    8001088a:	e398                	sd	a4,0(a5)

    heap->free        = NULL;
    8001088c:	00007797          	auipc	a5,0x7
    80010890:	79c78793          	addi	a5,a5,1948 # 80018028 <heap>
    80010894:	639c                	ld	a5,0(a5)
    80010896:	0007b023          	sd	zero,0(a5)
    heap->used        = NULL;
    8001089a:	00007797          	auipc	a5,0x7
    8001089e:	78e78793          	addi	a5,a5,1934 # 80018028 <heap>
    800108a2:	639c                	ld	a5,0(a5)
    800108a4:	0007b423          	sd	zero,8(a5)
    heap->fresh       = (Block *)(heap + 1);
    800108a8:	00007797          	auipc	a5,0x7
    800108ac:	78078793          	addi	a5,a5,1920 # 80018028 <heap>
    800108b0:	6398                	ld	a4,0(a5)
    800108b2:	00007797          	auipc	a5,0x7
    800108b6:	77678793          	addi	a5,a5,1910 # 80018028 <heap>
    800108ba:	639c                	ld	a5,0(a5)
    800108bc:	02070713          	addi	a4,a4,32
    800108c0:	eb98                	sd	a4,16(a5)
    heap->top         = (size_t)(heap->fresh + heap_blocks);
    800108c2:	00007797          	auipc	a5,0x7
    800108c6:	76678793          	addi	a5,a5,1894 # 80018028 <heap>
    800108ca:	639c                	ld	a5,0(a5)
    800108cc:	6b94                	ld	a3,16(a5)
    800108ce:	fc843703          	ld	a4,-56(s0)
    800108d2:	87ba                	mv	a5,a4
    800108d4:	0786                	slli	a5,a5,0x1
    800108d6:	97ba                	add	a5,a5,a4
    800108d8:	078e                	slli	a5,a5,0x3
    800108da:	00f68733          	add	a4,a3,a5
    800108de:	00007797          	auipc	a5,0x7
    800108e2:	74a78793          	addi	a5,a5,1866 # 80018028 <heap>
    800108e6:	639c                	ld	a5,0(a5)
    800108e8:	ef98                	sd	a4,24(a5)

    Block *block      = heap->fresh;
    800108ea:	00007797          	auipc	a5,0x7
    800108ee:	73e78793          	addi	a5,a5,1854 # 80018028 <heap>
    800108f2:	639c                	ld	a5,0(a5)
    800108f4:	6b9c                	ld	a5,16(a5)
    800108f6:	fef43423          	sd	a5,-24(s0)
    size_t i          = heap_max_blocks - 1;
    800108fa:	00007797          	auipc	a5,0x7
    800108fe:	74e78793          	addi	a5,a5,1870 # 80018048 <heap_max_blocks>
    80010902:	639c                	ld	a5,0(a5)
    80010904:	17fd                	addi	a5,a5,-1
    80010906:	fef43023          	sd	a5,-32(s0)
    while (i--) {
    8001090a:	a829                	j	80010924 <init+0xf8>
        block->next = block + 1;
    8001090c:	fe843783          	ld	a5,-24(s0)
    80010910:	01878713          	addi	a4,a5,24
    80010914:	fe843783          	ld	a5,-24(s0)
    80010918:	e798                	sd	a4,8(a5)
        block++;
    8001091a:	fe843783          	ld	a5,-24(s0)
    8001091e:	07e1                	addi	a5,a5,24
    80010920:	fef43423          	sd	a5,-24(s0)
    while (i--) {
    80010924:	fe043783          	ld	a5,-32(s0)
    80010928:	fff78713          	addi	a4,a5,-1
    8001092c:	fee43023          	sd	a4,-32(s0)
    80010930:	fff1                	bnez	a5,8001090c <init+0xe0>
    }
    block->next = NULL;
    80010932:	fe843783          	ld	a5,-24(s0)
    80010936:	0007b423          	sd	zero,8(a5)
    return true;
    8001093a:	4785                	li	a5,1
}
    8001093c:	853e                	mv	a0,a5
    8001093e:	6426                	ld	s0,72(sp)
    80010940:	6161                	addi	sp,sp,80
    80010942:	8082                	ret

0000000080010944 <free>:

static bool free(const void *free)
{
    80010944:	7179                	addi	sp,sp,-48
    80010946:	f406                	sd	ra,40(sp)
    80010948:	f022                	sd	s0,32(sp)
    8001094a:	1800                	addi	s0,sp,48
    8001094c:	fca43c23          	sd	a0,-40(s0)
    Block *block = heap->used;
    80010950:	00007797          	auipc	a5,0x7
    80010954:	6d878793          	addi	a5,a5,1752 # 80018028 <heap>
    80010958:	639c                	ld	a5,0(a5)
    8001095a:	679c                	ld	a5,8(a5)
    8001095c:	fef43423          	sd	a5,-24(s0)
    Block *prev  = NULL;
    80010960:	fe043023          	sd	zero,-32(s0)
    while (block != NULL) {
    80010964:	a8a1                	j	800109bc <free+0x78>
        if (free == block->addr) {
    80010966:	fe843783          	ld	a5,-24(s0)
    8001096a:	639c                	ld	a5,0(a5)
    8001096c:	fd843703          	ld	a4,-40(s0)
    80010970:	02f71d63          	bne	a4,a5,800109aa <free+0x66>
            if (prev) {
    80010974:	fe043783          	ld	a5,-32(s0)
    80010978:	cb81                	beqz	a5,80010988 <free+0x44>
                prev->next = block->next;
    8001097a:	fe843783          	ld	a5,-24(s0)
    8001097e:	6798                	ld	a4,8(a5)
    80010980:	fe043783          	ld	a5,-32(s0)
    80010984:	e798                	sd	a4,8(a5)
    80010986:	a811                	j	8001099a <free+0x56>
            }
            else {
                heap->used = block->next;
    80010988:	00007797          	auipc	a5,0x7
    8001098c:	6a078793          	addi	a5,a5,1696 # 80018028 <heap>
    80010990:	639c                	ld	a5,0(a5)
    80010992:	fe843703          	ld	a4,-24(s0)
    80010996:	6718                	ld	a4,8(a4)
    80010998:	e798                	sd	a4,8(a5)
            }
            insert_block(block);
    8001099a:	fe843503          	ld	a0,-24(s0)
    8001099e:	ccdff0ef          	jal	ra,8001066a <insert_block>
            compact();
    800109a2:	db5ff0ef          	jal	ra,80010756 <compact>
            return true;
    800109a6:	4785                	li	a5,1
    800109a8:	a831                	j	800109c4 <free+0x80>
        }
        prev  = block;
    800109aa:	fe843783          	ld	a5,-24(s0)
    800109ae:	fef43023          	sd	a5,-32(s0)
        block = block->next;
    800109b2:	fe843783          	ld	a5,-24(s0)
    800109b6:	679c                	ld	a5,8(a5)
    800109b8:	fef43423          	sd	a5,-24(s0)
    while (block != NULL) {
    800109bc:	fe843783          	ld	a5,-24(s0)
    800109c0:	f3dd                	bnez	a5,80010966 <free+0x22>
    }
    return false;
    800109c2:	4781                	li	a5,0
}
    800109c4:	853e                	mv	a0,a5
    800109c6:	70a2                	ld	ra,40(sp)
    800109c8:	7402                	ld	s0,32(sp)
    800109ca:	6145                	addi	sp,sp,48
    800109cc:	8082                	ret

00000000800109ce <alloc_block>:

static Block *alloc_block(size_t num)
{
    800109ce:	711d                	addi	sp,sp,-96
    800109d0:	ec86                	sd	ra,88(sp)
    800109d2:	e8a2                	sd	s0,80(sp)
    800109d4:	1080                	addi	s0,sp,96
    800109d6:	faa43423          	sd	a0,-88(s0)
    Block *ptr  = heap->free;
    800109da:	00007797          	auipc	a5,0x7
    800109de:	64e78793          	addi	a5,a5,1614 # 80018028 <heap>
    800109e2:	639c                	ld	a5,0(a5)
    800109e4:	639c                	ld	a5,0(a5)
    800109e6:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    800109ea:	fe043023          	sd	zero,-32(s0)
    size_t top  = heap->top;
    800109ee:	00007797          	auipc	a5,0x7
    800109f2:	63a78793          	addi	a5,a5,1594 # 80018028 <heap>
    800109f6:	639c                	ld	a5,0(a5)
    800109f8:	6f9c                	ld	a5,24(a5)
    800109fa:	fcf43c23          	sd	a5,-40(s0)
    num         = (num + heap_alignment - 1) & -heap_alignment;
    800109fe:	00007797          	auipc	a5,0x7
    80010a02:	64278793          	addi	a5,a5,1602 # 80018040 <heap_alignment>
    80010a06:	6398                	ld	a4,0(a5)
    80010a08:	fa843783          	ld	a5,-88(s0)
    80010a0c:	97ba                	add	a5,a5,a4
    80010a0e:	fff78713          	addi	a4,a5,-1
    80010a12:	00007797          	auipc	a5,0x7
    80010a16:	62e78793          	addi	a5,a5,1582 # 80018040 <heap_alignment>
    80010a1a:	639c                	ld	a5,0(a5)
    80010a1c:	40f007b3          	neg	a5,a5
    80010a20:	8ff9                	and	a5,a5,a4
    80010a22:	faf43423          	sd	a5,-88(s0)
    while (ptr != NULL) {
    80010a26:	a2bd                	j	80010b94 <alloc_block+0x1c6>
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    80010a28:	fe843783          	ld	a5,-24(s0)
    80010a2c:	639c                	ld	a5,0(a5)
    80010a2e:	873e                	mv	a4,a5
    80010a30:	fe843783          	ld	a5,-24(s0)
    80010a34:	6b9c                	ld	a5,16(a5)
    80010a36:	97ba                	add	a5,a5,a4
    80010a38:	fd843703          	ld	a4,-40(s0)
    80010a3c:	02e7e263          	bltu	a5,a4,80010a60 <alloc_block+0x92>
                           ((size_t)ptr->addr + num <= (size_t)heap_limit);
    80010a40:	fe843783          	ld	a5,-24(s0)
    80010a44:	639c                	ld	a5,0(a5)
    80010a46:	873e                	mv	a4,a5
    80010a48:	fa843783          	ld	a5,-88(s0)
    80010a4c:	97ba                	add	a5,a5,a4
    80010a4e:	00007717          	auipc	a4,0x7
    80010a52:	5e270713          	addi	a4,a4,1506 # 80018030 <heap_limit>
    80010a56:	6318                	ld	a4,0(a4)
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    80010a58:	00f76463          	bltu	a4,a5,80010a60 <alloc_block+0x92>
    80010a5c:	4785                	li	a5,1
    80010a5e:	a011                	j	80010a62 <alloc_block+0x94>
    80010a60:	4781                	li	a5,0
    80010a62:	fcf42623          	sw	a5,-52(s0)
        if (is_top || ptr->size >= num) {
    80010a66:	fcc42783          	lw	a5,-52(s0)
    80010a6a:	2781                	sext.w	a5,a5
    80010a6c:	eb81                	bnez	a5,80010a7c <alloc_block+0xae>
    80010a6e:	fe843783          	ld	a5,-24(s0)
    80010a72:	6b9c                	ld	a5,16(a5)
    80010a74:	fa843703          	ld	a4,-88(s0)
    80010a78:	10e7e563          	bltu	a5,a4,80010b82 <alloc_block+0x1b4>
            if (prev != NULL) {
    80010a7c:	fe043783          	ld	a5,-32(s0)
    80010a80:	cb81                	beqz	a5,80010a90 <alloc_block+0xc2>
                prev->next = ptr->next;
    80010a82:	fe843783          	ld	a5,-24(s0)
    80010a86:	6798                	ld	a4,8(a5)
    80010a88:	fe043783          	ld	a5,-32(s0)
    80010a8c:	e798                	sd	a4,8(a5)
    80010a8e:	a811                	j	80010aa2 <alloc_block+0xd4>
            }
            else {
                heap->free = ptr->next;
    80010a90:	00007797          	auipc	a5,0x7
    80010a94:	59878793          	addi	a5,a5,1432 # 80018028 <heap>
    80010a98:	639c                	ld	a5,0(a5)
    80010a9a:	fe843703          	ld	a4,-24(s0)
    80010a9e:	6718                	ld	a4,8(a4)
    80010aa0:	e398                	sd	a4,0(a5)
            }
            ptr->next  = heap->used;
    80010aa2:	00007797          	auipc	a5,0x7
    80010aa6:	58678793          	addi	a5,a5,1414 # 80018028 <heap>
    80010aaa:	639c                	ld	a5,0(a5)
    80010aac:	6798                	ld	a4,8(a5)
    80010aae:	fe843783          	ld	a5,-24(s0)
    80010ab2:	e798                	sd	a4,8(a5)
            heap->used = ptr;
    80010ab4:	00007797          	auipc	a5,0x7
    80010ab8:	57478793          	addi	a5,a5,1396 # 80018028 <heap>
    80010abc:	639c                	ld	a5,0(a5)
    80010abe:	fe843703          	ld	a4,-24(s0)
    80010ac2:	e798                	sd	a4,8(a5)
            if (is_top) {
    80010ac4:	fcc42783          	lw	a5,-52(s0)
    80010ac8:	2781                	sext.w	a5,a5
    80010aca:	c785                	beqz	a5,80010af2 <alloc_block+0x124>
                ptr->size = num;
    80010acc:	fe843783          	ld	a5,-24(s0)
    80010ad0:	fa843703          	ld	a4,-88(s0)
    80010ad4:	eb98                	sd	a4,16(a5)
                heap->top = (size_t)ptr->addr + num;
    80010ad6:	fe843783          	ld	a5,-24(s0)
    80010ada:	639c                	ld	a5,0(a5)
    80010adc:	86be                	mv	a3,a5
    80010ade:	00007797          	auipc	a5,0x7
    80010ae2:	54a78793          	addi	a5,a5,1354 # 80018028 <heap>
    80010ae6:	639c                	ld	a5,0(a5)
    80010ae8:	fa843703          	ld	a4,-88(s0)
    80010aec:	9736                	add	a4,a4,a3
    80010aee:	ef98                	sd	a4,24(a5)
    80010af0:	a071                	j	80010b7c <alloc_block+0x1ae>
            }
            else if (heap->fresh != NULL) {
    80010af2:	00007797          	auipc	a5,0x7
    80010af6:	53678793          	addi	a5,a5,1334 # 80018028 <heap>
    80010afa:	639c                	ld	a5,0(a5)
    80010afc:	6b9c                	ld	a5,16(a5)
    80010afe:	cfbd                	beqz	a5,80010b7c <alloc_block+0x1ae>
                size_t excess = ptr->size - num;
    80010b00:	fe843783          	ld	a5,-24(s0)
    80010b04:	6b98                	ld	a4,16(a5)
    80010b06:	fa843783          	ld	a5,-88(s0)
    80010b0a:	40f707b3          	sub	a5,a4,a5
    80010b0e:	fcf43023          	sd	a5,-64(s0)
                if (excess >= heap_split_thresh) {
    80010b12:	00007797          	auipc	a5,0x7
    80010b16:	52678793          	addi	a5,a5,1318 # 80018038 <heap_split_thresh>
    80010b1a:	639c                	ld	a5,0(a5)
    80010b1c:	fc043703          	ld	a4,-64(s0)
    80010b20:	04f76e63          	bltu	a4,a5,80010b7c <alloc_block+0x1ae>
                    ptr->size    = num;
    80010b24:	fe843783          	ld	a5,-24(s0)
    80010b28:	fa843703          	ld	a4,-88(s0)
    80010b2c:	eb98                	sd	a4,16(a5)
                    Block *split = heap->fresh;
    80010b2e:	00007797          	auipc	a5,0x7
    80010b32:	4fa78793          	addi	a5,a5,1274 # 80018028 <heap>
    80010b36:	639c                	ld	a5,0(a5)
    80010b38:	6b9c                	ld	a5,16(a5)
    80010b3a:	faf43c23          	sd	a5,-72(s0)
                    heap->fresh  = split->next;
    80010b3e:	00007797          	auipc	a5,0x7
    80010b42:	4ea78793          	addi	a5,a5,1258 # 80018028 <heap>
    80010b46:	639c                	ld	a5,0(a5)
    80010b48:	fb843703          	ld	a4,-72(s0)
    80010b4c:	6718                	ld	a4,8(a4)
    80010b4e:	eb98                	sd	a4,16(a5)
                    split->addr  = (void *)((size_t)ptr->addr + num);
    80010b50:	fe843783          	ld	a5,-24(s0)
    80010b54:	639c                	ld	a5,0(a5)
    80010b56:	873e                	mv	a4,a5
    80010b58:	fa843783          	ld	a5,-88(s0)
    80010b5c:	97ba                	add	a5,a5,a4
    80010b5e:	873e                	mv	a4,a5
    80010b60:	fb843783          	ld	a5,-72(s0)
    80010b64:	e398                	sd	a4,0(a5)
                    split->size  = excess;
    80010b66:	fb843783          	ld	a5,-72(s0)
    80010b6a:	fc043703          	ld	a4,-64(s0)
    80010b6e:	eb98                	sd	a4,16(a5)
                    insert_block(split);
    80010b70:	fb843503          	ld	a0,-72(s0)
    80010b74:	af7ff0ef          	jal	ra,8001066a <insert_block>
                    compact();
    80010b78:	bdfff0ef          	jal	ra,80010756 <compact>
                }
            }
            return ptr;
    80010b7c:	fe843783          	ld	a5,-24(s0)
    80010b80:	a875                	j	80010c3c <alloc_block+0x26e>
        }
        prev = ptr;
    80010b82:	fe843783          	ld	a5,-24(s0)
    80010b86:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    80010b8a:	fe843783          	ld	a5,-24(s0)
    80010b8e:	679c                	ld	a5,8(a5)
    80010b90:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80010b94:	fe843783          	ld	a5,-24(s0)
    80010b98:	e80798e3          	bnez	a5,80010a28 <alloc_block+0x5a>
    }
    // no matching free blocks
    // see if any other blocks available
    size_t new_top = top + num;
    80010b9c:	fd843703          	ld	a4,-40(s0)
    80010ba0:	fa843783          	ld	a5,-88(s0)
    80010ba4:	97ba                	add	a5,a5,a4
    80010ba6:	fcf43823          	sd	a5,-48(s0)
    if (heap->fresh != NULL && new_top <= (size_t)heap_limit) {
    80010baa:	00007797          	auipc	a5,0x7
    80010bae:	47e78793          	addi	a5,a5,1150 # 80018028 <heap>
    80010bb2:	639c                	ld	a5,0(a5)
    80010bb4:	6b9c                	ld	a5,16(a5)
    80010bb6:	c3d1                	beqz	a5,80010c3a <alloc_block+0x26c>
    80010bb8:	00007797          	auipc	a5,0x7
    80010bbc:	47878793          	addi	a5,a5,1144 # 80018030 <heap_limit>
    80010bc0:	639c                	ld	a5,0(a5)
    80010bc2:	873e                	mv	a4,a5
    80010bc4:	fd043783          	ld	a5,-48(s0)
    80010bc8:	06f76963          	bltu	a4,a5,80010c3a <alloc_block+0x26c>
        ptr         = heap->fresh;
    80010bcc:	00007797          	auipc	a5,0x7
    80010bd0:	45c78793          	addi	a5,a5,1116 # 80018028 <heap>
    80010bd4:	639c                	ld	a5,0(a5)
    80010bd6:	6b9c                	ld	a5,16(a5)
    80010bd8:	fef43423          	sd	a5,-24(s0)
        heap->fresh = ptr->next;
    80010bdc:	00007797          	auipc	a5,0x7
    80010be0:	44c78793          	addi	a5,a5,1100 # 80018028 <heap>
    80010be4:	639c                	ld	a5,0(a5)
    80010be6:	fe843703          	ld	a4,-24(s0)
    80010bea:	6718                	ld	a4,8(a4)
    80010bec:	eb98                	sd	a4,16(a5)
        ptr->addr   = (void *)top;
    80010bee:	fd843703          	ld	a4,-40(s0)
    80010bf2:	fe843783          	ld	a5,-24(s0)
    80010bf6:	e398                	sd	a4,0(a5)
        ptr->next   = heap->used;
    80010bf8:	00007797          	auipc	a5,0x7
    80010bfc:	43078793          	addi	a5,a5,1072 # 80018028 <heap>
    80010c00:	639c                	ld	a5,0(a5)
    80010c02:	6798                	ld	a4,8(a5)
    80010c04:	fe843783          	ld	a5,-24(s0)
    80010c08:	e798                	sd	a4,8(a5)
        ptr->size   = num;
    80010c0a:	fe843783          	ld	a5,-24(s0)
    80010c0e:	fa843703          	ld	a4,-88(s0)
    80010c12:	eb98                	sd	a4,16(a5)
        heap->used  = ptr;
    80010c14:	00007797          	auipc	a5,0x7
    80010c18:	41478793          	addi	a5,a5,1044 # 80018028 <heap>
    80010c1c:	639c                	ld	a5,0(a5)
    80010c1e:	fe843703          	ld	a4,-24(s0)
    80010c22:	e798                	sd	a4,8(a5)
        heap->top   = new_top;
    80010c24:	00007797          	auipc	a5,0x7
    80010c28:	40478793          	addi	a5,a5,1028 # 80018028 <heap>
    80010c2c:	639c                	ld	a5,0(a5)
    80010c2e:	fd043703          	ld	a4,-48(s0)
    80010c32:	ef98                	sd	a4,24(a5)
        return ptr;
    80010c34:	fe843783          	ld	a5,-24(s0)
    80010c38:	a011                	j	80010c3c <alloc_block+0x26e>
    }
    return NULL;
    80010c3a:	4781                	li	a5,0
}
    80010c3c:	853e                	mv	a0,a5
    80010c3e:	60e6                	ld	ra,88(sp)
    80010c40:	6446                	ld	s0,80(sp)
    80010c42:	6125                	addi	sp,sp,96
    80010c44:	8082                	ret

0000000080010c46 <alloc>:

static void *alloc(size_t num)
{
    80010c46:	7179                	addi	sp,sp,-48
    80010c48:	f406                	sd	ra,40(sp)
    80010c4a:	f022                	sd	s0,32(sp)
    80010c4c:	1800                	addi	s0,sp,48
    80010c4e:	fca43c23          	sd	a0,-40(s0)
    Block *block = alloc_block(num);
    80010c52:	fd843503          	ld	a0,-40(s0)
    80010c56:	d79ff0ef          	jal	ra,800109ce <alloc_block>
    80010c5a:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80010c5e:	fe843783          	ld	a5,-24(s0)
    80010c62:	c789                	beqz	a5,80010c6c <alloc+0x26>
        return block->addr;
    80010c64:	fe843783          	ld	a5,-24(s0)
    80010c68:	639c                	ld	a5,0(a5)
    80010c6a:	a011                	j	80010c6e <alloc+0x28>
    }
    return NULL;
    80010c6c:	4781                	li	a5,0
}
    80010c6e:	853e                	mv	a0,a5
    80010c70:	70a2                	ld	ra,40(sp)
    80010c72:	7402                	ld	s0,32(sp)
    80010c74:	6145                	addi	sp,sp,48
    80010c76:	8082                	ret

0000000080010c78 <calloc>:

static void *calloc(size_t num, size_t size)
{
    80010c78:	7179                	addi	sp,sp,-48
    80010c7a:	f406                	sd	ra,40(sp)
    80010c7c:	f022                	sd	s0,32(sp)
    80010c7e:	1800                	addi	s0,sp,48
    80010c80:	fca43c23          	sd	a0,-40(s0)
    80010c84:	fcb43823          	sd	a1,-48(s0)
    num *= size;
    80010c88:	fd843703          	ld	a4,-40(s0)
    80010c8c:	fd043783          	ld	a5,-48(s0)
    80010c90:	02f707b3          	mul	a5,a4,a5
    80010c94:	fcf43c23          	sd	a5,-40(s0)
    Block *block = alloc_block(num);
    80010c98:	fd843503          	ld	a0,-40(s0)
    80010c9c:	d33ff0ef          	jal	ra,800109ce <alloc_block>
    80010ca0:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80010ca4:	fe843783          	ld	a5,-24(s0)
    80010ca8:	c385                	beqz	a5,80010cc8 <calloc+0x50>
        memset(block->addr, 0, num);
    80010caa:	fe843783          	ld	a5,-24(s0)
    80010cae:	639c                	ld	a5,0(a5)
    80010cb0:	fd843703          	ld	a4,-40(s0)
    80010cb4:	2701                	sext.w	a4,a4
    80010cb6:	863a                	mv	a2,a4
    80010cb8:	4581                	li	a1,0
    80010cba:	853e                	mv	a0,a5
    80010cbc:	076040ef          	jal	ra,80014d32 <memset>
        return block->addr;
    80010cc0:	fe843783          	ld	a5,-24(s0)
    80010cc4:	639c                	ld	a5,0(a5)
    80010cc6:	a011                	j	80010cca <calloc+0x52>
    }
    return NULL;
    80010cc8:	4781                	li	a5,0
}
    80010cca:	853e                	mv	a0,a5
    80010ccc:	70a2                	ld	ra,40(sp)
    80010cce:	7402                	ld	s0,32(sp)
    80010cd0:	6145                	addi	sp,sp,48
    80010cd2:	8082                	ret

0000000080010cd4 <count_blocks>:

static size_t count_blocks(Block *ptr)
{
    80010cd4:	7179                	addi	sp,sp,-48
    80010cd6:	f422                	sd	s0,40(sp)
    80010cd8:	1800                	addi	s0,sp,48
    80010cda:	fca43c23          	sd	a0,-40(s0)
    size_t num = 0;
    80010cde:	fe043423          	sd	zero,-24(s0)
    while (ptr != NULL) {
    80010ce2:	a819                	j	80010cf8 <count_blocks+0x24>
        num++;
    80010ce4:	fe843783          	ld	a5,-24(s0)
    80010ce8:	0785                	addi	a5,a5,1
    80010cea:	fef43423          	sd	a5,-24(s0)
        ptr = ptr->next;
    80010cee:	fd843783          	ld	a5,-40(s0)
    80010cf2:	679c                	ld	a5,8(a5)
    80010cf4:	fcf43c23          	sd	a5,-40(s0)
    while (ptr != NULL) {
    80010cf8:	fd843783          	ld	a5,-40(s0)
    80010cfc:	f7e5                	bnez	a5,80010ce4 <count_blocks+0x10>
    }
    return num;
    80010cfe:	fe843783          	ld	a5,-24(s0)
}
    80010d02:	853e                	mv	a0,a5
    80010d04:	7422                	ld	s0,40(sp)
    80010d06:	6145                	addi	sp,sp,48
    80010d08:	8082                	ret

0000000080010d0a <heap_num_free>:
static size_t heap_num_free()
{
    80010d0a:	1141                	addi	sp,sp,-16
    80010d0c:	e406                	sd	ra,8(sp)
    80010d0e:	e022                	sd	s0,0(sp)
    80010d10:	0800                	addi	s0,sp,16
    return count_blocks(heap->free);
    80010d12:	00007797          	auipc	a5,0x7
    80010d16:	31678793          	addi	a5,a5,790 # 80018028 <heap>
    80010d1a:	639c                	ld	a5,0(a5)
    80010d1c:	639c                	ld	a5,0(a5)
    80010d1e:	853e                	mv	a0,a5
    80010d20:	fb5ff0ef          	jal	ra,80010cd4 <count_blocks>
    80010d24:	87aa                	mv	a5,a0
}
    80010d26:	853e                	mv	a0,a5
    80010d28:	60a2                	ld	ra,8(sp)
    80010d2a:	6402                	ld	s0,0(sp)
    80010d2c:	0141                	addi	sp,sp,16
    80010d2e:	8082                	ret

0000000080010d30 <heap_num_used>:
static size_t heap_num_used()
{
    80010d30:	1141                	addi	sp,sp,-16
    80010d32:	e406                	sd	ra,8(sp)
    80010d34:	e022                	sd	s0,0(sp)
    80010d36:	0800                	addi	s0,sp,16
    return count_blocks(heap->used);
    80010d38:	00007797          	auipc	a5,0x7
    80010d3c:	2f078793          	addi	a5,a5,752 # 80018028 <heap>
    80010d40:	639c                	ld	a5,0(a5)
    80010d42:	679c                	ld	a5,8(a5)
    80010d44:	853e                	mv	a0,a5
    80010d46:	f8fff0ef          	jal	ra,80010cd4 <count_blocks>
    80010d4a:	87aa                	mv	a5,a0
}
    80010d4c:	853e                	mv	a0,a5
    80010d4e:	60a2                	ld	ra,8(sp)
    80010d50:	6402                	ld	s0,0(sp)
    80010d52:	0141                	addi	sp,sp,16
    80010d54:	8082                	ret

0000000080010d56 <heap_num_fresh>:
static size_t heap_num_fresh()
{
    80010d56:	1141                	addi	sp,sp,-16
    80010d58:	e406                	sd	ra,8(sp)
    80010d5a:	e022                	sd	s0,0(sp)
    80010d5c:	0800                	addi	s0,sp,16
    return count_blocks(heap->fresh);
    80010d5e:	00007797          	auipc	a5,0x7
    80010d62:	2ca78793          	addi	a5,a5,714 # 80018028 <heap>
    80010d66:	639c                	ld	a5,0(a5)
    80010d68:	6b9c                	ld	a5,16(a5)
    80010d6a:	853e                	mv	a0,a5
    80010d6c:	f69ff0ef          	jal	ra,80010cd4 <count_blocks>
    80010d70:	87aa                	mv	a5,a0
}
    80010d72:	853e                	mv	a0,a5
    80010d74:	60a2                	ld	ra,8(sp)
    80010d76:	6402                	ld	s0,0(sp)
    80010d78:	0141                	addi	sp,sp,16
    80010d7a:	8082                	ret

0000000080010d7c <heap_check>:
static bool heap_check()
{
    80010d7c:	1101                	addi	sp,sp,-32
    80010d7e:	ec06                	sd	ra,24(sp)
    80010d80:	e822                	sd	s0,16(sp)
    80010d82:	e426                	sd	s1,8(sp)
    80010d84:	1000                	addi	s0,sp,32
    return heap_max_blocks == heap_num_free() + heap_num_used() + heap_num_fresh();
    80010d86:	f85ff0ef          	jal	ra,80010d0a <heap_num_free>
    80010d8a:	84aa                	mv	s1,a0
    80010d8c:	fa5ff0ef          	jal	ra,80010d30 <heap_num_used>
    80010d90:	87aa                	mv	a5,a0
    80010d92:	94be                	add	s1,s1,a5
    80010d94:	fc3ff0ef          	jal	ra,80010d56 <heap_num_fresh>
    80010d98:	87aa                	mv	a5,a0
    80010d9a:	00f48733          	add	a4,s1,a5
    80010d9e:	00007797          	auipc	a5,0x7
    80010da2:	2aa78793          	addi	a5,a5,682 # 80018048 <heap_max_blocks>
    80010da6:	639c                	ld	a5,0(a5)
    80010da8:	40f707b3          	sub	a5,a4,a5
    80010dac:	0017b793          	seqz	a5,a5
    80010db0:	0ff7f793          	andi	a5,a5,255
}
    80010db4:	853e                	mv	a0,a5
    80010db6:	60e2                	ld	ra,24(sp)
    80010db8:	6442                	ld	s0,16(sp)
    80010dba:	64a2                	ld	s1,8(sp)
    80010dbc:	6105                	addi	sp,sp,32
    80010dbe:	8082                	ret

0000000080010dc0 <heap_print_stats>:

void heap_print_stats(void)
{
    80010dc0:	7179                	addi	sp,sp,-48
    80010dc2:	f406                	sd	ra,40(sp)
    80010dc4:	f022                	sd	s0,32(sp)
    80010dc6:	ec26                	sd	s1,24(sp)
    80010dc8:	e84a                	sd	s2,16(sp)
    80010dca:	e44e                	sd	s3,8(sp)
    80010dcc:	1800                	addi	s0,sp,48
    debugf(
    80010dce:	f3dff0ef          	jal	ra,80010d0a <heap_num_free>
    80010dd2:	84aa                	mv	s1,a0
    80010dd4:	f5dff0ef          	jal	ra,80010d30 <heap_num_used>
    80010dd8:	892a                	mv	s2,a0
    80010dda:	f7dff0ef          	jal	ra,80010d56 <heap_num_fresh>
    80010dde:	89aa                	mv	s3,a0
        "HEAP\n~~~~\nFree blocks:    %lu\nUsed blocks:    %lu\nFresh blocks:   %lu\nHeap "
        "check:     %s\n",
        heap_num_free(), heap_num_used(), heap_num_fresh(), heap_check() ? "good" : "bad");
    80010de0:	f9dff0ef          	jal	ra,80010d7c <heap_check>
    80010de4:	87aa                	mv	a5,a0
    debugf(
    80010de6:	c791                	beqz	a5,80010df2 <heap_print_stats+0x32>
    80010de8:	00008797          	auipc	a5,0x8
    80010dec:	2c078793          	addi	a5,a5,704 # 800190a8 <SYSCALLS+0xa8>
    80010df0:	a029                	j	80010dfa <heap_print_stats+0x3a>
    80010df2:	00008797          	auipc	a5,0x8
    80010df6:	2be78793          	addi	a5,a5,702 # 800190b0 <SYSCALLS+0xb0>
    80010dfa:	873e                	mv	a4,a5
    80010dfc:	86ce                	mv	a3,s3
    80010dfe:	864a                	mv	a2,s2
    80010e00:	85a6                	mv	a1,s1
    80010e02:	00008517          	auipc	a0,0x8
    80010e06:	2b650513          	addi	a0,a0,694 # 800190b8 <SYSCALLS+0xb8>
    80010e0a:	2d5000ef          	jal	ra,800118de <debugf>
}
    80010e0e:	0001                	nop
    80010e10:	70a2                	ld	ra,40(sp)
    80010e12:	7402                	ld	s0,32(sp)
    80010e14:	64e2                	ld	s1,24(sp)
    80010e16:	6942                	ld	s2,16(sp)
    80010e18:	69a2                	ld	s3,8(sp)
    80010e1a:	6145                	addi	sp,sp,48
    80010e1c:	8082                	ret

0000000080010e1e <kmalloc>:
void *kmalloc(size_t sz)
{
    80010e1e:	1101                	addi	sp,sp,-32
    80010e20:	ec06                	sd	ra,24(sp)
    80010e22:	e822                	sd	s0,16(sp)
    80010e24:	1000                	addi	s0,sp,32
    80010e26:	fea43423          	sd	a0,-24(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kmalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return alloc(sz);
    80010e2a:	fe843503          	ld	a0,-24(s0)
    80010e2e:	e19ff0ef          	jal	ra,80010c46 <alloc>
    80010e32:	87aa                	mv	a5,a0
}
    80010e34:	853e                	mv	a0,a5
    80010e36:	60e2                	ld	ra,24(sp)
    80010e38:	6442                	ld	s0,16(sp)
    80010e3a:	6105                	addi	sp,sp,32
    80010e3c:	8082                	ret

0000000080010e3e <kcalloc>:
void *kcalloc(size_t n, size_t sz)
{
    80010e3e:	1101                	addi	sp,sp,-32
    80010e40:	ec06                	sd	ra,24(sp)
    80010e42:	e822                	sd	s0,16(sp)
    80010e44:	1000                	addi	s0,sp,32
    80010e46:	fea43423          	sd	a0,-24(s0)
    80010e4a:	feb43023          	sd	a1,-32(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kcalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return calloc(n, sz);
    80010e4e:	fe043583          	ld	a1,-32(s0)
    80010e52:	fe843503          	ld	a0,-24(s0)
    80010e56:	e23ff0ef          	jal	ra,80010c78 <calloc>
    80010e5a:	87aa                	mv	a5,a0
}
    80010e5c:	853e                	mv	a0,a5
    80010e5e:	60e2                	ld	ra,24(sp)
    80010e60:	6442                	ld	s0,16(sp)
    80010e62:	6105                	addi	sp,sp,32
    80010e64:	8082                	ret

0000000080010e66 <kfree>:
void kfree(void *m)
{
    80010e66:	1101                	addi	sp,sp,-32
    80010e68:	ec06                	sd	ra,24(sp)
    80010e6a:	e822                	sd	s0,16(sp)
    80010e6c:	1000                	addi	s0,sp,32
    80010e6e:	fea43423          	sd	a0,-24(s0)
    if (m != NULL) {
    80010e72:	fe843783          	ld	a5,-24(s0)
    80010e76:	c789                	beqz	a5,80010e80 <kfree+0x1a>
        free(m);
    80010e78:	fe843503          	ld	a0,-24(s0)
    80010e7c:	ac9ff0ef          	jal	ra,80010944 <free>
    }
#ifdef DEBUG_KMALLOC
    debugf("[kfree]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
}
    80010e80:	0001                	nop
    80010e82:	60e2                	ld	ra,24(sp)
    80010e84:	6442                	ld	s0,16(sp)
    80010e86:	6105                	addi	sp,sp,32
    80010e88:	8082                	ret

0000000080010e8a <heap_init>:

void heap_init(void)
{
    80010e8a:	1101                	addi	sp,sp,-32
    80010e8c:	ec06                	sd	ra,24(sp)
    80010e8e:	e822                	sd	s0,16(sp)
    80010e90:	1000                	addi	s0,sp,32
#ifdef DEBUG_HEAP
    debugf("[heap_init]: Prior to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif
    void *start = page_znalloc(KERNEL_HEAP_PAGES);
    80010e92:	6505                	lui	a0,0x1
    80010e94:	620010ef          	jal	ra,800124b4 <page_znalloc>
    80010e98:	fea43423          	sd	a0,-24(s0)
    debugf("[heap_init]: Heap start at 0x%08lx\n", start);
    debugf("[heap_init]: After to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif

    mmu_map_range(kernel_mmu_table, KERNEL_HEAP_START_VADDR, KERNEL_HEAP_END_VADDR, (uint64_t)start,
    80010e9c:	00007797          	auipc	a5,0x7
    80010ea0:	16478793          	addi	a5,a5,356 # 80018000 <kernel_mmu_table>
    80010ea4:	6388                	ld	a0,0(a5)
    80010ea6:	fe843683          	ld	a3,-24(s0)
    80010eaa:	4799                	li	a5,6
    80010eac:	4701                	li	a4,0
    80010eae:	00e08637          	lui	a2,0xe08
    80010eb2:	7f760613          	addi	a2,a2,2039 # e087f7 <i+0xe087d7>
    80010eb6:	0636                	slli	a2,a2,0xd
    80010eb8:	00e085b7          	lui	a1,0xe08
    80010ebc:	15dd                	addi	a1,a1,-9
    80010ebe:	05b6                	slli	a1,a1,0xd
    80010ec0:	cf8ff0ef          	jal	ra,800103b8 <mmu_map_range>
                  MMU_LEVEL_4K, PB_READ | PB_WRITE);
    init((void *)KERNEL_HEAP_START_VADDR, (void *)KERNEL_HEAP_END_VADDR, KERNEL_HEAP_PAGES / 4, 16,
    80010ec4:	4721                	li	a4,8
    80010ec6:	46c1                	li	a3,16
    80010ec8:	40000613          	li	a2,1024
    80010ecc:	00e087b7          	lui	a5,0xe08
    80010ed0:	7f778793          	addi	a5,a5,2039 # e087f7 <i+0xe087d7>
    80010ed4:	00d79593          	slli	a1,a5,0xd
    80010ed8:	00e087b7          	lui	a5,0xe08
    80010edc:	17dd                	addi	a5,a5,-9
    80010ede:	00d79513          	slli	a0,a5,0xd
    80010ee2:	94bff0ef          	jal	ra,8001082c <init>
         8);

}
    80010ee6:	0001                	nop
    80010ee8:	60e2                	ld	ra,24(sp)
    80010eea:	6442                	ld	s0,16(sp)
    80010eec:	6105                	addi	sp,sp,32
    80010eee:	8082                	ret

0000000080010ef0 <init_systems>:
// the kernel.
// Defined in src/include/mmu.h
struct page_table *kernel_mmu_table;

static void init_systems(void)
{
    80010ef0:	1141                	addi	sp,sp,-16
    80010ef2:	e406                	sd	ra,8(sp)
    80010ef4:	e022                	sd	s0,0(sp)
    80010ef6:	0800                	addi	s0,sp,16
    void plic_init(void);
    plic_init();
    80010ef8:	783000ef          	jal	ra,80011e7a <plic_init>
    void page_init(void);
    page_init();
    80010efc:	254010ef          	jal	ra,80012150 <page_init>
    pci_init();
#endif
#ifdef USE_VIRTIO
    virtio_init();
#endif
}
    80010f00:	0001                	nop
    80010f02:	60a2                	ld	ra,8(sp)
    80010f04:	6402                	ld	s0,0(sp)
    80010f06:	0141                	addi	sp,sp,16
    80010f08:	8082                	ret

0000000080010f0a <main>:
static const char *hart_status_values[] = {"NOT PRESENT", "STOPPED", "STARTING", "RUNNING"};
#ifdef RUN_INTERNAL_CONSOLE
static void console(void);
#endif
void main(unsigned int hart)
{
    80010f0a:	7179                	addi	sp,sp,-48
    80010f0c:	f406                	sd	ra,40(sp)
    80010f0e:	f022                	sd	s0,32(sp)
    80010f10:	1800                	addi	s0,sp,48
    80010f12:	87aa                	mv	a5,a0
    80010f14:	fcf42e23          	sw	a5,-36(s0)
    // Initialize the page allocator
    // Allocate and zero the kernel's page table.

    // Kind of neat to see our memory mappings to ensure they make sense.
    logf(LOG_INFO, "[[ MEMORY MAPPINGS ]]\n");
    80010f18:	00008597          	auipc	a1,0x8
    80010f1c:	23058593          	addi	a1,a1,560 # 80019148 <SYSCALLS+0x148>
    80010f20:	4511                	li	a0,4
    80010f22:	15f000ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  [TEXT]  : 0x%08lx -> 0x%08lx\n", sym_start(text), sym_end(text));
    80010f26:	fffff797          	auipc	a5,0xfffff
    80010f2a:	0da78793          	addi	a5,a5,218 # 80010000 <_memory_start>
    80010f2e:	00005717          	auipc	a4,0x5
    80010f32:	44470713          	addi	a4,a4,1092 # 80016372 <_text_end>
    80010f36:	86ba                	mv	a3,a4
    80010f38:	863e                	mv	a2,a5
    80010f3a:	00008597          	auipc	a1,0x8
    80010f3e:	22658593          	addi	a1,a1,550 # 80019160 <SYSCALLS+0x160>
    80010f42:	4511                	li	a0,4
    80010f44:	13d000ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  [BSS]   : 0x%08lx -> 0x%08lx\n", sym_start(bss), sym_end(bss));
    80010f48:	00007797          	auipc	a5,0x7
    80010f4c:	0b878793          	addi	a5,a5,184 # 80018000 <kernel_mmu_table>
    80010f50:	00007717          	auipc	a4,0x7
    80010f54:	10870713          	addi	a4,a4,264 # 80018058 <_bss_end>
    80010f58:	86ba                	mv	a3,a4
    80010f5a:	863e                	mv	a2,a5
    80010f5c:	00008597          	auipc	a1,0x8
    80010f60:	22458593          	addi	a1,a1,548 # 80019180 <SYSCALLS+0x180>
    80010f64:	4511                	li	a0,4
    80010f66:	11b000ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  [RODATA]: 0x%08lx -> 0x%08lx\n", sym_start(rodata), sym_end(rodata));
    80010f6a:	00008797          	auipc	a5,0x8
    80010f6e:	09678793          	addi	a5,a5,150 # 80019000 <SYSCALLS>
    80010f72:	00009717          	auipc	a4,0x9
    80010f76:	23670713          	addi	a4,a4,566 # 8001a1a8 <NUM_SYSCALLS>
    80010f7a:	86ba                	mv	a3,a4
    80010f7c:	863e                	mv	a2,a5
    80010f7e:	00008597          	auipc	a1,0x8
    80010f82:	22258593          	addi	a1,a1,546 # 800191a0 <SYSCALLS+0x1a0>
    80010f86:	4511                	li	a0,4
    80010f88:	0f9000ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  [DATA]  : 0x%08lx -> 0x%08lx\n", sym_start(data), sym_end(data));
    80010f8c:	0000a797          	auipc	a5,0xa
    80010f90:	07478793          	addi	a5,a5,116 # 8001b000 <k_log_level>
    80010f94:	0000a717          	auipc	a4,0xa
    80010f98:	09470713          	addi	a4,a4,148 # 8001b028 <_data_end>
    80010f9c:	86ba                	mv	a3,a4
    80010f9e:	863e                	mv	a2,a5
    80010fa0:	00008597          	auipc	a1,0x8
    80010fa4:	22058593          	addi	a1,a1,544 # 800191c0 <SYSCALLS+0x1c0>
    80010fa8:	4511                	li	a0,4
    80010faa:	0d7000ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  [STACK] : 0x%08lx -> 0x%08lx\n", sym_start(stack), sym_end(stack));
    80010fae:	0000b797          	auipc	a5,0xb
    80010fb2:	05278793          	addi	a5,a5,82 # 8001c000 <_stack_start>
    80010fb6:	00013717          	auipc	a4,0x13
    80010fba:	04a70713          	addi	a4,a4,74 # 80024000 <_heap_start>
    80010fbe:	86ba                	mv	a3,a4
    80010fc0:	863e                	mv	a2,a5
    80010fc2:	00008597          	auipc	a1,0x8
    80010fc6:	21e58593          	addi	a1,a1,542 # 800191e0 <SYSCALLS+0x1e0>
    80010fca:	4511                	li	a0,4
    80010fcc:	0b5000ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  [HEAP]  : 0x%08lx -> 0x%08lx\n", sym_start(heap), sym_end(heap));
    80010fd0:	00013797          	auipc	a5,0x13
    80010fd4:	03078793          	addi	a5,a5,48 # 80024000 <_heap_start>
    80010fd8:	07fff717          	auipc	a4,0x7fff
    80010fdc:	02870713          	addi	a4,a4,40 # 88010000 <_heap_end>
    80010fe0:	86ba                	mv	a3,a4
    80010fe2:	863e                	mv	a2,a5
    80010fe4:	00008597          	auipc	a1,0x8
    80010fe8:	21c58593          	addi	a1,a1,540 # 80019200 <SYSCALLS+0x200>
    80010fec:	4511                	li	a0,4
    80010fee:	093000ef          	jal	ra,80011880 <logf>

    logf(LOG_INFO, "[[ HART MAPPINGS ]]\n");
    80010ff2:	00008597          	auipc	a1,0x8
    80010ff6:	22e58593          	addi	a1,a1,558 # 80019220 <SYSCALLS+0x220>
    80010ffa:	4511                	li	a0,4
    80010ffc:	085000ef          	jal	ra,80011880 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80011000:	fe042623          	sw	zero,-20(s0)
    80011004:	a8bd                	j	80011082 <main+0x178>
        if (i == hart) {
    80011006:	fec42703          	lw	a4,-20(s0)
    8001100a:	fdc42783          	lw	a5,-36(s0)
    8001100e:	2701                	sext.w	a4,a4
    80011010:	2781                	sext.w	a5,a5
    80011012:	02f71b63          	bne	a4,a5,80011048 <main+0x13e>
            logf(LOG_INFO, "  [HART#%d]: %s (this HART).\n", i, hart_status_values[sbi_hart_get_status(i)]);
    80011016:	fec42783          	lw	a5,-20(s0)
    8001101a:	853e                	mv	a0,a5
    8001101c:	21d000ef          	jal	ra,80011a38 <sbi_hart_get_status>
    80011020:	87aa                	mv	a5,a0
    80011022:	0000a717          	auipc	a4,0xa
    80011026:	fe670713          	addi	a4,a4,-26 # 8001b008 <hart_status_values>
    8001102a:	078e                	slli	a5,a5,0x3
    8001102c:	97ba                	add	a5,a5,a4
    8001102e:	6398                	ld	a4,0(a5)
    80011030:	fec42783          	lw	a5,-20(s0)
    80011034:	86ba                	mv	a3,a4
    80011036:	863e                	mv	a2,a5
    80011038:	00008597          	auipc	a1,0x8
    8001103c:	20058593          	addi	a1,a1,512 # 80019238 <SYSCALLS+0x238>
    80011040:	4511                	li	a0,4
    80011042:	03f000ef          	jal	ra,80011880 <logf>
    80011046:	a80d                	j	80011078 <main+0x16e>
        }
        else {
            logf(LOG_INFO, "  [HART#%d]: %s.\n", i, hart_status_values[sbi_hart_get_status(i)]);
    80011048:	fec42783          	lw	a5,-20(s0)
    8001104c:	853e                	mv	a0,a5
    8001104e:	1eb000ef          	jal	ra,80011a38 <sbi_hart_get_status>
    80011052:	87aa                	mv	a5,a0
    80011054:	0000a717          	auipc	a4,0xa
    80011058:	fb470713          	addi	a4,a4,-76 # 8001b008 <hart_status_values>
    8001105c:	078e                	slli	a5,a5,0x3
    8001105e:	97ba                	add	a5,a5,a4
    80011060:	6398                	ld	a4,0(a5)
    80011062:	fec42783          	lw	a5,-20(s0)
    80011066:	86ba                	mv	a3,a4
    80011068:	863e                	mv	a2,a5
    8001106a:	00008597          	auipc	a1,0x8
    8001106e:	1ee58593          	addi	a1,a1,494 # 80019258 <SYSCALLS+0x258>
    80011072:	4511                	li	a0,4
    80011074:	00d000ef          	jal	ra,80011880 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80011078:	fec42783          	lw	a5,-20(s0)
    8001107c:	2785                	addiw	a5,a5,1
    8001107e:	fef42623          	sw	a5,-20(s0)
    80011082:	fec42783          	lw	a5,-20(s0)
    80011086:	0007871b          	sext.w	a4,a5
    8001108a:	478d                	li	a5,3
    8001108c:	f6e7fde3          	bgeu	a5,a4,80011006 <main+0xfc>
        }
    }

    struct page_table *pt    = mmu_table_create();
    80011090:	a20ff0ef          	jal	ra,800102b0 <mmu_table_create>
    80011094:	fea43023          	sd	a0,-32(s0)
    kernel_mmu_table = pt;
    80011098:	00007797          	auipc	a5,0x7
    8001109c:	f6878793          	addi	a5,a5,-152 # 80018000 <kernel_mmu_table>
    800110a0:	fe043703          	ld	a4,-32(s0)
    800110a4:	e398                	sd	a4,0(a5)
    // Map memory segments for our kernel
    mmu_map_range(pt, sym_start(text), sym_end(heap), sym_start(text), MMU_LEVEL_1G,
    800110a6:	fffff597          	auipc	a1,0xfffff
    800110aa:	f5a58593          	addi	a1,a1,-166 # 80010000 <_memory_start>
    800110ae:	07fff617          	auipc	a2,0x7fff
    800110b2:	f5260613          	addi	a2,a2,-174 # 88010000 <_heap_end>
    800110b6:	fffff697          	auipc	a3,0xfffff
    800110ba:	f4a68693          	addi	a3,a3,-182 # 80010000 <_memory_start>
    800110be:	47b9                	li	a5,14
    800110c0:	4709                	li	a4,2
    800110c2:	fe043503          	ld	a0,-32(s0)
    800110c6:	af2ff0ef          	jal	ra,800103b8 <mmu_map_range>
                  PB_READ | PB_WRITE | PB_EXECUTE);
    // PLIC
    mmu_map_range(pt, 0x0C000000, 0x0C2FFFFF, 0x0C000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    800110ca:	4799                	li	a5,6
    800110cc:	4705                	li	a4,1
    800110ce:	0c0006b7          	lui	a3,0xc000
    800110d2:	0c300637          	lui	a2,0xc300
    800110d6:	167d                	addi	a2,a2,-1
    800110d8:	0c0005b7          	lui	a1,0xc000
    800110dc:	fe043503          	ld	a0,-32(s0)
    800110e0:	ad8ff0ef          	jal	ra,800103b8 <mmu_map_range>
    // PCIe ECAM
    mmu_map_range(pt, 0x30000000, 0x30FFFFFF, 0x30000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    800110e4:	4799                	li	a5,6
    800110e6:	4705                	li	a4,1
    800110e8:	300006b7          	lui	a3,0x30000
    800110ec:	31000637          	lui	a2,0x31000
    800110f0:	167d                	addi	a2,a2,-1
    800110f2:	300005b7          	lui	a1,0x30000
    800110f6:	fe043503          	ld	a0,-32(s0)
    800110fa:	abeff0ef          	jal	ra,800103b8 <mmu_map_range>
    // PCIe MMIO
    mmu_map_range(pt, 0x40000000, 0x4FFFFFFF, 0x40000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    800110fe:	4799                	li	a5,6
    80011100:	4705                	li	a4,1
    80011102:	400006b7          	lui	a3,0x40000
    80011106:	50000637          	lui	a2,0x50000
    8001110a:	167d                	addi	a2,a2,-1
    8001110c:	400005b7          	lui	a1,0x40000
    80011110:	fe043503          	ld	a0,-32(s0)
    80011114:	aa4ff0ef          	jal	ra,800103b8 <mmu_map_range>

    // MMU is turned on here.

    // Initialize all submodules here, including PCI, VirtIO, Heap, etc.
    // Many will require the MMU, so write those functions first.
    init_systems();
    80011118:	dd9ff0ef          	jal	ra,80010ef0 <init_systems>

    // Now that all submodules are initialized, you need to schedule the init process
    // and the idle processes for each HART.
    logf(LOG_INFO, "Congratulations! You made it to the OS! Going back to sleep.\n");
    8001111c:	00008597          	auipc	a1,0x8
    80011120:	15458593          	addi	a1,a1,340 # 80019270 <SYSCALLS+0x270>
    80011124:	4511                	li	a0,4
    80011126:	75a000ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, 
    8001112a:	00008597          	auipc	a1,0x8
    8001112e:	18658593          	addi	a1,a1,390 # 800192b0 <SYSCALLS+0x2b0>
    80011132:	4511                	li	a0,4
    80011134:	74c000ef          	jal	ra,80011880 <logf>
        "The logf function in the OS uses sbi_putchar(), so this means ECALLs from S-mode are "
        "working!\n");
    logf(LOG_INFO, 
    80011138:	00008597          	auipc	a1,0x8
    8001113c:	1d858593          	addi	a1,a1,472 # 80019310 <SYSCALLS+0x310>
    80011140:	4511                	li	a0,4
    80011142:	73e000ef          	jal	ra,80011880 <logf>
    // Below is just a little shell that demonstrates the sbi_getchar and
    // how the console works.

    // This is defined above main()
#ifdef RUN_INTERNAL_CONSOLE
    console();
    80011146:	004000ef          	jal	ra,8001114a <console>

000000008001114a <console>:
#endif
}

#ifdef RUN_INTERNAL_CONSOLE
ATTR_NORET static void console(void)
{
    8001114a:	7179                	addi	sp,sp,-48
    8001114c:	f406                	sd	ra,40(sp)
    8001114e:	f022                	sd	s0,32(sp)
    80011150:	1800                	addi	s0,sp,48
    const int BUFFER_SIZE = 56;
    80011152:	03800313          	li	t1,56
    80011156:	fe642423          	sw	t1,-24(s0)
    int at                = 0;
    8001115a:	fe042623          	sw	zero,-20(s0)
    char input[BUFFER_SIZE];
    8001115e:	fe842303          	lw	t1,-24(s0)
    80011162:	137d                	addi	t1,t1,-1
    80011164:	fe643023          	sd	t1,-32(s0)
    80011168:	fe842303          	lw	t1,-24(s0)
    8001116c:	881a                	mv	a6,t1
    8001116e:	4881                	li	a7,0
    80011170:	03d85313          	srli	t1,a6,0x3d
    80011174:	00389693          	slli	a3,a7,0x3
    80011178:	00d366b3          	or	a3,t1,a3
    8001117c:	00381613          	slli	a2,a6,0x3
    80011180:	fe842683          	lw	a3,-24(s0)
    80011184:	8536                	mv	a0,a3
    80011186:	4581                	li	a1,0
    80011188:	03d55693          	srli	a3,a0,0x3d
    8001118c:	00359793          	slli	a5,a1,0x3
    80011190:	8fd5                	or	a5,a5,a3
    80011192:	00351713          	slli	a4,a0,0x3
    80011196:	fe842783          	lw	a5,-24(s0)
    8001119a:	07bd                	addi	a5,a5,15
    8001119c:	8391                	srli	a5,a5,0x4
    8001119e:	0792                	slli	a5,a5,0x4
    800111a0:	40f10133          	sub	sp,sp,a5
    800111a4:	878a                	mv	a5,sp
    800111a6:	00078793          	mv	a5,a5
    800111aa:	fcf43c23          	sd	a5,-40(s0)
    logf(LOG_TEXT, "> ");
    800111ae:	00008597          	auipc	a1,0x8
    800111b2:	1c258593          	addi	a1,a1,450 # 80019370 <SYSCALLS+0x370>
    800111b6:	4541                	li	a0,16
    800111b8:	6c8000ef          	jal	ra,80011880 <logf>
    do {
        char c;
        // Recall that sbi_getchar() will return -1, 0xff, 255
        // if the receiver is empty.
        if ((c = sbi_getchar()) != 0xff) {
    800111bc:	05d000ef          	jal	ra,80011a18 <sbi_getchar>
    800111c0:	87aa                	mv	a5,a0
    800111c2:	fcf40ba3          	sb	a5,-41(s0)
    800111c6:	fd744783          	lbu	a5,-41(s0)
    800111ca:	0ff7f713          	andi	a4,a5,255
    800111ce:	0ff00793          	li	a5,255
    800111d2:	22f70263          	beq	a4,a5,800113f6 <console+0x2ac>
            if (c == '\r' || c == '\n') {
    800111d6:	fd744783          	lbu	a5,-41(s0)
    800111da:	0ff7f713          	andi	a4,a5,255
    800111de:	47b5                	li	a5,13
    800111e0:	00f70963          	beq	a4,a5,800111f2 <console+0xa8>
    800111e4:	fd744783          	lbu	a5,-41(s0)
    800111e8:	0ff7f713          	andi	a4,a5,255
    800111ec:	47a9                	li	a5,10
    800111ee:	0cf71c63          	bne	a4,a5,800112c6 <console+0x17c>
                if (at > 0) {
    800111f2:	fec42783          	lw	a5,-20(s0)
    800111f6:	2781                	sext.w	a5,a5
    800111f8:	0af05f63          	blez	a5,800112b6 <console+0x16c>
                    input[at] = '\0';
    800111fc:	fd843703          	ld	a4,-40(s0)
    80011200:	fec42783          	lw	a5,-20(s0)
    80011204:	97ba                	add	a5,a5,a4
    80011206:	00078023          	sb	zero,0(a5)
                    if (!strcmp(input, "quit")) {
    8001120a:	00008597          	auipc	a1,0x8
    8001120e:	16e58593          	addi	a1,a1,366 # 80019378 <SYSCALLS+0x378>
    80011212:	fd843503          	ld	a0,-40(s0)
    80011216:	7ad030ef          	jal	ra,800151c2 <strcmp>
    8001121a:	87aa                	mv	a5,a0
    8001121c:	eb99                	bnez	a5,80011232 <console+0xe8>
                        logf(LOG_TEXT, "\nShutting down...\n\n");
    8001121e:	00008597          	auipc	a1,0x8
    80011222:	16258593          	addi	a1,a1,354 # 80019380 <SYSCALLS+0x380>
    80011226:	4541                	li	a0,16
    80011228:	658000ef          	jal	ra,80011880 <logf>
                        sbi_poweroff();
    8001122c:	09d000ef          	jal	ra,80011ac8 <sbi_poweroff>
    80011230:	a049                	j	800112b2 <console+0x168>
                    }
                    else if (!strcmp(input, "fatal")) {
    80011232:	00008597          	auipc	a1,0x8
    80011236:	16658593          	addi	a1,a1,358 # 80019398 <SYSCALLS+0x398>
    8001123a:	fd843503          	ld	a0,-40(s0)
    8001123e:	785030ef          	jal	ra,800151c2 <strcmp>
    80011242:	87aa                	mv	a5,a0
    80011244:	eb95                	bnez	a5,80011278 <console+0x12e>
                        logf(LOG_TEXT, "\n");
    80011246:	00008597          	auipc	a1,0x8
    8001124a:	15a58593          	addi	a1,a1,346 # 800193a0 <SYSCALLS+0x3a0>
    8001124e:	4541                	li	a0,16
    80011250:	630000ef          	jal	ra,80011880 <logf>
                        fatalf("Testing fatal error @ %lu.\nHanging HART...\n", sbi_rtc_get_time());
    80011254:	119000ef          	jal	ra,80011b6c <sbi_rtc_get_time>
    80011258:	87aa                	mv	a5,a0
    8001125a:	85be                	mv	a1,a5
    8001125c:	00008517          	auipc	a0,0x8
    80011260:	14c50513          	addi	a0,a0,332 # 800193a8 <SYSCALLS+0x3a8>
    80011264:	6d0000ef          	jal	ra,80011934 <fatalf>
                        logf(LOG_ERROR, "If I get here, fatal didn't work :'(.\n");
    80011268:	00008597          	auipc	a1,0x8
    8001126c:	17058593          	addi	a1,a1,368 # 800193d8 <SYSCALLS+0x3d8>
    80011270:	4505                	li	a0,1
    80011272:	60e000ef          	jal	ra,80011880 <logf>
    80011276:	a835                	j	800112b2 <console+0x168>
                    }
                    else if (!strcmp(input, "heap")) {
    80011278:	00008597          	auipc	a1,0x8
    8001127c:	18858593          	addi	a1,a1,392 # 80019400 <SYSCALLS+0x400>
    80011280:	fd843503          	ld	a0,-40(s0)
    80011284:	73f030ef          	jal	ra,800151c2 <strcmp>
    80011288:	87aa                	mv	a5,a0
    8001128a:	eb99                	bnez	a5,800112a0 <console+0x156>
                        logf(LOG_TEXT, "\n");
    8001128c:	00008597          	auipc	a1,0x8
    80011290:	11458593          	addi	a1,a1,276 # 800193a0 <SYSCALLS+0x3a0>
    80011294:	4541                	li	a0,16
    80011296:	5ea000ef          	jal	ra,80011880 <logf>
                        void heap_print_stats(void);
                        heap_print_stats();
    8001129a:	b27ff0ef          	jal	ra,80010dc0 <heap_print_stats>
    8001129e:	a811                	j	800112b2 <console+0x168>
                    }
                    else {
                        logf(LOG_TEXT, "\nUnknown command '%s'\n", input);
    800112a0:	fd843603          	ld	a2,-40(s0)
    800112a4:	00008597          	auipc	a1,0x8
    800112a8:	16458593          	addi	a1,a1,356 # 80019408 <SYSCALLS+0x408>
    800112ac:	4541                	li	a0,16
    800112ae:	5d2000ef          	jal	ra,80011880 <logf>
                    }
                    at = 0;
    800112b2:	fe042623          	sw	zero,-20(s0)
                }
                logf(LOG_TEXT, "\n> ");
    800112b6:	00008597          	auipc	a1,0x8
    800112ba:	16a58593          	addi	a1,a1,362 # 80019420 <SYSCALLS+0x420>
    800112be:	4541                	li	a0,16
    800112c0:	5c0000ef          	jal	ra,80011880 <logf>
    800112c4:	aa2d                	j	800113fe <console+0x2b4>
            }
            else if (c == 127) {
    800112c6:	fd744783          	lbu	a5,-41(s0)
    800112ca:	0ff7f713          	andi	a4,a5,255
    800112ce:	07f00793          	li	a5,127
    800112d2:	02f71463          	bne	a4,a5,800112fa <console+0x1b0>
                // BACKSPACE
                if (at > 0) {
    800112d6:	fec42783          	lw	a5,-20(s0)
    800112da:	2781                	sext.w	a5,a5
    800112dc:	eef050e3          	blez	a5,800111bc <console+0x72>
                    logf(LOG_TEXT, "\b \b");
    800112e0:	00008597          	auipc	a1,0x8
    800112e4:	14858593          	addi	a1,a1,328 # 80019428 <SYSCALLS+0x428>
    800112e8:	4541                	li	a0,16
    800112ea:	596000ef          	jal	ra,80011880 <logf>
                    at -= 1;
    800112ee:	fec42783          	lw	a5,-20(s0)
    800112f2:	37fd                	addiw	a5,a5,-1
    800112f4:	fef42623          	sw	a5,-20(s0)
    800112f8:	b5d1                	j	800111bc <console+0x72>
                }
            }
            else if (c == 0x1B) {
    800112fa:	fd744783          	lbu	a5,-41(s0)
    800112fe:	0ff7f713          	andi	a4,a5,255
    80011302:	47ed                	li	a5,27
    80011304:	0af71663          	bne	a4,a5,800113b0 <console+0x266>
                // Escape sequence
                char esc1 = sbi_getchar();
    80011308:	710000ef          	jal	ra,80011a18 <sbi_getchar>
    8001130c:	87aa                	mv	a5,a0
    8001130e:	fcf40b23          	sb	a5,-42(s0)
                char esc2 = sbi_getchar();
    80011312:	706000ef          	jal	ra,80011a18 <sbi_getchar>
    80011316:	87aa                	mv	a5,a0
    80011318:	fcf40aa3          	sb	a5,-43(s0)
                if (esc1 == 0x5B) {
    8001131c:	fd644783          	lbu	a5,-42(s0)
    80011320:	0ff7f713          	andi	a4,a5,255
    80011324:	05b00793          	li	a5,91
    80011328:	0cf71a63          	bne	a4,a5,800113fc <console+0x2b2>
                    switch (esc2) {
    8001132c:	fd544783          	lbu	a5,-43(s0)
    80011330:	2781                	sext.w	a5,a5
    80011332:	86be                	mv	a3,a5
    80011334:	04400713          	li	a4,68
    80011338:	06e68463          	beq	a3,a4,800113a0 <console+0x256>
    8001133c:	86be                	mv	a3,a5
    8001133e:	04400713          	li	a4,68
    80011342:	e6d74de3          	blt	a4,a3,800111bc <console+0x72>
    80011346:	86be                	mv	a3,a5
    80011348:	04300713          	li	a4,67
    8001134c:	04e68263          	beq	a3,a4,80011390 <console+0x246>
    80011350:	86be                	mv	a3,a5
    80011352:	04300713          	li	a4,67
    80011356:	e6d743e3          	blt	a4,a3,800111bc <console+0x72>
    8001135a:	86be                	mv	a3,a5
    8001135c:	04100713          	li	a4,65
    80011360:	00e68863          	beq	a3,a4,80011370 <console+0x226>
    80011364:	873e                	mv	a4,a5
    80011366:	04200793          	li	a5,66
    8001136a:	00f70b63          	beq	a4,a5,80011380 <console+0x236>
    8001136e:	a841                	j	800113fe <console+0x2b4>
                        case 0x41:
                            logf(LOG_INFO, "UP\n");
    80011370:	00008597          	auipc	a1,0x8
    80011374:	0c058593          	addi	a1,a1,192 # 80019430 <SYSCALLS+0x430>
    80011378:	4511                	li	a0,4
    8001137a:	506000ef          	jal	ra,80011880 <logf>
                            break;
    8001137e:	a041                	j	800113fe <console+0x2b4>
                        case 0x42:
                            logf(LOG_INFO, "DOWN\n");
    80011380:	00008597          	auipc	a1,0x8
    80011384:	0b858593          	addi	a1,a1,184 # 80019438 <SYSCALLS+0x438>
    80011388:	4511                	li	a0,4
    8001138a:	4f6000ef          	jal	ra,80011880 <logf>
                            break;
    8001138e:	a885                	j	800113fe <console+0x2b4>
                        case 0x43:
                            logf(LOG_INFO, "RIGHT\n");
    80011390:	00008597          	auipc	a1,0x8
    80011394:	0b058593          	addi	a1,a1,176 # 80019440 <SYSCALLS+0x440>
    80011398:	4511                	li	a0,4
    8001139a:	4e6000ef          	jal	ra,80011880 <logf>
                            break;
    8001139e:	a085                	j	800113fe <console+0x2b4>
                        case 0x44:
                            logf(LOG_INFO, "LEFT\n");
    800113a0:	00008597          	auipc	a1,0x8
    800113a4:	0a858593          	addi	a1,a1,168 # 80019448 <SYSCALLS+0x448>
    800113a8:	4511                	li	a0,4
    800113aa:	4d6000ef          	jal	ra,80011880 <logf>
                            break;
    800113ae:	a881                	j	800113fe <console+0x2b4>
                    }
                }
            }
            else {
                if (at < (BUFFER_SIZE - 1)) {
    800113b0:	fe842783          	lw	a5,-24(s0)
    800113b4:	37fd                	addiw	a5,a5,-1
    800113b6:	0007871b          	sext.w	a4,a5
    800113ba:	fec42783          	lw	a5,-20(s0)
    800113be:	2781                	sext.w	a5,a5
    800113c0:	dee7dee3          	bge	a5,a4,800111bc <console+0x72>
                    input[at++] = c;
    800113c4:	fec42783          	lw	a5,-20(s0)
    800113c8:	0017871b          	addiw	a4,a5,1
    800113cc:	fee42623          	sw	a4,-20(s0)
    800113d0:	fd843703          	ld	a4,-40(s0)
    800113d4:	97ba                	add	a5,a5,a4
    800113d6:	fd744703          	lbu	a4,-41(s0)
    800113da:	00e78023          	sb	a4,0(a5)
                    logf(LOG_TEXT, "%c", c);
    800113de:	fd744783          	lbu	a5,-41(s0)
    800113e2:	2781                	sext.w	a5,a5
    800113e4:	863e                	mv	a2,a5
    800113e6:	00008597          	auipc	a1,0x8
    800113ea:	06a58593          	addi	a1,a1,106 # 80019450 <SYSCALLS+0x450>
    800113ee:	4541                	li	a0,16
    800113f0:	490000ef          	jal	ra,80011880 <logf>
    800113f4:	b3e1                	j	800111bc <console+0x72>
            }
        }
        else {
            // We can WFI here since interrupts are enabled
            // for the UART.
            WFI();
    800113f6:	10500073          	wfi
    800113fa:	b3c9                	j	800111bc <console+0x72>
                }
    800113fc:	0001                	nop
    do {
    800113fe:	bb7d                	j	800111bc <console+0x72>

0000000080011400 <process_new>:
#define STACK_PAGES 2
#define STACK_SIZE  (STACK_PAGES * PAGE_SIZE)
#define STACK_TOP   0xfffffffc0ffee000UL

struct process *process_new(process_mode mode)
{
    80011400:	715d                	addi	sp,sp,-80
    80011402:	e486                	sd	ra,72(sp)
    80011404:	e0a2                	sd	s0,64(sp)
    80011406:	0880                	addi	s0,sp,80
    80011408:	87aa                	mv	a5,a0
    8001140a:	faf42e23          	sw	a5,-68(s0)
    struct process *p       = (struct process *)kzalloc(sizeof(*p));
    8001140e:	29000593          	li	a1,656
    80011412:	4505                	li	a0,1
    80011414:	a2bff0ef          	jal	ra,80010e3e <kcalloc>
    80011418:	fea43023          	sd	a0,-32(s0)

    p->hart                 = -1U;
    8001141c:	fe043783          	ld	a5,-32(s0)
    80011420:	577d                	li	a4,-1
    80011422:	c3d8                	sw	a4,4(a5)
    p->ptable               = mmu_table_create();
    80011424:	e8dfe0ef          	jal	ra,800102b0 <mmu_table_create>
    80011428:	872a                	mv	a4,a0
    8001142a:	fe043783          	ld	a5,-32(s0)
    8001142e:	26e7bc23          	sd	a4,632(a5)
    p->state                = PS_WAITING;
    80011432:	fe043783          	ld	a5,-32(s0)
    80011436:	4705                	li	a4,1
    80011438:	c7d8                	sw	a4,12(a5)
    // p->pid               = fill_in_with_unique_pid

    // Set the trap frame and create all necessary structures.
    // p->frame.sepc = filled_in_by_ELF_loader
    p->frame.sstatus        = SSTATUS_SPP_BOOL(mode) | SSTATUS_FS_INITIAL | SSTATUS_SPIE;
    8001143a:	fbc42783          	lw	a5,-68(s0)
    8001143e:	2781                	sext.w	a5,a5
    80011440:	c789                	beqz	a5,8001144a <process_new+0x4a>
    80011442:	6789                	lui	a5,0x2
    80011444:	12078793          	addi	a5,a5,288 # 2120 <i+0x2100>
    80011448:	a021                	j	80011450 <process_new+0x50>
    8001144a:	6789                	lui	a5,0x2
    8001144c:	02078793          	addi	a5,a5,32 # 2020 <i+0x2000>
    80011450:	fe043703          	ld	a4,-32(s0)
    80011454:	24f73023          	sd	a5,576(a4)
    p->frame.sie            = SIE_SEIE | SIE_SSIE | SIE_STIE;
    80011458:	fe043783          	ld	a5,-32(s0)
    8001145c:	22200713          	li	a4,546
    80011460:	24e7b423          	sd	a4,584(a5)
    p->frame.satp           = SATP(p->ptable, p->pid);
    80011464:	fe043783          	ld	a5,-32(s0)
    80011468:	2787b783          	ld	a5,632(a5)
    8001146c:	00c7d713          	srli	a4,a5,0xc
    80011470:	57fd                	li	a5,-1
    80011472:	83d1                	srli	a5,a5,0x14
    80011474:	8f7d                	and	a4,a4,a5
    80011476:	fe043783          	ld	a5,-32(s0)
    8001147a:	0007d783          	lhu	a5,0(a5)
    8001147e:	17b2                	slli	a5,a5,0x2c
    80011480:	8f5d                	or	a4,a4,a5
    80011482:	57fd                	li	a5,-1
    80011484:	17fe                	slli	a5,a5,0x3f
    80011486:	8f5d                	or	a4,a4,a5
    80011488:	fe043783          	ld	a5,-32(s0)
    8001148c:	24e7b823          	sd	a4,592(a5)
    p->frame.sscratch       = (unsigned long)&p->frame;
    80011490:	fe043783          	ld	a5,-32(s0)
    80011494:	03878793          	addi	a5,a5,56
    80011498:	873e                	mv	a4,a5
    8001149a:	fe043783          	ld	a5,-32(s0)
    8001149e:	24e7bc23          	sd	a4,600(a5)
    p->frame.stvec          = trampoline_trap_start;
    800114a2:	00009797          	auipc	a5,0x9
    800114a6:	cee78793          	addi	a5,a5,-786 # 8001a190 <trampoline_trap_start>
    800114aa:	6398                	ld	a4,0(a5)
    800114ac:	fe043783          	ld	a5,-32(s0)
    800114b0:	26e7b023          	sd	a4,608(a5)
    p->frame.trap_satp      = SATP_KERNEL;
    800114b4:	00007797          	auipc	a5,0x7
    800114b8:	b4c78793          	addi	a5,a5,-1204 # 80018000 <kernel_mmu_table>
    800114bc:	639c                	ld	a5,0(a5)
    800114be:	00c7d713          	srli	a4,a5,0xc
    800114c2:	57fd                	li	a5,-1
    800114c4:	83d1                	srli	a5,a5,0x14
    800114c6:	8f7d                	and	a4,a4,a5
    800114c8:	8ffff7b7          	lui	a5,0x8ffff
    800114cc:	1782                	slli	a5,a5,0x20
    800114ce:	8f5d                	or	a4,a4,a5
    800114d0:	fe043783          	ld	a5,-32(s0)
    800114d4:	26e7b423          	sd	a4,616(a5) # ffffffff8ffff268 <_heap_end+0xffffffff07fef268>
    // p->frame.trap_stack = filled_in_by_SCHEDULER

    p->fds = vector_new_with_capacity(5);
    800114d8:	4515                	li	a0,5
    800114da:	31c040ef          	jal	ra,800157f6 <vector_new_with_capacity>
    800114de:	872a                	mv	a4,a0
    800114e0:	fe043783          	ld	a5,-32(s0)
    800114e4:	28e7b423          	sd	a4,648(a5)
    p->pages = list_new();
    800114e8:	20e030ef          	jal	ra,800146f6 <list_new>
    800114ec:	872a                	mv	a4,a0
    800114ee:	fe043783          	ld	a5,-32(s0)
    800114f2:	28e7b023          	sd	a4,640(a5)

    // We need to keep track of the stack itself in the kernel, so we can free it
    // later, but the user process will interact with the stack via the SP register.
    p->frame.xregs[XREG_SP] = STACK_TOP + STACK_SIZE;
    800114f6:	fe043783          	ld	a5,-32(s0)
    800114fa:	c0fff737          	lui	a4,0xc0fff
    800114fe:	0712                	slli	a4,a4,0x4
    80011500:	e7b8                	sd	a4,72(a5)
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    80011502:	fe043423          	sd	zero,-24(s0)
    80011506:	a085                	j	80011566 <process_new+0x166>
        void *stack = page_zalloc();
    80011508:	4505                	li	a0,1
    8001150a:	7ab000ef          	jal	ra,800124b4 <page_znalloc>
    8001150e:	fca43423          	sd	a0,-56(s0)
        list_add_ptr(p->pages, stack);
    80011512:	fe043783          	ld	a5,-32(s0)
    80011516:	2807b783          	ld	a5,640(a5)
    8001151a:	fc843703          	ld	a4,-56(s0)
    8001151e:	85ba                	mv	a1,a4
    80011520:	853e                	mv	a0,a5
    80011522:	204030ef          	jal	ra,80014726 <list_add>
        mmu_map(p->ptable, STACK_TOP + PAGE_SIZE * i, (unsigned long)stack,
    80011526:	fe043783          	ld	a5,-32(s0)
    8001152a:	2787b503          	ld	a0,632(a5)
    8001152e:	fe843783          	ld	a5,-24(s0)
    80011532:	00c79713          	slli	a4,a5,0xc
    80011536:	ffe087b7          	lui	a5,0xffe08
    8001153a:	17dd                	addi	a5,a5,-9
    8001153c:	07b6                	slli	a5,a5,0xd
    8001153e:	00f705b3          	add	a1,a4,a5
    80011542:	fc843603          	ld	a2,-56(s0)
    80011546:	fbc42783          	lw	a5,-68(s0)
    8001154a:	2781                	sext.w	a5,a5
    8001154c:	e399                	bnez	a5,80011552 <process_new+0x152>
    8001154e:	47c1                	li	a5,16
    80011550:	a011                	j	80011554 <process_new+0x154>
    80011552:	4799                	li	a5,6
    80011554:	873e                	mv	a4,a5
    80011556:	4681                	li	a3,0
    80011558:	d73fe0ef          	jal	ra,800102ca <mmu_map>
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    8001155c:	fe843783          	ld	a5,-24(s0)
    80011560:	0785                	addi	a5,a5,1
    80011562:	fef43423          	sd	a5,-24(s0)
    80011566:	fe843703          	ld	a4,-24(s0)
    8001156a:	4785                	li	a5,1
    8001156c:	f8e7fee3          	bgeu	a5,a4,80011508 <process_new+0x108>
    }

    // We need to map certain kernel portions into the user's page table. Notice
    // that the PB_USER is NOT set, but it needs to be there because we need to execute
    // the trap/start instructions while using the user's page table until we change SATP.
    unsigned long trans_trampoline_start = mmu_translate(kernel_mmu_table, trampoline_thread_start);
    80011570:	00007797          	auipc	a5,0x7
    80011574:	a9078793          	addi	a5,a5,-1392 # 80018000 <kernel_mmu_table>
    80011578:	6398                	ld	a4,0(a5)
    8001157a:	00009797          	auipc	a5,0x9
    8001157e:	bfe78793          	addi	a5,a5,-1026 # 8001a178 <trampoline_thread_start>
    80011582:	639c                	ld	a5,0(a5)
    80011584:	85be                	mv	a1,a5
    80011586:	853a                	mv	a0,a4
    80011588:	de5fe0ef          	jal	ra,8001036c <mmu_translate>
    8001158c:	fca43c23          	sd	a0,-40(s0)
    unsigned long trans_trampoline_trap  = mmu_translate(kernel_mmu_table, trampoline_trap_start);
    80011590:	00007797          	auipc	a5,0x7
    80011594:	a7078793          	addi	a5,a5,-1424 # 80018000 <kernel_mmu_table>
    80011598:	6398                	ld	a4,0(a5)
    8001159a:	00009797          	auipc	a5,0x9
    8001159e:	bf678793          	addi	a5,a5,-1034 # 8001a190 <trampoline_trap_start>
    800115a2:	639c                	ld	a5,0(a5)
    800115a4:	85be                	mv	a1,a5
    800115a6:	853a                	mv	a0,a4
    800115a8:	dc5fe0ef          	jal	ra,8001036c <mmu_translate>
    800115ac:	fca43823          	sd	a0,-48(s0)
    mmu_map(p->ptable, trampoline_thread_start, trans_trampoline_start, MMU_LEVEL_4K,
    800115b0:	fe043783          	ld	a5,-32(s0)
    800115b4:	2787b503          	ld	a0,632(a5)
    800115b8:	00009797          	auipc	a5,0x9
    800115bc:	bc078793          	addi	a5,a5,-1088 # 8001a178 <trampoline_thread_start>
    800115c0:	639c                	ld	a5,0(a5)
    800115c2:	4729                	li	a4,10
    800115c4:	4681                	li	a3,0
    800115c6:	fd843603          	ld	a2,-40(s0)
    800115ca:	85be                	mv	a1,a5
    800115cc:	cfffe0ef          	jal	ra,800102ca <mmu_map>
            PB_READ | PB_EXECUTE);
    mmu_map(p->ptable, trampoline_trap_start, trans_trampoline_trap, MMU_LEVEL_4K,
    800115d0:	fe043783          	ld	a5,-32(s0)
    800115d4:	2787b503          	ld	a0,632(a5)
    800115d8:	00009797          	auipc	a5,0x9
    800115dc:	bb878793          	addi	a5,a5,-1096 # 8001a190 <trampoline_trap_start>
    800115e0:	639c                	ld	a5,0(a5)
    800115e2:	4729                	li	a4,10
    800115e4:	4681                	li	a3,0
    800115e6:	fd043603          	ld	a2,-48(s0)
    800115ea:	85be                	mv	a1,a5
    800115ec:	cdffe0ef          	jal	ra,800102ca <mmu_map>
            PB_READ | PB_EXECUTE);

    SFENCE_ASID(p->pid);
    800115f0:	fe043783          	ld	a5,-32(s0)
    800115f4:	0007d783          	lhu	a5,0(a5)
    800115f8:	12f00073          	sfence.vma	zero,a5

    return p;
    800115fc:	fe043783          	ld	a5,-32(s0)
}
    80011600:	853e                	mv	a0,a5
    80011602:	60a6                	ld	ra,72(sp)
    80011604:	6406                	ld	s0,64(sp)
    80011606:	6161                	addi	sp,sp,80
    80011608:	8082                	ret

000000008001160a <process_free>:

int process_free(struct process *p)
{
    8001160a:	7179                	addi	sp,sp,-48
    8001160c:	f406                	sd	ra,40(sp)
    8001160e:	f022                	sd	s0,32(sp)
    80011610:	1800                	addi	s0,sp,48
    80011612:	fca43c23          	sd	a0,-40(s0)
    struct ListElem *e;
    unsigned int i;

    if (!p || !ON_HART_NONE(p)) {
    80011616:	fd843783          	ld	a5,-40(s0)
    8001161a:	cb81                	beqz	a5,8001162a <process_free+0x20>
    8001161c:	fd843783          	ld	a5,-40(s0)
    80011620:	43dc                	lw	a5,4(a5)
    80011622:	873e                	mv	a4,a5
    80011624:	57fd                	li	a5,-1
    80011626:	00f70463          	beq	a4,a5,8001162e <process_free+0x24>
        // Process is invalid or running somewhere, or this is stale.
        return -1;
    8001162a:	57fd                	li	a5,-1
    8001162c:	a8d1                	j	80011700 <process_free+0xf6>
    }

    // Free all resources allocated to the process.

    if (p->ptable) {
    8001162e:	fd843783          	ld	a5,-40(s0)
    80011632:	2787b783          	ld	a5,632(a5)
    80011636:	cf91                	beqz	a5,80011652 <process_free+0x48>
        mmu_free(p->ptable);
    80011638:	fd843783          	ld	a5,-40(s0)
    8001163c:	2787b783          	ld	a5,632(a5)
    80011640:	853e                	mv	a0,a5
    80011642:	d1bfe0ef          	jal	ra,8001035c <mmu_free>
        SFENCE_ASID(p->pid);
    80011646:	fd843783          	ld	a5,-40(s0)
    8001164a:	0007d783          	lhu	a5,0(a5)
    8001164e:	12f00073          	sfence.vma	zero,a5
    }

    if (p->pages) {
    80011652:	fd843783          	ld	a5,-40(s0)
    80011656:	2807b783          	ld	a5,640(a5)
    8001165a:	cbb9                	beqz	a5,800116b0 <process_free+0xa6>
        list_for_each(p->pages, e) {
    8001165c:	fd843783          	ld	a5,-40(s0)
    80011660:	2807b783          	ld	a5,640(a5)
    80011664:	853e                	mv	a0,a5
    80011666:	4e0030ef          	jal	ra,80014b46 <list_elem_start_ascending>
    8001166a:	fea43423          	sd	a0,-24(s0)
    8001166e:	a839                	j	8001168c <process_free+0x82>
            page_free(list_elem_value_ptr(e));
    80011670:	fe843503          	ld	a0,-24(s0)
    80011674:	532030ef          	jal	ra,80014ba6 <list_elem_value>
    80011678:	87aa                	mv	a5,a0
    8001167a:	853e                	mv	a0,a5
    8001167c:	64f000ef          	jal	ra,800124ca <page_free>
        list_for_each(p->pages, e) {
    80011680:	fe843503          	ld	a0,-24(s0)
    80011684:	50a030ef          	jal	ra,80014b8e <list_elem_prev>
    80011688:	fea43423          	sd	a0,-24(s0)
    8001168c:	fd843783          	ld	a5,-40(s0)
    80011690:	2807b783          	ld	a5,640(a5)
    80011694:	fe843583          	ld	a1,-24(s0)
    80011698:	853e                	mv	a0,a5
    8001169a:	41e030ef          	jal	ra,80014ab8 <list_elem_valid>
    8001169e:	87aa                	mv	a5,a0
    800116a0:	fbe1                	bnez	a5,80011670 <process_free+0x66>
        }
        list_free(p->pages);
    800116a2:	fd843783          	ld	a5,-40(s0)
    800116a6:	2807b783          	ld	a5,640(a5)
    800116aa:	853e                	mv	a0,a5
    800116ac:	3b4030ef          	jal	ra,80014a60 <list_free>
    }

    if (p->fds) {
    800116b0:	fd843783          	ld	a5,-40(s0)
    800116b4:	2887b783          	ld	a5,648(a5)
    800116b8:	cf9d                	beqz	a5,800116f6 <process_free+0xec>
        for (i = 0;i < vector_size(p->fds);i += 1) {
    800116ba:	fe042223          	sw	zero,-28(s0)
    800116be:	a031                	j	800116ca <process_free+0xc0>
    800116c0:	fe442783          	lw	a5,-28(s0)
    800116c4:	2785                	addiw	a5,a5,1
    800116c6:	fef42223          	sw	a5,-28(s0)
    800116ca:	fd843783          	ld	a5,-40(s0)
    800116ce:	2887b783          	ld	a5,648(a5)
    800116d2:	853e                	mv	a0,a5
    800116d4:	211040ef          	jal	ra,800160e4 <vector_size>
    800116d8:	87aa                	mv	a5,a0
    800116da:	0007871b          	sext.w	a4,a5
    800116de:	fe442783          	lw	a5,-28(s0)
    800116e2:	2781                	sext.w	a5,a5
    800116e4:	fce7eee3          	bltu	a5,a4,800116c0 <process_free+0xb6>
            // Clean up any file descriptor stuff here.
        }
        vector_free(p->fds);
    800116e8:	fd843783          	ld	a5,-40(s0)
    800116ec:	2887b783          	ld	a5,648(a5)
    800116f0:	853e                	mv	a0,a5
    800116f2:	223040ef          	jal	ra,80016114 <vector_free>
    }
    

    kfree(p);
    800116f6:	fd843503          	ld	a0,-40(s0)
    800116fa:	f6cff0ef          	jal	ra,80010e66 <kfree>

    return 0;
    800116fe:	4781                	li	a5,0
}
    80011700:	853e                	mv	a0,a5
    80011702:	70a2                	ld	ra,40(sp)
    80011704:	7402                	ld	s0,32(sp)
    80011706:	6145                	addi	sp,sp,48
    80011708:	8082                	ret

000000008001170a <process_run>:

bool process_run(struct process *p, unsigned int hart)
{
    8001170a:	7179                	addi	sp,sp,-48
    8001170c:	f406                	sd	ra,40(sp)
    8001170e:	f022                	sd	s0,32(sp)
    80011710:	1800                	addi	s0,sp,48
    80011712:	fca43c23          	sd	a0,-40(s0)
    80011716:	87ae                	mv	a5,a1
    80011718:	fcf42a23          	sw	a5,-44(s0)
    void process_asm_run(void *frame_addr);
    unsigned int me = sbi_whoami();
    8001171c:	470000ef          	jal	ra,80011b8c <sbi_whoami>
    80011720:	87aa                	mv	a5,a0
    80011722:	fef42623          	sw	a5,-20(s0)

    if (me == hart) {
    80011726:	fec42703          	lw	a4,-20(s0)
    8001172a:	fd442783          	lw	a5,-44(s0)
    8001172e:	2701                	sext.w	a4,a4
    80011730:	2781                	sext.w	a5,a5
    80011732:	00f71b63          	bne	a4,a5,80011748 <process_run+0x3e>
        process_asm_run(&p->frame);
    80011736:	fd843783          	ld	a5,-40(s0)
    8001173a:	03878793          	addi	a5,a5,56
    8001173e:	853e                	mv	a0,a5
    80011740:	785020ef          	jal	ra,800146c4 <process_asm_run>
        // process_asm_run should not return, but if it does
        // something went wrong.
        return false;
    80011744:	4781                	li	a5,0
    80011746:	a815                	j	8001177a <process_run+0x70>
    }

    return sbi_hart_start(hart, trampoline_thread_start, (unsigned long)&p->frame, p->frame.satp);
    80011748:	00009797          	auipc	a5,0x9
    8001174c:	a3078793          	addi	a5,a5,-1488 # 8001a178 <trampoline_thread_start>
    80011750:	6398                	ld	a4,0(a5)
    80011752:	fd843783          	ld	a5,-40(s0)
    80011756:	03878793          	addi	a5,a5,56
    8001175a:	863e                	mv	a2,a5
    8001175c:	fd843783          	ld	a5,-40(s0)
    80011760:	2507b683          	ld	a3,592(a5)
    80011764:	fd442783          	lw	a5,-44(s0)
    80011768:	85ba                	mv	a1,a4
    8001176a:	853e                	mv	a0,a5
    8001176c:	2f8000ef          	jal	ra,80011a64 <sbi_hart_start>
    80011770:	87aa                	mv	a5,a0
    80011772:	00f037b3          	snez	a5,a5
    80011776:	0ff7f793          	andi	a5,a5,255
}
    8001177a:	853e                	mv	a0,a5
    8001177c:	70a2                	ld	ra,40(sp)
    8001177e:	7402                	ld	s0,32(sp)
    80011780:	6145                	addi	sp,sp,48
    80011782:	8082                	ret

0000000080011784 <lgprefix>:
#include <stdarg.h>
#include <csr.h>

static int k_log_level = 0xFFF;

static const char *lgprefix(log_type lt) {
    80011784:	1101                	addi	sp,sp,-32
    80011786:	ec22                	sd	s0,24(sp)
    80011788:	1000                	addi	s0,sp,32
    8001178a:	87aa                	mv	a5,a0
    8001178c:	fef42623          	sw	a5,-20(s0)
    switch (lt) {
    80011790:	fec42783          	lw	a5,-20(s0)
    80011794:	0007871b          	sext.w	a4,a5
    80011798:	47a1                	li	a5,8
    8001179a:	06f70463          	beq	a4,a5,80011802 <lgprefix+0x7e>
    8001179e:	fec42783          	lw	a5,-20(s0)
    800117a2:	0007871b          	sext.w	a4,a5
    800117a6:	47a1                	li	a5,8
    800117a8:	06e7e263          	bltu	a5,a4,8001180c <lgprefix+0x88>
    800117ac:	fec42783          	lw	a5,-20(s0)
    800117b0:	0007871b          	sext.w	a4,a5
    800117b4:	4791                	li	a5,4
    800117b6:	02f70c63          	beq	a4,a5,800117ee <lgprefix+0x6a>
    800117ba:	fec42783          	lw	a5,-20(s0)
    800117be:	0007871b          	sext.w	a4,a5
    800117c2:	4791                	li	a5,4
    800117c4:	04e7e463          	bltu	a5,a4,8001180c <lgprefix+0x88>
    800117c8:	fec42783          	lw	a5,-20(s0)
    800117cc:	0007871b          	sext.w	a4,a5
    800117d0:	4785                	li	a5,1
    800117d2:	02f70363          	beq	a4,a5,800117f8 <lgprefix+0x74>
    800117d6:	fec42783          	lw	a5,-20(s0)
    800117da:	0007871b          	sext.w	a4,a5
    800117de:	4789                	li	a5,2
    800117e0:	02f71663          	bne	a4,a5,8001180c <lgprefix+0x88>
        case LOG_DEBUG:
            return "[DEBUG]: ";
    800117e4:	00008797          	auipc	a5,0x8
    800117e8:	c7478793          	addi	a5,a5,-908 # 80019458 <SYSCALLS+0x458>
    800117ec:	a025                	j	80011814 <lgprefix+0x90>
        case LOG_INFO:
            return "[INFO]: ";
    800117ee:	00008797          	auipc	a5,0x8
    800117f2:	c7a78793          	addi	a5,a5,-902 # 80019468 <SYSCALLS+0x468>
    800117f6:	a839                	j	80011814 <lgprefix+0x90>
        case LOG_ERROR:
            return "[ERROR]: ";
    800117f8:	00008797          	auipc	a5,0x8
    800117fc:	c8078793          	addi	a5,a5,-896 # 80019478 <SYSCALLS+0x478>
    80011800:	a811                	j	80011814 <lgprefix+0x90>
        case LOG_FATAL:
            return "[FATAL]: ";
    80011802:	00008797          	auipc	a5,0x8
    80011806:	c8678793          	addi	a5,a5,-890 # 80019488 <SYSCALLS+0x488>
    8001180a:	a029                	j	80011814 <lgprefix+0x90>
        default:
            return "";
    8001180c:	00008797          	auipc	a5,0x8
    80011810:	c8c78793          	addi	a5,a5,-884 # 80019498 <SYSCALLS+0x498>
    }
}
    80011814:	853e                	mv	a0,a5
    80011816:	6462                	ld	s0,24(sp)
    80011818:	6105                	addi	sp,sp,32
    8001181a:	8082                	ret

000000008001181c <vlogf>:

static int vlogf(log_type lt, const char *fmt, va_list args)
{
    8001181c:	7179                	addi	sp,sp,-48
    8001181e:	f406                	sd	ra,40(sp)
    80011820:	f022                	sd	s0,32(sp)
    80011822:	1800                	addi	s0,sp,48
    80011824:	87aa                	mv	a5,a0
    80011826:	feb43023          	sd	a1,-32(s0)
    8001182a:	fcc43c23          	sd	a2,-40(s0)
    8001182e:	fef42623          	sw	a5,-20(s0)
    if (!(lt & k_log_level)) {
    80011832:	00009797          	auipc	a5,0x9
    80011836:	7ce78793          	addi	a5,a5,1998 # 8001b000 <k_log_level>
    8001183a:	439c                	lw	a5,0(a5)
    8001183c:	0007871b          	sext.w	a4,a5
    80011840:	fec42783          	lw	a5,-20(s0)
    80011844:	8ff9                	and	a5,a5,a4
    80011846:	2781                	sext.w	a5,a5
    80011848:	e399                	bnez	a5,8001184e <vlogf+0x32>
        return 0;
    8001184a:	4781                	li	a5,0
    8001184c:	a02d                	j	80011876 <vlogf+0x5a>
    }
    int printf(const char *fmt, ...);
    printf("%s", lgprefix(lt));
    8001184e:	fec42783          	lw	a5,-20(s0)
    80011852:	853e                	mv	a0,a5
    80011854:	f31ff0ef          	jal	ra,80011784 <lgprefix>
    80011858:	87aa                	mv	a5,a0
    8001185a:	85be                	mv	a1,a5
    8001185c:	00008517          	auipc	a0,0x8
    80011860:	c4450513          	addi	a0,a0,-956 # 800194a0 <SYSCALLS+0x4a0>
    80011864:	3e9020ef          	jal	ra,8001444c <printf>
    int vprintf_(const char *format, va_list va);
    return vprintf_(fmt, args);
    80011868:	fd843583          	ld	a1,-40(s0)
    8001186c:	fe043503          	ld	a0,-32(s0)
    80011870:	50b020ef          	jal	ra,8001457a <vprintf_>
    80011874:	87aa                	mv	a5,a0
}
    80011876:	853e                	mv	a0,a5
    80011878:	70a2                	ld	ra,40(sp)
    8001187a:	7402                	ld	s0,32(sp)
    8001187c:	6145                	addi	sp,sp,48
    8001187e:	8082                	ret

0000000080011880 <logf>:

int logf(log_type lt, const char *fmt, ...)
{
    80011880:	7159                	addi	sp,sp,-112
    80011882:	fc06                	sd	ra,56(sp)
    80011884:	f822                	sd	s0,48(sp)
    80011886:	0080                	addi	s0,sp,64
    80011888:	fcb43823          	sd	a1,-48(s0)
    8001188c:	e010                	sd	a2,0(s0)
    8001188e:	e414                	sd	a3,8(s0)
    80011890:	e818                	sd	a4,16(s0)
    80011892:	ec1c                	sd	a5,24(s0)
    80011894:	03043023          	sd	a6,32(s0)
    80011898:	03143423          	sd	a7,40(s0)
    8001189c:	87aa                	mv	a5,a0
    8001189e:	fcf42e23          	sw	a5,-36(s0)
    va_list va;
    va_start(va, fmt);
    800118a2:	03040793          	addi	a5,s0,48
    800118a6:	fcf43423          	sd	a5,-56(s0)
    800118aa:	fc843783          	ld	a5,-56(s0)
    800118ae:	fd078793          	addi	a5,a5,-48
    800118b2:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(lt, fmt, va);
    800118b6:	fe043703          	ld	a4,-32(s0)
    800118ba:	fdc42783          	lw	a5,-36(s0)
    800118be:	863a                	mv	a2,a4
    800118c0:	fd043583          	ld	a1,-48(s0)
    800118c4:	853e                	mv	a0,a5
    800118c6:	f57ff0ef          	jal	ra,8001181c <vlogf>
    800118ca:	87aa                	mv	a5,a0
    800118cc:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    800118d0:	fec42783          	lw	a5,-20(s0)
}
    800118d4:	853e                	mv	a0,a5
    800118d6:	70e2                	ld	ra,56(sp)
    800118d8:	7442                	ld	s0,48(sp)
    800118da:	6165                	addi	sp,sp,112
    800118dc:	8082                	ret

00000000800118de <debugf>:

int debugf(const char *fmt, ...)
{
    800118de:	7159                	addi	sp,sp,-112
    800118e0:	f406                	sd	ra,40(sp)
    800118e2:	f022                	sd	s0,32(sp)
    800118e4:	1800                	addi	s0,sp,48
    800118e6:	fca43c23          	sd	a0,-40(s0)
    800118ea:	e40c                	sd	a1,8(s0)
    800118ec:	e810                	sd	a2,16(s0)
    800118ee:	ec14                	sd	a3,24(s0)
    800118f0:	f018                	sd	a4,32(s0)
    800118f2:	f41c                	sd	a5,40(s0)
    800118f4:	03043823          	sd	a6,48(s0)
    800118f8:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    800118fc:	04040793          	addi	a5,s0,64
    80011900:	fcf43823          	sd	a5,-48(s0)
    80011904:	fd043783          	ld	a5,-48(s0)
    80011908:	fc878793          	addi	a5,a5,-56
    8001190c:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_DEBUG, fmt, va);
    80011910:	fe043783          	ld	a5,-32(s0)
    80011914:	863e                	mv	a2,a5
    80011916:	fd843583          	ld	a1,-40(s0)
    8001191a:	4509                	li	a0,2
    8001191c:	f01ff0ef          	jal	ra,8001181c <vlogf>
    80011920:	87aa                	mv	a5,a0
    80011922:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    80011926:	fec42783          	lw	a5,-20(s0)
}
    8001192a:	853e                	mv	a0,a5
    8001192c:	70a2                	ld	ra,40(sp)
    8001192e:	7402                	ld	s0,32(sp)
    80011930:	6165                	addi	sp,sp,112
    80011932:	8082                	ret

0000000080011934 <fatalf>:

ATTR_NORET void fatalf(const char *fmt, ...)
{
    80011934:	7159                	addi	sp,sp,-112
    80011936:	f406                	sd	ra,40(sp)
    80011938:	f022                	sd	s0,32(sp)
    8001193a:	1800                	addi	s0,sp,48
    8001193c:	fca43c23          	sd	a0,-40(s0)
    80011940:	e40c                	sd	a1,8(s0)
    80011942:	e810                	sd	a2,16(s0)
    80011944:	ec14                	sd	a3,24(s0)
    80011946:	f018                	sd	a4,32(s0)
    80011948:	f41c                	sd	a5,40(s0)
    8001194a:	03043823          	sd	a6,48(s0)
    8001194e:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    80011952:	04040793          	addi	a5,s0,64
    80011956:	fcf43823          	sd	a5,-48(s0)
    8001195a:	fd043783          	ld	a5,-48(s0)
    8001195e:	fc878793          	addi	a5,a5,-56
    80011962:	fef43423          	sd	a5,-24(s0)
    vlogf(LOG_FATAL, fmt, va);
    80011966:	fe843783          	ld	a5,-24(s0)
    8001196a:	863e                	mv	a2,a5
    8001196c:	fd843583          	ld	a1,-40(s0)
    80011970:	4521                	li	a0,8
    80011972:	eabff0ef          	jal	ra,8001181c <vlogf>
    va_end(va);

    CSR_CLEAR("sstatus");
    80011976:	10001073          	csrw	sstatus,zero
    WFI_LOOP();
    8001197a:	10500073          	wfi
    8001197e:	bff5                	j	8001197a <fatalf+0x46>

0000000080011980 <klogset>:
}

void klogset(log_type lt)
{
    80011980:	1101                	addi	sp,sp,-32
    80011982:	ec22                	sd	s0,24(sp)
    80011984:	1000                	addi	s0,sp,32
    80011986:	87aa                	mv	a5,a0
    80011988:	fef42623          	sw	a5,-20(s0)
    k_log_level |= lt;
    8001198c:	00009797          	auipc	a5,0x9
    80011990:	67478793          	addi	a5,a5,1652 # 8001b000 <k_log_level>
    80011994:	439c                	lw	a5,0(a5)
    80011996:	0007871b          	sext.w	a4,a5
    8001199a:	fec42783          	lw	a5,-20(s0)
    8001199e:	8fd9                	or	a5,a5,a4
    800119a0:	2781                	sext.w	a5,a5
    800119a2:	0007871b          	sext.w	a4,a5
    800119a6:	00009797          	auipc	a5,0x9
    800119aa:	65a78793          	addi	a5,a5,1626 # 8001b000 <k_log_level>
    800119ae:	c398                	sw	a4,0(a5)
}
    800119b0:	0001                	nop
    800119b2:	6462                	ld	s0,24(sp)
    800119b4:	6105                	addi	sp,sp,32
    800119b6:	8082                	ret

00000000800119b8 <klogclear>:

void klogclear(log_type lt)
{
    800119b8:	1101                	addi	sp,sp,-32
    800119ba:	ec22                	sd	s0,24(sp)
    800119bc:	1000                	addi	s0,sp,32
    800119be:	87aa                	mv	a5,a0
    800119c0:	fef42623          	sw	a5,-20(s0)
    k_log_level &= ~lt;
    800119c4:	fec42783          	lw	a5,-20(s0)
    800119c8:	fff7c793          	not	a5,a5
    800119cc:	0007871b          	sext.w	a4,a5
    800119d0:	00009797          	auipc	a5,0x9
    800119d4:	63078793          	addi	a5,a5,1584 # 8001b000 <k_log_level>
    800119d8:	439c                	lw	a5,0(a5)
    800119da:	2781                	sext.w	a5,a5
    800119dc:	8ff9                	and	a5,a5,a4
    800119de:	2781                	sext.w	a5,a5
    800119e0:	0007871b          	sext.w	a4,a5
    800119e4:	00009797          	auipc	a5,0x9
    800119e8:	61c78793          	addi	a5,a5,1564 # 8001b000 <k_log_level>
    800119ec:	c398                	sw	a4,0(a5)
}
    800119ee:	0001                	nop
    800119f0:	6462                	ld	s0,24(sp)
    800119f2:	6105                	addi	sp,sp,32
    800119f4:	8082                	ret

00000000800119f6 <sbi_putchar>:
#include <compiler.h>
#include <config.h>
#include <sbi.h>

void sbi_putchar(char c)
{
    800119f6:	1101                	addi	sp,sp,-32
    800119f8:	ec22                	sd	s0,24(sp)
    800119fa:	1000                	addi	s0,sp,32
    800119fc:	87aa                	mv	a5,a0
    800119fe:	fef407a3          	sb	a5,-17(s0)
    asm volatile("mv a7, %0\nmv a0, %1\necall" ::"r"(SBI_SVCALL_PUTCHAR), "r"(c) : "a7", "a0");
    80011a02:	47a5                	li	a5,9
    80011a04:	fef44703          	lbu	a4,-17(s0)
    80011a08:	88be                	mv	a7,a5
    80011a0a:	853a                	mv	a0,a4
    80011a0c:	00000073          	ecall
}
    80011a10:	0001                	nop
    80011a12:	6462                	ld	s0,24(sp)
    80011a14:	6105                	addi	sp,sp,32
    80011a16:	8082                	ret

0000000080011a18 <sbi_getchar>:

char sbi_getchar(void)
{
    80011a18:	1101                	addi	sp,sp,-32
    80011a1a:	ec22                	sd	s0,24(sp)
    80011a1c:	1000                	addi	s0,sp,32
    char c;
    asm volatile("mv a7, %1\necall\nmv %0, a0\n" : "=r"(c) : "r"(SBI_SVCALL_GETCHAR) : "a7", "a0");
    80011a1e:	47a9                	li	a5,10
    80011a20:	88be                	mv	a7,a5
    80011a22:	00000073          	ecall
    80011a26:	87aa                	mv	a5,a0
    80011a28:	fef407a3          	sb	a5,-17(s0)
    return c;
    80011a2c:	fef44783          	lbu	a5,-17(s0)
}
    80011a30:	853e                	mv	a0,a5
    80011a32:	6462                	ld	s0,24(sp)
    80011a34:	6105                	addi	sp,sp,32
    80011a36:	8082                	ret

0000000080011a38 <sbi_hart_get_status>:

int sbi_hart_get_status(unsigned int hart)
{
    80011a38:	7179                	addi	sp,sp,-48
    80011a3a:	f422                	sd	s0,40(sp)
    80011a3c:	1800                	addi	s0,sp,48
    80011a3e:	87aa                	mv	a5,a0
    80011a40:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\necall\nmv %0, a0\n"
    80011a44:	4785                	li	a5,1
    80011a46:	fdc42703          	lw	a4,-36(s0)
    80011a4a:	88be                	mv	a7,a5
    80011a4c:	853a                	mv	a0,a4
    80011a4e:	00000073          	ecall
    80011a52:	87aa                	mv	a5,a0
    80011a54:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_STATUS), "r"(hart)
                 : "a0", "a7");
    return stat;
    80011a58:	fec42783          	lw	a5,-20(s0)
}
    80011a5c:	853e                	mv	a0,a5
    80011a5e:	7422                	ld	s0,40(sp)
    80011a60:	6145                	addi	sp,sp,48
    80011a62:	8082                	ret

0000000080011a64 <sbi_hart_start>:

int sbi_hart_start(unsigned int hart, unsigned long target, unsigned long scratch, unsigned long satp)
{
    80011a64:	7139                	addi	sp,sp,-64
    80011a66:	fc22                	sd	s0,56(sp)
    80011a68:	0080                	addi	s0,sp,64
    80011a6a:	87aa                	mv	a5,a0
    80011a6c:	fcb43823          	sd	a1,-48(s0)
    80011a70:	fcc43423          	sd	a2,-56(s0)
    80011a74:	fcd43023          	sd	a3,-64(s0)
    80011a78:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\nmv a1, %3\nmv a2, %4\nmv a3, %5\necall\nmv %0, a0\n"
    80011a7c:	4789                	li	a5,2
    80011a7e:	fdc42703          	lw	a4,-36(s0)
    80011a82:	fd043683          	ld	a3,-48(s0)
    80011a86:	fc843803          	ld	a6,-56(s0)
    80011a8a:	fc043303          	ld	t1,-64(s0)
    80011a8e:	88be                	mv	a7,a5
    80011a90:	853a                	mv	a0,a4
    80011a92:	85b6                	mv	a1,a3
    80011a94:	8642                	mv	a2,a6
    80011a96:	869a                	mv	a3,t1
    80011a98:	00000073          	ecall
    80011a9c:	87aa                	mv	a5,a0
    80011a9e:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_START), "r"(hart), "r"(target), "r"(scratch), "r"(satp)
                 : "a0", "a1", "a2", "a7");
    return stat;
    80011aa2:	fec42783          	lw	a5,-20(s0)
}
    80011aa6:	853e                	mv	a0,a5
    80011aa8:	7462                	ld	s0,56(sp)
    80011aaa:	6121                	addi	sp,sp,64
    80011aac:	8082                	ret

0000000080011aae <sbi_hart_stop>:

void sbi_hart_stop(void)
{
    80011aae:	1141                	addi	sp,sp,-16
    80011ab0:	e422                	sd	s0,8(sp)
    80011ab2:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall\nwfi" : : "r"(SBI_SVCALL_HART_STOP) : "a0", "a7");
    80011ab4:	478d                	li	a5,3
    80011ab6:	88be                	mv	a7,a5
    80011ab8:	00000073          	ecall
    80011abc:	10500073          	wfi
}
    80011ac0:	0001                	nop
    80011ac2:	6422                	ld	s0,8(sp)
    80011ac4:	0141                	addi	sp,sp,16
    80011ac6:	8082                	ret

0000000080011ac8 <sbi_poweroff>:

void sbi_poweroff(void)
{
    80011ac8:	1141                	addi	sp,sp,-16
    80011aca:	e422                	sd	s0,8(sp)
    80011acc:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" : : "r"(SBI_SVCALL_POWEROFF) : "a0", "a7");
    80011ace:	47b1                	li	a5,12
    80011ad0:	88be                	mv	a7,a5
    80011ad2:	00000073          	ecall
}
    80011ad6:	0001                	nop
    80011ad8:	6422                	ld	s0,8(sp)
    80011ada:	0141                	addi	sp,sp,16
    80011adc:	8082                	ret

0000000080011ade <sbi_get_time>:

unsigned long sbi_get_time(void)
{
    80011ade:	1101                	addi	sp,sp,-32
    80011ae0:	ec22                	sd	s0,24(sp)
    80011ae2:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_GET_TIME) : "a0", "a7");
    80011ae4:	4791                	li	a5,4
    80011ae6:	88be                	mv	a7,a5
    80011ae8:	00000073          	ecall
    80011aec:	87aa                	mv	a5,a0
    80011aee:	fef43423          	sd	a5,-24(s0)
    return ret;
    80011af2:	fe843783          	ld	a5,-24(s0)
}
    80011af6:	853e                	mv	a0,a5
    80011af8:	6462                	ld	s0,24(sp)
    80011afa:	6105                	addi	sp,sp,32
    80011afc:	8082                	ret

0000000080011afe <sbi_set_timer>:

void sbi_set_timer(unsigned int hart, unsigned long val)
{
    80011afe:	1101                	addi	sp,sp,-32
    80011b00:	ec22                	sd	s0,24(sp)
    80011b02:	1000                	addi	s0,sp,32
    80011b04:	87aa                	mv	a5,a0
    80011b06:	feb43023          	sd	a1,-32(s0)
    80011b0a:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_SET_TIMECMP), "r"(hart),
    80011b0e:	4795                	li	a5,5
    80011b10:	fec42703          	lw	a4,-20(s0)
    80011b14:	fe043683          	ld	a3,-32(s0)
    80011b18:	88be                	mv	a7,a5
    80011b1a:	853a                	mv	a0,a4
    80011b1c:	85b6                	mv	a1,a3
    80011b1e:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    80011b22:	0001                	nop
    80011b24:	6462                	ld	s0,24(sp)
    80011b26:	6105                	addi	sp,sp,32
    80011b28:	8082                	ret

0000000080011b2a <sbi_add_timer>:

void sbi_add_timer(unsigned int hart, unsigned long val)
{
    80011b2a:	1101                	addi	sp,sp,-32
    80011b2c:	ec22                	sd	s0,24(sp)
    80011b2e:	1000                	addi	s0,sp,32
    80011b30:	87aa                	mv	a5,a0
    80011b32:	feb43023          	sd	a1,-32(s0)
    80011b36:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_ADD_TIMECMP), "r"(hart),
    80011b3a:	4799                	li	a5,6
    80011b3c:	fec42703          	lw	a4,-20(s0)
    80011b40:	fe043683          	ld	a3,-32(s0)
    80011b44:	88be                	mv	a7,a5
    80011b46:	853a                	mv	a0,a4
    80011b48:	85b6                	mv	a1,a3
    80011b4a:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    80011b4e:	0001                	nop
    80011b50:	6462                	ld	s0,24(sp)
    80011b52:	6105                	addi	sp,sp,32
    80011b54:	8082                	ret

0000000080011b56 <sbi_ack_timer>:

void sbi_ack_timer(void)
{
    80011b56:	1141                	addi	sp,sp,-16
    80011b58:	e422                	sd	s0,8(sp)
    80011b5a:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" ::"r"(SBI_SVCALL_ACK_TIMER) : "a7");
    80011b5c:	479d                	li	a5,7
    80011b5e:	88be                	mv	a7,a5
    80011b60:	00000073          	ecall
}
    80011b64:	0001                	nop
    80011b66:	6422                	ld	s0,8(sp)
    80011b68:	0141                	addi	sp,sp,16
    80011b6a:	8082                	ret

0000000080011b6c <sbi_rtc_get_time>:

unsigned long sbi_rtc_get_time(void)
{
    80011b6c:	1101                	addi	sp,sp,-32
    80011b6e:	ec22                	sd	s0,24(sp)
    80011b70:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0"
    80011b72:	47a1                	li	a5,8
    80011b74:	88be                	mv	a7,a5
    80011b76:	00000073          	ecall
    80011b7a:	87aa                	mv	a5,a0
    80011b7c:	fef43423          	sd	a5,-24(s0)
                 : "=r"(ret)
                 : "r"(SBI_SVCALL_RTC_GET_TIME)
                 : "a0", "a7");
    return ret;
    80011b80:	fe843783          	ld	a5,-24(s0)
}
    80011b84:	853e                	mv	a0,a5
    80011b86:	6462                	ld	s0,24(sp)
    80011b88:	6105                	addi	sp,sp,32
    80011b8a:	8082                	ret

0000000080011b8c <sbi_whoami>:

int sbi_whoami(void)
{
    80011b8c:	1101                	addi	sp,sp,-32
    80011b8e:	ec22                	sd	s0,24(sp)
    80011b90:	1000                	addi	s0,sp,32
    int ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_WHOAMI) : "a0", "a7");
    80011b92:	47ad                	li	a5,11
    80011b94:	88be                	mv	a7,a5
    80011b96:	00000073          	ecall
    80011b9a:	87aa                	mv	a5,a0
    80011b9c:	fef42623          	sw	a5,-20(s0)
    return ret;
    80011ba0:	fec42783          	lw	a5,-20(s0)
}
    80011ba4:	853e                	mv	a0,a5
    80011ba6:	6462                	ld	s0,24(sp)
    80011ba8:	6105                	addi	sp,sp,32
    80011baa:	8082                	ret

0000000080011bac <sbi_num_harts>:

int sbi_num_harts(void)
{
    80011bac:	1101                	addi	sp,sp,-32
    80011bae:	ec06                	sd	ra,24(sp)
    80011bb0:	e822                	sd	s0,16(sp)
    80011bb2:	1000                	addi	s0,sp,32
    unsigned int i;
    int num_harts = 0;
    80011bb4:	fe042423          	sw	zero,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80011bb8:	fe042623          	sw	zero,-20(s0)
    80011bbc:	a015                	j	80011be0 <sbi_num_harts+0x34>
        if (sbi_hart_get_status(i) != 0) {
    80011bbe:	fec42783          	lw	a5,-20(s0)
    80011bc2:	853e                	mv	a0,a5
    80011bc4:	e75ff0ef          	jal	ra,80011a38 <sbi_hart_get_status>
    80011bc8:	87aa                	mv	a5,a0
    80011bca:	c791                	beqz	a5,80011bd6 <sbi_num_harts+0x2a>
            num_harts += 1;
    80011bcc:	fe842783          	lw	a5,-24(s0)
    80011bd0:	2785                	addiw	a5,a5,1
    80011bd2:	fef42423          	sw	a5,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80011bd6:	fec42783          	lw	a5,-20(s0)
    80011bda:	2785                	addiw	a5,a5,1
    80011bdc:	fef42623          	sw	a5,-20(s0)
    80011be0:	fec42783          	lw	a5,-20(s0)
    80011be4:	0007871b          	sext.w	a4,a5
    80011be8:	478d                	li	a5,3
    80011bea:	fce7fae3          	bgeu	a5,a4,80011bbe <sbi_num_harts+0x12>
        }
    }
    return num_harts;
    80011bee:	fe842783          	lw	a5,-24(s0)
}
    80011bf2:	853e                	mv	a0,a5
    80011bf4:	60e2                	ld	ra,24(sp)
    80011bf6:	6442                	ld	s0,16(sp)
    80011bf8:	6105                	addi	sp,sp,32
    80011bfa:	8082                	ret

0000000080011bfc <plic_set_priority>:
#define PLIC_PCI_INTB 33
#define PLIC_PCI_INTC 34
#define PLIC_PCI_INTD 35

void plic_set_priority(int interrupt_id, char priority)
{
    80011bfc:	7179                	addi	sp,sp,-48
    80011bfe:	f422                	sd	s0,40(sp)
    80011c00:	1800                	addi	s0,sp,48
    80011c02:	87aa                	mv	a5,a0
    80011c04:	872e                	mv	a4,a1
    80011c06:	fcf42e23          	sw	a5,-36(s0)
    80011c0a:	87ba                	mv	a5,a4
    80011c0c:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_PRIORITY(interrupt_id);
    80011c10:	fdc42783          	lw	a5,-36(s0)
    80011c14:	0027979b          	slliw	a5,a5,0x2
    80011c18:	2781                	sext.w	a5,a5
    80011c1a:	873e                	mv	a4,a5
    80011c1c:	0c0007b7          	lui	a5,0xc000
    80011c20:	97ba                	add	a5,a5,a4
    80011c22:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    80011c26:	fdb44783          	lbu	a5,-37(s0)
    80011c2a:	2781                	sext.w	a5,a5
    80011c2c:	8b9d                	andi	a5,a5,7
    80011c2e:	0007871b          	sext.w	a4,a5
    80011c32:	fe843783          	ld	a5,-24(s0)
    80011c36:	c398                	sw	a4,0(a5)
}
    80011c38:	0001                	nop
    80011c3a:	7422                	ld	s0,40(sp)
    80011c3c:	6145                	addi	sp,sp,48
    80011c3e:	8082                	ret

0000000080011c40 <plic_set_threshold>:
void plic_set_threshold(int hart, char priority)
{
    80011c40:	7179                	addi	sp,sp,-48
    80011c42:	f422                	sd	s0,40(sp)
    80011c44:	1800                	addi	s0,sp,48
    80011c46:	87aa                	mv	a5,a0
    80011c48:	872e                	mv	a4,a1
    80011c4a:	fcf42e23          	sw	a5,-36(s0)
    80011c4e:	87ba                	mv	a5,a4
    80011c50:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_THRESHOLD(hart, PLIC_MODE_SUPERVISOR);
    80011c54:	fdc42783          	lw	a5,-36(s0)
    80011c58:	0017979b          	slliw	a5,a5,0x1
    80011c5c:	2781                	sext.w	a5,a5
    80011c5e:	2785                	addiw	a5,a5,1
    80011c60:	2781                	sext.w	a5,a5
    80011c62:	00c7979b          	slliw	a5,a5,0xc
    80011c66:	2781                	sext.w	a5,a5
    80011c68:	873e                	mv	a4,a5
    80011c6a:	0c2007b7          	lui	a5,0xc200
    80011c6e:	97ba                	add	a5,a5,a4
    80011c70:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    80011c74:	fdb44783          	lbu	a5,-37(s0)
    80011c78:	2781                	sext.w	a5,a5
    80011c7a:	8b9d                	andi	a5,a5,7
    80011c7c:	0007871b          	sext.w	a4,a5
    80011c80:	fe843783          	ld	a5,-24(s0)
    80011c84:	c398                	sw	a4,0(a5)
}
    80011c86:	0001                	nop
    80011c88:	7422                	ld	s0,40(sp)
    80011c8a:	6145                	addi	sp,sp,48
    80011c8c:	8082                	ret

0000000080011c8e <plic_enable>:
void plic_enable(int hart, int interrupt_id)
{
    80011c8e:	7179                	addi	sp,sp,-48
    80011c90:	f422                	sd	s0,40(sp)
    80011c92:	1800                	addi	s0,sp,48
    80011c94:	87aa                	mv	a5,a0
    80011c96:	872e                	mv	a4,a1
    80011c98:	fcf42e23          	sw	a5,-36(s0)
    80011c9c:	87ba                	mv	a5,a4
    80011c9e:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    80011ca2:	fdc42783          	lw	a5,-36(s0)
    80011ca6:	0017979b          	slliw	a5,a5,0x1
    80011caa:	2781                	sext.w	a5,a5
    80011cac:	2785                	addiw	a5,a5,1
    80011cae:	2781                	sext.w	a5,a5
    80011cb0:	0077979b          	slliw	a5,a5,0x7
    80011cb4:	2781                	sext.w	a5,a5
    80011cb6:	873e                	mv	a4,a5
    80011cb8:	0c0027b7          	lui	a5,0xc002
    80011cbc:	97ba                	add	a5,a5,a4
    80011cbe:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] |= 1UL << (interrupt_id % 32);
    80011cc2:	fd842783          	lw	a5,-40(s0)
    80011cc6:	41f7d71b          	sraiw	a4,a5,0x1f
    80011cca:	01b7571b          	srliw	a4,a4,0x1b
    80011cce:	9fb9                	addw	a5,a5,a4
    80011cd0:	4057d79b          	sraiw	a5,a5,0x5
    80011cd4:	0007869b          	sext.w	a3,a5
    80011cd8:	87b6                	mv	a5,a3
    80011cda:	078a                	slli	a5,a5,0x2
    80011cdc:	fe843703          	ld	a4,-24(s0)
    80011ce0:	97ba                	add	a5,a5,a4
    80011ce2:	438c                	lw	a1,0(a5)
    80011ce4:	fd842703          	lw	a4,-40(s0)
    80011ce8:	41f7579b          	sraiw	a5,a4,0x1f
    80011cec:	01b7d79b          	srliw	a5,a5,0x1b
    80011cf0:	9f3d                	addw	a4,a4,a5
    80011cf2:	8b7d                	andi	a4,a4,31
    80011cf4:	40f707bb          	subw	a5,a4,a5
    80011cf8:	2781                	sext.w	a5,a5
    80011cfa:	873e                	mv	a4,a5
    80011cfc:	4785                	li	a5,1
    80011cfe:	00e797b3          	sll	a5,a5,a4
    80011d02:	0007861b          	sext.w	a2,a5
    80011d06:	87b6                	mv	a5,a3
    80011d08:	078a                	slli	a5,a5,0x2
    80011d0a:	fe843703          	ld	a4,-24(s0)
    80011d0e:	97ba                	add	a5,a5,a4
    80011d10:	86ae                	mv	a3,a1
    80011d12:	8732                	mv	a4,a2
    80011d14:	8f55                	or	a4,a4,a3
    80011d16:	2701                	sext.w	a4,a4
    80011d18:	c398                	sw	a4,0(a5)
}
    80011d1a:	0001                	nop
    80011d1c:	7422                	ld	s0,40(sp)
    80011d1e:	6145                	addi	sp,sp,48
    80011d20:	8082                	ret

0000000080011d22 <plic_disable>:
void plic_disable(int hart, int interrupt_id)
{
    80011d22:	7179                	addi	sp,sp,-48
    80011d24:	f422                	sd	s0,40(sp)
    80011d26:	1800                	addi	s0,sp,48
    80011d28:	87aa                	mv	a5,a0
    80011d2a:	872e                	mv	a4,a1
    80011d2c:	fcf42e23          	sw	a5,-36(s0)
    80011d30:	87ba                	mv	a5,a4
    80011d32:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    80011d36:	fdc42783          	lw	a5,-36(s0)
    80011d3a:	0017979b          	slliw	a5,a5,0x1
    80011d3e:	2781                	sext.w	a5,a5
    80011d40:	2785                	addiw	a5,a5,1
    80011d42:	2781                	sext.w	a5,a5
    80011d44:	0077979b          	slliw	a5,a5,0x7
    80011d48:	2781                	sext.w	a5,a5
    80011d4a:	873e                	mv	a4,a5
    80011d4c:	0c0027b7          	lui	a5,0xc002
    80011d50:	97ba                	add	a5,a5,a4
    80011d52:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] &= ~(1UL << (interrupt_id % 32));
    80011d56:	fd842783          	lw	a5,-40(s0)
    80011d5a:	41f7d71b          	sraiw	a4,a5,0x1f
    80011d5e:	01b7571b          	srliw	a4,a4,0x1b
    80011d62:	9fb9                	addw	a5,a5,a4
    80011d64:	4057d79b          	sraiw	a5,a5,0x5
    80011d68:	0007869b          	sext.w	a3,a5
    80011d6c:	87b6                	mv	a5,a3
    80011d6e:	078a                	slli	a5,a5,0x2
    80011d70:	fe843703          	ld	a4,-24(s0)
    80011d74:	97ba                	add	a5,a5,a4
    80011d76:	438c                	lw	a1,0(a5)
    80011d78:	fd842703          	lw	a4,-40(s0)
    80011d7c:	41f7579b          	sraiw	a5,a4,0x1f
    80011d80:	01b7d79b          	srliw	a5,a5,0x1b
    80011d84:	9f3d                	addw	a4,a4,a5
    80011d86:	8b7d                	andi	a4,a4,31
    80011d88:	40f707bb          	subw	a5,a4,a5
    80011d8c:	2781                	sext.w	a5,a5
    80011d8e:	873e                	mv	a4,a5
    80011d90:	4785                	li	a5,1
    80011d92:	00e797b3          	sll	a5,a5,a4
    80011d96:	2781                	sext.w	a5,a5
    80011d98:	fff7c793          	not	a5,a5
    80011d9c:	0007861b          	sext.w	a2,a5
    80011da0:	87b6                	mv	a5,a3
    80011da2:	078a                	slli	a5,a5,0x2
    80011da4:	fe843703          	ld	a4,-24(s0)
    80011da8:	97ba                	add	a5,a5,a4
    80011daa:	86ae                	mv	a3,a1
    80011dac:	8732                	mv	a4,a2
    80011dae:	8f75                	and	a4,a4,a3
    80011db0:	2701                	sext.w	a4,a4
    80011db2:	c398                	sw	a4,0(a5)
}
    80011db4:	0001                	nop
    80011db6:	7422                	ld	s0,40(sp)
    80011db8:	6145                	addi	sp,sp,48
    80011dba:	8082                	ret

0000000080011dbc <plic_claim>:
uint32_t plic_claim(int hart)
{
    80011dbc:	7179                	addi	sp,sp,-48
    80011dbe:	f422                	sd	s0,40(sp)
    80011dc0:	1800                	addi	s0,sp,48
    80011dc2:	87aa                	mv	a5,a0
    80011dc4:	fcf42e23          	sw	a5,-36(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    80011dc8:	fdc42783          	lw	a5,-36(s0)
    80011dcc:	0017979b          	slliw	a5,a5,0x1
    80011dd0:	2781                	sext.w	a5,a5
    80011dd2:	2785                	addiw	a5,a5,1
    80011dd4:	2781                	sext.w	a5,a5
    80011dd6:	00c7979b          	slliw	a5,a5,0xc
    80011dda:	2781                	sext.w	a5,a5
    80011ddc:	873e                	mv	a4,a5
    80011dde:	0c2007b7          	lui	a5,0xc200
    80011de2:	0791                	addi	a5,a5,4
    80011de4:	97ba                	add	a5,a5,a4
    80011de6:	fef43423          	sd	a5,-24(s0)
    return *base;
    80011dea:	fe843783          	ld	a5,-24(s0)
    80011dee:	439c                	lw	a5,0(a5)
}
    80011df0:	853e                	mv	a0,a5
    80011df2:	7422                	ld	s0,40(sp)
    80011df4:	6145                	addi	sp,sp,48
    80011df6:	8082                	ret

0000000080011df8 <plic_complete>:
void plic_complete(int hart, int id)
{
    80011df8:	7179                	addi	sp,sp,-48
    80011dfa:	f422                	sd	s0,40(sp)
    80011dfc:	1800                	addi	s0,sp,48
    80011dfe:	87aa                	mv	a5,a0
    80011e00:	872e                	mv	a4,a1
    80011e02:	fcf42e23          	sw	a5,-36(s0)
    80011e06:	87ba                	mv	a5,a4
    80011e08:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    80011e0c:	fdc42783          	lw	a5,-36(s0)
    80011e10:	0017979b          	slliw	a5,a5,0x1
    80011e14:	2781                	sext.w	a5,a5
    80011e16:	2785                	addiw	a5,a5,1
    80011e18:	2781                	sext.w	a5,a5
    80011e1a:	00c7979b          	slliw	a5,a5,0xc
    80011e1e:	2781                	sext.w	a5,a5
    80011e20:	873e                	mv	a4,a5
    80011e22:	0c2007b7          	lui	a5,0xc200
    80011e26:	0791                	addi	a5,a5,4
    80011e28:	97ba                	add	a5,a5,a4
    80011e2a:	fef43423          	sd	a5,-24(s0)
    *base          = id;
    80011e2e:	fd842703          	lw	a4,-40(s0)
    80011e32:	fe843783          	ld	a5,-24(s0)
    80011e36:	c398                	sw	a4,0(a5)
}
    80011e38:	0001                	nop
    80011e3a:	7422                	ld	s0,40(sp)
    80011e3c:	6145                	addi	sp,sp,48
    80011e3e:	8082                	ret

0000000080011e40 <plic_handle_irq>:

void plic_handle_irq(int hart)
{
    80011e40:	7179                	addi	sp,sp,-48
    80011e42:	f406                	sd	ra,40(sp)
    80011e44:	f022                	sd	s0,32(sp)
    80011e46:	1800                	addi	s0,sp,48
    80011e48:	87aa                	mv	a5,a0
    80011e4a:	fcf42e23          	sw	a5,-36(s0)
    int irq = plic_claim(hart);
    80011e4e:	fdc42783          	lw	a5,-36(s0)
    80011e52:	853e                	mv	a0,a5
    80011e54:	f69ff0ef          	jal	ra,80011dbc <plic_claim>
    80011e58:	87aa                	mv	a5,a0
    80011e5a:	2781                	sext.w	a5,a5
    80011e5c:	fef42623          	sw	a5,-20(s0)
            pci_dispatch_irq(irq);
#endif
            break;
    }

    plic_complete(hart, irq);
    80011e60:	fec42703          	lw	a4,-20(s0)
    80011e64:	fdc42783          	lw	a5,-36(s0)
    80011e68:	85ba                	mv	a1,a4
    80011e6a:	853e                	mv	a0,a5
    80011e6c:	f8dff0ef          	jal	ra,80011df8 <plic_complete>
}
    80011e70:	0001                	nop
    80011e72:	70a2                	ld	ra,40(sp)
    80011e74:	7402                	ld	s0,32(sp)
    80011e76:	6145                	addi	sp,sp,48
    80011e78:	8082                	ret

0000000080011e7a <plic_init>:

void plic_init(void)
{
    80011e7a:	1141                	addi	sp,sp,-16
    80011e7c:	e406                	sd	ra,8(sp)
    80011e7e:	e022                	sd	s0,0(sp)
    80011e80:	0800                	addi	s0,sp,16
    plic_enable(0, PLIC_PCI_INTA);
    80011e82:	02000593          	li	a1,32
    80011e86:	4501                	li	a0,0
    80011e88:	e07ff0ef          	jal	ra,80011c8e <plic_enable>
    plic_enable(0, PLIC_PCI_INTB);
    80011e8c:	02100593          	li	a1,33
    80011e90:	4501                	li	a0,0
    80011e92:	dfdff0ef          	jal	ra,80011c8e <plic_enable>
    plic_enable(0, PLIC_PCI_INTC);
    80011e96:	02200593          	li	a1,34
    80011e9a:	4501                	li	a0,0
    80011e9c:	df3ff0ef          	jal	ra,80011c8e <plic_enable>
    plic_enable(0, PLIC_PCI_INTD);
    80011ea0:	02300593          	li	a1,35
    80011ea4:	4501                	li	a0,0
    80011ea6:	de9ff0ef          	jal	ra,80011c8e <plic_enable>

    plic_set_threshold(0, 1);
    80011eaa:	4585                	li	a1,1
    80011eac:	4501                	li	a0,0
    80011eae:	d93ff0ef          	jal	ra,80011c40 <plic_set_threshold>

    plic_set_priority(PLIC_PCI_INTA, 3);
    80011eb2:	458d                	li	a1,3
    80011eb4:	02000513          	li	a0,32
    80011eb8:	d45ff0ef          	jal	ra,80011bfc <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTB, 3);
    80011ebc:	458d                	li	a1,3
    80011ebe:	02100513          	li	a0,33
    80011ec2:	d3bff0ef          	jal	ra,80011bfc <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTC, 3);
    80011ec6:	458d                	li	a1,3
    80011ec8:	02200513          	li	a0,34
    80011ecc:	d31ff0ef          	jal	ra,80011bfc <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTD, 3);
    80011ed0:	458d                	li	a1,3
    80011ed2:	02300513          	li	a0,35
    80011ed6:	d27ff0ef          	jal	ra,80011bfc <plic_set_priority>
}
    80011eda:	0001                	nop
    80011edc:	60a2                	ld	ra,8(sp)
    80011ede:	6402                	ld	s0,0(sp)
    80011ee0:	0141                	addi	sp,sp,16
    80011ee2:	8082                	ret

0000000080011ee4 <set_taken>:

static uint8_t *bookkeeping;  // Pointer to the bookkeeping area

// For some reason, the macros didn't work for me, so I used the static functions like Marz said and it works.
static void set_taken(uint64_t index)
{
    80011ee4:	1101                	addi	sp,sp,-32
    80011ee6:	ec22                	sd	s0,24(sp)
    80011ee8:	1000                	addi	s0,sp,32
    80011eea:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2));
    80011eee:	00006797          	auipc	a5,0x6
    80011ef2:	16278793          	addi	a5,a5,354 # 80018050 <bookkeeping>
    80011ef6:	6398                	ld	a4,0(a5)
    80011ef8:	fe843783          	ld	a5,-24(s0)
    80011efc:	8389                	srli	a5,a5,0x2
    80011efe:	973e                	add	a4,a4,a5
    80011f00:	00074703          	lbu	a4,0(a4) # ffffffffc0fff000 <_heap_end+0xffffffff38fef000>
    80011f04:	0187169b          	slliw	a3,a4,0x18
    80011f08:	4186d69b          	sraiw	a3,a3,0x18
    80011f0c:	fe843703          	ld	a4,-24(s0)
    80011f10:	2701                	sext.w	a4,a4
    80011f12:	8b0d                	andi	a4,a4,3
    80011f14:	2701                	sext.w	a4,a4
    80011f16:	0017171b          	slliw	a4,a4,0x1
    80011f1a:	2701                	sext.w	a4,a4
    80011f1c:	4605                	li	a2,1
    80011f1e:	00e6173b          	sllw	a4,a2,a4
    80011f22:	2701                	sext.w	a4,a4
    80011f24:	0187171b          	slliw	a4,a4,0x18
    80011f28:	4187571b          	sraiw	a4,a4,0x18
    80011f2c:	8f55                	or	a4,a4,a3
    80011f2e:	0187169b          	slliw	a3,a4,0x18
    80011f32:	4186d69b          	sraiw	a3,a3,0x18
    80011f36:	00006717          	auipc	a4,0x6
    80011f3a:	11a70713          	addi	a4,a4,282 # 80018050 <bookkeeping>
    80011f3e:	6318                	ld	a4,0(a4)
    80011f40:	97ba                	add	a5,a5,a4
    80011f42:	0ff6f713          	andi	a4,a3,255
    80011f46:	00e78023          	sb	a4,0(a5)
}
    80011f4a:	0001                	nop
    80011f4c:	6462                	ld	s0,24(sp)
    80011f4e:	6105                	addi	sp,sp,32
    80011f50:	8082                	ret

0000000080011f52 <clear_taken>:

static void clear_taken(uint64_t index)
{
    80011f52:	1101                	addi	sp,sp,-32
    80011f54:	ec22                	sd	s0,24(sp)
    80011f56:	1000                	addi	s0,sp,32
    80011f58:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2));
    80011f5c:	00006797          	auipc	a5,0x6
    80011f60:	0f478793          	addi	a5,a5,244 # 80018050 <bookkeeping>
    80011f64:	6398                	ld	a4,0(a5)
    80011f66:	fe843783          	ld	a5,-24(s0)
    80011f6a:	8389                	srli	a5,a5,0x2
    80011f6c:	973e                	add	a4,a4,a5
    80011f6e:	00074703          	lbu	a4,0(a4)
    80011f72:	0187169b          	slliw	a3,a4,0x18
    80011f76:	4186d69b          	sraiw	a3,a3,0x18
    80011f7a:	fe843703          	ld	a4,-24(s0)
    80011f7e:	2701                	sext.w	a4,a4
    80011f80:	8b0d                	andi	a4,a4,3
    80011f82:	2701                	sext.w	a4,a4
    80011f84:	0017171b          	slliw	a4,a4,0x1
    80011f88:	2701                	sext.w	a4,a4
    80011f8a:	4605                	li	a2,1
    80011f8c:	00e6173b          	sllw	a4,a2,a4
    80011f90:	2701                	sext.w	a4,a4
    80011f92:	0187171b          	slliw	a4,a4,0x18
    80011f96:	4187571b          	sraiw	a4,a4,0x18
    80011f9a:	fff74713          	not	a4,a4
    80011f9e:	0187171b          	slliw	a4,a4,0x18
    80011fa2:	4187571b          	sraiw	a4,a4,0x18
    80011fa6:	8f75                	and	a4,a4,a3
    80011fa8:	0187169b          	slliw	a3,a4,0x18
    80011fac:	4186d69b          	sraiw	a3,a3,0x18
    80011fb0:	00006717          	auipc	a4,0x6
    80011fb4:	0a070713          	addi	a4,a4,160 # 80018050 <bookkeeping>
    80011fb8:	6318                	ld	a4,0(a4)
    80011fba:	97ba                	add	a5,a5,a4
    80011fbc:	0ff6f713          	andi	a4,a3,255
    80011fc0:	00e78023          	sb	a4,0(a5)
}
    80011fc4:	0001                	nop
    80011fc6:	6462                	ld	s0,24(sp)
    80011fc8:	6105                	addi	sp,sp,32
    80011fca:	8082                	ret

0000000080011fcc <is_taken>:

static int is_taken(uint64_t index)
{
    80011fcc:	1101                	addi	sp,sp,-32
    80011fce:	ec22                	sd	s0,24(sp)
    80011fd0:	1000                	addi	s0,sp,32
    80011fd2:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2));
    80011fd6:	00006797          	auipc	a5,0x6
    80011fda:	07a78793          	addi	a5,a5,122 # 80018050 <bookkeeping>
    80011fde:	6398                	ld	a4,0(a5)
    80011fe0:	fe843783          	ld	a5,-24(s0)
    80011fe4:	8389                	srli	a5,a5,0x2
    80011fe6:	97ba                	add	a5,a5,a4
    80011fe8:	0007c783          	lbu	a5,0(a5)
    80011fec:	0007871b          	sext.w	a4,a5
    80011ff0:	fe843783          	ld	a5,-24(s0)
    80011ff4:	2781                	sext.w	a5,a5
    80011ff6:	8b8d                	andi	a5,a5,3
    80011ff8:	2781                	sext.w	a5,a5
    80011ffa:	0017979b          	slliw	a5,a5,0x1
    80011ffe:	2781                	sext.w	a5,a5
    80012000:	4685                	li	a3,1
    80012002:	00f697bb          	sllw	a5,a3,a5
    80012006:	2781                	sext.w	a5,a5
    80012008:	8ff9                	and	a5,a5,a4
    8001200a:	2781                	sext.w	a5,a5
}
    8001200c:	853e                	mv	a0,a5
    8001200e:	6462                	ld	s0,24(sp)
    80012010:	6105                	addi	sp,sp,32
    80012012:	8082                	ret

0000000080012014 <set_last>:

static void set_last(uint64_t index)
{
    80012014:	1101                	addi	sp,sp,-32
    80012016:	ec22                	sd	s0,24(sp)
    80012018:	1000                	addi	s0,sp,32
    8001201a:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2 + 1));
    8001201e:	00006797          	auipc	a5,0x6
    80012022:	03278793          	addi	a5,a5,50 # 80018050 <bookkeeping>
    80012026:	6398                	ld	a4,0(a5)
    80012028:	fe843783          	ld	a5,-24(s0)
    8001202c:	8389                	srli	a5,a5,0x2
    8001202e:	973e                	add	a4,a4,a5
    80012030:	00074703          	lbu	a4,0(a4)
    80012034:	0187169b          	slliw	a3,a4,0x18
    80012038:	4186d69b          	sraiw	a3,a3,0x18
    8001203c:	fe843703          	ld	a4,-24(s0)
    80012040:	2701                	sext.w	a4,a4
    80012042:	8b0d                	andi	a4,a4,3
    80012044:	2701                	sext.w	a4,a4
    80012046:	0017171b          	slliw	a4,a4,0x1
    8001204a:	2701                	sext.w	a4,a4
    8001204c:	2705                	addiw	a4,a4,1
    8001204e:	2701                	sext.w	a4,a4
    80012050:	4605                	li	a2,1
    80012052:	00e6173b          	sllw	a4,a2,a4
    80012056:	2701                	sext.w	a4,a4
    80012058:	0187171b          	slliw	a4,a4,0x18
    8001205c:	4187571b          	sraiw	a4,a4,0x18
    80012060:	8f55                	or	a4,a4,a3
    80012062:	0187169b          	slliw	a3,a4,0x18
    80012066:	4186d69b          	sraiw	a3,a3,0x18
    8001206a:	00006717          	auipc	a4,0x6
    8001206e:	fe670713          	addi	a4,a4,-26 # 80018050 <bookkeeping>
    80012072:	6318                	ld	a4,0(a4)
    80012074:	97ba                	add	a5,a5,a4
    80012076:	0ff6f713          	andi	a4,a3,255
    8001207a:	00e78023          	sb	a4,0(a5)
}
    8001207e:	0001                	nop
    80012080:	6462                	ld	s0,24(sp)
    80012082:	6105                	addi	sp,sp,32
    80012084:	8082                	ret

0000000080012086 <clear_last>:

static void clear_last(uint64_t index)
{
    80012086:	1101                	addi	sp,sp,-32
    80012088:	ec22                	sd	s0,24(sp)
    8001208a:	1000                	addi	s0,sp,32
    8001208c:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2 + 1));
    80012090:	00006797          	auipc	a5,0x6
    80012094:	fc078793          	addi	a5,a5,-64 # 80018050 <bookkeeping>
    80012098:	6398                	ld	a4,0(a5)
    8001209a:	fe843783          	ld	a5,-24(s0)
    8001209e:	8389                	srli	a5,a5,0x2
    800120a0:	973e                	add	a4,a4,a5
    800120a2:	00074703          	lbu	a4,0(a4)
    800120a6:	0187169b          	slliw	a3,a4,0x18
    800120aa:	4186d69b          	sraiw	a3,a3,0x18
    800120ae:	fe843703          	ld	a4,-24(s0)
    800120b2:	2701                	sext.w	a4,a4
    800120b4:	8b0d                	andi	a4,a4,3
    800120b6:	2701                	sext.w	a4,a4
    800120b8:	0017171b          	slliw	a4,a4,0x1
    800120bc:	2701                	sext.w	a4,a4
    800120be:	2705                	addiw	a4,a4,1
    800120c0:	2701                	sext.w	a4,a4
    800120c2:	4605                	li	a2,1
    800120c4:	00e6173b          	sllw	a4,a2,a4
    800120c8:	2701                	sext.w	a4,a4
    800120ca:	0187171b          	slliw	a4,a4,0x18
    800120ce:	4187571b          	sraiw	a4,a4,0x18
    800120d2:	fff74713          	not	a4,a4
    800120d6:	0187171b          	slliw	a4,a4,0x18
    800120da:	4187571b          	sraiw	a4,a4,0x18
    800120de:	8f75                	and	a4,a4,a3
    800120e0:	0187169b          	slliw	a3,a4,0x18
    800120e4:	4186d69b          	sraiw	a3,a3,0x18
    800120e8:	00006717          	auipc	a4,0x6
    800120ec:	f6870713          	addi	a4,a4,-152 # 80018050 <bookkeeping>
    800120f0:	6318                	ld	a4,0(a4)
    800120f2:	97ba                	add	a5,a5,a4
    800120f4:	0ff6f713          	andi	a4,a3,255
    800120f8:	00e78023          	sb	a4,0(a5)
}
    800120fc:	0001                	nop
    800120fe:	6462                	ld	s0,24(sp)
    80012100:	6105                	addi	sp,sp,32
    80012102:	8082                	ret

0000000080012104 <is_last>:

static int is_last(uint64_t index)
{
    80012104:	1101                	addi	sp,sp,-32
    80012106:	ec22                	sd	s0,24(sp)
    80012108:	1000                	addi	s0,sp,32
    8001210a:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2 + 1));
    8001210e:	00006797          	auipc	a5,0x6
    80012112:	f4278793          	addi	a5,a5,-190 # 80018050 <bookkeeping>
    80012116:	6398                	ld	a4,0(a5)
    80012118:	fe843783          	ld	a5,-24(s0)
    8001211c:	8389                	srli	a5,a5,0x2
    8001211e:	97ba                	add	a5,a5,a4
    80012120:	0007c783          	lbu	a5,0(a5)
    80012124:	0007871b          	sext.w	a4,a5
    80012128:	fe843783          	ld	a5,-24(s0)
    8001212c:	2781                	sext.w	a5,a5
    8001212e:	8b8d                	andi	a5,a5,3
    80012130:	2781                	sext.w	a5,a5
    80012132:	0017979b          	slliw	a5,a5,0x1
    80012136:	2781                	sext.w	a5,a5
    80012138:	2785                	addiw	a5,a5,1
    8001213a:	2781                	sext.w	a5,a5
    8001213c:	4685                	li	a3,1
    8001213e:	00f697bb          	sllw	a5,a3,a5
    80012142:	2781                	sext.w	a5,a5
    80012144:	8ff9                	and	a5,a5,a4
    80012146:	2781                	sext.w	a5,a5
}
    80012148:	853e                	mv	a0,a5
    8001214a:	6462                	ld	s0,24(sp)
    8001214c:	6105                	addi	sp,sp,32
    8001214e:	8082                	ret

0000000080012150 <page_init>:

void page_init(void)
{
    80012150:	1101                	addi	sp,sp,-32
    80012152:	ec06                	sd	ra,24(sp)
    80012154:	e822                	sd	s0,16(sp)
    80012156:	1000                	addi	s0,sp,32
    /* Initialize the page system. */
    bookkeeping = sym_start(heap);
    80012158:	00006797          	auipc	a5,0x6
    8001215c:	ef878793          	addi	a5,a5,-264 # 80018050 <bookkeeping>
    80012160:	00012717          	auipc	a4,0x12
    80012164:	ea070713          	addi	a4,a4,-352 # 80024000 <_heap_start>
    80012168:	e398                	sd	a4,0(a5)
    
    // Print bookkeeping area
    mutex_spinlock(&page_lock);
    8001216a:	00006517          	auipc	a0,0x6
    8001216e:	e9e50513          	addi	a0,a0,-354 # 80018008 <page_lock>
    80012172:	cb0fe0ef          	jal	ra,80010622 <mutex_spinlock>

    // Initialize the bookkeeping area
    memset(bookkeeping, 0, BK_SIZE_IN_BYTES);
    80012176:	00006797          	auipc	a5,0x6
    8001217a:	eda78793          	addi	a5,a5,-294 # 80018050 <bookkeeping>
    8001217e:	6394                	ld	a3,0(a5)
    80012180:	07ffe717          	auipc	a4,0x7ffe
    80012184:	e8070713          	addi	a4,a4,-384 # 88010000 <_heap_end>
    80012188:	00012797          	auipc	a5,0x12
    8001218c:	e7878793          	addi	a5,a5,-392 # 80024000 <_heap_start>
    80012190:	40f707b3          	sub	a5,a4,a5
    80012194:	83b9                	srli	a5,a5,0xe
    80012196:	0007871b          	sext.w	a4,a5
    8001219a:	6785                	lui	a5,0x1
    8001219c:	37fd                	addiw	a5,a5,-1
    8001219e:	9fb9                	addw	a5,a5,a4
    800121a0:	2781                	sext.w	a5,a5
    800121a2:	0007871b          	sext.w	a4,a5
    800121a6:	77fd                	lui	a5,0xfffff
    800121a8:	8ff9                	and	a5,a5,a4
    800121aa:	2781                	sext.w	a5,a5
    800121ac:	863e                	mv	a2,a5
    800121ae:	4581                	li	a1,0
    800121b0:	8536                	mv	a0,a3
    800121b2:	381020ef          	jal	ra,80014d32 <memset>
    // Mark the bookkeeping pages as taken
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    800121b6:	fe043423          	sd	zero,-24(s0)
    800121ba:	a811                	j	800121ce <page_init+0x7e>
        set_taken(i);
    800121bc:	fe843503          	ld	a0,-24(s0)
    800121c0:	d25ff0ef          	jal	ra,80011ee4 <set_taken>
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    800121c4:	fe843783          	ld	a5,-24(s0)
    800121c8:	0785                	addi	a5,a5,1
    800121ca:	fef43423          	sd	a5,-24(s0)
    800121ce:	07ffe717          	auipc	a4,0x7ffe
    800121d2:	e3270713          	addi	a4,a4,-462 # 88010000 <_heap_end>
    800121d6:	00012797          	auipc	a5,0x12
    800121da:	e2a78793          	addi	a5,a5,-470 # 80024000 <_heap_start>
    800121de:	40f707b3          	sub	a5,a4,a5
    800121e2:	00e7d713          	srli	a4,a5,0xe
    800121e6:	6785                	lui	a5,0x1
    800121e8:	17fd                	addi	a5,a5,-1
    800121ea:	97ba                	add	a5,a5,a4
    800121ec:	83b1                	srli	a5,a5,0xc
    800121ee:	fe843703          	ld	a4,-24(s0)
    800121f2:	fcf765e3          	bltu	a4,a5,800121bc <page_init+0x6c>
    }
    set_last(BK_SIZE_IN_PAGES - 1);
    800121f6:	07ffe717          	auipc	a4,0x7ffe
    800121fa:	e0a70713          	addi	a4,a4,-502 # 88010000 <_heap_end>
    800121fe:	00012797          	auipc	a5,0x12
    80012202:	e0278793          	addi	a5,a5,-510 # 80024000 <_heap_start>
    80012206:	40f707b3          	sub	a5,a4,a5
    8001220a:	00e7d713          	srli	a4,a5,0xe
    8001220e:	6785                	lui	a5,0x1
    80012210:	17fd                	addi	a5,a5,-1
    80012212:	97ba                	add	a5,a5,a4
    80012214:	83b1                	srli	a5,a5,0xc
    80012216:	17fd                	addi	a5,a5,-1
    80012218:	853e                	mv	a0,a5
    8001221a:	dfbff0ef          	jal	ra,80012014 <set_last>

    // Print out the bookkeeping area's contents
    mutex_unlock(&page_lock);
    8001221e:	00006517          	auipc	a0,0x6
    80012222:	dea50513          	addi	a0,a0,-534 # 80018008 <page_lock>
    80012226:	c2afe0ef          	jal	ra,80010650 <mutex_unlock>

    logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    8001222a:	00006797          	auipc	a5,0x6
    8001222e:	e2678793          	addi	a5,a5,-474 # 80018050 <bookkeeping>
    80012232:	6390                	ld	a2,0(a5)
    80012234:	00006797          	auipc	a5,0x6
    80012238:	e1c78793          	addi	a5,a5,-484 # 80018050 <bookkeeping>
    8001223c:	6398                	ld	a4,0(a5)
    8001223e:	07ffe697          	auipc	a3,0x7ffe
    80012242:	dc268693          	addi	a3,a3,-574 # 88010000 <_heap_end>
    80012246:	00012797          	auipc	a5,0x12
    8001224a:	dba78793          	addi	a5,a5,-582 # 80024000 <_heap_start>
    8001224e:	40f687b3          	sub	a5,a3,a5
    80012252:	00e7d693          	srli	a3,a5,0xe
    80012256:	6785                	lui	a5,0x1
    80012258:	17fd                	addi	a5,a5,-1
    8001225a:	96be                	add	a3,a3,a5
    8001225c:	77fd                	lui	a5,0xfffff
    8001225e:	8ff5                	and	a5,a5,a3
    80012260:	97ba                	add	a5,a5,a4
    80012262:	86be                	mv	a3,a5
    80012264:	00007597          	auipc	a1,0x7
    80012268:	24458593          	addi	a1,a1,580 # 800194a8 <SYSCALLS+0x4a8>
    8001226c:	4511                	li	a0,4
    8001226e:	e12ff0ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    80012272:	07ffe717          	auipc	a4,0x7ffe
    80012276:	d8e70713          	addi	a4,a4,-626 # 88010000 <_heap_end>
    8001227a:	00012797          	auipc	a5,0x12
    8001227e:	d8678793          	addi	a5,a5,-634 # 80024000 <_heap_start>
    80012282:	40f70633          	sub	a2,a4,a5
    80012286:	07ffe717          	auipc	a4,0x7ffe
    8001228a:	d7a70713          	addi	a4,a4,-646 # 88010000 <_heap_end>
    8001228e:	00012797          	auipc	a5,0x12
    80012292:	d7278793          	addi	a5,a5,-654 # 80024000 <_heap_start>
    80012296:	40f707b3          	sub	a5,a4,a5
    8001229a:	83b1                	srli	a5,a5,0xc
    8001229c:	86be                	mv	a3,a5
    8001229e:	00007597          	auipc	a1,0x7
    800122a2:	22a58593          	addi	a1,a1,554 # 800194c8 <SYSCALLS+0x4c8>
    800122a6:	4511                	li	a0,4
    800122a8:	dd8ff0ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    800122ac:	07ffe717          	auipc	a4,0x7ffe
    800122b0:	d5470713          	addi	a4,a4,-684 # 88010000 <_heap_end>
    800122b4:	00012797          	auipc	a5,0x12
    800122b8:	d4c78793          	addi	a5,a5,-692 # 80024000 <_heap_start>
    800122bc:	40f707b3          	sub	a5,a4,a5
    800122c0:	00e7d713          	srli	a4,a5,0xe
    800122c4:	6785                	lui	a5,0x1
    800122c6:	17fd                	addi	a5,a5,-1
    800122c8:	973e                	add	a4,a4,a5
    800122ca:	77fd                	lui	a5,0xfffff
    800122cc:	00f77633          	and	a2,a4,a5
    800122d0:	07ffe717          	auipc	a4,0x7ffe
    800122d4:	d3070713          	addi	a4,a4,-720 # 88010000 <_heap_end>
    800122d8:	00012797          	auipc	a5,0x12
    800122dc:	d2878793          	addi	a5,a5,-728 # 80024000 <_heap_start>
    800122e0:	40f707b3          	sub	a5,a4,a5
    800122e4:	00e7d713          	srli	a4,a5,0xe
    800122e8:	6785                	lui	a5,0x1
    800122ea:	17fd                	addi	a5,a5,-1
    800122ec:	97ba                	add	a5,a5,a4
    800122ee:	83b1                	srli	a5,a5,0xc
    800122f0:	86be                	mv	a3,a5
    800122f2:	00007597          	auipc	a1,0x7
    800122f6:	1fe58593          	addi	a1,a1,510 # 800194f0 <SYSCALLS+0x4f0>
    800122fa:	4511                	li	a0,4
    800122fc:	d84ff0ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    80012300:	308000ef          	jal	ra,80012608 <page_count_taken>
    80012304:	87aa                	mv	a5,a0
    80012306:	863e                	mv	a2,a5
    80012308:	00007597          	auipc	a1,0x7
    8001230c:	21858593          	addi	a1,a1,536 # 80019520 <SYSCALLS+0x520>
    80012310:	4511                	li	a0,4
    80012312:	d6eff0ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
    80012316:	27c000ef          	jal	ra,80012592 <page_count_free>
    8001231a:	87aa                	mv	a5,a0
    8001231c:	863e                	mv	a2,a5
    8001231e:	00007597          	auipc	a1,0x7
    80012322:	21a58593          	addi	a1,a1,538 # 80019538 <SYSCALLS+0x538>
    80012326:	4511                	li	a0,4
    80012328:	d58ff0ef          	jal	ra,80011880 <logf>
    logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
    */
}
    8001232c:	0001                	nop
    8001232e:	60e2                	ld	ra,24(sp)
    80012330:	6442                	ld	s0,16(sp)
    80012332:	6105                	addi	sp,sp,32
    80012334:	8082                	ret

0000000080012336 <page_nalloc>:

void *page_nalloc(int n)
{
    80012336:	7139                	addi	sp,sp,-64
    80012338:	fc06                	sd	ra,56(sp)
    8001233a:	f822                	sd	s0,48(sp)
    8001233c:	0080                	addi	s0,sp,64
    8001233e:	87aa                	mv	a5,a0
    80012340:	fcf42623          	sw	a5,-52(s0)
    if (n <= 0) {
    80012344:	fcc42783          	lw	a5,-52(s0)
    80012348:	2781                	sext.w	a5,a5
    8001234a:	00f04463          	bgtz	a5,80012352 <page_nalloc+0x1c>
        return NULL;
    8001234e:	4781                	li	a5,0
    80012350:	aaa9                	j	800124aa <page_nalloc+0x174>
    }

    mutex_spinlock(&page_lock);
    80012352:	00006517          	auipc	a0,0x6
    80012356:	cb650513          	addi	a0,a0,-842 # 80018008 <page_lock>
    8001235a:	ac8fe0ef          	jal	ra,80010622 <mutex_spinlock>

    int start = 0;
    8001235e:	fe042623          	sw	zero,-20(s0)
    int consecutive = 0;
    80012362:	fe042423          	sw	zero,-24(s0)

    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80012366:	fe043023          	sd	zero,-32(s0)
    8001236a:	aa11                	j	8001247e <page_nalloc+0x148>
        if (!is_taken(i)) {
    8001236c:	fe043503          	ld	a0,-32(s0)
    80012370:	c5dff0ef          	jal	ra,80011fcc <is_taken>
    80012374:	87aa                	mv	a5,a0
    80012376:	0e079563          	bnez	a5,80012460 <page_nalloc+0x12a>
            if (consecutive == 0) {
    8001237a:	fe842783          	lw	a5,-24(s0)
    8001237e:	2781                	sext.w	a5,a5
    80012380:	e789                	bnez	a5,8001238a <page_nalloc+0x54>
                start = i;
    80012382:	fe043783          	ld	a5,-32(s0)
    80012386:	fef42623          	sw	a5,-20(s0)
            }

            consecutive++;
    8001238a:	fe842783          	lw	a5,-24(s0)
    8001238e:	2785                	addiw	a5,a5,1
    80012390:	fef42423          	sw	a5,-24(s0)

            if (consecutive >= n) {
    80012394:	fe842703          	lw	a4,-24(s0)
    80012398:	fcc42783          	lw	a5,-52(s0)
    8001239c:	2701                	sext.w	a4,a4
    8001239e:	2781                	sext.w	a5,a5
    800123a0:	0cf74a63          	blt	a4,a5,80012474 <page_nalloc+0x13e>
                debugf("page_nalloc: found %d consecutive pages starting at 0x%08lx\n", n, start);
    800123a4:	fec42703          	lw	a4,-20(s0)
    800123a8:	fcc42783          	lw	a5,-52(s0)
    800123ac:	863a                	mv	a2,a4
    800123ae:	85be                	mv	a1,a5
    800123b0:	00007517          	auipc	a0,0x7
    800123b4:	1a050513          	addi	a0,a0,416 # 80019550 <SYSCALLS+0x550>
    800123b8:	d26ff0ef          	jal	ra,800118de <debugf>
                for (int j = 0; j < n; j++) {
    800123bc:	fc042e23          	sw	zero,-36(s0)
    800123c0:	a825                	j	800123f8 <page_nalloc+0xc2>
                    debugf("page_nalloc: marking page 0x%08lx as taken\n", start + j);
    800123c2:	fec42703          	lw	a4,-20(s0)
    800123c6:	fdc42783          	lw	a5,-36(s0)
    800123ca:	9fb9                	addw	a5,a5,a4
    800123cc:	2781                	sext.w	a5,a5
    800123ce:	85be                	mv	a1,a5
    800123d0:	00007517          	auipc	a0,0x7
    800123d4:	1c050513          	addi	a0,a0,448 # 80019590 <SYSCALLS+0x590>
    800123d8:	d06ff0ef          	jal	ra,800118de <debugf>
                    set_taken(start + j);
    800123dc:	fec42703          	lw	a4,-20(s0)
    800123e0:	fdc42783          	lw	a5,-36(s0)
    800123e4:	9fb9                	addw	a5,a5,a4
    800123e6:	2781                	sext.w	a5,a5
    800123e8:	853e                	mv	a0,a5
    800123ea:	afbff0ef          	jal	ra,80011ee4 <set_taken>
                for (int j = 0; j < n; j++) {
    800123ee:	fdc42783          	lw	a5,-36(s0)
    800123f2:	2785                	addiw	a5,a5,1
    800123f4:	fcf42e23          	sw	a5,-36(s0)
    800123f8:	fdc42703          	lw	a4,-36(s0)
    800123fc:	fcc42783          	lw	a5,-52(s0)
    80012400:	2701                	sext.w	a4,a4
    80012402:	2781                	sext.w	a5,a5
    80012404:	faf74fe3          	blt	a4,a5,800123c2 <page_nalloc+0x8c>
                }
                debugf("page_nalloc: marking page 0x%08lx as last\n", start + n - 1);
    80012408:	fec42703          	lw	a4,-20(s0)
    8001240c:	fcc42783          	lw	a5,-52(s0)
    80012410:	9fb9                	addw	a5,a5,a4
    80012412:	2781                	sext.w	a5,a5
    80012414:	37fd                	addiw	a5,a5,-1
    80012416:	2781                	sext.w	a5,a5
    80012418:	85be                	mv	a1,a5
    8001241a:	00007517          	auipc	a0,0x7
    8001241e:	1a650513          	addi	a0,a0,422 # 800195c0 <SYSCALLS+0x5c0>
    80012422:	cbcff0ef          	jal	ra,800118de <debugf>
                set_last(start + n - 1);
    80012426:	fec42703          	lw	a4,-20(s0)
    8001242a:	fcc42783          	lw	a5,-52(s0)
    8001242e:	9fb9                	addw	a5,a5,a4
    80012430:	2781                	sext.w	a5,a5
    80012432:	37fd                	addiw	a5,a5,-1
    80012434:	2781                	sext.w	a5,a5
    80012436:	853e                	mv	a0,a5
    80012438:	bddff0ef          	jal	ra,80012014 <set_last>

                mutex_unlock(&page_lock);
    8001243c:	00006517          	auipc	a0,0x6
    80012440:	bcc50513          	addi	a0,a0,-1076 # 80018008 <page_lock>
    80012444:	a0cfe0ef          	jal	ra,80010650 <mutex_unlock>
                return (void *)(bookkeeping + start * PAGE_SIZE);
    80012448:	00006797          	auipc	a5,0x6
    8001244c:	c0878793          	addi	a5,a5,-1016 # 80018050 <bookkeeping>
    80012450:	639c                	ld	a5,0(a5)
    80012452:	fec42703          	lw	a4,-20(s0)
    80012456:	00c7171b          	slliw	a4,a4,0xc
    8001245a:	2701                	sext.w	a4,a4
    8001245c:	97ba                	add	a5,a5,a4
    8001245e:	a0b1                	j	800124aa <page_nalloc+0x174>
            }
        } else {
            debugf("page_nalloc: page 0x%08lx is taken\n", i);
    80012460:	fe043583          	ld	a1,-32(s0)
    80012464:	00007517          	auipc	a0,0x7
    80012468:	18c50513          	addi	a0,a0,396 # 800195f0 <SYSCALLS+0x5f0>
    8001246c:	c72ff0ef          	jal	ra,800118de <debugf>
            consecutive = 0;
    80012470:	fe042423          	sw	zero,-24(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80012474:	fe043783          	ld	a5,-32(s0)
    80012478:	0785                	addi	a5,a5,1
    8001247a:	fef43023          	sd	a5,-32(s0)
    8001247e:	07ffe717          	auipc	a4,0x7ffe
    80012482:	b8270713          	addi	a4,a4,-1150 # 88010000 <_heap_end>
    80012486:	00012797          	auipc	a5,0x12
    8001248a:	b7a78793          	addi	a5,a5,-1158 # 80024000 <_heap_start>
    8001248e:	40f707b3          	sub	a5,a4,a5
    80012492:	83b1                	srli	a5,a5,0xc
    80012494:	fe043703          	ld	a4,-32(s0)
    80012498:	ecf76ae3          	bltu	a4,a5,8001236c <page_nalloc+0x36>
        }
    }

    mutex_unlock(&page_lock);
    8001249c:	00006517          	auipc	a0,0x6
    800124a0:	b6c50513          	addi	a0,a0,-1172 # 80018008 <page_lock>
    800124a4:	9acfe0ef          	jal	ra,80010650 <mutex_unlock>
    return NULL;
    800124a8:	4781                	li	a5,0
}
    800124aa:	853e                	mv	a0,a5
    800124ac:	70e2                	ld	ra,56(sp)
    800124ae:	7442                	ld	s0,48(sp)
    800124b0:	6121                	addi	sp,sp,64
    800124b2:	8082                	ret

00000000800124b4 <page_znalloc>:

void *page_znalloc(int n)
{
    800124b4:	1101                	addi	sp,sp,-32
    800124b6:	ec22                	sd	s0,24(sp)
    800124b8:	1000                	addi	s0,sp,32
    800124ba:	87aa                	mv	a5,a0
    800124bc:	fef42623          	sw	a5,-20(s0)
    return NULL;
    800124c0:	4781                	li	a5,0
    void *mem = page_nalloc(n);
    if (mem) {
        memset(mem, 0, n * PAGE_SIZE);
    }
    return mem;
}
    800124c2:	853e                	mv	a0,a5
    800124c4:	6462                	ld	s0,24(sp)
    800124c6:	6105                	addi	sp,sp,32
    800124c8:	8082                	ret

00000000800124ca <page_free>:

void page_free(void *p)
{
    800124ca:	7179                	addi	sp,sp,-48
    800124cc:	f406                	sd	ra,40(sp)
    800124ce:	f022                	sd	s0,32(sp)
    800124d0:	1800                	addi	s0,sp,48
    800124d2:	fca43c23          	sd	a0,-40(s0)
    if (p == NULL) {
    800124d6:	fd843783          	ld	a5,-40(s0)
    800124da:	c7dd                	beqz	a5,80012588 <page_free+0xbe>
        return;
    }
    /* Free the page */
    uint64_t x = ((uint64_t)p - (uint64_t)bookkeeping) / PAGE_SIZE;
    800124dc:	fd843783          	ld	a5,-40(s0)
    800124e0:	00006717          	auipc	a4,0x6
    800124e4:	b7070713          	addi	a4,a4,-1168 # 80018050 <bookkeeping>
    800124e8:	6318                	ld	a4,0(a4)
    800124ea:	8f99                	sub	a5,a5,a4
    800124ec:	83b1                	srli	a5,a5,0xc
    800124ee:	fef43423          	sd	a5,-24(s0)
    logf(LOG_INFO, "page_free: freeing page %lu at address 0x%p\n", x, p);
    800124f2:	fd843683          	ld	a3,-40(s0)
    800124f6:	fe843603          	ld	a2,-24(s0)
    800124fa:	00007597          	auipc	a1,0x7
    800124fe:	11e58593          	addi	a1,a1,286 # 80019618 <SYSCALLS+0x618>
    80012502:	4511                	li	a0,4
    80012504:	b7cff0ef          	jal	ra,80011880 <logf>

    mutex_spinlock(&page_lock);
    80012508:	00006517          	auipc	a0,0x6
    8001250c:	b0050513          	addi	a0,a0,-1280 # 80018008 <page_lock>
    80012510:	912fe0ef          	jal	ra,80010622 <mutex_spinlock>


    if (!is_taken(x)) {
    80012514:	fe843503          	ld	a0,-24(s0)
    80012518:	ab5ff0ef          	jal	ra,80011fcc <is_taken>
    8001251c:	87aa                	mv	a5,a0
    8001251e:	eb95                	bnez	a5,80012552 <page_free+0x88>
        logf(LOG_ERROR, "page_free: page 0x%08lx is already free!\n", x);
    80012520:	fe843603          	ld	a2,-24(s0)
    80012524:	00007597          	auipc	a1,0x7
    80012528:	12458593          	addi	a1,a1,292 # 80019648 <SYSCALLS+0x648>
    8001252c:	4505                	li	a0,1
    8001252e:	b52ff0ef          	jal	ra,80011880 <logf>
        mutex_unlock(&page_lock);
    80012532:	00006517          	auipc	a0,0x6
    80012536:	ad650513          	addi	a0,a0,-1322 # 80018008 <page_lock>
    8001253a:	916fe0ef          	jal	ra,80010650 <mutex_unlock>
        return;
    8001253e:	a0b1                	j	8001258a <page_free+0xc0>
    }

    // Clear all the pages starting at the index until the last page
    while (is_taken(x) && !is_last(x)) {
        clear_taken(x);
    80012540:	fe843503          	ld	a0,-24(s0)
    80012544:	a0fff0ef          	jal	ra,80011f52 <clear_taken>
        x++;
    80012548:	fe843783          	ld	a5,-24(s0)
    8001254c:	0785                	addi	a5,a5,1
    8001254e:	fef43423          	sd	a5,-24(s0)
    while (is_taken(x) && !is_last(x)) {
    80012552:	fe843503          	ld	a0,-24(s0)
    80012556:	a77ff0ef          	jal	ra,80011fcc <is_taken>
    8001255a:	87aa                	mv	a5,a0
    8001255c:	c799                	beqz	a5,8001256a <page_free+0xa0>
    8001255e:	fe843503          	ld	a0,-24(s0)
    80012562:	ba3ff0ef          	jal	ra,80012104 <is_last>
    80012566:	87aa                	mv	a5,a0
    80012568:	dfe1                	beqz	a5,80012540 <page_free+0x76>
    }
    clear_taken(x);
    8001256a:	fe843503          	ld	a0,-24(s0)
    8001256e:	9e5ff0ef          	jal	ra,80011f52 <clear_taken>
    clear_last(x);
    80012572:	fe843503          	ld	a0,-24(s0)
    80012576:	b11ff0ef          	jal	ra,80012086 <clear_last>


    mutex_unlock(&page_lock);
    8001257a:	00006517          	auipc	a0,0x6
    8001257e:	a8e50513          	addi	a0,a0,-1394 # 80018008 <page_lock>
    80012582:	8cefe0ef          	jal	ra,80010650 <mutex_unlock>
    80012586:	a011                	j	8001258a <page_free+0xc0>
        return;
    80012588:	0001                	nop
}
    8001258a:	70a2                	ld	ra,40(sp)
    8001258c:	7402                	ld	s0,32(sp)
    8001258e:	6145                	addi	sp,sp,48
    80012590:	8082                	ret

0000000080012592 <page_count_free>:

int page_count_free(void)
{
    80012592:	1101                	addi	sp,sp,-32
    80012594:	ec06                	sd	ra,24(sp)
    80012596:	e822                	sd	s0,16(sp)
    80012598:	1000                	addi	s0,sp,32
    int ret = 0;
    8001259a:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract taken. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract taken pages from it.
    */

    mutex_spinlock(&page_lock);
    8001259e:	00006517          	auipc	a0,0x6
    800125a2:	a6a50513          	addi	a0,a0,-1430 # 80018008 <page_lock>
    800125a6:	87cfe0ef          	jal	ra,80010622 <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    800125aa:	fe043023          	sd	zero,-32(s0)
    800125ae:	a00d                	j	800125d0 <page_count_free+0x3e>
       if (!is_taken(i)) {
    800125b0:	fe043503          	ld	a0,-32(s0)
    800125b4:	a19ff0ef          	jal	ra,80011fcc <is_taken>
    800125b8:	87aa                	mv	a5,a0
    800125ba:	e791                	bnez	a5,800125c6 <page_count_free+0x34>
           ret++;
    800125bc:	fec42783          	lw	a5,-20(s0)
    800125c0:	2785                	addiw	a5,a5,1
    800125c2:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    800125c6:	fe043783          	ld	a5,-32(s0)
    800125ca:	0785                	addi	a5,a5,1
    800125cc:	fef43023          	sd	a5,-32(s0)
    800125d0:	07ffe717          	auipc	a4,0x7ffe
    800125d4:	a3070713          	addi	a4,a4,-1488 # 88010000 <_heap_end>
    800125d8:	00012797          	auipc	a5,0x12
    800125dc:	a2878793          	addi	a5,a5,-1496 # 80024000 <_heap_start>
    800125e0:	40f707b3          	sub	a5,a4,a5
    800125e4:	83b1                	srli	a5,a5,0xc
    800125e6:	fe043703          	ld	a4,-32(s0)
    800125ea:	fcf763e3          	bltu	a4,a5,800125b0 <page_count_free+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    800125ee:	00006517          	auipc	a0,0x6
    800125f2:	a1a50513          	addi	a0,a0,-1510 # 80018008 <page_lock>
    800125f6:	85afe0ef          	jal	ra,80010650 <mutex_unlock>

    return ret;
    800125fa:	fec42783          	lw	a5,-20(s0)
}
    800125fe:	853e                	mv	a0,a5
    80012600:	60e2                	ld	ra,24(sp)
    80012602:	6442                	ld	s0,16(sp)
    80012604:	6105                	addi	sp,sp,32
    80012606:	8082                	ret

0000000080012608 <page_count_taken>:

int page_count_taken(void)
{
    80012608:	1101                	addi	sp,sp,-32
    8001260a:	ec06                	sd	ra,24(sp)
    8001260c:	e822                	sd	s0,16(sp)
    8001260e:	1000                	addi	s0,sp,32
    int ret = 0;
    80012610:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract free. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract free pages from it.
    */

    mutex_spinlock(&page_lock);
    80012614:	00006517          	auipc	a0,0x6
    80012618:	9f450513          	addi	a0,a0,-1548 # 80018008 <page_lock>
    8001261c:	806fe0ef          	jal	ra,80010622 <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80012620:	fe043023          	sd	zero,-32(s0)
    80012624:	a00d                	j	80012646 <page_count_taken+0x3e>
       if (is_taken(i)) {
    80012626:	fe043503          	ld	a0,-32(s0)
    8001262a:	9a3ff0ef          	jal	ra,80011fcc <is_taken>
    8001262e:	87aa                	mv	a5,a0
    80012630:	c791                	beqz	a5,8001263c <page_count_taken+0x34>
           ret++;
    80012632:	fec42783          	lw	a5,-20(s0)
    80012636:	2785                	addiw	a5,a5,1
    80012638:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001263c:	fe043783          	ld	a5,-32(s0)
    80012640:	0785                	addi	a5,a5,1
    80012642:	fef43023          	sd	a5,-32(s0)
    80012646:	07ffe717          	auipc	a4,0x7ffe
    8001264a:	9ba70713          	addi	a4,a4,-1606 # 88010000 <_heap_end>
    8001264e:	00012797          	auipc	a5,0x12
    80012652:	9b278793          	addi	a5,a5,-1614 # 80024000 <_heap_start>
    80012656:	40f707b3          	sub	a5,a4,a5
    8001265a:	83b1                	srli	a5,a5,0xc
    8001265c:	fe043703          	ld	a4,-32(s0)
    80012660:	fcf763e3          	bltu	a4,a5,80012626 <page_count_taken+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    80012664:	00006517          	auipc	a0,0x6
    80012668:	9a450513          	addi	a0,a0,-1628 # 80018008 <page_lock>
    8001266c:	fe5fd0ef          	jal	ra,80010650 <mutex_unlock>

    return ret;
    80012670:	fec42783          	lw	a5,-20(s0)
    80012674:	853e                	mv	a0,a5
    80012676:	60e2                	ld	ra,24(sp)
    80012678:	6442                	ld	s0,16(sp)
    8001267a:	6105                	addi	sp,sp,32
    8001267c:	8082                	ret

000000008001267e <_putchar>:
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#include "sbi.h"
void _putchar(char c) { sbi_putchar(c); }
    8001267e:	1101                	addi	sp,sp,-32
    80012680:	ec06                	sd	ra,24(sp)
    80012682:	e822                	sd	s0,16(sp)
    80012684:	1000                	addi	s0,sp,32
    80012686:	87aa                	mv	a5,a0
    80012688:	fef407a3          	sb	a5,-17(s0)
    8001268c:	fef44783          	lbu	a5,-17(s0)
    80012690:	853e                	mv	a0,a5
    80012692:	b64ff0ef          	jal	ra,800119f6 <sbi_putchar>
    80012696:	0001                	nop
    80012698:	60e2                	ld	ra,24(sp)
    8001269a:	6442                	ld	s0,16(sp)
    8001269c:	6105                	addi	sp,sp,32
    8001269e:	8082                	ret

00000000800126a0 <_out_buffer>:
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx,
                               size_t maxlen)
{
    800126a0:	7179                	addi	sp,sp,-48
    800126a2:	f422                	sd	s0,40(sp)
    800126a4:	1800                	addi	s0,sp,48
    800126a6:	87aa                	mv	a5,a0
    800126a8:	feb43023          	sd	a1,-32(s0)
    800126ac:	fcc43c23          	sd	a2,-40(s0)
    800126b0:	fcd43823          	sd	a3,-48(s0)
    800126b4:	fef407a3          	sb	a5,-17(s0)
    if (idx < maxlen) {
    800126b8:	fd843703          	ld	a4,-40(s0)
    800126bc:	fd043783          	ld	a5,-48(s0)
    800126c0:	00f77b63          	bgeu	a4,a5,800126d6 <_out_buffer+0x36>
        ((char *)buffer)[idx] = character;
    800126c4:	fe043703          	ld	a4,-32(s0)
    800126c8:	fd843783          	ld	a5,-40(s0)
    800126cc:	97ba                	add	a5,a5,a4
    800126ce:	fef44703          	lbu	a4,-17(s0)
    800126d2:	00e78023          	sb	a4,0(a5)
    }
}
    800126d6:	0001                	nop
    800126d8:	7422                	ld	s0,40(sp)
    800126da:	6145                	addi	sp,sp,48
    800126dc:	8082                	ret

00000000800126de <_out_null>:

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800126de:	7179                	addi	sp,sp,-48
    800126e0:	f422                	sd	s0,40(sp)
    800126e2:	1800                	addi	s0,sp,48
    800126e4:	87aa                	mv	a5,a0
    800126e6:	feb43023          	sd	a1,-32(s0)
    800126ea:	fcc43c23          	sd	a2,-40(s0)
    800126ee:	fcd43823          	sd	a3,-48(s0)
    800126f2:	fef407a3          	sb	a5,-17(s0)
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}
    800126f6:	0001                	nop
    800126f8:	7422                	ld	s0,40(sp)
    800126fa:	6145                	addi	sp,sp,48
    800126fc:	8082                	ret

00000000800126fe <_out_char>:

// internal _putchar wrapper
static inline void _out_char(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800126fe:	7179                	addi	sp,sp,-48
    80012700:	f406                	sd	ra,40(sp)
    80012702:	f022                	sd	s0,32(sp)
    80012704:	1800                	addi	s0,sp,48
    80012706:	87aa                	mv	a5,a0
    80012708:	feb43023          	sd	a1,-32(s0)
    8001270c:	fcc43c23          	sd	a2,-40(s0)
    80012710:	fcd43823          	sd	a3,-48(s0)
    80012714:	fef407a3          	sb	a5,-17(s0)
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
    80012718:	fef44783          	lbu	a5,-17(s0)
    8001271c:	0ff7f793          	andi	a5,a5,255
    80012720:	c791                	beqz	a5,8001272c <_out_char+0x2e>
        _putchar(character);
    80012722:	fef44783          	lbu	a5,-17(s0)
    80012726:	853e                	mv	a0,a5
    80012728:	f57ff0ef          	jal	ra,8001267e <_putchar>
    }
}
    8001272c:	0001                	nop
    8001272e:	70a2                	ld	ra,40(sp)
    80012730:	7402                	ld	s0,32(sp)
    80012732:	6145                	addi	sp,sp,48
    80012734:	8082                	ret

0000000080012736 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx,
                            size_t maxlen)
{
    80012736:	7179                	addi	sp,sp,-48
    80012738:	f406                	sd	ra,40(sp)
    8001273a:	f022                	sd	s0,32(sp)
    8001273c:	1800                	addi	s0,sp,48
    8001273e:	87aa                	mv	a5,a0
    80012740:	feb43023          	sd	a1,-32(s0)
    80012744:	fcc43c23          	sd	a2,-40(s0)
    80012748:	fcd43823          	sd	a3,-48(s0)
    8001274c:	fef407a3          	sb	a5,-17(s0)
    (void)idx;
    (void)maxlen;
    if (character) {
    80012750:	fef44783          	lbu	a5,-17(s0)
    80012754:	0ff7f793          	andi	a5,a5,255
    80012758:	cf81                	beqz	a5,80012770 <_out_fct+0x3a>
        // buffer is the output fct pointer
        ((out_fct_wrap_type *)buffer)
            ->fct(character, ((out_fct_wrap_type *)buffer)->arg);
    8001275a:	fe043783          	ld	a5,-32(s0)
    8001275e:	6394                	ld	a3,0(a5)
        ((out_fct_wrap_type *)buffer)
    80012760:	fe043783          	ld	a5,-32(s0)
    80012764:	6798                	ld	a4,8(a5)
    80012766:	fef44783          	lbu	a5,-17(s0)
    8001276a:	85ba                	mv	a1,a4
    8001276c:	853e                	mv	a0,a5
    8001276e:	9682                	jalr	a3
    }
}
    80012770:	0001                	nop
    80012772:	70a2                	ld	ra,40(sp)
    80012774:	7402                	ld	s0,32(sp)
    80012776:	6145                	addi	sp,sp,48
    80012778:	8082                	ret

000000008001277a <_strnlen_s>:

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize)
{
    8001277a:	7179                	addi	sp,sp,-48
    8001277c:	f422                	sd	s0,40(sp)
    8001277e:	1800                	addi	s0,sp,48
    80012780:	fca43c23          	sd	a0,-40(s0)
    80012784:	fcb43823          	sd	a1,-48(s0)
    const char *s;
    for (s = str; *s && maxsize--; ++s)
    80012788:	fd843783          	ld	a5,-40(s0)
    8001278c:	fef43423          	sd	a5,-24(s0)
    80012790:	a031                	j	8001279c <_strnlen_s+0x22>
    80012792:	fe843783          	ld	a5,-24(s0)
    80012796:	0785                	addi	a5,a5,1
    80012798:	fef43423          	sd	a5,-24(s0)
    8001279c:	fe843783          	ld	a5,-24(s0)
    800127a0:	0007c783          	lbu	a5,0(a5)
    800127a4:	cb81                	beqz	a5,800127b4 <_strnlen_s+0x3a>
    800127a6:	fd043783          	ld	a5,-48(s0)
    800127aa:	fff78713          	addi	a4,a5,-1
    800127ae:	fce43823          	sd	a4,-48(s0)
    800127b2:	f3e5                	bnez	a5,80012792 <_strnlen_s+0x18>
        ;
    return (unsigned int)(s - str);
    800127b4:	fe843703          	ld	a4,-24(s0)
    800127b8:	fd843783          	ld	a5,-40(s0)
    800127bc:	40f707b3          	sub	a5,a4,a5
    800127c0:	2781                	sext.w	a5,a5
}
    800127c2:	853e                	mv	a0,a5
    800127c4:	7422                	ld	s0,40(sp)
    800127c6:	6145                	addi	sp,sp,48
    800127c8:	8082                	ret

00000000800127ca <_is_digit>:

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) { return (ch >= '0') && (ch <= '9'); }
    800127ca:	1101                	addi	sp,sp,-32
    800127cc:	ec22                	sd	s0,24(sp)
    800127ce:	1000                	addi	s0,sp,32
    800127d0:	87aa                	mv	a5,a0
    800127d2:	fef407a3          	sb	a5,-17(s0)
    800127d6:	fef44783          	lbu	a5,-17(s0)
    800127da:	0ff7f713          	andi	a4,a5,255
    800127de:	02f00793          	li	a5,47
    800127e2:	00e7fc63          	bgeu	a5,a4,800127fa <_is_digit+0x30>
    800127e6:	fef44783          	lbu	a5,-17(s0)
    800127ea:	0ff7f713          	andi	a4,a5,255
    800127ee:	03900793          	li	a5,57
    800127f2:	00e7e463          	bltu	a5,a4,800127fa <_is_digit+0x30>
    800127f6:	4785                	li	a5,1
    800127f8:	a011                	j	800127fc <_is_digit+0x32>
    800127fa:	4781                	li	a5,0
    800127fc:	8b85                	andi	a5,a5,1
    800127fe:	0ff7f793          	andi	a5,a5,255
    80012802:	853e                	mv	a0,a5
    80012804:	6462                	ld	s0,24(sp)
    80012806:	6105                	addi	sp,sp,32
    80012808:	8082                	ret

000000008001280a <_atoi>:

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str)
{
    8001280a:	7179                	addi	sp,sp,-48
    8001280c:	f406                	sd	ra,40(sp)
    8001280e:	f022                	sd	s0,32(sp)
    80012810:	1800                	addi	s0,sp,48
    80012812:	fca43c23          	sd	a0,-40(s0)
    unsigned int i = 0U;
    80012816:	fe042623          	sw	zero,-20(s0)
    while (_is_digit(**str)) {
    8001281a:	a825                	j	80012852 <_atoi+0x48>
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
    8001281c:	fec42703          	lw	a4,-20(s0)
    80012820:	87ba                	mv	a5,a4
    80012822:	0027979b          	slliw	a5,a5,0x2
    80012826:	9fb9                	addw	a5,a5,a4
    80012828:	0017979b          	slliw	a5,a5,0x1
    8001282c:	0007871b          	sext.w	a4,a5
    80012830:	fd843783          	ld	a5,-40(s0)
    80012834:	639c                	ld	a5,0(a5)
    80012836:	00178613          	addi	a2,a5,1
    8001283a:	fd843683          	ld	a3,-40(s0)
    8001283e:	e290                	sd	a2,0(a3)
    80012840:	0007c783          	lbu	a5,0(a5)
    80012844:	2781                	sext.w	a5,a5
    80012846:	9fb9                	addw	a5,a5,a4
    80012848:	2781                	sext.w	a5,a5
    8001284a:	fd07879b          	addiw	a5,a5,-48
    8001284e:	fef42623          	sw	a5,-20(s0)
    while (_is_digit(**str)) {
    80012852:	fd843783          	ld	a5,-40(s0)
    80012856:	639c                	ld	a5,0(a5)
    80012858:	0007c783          	lbu	a5,0(a5)
    8001285c:	853e                	mv	a0,a5
    8001285e:	f6dff0ef          	jal	ra,800127ca <_is_digit>
    80012862:	87aa                	mv	a5,a0
    80012864:	ffc5                	bnez	a5,8001281c <_atoi+0x12>
    }
    return i;
    80012866:	fec42783          	lw	a5,-20(s0)
}
    8001286a:	853e                	mv	a0,a5
    8001286c:	70a2                	ld	ra,40(sp)
    8001286e:	7402                	ld	s0,32(sp)
    80012870:	6145                	addi	sp,sp,48
    80012872:	8082                	ret

0000000080012874 <_out_rev>:

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx,
                       size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags)
{
    80012874:	711d                	addi	sp,sp,-96
    80012876:	ec86                	sd	ra,88(sp)
    80012878:	e8a2                	sd	s0,80(sp)
    8001287a:	1080                	addi	s0,sp,96
    8001287c:	fca43c23          	sd	a0,-40(s0)
    80012880:	fcb43823          	sd	a1,-48(s0)
    80012884:	fcc43423          	sd	a2,-56(s0)
    80012888:	fcd43023          	sd	a3,-64(s0)
    8001288c:	fae43c23          	sd	a4,-72(s0)
    80012890:	faf43823          	sd	a5,-80(s0)
    80012894:	87c2                	mv	a5,a6
    80012896:	8746                	mv	a4,a7
    80012898:	faf42623          	sw	a5,-84(s0)
    8001289c:	87ba                	mv	a5,a4
    8001289e:	faf42423          	sw	a5,-88(s0)
    const size_t start_idx = idx;
    800128a2:	fc843783          	ld	a5,-56(s0)
    800128a6:	fef43023          	sd	a5,-32(s0)

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    800128aa:	fa842783          	lw	a5,-88(s0)
    800128ae:	8b89                	andi	a5,a5,2
    800128b0:	2781                	sext.w	a5,a5
    800128b2:	e3c9                	bnez	a5,80012934 <_out_rev+0xc0>
    800128b4:	fa842783          	lw	a5,-88(s0)
    800128b8:	8b85                	andi	a5,a5,1
    800128ba:	2781                	sext.w	a5,a5
    800128bc:	efa5                	bnez	a5,80012934 <_out_rev+0xc0>
        for (size_t i = len; i < width; i++) {
    800128be:	fb043783          	ld	a5,-80(s0)
    800128c2:	fef43423          	sd	a5,-24(s0)
    800128c6:	a035                	j	800128f2 <_out_rev+0x7e>
            out(' ', buffer, idx++, maxlen);
    800128c8:	fc843783          	ld	a5,-56(s0)
    800128cc:	00178713          	addi	a4,a5,1
    800128d0:	fce43423          	sd	a4,-56(s0)
    800128d4:	fd843703          	ld	a4,-40(s0)
    800128d8:	fc043683          	ld	a3,-64(s0)
    800128dc:	863e                	mv	a2,a5
    800128de:	fd043583          	ld	a1,-48(s0)
    800128e2:	02000513          	li	a0,32
    800128e6:	9702                	jalr	a4
        for (size_t i = len; i < width; i++) {
    800128e8:	fe843783          	ld	a5,-24(s0)
    800128ec:	0785                	addi	a5,a5,1
    800128ee:	fef43423          	sd	a5,-24(s0)
    800128f2:	fac46783          	lwu	a5,-84(s0)
    800128f6:	fe843703          	ld	a4,-24(s0)
    800128fa:	fcf767e3          	bltu	a4,a5,800128c8 <_out_rev+0x54>
        }
    }

    // reverse string
    while (len) {
    800128fe:	a81d                	j	80012934 <_out_rev+0xc0>
        out(buf[--len], buffer, idx++, maxlen);
    80012900:	fb043783          	ld	a5,-80(s0)
    80012904:	17fd                	addi	a5,a5,-1
    80012906:	faf43823          	sd	a5,-80(s0)
    8001290a:	fb843703          	ld	a4,-72(s0)
    8001290e:	fb043783          	ld	a5,-80(s0)
    80012912:	97ba                	add	a5,a5,a4
    80012914:	0007c503          	lbu	a0,0(a5)
    80012918:	fc843783          	ld	a5,-56(s0)
    8001291c:	00178713          	addi	a4,a5,1
    80012920:	fce43423          	sd	a4,-56(s0)
    80012924:	fd843703          	ld	a4,-40(s0)
    80012928:	fc043683          	ld	a3,-64(s0)
    8001292c:	863e                	mv	a2,a5
    8001292e:	fd043583          	ld	a1,-48(s0)
    80012932:	9702                	jalr	a4
    while (len) {
    80012934:	fb043783          	ld	a5,-80(s0)
    80012938:	f7e1                	bnez	a5,80012900 <_out_rev+0x8c>
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
    8001293a:	fa842783          	lw	a5,-88(s0)
    8001293e:	8b89                	andi	a5,a5,2
    80012940:	2781                	sext.w	a5,a5
    80012942:	cb9d                	beqz	a5,80012978 <_out_rev+0x104>
        while (idx - start_idx < width) {
    80012944:	a00d                	j	80012966 <_out_rev+0xf2>
            out(' ', buffer, idx++, maxlen);
    80012946:	fc843783          	ld	a5,-56(s0)
    8001294a:	00178713          	addi	a4,a5,1
    8001294e:	fce43423          	sd	a4,-56(s0)
    80012952:	fd843703          	ld	a4,-40(s0)
    80012956:	fc043683          	ld	a3,-64(s0)
    8001295a:	863e                	mv	a2,a5
    8001295c:	fd043583          	ld	a1,-48(s0)
    80012960:	02000513          	li	a0,32
    80012964:	9702                	jalr	a4
        while (idx - start_idx < width) {
    80012966:	fc843703          	ld	a4,-56(s0)
    8001296a:	fe043783          	ld	a5,-32(s0)
    8001296e:	8f1d                	sub	a4,a4,a5
    80012970:	fac46783          	lwu	a5,-84(s0)
    80012974:	fcf769e3          	bltu	a4,a5,80012946 <_out_rev+0xd2>
        }
    }

    return idx;
    80012978:	fc843783          	ld	a5,-56(s0)
}
    8001297c:	853e                	mv	a0,a5
    8001297e:	60e6                	ld	ra,88(sp)
    80012980:	6446                	ld	s0,80(sp)
    80012982:	6125                	addi	sp,sp,96
    80012984:	8082                	ret

0000000080012986 <_ntoa_format>:
// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx,
                           size_t maxlen, char *buf, size_t len, bool negative,
                           unsigned int base, unsigned int prec,
                           unsigned int width, unsigned int flags)
{
    80012986:	715d                	addi	sp,sp,-80
    80012988:	e486                	sd	ra,72(sp)
    8001298a:	e0a2                	sd	s0,64(sp)
    8001298c:	0880                	addi	s0,sp,80
    8001298e:	fea43423          	sd	a0,-24(s0)
    80012992:	feb43023          	sd	a1,-32(s0)
    80012996:	fcc43c23          	sd	a2,-40(s0)
    8001299a:	fcd43823          	sd	a3,-48(s0)
    8001299e:	fce43423          	sd	a4,-56(s0)
    800129a2:	fcf43023          	sd	a5,-64(s0)
    800129a6:	87c2                	mv	a5,a6
    800129a8:	8746                	mv	a4,a7
    800129aa:	faf40fa3          	sb	a5,-65(s0)
    800129ae:	87ba                	mv	a5,a4
    800129b0:	faf42c23          	sw	a5,-72(s0)
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
    800129b4:	481c                	lw	a5,16(s0)
    800129b6:	8b89                	andi	a5,a5,2
    800129b8:	2781                	sext.w	a5,a5
    800129ba:	ebd1                	bnez	a5,80012a4e <_ntoa_format+0xc8>
        if (width && (flags & FLAGS_ZEROPAD) &&
    800129bc:	441c                	lw	a5,8(s0)
    800129be:	2781                	sext.w	a5,a5
    800129c0:	cf9d                	beqz	a5,800129fe <_ntoa_format+0x78>
    800129c2:	481c                	lw	a5,16(s0)
    800129c4:	8b85                	andi	a5,a5,1
    800129c6:	2781                	sext.w	a5,a5
    800129c8:	cb9d                	beqz	a5,800129fe <_ntoa_format+0x78>
    800129ca:	fbf44783          	lbu	a5,-65(s0)
    800129ce:	0ff7f793          	andi	a5,a5,255
    800129d2:	e789                	bnez	a5,800129dc <_ntoa_format+0x56>
            (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    800129d4:	481c                	lw	a5,16(s0)
    800129d6:	8bb1                	andi	a5,a5,12
    800129d8:	2781                	sext.w	a5,a5
    800129da:	c395                	beqz	a5,800129fe <_ntoa_format+0x78>
            width--;
    800129dc:	441c                	lw	a5,8(s0)
    800129de:	37fd                	addiw	a5,a5,-1
    800129e0:	c41c                	sw	a5,8(s0)
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800129e2:	a831                	j	800129fe <_ntoa_format+0x78>
            buf[len++] = '0';
    800129e4:	fc043783          	ld	a5,-64(s0)
    800129e8:	00178713          	addi	a4,a5,1
    800129ec:	fce43023          	sd	a4,-64(s0)
    800129f0:	fc843703          	ld	a4,-56(s0)
    800129f4:	97ba                	add	a5,a5,a4
    800129f6:	03000713          	li	a4,48
    800129fa:	00e78023          	sb	a4,0(a5)
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800129fe:	00046783          	lwu	a5,0(s0)
    80012a02:	fc043703          	ld	a4,-64(s0)
    80012a06:	02f77563          	bgeu	a4,a5,80012a30 <_ntoa_format+0xaa>
    80012a0a:	fc043703          	ld	a4,-64(s0)
    80012a0e:	47fd                	li	a5,31
    80012a10:	fce7fae3          	bgeu	a5,a4,800129e4 <_ntoa_format+0x5e>
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    80012a14:	a831                	j	80012a30 <_ntoa_format+0xaa>
               (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
    80012a16:	fc043783          	ld	a5,-64(s0)
    80012a1a:	00178713          	addi	a4,a5,1
    80012a1e:	fce43023          	sd	a4,-64(s0)
    80012a22:	fc843703          	ld	a4,-56(s0)
    80012a26:	97ba                	add	a5,a5,a4
    80012a28:	03000713          	li	a4,48
    80012a2c:	00e78023          	sb	a4,0(a5)
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    80012a30:	481c                	lw	a5,16(s0)
    80012a32:	8b85                	andi	a5,a5,1
    80012a34:	2781                	sext.w	a5,a5
    80012a36:	cf81                	beqz	a5,80012a4e <_ntoa_format+0xc8>
    80012a38:	00846783          	lwu	a5,8(s0)
    80012a3c:	fc043703          	ld	a4,-64(s0)
    80012a40:	00f77763          	bgeu	a4,a5,80012a4e <_ntoa_format+0xc8>
    80012a44:	fc043703          	ld	a4,-64(s0)
    80012a48:	47fd                	li	a5,31
    80012a4a:	fce7f6e3          	bgeu	a5,a4,80012a16 <_ntoa_format+0x90>
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
    80012a4e:	481c                	lw	a5,16(s0)
    80012a50:	8bc1                	andi	a5,a5,16
    80012a52:	2781                	sext.w	a5,a5
    80012a54:	12078363          	beqz	a5,80012b7a <_ntoa_format+0x1f4>
        if (!(flags & FLAGS_PRECISION) && len &&
    80012a58:	481c                	lw	a5,16(s0)
    80012a5a:	4007f793          	andi	a5,a5,1024
    80012a5e:	2781                	sext.w	a5,a5
    80012a60:	e7a1                	bnez	a5,80012aa8 <_ntoa_format+0x122>
    80012a62:	fc043783          	ld	a5,-64(s0)
    80012a66:	c3a9                	beqz	a5,80012aa8 <_ntoa_format+0x122>
            ((len == prec) || (len == width))) {
    80012a68:	00046783          	lwu	a5,0(s0)
        if (!(flags & FLAGS_PRECISION) && len &&
    80012a6c:	fc043703          	ld	a4,-64(s0)
    80012a70:	00f70863          	beq	a4,a5,80012a80 <_ntoa_format+0xfa>
            ((len == prec) || (len == width))) {
    80012a74:	00846783          	lwu	a5,8(s0)
    80012a78:	fc043703          	ld	a4,-64(s0)
    80012a7c:	02f71663          	bne	a4,a5,80012aa8 <_ntoa_format+0x122>
            len--;
    80012a80:	fc043783          	ld	a5,-64(s0)
    80012a84:	17fd                	addi	a5,a5,-1
    80012a86:	fcf43023          	sd	a5,-64(s0)
            if (len && (base == 16U)) {
    80012a8a:	fc043783          	ld	a5,-64(s0)
    80012a8e:	cf89                	beqz	a5,80012aa8 <_ntoa_format+0x122>
    80012a90:	fb842783          	lw	a5,-72(s0)
    80012a94:	0007871b          	sext.w	a4,a5
    80012a98:	47c1                	li	a5,16
    80012a9a:	00f71763          	bne	a4,a5,80012aa8 <_ntoa_format+0x122>
                len--;
    80012a9e:	fc043783          	ld	a5,-64(s0)
    80012aa2:	17fd                	addi	a5,a5,-1
    80012aa4:	fcf43023          	sd	a5,-64(s0)
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) &&
    80012aa8:	fb842783          	lw	a5,-72(s0)
    80012aac:	0007871b          	sext.w	a4,a5
    80012ab0:	47c1                	li	a5,16
    80012ab2:	02f71a63          	bne	a4,a5,80012ae6 <_ntoa_format+0x160>
    80012ab6:	481c                	lw	a5,16(s0)
    80012ab8:	0207f793          	andi	a5,a5,32
    80012abc:	2781                	sext.w	a5,a5
    80012abe:	e785                	bnez	a5,80012ae6 <_ntoa_format+0x160>
    80012ac0:	fc043703          	ld	a4,-64(s0)
    80012ac4:	47fd                	li	a5,31
    80012ac6:	02e7e063          	bltu	a5,a4,80012ae6 <_ntoa_format+0x160>
            (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'x';
    80012aca:	fc043783          	ld	a5,-64(s0)
    80012ace:	00178713          	addi	a4,a5,1
    80012ad2:	fce43023          	sd	a4,-64(s0)
    80012ad6:	fc843703          	ld	a4,-56(s0)
    80012ada:	97ba                	add	a5,a5,a4
    80012adc:	07800713          	li	a4,120
    80012ae0:	00e78023          	sb	a4,0(a5)
    80012ae4:	a88d                	j	80012b56 <_ntoa_format+0x1d0>
        }
        else if ((base == 16U) && (flags & FLAGS_UPPERCASE) &&
    80012ae6:	fb842783          	lw	a5,-72(s0)
    80012aea:	0007871b          	sext.w	a4,a5
    80012aee:	47c1                	li	a5,16
    80012af0:	02f71a63          	bne	a4,a5,80012b24 <_ntoa_format+0x19e>
    80012af4:	481c                	lw	a5,16(s0)
    80012af6:	0207f793          	andi	a5,a5,32
    80012afa:	2781                	sext.w	a5,a5
    80012afc:	c785                	beqz	a5,80012b24 <_ntoa_format+0x19e>
    80012afe:	fc043703          	ld	a4,-64(s0)
    80012b02:	47fd                	li	a5,31
    80012b04:	02e7e063          	bltu	a5,a4,80012b24 <_ntoa_format+0x19e>
                 (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'X';
    80012b08:	fc043783          	ld	a5,-64(s0)
    80012b0c:	00178713          	addi	a4,a5,1
    80012b10:	fce43023          	sd	a4,-64(s0)
    80012b14:	fc843703          	ld	a4,-56(s0)
    80012b18:	97ba                	add	a5,a5,a4
    80012b1a:	05800713          	li	a4,88
    80012b1e:	00e78023          	sb	a4,0(a5)
    80012b22:	a815                	j	80012b56 <_ntoa_format+0x1d0>
        }
        else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    80012b24:	fb842783          	lw	a5,-72(s0)
    80012b28:	0007871b          	sext.w	a4,a5
    80012b2c:	4789                	li	a5,2
    80012b2e:	02f71463          	bne	a4,a5,80012b56 <_ntoa_format+0x1d0>
    80012b32:	fc043703          	ld	a4,-64(s0)
    80012b36:	47fd                	li	a5,31
    80012b38:	00e7ef63          	bltu	a5,a4,80012b56 <_ntoa_format+0x1d0>
            buf[len++] = 'b';
    80012b3c:	fc043783          	ld	a5,-64(s0)
    80012b40:	00178713          	addi	a4,a5,1
    80012b44:	fce43023          	sd	a4,-64(s0)
    80012b48:	fc843703          	ld	a4,-56(s0)
    80012b4c:	97ba                	add	a5,a5,a4
    80012b4e:	06200713          	li	a4,98
    80012b52:	00e78023          	sb	a4,0(a5)
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80012b56:	fc043703          	ld	a4,-64(s0)
    80012b5a:	47fd                	li	a5,31
    80012b5c:	00e7ef63          	bltu	a5,a4,80012b7a <_ntoa_format+0x1f4>
            buf[len++] = '0';
    80012b60:	fc043783          	ld	a5,-64(s0)
    80012b64:	00178713          	addi	a4,a5,1
    80012b68:	fce43023          	sd	a4,-64(s0)
    80012b6c:	fc843703          	ld	a4,-56(s0)
    80012b70:	97ba                	add	a5,a5,a4
    80012b72:	03000713          	li	a4,48
    80012b76:	00e78023          	sb	a4,0(a5)
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80012b7a:	fc043703          	ld	a4,-64(s0)
    80012b7e:	47fd                	li	a5,31
    80012b80:	06e7e863          	bltu	a5,a4,80012bf0 <_ntoa_format+0x26a>
        if (negative) {
    80012b84:	fbf44783          	lbu	a5,-65(s0)
    80012b88:	0ff7f793          	andi	a5,a5,255
    80012b8c:	cf99                	beqz	a5,80012baa <_ntoa_format+0x224>
            buf[len++] = '-';
    80012b8e:	fc043783          	ld	a5,-64(s0)
    80012b92:	00178713          	addi	a4,a5,1
    80012b96:	fce43023          	sd	a4,-64(s0)
    80012b9a:	fc843703          	ld	a4,-56(s0)
    80012b9e:	97ba                	add	a5,a5,a4
    80012ba0:	02d00713          	li	a4,45
    80012ba4:	00e78023          	sb	a4,0(a5)
    80012ba8:	a0a1                	j	80012bf0 <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_PLUS) {
    80012baa:	481c                	lw	a5,16(s0)
    80012bac:	8b91                	andi	a5,a5,4
    80012bae:	2781                	sext.w	a5,a5
    80012bb0:	cf99                	beqz	a5,80012bce <_ntoa_format+0x248>
            buf[len++] = '+';  // ignore the space if the '+' exists
    80012bb2:	fc043783          	ld	a5,-64(s0)
    80012bb6:	00178713          	addi	a4,a5,1
    80012bba:	fce43023          	sd	a4,-64(s0)
    80012bbe:	fc843703          	ld	a4,-56(s0)
    80012bc2:	97ba                	add	a5,a5,a4
    80012bc4:	02b00713          	li	a4,43
    80012bc8:	00e78023          	sb	a4,0(a5)
    80012bcc:	a015                	j	80012bf0 <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_SPACE) {
    80012bce:	481c                	lw	a5,16(s0)
    80012bd0:	8ba1                	andi	a5,a5,8
    80012bd2:	2781                	sext.w	a5,a5
    80012bd4:	cf91                	beqz	a5,80012bf0 <_ntoa_format+0x26a>
            buf[len++] = ' ';
    80012bd6:	fc043783          	ld	a5,-64(s0)
    80012bda:	00178713          	addi	a4,a5,1
    80012bde:	fce43023          	sd	a4,-64(s0)
    80012be2:	fc843703          	ld	a4,-56(s0)
    80012be6:	97ba                	add	a5,a5,a4
    80012be8:	02000713          	li	a4,32
    80012bec:	00e78023          	sb	a4,0(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    80012bf0:	4818                	lw	a4,16(s0)
    80012bf2:	441c                	lw	a5,8(s0)
    80012bf4:	88ba                	mv	a7,a4
    80012bf6:	883e                	mv	a6,a5
    80012bf8:	fc043783          	ld	a5,-64(s0)
    80012bfc:	fc843703          	ld	a4,-56(s0)
    80012c00:	fd043683          	ld	a3,-48(s0)
    80012c04:	fd843603          	ld	a2,-40(s0)
    80012c08:	fe043583          	ld	a1,-32(s0)
    80012c0c:	fe843503          	ld	a0,-24(s0)
    80012c10:	c65ff0ef          	jal	ra,80012874 <_out_rev>
    80012c14:	87aa                	mv	a5,a0
}
    80012c16:	853e                	mv	a0,a5
    80012c18:	60a6                	ld	ra,72(sp)
    80012c1a:	6406                	ld	s0,64(sp)
    80012c1c:	6161                	addi	sp,sp,80
    80012c1e:	8082                	ret

0000000080012c20 <_ntoa_long>:
// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
                         size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec,
                         unsigned int width, unsigned int flags)
{
    80012c20:	7135                	addi	sp,sp,-160
    80012c22:	ed06                	sd	ra,152(sp)
    80012c24:	e922                	sd	s0,144(sp)
    80012c26:	1100                	addi	s0,sp,160
    80012c28:	faa43c23          	sd	a0,-72(s0)
    80012c2c:	fab43823          	sd	a1,-80(s0)
    80012c30:	fac43423          	sd	a2,-88(s0)
    80012c34:	fad43023          	sd	a3,-96(s0)
    80012c38:	f8e43c23          	sd	a4,-104(s0)
    80012c3c:	f9043423          	sd	a6,-120(s0)
    80012c40:	8746                	mv	a4,a7
    80012c42:	f8f40ba3          	sb	a5,-105(s0)
    80012c46:	87ba                	mv	a5,a4
    80012c48:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80012c4c:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80012c50:	f9843783          	ld	a5,-104(s0)
    80012c54:	e781                	bnez	a5,80012c5c <_ntoa_long+0x3c>
        flags &= ~FLAGS_HASH;
    80012c56:	441c                	lw	a5,8(s0)
    80012c58:	9bbd                	andi	a5,a5,-17
    80012c5a:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80012c5c:	441c                	lw	a5,8(s0)
    80012c5e:	4007f793          	andi	a5,a5,1024
    80012c62:	2781                	sext.w	a5,a5
    80012c64:	c781                	beqz	a5,80012c6c <_ntoa_long+0x4c>
    80012c66:	f9843783          	ld	a5,-104(s0)
    80012c6a:	c7c1                	beqz	a5,80012cf2 <_ntoa_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80012c6c:	f9843703          	ld	a4,-104(s0)
    80012c70:	f8843783          	ld	a5,-120(s0)
    80012c74:	02f777b3          	remu	a5,a4,a5
    80012c78:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80012c7c:	fe744783          	lbu	a5,-25(s0)
    80012c80:	0ff7f713          	andi	a4,a5,255
    80012c84:	47a5                	li	a5,9
    80012c86:	00e7e963          	bltu	a5,a4,80012c98 <_ntoa_long+0x78>
    80012c8a:	fe744783          	lbu	a5,-25(s0)
    80012c8e:	0307879b          	addiw	a5,a5,48
    80012c92:	0ff7f793          	andi	a5,a5,255
    80012c96:	a01d                	j	80012cbc <_ntoa_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80012c98:	441c                	lw	a5,8(s0)
    80012c9a:	0207f793          	andi	a5,a5,32
    80012c9e:	2781                	sext.w	a5,a5
    80012ca0:	c781                	beqz	a5,80012ca8 <_ntoa_long+0x88>
    80012ca2:	04100793          	li	a5,65
    80012ca6:	a019                	j	80012cac <_ntoa_long+0x8c>
    80012ca8:	06100793          	li	a5,97
    80012cac:	fe744703          	lbu	a4,-25(s0)
    80012cb0:	9fb9                	addw	a5,a5,a4
    80012cb2:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80012cb6:	37d9                	addiw	a5,a5,-10
    80012cb8:	0ff7f793          	andi	a5,a5,255
    80012cbc:	fe843703          	ld	a4,-24(s0)
    80012cc0:	00170693          	addi	a3,a4,1
    80012cc4:	fed43423          	sd	a3,-24(s0)
    80012cc8:	ff040693          	addi	a3,s0,-16
    80012ccc:	9736                	add	a4,a4,a3
    80012cce:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80012cd2:	f9843703          	ld	a4,-104(s0)
    80012cd6:	f8843783          	ld	a5,-120(s0)
    80012cda:	02f757b3          	divu	a5,a4,a5
    80012cde:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80012ce2:	f9843783          	ld	a5,-104(s0)
    80012ce6:	c791                	beqz	a5,80012cf2 <_ntoa_long+0xd2>
    80012ce8:	fe843703          	ld	a4,-24(s0)
    80012cec:	47fd                	li	a5,31
    80012cee:	f6e7ffe3          	bgeu	a5,a4,80012c6c <_ntoa_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80012cf2:	f8843783          	ld	a5,-120(s0)
    80012cf6:	0007861b          	sext.w	a2,a5
    80012cfa:	f9744683          	lbu	a3,-105(s0)
    80012cfe:	fc040713          	addi	a4,s0,-64
    80012d02:	441c                	lw	a5,8(s0)
    80012d04:	e83e                	sd	a5,16(sp)
    80012d06:	401c                	lw	a5,0(s0)
    80012d08:	e43e                	sd	a5,8(sp)
    80012d0a:	f9042783          	lw	a5,-112(s0)
    80012d0e:	e03e                	sd	a5,0(sp)
    80012d10:	88b2                	mv	a7,a2
    80012d12:	8836                	mv	a6,a3
    80012d14:	fe843783          	ld	a5,-24(s0)
    80012d18:	fa043683          	ld	a3,-96(s0)
    80012d1c:	fa843603          	ld	a2,-88(s0)
    80012d20:	fb043583          	ld	a1,-80(s0)
    80012d24:	fb843503          	ld	a0,-72(s0)
    80012d28:	c5fff0ef          	jal	ra,80012986 <_ntoa_format>
    80012d2c:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80012d2e:	853e                	mv	a0,a5
    80012d30:	60ea                	ld	ra,152(sp)
    80012d32:	644a                	ld	s0,144(sp)
    80012d34:	610d                	addi	sp,sp,160
    80012d36:	8082                	ret

0000000080012d38 <_ntoa_long_long>:
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
                              size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base,
                              unsigned int prec, unsigned int width,
                              unsigned int flags)
{
    80012d38:	7135                	addi	sp,sp,-160
    80012d3a:	ed06                	sd	ra,152(sp)
    80012d3c:	e922                	sd	s0,144(sp)
    80012d3e:	1100                	addi	s0,sp,160
    80012d40:	faa43c23          	sd	a0,-72(s0)
    80012d44:	fab43823          	sd	a1,-80(s0)
    80012d48:	fac43423          	sd	a2,-88(s0)
    80012d4c:	fad43023          	sd	a3,-96(s0)
    80012d50:	f8e43c23          	sd	a4,-104(s0)
    80012d54:	f9043423          	sd	a6,-120(s0)
    80012d58:	8746                	mv	a4,a7
    80012d5a:	f8f40ba3          	sb	a5,-105(s0)
    80012d5e:	87ba                	mv	a5,a4
    80012d60:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80012d64:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80012d68:	f9843783          	ld	a5,-104(s0)
    80012d6c:	e781                	bnez	a5,80012d74 <_ntoa_long_long+0x3c>
        flags &= ~FLAGS_HASH;
    80012d6e:	441c                	lw	a5,8(s0)
    80012d70:	9bbd                	andi	a5,a5,-17
    80012d72:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80012d74:	441c                	lw	a5,8(s0)
    80012d76:	4007f793          	andi	a5,a5,1024
    80012d7a:	2781                	sext.w	a5,a5
    80012d7c:	c781                	beqz	a5,80012d84 <_ntoa_long_long+0x4c>
    80012d7e:	f9843783          	ld	a5,-104(s0)
    80012d82:	c7c1                	beqz	a5,80012e0a <_ntoa_long_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80012d84:	f9843703          	ld	a4,-104(s0)
    80012d88:	f8843783          	ld	a5,-120(s0)
    80012d8c:	02f777b3          	remu	a5,a4,a5
    80012d90:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80012d94:	fe744783          	lbu	a5,-25(s0)
    80012d98:	0ff7f713          	andi	a4,a5,255
    80012d9c:	47a5                	li	a5,9
    80012d9e:	00e7e963          	bltu	a5,a4,80012db0 <_ntoa_long_long+0x78>
    80012da2:	fe744783          	lbu	a5,-25(s0)
    80012da6:	0307879b          	addiw	a5,a5,48
    80012daa:	0ff7f793          	andi	a5,a5,255
    80012dae:	a01d                	j	80012dd4 <_ntoa_long_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80012db0:	441c                	lw	a5,8(s0)
    80012db2:	0207f793          	andi	a5,a5,32
    80012db6:	2781                	sext.w	a5,a5
    80012db8:	c781                	beqz	a5,80012dc0 <_ntoa_long_long+0x88>
    80012dba:	04100793          	li	a5,65
    80012dbe:	a019                	j	80012dc4 <_ntoa_long_long+0x8c>
    80012dc0:	06100793          	li	a5,97
    80012dc4:	fe744703          	lbu	a4,-25(s0)
    80012dc8:	9fb9                	addw	a5,a5,a4
    80012dca:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80012dce:	37d9                	addiw	a5,a5,-10
    80012dd0:	0ff7f793          	andi	a5,a5,255
    80012dd4:	fe843703          	ld	a4,-24(s0)
    80012dd8:	00170693          	addi	a3,a4,1
    80012ddc:	fed43423          	sd	a3,-24(s0)
    80012de0:	ff040693          	addi	a3,s0,-16
    80012de4:	9736                	add	a4,a4,a3
    80012de6:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80012dea:	f9843703          	ld	a4,-104(s0)
    80012dee:	f8843783          	ld	a5,-120(s0)
    80012df2:	02f757b3          	divu	a5,a4,a5
    80012df6:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80012dfa:	f9843783          	ld	a5,-104(s0)
    80012dfe:	c791                	beqz	a5,80012e0a <_ntoa_long_long+0xd2>
    80012e00:	fe843703          	ld	a4,-24(s0)
    80012e04:	47fd                	li	a5,31
    80012e06:	f6e7ffe3          	bgeu	a5,a4,80012d84 <_ntoa_long_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80012e0a:	f8843783          	ld	a5,-120(s0)
    80012e0e:	0007861b          	sext.w	a2,a5
    80012e12:	f9744683          	lbu	a3,-105(s0)
    80012e16:	fc040713          	addi	a4,s0,-64
    80012e1a:	441c                	lw	a5,8(s0)
    80012e1c:	e83e                	sd	a5,16(sp)
    80012e1e:	401c                	lw	a5,0(s0)
    80012e20:	e43e                	sd	a5,8(sp)
    80012e22:	f9042783          	lw	a5,-112(s0)
    80012e26:	e03e                	sd	a5,0(sp)
    80012e28:	88b2                	mv	a7,a2
    80012e2a:	8836                	mv	a6,a3
    80012e2c:	fe843783          	ld	a5,-24(s0)
    80012e30:	fa043683          	ld	a3,-96(s0)
    80012e34:	fa843603          	ld	a2,-88(s0)
    80012e38:	fb043583          	ld	a1,-80(s0)
    80012e3c:	fb843503          	ld	a0,-72(s0)
    80012e40:	b47ff0ef          	jal	ra,80012986 <_ntoa_format>
    80012e44:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80012e46:	853e                	mv	a0,a5
    80012e48:	60ea                	ld	ra,152(sp)
    80012e4a:	644a                	ld	s0,144(sp)
    80012e4c:	610d                	addi	sp,sp,160
    80012e4e:	8082                	ret

0000000080012e50 <_ftoa>:

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80012e50:	7135                	addi	sp,sp,-160
    80012e52:	ed06                	sd	ra,152(sp)
    80012e54:	e922                	sd	s0,144(sp)
    80012e56:	1100                	addi	s0,sp,160
    80012e58:	f8a43c23          	sd	a0,-104(s0)
    80012e5c:	f8b43823          	sd	a1,-112(s0)
    80012e60:	f8c43423          	sd	a2,-120(s0)
    80012e64:	f8d43023          	sd	a3,-128(s0)
    80012e68:	f6a43c27          	fsd	fa0,-136(s0)
    80012e6c:	863a                	mv	a2,a4
    80012e6e:	86be                	mv	a3,a5
    80012e70:	8742                	mv	a4,a6
    80012e72:	87b2                	mv	a5,a2
    80012e74:	f6f42a23          	sw	a5,-140(s0)
    80012e78:	87b6                	mv	a5,a3
    80012e7a:	f6f42823          	sw	a5,-144(s0)
    80012e7e:	87ba                	mv	a5,a4
    80012e80:	f6f42623          	sw	a5,-148(s0)
    char buf[PRINTF_FTOA_BUFFER_SIZE];
    size_t len                  = 0U;
    80012e84:	fe043423          	sd	zero,-24(s0)
    double diff                 = 0.0;
    80012e88:	fc043423          	sd	zero,-56(s0)
    static const double pow10[] = {1,         10,        100,     1000,
                                   10000,     100000,    1000000, 10000000,
                                   100000000, 1000000000};

    // test for special values
    if (value != value)
    80012e8c:	f7843707          	fld	fa4,-136(s0)
    80012e90:	f7843787          	fld	fa5,-136(s0)
    80012e94:	a2f727d3          	feq.d	a5,fa4,fa5
    80012e98:	eb85                	bnez	a5,80012ec8 <_ftoa+0x78>
        return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
    80012e9a:	f6c42703          	lw	a4,-148(s0)
    80012e9e:	f7042783          	lw	a5,-144(s0)
    80012ea2:	88ba                	mv	a7,a4
    80012ea4:	883e                	mv	a6,a5
    80012ea6:	478d                	li	a5,3
    80012ea8:	00006717          	auipc	a4,0x6
    80012eac:	7d070713          	addi	a4,a4,2000 # 80019678 <SYSCALLS+0x678>
    80012eb0:	f8043683          	ld	a3,-128(s0)
    80012eb4:	f8843603          	ld	a2,-120(s0)
    80012eb8:	f9043583          	ld	a1,-112(s0)
    80012ebc:	f9843503          	ld	a0,-104(s0)
    80012ec0:	9b5ff0ef          	jal	ra,80012874 <_out_rev>
    80012ec4:	87aa                	mv	a5,a0
    80012ec6:	a1f1                	j	80013392 <_ftoa+0x542>
    if (value < -DBL_MAX)
    80012ec8:	f7843707          	fld	fa4,-136(s0)
    80012ecc:	00007797          	auipc	a5,0x7
    80012ed0:	9fc78793          	addi	a5,a5,-1540 # 800198c8 <pow10.0+0x50>
    80012ed4:	239c                	fld	fa5,0(a5)
    80012ed6:	a2f717d3          	flt.d	a5,fa4,fa5
    80012eda:	cb85                	beqz	a5,80012f0a <_ftoa+0xba>
        return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    80012edc:	f6c42703          	lw	a4,-148(s0)
    80012ee0:	f7042783          	lw	a5,-144(s0)
    80012ee4:	88ba                	mv	a7,a4
    80012ee6:	883e                	mv	a6,a5
    80012ee8:	4791                	li	a5,4
    80012eea:	00006717          	auipc	a4,0x6
    80012eee:	79670713          	addi	a4,a4,1942 # 80019680 <SYSCALLS+0x680>
    80012ef2:	f8043683          	ld	a3,-128(s0)
    80012ef6:	f8843603          	ld	a2,-120(s0)
    80012efa:	f9043583          	ld	a1,-112(s0)
    80012efe:	f9843503          	ld	a0,-104(s0)
    80012f02:	973ff0ef          	jal	ra,80012874 <_out_rev>
    80012f06:	87aa                	mv	a5,a0
    80012f08:	a169                	j	80013392 <_ftoa+0x542>
    if (value > DBL_MAX)
    80012f0a:	f7843707          	fld	fa4,-136(s0)
    80012f0e:	00007797          	auipc	a5,0x7
    80012f12:	9c278793          	addi	a5,a5,-1598 # 800198d0 <pow10.0+0x58>
    80012f16:	239c                	fld	fa5,0(a5)
    80012f18:	a2e797d3          	flt.d	a5,fa5,fa4
    80012f1c:	cba9                	beqz	a5,80012f6e <_ftoa+0x11e>
        return _out_rev(out, buffer, idx, maxlen,
                        (flags & FLAGS_PLUS) ? "fni+" : "fni",
    80012f1e:	f6c42783          	lw	a5,-148(s0)
    80012f22:	8b91                	andi	a5,a5,4
    80012f24:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80012f26:	c791                	beqz	a5,80012f32 <_ftoa+0xe2>
    80012f28:	00006717          	auipc	a4,0x6
    80012f2c:	76070713          	addi	a4,a4,1888 # 80019688 <SYSCALLS+0x688>
    80012f30:	a029                	j	80012f3a <_ftoa+0xea>
    80012f32:	00006717          	auipc	a4,0x6
    80012f36:	75e70713          	addi	a4,a4,1886 # 80019690 <SYSCALLS+0x690>
                        (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
    80012f3a:	f6c42783          	lw	a5,-148(s0)
    80012f3e:	8b91                	andi	a5,a5,4
    80012f40:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80012f42:	c399                	beqz	a5,80012f48 <_ftoa+0xf8>
    80012f44:	4791                	li	a5,4
    80012f46:	a011                	j	80012f4a <_ftoa+0xfa>
    80012f48:	478d                	li	a5,3
    80012f4a:	f6c42603          	lw	a2,-148(s0)
    80012f4e:	f7042683          	lw	a3,-144(s0)
    80012f52:	88b2                	mv	a7,a2
    80012f54:	8836                	mv	a6,a3
    80012f56:	f8043683          	ld	a3,-128(s0)
    80012f5a:	f8843603          	ld	a2,-120(s0)
    80012f5e:	f9043583          	ld	a1,-112(s0)
    80012f62:	f9843503          	ld	a0,-104(s0)
    80012f66:	90fff0ef          	jal	ra,80012874 <_out_rev>
    80012f6a:	87aa                	mv	a5,a0
    80012f6c:	a11d                	j	80013392 <_ftoa+0x542>

    // test for very large values
    // standard printf behavior is to print EVERY whole number digit -- which
    // could be 100s of characters overflowing your buffers == bad
    if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
    80012f6e:	f7843707          	fld	fa4,-136(s0)
    80012f72:	00007797          	auipc	a5,0x7
    80012f76:	96678793          	addi	a5,a5,-1690 # 800198d8 <pow10.0+0x60>
    80012f7a:	239c                	fld	fa5,0(a5)
    80012f7c:	a2e797d3          	flt.d	a5,fa5,fa4
    80012f80:	eb99                	bnez	a5,80012f96 <_ftoa+0x146>
    80012f82:	f7843707          	fld	fa4,-136(s0)
    80012f86:	00007797          	auipc	a5,0x7
    80012f8a:	95a78793          	addi	a5,a5,-1702 # 800198e0 <pow10.0+0x68>
    80012f8e:	239c                	fld	fa5,0(a5)
    80012f90:	a2f717d3          	flt.d	a5,fa4,fa5
    80012f94:	c795                	beqz	a5,80012fc0 <_ftoa+0x170>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80012f96:	f6c42683          	lw	a3,-148(s0)
    80012f9a:	f7042783          	lw	a5,-144(s0)
    80012f9e:	f7442703          	lw	a4,-140(s0)
    80012fa2:	8836                	mv	a6,a3
    80012fa4:	f7843507          	fld	fa0,-136(s0)
    80012fa8:	f8043683          	ld	a3,-128(s0)
    80012fac:	f8843603          	ld	a2,-120(s0)
    80012fb0:	f9043583          	ld	a1,-112(s0)
    80012fb4:	f9843503          	ld	a0,-104(s0)
    80012fb8:	3e4000ef          	jal	ra,8001339c <_etoa>
    80012fbc:	87aa                	mv	a5,a0
    80012fbe:	aed1                	j	80013392 <_ftoa+0x542>
        return 0U;
#endif
    }

    // test for negative
    bool negative = false;
    80012fc0:	fe0403a3          	sb	zero,-25(s0)
    if (value < 0) {
    80012fc4:	f7843787          	fld	fa5,-136(s0)
    80012fc8:	f2000753          	fmv.d.x	fa4,zero
    80012fcc:	a2e797d3          	flt.d	a5,fa5,fa4
    80012fd0:	cf81                	beqz	a5,80012fe8 <_ftoa+0x198>
        negative = true;
    80012fd2:	4785                	li	a5,1
    80012fd4:	fef403a3          	sb	a5,-25(s0)
        value    = 0 - value;
    80012fd8:	f2000753          	fmv.d.x	fa4,zero
    80012fdc:	f7843787          	fld	fa5,-136(s0)
    80012fe0:	0af777d3          	fsub.d	fa5,fa4,fa5
    80012fe4:	f6f43c27          	fsd	fa5,-136(s0)
    }

    // set default precision, if not set explicitly
    if (!(flags & FLAGS_PRECISION)) {
    80012fe8:	f6c42783          	lw	a5,-148(s0)
    80012fec:	4007f793          	andi	a5,a5,1024
    80012ff0:	2781                	sext.w	a5,a5
    80012ff2:	e79d                	bnez	a5,80013020 <_ftoa+0x1d0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80012ff4:	4799                	li	a5,6
    80012ff6:	f6f42a23          	sw	a5,-140(s0)
    }
    // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80012ffa:	a01d                	j	80013020 <_ftoa+0x1d0>
        buf[len++] = '0';
    80012ffc:	fe843783          	ld	a5,-24(s0)
    80013000:	00178713          	addi	a4,a5,1
    80013004:	fee43423          	sd	a4,-24(s0)
    80013008:	ff040713          	addi	a4,s0,-16
    8001300c:	97ba                	add	a5,a5,a4
    8001300e:	03000713          	li	a4,48
    80013012:	fae78823          	sb	a4,-80(a5)
        prec--;
    80013016:	f7442783          	lw	a5,-140(s0)
    8001301a:	37fd                	addiw	a5,a5,-1
    8001301c:	f6f42a23          	sw	a5,-140(s0)
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80013020:	fe843703          	ld	a4,-24(s0)
    80013024:	47fd                	li	a5,31
    80013026:	00e7e963          	bltu	a5,a4,80013038 <_ftoa+0x1e8>
    8001302a:	f7442783          	lw	a5,-140(s0)
    8001302e:	0007871b          	sext.w	a4,a5
    80013032:	47a5                	li	a5,9
    80013034:	fce7e4e3          	bltu	a5,a4,80012ffc <_ftoa+0x1ac>
    }

    int whole          = (int)value;
    80013038:	f7843787          	fld	fa5,-136(s0)
    8001303c:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80013040:	fef42023          	sw	a5,-32(s0)
    double tmp         = (value - whole) * pow10[prec];
    80013044:	fe042783          	lw	a5,-32(s0)
    80013048:	d20787d3          	fcvt.d.w	fa5,a5
    8001304c:	f7843707          	fld	fa4,-136(s0)
    80013050:	0af77753          	fsub.d	fa4,fa4,fa5
    80013054:	00007717          	auipc	a4,0x7
    80013058:	82470713          	addi	a4,a4,-2012 # 80019878 <pow10.0>
    8001305c:	f7446783          	lwu	a5,-140(s0)
    80013060:	078e                	slli	a5,a5,0x3
    80013062:	97ba                	add	a5,a5,a4
    80013064:	239c                	fld	fa5,0(a5)
    80013066:	12f777d3          	fmul.d	fa5,fa4,fa5
    8001306a:	fcf43027          	fsd	fa5,-64(s0)
    unsigned long frac = (unsigned long)tmp;
    8001306e:	fc043787          	fld	fa5,-64(s0)
    80013072:	c23797d3          	fcvt.lu.d	a5,fa5,rtz
    80013076:	fcf43c23          	sd	a5,-40(s0)
    diff               = tmp - frac;
    8001307a:	fd843783          	ld	a5,-40(s0)
    8001307e:	d237f7d3          	fcvt.d.lu	fa5,a5
    80013082:	fc043707          	fld	fa4,-64(s0)
    80013086:	0af777d3          	fsub.d	fa5,fa4,fa5
    8001308a:	fcf43427          	fsd	fa5,-56(s0)

    if (diff > 0.5) {
    8001308e:	fc843707          	fld	fa4,-56(s0)
    80013092:	00007797          	auipc	a5,0x7
    80013096:	85678793          	addi	a5,a5,-1962 # 800198e8 <pow10.0+0x70>
    8001309a:	239c                	fld	fa5,0(a5)
    8001309c:	a2e797d3          	flt.d	a5,fa5,fa4
    800130a0:	cf95                	beqz	a5,800130dc <_ftoa+0x28c>
        ++frac;
    800130a2:	fd843783          	ld	a5,-40(s0)
    800130a6:	0785                	addi	a5,a5,1
    800130a8:	fcf43c23          	sd	a5,-40(s0)
        // handle rollover, e.g. case 0.99 with prec 1 is 1.0
        if (frac >= pow10[prec]) {
    800130ac:	fd843783          	ld	a5,-40(s0)
    800130b0:	d237f753          	fcvt.d.lu	fa4,a5
    800130b4:	00006717          	auipc	a4,0x6
    800130b8:	7c470713          	addi	a4,a4,1988 # 80019878 <pow10.0>
    800130bc:	f7446783          	lwu	a5,-140(s0)
    800130c0:	078e                	slli	a5,a5,0x3
    800130c2:	97ba                	add	a5,a5,a4
    800130c4:	239c                	fld	fa5,0(a5)
    800130c6:	a2e787d3          	fle.d	a5,fa5,fa4
    800130ca:	cf9d                	beqz	a5,80013108 <_ftoa+0x2b8>
            frac = 0;
    800130cc:	fc043c23          	sd	zero,-40(s0)
            ++whole;
    800130d0:	fe042783          	lw	a5,-32(s0)
    800130d4:	2785                	addiw	a5,a5,1
    800130d6:	fef42023          	sw	a5,-32(s0)
    800130da:	a03d                	j	80013108 <_ftoa+0x2b8>
        }
    }
    else if (diff < 0.5) {
    800130dc:	fc843707          	fld	fa4,-56(s0)
    800130e0:	00007797          	auipc	a5,0x7
    800130e4:	80878793          	addi	a5,a5,-2040 # 800198e8 <pow10.0+0x70>
    800130e8:	239c                	fld	fa5,0(a5)
    800130ea:	a2f717d3          	flt.d	a5,fa4,fa5
    800130ee:	ef89                	bnez	a5,80013108 <_ftoa+0x2b8>
    }
    else if ((frac == 0U) || (frac & 1U)) {
    800130f0:	fd843783          	ld	a5,-40(s0)
    800130f4:	c789                	beqz	a5,800130fe <_ftoa+0x2ae>
    800130f6:	fd843783          	ld	a5,-40(s0)
    800130fa:	8b85                	andi	a5,a5,1
    800130fc:	c791                	beqz	a5,80013108 <_ftoa+0x2b8>
        // if halfway, round up if odd OR if last digit is 0
        ++frac;
    800130fe:	fd843783          	ld	a5,-40(s0)
    80013102:	0785                	addi	a5,a5,1
    80013104:	fcf43c23          	sd	a5,-40(s0)
    }

    if (prec == 0U) {
    80013108:	f7442783          	lw	a5,-140(s0)
    8001310c:	2781                	sext.w	a5,a5
    8001310e:	e3bd                	bnez	a5,80013174 <_ftoa+0x324>
        diff = value - (double)whole;
    80013110:	fe042783          	lw	a5,-32(s0)
    80013114:	d20787d3          	fcvt.d.w	fa5,a5
    80013118:	f7843707          	fld	fa4,-136(s0)
    8001311c:	0af777d3          	fsub.d	fa5,fa4,fa5
    80013120:	fcf43427          	fsd	fa5,-56(s0)
        if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    80013124:	fc843707          	fld	fa4,-56(s0)
    80013128:	00006797          	auipc	a5,0x6
    8001312c:	7c078793          	addi	a5,a5,1984 # 800198e8 <pow10.0+0x70>
    80013130:	239c                	fld	fa5,0(a5)
    80013132:	a2f717d3          	flt.d	a5,fa4,fa5
    80013136:	00f037b3          	snez	a5,a5
    8001313a:	0ff7f793          	andi	a5,a5,255
    8001313e:	0017c793          	xori	a5,a5,1
    80013142:	0ff7f793          	andi	a5,a5,255
    80013146:	eb99                	bnez	a5,8001315c <_ftoa+0x30c>
    80013148:	fc843707          	fld	fa4,-56(s0)
    8001314c:	00006797          	auipc	a5,0x6
    80013150:	79c78793          	addi	a5,a5,1948 # 800198e8 <pow10.0+0x70>
    80013154:	239c                	fld	fa5,0(a5)
    80013156:	a2e797d3          	flt.d	a5,fa5,fa4
    8001315a:	cbf1                	beqz	a5,8001322e <_ftoa+0x3de>
    8001315c:	fe042783          	lw	a5,-32(s0)
    80013160:	8b85                	andi	a5,a5,1
    80013162:	2781                	sext.w	a5,a5
    80013164:	10078863          	beqz	a5,80013274 <_ftoa+0x424>
            // exactly 0.5 and ODD, then round up
            // 1.5 -> 2, but 2.5 -> 2
            ++whole;
    80013168:	fe042783          	lw	a5,-32(s0)
    8001316c:	2785                	addiw	a5,a5,1
    8001316e:	fef42023          	sw	a5,-32(s0)
    80013172:	a209                	j	80013274 <_ftoa+0x424>
        }
    }
    else {
        unsigned int count = prec;
    80013174:	f7442783          	lw	a5,-140(s0)
    80013178:	fcf42a23          	sw	a5,-44(s0)
        // now do fractional part, as an unsigned number
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    8001317c:	a0b1                	j	800131c8 <_ftoa+0x378>
            --count;
    8001317e:	fd442783          	lw	a5,-44(s0)
    80013182:	37fd                	addiw	a5,a5,-1
    80013184:	fcf42a23          	sw	a5,-44(s0)
            buf[len++] = (char)(48U + (frac % 10U));
    80013188:	fd843703          	ld	a4,-40(s0)
    8001318c:	47a9                	li	a5,10
    8001318e:	02f777b3          	remu	a5,a4,a5
    80013192:	0ff7f713          	andi	a4,a5,255
    80013196:	fe843783          	ld	a5,-24(s0)
    8001319a:	00178693          	addi	a3,a5,1
    8001319e:	fed43423          	sd	a3,-24(s0)
    800131a2:	0307071b          	addiw	a4,a4,48
    800131a6:	0ff77713          	andi	a4,a4,255
    800131aa:	ff040693          	addi	a3,s0,-16
    800131ae:	97b6                	add	a5,a5,a3
    800131b0:	fae78823          	sb	a4,-80(a5)
            if (!(frac /= 10U)) {
    800131b4:	fd843703          	ld	a4,-40(s0)
    800131b8:	47a9                	li	a5,10
    800131ba:	02f757b3          	divu	a5,a4,a5
    800131be:	fcf43c23          	sd	a5,-40(s0)
    800131c2:	fd843783          	ld	a5,-40(s0)
    800131c6:	c799                	beqz	a5,800131d4 <_ftoa+0x384>
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    800131c8:	fe843703          	ld	a4,-24(s0)
    800131cc:	47fd                	li	a5,31
    800131ce:	fae7f8e3          	bgeu	a5,a4,8001317e <_ftoa+0x32e>
    800131d2:	a005                	j	800131f2 <_ftoa+0x3a2>
                break;
    800131d4:	0001                	nop
            }
        }
        // add extra 0s
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    800131d6:	a831                	j	800131f2 <_ftoa+0x3a2>
            buf[len++] = '0';
    800131d8:	fe843783          	ld	a5,-24(s0)
    800131dc:	00178713          	addi	a4,a5,1
    800131e0:	fee43423          	sd	a4,-24(s0)
    800131e4:	ff040713          	addi	a4,s0,-16
    800131e8:	97ba                	add	a5,a5,a4
    800131ea:	03000713          	li	a4,48
    800131ee:	fae78823          	sb	a4,-80(a5)
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    800131f2:	fe843703          	ld	a4,-24(s0)
    800131f6:	47fd                	li	a5,31
    800131f8:	00e7e963          	bltu	a5,a4,8001320a <_ftoa+0x3ba>
    800131fc:	fd442783          	lw	a5,-44(s0)
    80013200:	fff7871b          	addiw	a4,a5,-1
    80013204:	fce42a23          	sw	a4,-44(s0)
    80013208:	fbe1                	bnez	a5,800131d8 <_ftoa+0x388>
        }
        if (len < PRINTF_FTOA_BUFFER_SIZE) {
    8001320a:	fe843703          	ld	a4,-24(s0)
    8001320e:	47fd                	li	a5,31
    80013210:	06e7e263          	bltu	a5,a4,80013274 <_ftoa+0x424>
            // add decimal
            buf[len++] = '.';
    80013214:	fe843783          	ld	a5,-24(s0)
    80013218:	00178713          	addi	a4,a5,1
    8001321c:	fee43423          	sd	a4,-24(s0)
    80013220:	ff040713          	addi	a4,s0,-16
    80013224:	97ba                	add	a5,a5,a4
    80013226:	02e00713          	li	a4,46
    8001322a:	fae78823          	sb	a4,-80(a5)
        }
    }

    // do whole part, number is reversed
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    8001322e:	a099                	j	80013274 <_ftoa+0x424>
        buf[len++] = (char)(48 + (whole % 10));
    80013230:	fe042703          	lw	a4,-32(s0)
    80013234:	47a9                	li	a5,10
    80013236:	02f767bb          	remw	a5,a4,a5
    8001323a:	2781                	sext.w	a5,a5
    8001323c:	0ff7f713          	andi	a4,a5,255
    80013240:	fe843783          	ld	a5,-24(s0)
    80013244:	00178693          	addi	a3,a5,1
    80013248:	fed43423          	sd	a3,-24(s0)
    8001324c:	0307071b          	addiw	a4,a4,48
    80013250:	0ff77713          	andi	a4,a4,255
    80013254:	ff040693          	addi	a3,s0,-16
    80013258:	97b6                	add	a5,a5,a3
    8001325a:	fae78823          	sb	a4,-80(a5)
        if (!(whole /= 10)) {
    8001325e:	fe042703          	lw	a4,-32(s0)
    80013262:	47a9                	li	a5,10
    80013264:	02f747bb          	divw	a5,a4,a5
    80013268:	fef42023          	sw	a5,-32(s0)
    8001326c:	fe042783          	lw	a5,-32(s0)
    80013270:	2781                	sext.w	a5,a5
    80013272:	c799                	beqz	a5,80013280 <_ftoa+0x430>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80013274:	fe843703          	ld	a4,-24(s0)
    80013278:	47fd                	li	a5,31
    8001327a:	fae7fbe3          	bgeu	a5,a4,80013230 <_ftoa+0x3e0>
    8001327e:	a011                	j	80013282 <_ftoa+0x432>
            break;
    80013280:	0001                	nop
        }
    }

    // pad leading zeros
    if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    80013282:	f6c42783          	lw	a5,-148(s0)
    80013286:	8b89                	andi	a5,a5,2
    80013288:	2781                	sext.w	a5,a5
    8001328a:	e3b5                	bnez	a5,800132ee <_ftoa+0x49e>
    8001328c:	f6c42783          	lw	a5,-148(s0)
    80013290:	8b85                	andi	a5,a5,1
    80013292:	2781                	sext.w	a5,a5
    80013294:	cfa9                	beqz	a5,800132ee <_ftoa+0x49e>
        if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80013296:	f7042783          	lw	a5,-144(s0)
    8001329a:	2781                	sext.w	a5,a5
    8001329c:	cf95                	beqz	a5,800132d8 <_ftoa+0x488>
    8001329e:	fe744783          	lbu	a5,-25(s0)
    800132a2:	0ff7f793          	andi	a5,a5,255
    800132a6:	e791                	bnez	a5,800132b2 <_ftoa+0x462>
    800132a8:	f6c42783          	lw	a5,-148(s0)
    800132ac:	8bb1                	andi	a5,a5,12
    800132ae:	2781                	sext.w	a5,a5
    800132b0:	c785                	beqz	a5,800132d8 <_ftoa+0x488>
            width--;
    800132b2:	f7042783          	lw	a5,-144(s0)
    800132b6:	37fd                	addiw	a5,a5,-1
    800132b8:	f6f42823          	sw	a5,-144(s0)
        }
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800132bc:	a831                	j	800132d8 <_ftoa+0x488>
            buf[len++] = '0';
    800132be:	fe843783          	ld	a5,-24(s0)
    800132c2:	00178713          	addi	a4,a5,1
    800132c6:	fee43423          	sd	a4,-24(s0)
    800132ca:	ff040713          	addi	a4,s0,-16
    800132ce:	97ba                	add	a5,a5,a4
    800132d0:	03000713          	li	a4,48
    800132d4:	fae78823          	sb	a4,-80(a5)
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800132d8:	f7046783          	lwu	a5,-144(s0)
    800132dc:	fe843703          	ld	a4,-24(s0)
    800132e0:	00f77763          	bgeu	a4,a5,800132ee <_ftoa+0x49e>
    800132e4:	fe843703          	ld	a4,-24(s0)
    800132e8:	47fd                	li	a5,31
    800132ea:	fce7fae3          	bgeu	a5,a4,800132be <_ftoa+0x46e>
        }
    }

    if (len < PRINTF_FTOA_BUFFER_SIZE) {
    800132ee:	fe843703          	ld	a4,-24(s0)
    800132f2:	47fd                	li	a5,31
    800132f4:	06e7ea63          	bltu	a5,a4,80013368 <_ftoa+0x518>
        if (negative) {
    800132f8:	fe744783          	lbu	a5,-25(s0)
    800132fc:	0ff7f793          	andi	a5,a5,255
    80013300:	cf99                	beqz	a5,8001331e <_ftoa+0x4ce>
            buf[len++] = '-';
    80013302:	fe843783          	ld	a5,-24(s0)
    80013306:	00178713          	addi	a4,a5,1
    8001330a:	fee43423          	sd	a4,-24(s0)
    8001330e:	ff040713          	addi	a4,s0,-16
    80013312:	97ba                	add	a5,a5,a4
    80013314:	02d00713          	li	a4,45
    80013318:	fae78823          	sb	a4,-80(a5)
    8001331c:	a0b1                	j	80013368 <_ftoa+0x518>
        }
        else if (flags & FLAGS_PLUS) {
    8001331e:	f6c42783          	lw	a5,-148(s0)
    80013322:	8b91                	andi	a5,a5,4
    80013324:	2781                	sext.w	a5,a5
    80013326:	cf99                	beqz	a5,80013344 <_ftoa+0x4f4>
            buf[len++] = '+';  // ignore the space if the '+' exists
    80013328:	fe843783          	ld	a5,-24(s0)
    8001332c:	00178713          	addi	a4,a5,1
    80013330:	fee43423          	sd	a4,-24(s0)
    80013334:	ff040713          	addi	a4,s0,-16
    80013338:	97ba                	add	a5,a5,a4
    8001333a:	02b00713          	li	a4,43
    8001333e:	fae78823          	sb	a4,-80(a5)
    80013342:	a01d                	j	80013368 <_ftoa+0x518>
        }
        else if (flags & FLAGS_SPACE) {
    80013344:	f6c42783          	lw	a5,-148(s0)
    80013348:	8ba1                	andi	a5,a5,8
    8001334a:	2781                	sext.w	a5,a5
    8001334c:	cf91                	beqz	a5,80013368 <_ftoa+0x518>
            buf[len++] = ' ';
    8001334e:	fe843783          	ld	a5,-24(s0)
    80013352:	00178713          	addi	a4,a5,1
    80013356:	fee43423          	sd	a4,-24(s0)
    8001335a:	ff040713          	addi	a4,s0,-16
    8001335e:	97ba                	add	a5,a5,a4
    80013360:	02000713          	li	a4,32
    80013364:	fae78823          	sb	a4,-80(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    80013368:	f6c42683          	lw	a3,-148(s0)
    8001336c:	f7042783          	lw	a5,-144(s0)
    80013370:	fa040713          	addi	a4,s0,-96
    80013374:	88b6                	mv	a7,a3
    80013376:	883e                	mv	a6,a5
    80013378:	fe843783          	ld	a5,-24(s0)
    8001337c:	f8043683          	ld	a3,-128(s0)
    80013380:	f8843603          	ld	a2,-120(s0)
    80013384:	f9043583          	ld	a1,-112(s0)
    80013388:	f9843503          	ld	a0,-104(s0)
    8001338c:	ce8ff0ef          	jal	ra,80012874 <_out_rev>
    80013390:	87aa                	mv	a5,a0
}
    80013392:	853e                	mv	a0,a5
    80013394:	60ea                	ld	ra,152(sp)
    80013396:	644a                	ld	s0,144(sp)
    80013398:	610d                	addi	sp,sp,160
    8001339a:	8082                	ret

000000008001339c <_etoa>:
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    8001339c:	7135                	addi	sp,sp,-160
    8001339e:	ed06                	sd	ra,152(sp)
    800133a0:	e922                	sd	s0,144(sp)
    800133a2:	1100                	addi	s0,sp,160
    800133a4:	faa43423          	sd	a0,-88(s0)
    800133a8:	fab43023          	sd	a1,-96(s0)
    800133ac:	f8c43c23          	sd	a2,-104(s0)
    800133b0:	f8d43823          	sd	a3,-112(s0)
    800133b4:	f8a43427          	fsd	fa0,-120(s0)
    800133b8:	863a                	mv	a2,a4
    800133ba:	86be                	mv	a3,a5
    800133bc:	8742                	mv	a4,a6
    800133be:	87b2                	mv	a5,a2
    800133c0:	f8f42223          	sw	a5,-124(s0)
    800133c4:	87b6                	mv	a5,a3
    800133c6:	f8f42023          	sw	a5,-128(s0)
    800133ca:	87ba                	mv	a5,a4
    800133cc:	f6f42e23          	sw	a5,-132(s0)
    // check for NaN and special values
    if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    800133d0:	f8843707          	fld	fa4,-120(s0)
    800133d4:	f8843787          	fld	fa5,-120(s0)
    800133d8:	a2f727d3          	feq.d	a5,fa4,fa5
    800133dc:	c78d                	beqz	a5,80013406 <_etoa+0x6a>
    800133de:	f8843707          	fld	fa4,-120(s0)
    800133e2:	00006797          	auipc	a5,0x6
    800133e6:	4ee78793          	addi	a5,a5,1262 # 800198d0 <pow10.0+0x58>
    800133ea:	239c                	fld	fa5,0(a5)
    800133ec:	a2e797d3          	flt.d	a5,fa5,fa4
    800133f0:	eb99                	bnez	a5,80013406 <_etoa+0x6a>
    800133f2:	f8843707          	fld	fa4,-120(s0)
    800133f6:	00006797          	auipc	a5,0x6
    800133fa:	4d278793          	addi	a5,a5,1234 # 800198c8 <pow10.0+0x50>
    800133fe:	239c                	fld	fa5,0(a5)
    80013400:	a2f717d3          	flt.d	a5,fa4,fa5
    80013404:	c795                	beqz	a5,80013430 <_etoa+0x94>
        return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80013406:	f7c42683          	lw	a3,-132(s0)
    8001340a:	f8042783          	lw	a5,-128(s0)
    8001340e:	f8442703          	lw	a4,-124(s0)
    80013412:	8836                	mv	a6,a3
    80013414:	f8843507          	fld	fa0,-120(s0)
    80013418:	f9043683          	ld	a3,-112(s0)
    8001341c:	f9843603          	ld	a2,-104(s0)
    80013420:	fa043583          	ld	a1,-96(s0)
    80013424:	fa843503          	ld	a0,-88(s0)
    80013428:	a29ff0ef          	jal	ra,80012e50 <_ftoa>
    8001342c:	87aa                	mv	a5,a0
    8001342e:	a11d                	j	80013854 <_etoa+0x4b8>
    }

    // determine the sign
    const bool negative = value < 0;
    80013430:	f8843787          	fld	fa5,-120(s0)
    80013434:	f2000753          	fmv.d.x	fa4,zero
    80013438:	a2e797d3          	flt.d	a5,fa5,fa4
    8001343c:	00f037b3          	snez	a5,a5
    80013440:	fef401a3          	sb	a5,-29(s0)
    if (negative) {
    80013444:	fe344783          	lbu	a5,-29(s0)
    80013448:	0ff7f793          	andi	a5,a5,255
    8001344c:	c799                	beqz	a5,8001345a <_etoa+0xbe>
        value = -value;
    8001344e:	f8843787          	fld	fa5,-120(s0)
    80013452:	22f797d3          	fneg.d	fa5,fa5
    80013456:	f8f43427          	fsd	fa5,-120(s0)
    }

    // default precision
    if (!(flags & FLAGS_PRECISION)) {
    8001345a:	f7c42783          	lw	a5,-132(s0)
    8001345e:	4007f793          	andi	a5,a5,1024
    80013462:	2781                	sext.w	a5,a5
    80013464:	e781                	bnez	a5,8001346c <_etoa+0xd0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80013466:	4799                	li	a5,6
    80013468:	f8f42223          	sw	a5,-124(s0)
    union {
        uint64_t U;
        double F;
    } conv;

    conv.F   = value;
    8001346c:	f8843787          	fld	fa5,-120(s0)
    80013470:	faf43c27          	fsd	fa5,-72(s0)
    int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;  // effectively log2
    80013474:	fb843783          	ld	a5,-72(s0)
    80013478:	93d1                	srli	a5,a5,0x34
    8001347a:	2781                	sext.w	a5,a5
    8001347c:	7ff7f793          	andi	a5,a5,2047
    80013480:	2781                	sext.w	a5,a5
    80013482:	c017879b          	addiw	a5,a5,-1023
    80013486:	fcf42e23          	sw	a5,-36(s0)
    conv.U   = (conv.U & ((1ULL << 52U) - 1U)) |
    8001348a:	fb843703          	ld	a4,-72(s0)
    8001348e:	57fd                	li	a5,-1
    80013490:	83b1                	srli	a5,a5,0xc
    80013492:	8f7d                	and	a4,a4,a5
    80013494:	3ff00793          	li	a5,1023
    80013498:	17d2                	slli	a5,a5,0x34
    8001349a:	8fd9                	or	a5,a5,a4
    8001349c:	faf43c23          	sd	a5,-72(s0)
             (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    // now approximate log10 from the log2 integer part and an expansion of ln
    // around 1.5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    800134a0:	fdc42783          	lw	a5,-36(s0)
    800134a4:	d2078753          	fcvt.d.w	fa4,a5
    800134a8:	00006797          	auipc	a5,0x6
    800134ac:	44878793          	addi	a5,a5,1096 # 800198f0 <pow10.0+0x78>
    800134b0:	239c                	fld	fa5,0(a5)
    800134b2:	12f77753          	fmul.d	fa4,fa4,fa5
    800134b6:	00006797          	auipc	a5,0x6
    800134ba:	44278793          	addi	a5,a5,1090 # 800198f8 <pow10.0+0x80>
    800134be:	239c                	fld	fa5,0(a5)
    800134c0:	02f77753          	fadd.d	fa4,fa4,fa5
                       (conv.F - 1.5) * 0.289529654602168);
    800134c4:	fb843687          	fld	fa3,-72(s0)
    800134c8:	00006797          	auipc	a5,0x6
    800134cc:	43878793          	addi	a5,a5,1080 # 80019900 <pow10.0+0x88>
    800134d0:	239c                	fld	fa5,0(a5)
    800134d2:	0af6f6d3          	fsub.d	fa3,fa3,fa5
    800134d6:	00006797          	auipc	a5,0x6
    800134da:	43278793          	addi	a5,a5,1074 # 80019908 <pow10.0+0x90>
    800134de:	239c                	fld	fa5,0(a5)
    800134e0:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    800134e4:	02f777d3          	fadd.d	fa5,fa4,fa5
    800134e8:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    800134ec:	fef42623          	sw	a5,-20(s0)
    // now we want to compute 10^expval but we want to be sure it won't overflow
    exp2            = (int)(expval * 3.321928094887362 + 0.5);
    800134f0:	fec42783          	lw	a5,-20(s0)
    800134f4:	d2078753          	fcvt.d.w	fa4,a5
    800134f8:	00006797          	auipc	a5,0x6
    800134fc:	41878793          	addi	a5,a5,1048 # 80019910 <pow10.0+0x98>
    80013500:	239c                	fld	fa5,0(a5)
    80013502:	12f77753          	fmul.d	fa4,fa4,fa5
    80013506:	00006797          	auipc	a5,0x6
    8001350a:	3e278793          	addi	a5,a5,994 # 800198e8 <pow10.0+0x70>
    8001350e:	239c                	fld	fa5,0(a5)
    80013510:	02f777d3          	fadd.d	fa5,fa4,fa5
    80013514:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80013518:	fcf42e23          	sw	a5,-36(s0)
    const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    8001351c:	fec42783          	lw	a5,-20(s0)
    80013520:	d2078753          	fcvt.d.w	fa4,a5
    80013524:	00006797          	auipc	a5,0x6
    80013528:	3f478793          	addi	a5,a5,1012 # 80019918 <pow10.0+0xa0>
    8001352c:	239c                	fld	fa5,0(a5)
    8001352e:	12f77753          	fmul.d	fa4,fa4,fa5
    80013532:	fdc42783          	lw	a5,-36(s0)
    80013536:	d20786d3          	fcvt.d.w	fa3,a5
    8001353a:	00006797          	auipc	a5,0x6
    8001353e:	3e678793          	addi	a5,a5,998 # 80019920 <pow10.0+0xa8>
    80013542:	239c                	fld	fa5,0(a5)
    80013544:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    80013548:	0af777d3          	fsub.d	fa5,fa4,fa5
    8001354c:	fcf43827          	fsd	fa5,-48(s0)
    const double z2 = z * z;
    80013550:	fd043787          	fld	fa5,-48(s0)
    80013554:	12f7f7d3          	fmul.d	fa5,fa5,fa5
    80013558:	fcf43427          	fsd	fa5,-56(s0)
    conv.U          = (uint64_t)(exp2 + 1023) << 52U;
    8001355c:	fdc42783          	lw	a5,-36(s0)
    80013560:	3ff7879b          	addiw	a5,a5,1023
    80013564:	2781                	sext.w	a5,a5
    80013566:	17d2                	slli	a5,a5,0x34
    80013568:	faf43c23          	sd	a5,-72(s0)
    // compute exp(z) using continued fractions, see
    // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    8001356c:	fb843707          	fld	fa4,-72(s0)
    80013570:	fd043787          	fld	fa5,-48(s0)
    80013574:	02f7f6d3          	fadd.d	fa3,fa5,fa5
    80013578:	00006797          	auipc	a5,0x6
    8001357c:	3b078793          	addi	a5,a5,944 # 80019928 <pow10.0+0xb0>
    80013580:	2390                	fld	fa2,0(a5)
    80013582:	fd043787          	fld	fa5,-48(s0)
    80013586:	0af67653          	fsub.d	fa2,fa2,fa5
    8001358a:	fc843587          	fld	fa1,-56(s0)
    8001358e:	00006797          	auipc	a5,0x6
    80013592:	3a278793          	addi	a5,a5,930 # 80019930 <pow10.0+0xb8>
    80013596:	239c                	fld	fa5,0(a5)
    80013598:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    8001359c:	00006797          	auipc	a5,0x6
    800135a0:	39c78793          	addi	a5,a5,924 # 80019938 <pow10.0+0xc0>
    800135a4:	239c                	fld	fa5,0(a5)
    800135a6:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800135aa:	fc843587          	fld	fa1,-56(s0)
    800135ae:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    800135b2:	00006797          	auipc	a5,0x6
    800135b6:	38e78793          	addi	a5,a5,910 # 80019940 <pow10.0+0xc8>
    800135ba:	239c                	fld	fa5,0(a5)
    800135bc:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800135c0:	fc843587          	fld	fa1,-56(s0)
    800135c4:	1af5f7d3          	fdiv.d	fa5,fa1,fa5
    800135c8:	02f677d3          	fadd.d	fa5,fa2,fa5
    800135cc:	1af6f6d3          	fdiv.d	fa3,fa3,fa5
    800135d0:	00006797          	auipc	a5,0x6
    800135d4:	37878793          	addi	a5,a5,888 # 80019948 <pow10.0+0xd0>
    800135d8:	239c                	fld	fa5,0(a5)
    800135da:	02f6f7d3          	fadd.d	fa5,fa3,fa5
    800135de:	12f777d3          	fmul.d	fa5,fa4,fa5
    800135e2:	faf43c27          	fsd	fa5,-72(s0)
    // correct for rounding errors
    if (value < conv.F) {
    800135e6:	fb843787          	fld	fa5,-72(s0)
    800135ea:	f8843707          	fld	fa4,-120(s0)
    800135ee:	a2f717d3          	flt.d	a5,fa4,fa5
    800135f2:	c38d                	beqz	a5,80013614 <_etoa+0x278>
        expval--;
    800135f4:	fec42783          	lw	a5,-20(s0)
    800135f8:	37fd                	addiw	a5,a5,-1
    800135fa:	fef42623          	sw	a5,-20(s0)
        conv.F /= 10;
    800135fe:	fb843707          	fld	fa4,-72(s0)
    80013602:	00006797          	auipc	a5,0x6
    80013606:	33678793          	addi	a5,a5,822 # 80019938 <pow10.0+0xc0>
    8001360a:	239c                	fld	fa5,0(a5)
    8001360c:	1af777d3          	fdiv.d	fa5,fa4,fa5
    80013610:	faf43c27          	fsd	fa5,-72(s0)
    }

    // the exponent format is "%+03d" and largest value is "307", so set aside
    // 4-5 characters
    unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    80013614:	fec42783          	lw	a5,-20(s0)
    80013618:	0007871b          	sext.w	a4,a5
    8001361c:	06300793          	li	a5,99
    80013620:	00e7cc63          	blt	a5,a4,80013638 <_etoa+0x29c>
    80013624:	fec42783          	lw	a5,-20(s0)
    80013628:	0007871b          	sext.w	a4,a5
    8001362c:	f9d00793          	li	a5,-99
    80013630:	00f74463          	blt	a4,a5,80013638 <_etoa+0x29c>
    80013634:	4791                	li	a5,4
    80013636:	a011                	j	8001363a <_etoa+0x29e>
    80013638:	4795                	li	a5,5
    8001363a:	fef42423          	sw	a5,-24(s0)

    // in "%g" mode, "prec" is the number of *significant figures* not decimals
    if (flags & FLAGS_ADAPT_EXP) {
    8001363e:	f7c42703          	lw	a4,-132(s0)
    80013642:	6785                	lui	a5,0x1
    80013644:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80013648:	8ff9                	and	a5,a5,a4
    8001364a:	2781                	sext.w	a5,a5
    8001364c:	c7c1                	beqz	a5,800136d4 <_etoa+0x338>
        // do we want to fall-back to "%f" mode?
        if ((value >= 1e-4) && (value < 1e6)) {
    8001364e:	f8843707          	fld	fa4,-120(s0)
    80013652:	00006797          	auipc	a5,0x6
    80013656:	2fe78793          	addi	a5,a5,766 # 80019950 <pow10.0+0xd8>
    8001365a:	239c                	fld	fa5,0(a5)
    8001365c:	a2e787d3          	fle.d	a5,fa5,fa4
    80013660:	cbb9                	beqz	a5,800136b6 <_etoa+0x31a>
    80013662:	f8843707          	fld	fa4,-120(s0)
    80013666:	00006797          	auipc	a5,0x6
    8001366a:	2f278793          	addi	a5,a5,754 # 80019958 <pow10.0+0xe0>
    8001366e:	239c                	fld	fa5,0(a5)
    80013670:	a2f717d3          	flt.d	a5,fa4,fa5
    80013674:	c3a9                	beqz	a5,800136b6 <_etoa+0x31a>
            if ((int)prec > expval) {
    80013676:	f8442703          	lw	a4,-124(s0)
    8001367a:	fec42783          	lw	a5,-20(s0)
    8001367e:	2781                	sext.w	a5,a5
    80013680:	00e7de63          	bge	a5,a4,8001369c <_etoa+0x300>
                prec = (unsigned)((int)prec - expval - 1);
    80013684:	f8442703          	lw	a4,-124(s0)
    80013688:	fec42783          	lw	a5,-20(s0)
    8001368c:	40f707bb          	subw	a5,a4,a5
    80013690:	2781                	sext.w	a5,a5
    80013692:	37fd                	addiw	a5,a5,-1
    80013694:	2781                	sext.w	a5,a5
    80013696:	f8f42223          	sw	a5,-124(s0)
    8001369a:	a019                	j	800136a0 <_etoa+0x304>
            }
            else {
                prec = 0;
    8001369c:	f8042223          	sw	zero,-124(s0)
            }
            flags |= FLAGS_PRECISION;  // make sure _ftoa respects precision
    800136a0:	f7c42783          	lw	a5,-132(s0)
    800136a4:	4007e793          	ori	a5,a5,1024
    800136a8:	f6f42e23          	sw	a5,-132(s0)
            // no characters in exponent
            minwidth = 0U;
    800136ac:	fe042423          	sw	zero,-24(s0)
            expval   = 0;
    800136b0:	fe042623          	sw	zero,-20(s0)
    800136b4:	a005                	j	800136d4 <_etoa+0x338>
        }
        else {
            // we use one sigfig for the whole part
            if ((prec > 0) && (flags & FLAGS_PRECISION)) {
    800136b6:	f8442783          	lw	a5,-124(s0)
    800136ba:	2781                	sext.w	a5,a5
    800136bc:	cf81                	beqz	a5,800136d4 <_etoa+0x338>
    800136be:	f7c42783          	lw	a5,-132(s0)
    800136c2:	4007f793          	andi	a5,a5,1024
    800136c6:	2781                	sext.w	a5,a5
    800136c8:	c791                	beqz	a5,800136d4 <_etoa+0x338>
                --prec;
    800136ca:	f8442783          	lw	a5,-124(s0)
    800136ce:	37fd                	addiw	a5,a5,-1
    800136d0:	f8f42223          	sw	a5,-124(s0)
            }
        }
    }

    // will everything fit?
    unsigned int fwidth = width;
    800136d4:	f8042783          	lw	a5,-128(s0)
    800136d8:	fef42223          	sw	a5,-28(s0)
    if (width > minwidth) {
    800136dc:	f8042703          	lw	a4,-128(s0)
    800136e0:	fe842783          	lw	a5,-24(s0)
    800136e4:	2701                	sext.w	a4,a4
    800136e6:	2781                	sext.w	a5,a5
    800136e8:	00e7fb63          	bgeu	a5,a4,800136fe <_etoa+0x362>
        // we didn't fall-back so subtract the characters required for the
        // exponent
        fwidth -= minwidth;
    800136ec:	fe442703          	lw	a4,-28(s0)
    800136f0:	fe842783          	lw	a5,-24(s0)
    800136f4:	40f707bb          	subw	a5,a4,a5
    800136f8:	fef42223          	sw	a5,-28(s0)
    800136fc:	a019                	j	80013702 <_etoa+0x366>
    }
    else {
        // not enough characters, so go back to default sizing
        fwidth = 0U;
    800136fe:	fe042223          	sw	zero,-28(s0)
    }
    if ((flags & FLAGS_LEFT) && minwidth) {
    80013702:	f7c42783          	lw	a5,-132(s0)
    80013706:	8b89                	andi	a5,a5,2
    80013708:	2781                	sext.w	a5,a5
    8001370a:	c799                	beqz	a5,80013718 <_etoa+0x37c>
    8001370c:	fe842783          	lw	a5,-24(s0)
    80013710:	2781                	sext.w	a5,a5
    80013712:	c399                	beqz	a5,80013718 <_etoa+0x37c>
        // if we're padding on the right, DON'T pad the floating part
        fwidth = 0U;
    80013714:	fe042223          	sw	zero,-28(s0)
    }

    // rescale the float value
    if (expval) {
    80013718:	fec42783          	lw	a5,-20(s0)
    8001371c:	2781                	sext.w	a5,a5
    8001371e:	cb89                	beqz	a5,80013730 <_etoa+0x394>
        value /= conv.F;
    80013720:	fb843787          	fld	fa5,-72(s0)
    80013724:	f8843707          	fld	fa4,-120(s0)
    80013728:	1af777d3          	fdiv.d	fa5,fa4,fa5
    8001372c:	f8f43427          	fsd	fa5,-120(s0)
    }

    // output the floating part
    const size_t start_idx = idx;
    80013730:	f9843783          	ld	a5,-104(s0)
    80013734:	fcf43023          	sd	a5,-64(s0)
    idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec,
    80013738:	fe344783          	lbu	a5,-29(s0)
    8001373c:	0ff7f793          	andi	a5,a5,255
    80013740:	c791                	beqz	a5,8001374c <_etoa+0x3b0>
    80013742:	f8843787          	fld	fa5,-120(s0)
    80013746:	22f797d3          	fneg.d	fa5,fa5
    8001374a:	a019                	j	80013750 <_etoa+0x3b4>
    8001374c:	f8843787          	fld	fa5,-120(s0)
    80013750:	f7c42703          	lw	a4,-132(s0)
    80013754:	77fd                	lui	a5,0xfffff
    80013756:	7ff78793          	addi	a5,a5,2047 # fffffffffffff7ff <_heap_end+0xffffffff77fef7ff>
    8001375a:	8ff9                	and	a5,a5,a4
    8001375c:	0007869b          	sext.w	a3,a5
    80013760:	fe442783          	lw	a5,-28(s0)
    80013764:	f8442703          	lw	a4,-124(s0)
    80013768:	8836                	mv	a6,a3
    8001376a:	22f78553          	fmv.d	fa0,fa5
    8001376e:	f9043683          	ld	a3,-112(s0)
    80013772:	f9843603          	ld	a2,-104(s0)
    80013776:	fa043583          	ld	a1,-96(s0)
    8001377a:	fa843503          	ld	a0,-88(s0)
    8001377e:	ed2ff0ef          	jal	ra,80012e50 <_ftoa>
    80013782:	f8a43c23          	sd	a0,-104(s0)
                fwidth, flags & ~FLAGS_ADAPT_EXP);

    // output the exponent part
    if (minwidth) {
    80013786:	fe842783          	lw	a5,-24(s0)
    8001378a:	2781                	sext.w	a5,a5
    8001378c:	c3f1                	beqz	a5,80013850 <_etoa+0x4b4>
        // output the exponential symbol
        out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    8001378e:	f7c42783          	lw	a5,-132(s0)
    80013792:	0207f793          	andi	a5,a5,32
    80013796:	2781                	sext.w	a5,a5
    80013798:	c781                	beqz	a5,800137a0 <_etoa+0x404>
    8001379a:	04500793          	li	a5,69
    8001379e:	a019                	j	800137a4 <_etoa+0x408>
    800137a0:	06500793          	li	a5,101
    800137a4:	f9843703          	ld	a4,-104(s0)
    800137a8:	00170693          	addi	a3,a4,1
    800137ac:	f8d43c23          	sd	a3,-104(s0)
    800137b0:	fa843803          	ld	a6,-88(s0)
    800137b4:	f9043683          	ld	a3,-112(s0)
    800137b8:	863a                	mv	a2,a4
    800137ba:	fa043583          	ld	a1,-96(s0)
    800137be:	853e                	mv	a0,a5
    800137c0:	9802                	jalr	a6
        // output the exponent value
        idx = _ntoa_long(out, buffer, idx, maxlen,
                         (expval < 0) ? -expval : expval, expval < 0, 10, 0,
    800137c2:	fec42783          	lw	a5,-20(s0)
    800137c6:	41f7d79b          	sraiw	a5,a5,0x1f
    800137ca:	fec42703          	lw	a4,-20(s0)
    800137ce:	8f3d                	xor	a4,a4,a5
    800137d0:	40f707bb          	subw	a5,a4,a5
    800137d4:	2781                	sext.w	a5,a5
        idx = _ntoa_long(out, buffer, idx, maxlen,
    800137d6:	863e                	mv	a2,a5
    800137d8:	fec42783          	lw	a5,-20(s0)
    800137dc:	01f7d79b          	srliw	a5,a5,0x1f
    800137e0:	0ff7f693          	andi	a3,a5,255
    800137e4:	fe842783          	lw	a5,-24(s0)
    800137e8:	37fd                	addiw	a5,a5,-1
    800137ea:	2781                	sext.w	a5,a5
    800137ec:	4715                	li	a4,5
    800137ee:	e43a                	sd	a4,8(sp)
    800137f0:	e03e                	sd	a5,0(sp)
    800137f2:	4881                	li	a7,0
    800137f4:	4829                	li	a6,10
    800137f6:	87b6                	mv	a5,a3
    800137f8:	8732                	mv	a4,a2
    800137fa:	f9043683          	ld	a3,-112(s0)
    800137fe:	f9843603          	ld	a2,-104(s0)
    80013802:	fa043583          	ld	a1,-96(s0)
    80013806:	fa843503          	ld	a0,-88(s0)
    8001380a:	c16ff0ef          	jal	ra,80012c20 <_ntoa_long>
    8001380e:	f8a43c23          	sd	a0,-104(s0)
                         minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
        // might need to right-pad spaces
        if (flags & FLAGS_LEFT) {
    80013812:	f7c42783          	lw	a5,-132(s0)
    80013816:	8b89                	andi	a5,a5,2
    80013818:	2781                	sext.w	a5,a5
    8001381a:	cb9d                	beqz	a5,80013850 <_etoa+0x4b4>
            while (idx - start_idx < width)
    8001381c:	a00d                	j	8001383e <_etoa+0x4a2>
                out(' ', buffer, idx++, maxlen);
    8001381e:	f9843783          	ld	a5,-104(s0)
    80013822:	00178713          	addi	a4,a5,1
    80013826:	f8e43c23          	sd	a4,-104(s0)
    8001382a:	fa843703          	ld	a4,-88(s0)
    8001382e:	f9043683          	ld	a3,-112(s0)
    80013832:	863e                	mv	a2,a5
    80013834:	fa043583          	ld	a1,-96(s0)
    80013838:	02000513          	li	a0,32
    8001383c:	9702                	jalr	a4
            while (idx - start_idx < width)
    8001383e:	f9843703          	ld	a4,-104(s0)
    80013842:	fc043783          	ld	a5,-64(s0)
    80013846:	8f1d                	sub	a4,a4,a5
    80013848:	f8046783          	lwu	a5,-128(s0)
    8001384c:	fcf769e3          	bltu	a4,a5,8001381e <_etoa+0x482>
        }
    }
    return idx;
    80013850:	f9843783          	ld	a5,-104(s0)
}
    80013854:	853e                	mv	a0,a5
    80013856:	60ea                	ld	ra,152(sp)
    80013858:	644a                	ld	s0,144(sp)
    8001385a:	610d                	addi	sp,sp,160
    8001385c:	8082                	ret

000000008001385e <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
                      const char *format, va_list va)
{
    8001385e:	7135                	addi	sp,sp,-160
    80013860:	ed06                	sd	ra,152(sp)
    80013862:	e922                	sd	s0,144(sp)
    80013864:	1100                	addi	s0,sp,160
    80013866:	f8a43c23          	sd	a0,-104(s0)
    8001386a:	f8b43823          	sd	a1,-112(s0)
    8001386e:	f8c43423          	sd	a2,-120(s0)
    80013872:	f8d43023          	sd	a3,-128(s0)
    80013876:	f6e43c23          	sd	a4,-136(s0)
    unsigned int flags, width, precision, n;
    size_t idx = 0U;
    8001387a:	fc043c23          	sd	zero,-40(s0)

    if (!buffer) {
    8001387e:	f9043783          	ld	a5,-112(s0)
    80013882:	380792e3          	bnez	a5,80014406 <_vsnprintf+0xba8>
        // use null output function
        out = _out_null;
    80013886:	fffff797          	auipc	a5,0xfffff
    8001388a:	e5878793          	addi	a5,a5,-424 # 800126de <_out_null>
    8001388e:	f8f43c23          	sd	a5,-104(s0)
    }

    while (*format) {
    80013892:	3750006f          	j	80014406 <_vsnprintf+0xba8>
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
    80013896:	f8043783          	ld	a5,-128(s0)
    8001389a:	0007c783          	lbu	a5,0(a5)
    8001389e:	873e                	mv	a4,a5
    800138a0:	02500793          	li	a5,37
    800138a4:	02f70b63          	beq	a4,a5,800138da <_vsnprintf+0x7c>
            // no
            out(*format, buffer, idx++, maxlen);
    800138a8:	f8043783          	ld	a5,-128(s0)
    800138ac:	0007c503          	lbu	a0,0(a5)
    800138b0:	fd843783          	ld	a5,-40(s0)
    800138b4:	00178713          	addi	a4,a5,1
    800138b8:	fce43c23          	sd	a4,-40(s0)
    800138bc:	f9843703          	ld	a4,-104(s0)
    800138c0:	f8843683          	ld	a3,-120(s0)
    800138c4:	863e                	mv	a2,a5
    800138c6:	f9043583          	ld	a1,-112(s0)
    800138ca:	9702                	jalr	a4
            format++;
    800138cc:	f8043783          	ld	a5,-128(s0)
    800138d0:	0785                	addi	a5,a5,1
    800138d2:	f8f43023          	sd	a5,-128(s0)
            continue;
    800138d6:	3310006f          	j	80014406 <_vsnprintf+0xba8>
        }
        else {
            // yes, evaluate it
            format++;
    800138da:	f8043783          	ld	a5,-128(s0)
    800138de:	0785                	addi	a5,a5,1
    800138e0:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate flags
        flags = 0U;
    800138e4:	fe042623          	sw	zero,-20(s0)
        do {
            switch (*format) {
    800138e8:	f8043783          	ld	a5,-128(s0)
    800138ec:	0007c783          	lbu	a5,0(a5)
    800138f0:	2781                	sext.w	a5,a5
    800138f2:	fe07869b          	addiw	a3,a5,-32
    800138f6:	0006871b          	sext.w	a4,a3
    800138fa:	47c1                	li	a5,16
    800138fc:	0ce7e063          	bltu	a5,a4,800139bc <_vsnprintf+0x15e>
    80013900:	02069793          	slli	a5,a3,0x20
    80013904:	9381                	srli	a5,a5,0x20
    80013906:	00279713          	slli	a4,a5,0x2
    8001390a:	00006797          	auipc	a5,0x6
    8001390e:	d8a78793          	addi	a5,a5,-630 # 80019694 <SYSCALLS+0x694>
    80013912:	97ba                	add	a5,a5,a4
    80013914:	439c                	lw	a5,0(a5)
    80013916:	0007871b          	sext.w	a4,a5
    8001391a:	00006797          	auipc	a5,0x6
    8001391e:	d7a78793          	addi	a5,a5,-646 # 80019694 <SYSCALLS+0x694>
    80013922:	97ba                	add	a5,a5,a4
    80013924:	8782                	jr	a5
                case '0':
                    flags |= FLAGS_ZEROPAD;
    80013926:	fec42783          	lw	a5,-20(s0)
    8001392a:	0017e793          	ori	a5,a5,1
    8001392e:	fef42623          	sw	a5,-20(s0)
                    format++;
    80013932:	f8043783          	ld	a5,-128(s0)
    80013936:	0785                	addi	a5,a5,1
    80013938:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    8001393c:	4785                	li	a5,1
    8001393e:	fef42023          	sw	a5,-32(s0)
                    break;
    80013942:	a041                	j	800139c2 <_vsnprintf+0x164>
                case '-':
                    flags |= FLAGS_LEFT;
    80013944:	fec42783          	lw	a5,-20(s0)
    80013948:	0027e793          	ori	a5,a5,2
    8001394c:	fef42623          	sw	a5,-20(s0)
                    format++;
    80013950:	f8043783          	ld	a5,-128(s0)
    80013954:	0785                	addi	a5,a5,1
    80013956:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    8001395a:	4785                	li	a5,1
    8001395c:	fef42023          	sw	a5,-32(s0)
                    break;
    80013960:	a08d                	j	800139c2 <_vsnprintf+0x164>
                case '+':
                    flags |= FLAGS_PLUS;
    80013962:	fec42783          	lw	a5,-20(s0)
    80013966:	0047e793          	ori	a5,a5,4
    8001396a:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001396e:	f8043783          	ld	a5,-128(s0)
    80013972:	0785                	addi	a5,a5,1
    80013974:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80013978:	4785                	li	a5,1
    8001397a:	fef42023          	sw	a5,-32(s0)
                    break;
    8001397e:	a091                	j	800139c2 <_vsnprintf+0x164>
                case ' ':
                    flags |= FLAGS_SPACE;
    80013980:	fec42783          	lw	a5,-20(s0)
    80013984:	0087e793          	ori	a5,a5,8
    80013988:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001398c:	f8043783          	ld	a5,-128(s0)
    80013990:	0785                	addi	a5,a5,1
    80013992:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80013996:	4785                	li	a5,1
    80013998:	fef42023          	sw	a5,-32(s0)
                    break;
    8001399c:	a01d                	j	800139c2 <_vsnprintf+0x164>
                case '#':
                    flags |= FLAGS_HASH;
    8001399e:	fec42783          	lw	a5,-20(s0)
    800139a2:	0107e793          	ori	a5,a5,16
    800139a6:	fef42623          	sw	a5,-20(s0)
                    format++;
    800139aa:	f8043783          	ld	a5,-128(s0)
    800139ae:	0785                	addi	a5,a5,1
    800139b0:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    800139b4:	4785                	li	a5,1
    800139b6:	fef42023          	sw	a5,-32(s0)
                    break;
    800139ba:	a021                	j	800139c2 <_vsnprintf+0x164>
                default:
                    n = 0U;
    800139bc:	fe042023          	sw	zero,-32(s0)
                    break;
    800139c0:	0001                	nop
            }
        } while (n);
    800139c2:	fe042783          	lw	a5,-32(s0)
    800139c6:	2781                	sext.w	a5,a5
    800139c8:	f385                	bnez	a5,800138e8 <_vsnprintf+0x8a>

        // evaluate width field
        width = 0U;
    800139ca:	fe042423          	sw	zero,-24(s0)
        if (_is_digit(*format)) {
    800139ce:	f8043783          	ld	a5,-128(s0)
    800139d2:	0007c783          	lbu	a5,0(a5)
    800139d6:	853e                	mv	a0,a5
    800139d8:	df3fe0ef          	jal	ra,800127ca <_is_digit>
    800139dc:	87aa                	mv	a5,a0
    800139de:	cb91                	beqz	a5,800139f2 <_vsnprintf+0x194>
            width = _atoi(&format);
    800139e0:	f8040793          	addi	a5,s0,-128
    800139e4:	853e                	mv	a0,a5
    800139e6:	e25fe0ef          	jal	ra,8001280a <_atoi>
    800139ea:	87aa                	mv	a5,a0
    800139ec:	fef42423          	sw	a5,-24(s0)
    800139f0:	a8b9                	j	80013a4e <_vsnprintf+0x1f0>
        }
        else if (*format == '*') {
    800139f2:	f8043783          	ld	a5,-128(s0)
    800139f6:	0007c783          	lbu	a5,0(a5)
    800139fa:	873e                	mv	a4,a5
    800139fc:	02a00793          	li	a5,42
    80013a00:	04f71763          	bne	a4,a5,80013a4e <_vsnprintf+0x1f0>
            const int w = va_arg(va, int);
    80013a04:	f7843783          	ld	a5,-136(s0)
    80013a08:	00878713          	addi	a4,a5,8
    80013a0c:	f6e43c23          	sd	a4,-136(s0)
    80013a10:	439c                	lw	a5,0(a5)
    80013a12:	fcf42023          	sw	a5,-64(s0)
            if (w < 0) {
    80013a16:	fc042783          	lw	a5,-64(s0)
    80013a1a:	2781                	sext.w	a5,a5
    80013a1c:	0207d063          	bgez	a5,80013a3c <_vsnprintf+0x1de>
                flags |= FLAGS_LEFT;  // reverse padding
    80013a20:	fec42783          	lw	a5,-20(s0)
    80013a24:	0027e793          	ori	a5,a5,2
    80013a28:	fef42623          	sw	a5,-20(s0)
                width = (unsigned int)-w;
    80013a2c:	fc042783          	lw	a5,-64(s0)
    80013a30:	40f007bb          	negw	a5,a5
    80013a34:	2781                	sext.w	a5,a5
    80013a36:	fef42423          	sw	a5,-24(s0)
    80013a3a:	a029                	j	80013a44 <_vsnprintf+0x1e6>
            }
            else {
                width = (unsigned int)w;
    80013a3c:	fc042783          	lw	a5,-64(s0)
    80013a40:	fef42423          	sw	a5,-24(s0)
            }
            format++;
    80013a44:	f8043783          	ld	a5,-128(s0)
    80013a48:	0785                	addi	a5,a5,1
    80013a4a:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate precision field
        precision = 0U;
    80013a4e:	fe042223          	sw	zero,-28(s0)
        if (*format == '.') {
    80013a52:	f8043783          	ld	a5,-128(s0)
    80013a56:	0007c783          	lbu	a5,0(a5)
    80013a5a:	873e                	mv	a4,a5
    80013a5c:	02e00793          	li	a5,46
    80013a60:	08f71063          	bne	a4,a5,80013ae0 <_vsnprintf+0x282>
            flags |= FLAGS_PRECISION;
    80013a64:	fec42783          	lw	a5,-20(s0)
    80013a68:	4007e793          	ori	a5,a5,1024
    80013a6c:	fef42623          	sw	a5,-20(s0)
            format++;
    80013a70:	f8043783          	ld	a5,-128(s0)
    80013a74:	0785                	addi	a5,a5,1
    80013a76:	f8f43023          	sd	a5,-128(s0)
            if (_is_digit(*format)) {
    80013a7a:	f8043783          	ld	a5,-128(s0)
    80013a7e:	0007c783          	lbu	a5,0(a5)
    80013a82:	853e                	mv	a0,a5
    80013a84:	d47fe0ef          	jal	ra,800127ca <_is_digit>
    80013a88:	87aa                	mv	a5,a0
    80013a8a:	cb91                	beqz	a5,80013a9e <_vsnprintf+0x240>
                precision = _atoi(&format);
    80013a8c:	f8040793          	addi	a5,s0,-128
    80013a90:	853e                	mv	a0,a5
    80013a92:	d79fe0ef          	jal	ra,8001280a <_atoi>
    80013a96:	87aa                	mv	a5,a0
    80013a98:	fef42223          	sw	a5,-28(s0)
    80013a9c:	a091                	j	80013ae0 <_vsnprintf+0x282>
            }
            else if (*format == '*') {
    80013a9e:	f8043783          	ld	a5,-128(s0)
    80013aa2:	0007c783          	lbu	a5,0(a5)
    80013aa6:	873e                	mv	a4,a5
    80013aa8:	02a00793          	li	a5,42
    80013aac:	02f71a63          	bne	a4,a5,80013ae0 <_vsnprintf+0x282>
                const int prec = (int)va_arg(va, int);
    80013ab0:	f7843783          	ld	a5,-136(s0)
    80013ab4:	00878713          	addi	a4,a5,8
    80013ab8:	f6e43c23          	sd	a4,-136(s0)
    80013abc:	439c                	lw	a5,0(a5)
    80013abe:	faf42e23          	sw	a5,-68(s0)
                precision      = prec > 0 ? (unsigned int)prec : 0U;
    80013ac2:	fbc42783          	lw	a5,-68(s0)
    80013ac6:	0007871b          	sext.w	a4,a5
    80013aca:	00075363          	bgez	a4,80013ad0 <_vsnprintf+0x272>
    80013ace:	4781                	li	a5,0
    80013ad0:	2781                	sext.w	a5,a5
    80013ad2:	fef42223          	sw	a5,-28(s0)
                format++;
    80013ad6:	f8043783          	ld	a5,-128(s0)
    80013ada:	0785                	addi	a5,a5,1
    80013adc:	f8f43023          	sd	a5,-128(s0)
            }
        }

        // evaluate length field
        switch (*format) {
    80013ae0:	f8043783          	ld	a5,-128(s0)
    80013ae4:	0007c783          	lbu	a5,0(a5)
    80013ae8:	2781                	sext.w	a5,a5
    80013aea:	f987869b          	addiw	a3,a5,-104
    80013aee:	0006871b          	sext.w	a4,a3
    80013af2:	47c9                	li	a5,18
    80013af4:	0ee7e963          	bltu	a5,a4,80013be6 <_vsnprintf+0x388>
    80013af8:	02069793          	slli	a5,a3,0x20
    80013afc:	9381                	srli	a5,a5,0x20
    80013afe:	00279713          	slli	a4,a5,0x2
    80013b02:	00006797          	auipc	a5,0x6
    80013b06:	bd678793          	addi	a5,a5,-1066 # 800196d8 <SYSCALLS+0x6d8>
    80013b0a:	97ba                	add	a5,a5,a4
    80013b0c:	439c                	lw	a5,0(a5)
    80013b0e:	0007871b          	sext.w	a4,a5
    80013b12:	00006797          	auipc	a5,0x6
    80013b16:	bc678793          	addi	a5,a5,-1082 # 800196d8 <SYSCALLS+0x6d8>
    80013b1a:	97ba                	add	a5,a5,a4
    80013b1c:	8782                	jr	a5
            case 'l':
                flags |= FLAGS_LONG;
    80013b1e:	fec42783          	lw	a5,-20(s0)
    80013b22:	1007e793          	ori	a5,a5,256
    80013b26:	fef42623          	sw	a5,-20(s0)
                format++;
    80013b2a:	f8043783          	ld	a5,-128(s0)
    80013b2e:	0785                	addi	a5,a5,1
    80013b30:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'l') {
    80013b34:	f8043783          	ld	a5,-128(s0)
    80013b38:	0007c783          	lbu	a5,0(a5)
    80013b3c:	873e                	mv	a4,a5
    80013b3e:	06c00793          	li	a5,108
    80013b42:	0af71463          	bne	a4,a5,80013bea <_vsnprintf+0x38c>
                    flags |= FLAGS_LONG_LONG;
    80013b46:	fec42783          	lw	a5,-20(s0)
    80013b4a:	2007e793          	ori	a5,a5,512
    80013b4e:	fef42623          	sw	a5,-20(s0)
                    format++;
    80013b52:	f8043783          	ld	a5,-128(s0)
    80013b56:	0785                	addi	a5,a5,1
    80013b58:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80013b5c:	a079                	j	80013bea <_vsnprintf+0x38c>
            case 'h':
                flags |= FLAGS_SHORT;
    80013b5e:	fec42783          	lw	a5,-20(s0)
    80013b62:	0807e793          	ori	a5,a5,128
    80013b66:	fef42623          	sw	a5,-20(s0)
                format++;
    80013b6a:	f8043783          	ld	a5,-128(s0)
    80013b6e:	0785                	addi	a5,a5,1
    80013b70:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'h') {
    80013b74:	f8043783          	ld	a5,-128(s0)
    80013b78:	0007c783          	lbu	a5,0(a5)
    80013b7c:	873e                	mv	a4,a5
    80013b7e:	06800793          	li	a5,104
    80013b82:	06f71663          	bne	a4,a5,80013bee <_vsnprintf+0x390>
                    flags |= FLAGS_CHAR;
    80013b86:	fec42783          	lw	a5,-20(s0)
    80013b8a:	0407e793          	ori	a5,a5,64
    80013b8e:	fef42623          	sw	a5,-20(s0)
                    format++;
    80013b92:	f8043783          	ld	a5,-128(s0)
    80013b96:	0785                	addi	a5,a5,1
    80013b98:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80013b9c:	a889                	j	80013bee <_vsnprintf+0x390>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
            case 't':
                flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG
    80013b9e:	fec42783          	lw	a5,-20(s0)
    80013ba2:	1007e793          	ori	a5,a5,256
    80013ba6:	fef42623          	sw	a5,-20(s0)
                                                            : FLAGS_LONG_LONG);
                format++;
    80013baa:	f8043783          	ld	a5,-128(s0)
    80013bae:	0785                	addi	a5,a5,1
    80013bb0:	f8f43023          	sd	a5,-128(s0)
                break;
    80013bb4:	a835                	j	80013bf0 <_vsnprintf+0x392>
#endif
            case 'j':
                flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG
    80013bb6:	fec42783          	lw	a5,-20(s0)
    80013bba:	1007e793          	ori	a5,a5,256
    80013bbe:	fef42623          	sw	a5,-20(s0)
                                                           : FLAGS_LONG_LONG);
                format++;
    80013bc2:	f8043783          	ld	a5,-128(s0)
    80013bc6:	0785                	addi	a5,a5,1
    80013bc8:	f8f43023          	sd	a5,-128(s0)
                break;
    80013bcc:	a015                	j	80013bf0 <_vsnprintf+0x392>
            case 'z':
                flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG
    80013bce:	fec42783          	lw	a5,-20(s0)
    80013bd2:	1007e793          	ori	a5,a5,256
    80013bd6:	fef42623          	sw	a5,-20(s0)
                                                         : FLAGS_LONG_LONG);
                format++;
    80013bda:	f8043783          	ld	a5,-128(s0)
    80013bde:	0785                	addi	a5,a5,1
    80013be0:	f8f43023          	sd	a5,-128(s0)
                break;
    80013be4:	a031                	j	80013bf0 <_vsnprintf+0x392>
            default:
                break;
    80013be6:	0001                	nop
    80013be8:	a021                	j	80013bf0 <_vsnprintf+0x392>
                break;
    80013bea:	0001                	nop
    80013bec:	a011                	j	80013bf0 <_vsnprintf+0x392>
                break;
    80013bee:	0001                	nop
        }

        // evaluate specifier
        switch (*format) {
    80013bf0:	f8043783          	ld	a5,-128(s0)
    80013bf4:	0007c783          	lbu	a5,0(a5)
    80013bf8:	2781                	sext.w	a5,a5
    80013bfa:	fdb7869b          	addiw	a3,a5,-37
    80013bfe:	0006871b          	sext.w	a4,a3
    80013c02:	05300793          	li	a5,83
    80013c06:	7ce7e863          	bltu	a5,a4,800143d6 <_vsnprintf+0xb78>
    80013c0a:	02069793          	slli	a5,a3,0x20
    80013c0e:	9381                	srli	a5,a5,0x20
    80013c10:	00279713          	slli	a4,a5,0x2
    80013c14:	00006797          	auipc	a5,0x6
    80013c18:	b1078793          	addi	a5,a5,-1264 # 80019724 <SYSCALLS+0x724>
    80013c1c:	97ba                	add	a5,a5,a4
    80013c1e:	439c                	lw	a5,0(a5)
    80013c20:	0007871b          	sext.w	a4,a5
    80013c24:	00006797          	auipc	a5,0x6
    80013c28:	b0078793          	addi	a5,a5,-1280 # 80019724 <SYSCALLS+0x724>
    80013c2c:	97ba                	add	a5,a5,a4
    80013c2e:	8782                	jr	a5
            case 'X':
            case 'o':
            case 'b': {
                // set the base
                unsigned int base;
                if (*format == 'x' || *format == 'X') {
    80013c30:	f8043783          	ld	a5,-128(s0)
    80013c34:	0007c783          	lbu	a5,0(a5)
    80013c38:	873e                	mv	a4,a5
    80013c3a:	07800793          	li	a5,120
    80013c3e:	00f70b63          	beq	a4,a5,80013c54 <_vsnprintf+0x3f6>
    80013c42:	f8043783          	ld	a5,-128(s0)
    80013c46:	0007c783          	lbu	a5,0(a5)
    80013c4a:	873e                	mv	a4,a5
    80013c4c:	05800793          	li	a5,88
    80013c50:	00f71663          	bne	a4,a5,80013c5c <_vsnprintf+0x3fe>
                    base = 16U;
    80013c54:	47c1                	li	a5,16
    80013c56:	fcf42a23          	sw	a5,-44(s0)
    80013c5a:	a099                	j	80013ca0 <_vsnprintf+0x442>
                }
                else if (*format == 'o') {
    80013c5c:	f8043783          	ld	a5,-128(s0)
    80013c60:	0007c783          	lbu	a5,0(a5)
    80013c64:	873e                	mv	a4,a5
    80013c66:	06f00793          	li	a5,111
    80013c6a:	00f71663          	bne	a4,a5,80013c76 <_vsnprintf+0x418>
                    base = 8U;
    80013c6e:	47a1                	li	a5,8
    80013c70:	fcf42a23          	sw	a5,-44(s0)
    80013c74:	a035                	j	80013ca0 <_vsnprintf+0x442>
                }
                else if (*format == 'b') {
    80013c76:	f8043783          	ld	a5,-128(s0)
    80013c7a:	0007c783          	lbu	a5,0(a5)
    80013c7e:	873e                	mv	a4,a5
    80013c80:	06200793          	li	a5,98
    80013c84:	00f71663          	bne	a4,a5,80013c90 <_vsnprintf+0x432>
                    base = 2U;
    80013c88:	4789                	li	a5,2
    80013c8a:	fcf42a23          	sw	a5,-44(s0)
    80013c8e:	a809                	j	80013ca0 <_vsnprintf+0x442>
                }
                else {
                    base = 10U;
    80013c90:	47a9                	li	a5,10
    80013c92:	fcf42a23          	sw	a5,-44(s0)
                    flags &= ~FLAGS_HASH;  // no hash for dec format
    80013c96:	fec42783          	lw	a5,-20(s0)
    80013c9a:	9bbd                	andi	a5,a5,-17
    80013c9c:	fef42623          	sw	a5,-20(s0)
                }
                // uppercase
                if (*format == 'X') {
    80013ca0:	f8043783          	ld	a5,-128(s0)
    80013ca4:	0007c783          	lbu	a5,0(a5)
    80013ca8:	873e                	mv	a4,a5
    80013caa:	05800793          	li	a5,88
    80013cae:	00f71863          	bne	a4,a5,80013cbe <_vsnprintf+0x460>
                    flags |= FLAGS_UPPERCASE;
    80013cb2:	fec42783          	lw	a5,-20(s0)
    80013cb6:	0207e793          	ori	a5,a5,32
    80013cba:	fef42623          	sw	a5,-20(s0)
                }

                // no plus or space flag for u, x, X, o, b
                if ((*format != 'i') && (*format != 'd')) {
    80013cbe:	f8043783          	ld	a5,-128(s0)
    80013cc2:	0007c783          	lbu	a5,0(a5)
    80013cc6:	873e                	mv	a4,a5
    80013cc8:	06900793          	li	a5,105
    80013ccc:	02f70063          	beq	a4,a5,80013cec <_vsnprintf+0x48e>
    80013cd0:	f8043783          	ld	a5,-128(s0)
    80013cd4:	0007c783          	lbu	a5,0(a5)
    80013cd8:	873e                	mv	a4,a5
    80013cda:	06400793          	li	a5,100
    80013cde:	00f70763          	beq	a4,a5,80013cec <_vsnprintf+0x48e>
                    flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    80013ce2:	fec42783          	lw	a5,-20(s0)
    80013ce6:	9bcd                	andi	a5,a5,-13
    80013ce8:	fef42623          	sw	a5,-20(s0)
                }

                // ignore '0' flag when precision is given
                if (flags & FLAGS_PRECISION) {
    80013cec:	fec42783          	lw	a5,-20(s0)
    80013cf0:	4007f793          	andi	a5,a5,1024
    80013cf4:	2781                	sext.w	a5,a5
    80013cf6:	c791                	beqz	a5,80013d02 <_vsnprintf+0x4a4>
                    flags &= ~FLAGS_ZEROPAD;
    80013cf8:	fec42783          	lw	a5,-20(s0)
    80013cfc:	9bf9                	andi	a5,a5,-2
    80013cfe:	fef42623          	sw	a5,-20(s0)
                }

                // convert the integer
                if ((*format == 'i') || (*format == 'd')) {
    80013d02:	f8043783          	ld	a5,-128(s0)
    80013d06:	0007c783          	lbu	a5,0(a5)
    80013d0a:	873e                	mv	a4,a5
    80013d0c:	06900793          	li	a5,105
    80013d10:	00f70b63          	beq	a4,a5,80013d26 <_vsnprintf+0x4c8>
    80013d14:	f8043783          	ld	a5,-128(s0)
    80013d18:	0007c783          	lbu	a5,0(a5)
    80013d1c:	873e                	mv	a4,a5
    80013d1e:	06400793          	li	a5,100
    80013d22:	18f71d63          	bne	a4,a5,80013ebc <_vsnprintf+0x65e>
                    // signed
                    if (flags & FLAGS_LONG_LONG) {
    80013d26:	fec42783          	lw	a5,-20(s0)
    80013d2a:	2007f793          	andi	a5,a5,512
    80013d2e:	2781                	sext.w	a5,a5
    80013d30:	c3bd                	beqz	a5,80013d96 <_vsnprintf+0x538>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        const long long value = va_arg(va, long long);
    80013d32:	f7843783          	ld	a5,-136(s0)
    80013d36:	00878713          	addi	a4,a5,8
    80013d3a:	f6e43c23          	sd	a4,-136(s0)
    80013d3e:	639c                	ld	a5,0(a5)
    80013d40:	faf43023          	sd	a5,-96(s0)
                        idx                   = _ntoa_long_long(
                                              out, buffer, idx, maxlen,
                                              (unsigned long long)(value > 0 ? value : 0 - value),
    80013d44:	fa043783          	ld	a5,-96(s0)
    80013d48:	43f7d713          	srai	a4,a5,0x3f
    80013d4c:	fa043783          	ld	a5,-96(s0)
    80013d50:	8fb9                	xor	a5,a5,a4
    80013d52:	8f99                	sub	a5,a5,a4
                        idx                   = _ntoa_long_long(
    80013d54:	85be                	mv	a1,a5
    80013d56:	fa043783          	ld	a5,-96(s0)
    80013d5a:	93fd                	srli	a5,a5,0x3f
    80013d5c:	0ff7f713          	andi	a4,a5,255
    80013d60:	fd446683          	lwu	a3,-44(s0)
    80013d64:	fe442603          	lw	a2,-28(s0)
    80013d68:	fec42783          	lw	a5,-20(s0)
    80013d6c:	e43e                	sd	a5,8(sp)
    80013d6e:	fe842783          	lw	a5,-24(s0)
    80013d72:	e03e                	sd	a5,0(sp)
    80013d74:	88b2                	mv	a7,a2
    80013d76:	8836                	mv	a6,a3
    80013d78:	87ba                	mv	a5,a4
    80013d7a:	872e                	mv	a4,a1
    80013d7c:	f8843683          	ld	a3,-120(s0)
    80013d80:	fd843603          	ld	a2,-40(s0)
    80013d84:	f9043583          	ld	a1,-112(s0)
    80013d88:	f9843503          	ld	a0,-104(s0)
    80013d8c:	fadfe0ef          	jal	ra,80012d38 <_ntoa_long_long>
    80013d90:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80013d94:	ac89                	j	80013fe6 <_vsnprintf+0x788>
                                              value < 0, base, precision, width, flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80013d96:	fec42783          	lw	a5,-20(s0)
    80013d9a:	1007f793          	andi	a5,a5,256
    80013d9e:	2781                	sext.w	a5,a5
    80013da0:	c3bd                	beqz	a5,80013e06 <_vsnprintf+0x5a8>
                        const long value = va_arg(va, long);
    80013da2:	f7843783          	ld	a5,-136(s0)
    80013da6:	00878713          	addi	a4,a5,8
    80013daa:	f6e43c23          	sd	a4,-136(s0)
    80013dae:	639c                	ld	a5,0(a5)
    80013db0:	faf43423          	sd	a5,-88(s0)
                        idx              = _ntoa_long(
                                         out, buffer, idx, maxlen,
                                         (unsigned long)(value > 0 ? value : 0 - value),
    80013db4:	fa843783          	ld	a5,-88(s0)
    80013db8:	43f7d713          	srai	a4,a5,0x3f
    80013dbc:	fa843783          	ld	a5,-88(s0)
    80013dc0:	8fb9                	xor	a5,a5,a4
    80013dc2:	8f99                	sub	a5,a5,a4
                        idx              = _ntoa_long(
    80013dc4:	85be                	mv	a1,a5
    80013dc6:	fa843783          	ld	a5,-88(s0)
    80013dca:	93fd                	srli	a5,a5,0x3f
    80013dcc:	0ff7f713          	andi	a4,a5,255
    80013dd0:	fd446683          	lwu	a3,-44(s0)
    80013dd4:	fe442603          	lw	a2,-28(s0)
    80013dd8:	fec42783          	lw	a5,-20(s0)
    80013ddc:	e43e                	sd	a5,8(sp)
    80013dde:	fe842783          	lw	a5,-24(s0)
    80013de2:	e03e                	sd	a5,0(sp)
    80013de4:	88b2                	mv	a7,a2
    80013de6:	8836                	mv	a6,a3
    80013de8:	87ba                	mv	a5,a4
    80013dea:	872e                	mv	a4,a1
    80013dec:	f8843683          	ld	a3,-120(s0)
    80013df0:	fd843603          	ld	a2,-40(s0)
    80013df4:	f9043583          	ld	a1,-112(s0)
    80013df8:	f9843503          	ld	a0,-104(s0)
    80013dfc:	e25fe0ef          	jal	ra,80012c20 <_ntoa_long>
    80013e00:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80013e04:	a2cd                	j	80013fe6 <_vsnprintf+0x788>
                                         value < 0, base, precision, width, flags);
                    }
                    else {
                        const int value =
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80013e06:	fec42783          	lw	a5,-20(s0)
    80013e0a:	0407f793          	andi	a5,a5,64
    80013e0e:	2781                	sext.w	a5,a5
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80013e10:	cf81                	beqz	a5,80013e28 <_vsnprintf+0x5ca>
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80013e12:	f7843783          	ld	a5,-136(s0)
    80013e16:	00878713          	addi	a4,a5,8
    80013e1a:	f6e43c23          	sd	a4,-136(s0)
    80013e1e:	439c                	lw	a5,0(a5)
    80013e20:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80013e24:	2781                	sext.w	a5,a5
    80013e26:	a81d                	j	80013e5c <_vsnprintf+0x5fe>
    80013e28:	fec42783          	lw	a5,-20(s0)
    80013e2c:	0807f793          	andi	a5,a5,128
    80013e30:	2781                	sext.w	a5,a5
                                                    : va_arg(va, int);
    80013e32:	cf91                	beqz	a5,80013e4e <_vsnprintf+0x5f0>
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80013e34:	f7843783          	ld	a5,-136(s0)
    80013e38:	00878713          	addi	a4,a5,8
    80013e3c:	f6e43c23          	sd	a4,-136(s0)
    80013e40:	439c                	lw	a5,0(a5)
    80013e42:	0107979b          	slliw	a5,a5,0x10
    80013e46:	4107d79b          	sraiw	a5,a5,0x10
                                                    : va_arg(va, int);
    80013e4a:	2781                	sext.w	a5,a5
    80013e4c:	a801                	j	80013e5c <_vsnprintf+0x5fe>
    80013e4e:	f7843783          	ld	a5,-136(s0)
    80013e52:	00878713          	addi	a4,a5,8
    80013e56:	f6e43c23          	sd	a4,-136(s0)
    80013e5a:	439c                	lw	a5,0(a5)
                        const int value =
    80013e5c:	faf42823          	sw	a5,-80(s0)
                        idx = _ntoa_long(
                            out, buffer, idx, maxlen,
                            (unsigned int)(value > 0 ? value : 0 - value),
    80013e60:	fb042783          	lw	a5,-80(s0)
    80013e64:	41f7d79b          	sraiw	a5,a5,0x1f
    80013e68:	fb042703          	lw	a4,-80(s0)
    80013e6c:	8f3d                	xor	a4,a4,a5
    80013e6e:	40f707bb          	subw	a5,a4,a5
    80013e72:	2781                	sext.w	a5,a5
    80013e74:	2781                	sext.w	a5,a5
                        idx = _ntoa_long(
    80013e76:	02079713          	slli	a4,a5,0x20
    80013e7a:	9301                	srli	a4,a4,0x20
    80013e7c:	fb042783          	lw	a5,-80(s0)
    80013e80:	01f7d79b          	srliw	a5,a5,0x1f
    80013e84:	0ff7f693          	andi	a3,a5,255
    80013e88:	fd446603          	lwu	a2,-44(s0)
    80013e8c:	fe442583          	lw	a1,-28(s0)
    80013e90:	fec42783          	lw	a5,-20(s0)
    80013e94:	e43e                	sd	a5,8(sp)
    80013e96:	fe842783          	lw	a5,-24(s0)
    80013e9a:	e03e                	sd	a5,0(sp)
    80013e9c:	88ae                	mv	a7,a1
    80013e9e:	8832                	mv	a6,a2
    80013ea0:	87b6                	mv	a5,a3
    80013ea2:	f8843683          	ld	a3,-120(s0)
    80013ea6:	fd843603          	ld	a2,-40(s0)
    80013eaa:	f9043583          	ld	a1,-112(s0)
    80013eae:	f9843503          	ld	a0,-104(s0)
    80013eb2:	d6ffe0ef          	jal	ra,80012c20 <_ntoa_long>
    80013eb6:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80013eba:	a235                	j	80013fe6 <_vsnprintf+0x788>
                            value < 0, base, precision, width, flags);
                    }
                }
                else {
                    // unsigned
                    if (flags & FLAGS_LONG_LONG) {
    80013ebc:	fec42783          	lw	a5,-20(s0)
    80013ec0:	2007f793          	andi	a5,a5,512
    80013ec4:	2781                	sext.w	a5,a5
    80013ec6:	c3b1                	beqz	a5,80013f0a <_vsnprintf+0x6ac>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80013ec8:	f7843783          	ld	a5,-136(s0)
    80013ecc:	00878713          	addi	a4,a5,8
    80013ed0:	f6e43c23          	sd	a4,-136(s0)
    80013ed4:	6398                	ld	a4,0(a5)
    80013ed6:	fd446683          	lwu	a3,-44(s0)
    80013eda:	fe442603          	lw	a2,-28(s0)
    80013ede:	fec42783          	lw	a5,-20(s0)
    80013ee2:	e43e                	sd	a5,8(sp)
    80013ee4:	fe842783          	lw	a5,-24(s0)
    80013ee8:	e03e                	sd	a5,0(sp)
    80013eea:	88b2                	mv	a7,a2
    80013eec:	8836                	mv	a6,a3
    80013eee:	4781                	li	a5,0
    80013ef0:	f8843683          	ld	a3,-120(s0)
    80013ef4:	fd843603          	ld	a2,-40(s0)
    80013ef8:	f9043583          	ld	a1,-112(s0)
    80013efc:	f9843503          	ld	a0,-104(s0)
    80013f00:	e39fe0ef          	jal	ra,80012d38 <_ntoa_long_long>
    80013f04:	fca43c23          	sd	a0,-40(s0)
    80013f08:	a8f9                	j	80013fe6 <_vsnprintf+0x788>
                                              va_arg(va, unsigned long long),
                                              false, base, precision, width,
                                              flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80013f0a:	fec42783          	lw	a5,-20(s0)
    80013f0e:	1007f793          	andi	a5,a5,256
    80013f12:	2781                	sext.w	a5,a5
    80013f14:	c3b1                	beqz	a5,80013f58 <_vsnprintf+0x6fa>
                        idx = _ntoa_long(out, buffer, idx, maxlen,
    80013f16:	f7843783          	ld	a5,-136(s0)
    80013f1a:	00878713          	addi	a4,a5,8
    80013f1e:	f6e43c23          	sd	a4,-136(s0)
    80013f22:	6398                	ld	a4,0(a5)
    80013f24:	fd446683          	lwu	a3,-44(s0)
    80013f28:	fe442603          	lw	a2,-28(s0)
    80013f2c:	fec42783          	lw	a5,-20(s0)
    80013f30:	e43e                	sd	a5,8(sp)
    80013f32:	fe842783          	lw	a5,-24(s0)
    80013f36:	e03e                	sd	a5,0(sp)
    80013f38:	88b2                	mv	a7,a2
    80013f3a:	8836                	mv	a6,a3
    80013f3c:	4781                	li	a5,0
    80013f3e:	f8843683          	ld	a3,-120(s0)
    80013f42:	fd843603          	ld	a2,-40(s0)
    80013f46:	f9043583          	ld	a1,-112(s0)
    80013f4a:	f9843503          	ld	a0,-104(s0)
    80013f4e:	cd3fe0ef          	jal	ra,80012c20 <_ntoa_long>
    80013f52:	fca43c23          	sd	a0,-40(s0)
    80013f56:	a841                	j	80013fe6 <_vsnprintf+0x788>
                                         va_arg(va, unsigned long), false, base,
                                         precision, width, flags);
                    }
                    else {
                        const unsigned int value =
                            (flags & FLAGS_CHAR)
    80013f58:	fec42783          	lw	a5,-20(s0)
    80013f5c:	0407f793          	andi	a5,a5,64
    80013f60:	2781                	sext.w	a5,a5
                                ? (unsigned char)va_arg(va, unsigned int)
                            : (flags & FLAGS_SHORT)
    80013f62:	cf81                	beqz	a5,80013f7a <_vsnprintf+0x71c>
                                ? (unsigned char)va_arg(va, unsigned int)
    80013f64:	f7843783          	ld	a5,-136(s0)
    80013f68:	00878713          	addi	a4,a5,8
    80013f6c:	f6e43c23          	sd	a4,-136(s0)
    80013f70:	439c                	lw	a5,0(a5)
    80013f72:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT)
    80013f76:	2781                	sext.w	a5,a5
    80013f78:	a815                	j	80013fac <_vsnprintf+0x74e>
    80013f7a:	fec42783          	lw	a5,-20(s0)
    80013f7e:	0807f793          	andi	a5,a5,128
    80013f82:	2781                	sext.w	a5,a5
                                ? (unsigned short int)va_arg(va, unsigned int)
                                : va_arg(va, unsigned int);
    80013f84:	cf81                	beqz	a5,80013f9c <_vsnprintf+0x73e>
                                ? (unsigned short int)va_arg(va, unsigned int)
    80013f86:	f7843783          	ld	a5,-136(s0)
    80013f8a:	00878713          	addi	a4,a5,8
    80013f8e:	f6e43c23          	sd	a4,-136(s0)
    80013f92:	439c                	lw	a5,0(a5)
    80013f94:	17c2                	slli	a5,a5,0x30
    80013f96:	93c1                	srli	a5,a5,0x30
                                : va_arg(va, unsigned int);
    80013f98:	2781                	sext.w	a5,a5
    80013f9a:	a801                	j	80013faa <_vsnprintf+0x74c>
    80013f9c:	f7843783          	ld	a5,-136(s0)
    80013fa0:	00878713          	addi	a4,a5,8
    80013fa4:	f6e43c23          	sd	a4,-136(s0)
    80013fa8:	439c                	lw	a5,0(a5)
                            : (flags & FLAGS_SHORT)
    80013faa:	2781                	sext.w	a5,a5
                        const unsigned int value =
    80013fac:	faf42a23          	sw	a5,-76(s0)
                        idx = _ntoa_long(out, buffer, idx, maxlen, value, false,
    80013fb0:	fb446703          	lwu	a4,-76(s0)
    80013fb4:	fd446683          	lwu	a3,-44(s0)
    80013fb8:	fe442603          	lw	a2,-28(s0)
    80013fbc:	fec42783          	lw	a5,-20(s0)
    80013fc0:	e43e                	sd	a5,8(sp)
    80013fc2:	fe842783          	lw	a5,-24(s0)
    80013fc6:	e03e                	sd	a5,0(sp)
    80013fc8:	88b2                	mv	a7,a2
    80013fca:	8836                	mv	a6,a3
    80013fcc:	4781                	li	a5,0
    80013fce:	f8843683          	ld	a3,-120(s0)
    80013fd2:	fd843603          	ld	a2,-40(s0)
    80013fd6:	f9043583          	ld	a1,-112(s0)
    80013fda:	f9843503          	ld	a0,-104(s0)
    80013fde:	c43fe0ef          	jal	ra,80012c20 <_ntoa_long>
    80013fe2:	fca43c23          	sd	a0,-40(s0)
                                         base, precision, width, flags);
                    }
                }
                format++;
    80013fe6:	f8043783          	ld	a5,-128(s0)
    80013fea:	0785                	addi	a5,a5,1
    80013fec:	f8f43023          	sd	a5,-128(s0)
                break;
    80013ff0:	a919                	j	80014406 <_vsnprintf+0xba8>
            }
#if defined(PRINTF_SUPPORT_FLOAT)
            case 'f':
            case 'F':
                if (*format == 'F')
    80013ff2:	f8043783          	ld	a5,-128(s0)
    80013ff6:	0007c783          	lbu	a5,0(a5)
    80013ffa:	873e                	mv	a4,a5
    80013ffc:	04600793          	li	a5,70
    80014000:	00f71863          	bne	a4,a5,80014010 <_vsnprintf+0x7b2>
                    flags |= FLAGS_UPPERCASE;
    80014004:	fec42783          	lw	a5,-20(s0)
    80014008:	0207e793          	ori	a5,a5,32
    8001400c:	fef42623          	sw	a5,-20(s0)
                idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double),
    80014010:	f7843783          	ld	a5,-136(s0)
    80014014:	00878713          	addi	a4,a5,8
    80014018:	f6e43c23          	sd	a4,-136(s0)
    8001401c:	239c                	fld	fa5,0(a5)
    8001401e:	fec42683          	lw	a3,-20(s0)
    80014022:	fe842783          	lw	a5,-24(s0)
    80014026:	fe442703          	lw	a4,-28(s0)
    8001402a:	8836                	mv	a6,a3
    8001402c:	22f78553          	fmv.d	fa0,fa5
    80014030:	f8843683          	ld	a3,-120(s0)
    80014034:	fd843603          	ld	a2,-40(s0)
    80014038:	f9043583          	ld	a1,-112(s0)
    8001403c:	f9843503          	ld	a0,-104(s0)
    80014040:	e11fe0ef          	jal	ra,80012e50 <_ftoa>
    80014044:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80014048:	f8043783          	ld	a5,-128(s0)
    8001404c:	0785                	addi	a5,a5,1
    8001404e:	f8f43023          	sd	a5,-128(s0)
                break;
    80014052:	ae55                	j	80014406 <_vsnprintf+0xba8>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
            case 'e':
            case 'E':
            case 'g':
            case 'G':
                if ((*format == 'g') || (*format == 'G'))
    80014054:	f8043783          	ld	a5,-128(s0)
    80014058:	0007c783          	lbu	a5,0(a5)
    8001405c:	873e                	mv	a4,a5
    8001405e:	06700793          	li	a5,103
    80014062:	00f70b63          	beq	a4,a5,80014078 <_vsnprintf+0x81a>
    80014066:	f8043783          	ld	a5,-128(s0)
    8001406a:	0007c783          	lbu	a5,0(a5)
    8001406e:	873e                	mv	a4,a5
    80014070:	04700793          	li	a5,71
    80014074:	00f71a63          	bne	a4,a5,80014088 <_vsnprintf+0x82a>
                    flags |= FLAGS_ADAPT_EXP;
    80014078:	fec42703          	lw	a4,-20(s0)
    8001407c:	6785                	lui	a5,0x1
    8001407e:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80014082:	8fd9                	or	a5,a5,a4
    80014084:	fef42623          	sw	a5,-20(s0)
                if ((*format == 'E') || (*format == 'G'))
    80014088:	f8043783          	ld	a5,-128(s0)
    8001408c:	0007c783          	lbu	a5,0(a5)
    80014090:	873e                	mv	a4,a5
    80014092:	04500793          	li	a5,69
    80014096:	00f70b63          	beq	a4,a5,800140ac <_vsnprintf+0x84e>
    8001409a:	f8043783          	ld	a5,-128(s0)
    8001409e:	0007c783          	lbu	a5,0(a5)
    800140a2:	873e                	mv	a4,a5
    800140a4:	04700793          	li	a5,71
    800140a8:	00f71863          	bne	a4,a5,800140b8 <_vsnprintf+0x85a>
                    flags |= FLAGS_UPPERCASE;
    800140ac:	fec42783          	lw	a5,-20(s0)
    800140b0:	0207e793          	ori	a5,a5,32
    800140b4:	fef42623          	sw	a5,-20(s0)
                idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double),
    800140b8:	f7843783          	ld	a5,-136(s0)
    800140bc:	00878713          	addi	a4,a5,8
    800140c0:	f6e43c23          	sd	a4,-136(s0)
    800140c4:	239c                	fld	fa5,0(a5)
    800140c6:	fec42683          	lw	a3,-20(s0)
    800140ca:	fe842783          	lw	a5,-24(s0)
    800140ce:	fe442703          	lw	a4,-28(s0)
    800140d2:	8836                	mv	a6,a3
    800140d4:	22f78553          	fmv.d	fa0,fa5
    800140d8:	f8843683          	ld	a3,-120(s0)
    800140dc:	fd843603          	ld	a2,-40(s0)
    800140e0:	f9043583          	ld	a1,-112(s0)
    800140e4:	f9843503          	ld	a0,-104(s0)
    800140e8:	ab4ff0ef          	jal	ra,8001339c <_etoa>
    800140ec:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    800140f0:	f8043783          	ld	a5,-128(s0)
    800140f4:	0785                	addi	a5,a5,1
    800140f6:	f8f43023          	sd	a5,-128(s0)
                break;
    800140fa:	a631                	j	80014406 <_vsnprintf+0xba8>
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
            case 'c': {
                unsigned int l = 1U;
    800140fc:	4785                	li	a5,1
    800140fe:	fcf42823          	sw	a5,-48(s0)
                // pre padding
                if (!(flags & FLAGS_LEFT)) {
    80014102:	fec42783          	lw	a5,-20(s0)
    80014106:	8b89                	andi	a5,a5,2
    80014108:	2781                	sext.w	a5,a5
    8001410a:	ef8d                	bnez	a5,80014144 <_vsnprintf+0x8e6>
                    while (l++ < width) {
    8001410c:	a00d                	j	8001412e <_vsnprintf+0x8d0>
                        out(' ', buffer, idx++, maxlen);
    8001410e:	fd843783          	ld	a5,-40(s0)
    80014112:	00178713          	addi	a4,a5,1
    80014116:	fce43c23          	sd	a4,-40(s0)
    8001411a:	f9843703          	ld	a4,-104(s0)
    8001411e:	f8843683          	ld	a3,-120(s0)
    80014122:	863e                	mv	a2,a5
    80014124:	f9043583          	ld	a1,-112(s0)
    80014128:	02000513          	li	a0,32
    8001412c:	9702                	jalr	a4
                    while (l++ < width) {
    8001412e:	fd042783          	lw	a5,-48(s0)
    80014132:	0017871b          	addiw	a4,a5,1
    80014136:	fce42823          	sw	a4,-48(s0)
    8001413a:	fe842703          	lw	a4,-24(s0)
    8001413e:	2701                	sext.w	a4,a4
    80014140:	fce7e7e3          	bltu	a5,a4,8001410e <_vsnprintf+0x8b0>
                    }
                }
                // char output
                out((char)va_arg(va, int), buffer, idx++, maxlen);
    80014144:	f7843783          	ld	a5,-136(s0)
    80014148:	00878713          	addi	a4,a5,8
    8001414c:	f6e43c23          	sd	a4,-136(s0)
    80014150:	439c                	lw	a5,0(a5)
    80014152:	0ff7f513          	andi	a0,a5,255
    80014156:	fd843783          	ld	a5,-40(s0)
    8001415a:	00178713          	addi	a4,a5,1
    8001415e:	fce43c23          	sd	a4,-40(s0)
    80014162:	f9843703          	ld	a4,-104(s0)
    80014166:	f8843683          	ld	a3,-120(s0)
    8001416a:	863e                	mv	a2,a5
    8001416c:	f9043583          	ld	a1,-112(s0)
    80014170:	9702                	jalr	a4
                // post padding
                if (flags & FLAGS_LEFT) {
    80014172:	fec42783          	lw	a5,-20(s0)
    80014176:	8b89                	andi	a5,a5,2
    80014178:	2781                	sext.w	a5,a5
    8001417a:	cf8d                	beqz	a5,800141b4 <_vsnprintf+0x956>
                    while (l++ < width) {
    8001417c:	a00d                	j	8001419e <_vsnprintf+0x940>
                        out(' ', buffer, idx++, maxlen);
    8001417e:	fd843783          	ld	a5,-40(s0)
    80014182:	00178713          	addi	a4,a5,1
    80014186:	fce43c23          	sd	a4,-40(s0)
    8001418a:	f9843703          	ld	a4,-104(s0)
    8001418e:	f8843683          	ld	a3,-120(s0)
    80014192:	863e                	mv	a2,a5
    80014194:	f9043583          	ld	a1,-112(s0)
    80014198:	02000513          	li	a0,32
    8001419c:	9702                	jalr	a4
                    while (l++ < width) {
    8001419e:	fd042783          	lw	a5,-48(s0)
    800141a2:	0017871b          	addiw	a4,a5,1
    800141a6:	fce42823          	sw	a4,-48(s0)
    800141aa:	fe842703          	lw	a4,-24(s0)
    800141ae:	2701                	sext.w	a4,a4
    800141b0:	fce7e7e3          	bltu	a5,a4,8001417e <_vsnprintf+0x920>
                    }
                }
                format++;
    800141b4:	f8043783          	ld	a5,-128(s0)
    800141b8:	0785                	addi	a5,a5,1
    800141ba:	f8f43023          	sd	a5,-128(s0)
                break;
    800141be:	a4a1                	j	80014406 <_vsnprintf+0xba8>
            }

            case 's': {
                const char *p = va_arg(va, char *);
    800141c0:	f7843783          	ld	a5,-136(s0)
    800141c4:	00878713          	addi	a4,a5,8
    800141c8:	f6e43c23          	sd	a4,-136(s0)
    800141cc:	639c                	ld	a5,0(a5)
    800141ce:	fcf43423          	sd	a5,-56(s0)
                unsigned int l =
                    _strnlen_s(p, precision ? precision : (size_t)-1);
    800141d2:	fe442783          	lw	a5,-28(s0)
    800141d6:	2781                	sext.w	a5,a5
    800141d8:	c781                	beqz	a5,800141e0 <_vsnprintf+0x982>
    800141da:	fe446783          	lwu	a5,-28(s0)
    800141de:	a011                	j	800141e2 <_vsnprintf+0x984>
    800141e0:	57fd                	li	a5,-1
    800141e2:	85be                	mv	a1,a5
    800141e4:	fc843503          	ld	a0,-56(s0)
    800141e8:	d92fe0ef          	jal	ra,8001277a <_strnlen_s>
    800141ec:	87aa                	mv	a5,a0
    800141ee:	fcf42223          	sw	a5,-60(s0)
                // pre padding
                if (flags & FLAGS_PRECISION) {
    800141f2:	fec42783          	lw	a5,-20(s0)
    800141f6:	4007f793          	andi	a5,a5,1024
    800141fa:	2781                	sext.w	a5,a5
    800141fc:	cf91                	beqz	a5,80014218 <_vsnprintf+0x9ba>
                    l = (l < precision ? l : precision);
    800141fe:	fc442603          	lw	a2,-60(s0)
    80014202:	fe442783          	lw	a5,-28(s0)
    80014206:	0007869b          	sext.w	a3,a5
    8001420a:	0006071b          	sext.w	a4,a2
    8001420e:	00d77363          	bgeu	a4,a3,80014214 <_vsnprintf+0x9b6>
    80014212:	87b2                	mv	a5,a2
    80014214:	fcf42223          	sw	a5,-60(s0)
                }
                if (!(flags & FLAGS_LEFT)) {
    80014218:	fec42783          	lw	a5,-20(s0)
    8001421c:	8b89                	andi	a5,a5,2
    8001421e:	2781                	sext.w	a5,a5
    80014220:	e7a5                	bnez	a5,80014288 <_vsnprintf+0xa2a>
                    while (l++ < width) {
    80014222:	a00d                	j	80014244 <_vsnprintf+0x9e6>
                        out(' ', buffer, idx++, maxlen);
    80014224:	fd843783          	ld	a5,-40(s0)
    80014228:	00178713          	addi	a4,a5,1
    8001422c:	fce43c23          	sd	a4,-40(s0)
    80014230:	f9843703          	ld	a4,-104(s0)
    80014234:	f8843683          	ld	a3,-120(s0)
    80014238:	863e                	mv	a2,a5
    8001423a:	f9043583          	ld	a1,-112(s0)
    8001423e:	02000513          	li	a0,32
    80014242:	9702                	jalr	a4
                    while (l++ < width) {
    80014244:	fc442783          	lw	a5,-60(s0)
    80014248:	0017871b          	addiw	a4,a5,1
    8001424c:	fce42223          	sw	a4,-60(s0)
    80014250:	fe842703          	lw	a4,-24(s0)
    80014254:	2701                	sext.w	a4,a4
    80014256:	fce7e7e3          	bltu	a5,a4,80014224 <_vsnprintf+0x9c6>
                    }
                }
                // string output
                while ((*p != 0) &&
    8001425a:	a03d                	j	80014288 <_vsnprintf+0xa2a>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
                    out(*(p++), buffer, idx++, maxlen);
    8001425c:	fc843783          	ld	a5,-56(s0)
    80014260:	00178713          	addi	a4,a5,1
    80014264:	fce43423          	sd	a4,-56(s0)
    80014268:	0007c503          	lbu	a0,0(a5)
    8001426c:	fd843783          	ld	a5,-40(s0)
    80014270:	00178713          	addi	a4,a5,1
    80014274:	fce43c23          	sd	a4,-40(s0)
    80014278:	f9843703          	ld	a4,-104(s0)
    8001427c:	f8843683          	ld	a3,-120(s0)
    80014280:	863e                	mv	a2,a5
    80014282:	f9043583          	ld	a1,-112(s0)
    80014286:	9702                	jalr	a4
                while ((*p != 0) &&
    80014288:	fc843783          	ld	a5,-56(s0)
    8001428c:	0007c783          	lbu	a5,0(a5)
    80014290:	cf91                	beqz	a5,800142ac <_vsnprintf+0xa4e>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    80014292:	fec42783          	lw	a5,-20(s0)
    80014296:	4007f793          	andi	a5,a5,1024
    8001429a:	2781                	sext.w	a5,a5
                while ((*p != 0) &&
    8001429c:	d3e1                	beqz	a5,8001425c <_vsnprintf+0x9fe>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    8001429e:	fe442783          	lw	a5,-28(s0)
    800142a2:	fff7871b          	addiw	a4,a5,-1
    800142a6:	fee42223          	sw	a4,-28(s0)
    800142aa:	fbcd                	bnez	a5,8001425c <_vsnprintf+0x9fe>
                }
                // post padding
                if (flags & FLAGS_LEFT) {
    800142ac:	fec42783          	lw	a5,-20(s0)
    800142b0:	8b89                	andi	a5,a5,2
    800142b2:	2781                	sext.w	a5,a5
    800142b4:	cf8d                	beqz	a5,800142ee <_vsnprintf+0xa90>
                    while (l++ < width) {
    800142b6:	a00d                	j	800142d8 <_vsnprintf+0xa7a>
                        out(' ', buffer, idx++, maxlen);
    800142b8:	fd843783          	ld	a5,-40(s0)
    800142bc:	00178713          	addi	a4,a5,1
    800142c0:	fce43c23          	sd	a4,-40(s0)
    800142c4:	f9843703          	ld	a4,-104(s0)
    800142c8:	f8843683          	ld	a3,-120(s0)
    800142cc:	863e                	mv	a2,a5
    800142ce:	f9043583          	ld	a1,-112(s0)
    800142d2:	02000513          	li	a0,32
    800142d6:	9702                	jalr	a4
                    while (l++ < width) {
    800142d8:	fc442783          	lw	a5,-60(s0)
    800142dc:	0017871b          	addiw	a4,a5,1
    800142e0:	fce42223          	sw	a4,-60(s0)
    800142e4:	fe842703          	lw	a4,-24(s0)
    800142e8:	2701                	sext.w	a4,a4
    800142ea:	fce7e7e3          	bltu	a5,a4,800142b8 <_vsnprintf+0xa5a>
                    }
                }
                format++;
    800142ee:	f8043783          	ld	a5,-128(s0)
    800142f2:	0785                	addi	a5,a5,1
    800142f4:	f8f43023          	sd	a5,-128(s0)
                break;
    800142f8:	a239                	j	80014406 <_vsnprintf+0xba8>
            }

            case 'p': {
                width = sizeof(void *) * 2U;
    800142fa:	47c1                	li	a5,16
    800142fc:	fef42423          	sw	a5,-24(s0)
                flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    80014300:	fec42783          	lw	a5,-20(s0)
    80014304:	0217e793          	ori	a5,a5,33
    80014308:	fef42623          	sw	a5,-20(s0)
#if defined(PRINTF_SUPPORT_LONG_LONG)
                const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
    8001430c:	4785                	li	a5,1
    8001430e:	faf40da3          	sb	a5,-69(s0)
                if (is_ll) {
    80014312:	fbb44783          	lbu	a5,-69(s0)
    80014316:	0ff7f793          	andi	a5,a5,255
    8001431a:	c3b1                	beqz	a5,8001435e <_vsnprintf+0xb00>
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
                                          (uintptr_t)va_arg(va, void *), false,
    8001431c:	f7843783          	ld	a5,-136(s0)
    80014320:	00878713          	addi	a4,a5,8
    80014324:	f6e43c23          	sd	a4,-136(s0)
    80014328:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
    8001432a:	86be                	mv	a3,a5
    8001432c:	fe442703          	lw	a4,-28(s0)
    80014330:	fec42783          	lw	a5,-20(s0)
    80014334:	e43e                	sd	a5,8(sp)
    80014336:	fe842783          	lw	a5,-24(s0)
    8001433a:	e03e                	sd	a5,0(sp)
    8001433c:	88ba                	mv	a7,a4
    8001433e:	4841                	li	a6,16
    80014340:	4781                	li	a5,0
    80014342:	8736                	mv	a4,a3
    80014344:	f8843683          	ld	a3,-120(s0)
    80014348:	fd843603          	ld	a2,-40(s0)
    8001434c:	f9043583          	ld	a1,-112(s0)
    80014350:	f9843503          	ld	a0,-104(s0)
    80014354:	9e5fe0ef          	jal	ra,80012d38 <_ntoa_long_long>
    80014358:	fca43c23          	sd	a0,-40(s0)
    8001435c:	a089                	j	8001439e <_vsnprintf+0xb40>
                }
                else {
#endif
                    idx = _ntoa_long(
                        out, buffer, idx, maxlen,
                        (unsigned long)((uintptr_t)va_arg(va, void *)), false,
    8001435e:	f7843783          	ld	a5,-136(s0)
    80014362:	00878713          	addi	a4,a5,8
    80014366:	f6e43c23          	sd	a4,-136(s0)
    8001436a:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long(
    8001436c:	86be                	mv	a3,a5
    8001436e:	fe442703          	lw	a4,-28(s0)
    80014372:	fec42783          	lw	a5,-20(s0)
    80014376:	e43e                	sd	a5,8(sp)
    80014378:	fe842783          	lw	a5,-24(s0)
    8001437c:	e03e                	sd	a5,0(sp)
    8001437e:	88ba                	mv	a7,a4
    80014380:	4841                	li	a6,16
    80014382:	4781                	li	a5,0
    80014384:	8736                	mv	a4,a3
    80014386:	f8843683          	ld	a3,-120(s0)
    8001438a:	fd843603          	ld	a2,-40(s0)
    8001438e:	f9043583          	ld	a1,-112(s0)
    80014392:	f9843503          	ld	a0,-104(s0)
    80014396:	88bfe0ef          	jal	ra,80012c20 <_ntoa_long>
    8001439a:	fca43c23          	sd	a0,-40(s0)
                        16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
                }
#endif
                format++;
    8001439e:	f8043783          	ld	a5,-128(s0)
    800143a2:	0785                	addi	a5,a5,1
    800143a4:	f8f43023          	sd	a5,-128(s0)
                break;
    800143a8:	a8b9                	j	80014406 <_vsnprintf+0xba8>
            }

            case '%':
                out('%', buffer, idx++, maxlen);
    800143aa:	fd843783          	ld	a5,-40(s0)
    800143ae:	00178713          	addi	a4,a5,1
    800143b2:	fce43c23          	sd	a4,-40(s0)
    800143b6:	f9843703          	ld	a4,-104(s0)
    800143ba:	f8843683          	ld	a3,-120(s0)
    800143be:	863e                	mv	a2,a5
    800143c0:	f9043583          	ld	a1,-112(s0)
    800143c4:	02500513          	li	a0,37
    800143c8:	9702                	jalr	a4
                format++;
    800143ca:	f8043783          	ld	a5,-128(s0)
    800143ce:	0785                	addi	a5,a5,1
    800143d0:	f8f43023          	sd	a5,-128(s0)
                break;
    800143d4:	a80d                	j	80014406 <_vsnprintf+0xba8>

            default:
                out(*format, buffer, idx++, maxlen);
    800143d6:	f8043783          	ld	a5,-128(s0)
    800143da:	0007c503          	lbu	a0,0(a5)
    800143de:	fd843783          	ld	a5,-40(s0)
    800143e2:	00178713          	addi	a4,a5,1
    800143e6:	fce43c23          	sd	a4,-40(s0)
    800143ea:	f9843703          	ld	a4,-104(s0)
    800143ee:	f8843683          	ld	a3,-120(s0)
    800143f2:	863e                	mv	a2,a5
    800143f4:	f9043583          	ld	a1,-112(s0)
    800143f8:	9702                	jalr	a4
                format++;
    800143fa:	f8043783          	ld	a5,-128(s0)
    800143fe:	0785                	addi	a5,a5,1
    80014400:	f8f43023          	sd	a5,-128(s0)
                break;
    80014404:	0001                	nop
    while (*format) {
    80014406:	f8043783          	ld	a5,-128(s0)
    8001440a:	0007c783          	lbu	a5,0(a5)
    8001440e:	c8079463          	bnez	a5,80013896 <_vsnprintf+0x38>
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    80014412:	fd843703          	ld	a4,-40(s0)
    80014416:	f8843783          	ld	a5,-120(s0)
    8001441a:	00f76663          	bltu	a4,a5,80014426 <_vsnprintf+0xbc8>
    8001441e:	f8843783          	ld	a5,-120(s0)
    80014422:	17fd                	addi	a5,a5,-1
    80014424:	a019                	j	8001442a <_vsnprintf+0xbcc>
    80014426:	fd843783          	ld	a5,-40(s0)
    8001442a:	f9843703          	ld	a4,-104(s0)
    8001442e:	f8843683          	ld	a3,-120(s0)
    80014432:	863e                	mv	a2,a5
    80014434:	f9043583          	ld	a1,-112(s0)
    80014438:	4501                	li	a0,0
    8001443a:	9702                	jalr	a4

    // return written chars without terminating \0
    return (int)idx;
    8001443c:	fd843783          	ld	a5,-40(s0)
    80014440:	2781                	sext.w	a5,a5
}
    80014442:	853e                	mv	a0,a5
    80014444:	60ea                	ld	ra,152(sp)
    80014446:	644a                	ld	s0,144(sp)
    80014448:	610d                	addi	sp,sp,160
    8001444a:	8082                	ret

000000008001444c <printf>:

///////////////////////////////////////////////////////////////////////////////

int printf(const char *format, ...)
{
    8001444c:	7119                	addi	sp,sp,-128
    8001444e:	fc06                	sd	ra,56(sp)
    80014450:	f822                	sd	s0,48(sp)
    80014452:	0080                	addi	s0,sp,64
    80014454:	fca43423          	sd	a0,-56(s0)
    80014458:	e40c                	sd	a1,8(s0)
    8001445a:	e810                	sd	a2,16(s0)
    8001445c:	ec14                	sd	a3,24(s0)
    8001445e:	f018                	sd	a4,32(s0)
    80014460:	f41c                	sd	a5,40(s0)
    80014462:	03043823          	sd	a6,48(s0)
    80014466:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, format);
    8001446a:	04040793          	addi	a5,s0,64
    8001446e:	fcf43023          	sd	a5,-64(s0)
    80014472:	fc043783          	ld	a5,-64(s0)
    80014476:	fc878793          	addi	a5,a5,-56
    8001447a:	fef43023          	sd	a5,-32(s0)
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    8001447e:	fe043703          	ld	a4,-32(s0)
    80014482:	fd840793          	addi	a5,s0,-40
    80014486:	fc843683          	ld	a3,-56(s0)
    8001448a:	567d                	li	a2,-1
    8001448c:	85be                	mv	a1,a5
    8001448e:	ffffe517          	auipc	a0,0xffffe
    80014492:	27050513          	addi	a0,a0,624 # 800126fe <_out_char>
    80014496:	bc8ff0ef          	jal	ra,8001385e <_vsnprintf>
    8001449a:	87aa                	mv	a5,a0
    8001449c:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    800144a0:	fec42783          	lw	a5,-20(s0)
}
    800144a4:	853e                	mv	a0,a5
    800144a6:	70e2                	ld	ra,56(sp)
    800144a8:	7442                	ld	s0,48(sp)
    800144aa:	6109                	addi	sp,sp,128
    800144ac:	8082                	ret

00000000800144ae <sprintf>:

int sprintf(char *buffer, const char *format, ...)
{
    800144ae:	7159                	addi	sp,sp,-112
    800144b0:	fc06                	sd	ra,56(sp)
    800144b2:	f822                	sd	s0,48(sp)
    800144b4:	0080                	addi	s0,sp,64
    800144b6:	fca43c23          	sd	a0,-40(s0)
    800144ba:	fcb43823          	sd	a1,-48(s0)
    800144be:	e010                	sd	a2,0(s0)
    800144c0:	e414                	sd	a3,8(s0)
    800144c2:	e818                	sd	a4,16(s0)
    800144c4:	ec1c                	sd	a5,24(s0)
    800144c6:	03043023          	sd	a6,32(s0)
    800144ca:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    800144ce:	03040793          	addi	a5,s0,48
    800144d2:	fcf43423          	sd	a5,-56(s0)
    800144d6:	fc843783          	ld	a5,-56(s0)
    800144da:	fd078793          	addi	a5,a5,-48
    800144de:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
    800144e2:	fe043783          	ld	a5,-32(s0)
    800144e6:	873e                	mv	a4,a5
    800144e8:	fd043683          	ld	a3,-48(s0)
    800144ec:	567d                	li	a2,-1
    800144ee:	fd843583          	ld	a1,-40(s0)
    800144f2:	ffffe517          	auipc	a0,0xffffe
    800144f6:	1ae50513          	addi	a0,a0,430 # 800126a0 <_out_buffer>
    800144fa:	b64ff0ef          	jal	ra,8001385e <_vsnprintf>
    800144fe:	87aa                	mv	a5,a0
    80014500:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80014504:	fec42783          	lw	a5,-20(s0)
}
    80014508:	853e                	mv	a0,a5
    8001450a:	70e2                	ld	ra,56(sp)
    8001450c:	7442                	ld	s0,48(sp)
    8001450e:	6165                	addi	sp,sp,112
    80014510:	8082                	ret

0000000080014512 <snprintf>:

int snprintf(char *buffer, size_t count, const char *format, ...)
{
    80014512:	7159                	addi	sp,sp,-112
    80014514:	fc06                	sd	ra,56(sp)
    80014516:	f822                	sd	s0,48(sp)
    80014518:	0080                	addi	s0,sp,64
    8001451a:	fca43c23          	sd	a0,-40(s0)
    8001451e:	fcb43823          	sd	a1,-48(s0)
    80014522:	fcc43423          	sd	a2,-56(s0)
    80014526:	e414                	sd	a3,8(s0)
    80014528:	e818                	sd	a4,16(s0)
    8001452a:	ec1c                	sd	a5,24(s0)
    8001452c:	03043023          	sd	a6,32(s0)
    80014530:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80014534:	03040793          	addi	a5,s0,48
    80014538:	fcf43023          	sd	a5,-64(s0)
    8001453c:	fc043783          	ld	a5,-64(s0)
    80014540:	fd878793          	addi	a5,a5,-40
    80014544:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    80014548:	fe043783          	ld	a5,-32(s0)
    8001454c:	873e                	mv	a4,a5
    8001454e:	fc843683          	ld	a3,-56(s0)
    80014552:	fd043603          	ld	a2,-48(s0)
    80014556:	fd843583          	ld	a1,-40(s0)
    8001455a:	ffffe517          	auipc	a0,0xffffe
    8001455e:	14650513          	addi	a0,a0,326 # 800126a0 <_out_buffer>
    80014562:	afcff0ef          	jal	ra,8001385e <_vsnprintf>
    80014566:	87aa                	mv	a5,a0
    80014568:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    8001456c:	fec42783          	lw	a5,-20(s0)
}
    80014570:	853e                	mv	a0,a5
    80014572:	70e2                	ld	ra,56(sp)
    80014574:	7442                	ld	s0,48(sp)
    80014576:	6165                	addi	sp,sp,112
    80014578:	8082                	ret

000000008001457a <vprintf_>:

int vprintf_(const char *format, va_list va)
{
    8001457a:	7179                	addi	sp,sp,-48
    8001457c:	f406                	sd	ra,40(sp)
    8001457e:	f022                	sd	s0,32(sp)
    80014580:	1800                	addi	s0,sp,48
    80014582:	fca43c23          	sd	a0,-40(s0)
    80014586:	fcb43823          	sd	a1,-48(s0)
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    8001458a:	fe840793          	addi	a5,s0,-24
    8001458e:	fd043703          	ld	a4,-48(s0)
    80014592:	fd843683          	ld	a3,-40(s0)
    80014596:	567d                	li	a2,-1
    80014598:	85be                	mv	a1,a5
    8001459a:	ffffe517          	auipc	a0,0xffffe
    8001459e:	16450513          	addi	a0,a0,356 # 800126fe <_out_char>
    800145a2:	abcff0ef          	jal	ra,8001385e <_vsnprintf>
    800145a6:	87aa                	mv	a5,a0
}
    800145a8:	853e                	mv	a0,a5
    800145aa:	70a2                	ld	ra,40(sp)
    800145ac:	7402                	ld	s0,32(sp)
    800145ae:	6145                	addi	sp,sp,48
    800145b0:	8082                	ret

00000000800145b2 <vsnprintf_>:

int vsnprintf_(char *buffer, size_t count, const char *format, va_list va)
{
    800145b2:	7179                	addi	sp,sp,-48
    800145b4:	f406                	sd	ra,40(sp)
    800145b6:	f022                	sd	s0,32(sp)
    800145b8:	1800                	addi	s0,sp,48
    800145ba:	fea43423          	sd	a0,-24(s0)
    800145be:	feb43023          	sd	a1,-32(s0)
    800145c2:	fcc43c23          	sd	a2,-40(s0)
    800145c6:	fcd43823          	sd	a3,-48(s0)
    return _vsnprintf(_out_buffer, buffer, count, format, va);
    800145ca:	fd043703          	ld	a4,-48(s0)
    800145ce:	fd843683          	ld	a3,-40(s0)
    800145d2:	fe043603          	ld	a2,-32(s0)
    800145d6:	fe843583          	ld	a1,-24(s0)
    800145da:	ffffe517          	auipc	a0,0xffffe
    800145de:	0c650513          	addi	a0,a0,198 # 800126a0 <_out_buffer>
    800145e2:	a7cff0ef          	jal	ra,8001385e <_vsnprintf>
    800145e6:	87aa                	mv	a5,a0
}
    800145e8:	853e                	mv	a0,a5
    800145ea:	70a2                	ld	ra,40(sp)
    800145ec:	7402                	ld	s0,32(sp)
    800145ee:	6145                	addi	sp,sp,48
    800145f0:	8082                	ret

00000000800145f2 <fctprintf>:

int fctprintf(void (*out)(char character, void *arg), void *arg,
              const char *format, ...)
{
    800145f2:	7119                	addi	sp,sp,-128
    800145f4:	e486                	sd	ra,72(sp)
    800145f6:	e0a2                	sd	s0,64(sp)
    800145f8:	0880                	addi	s0,sp,80
    800145fa:	fca43423          	sd	a0,-56(s0)
    800145fe:	fcb43023          	sd	a1,-64(s0)
    80014602:	fac43c23          	sd	a2,-72(s0)
    80014606:	e414                	sd	a3,8(s0)
    80014608:	e818                	sd	a4,16(s0)
    8001460a:	ec1c                	sd	a5,24(s0)
    8001460c:	03043023          	sd	a6,32(s0)
    80014610:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80014614:	03040793          	addi	a5,s0,48
    80014618:	faf43823          	sd	a5,-80(s0)
    8001461c:	fb043783          	ld	a5,-80(s0)
    80014620:	fd878793          	addi	a5,a5,-40
    80014624:	fef43023          	sd	a5,-32(s0)
    const out_fct_wrap_type out_fct_wrap = {out, arg};
    80014628:	fc843783          	ld	a5,-56(s0)
    8001462c:	fcf43823          	sd	a5,-48(s0)
    80014630:	fc043783          	ld	a5,-64(s0)
    80014634:	fcf43c23          	sd	a5,-40(s0)
    const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap,
    80014638:	fe043703          	ld	a4,-32(s0)
    8001463c:	fd040793          	addi	a5,s0,-48
    80014640:	fb843683          	ld	a3,-72(s0)
    80014644:	567d                	li	a2,-1
    80014646:	85be                	mv	a1,a5
    80014648:	ffffe517          	auipc	a0,0xffffe
    8001464c:	0ee50513          	addi	a0,a0,238 # 80012736 <_out_fct>
    80014650:	a0eff0ef          	jal	ra,8001385e <_vsnprintf>
    80014654:	87aa                	mv	a5,a0
    80014656:	fef42623          	sw	a5,-20(s0)
                               (size_t)-1, format, va);
    va_end(va);
    return ret;
    8001465a:	fec42783          	lw	a5,-20(s0)
}
    8001465e:	853e                	mv	a0,a5
    80014660:	60a6                	ld	ra,72(sp)
    80014662:	6406                	ld	s0,64(sp)
    80014664:	6109                	addi	sp,sp,128
    80014666:	8082                	ret
	...

0000000080014670 <_start>:
.section .text
.global _start
_start:
.option push
.option norelax
	la		sp, _stack_end
    80014670:	00010117          	auipc	sp,0x10
    80014674:	99010113          	addi	sp,sp,-1648 # 80024000 <_heap_start>
	la		gp, __global_pointer$
    80014678:	00004197          	auipc	gp,0x4
    8001467c:	98818193          	addi	gp,gp,-1656 # 80018000 <kernel_mmu_table>
    # Unlike the SBI, we will be trap returning so that
    # we know the registers sstatus, sip, stvec, and sepc are
    # in a place where we expect them to be. We can just jump
    # into main (tail main) like the SBI, but this ensures the CSRs
    # are what we say they are instead of just assuming from the SBI.
	la		t0, main
    80014680:	ffffd297          	auipc	t0,0xffffd
    80014684:	88a28293          	addi	t0,t0,-1910 # 80010f0a <main>
	csrw	sepc, t0
    80014688:	14129073          	csrw	sepc,t0
	li		t0, 1 << 9
    8001468c:	20000293          	li	t0,512
	csrw	sie, t0
    80014690:	10429073          	csrw	sie,t0
    # 1 << 13 - FS:  in the "initial" position
    # 1 << 8  - SPP: into Supervisor Mode
    # 1 << 5  - SPIE: enable interrupts
	li		t0, (1 << 13) | (1 << 8) | (1 << 5)
    80014694:	6289                	lui	t0,0x2
    80014696:	1202829b          	addiw	t0,t0,288
	csrw	sstatus, t0
    8001469a:	10029073          	csrw	sstatus,t0
    # Load the return address (RA) to the park. When main
    # returns, it will park the HART.
	la		ra, park
    8001469e:	00000097          	auipc	ra,0x0
    800146a2:	01208093          	addi	ra,ra,18 # 800146b0 <park>
	csrr	a0, sscratch
    800146a6:	14002573          	csrr	a0,sscratch
	sret
    800146aa:	10200073          	sret
    800146ae:	0001                	nop

00000000800146b0 <park>:

.section .text
.global park
.align 4
park:
	wfi
    800146b0:	10500073          	wfi
	j	park
    800146b4:	bff5                	j	800146b0 <park>

00000000800146b6 <park_end>:
	...

00000000800146c4 <process_asm_run>:

.section .text
.global process_asm_run
process_asm_run:
    # a0 - Trap frame
    csrw    sscratch, a0
    800146c4:	14051073          	csrw	sscratch,a0
    tail    _spawn_kthread
    800146c8:	1390206f          	j	80017000 <_spawn_kthread>

00000000800146cc <list_init>:
typedef struct List {
    ListElem head;
} List;

static List *list_init(List *lst)
{
    800146cc:	1101                	addi	sp,sp,-32
    800146ce:	ec22                	sd	s0,24(sp)
    800146d0:	1000                	addi	s0,sp,32
    800146d2:	fea43423          	sd	a0,-24(s0)
    lst->head.next = &lst->head;
    800146d6:	fe843703          	ld	a4,-24(s0)
    800146da:	fe843783          	ld	a5,-24(s0)
    800146de:	e798                	sd	a4,8(a5)
    lst->head.prev = &lst->head;
    800146e0:	fe843703          	ld	a4,-24(s0)
    800146e4:	fe843783          	ld	a5,-24(s0)
    800146e8:	eb98                	sd	a4,16(a5)

    return lst;
    800146ea:	fe843783          	ld	a5,-24(s0)
}
    800146ee:	853e                	mv	a0,a5
    800146f0:	6462                	ld	s0,24(sp)
    800146f2:	6105                	addi	sp,sp,32
    800146f4:	8082                	ret

00000000800146f6 <list_new>:

List *list_new(void)
{
    800146f6:	1101                	addi	sp,sp,-32
    800146f8:	ec06                	sd	ra,24(sp)
    800146fa:	e822                	sd	s0,16(sp)
    800146fc:	1000                	addi	s0,sp,32
    List *m = (List *)g_kmalloc(sizeof(List));
    800146fe:	4561                	li	a0,24
    80014700:	363010ef          	jal	ra,80016262 <g_kmalloc>
    80014704:	fea43423          	sd	a0,-24(s0)
    if (m == NULL) {
    80014708:	fe843783          	ld	a5,-24(s0)
    8001470c:	e399                	bnez	a5,80014712 <list_new+0x1c>
        return NULL;
    8001470e:	4781                	li	a5,0
    80014710:	a031                	j	8001471c <list_new+0x26>
    }
    return list_init(m);
    80014712:	fe843503          	ld	a0,-24(s0)
    80014716:	fb7ff0ef          	jal	ra,800146cc <list_init>
    8001471a:	87aa                	mv	a5,a0
}
    8001471c:	853e                	mv	a0,a5
    8001471e:	60e2                	ld	ra,24(sp)
    80014720:	6442                	ld	s0,16(sp)
    80014722:	6105                	addi	sp,sp,32
    80014724:	8082                	ret

0000000080014726 <list_add>:

void list_add(List *lst, uint64_t value)
{
    80014726:	7179                	addi	sp,sp,-48
    80014728:	f406                	sd	ra,40(sp)
    8001472a:	f022                	sd	s0,32(sp)
    8001472c:	1800                	addi	s0,sp,48
    8001472e:	fca43c23          	sd	a0,-40(s0)
    80014732:	fcb43823          	sd	a1,-48(s0)
    ListElem *l;
    l             = (ListElem *)g_kzalloc(sizeof(ListElem));
    80014736:	4561                	li	a0,24
    80014738:	3a3010ef          	jal	ra,800162da <g_kzalloc>
    8001473c:	fea43423          	sd	a0,-24(s0)
    l->next       = lst->head.next;
    80014740:	fd843783          	ld	a5,-40(s0)
    80014744:	6798                	ld	a4,8(a5)
    80014746:	fe843783          	ld	a5,-24(s0)
    8001474a:	e798                	sd	a4,8(a5)
    l->prev       = &lst->head;
    8001474c:	fd843703          	ld	a4,-40(s0)
    80014750:	fe843783          	ld	a5,-24(s0)
    80014754:	eb98                	sd	a4,16(a5)
    l->next->prev = l;
    80014756:	fe843783          	ld	a5,-24(s0)
    8001475a:	679c                	ld	a5,8(a5)
    8001475c:	fe843703          	ld	a4,-24(s0)
    80014760:	eb98                	sd	a4,16(a5)
    l->prev->next = l;
    80014762:	fe843783          	ld	a5,-24(s0)
    80014766:	6b9c                	ld	a5,16(a5)
    80014768:	fe843703          	ld	a4,-24(s0)
    8001476c:	e798                	sd	a4,8(a5)
    l->value      = value;
    8001476e:	fe843783          	ld	a5,-24(s0)
    80014772:	fd043703          	ld	a4,-48(s0)
    80014776:	e398                	sd	a4,0(a5)
}
    80014778:	0001                	nop
    8001477a:	70a2                	ld	ra,40(sp)
    8001477c:	7402                	ld	s0,32(sp)
    8001477e:	6145                	addi	sp,sp,48
    80014780:	8082                	ret

0000000080014782 <list_clear>:

void list_clear(List *lst)
{
    80014782:	7179                	addi	sp,sp,-48
    80014784:	f406                	sd	ra,40(sp)
    80014786:	f022                	sd	s0,32(sp)
    80014788:	1800                	addi	s0,sp,48
    8001478a:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001478e:	fd843783          	ld	a5,-40(s0)
    80014792:	679c                	ld	a5,8(a5)
    80014794:	fef43423          	sd	a5,-24(s0)
    80014798:	a831                	j	800147b4 <list_clear+0x32>
        n = e->next;
    8001479a:	fe843783          	ld	a5,-24(s0)
    8001479e:	679c                	ld	a5,8(a5)
    800147a0:	fef43023          	sd	a5,-32(s0)
        list_remove_elem(e);
    800147a4:	fe843503          	ld	a0,-24(s0)
    800147a8:	120000ef          	jal	ra,800148c8 <list_remove_elem>
    for (e = lst->head.next; e != &lst->head; e = n) {
    800147ac:	fe043783          	ld	a5,-32(s0)
    800147b0:	fef43423          	sd	a5,-24(s0)
    800147b4:	fd843783          	ld	a5,-40(s0)
    800147b8:	fe843703          	ld	a4,-24(s0)
    800147bc:	fcf71fe3          	bne	a4,a5,8001479a <list_clear+0x18>
    }
}
    800147c0:	0001                	nop
    800147c2:	0001                	nop
    800147c4:	70a2                	ld	ra,40(sp)
    800147c6:	7402                	ld	s0,32(sp)
    800147c8:	6145                	addi	sp,sp,48
    800147ca:	8082                	ret

00000000800147cc <list_sort>:

void list_sort(List *lst, LIST_COMPARATOR_PARAM(comp))
{
    800147cc:	7139                	addi	sp,sp,-64
    800147ce:	fc06                	sd	ra,56(sp)
    800147d0:	f822                	sd	s0,48(sp)
    800147d2:	0080                	addi	s0,sp,64
    800147d4:	fca43423          	sd	a0,-56(s0)
    800147d8:	fcb43023          	sd	a1,-64(s0)
    ListElem *e;
    bool swapped;
    uint64_t tmp;

    do {
        swapped = false;
    800147dc:	fe0403a3          	sb	zero,-25(s0)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    800147e0:	fc843783          	ld	a5,-56(s0)
    800147e4:	6b9c                	ld	a5,16(a5)
    800147e6:	fef43423          	sd	a5,-24(s0)
    800147ea:	a8a9                	j	80014844 <list_sort+0x78>
            if (!comp(e->value, e->prev->value)) {
    800147ec:	fe843783          	ld	a5,-24(s0)
    800147f0:	6398                	ld	a4,0(a5)
    800147f2:	fe843783          	ld	a5,-24(s0)
    800147f6:	6b9c                	ld	a5,16(a5)
    800147f8:	639c                	ld	a5,0(a5)
    800147fa:	fc043683          	ld	a3,-64(s0)
    800147fe:	85be                	mv	a1,a5
    80014800:	853a                	mv	a0,a4
    80014802:	9682                	jalr	a3
    80014804:	87aa                	mv	a5,a0
    80014806:	0017c793          	xori	a5,a5,1
    8001480a:	0ff7f793          	andi	a5,a5,255
    8001480e:	c795                	beqz	a5,8001483a <list_sort+0x6e>
                swapped        = true;
    80014810:	4785                	li	a5,1
    80014812:	fef403a3          	sb	a5,-25(s0)
                tmp            = e->value;
    80014816:	fe843783          	ld	a5,-24(s0)
    8001481a:	639c                	ld	a5,0(a5)
    8001481c:	fcf43c23          	sd	a5,-40(s0)
                e->value       = e->prev->value;
    80014820:	fe843783          	ld	a5,-24(s0)
    80014824:	6b9c                	ld	a5,16(a5)
    80014826:	6398                	ld	a4,0(a5)
    80014828:	fe843783          	ld	a5,-24(s0)
    8001482c:	e398                	sd	a4,0(a5)
                e->prev->value = tmp;
    8001482e:	fe843783          	ld	a5,-24(s0)
    80014832:	6b9c                	ld	a5,16(a5)
    80014834:	fd843703          	ld	a4,-40(s0)
    80014838:	e398                	sd	a4,0(a5)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    8001483a:	fe843783          	ld	a5,-24(s0)
    8001483e:	6b9c                	ld	a5,16(a5)
    80014840:	fef43423          	sd	a5,-24(s0)
    80014844:	fe843783          	ld	a5,-24(s0)
    80014848:	6b98                	ld	a4,16(a5)
    8001484a:	fc843783          	ld	a5,-56(s0)
    8001484e:	f8f71fe3          	bne	a4,a5,800147ec <list_sort+0x20>
            }
        }
    } while (swapped);
    80014852:	fe744783          	lbu	a5,-25(s0)
    80014856:	0ff7f793          	andi	a5,a5,255
    8001485a:	f3c9                	bnez	a5,800147dc <list_sort+0x10>
}
    8001485c:	0001                	nop
    8001485e:	0001                	nop
    80014860:	70e2                	ld	ra,56(sp)
    80014862:	7442                	ld	s0,48(sp)
    80014864:	6121                	addi	sp,sp,64
    80014866:	8082                	ret

0000000080014868 <list_remove>:

bool list_remove(List *lst, uint64_t value)
{
    80014868:	7179                	addi	sp,sp,-48
    8001486a:	f406                	sd	ra,40(sp)
    8001486c:	f022                	sd	s0,32(sp)
    8001486e:	1800                	addi	s0,sp,48
    80014870:	fca43c23          	sd	a0,-40(s0)
    80014874:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(lst, e)
    80014878:	fd843503          	ld	a0,-40(s0)
    8001487c:	2ca000ef          	jal	ra,80014b46 <list_elem_start_ascending>
    80014880:	fea43423          	sd	a0,-24(s0)
    80014884:	a025                	j	800148ac <list_remove+0x44>
    {
        if (e->value == value) {
    80014886:	fe843783          	ld	a5,-24(s0)
    8001488a:	639c                	ld	a5,0(a5)
    8001488c:	fd043703          	ld	a4,-48(s0)
    80014890:	00f71863          	bne	a4,a5,800148a0 <list_remove+0x38>
            list_remove_elem(e);
    80014894:	fe843503          	ld	a0,-24(s0)
    80014898:	030000ef          	jal	ra,800148c8 <list_remove_elem>
            return true;
    8001489c:	4785                	li	a5,1
    8001489e:	a005                	j	800148be <list_remove+0x56>
    list_for_each(lst, e)
    800148a0:	fe843503          	ld	a0,-24(s0)
    800148a4:	2ea000ef          	jal	ra,80014b8e <list_elem_prev>
    800148a8:	fea43423          	sd	a0,-24(s0)
    800148ac:	fe843583          	ld	a1,-24(s0)
    800148b0:	fd843503          	ld	a0,-40(s0)
    800148b4:	204000ef          	jal	ra,80014ab8 <list_elem_valid>
    800148b8:	87aa                	mv	a5,a0
    800148ba:	f7f1                	bnez	a5,80014886 <list_remove+0x1e>
        }
    }
    return false;
    800148bc:	4781                	li	a5,0
}
    800148be:	853e                	mv	a0,a5
    800148c0:	70a2                	ld	ra,40(sp)
    800148c2:	7402                	ld	s0,32(sp)
    800148c4:	6145                	addi	sp,sp,48
    800148c6:	8082                	ret

00000000800148c8 <list_remove_elem>:

void list_remove_elem(ListElem *e)
{
    800148c8:	1101                	addi	sp,sp,-32
    800148ca:	ec06                	sd	ra,24(sp)
    800148cc:	e822                	sd	s0,16(sp)
    800148ce:	1000                	addi	s0,sp,32
    800148d0:	fea43423          	sd	a0,-24(s0)
    e->next->prev = e->prev;
    800148d4:	fe843783          	ld	a5,-24(s0)
    800148d8:	679c                	ld	a5,8(a5)
    800148da:	fe843703          	ld	a4,-24(s0)
    800148de:	6b18                	ld	a4,16(a4)
    800148e0:	eb98                	sd	a4,16(a5)
    e->prev->next = e->next;
    800148e2:	fe843783          	ld	a5,-24(s0)
    800148e6:	6b9c                	ld	a5,16(a5)
    800148e8:	fe843703          	ld	a4,-24(s0)
    800148ec:	6718                	ld	a4,8(a4)
    800148ee:	e798                	sd	a4,8(a5)
    g_kfree(e);
    800148f0:	fe843503          	ld	a0,-24(s0)
    800148f4:	209010ef          	jal	ra,800162fc <g_kfree>
}
    800148f8:	0001                	nop
    800148fa:	60e2                	ld	ra,24(sp)
    800148fc:	6442                	ld	s0,16(sp)
    800148fe:	6105                	addi	sp,sp,32
    80014900:	8082                	ret

0000000080014902 <list_find_elem>:

ListElem *list_find_elem(List *l, uint64_t value)
{
    80014902:	7179                	addi	sp,sp,-48
    80014904:	f406                	sd	ra,40(sp)
    80014906:	f022                	sd	s0,32(sp)
    80014908:	1800                	addi	s0,sp,48
    8001490a:	fca43c23          	sd	a0,-40(s0)
    8001490e:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(l, e)
    80014912:	fd843503          	ld	a0,-40(s0)
    80014916:	230000ef          	jal	ra,80014b46 <list_elem_start_ascending>
    8001491a:	fea43423          	sd	a0,-24(s0)
    8001491e:	a00d                	j	80014940 <list_find_elem+0x3e>
    {
        if (e->value == value) {
    80014920:	fe843783          	ld	a5,-24(s0)
    80014924:	639c                	ld	a5,0(a5)
    80014926:	fd043703          	ld	a4,-48(s0)
    8001492a:	00f71563          	bne	a4,a5,80014934 <list_find_elem+0x32>
            return e;
    8001492e:	fe843783          	ld	a5,-24(s0)
    80014932:	a005                	j	80014952 <list_find_elem+0x50>
    list_for_each(l, e)
    80014934:	fe843503          	ld	a0,-24(s0)
    80014938:	256000ef          	jal	ra,80014b8e <list_elem_prev>
    8001493c:	fea43423          	sd	a0,-24(s0)
    80014940:	fe843583          	ld	a1,-24(s0)
    80014944:	fd843503          	ld	a0,-40(s0)
    80014948:	170000ef          	jal	ra,80014ab8 <list_elem_valid>
    8001494c:	87aa                	mv	a5,a0
    8001494e:	fbe9                	bnez	a5,80014920 <list_find_elem+0x1e>
        }
    }
    return NULL;
    80014950:	4781                	li	a5,0
}
    80014952:	853e                	mv	a0,a5
    80014954:	70a2                	ld	ra,40(sp)
    80014956:	7402                	ld	s0,32(sp)
    80014958:	6145                	addi	sp,sp,48
    8001495a:	8082                	ret

000000008001495c <list_contains>:

bool list_contains(const List *lst, uint64_t value)
{
    8001495c:	7179                	addi	sp,sp,-48
    8001495e:	f406                	sd	ra,40(sp)
    80014960:	f022                	sd	s0,32(sp)
    80014962:	1800                	addi	s0,sp,48
    80014964:	fca43c23          	sd	a0,-40(s0)
    80014968:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e = list_find_celem(lst, value);
    8001496c:	fd043583          	ld	a1,-48(s0)
    80014970:	fd843503          	ld	a0,-40(s0)
    80014974:	178000ef          	jal	ra,80014aec <list_find_celem>
    80014978:	fea43423          	sd	a0,-24(s0)

    return e == NULL ? false : true;
    8001497c:	fe843783          	ld	a5,-24(s0)
    80014980:	00f037b3          	snez	a5,a5
    80014984:	0ff7f793          	andi	a5,a5,255
}
    80014988:	853e                	mv	a0,a5
    8001498a:	70a2                	ld	ra,40(sp)
    8001498c:	7402                	ld	s0,32(sp)
    8001498e:	6145                	addi	sp,sp,48
    80014990:	8082                	ret

0000000080014992 <list_pop_back>:

ListElem *list_pop_back(List *l)
{
    80014992:	7179                	addi	sp,sp,-48
    80014994:	f406                	sd	ra,40(sp)
    80014996:	f022                	sd	s0,32(sp)
    80014998:	1800                	addi	s0,sp,48
    8001499a:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.next) {
    8001499e:	fd843703          	ld	a4,-40(s0)
    800149a2:	fd843783          	ld	a5,-40(s0)
    800149a6:	679c                	ld	a5,8(a5)
    800149a8:	00f71463          	bne	a4,a5,800149b0 <list_pop_back+0x1e>
        return NULL;
    800149ac:	4781                	li	a5,0
    800149ae:	a821                	j	800149c6 <list_pop_back+0x34>
    }
    ListElem *e = l->head.next;
    800149b0:	fd843783          	ld	a5,-40(s0)
    800149b4:	679c                	ld	a5,8(a5)
    800149b6:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    800149ba:	fe843503          	ld	a0,-24(s0)
    800149be:	f0bff0ef          	jal	ra,800148c8 <list_remove_elem>
    return e;
    800149c2:	fe843783          	ld	a5,-24(s0)
}
    800149c6:	853e                	mv	a0,a5
    800149c8:	70a2                	ld	ra,40(sp)
    800149ca:	7402                	ld	s0,32(sp)
    800149cc:	6145                	addi	sp,sp,48
    800149ce:	8082                	ret

00000000800149d0 <list_pop>:

ListElem *list_pop(List *l)
{
    800149d0:	7179                	addi	sp,sp,-48
    800149d2:	f406                	sd	ra,40(sp)
    800149d4:	f022                	sd	s0,32(sp)
    800149d6:	1800                	addi	s0,sp,48
    800149d8:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.prev) {
    800149dc:	fd843703          	ld	a4,-40(s0)
    800149e0:	fd843783          	ld	a5,-40(s0)
    800149e4:	6b9c                	ld	a5,16(a5)
    800149e6:	00f71463          	bne	a4,a5,800149ee <list_pop+0x1e>
        return NULL;
    800149ea:	4781                	li	a5,0
    800149ec:	a821                	j	80014a04 <list_pop+0x34>
    }
    ListElem *e = l->head.prev;
    800149ee:	fd843783          	ld	a5,-40(s0)
    800149f2:	6b9c                	ld	a5,16(a5)
    800149f4:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    800149f8:	fe843503          	ld	a0,-24(s0)
    800149fc:	ecdff0ef          	jal	ra,800148c8 <list_remove_elem>
    return e;
    80014a00:	fe843783          	ld	a5,-24(s0)
}
    80014a04:	853e                	mv	a0,a5
    80014a06:	70a2                	ld	ra,40(sp)
    80014a08:	7402                	ld	s0,32(sp)
    80014a0a:	6145                	addi	sp,sp,48
    80014a0c:	8082                	ret

0000000080014a0e <list_size>:

uint64_t list_size(const List *lst)
{
    80014a0e:	7179                	addi	sp,sp,-48
    80014a10:	f406                	sd	ra,40(sp)
    80014a12:	f022                	sd	s0,32(sp)
    80014a14:	1800                	addi	s0,sp,48
    80014a16:	fca43c23          	sd	a0,-40(s0)
    uint64_t s = 0;
    80014a1a:	fe043423          	sd	zero,-24(s0)
    const ListElem *e;
    list_for_ceach(lst, e)
    80014a1e:	fd843503          	ld	a0,-40(s0)
    80014a22:	19c000ef          	jal	ra,80014bbe <list_celem_start_ascending>
    80014a26:	fea43023          	sd	a0,-32(s0)
    80014a2a:	a821                	j	80014a42 <list_size+0x34>
    {
        s += 1;
    80014a2c:	fe843783          	ld	a5,-24(s0)
    80014a30:	0785                	addi	a5,a5,1
    80014a32:	fef43423          	sd	a5,-24(s0)
    list_for_ceach(lst, e)
    80014a36:	fe043503          	ld	a0,-32(s0)
    80014a3a:	1cc000ef          	jal	ra,80014c06 <list_celem_prev>
    80014a3e:	fea43023          	sd	a0,-32(s0)
    80014a42:	fe043583          	ld	a1,-32(s0)
    80014a46:	fd843503          	ld	a0,-40(s0)
    80014a4a:	06e000ef          	jal	ra,80014ab8 <list_elem_valid>
    80014a4e:	87aa                	mv	a5,a0
    80014a50:	fff1                	bnez	a5,80014a2c <list_size+0x1e>
    }
    return s;
    80014a52:	fe843783          	ld	a5,-24(s0)
}
    80014a56:	853e                	mv	a0,a5
    80014a58:	70a2                	ld	ra,40(sp)
    80014a5a:	7402                	ld	s0,32(sp)
    80014a5c:	6145                	addi	sp,sp,48
    80014a5e:	8082                	ret

0000000080014a60 <list_free>:

void list_free(List *lst)
{
    80014a60:	7179                	addi	sp,sp,-48
    80014a62:	f406                	sd	ra,40(sp)
    80014a64:	f022                	sd	s0,32(sp)
    80014a66:	1800                	addi	s0,sp,48
    80014a68:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    if (lst == NULL) {
    80014a6c:	fd843783          	ld	a5,-40(s0)
    80014a70:	cf9d                	beqz	a5,80014aae <list_free+0x4e>
        return;
    }
    for (e = lst->head.next; e != &lst->head; e = n) {
    80014a72:	fd843783          	ld	a5,-40(s0)
    80014a76:	679c                	ld	a5,8(a5)
    80014a78:	fef43423          	sd	a5,-24(s0)
    80014a7c:	a831                	j	80014a98 <list_free+0x38>
        n = e->next;
    80014a7e:	fe843783          	ld	a5,-24(s0)
    80014a82:	679c                	ld	a5,8(a5)
    80014a84:	fef43023          	sd	a5,-32(s0)
        g_kfree(e);
    80014a88:	fe843503          	ld	a0,-24(s0)
    80014a8c:	071010ef          	jal	ra,800162fc <g_kfree>
    for (e = lst->head.next; e != &lst->head; e = n) {
    80014a90:	fe043783          	ld	a5,-32(s0)
    80014a94:	fef43423          	sd	a5,-24(s0)
    80014a98:	fd843783          	ld	a5,-40(s0)
    80014a9c:	fe843703          	ld	a4,-24(s0)
    80014aa0:	fcf71fe3          	bne	a4,a5,80014a7e <list_free+0x1e>
    }
    g_kfree(lst);
    80014aa4:	fd843503          	ld	a0,-40(s0)
    80014aa8:	055010ef          	jal	ra,800162fc <g_kfree>
    80014aac:	a011                	j	80014ab0 <list_free+0x50>
        return;
    80014aae:	0001                	nop
}
    80014ab0:	70a2                	ld	ra,40(sp)
    80014ab2:	7402                	ld	s0,32(sp)
    80014ab4:	6145                	addi	sp,sp,48
    80014ab6:	8082                	ret

0000000080014ab8 <list_elem_valid>:

bool list_elem_valid(const List *l, const ListElem *e)
{
    80014ab8:	1101                	addi	sp,sp,-32
    80014aba:	ec22                	sd	s0,24(sp)
    80014abc:	1000                	addi	s0,sp,32
    80014abe:	fea43423          	sd	a0,-24(s0)
    80014ac2:	feb43023          	sd	a1,-32(s0)
    return e != NULL && e != &l->head;
    80014ac6:	fe043783          	ld	a5,-32(s0)
    80014aca:	cb89                	beqz	a5,80014adc <list_elem_valid+0x24>
    80014acc:	fe843783          	ld	a5,-24(s0)
    80014ad0:	fe043703          	ld	a4,-32(s0)
    80014ad4:	00f70463          	beq	a4,a5,80014adc <list_elem_valid+0x24>
    80014ad8:	4785                	li	a5,1
    80014ada:	a011                	j	80014ade <list_elem_valid+0x26>
    80014adc:	4781                	li	a5,0
    80014ade:	8b85                	andi	a5,a5,1
    80014ae0:	0ff7f793          	andi	a5,a5,255
}
    80014ae4:	853e                	mv	a0,a5
    80014ae6:	6462                	ld	s0,24(sp)
    80014ae8:	6105                	addi	sp,sp,32
    80014aea:	8082                	ret

0000000080014aec <list_find_celem>:

const ListElem *list_find_celem(const List *l, uint64_t value) 
{
    80014aec:	7179                	addi	sp,sp,-48
    80014aee:	f406                	sd	ra,40(sp)
    80014af0:	f022                	sd	s0,32(sp)
    80014af2:	1800                	addi	s0,sp,48
    80014af4:	fca43c23          	sd	a0,-40(s0)
    80014af8:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e;
    list_for_ceach(l, e) 
    80014afc:	fd843503          	ld	a0,-40(s0)
    80014b00:	0be000ef          	jal	ra,80014bbe <list_celem_start_ascending>
    80014b04:	fea43423          	sd	a0,-24(s0)
    80014b08:	a00d                	j	80014b2a <list_find_celem+0x3e>
    {
        if (e->value == value) {
    80014b0a:	fe843783          	ld	a5,-24(s0)
    80014b0e:	639c                	ld	a5,0(a5)
    80014b10:	fd043703          	ld	a4,-48(s0)
    80014b14:	00f71563          	bne	a4,a5,80014b1e <list_find_celem+0x32>
            return e;
    80014b18:	fe843783          	ld	a5,-24(s0)
    80014b1c:	a005                	j	80014b3c <list_find_celem+0x50>
    list_for_ceach(l, e) 
    80014b1e:	fe843503          	ld	a0,-24(s0)
    80014b22:	0e4000ef          	jal	ra,80014c06 <list_celem_prev>
    80014b26:	fea43423          	sd	a0,-24(s0)
    80014b2a:	fe843583          	ld	a1,-24(s0)
    80014b2e:	fd843503          	ld	a0,-40(s0)
    80014b32:	f87ff0ef          	jal	ra,80014ab8 <list_elem_valid>
    80014b36:	87aa                	mv	a5,a0
    80014b38:	fbe9                	bnez	a5,80014b0a <list_find_celem+0x1e>
        }
    }
    return NULL;
    80014b3a:	4781                	li	a5,0
}
    80014b3c:	853e                	mv	a0,a5
    80014b3e:	70a2                	ld	ra,40(sp)
    80014b40:	7402                	ld	s0,32(sp)
    80014b42:	6145                	addi	sp,sp,48
    80014b44:	8082                	ret

0000000080014b46 <list_elem_start_ascending>:

ListElem *list_elem_start_ascending(List *l)
{
    80014b46:	1101                	addi	sp,sp,-32
    80014b48:	ec22                	sd	s0,24(sp)
    80014b4a:	1000                	addi	s0,sp,32
    80014b4c:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    80014b50:	fe843783          	ld	a5,-24(s0)
    80014b54:	6b9c                	ld	a5,16(a5)
}
    80014b56:	853e                	mv	a0,a5
    80014b58:	6462                	ld	s0,24(sp)
    80014b5a:	6105                	addi	sp,sp,32
    80014b5c:	8082                	ret

0000000080014b5e <list_elem_start_descending>:

ListElem *list_elem_start_descending(List *l)
{
    80014b5e:	1101                	addi	sp,sp,-32
    80014b60:	ec22                	sd	s0,24(sp)
    80014b62:	1000                	addi	s0,sp,32
    80014b64:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    80014b68:	fe843783          	ld	a5,-24(s0)
    80014b6c:	679c                	ld	a5,8(a5)
}
    80014b6e:	853e                	mv	a0,a5
    80014b70:	6462                	ld	s0,24(sp)
    80014b72:	6105                	addi	sp,sp,32
    80014b74:	8082                	ret

0000000080014b76 <list_elem_next>:

ListElem *list_elem_next(ListElem *e)
{
    80014b76:	1101                	addi	sp,sp,-32
    80014b78:	ec22                	sd	s0,24(sp)
    80014b7a:	1000                	addi	s0,sp,32
    80014b7c:	fea43423          	sd	a0,-24(s0)
    return e->next;
    80014b80:	fe843783          	ld	a5,-24(s0)
    80014b84:	679c                	ld	a5,8(a5)
}
    80014b86:	853e                	mv	a0,a5
    80014b88:	6462                	ld	s0,24(sp)
    80014b8a:	6105                	addi	sp,sp,32
    80014b8c:	8082                	ret

0000000080014b8e <list_elem_prev>:

ListElem *list_elem_prev(ListElem *e)
{
    80014b8e:	1101                	addi	sp,sp,-32
    80014b90:	ec22                	sd	s0,24(sp)
    80014b92:	1000                	addi	s0,sp,32
    80014b94:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    80014b98:	fe843783          	ld	a5,-24(s0)
    80014b9c:	6b9c                	ld	a5,16(a5)
}
    80014b9e:	853e                	mv	a0,a5
    80014ba0:	6462                	ld	s0,24(sp)
    80014ba2:	6105                	addi	sp,sp,32
    80014ba4:	8082                	ret

0000000080014ba6 <list_elem_value>:

uint64_t list_elem_value(const ListElem *e)
{
    80014ba6:	1101                	addi	sp,sp,-32
    80014ba8:	ec22                	sd	s0,24(sp)
    80014baa:	1000                	addi	s0,sp,32
    80014bac:	fea43423          	sd	a0,-24(s0)
    return e->value;
    80014bb0:	fe843783          	ld	a5,-24(s0)
    80014bb4:	639c                	ld	a5,0(a5)
}
    80014bb6:	853e                	mv	a0,a5
    80014bb8:	6462                	ld	s0,24(sp)
    80014bba:	6105                	addi	sp,sp,32
    80014bbc:	8082                	ret

0000000080014bbe <list_celem_start_ascending>:

const ListElem *list_celem_start_ascending(const List *l) {
    80014bbe:	1101                	addi	sp,sp,-32
    80014bc0:	ec22                	sd	s0,24(sp)
    80014bc2:	1000                	addi	s0,sp,32
    80014bc4:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    80014bc8:	fe843783          	ld	a5,-24(s0)
    80014bcc:	6b9c                	ld	a5,16(a5)
}
    80014bce:	853e                	mv	a0,a5
    80014bd0:	6462                	ld	s0,24(sp)
    80014bd2:	6105                	addi	sp,sp,32
    80014bd4:	8082                	ret

0000000080014bd6 <list_celem_start_descending>:
const ListElem *list_celem_start_descending(const List *l) {
    80014bd6:	1101                	addi	sp,sp,-32
    80014bd8:	ec22                	sd	s0,24(sp)
    80014bda:	1000                	addi	s0,sp,32
    80014bdc:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    80014be0:	fe843783          	ld	a5,-24(s0)
    80014be4:	679c                	ld	a5,8(a5)
}
    80014be6:	853e                	mv	a0,a5
    80014be8:	6462                	ld	s0,24(sp)
    80014bea:	6105                	addi	sp,sp,32
    80014bec:	8082                	ret

0000000080014bee <list_celem_next>:
const ListElem *list_celem_next(const ListElem *e) {
    80014bee:	1101                	addi	sp,sp,-32
    80014bf0:	ec22                	sd	s0,24(sp)
    80014bf2:	1000                	addi	s0,sp,32
    80014bf4:	fea43423          	sd	a0,-24(s0)
    return e->next;
    80014bf8:	fe843783          	ld	a5,-24(s0)
    80014bfc:	679c                	ld	a5,8(a5)
}
    80014bfe:	853e                	mv	a0,a5
    80014c00:	6462                	ld	s0,24(sp)
    80014c02:	6105                	addi	sp,sp,32
    80014c04:	8082                	ret

0000000080014c06 <list_celem_prev>:
const ListElem *list_celem_prev(const ListElem *e) {
    80014c06:	1101                	addi	sp,sp,-32
    80014c08:	ec22                	sd	s0,24(sp)
    80014c0a:	1000                	addi	s0,sp,32
    80014c0c:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    80014c10:	fe843783          	ld	a5,-24(s0)
    80014c14:	6b9c                	ld	a5,16(a5)
}
    80014c16:	853e                	mv	a0,a5
    80014c18:	6462                	ld	s0,24(sp)
    80014c1a:	6105                	addi	sp,sp,32
    80014c1c:	8082                	ret

0000000080014c1e <list_sort_signed_long_comparator_ascending>:

// Default list comparators
LIST_COMPARATOR(list_sort_signed_long_comparator_ascending)
{
    80014c1e:	1101                	addi	sp,sp,-32
    80014c20:	ec22                	sd	s0,24(sp)
    80014c22:	1000                	addi	s0,sp,32
    80014c24:	fea43423          	sd	a0,-24(s0)
    80014c28:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    80014c2c:	fe843703          	ld	a4,-24(s0)
    80014c30:	fe043783          	ld	a5,-32(s0)
    80014c34:	00e7a7b3          	slt	a5,a5,a4
    80014c38:	0017c793          	xori	a5,a5,1
    80014c3c:	0ff7f793          	andi	a5,a5,255
}
    80014c40:	853e                	mv	a0,a5
    80014c42:	6462                	ld	s0,24(sp)
    80014c44:	6105                	addi	sp,sp,32
    80014c46:	8082                	ret

0000000080014c48 <list_sort_signed_long_comparator_descending>:
LIST_COMPARATOR(list_sort_signed_long_comparator_descending)
{
    80014c48:	1101                	addi	sp,sp,-32
    80014c4a:	ec22                	sd	s0,24(sp)
    80014c4c:	1000                	addi	s0,sp,32
    80014c4e:	fea43423          	sd	a0,-24(s0)
    80014c52:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    80014c56:	fe843703          	ld	a4,-24(s0)
    80014c5a:	fe043783          	ld	a5,-32(s0)
    80014c5e:	00f727b3          	slt	a5,a4,a5
    80014c62:	0017c793          	xori	a5,a5,1
    80014c66:	0ff7f793          	andi	a5,a5,255
}
    80014c6a:	853e                	mv	a0,a5
    80014c6c:	6462                	ld	s0,24(sp)
    80014c6e:	6105                	addi	sp,sp,32
    80014c70:	8082                	ret

0000000080014c72 <list_sort_unsigned_long_comparator_ascending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_ascending)
{
    80014c72:	1101                	addi	sp,sp,-32
    80014c74:	ec22                	sd	s0,24(sp)
    80014c76:	1000                	addi	s0,sp,32
    80014c78:	fea43423          	sd	a0,-24(s0)
    80014c7c:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    80014c80:	fe843703          	ld	a4,-24(s0)
    80014c84:	fe043783          	ld	a5,-32(s0)
    80014c88:	00e7b7b3          	sltu	a5,a5,a4
    80014c8c:	0017c793          	xori	a5,a5,1
    80014c90:	0ff7f793          	andi	a5,a5,255
}
    80014c94:	853e                	mv	a0,a5
    80014c96:	6462                	ld	s0,24(sp)
    80014c98:	6105                	addi	sp,sp,32
    80014c9a:	8082                	ret

0000000080014c9c <list_sort_unsigned_long_comparator_descending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_descending)
{
    80014c9c:	1101                	addi	sp,sp,-32
    80014c9e:	ec22                	sd	s0,24(sp)
    80014ca0:	1000                	addi	s0,sp,32
    80014ca2:	fea43423          	sd	a0,-24(s0)
    80014ca6:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    80014caa:	fe843703          	ld	a4,-24(s0)
    80014cae:	fe043783          	ld	a5,-32(s0)
    80014cb2:	00f737b3          	sltu	a5,a4,a5
    80014cb6:	0017c793          	xori	a5,a5,1
    80014cba:	0ff7f793          	andi	a5,a5,255
}
    80014cbe:	853e                	mv	a0,a5
    80014cc0:	6462                	ld	s0,24(sp)
    80014cc2:	6105                	addi	sp,sp,32
    80014cc4:	8082                	ret

0000000080014cc6 <list_sort_string_comparator_ascending>:
LIST_COMPARATOR(list_sort_string_comparator_ascending)
{
    80014cc6:	1101                	addi	sp,sp,-32
    80014cc8:	ec06                	sd	ra,24(sp)
    80014cca:	e822                	sd	s0,16(sp)
    80014ccc:	1000                	addi	s0,sp,32
    80014cce:	fea43423          	sd	a0,-24(s0)
    80014cd2:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    80014cd6:	fe843783          	ld	a5,-24(s0)
    80014cda:	fe043703          	ld	a4,-32(s0)
    80014cde:	85ba                	mv	a1,a4
    80014ce0:	853e                	mv	a0,a5
    80014ce2:	4e0000ef          	jal	ra,800151c2 <strcmp>
    80014ce6:	87aa                	mv	a5,a0
    80014ce8:	0017a793          	slti	a5,a5,1
    80014cec:	0ff7f793          	andi	a5,a5,255
}
    80014cf0:	853e                	mv	a0,a5
    80014cf2:	60e2                	ld	ra,24(sp)
    80014cf4:	6442                	ld	s0,16(sp)
    80014cf6:	6105                	addi	sp,sp,32
    80014cf8:	8082                	ret

0000000080014cfa <list_sort_string_comparator_descending>:
LIST_COMPARATOR(list_sort_string_comparator_descending)
{
    80014cfa:	1101                	addi	sp,sp,-32
    80014cfc:	ec06                	sd	ra,24(sp)
    80014cfe:	e822                	sd	s0,16(sp)
    80014d00:	1000                	addi	s0,sp,32
    80014d02:	fea43423          	sd	a0,-24(s0)
    80014d06:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    80014d0a:	fe843783          	ld	a5,-24(s0)
    80014d0e:	fe043703          	ld	a4,-32(s0)
    80014d12:	85ba                	mv	a1,a4
    80014d14:	853e                	mv	a0,a5
    80014d16:	4ac000ef          	jal	ra,800151c2 <strcmp>
    80014d1a:	87aa                	mv	a5,a0
    80014d1c:	fff7c793          	not	a5,a5
    80014d20:	01f7d79b          	srliw	a5,a5,0x1f
    80014d24:	0ff7f793          	andi	a5,a5,255
}
    80014d28:	853e                	mv	a0,a5
    80014d2a:	60e2                	ld	ra,24(sp)
    80014d2c:	6442                	ld	s0,16(sp)
    80014d2e:	6105                	addi	sp,sp,32
    80014d30:	8082                	ret

0000000080014d32 <memset>:
#include <alloc.h>
#include <stdint.h>
#include <util.h>

void *memset(void *dst, char data, int size)
{
    80014d32:	715d                	addi	sp,sp,-80
    80014d34:	e4a2                	sd	s0,72(sp)
    80014d36:	0880                	addi	s0,sp,80
    80014d38:	faa43c23          	sd	a0,-72(s0)
    80014d3c:	87ae                	mv	a5,a1
    80014d3e:	8732                	mv	a4,a2
    80014d40:	faf40ba3          	sb	a5,-73(s0)
    80014d44:	87ba                	mv	a5,a4
    80014d46:	faf42823          	sw	a5,-80(s0)
    int64_t i;
    long *ldst = (long *)dst;
    80014d4a:	fb843783          	ld	a5,-72(s0)
    80014d4e:	fef43023          	sd	a5,-32(s0)
    char *cdst;
    char l[]              = {data, data, data, data, data, data, data, data};
    80014d52:	fb744783          	lbu	a5,-73(s0)
    80014d56:	fcf40423          	sb	a5,-56(s0)
    80014d5a:	fb744783          	lbu	a5,-73(s0)
    80014d5e:	fcf404a3          	sb	a5,-55(s0)
    80014d62:	fb744783          	lbu	a5,-73(s0)
    80014d66:	fcf40523          	sb	a5,-54(s0)
    80014d6a:	fb744783          	lbu	a5,-73(s0)
    80014d6e:	fcf405a3          	sb	a5,-53(s0)
    80014d72:	fb744783          	lbu	a5,-73(s0)
    80014d76:	fcf40623          	sb	a5,-52(s0)
    80014d7a:	fb744783          	lbu	a5,-73(s0)
    80014d7e:	fcf406a3          	sb	a5,-51(s0)
    80014d82:	fb744783          	lbu	a5,-73(s0)
    80014d86:	fcf40723          	sb	a5,-50(s0)
    80014d8a:	fb744783          	lbu	a5,-73(s0)
    80014d8e:	fcf407a3          	sb	a5,-49(s0)

    int num_8_byte_copies = size / 8;
    80014d92:	fb042783          	lw	a5,-80(s0)
    80014d96:	41f7d71b          	sraiw	a4,a5,0x1f
    80014d9a:	01d7571b          	srliw	a4,a4,0x1d
    80014d9e:	9fb9                	addw	a5,a5,a4
    80014da0:	4037d79b          	sraiw	a5,a5,0x3
    80014da4:	fcf42a23          	sw	a5,-44(s0)
    int num_1_byte_copies = size % 8;
    80014da8:	fb042703          	lw	a4,-80(s0)
    80014dac:	41f7579b          	sraiw	a5,a4,0x1f
    80014db0:	01d7d79b          	srliw	a5,a5,0x1d
    80014db4:	9f3d                	addw	a4,a4,a5
    80014db6:	8b1d                	andi	a4,a4,7
    80014db8:	40f707bb          	subw	a5,a4,a5
    80014dbc:	fcf42823          	sw	a5,-48(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    80014dc0:	fe043423          	sd	zero,-24(s0)
    80014dc4:	a005                	j	80014de4 <memset+0xb2>
        *ldst++ = *((long *)l);
    80014dc6:	fc840713          	addi	a4,s0,-56
    80014dca:	fe043783          	ld	a5,-32(s0)
    80014dce:	00878693          	addi	a3,a5,8
    80014dd2:	fed43023          	sd	a3,-32(s0)
    80014dd6:	6318                	ld	a4,0(a4)
    80014dd8:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    80014dda:	fe843783          	ld	a5,-24(s0)
    80014dde:	0785                	addi	a5,a5,1
    80014de0:	fef43423          	sd	a5,-24(s0)
    80014de4:	fd442783          	lw	a5,-44(s0)
    80014de8:	fe843703          	ld	a4,-24(s0)
    80014dec:	fcf74de3          	blt	a4,a5,80014dc6 <memset+0x94>
    }

    cdst = (char *)ldst;
    80014df0:	fe043783          	ld	a5,-32(s0)
    80014df4:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    80014df8:	fe043423          	sd	zero,-24(s0)
    80014dfc:	a005                	j	80014e1c <memset+0xea>
        *cdst++ = data;
    80014dfe:	fd843783          	ld	a5,-40(s0)
    80014e02:	00178713          	addi	a4,a5,1
    80014e06:	fce43c23          	sd	a4,-40(s0)
    80014e0a:	fb744703          	lbu	a4,-73(s0)
    80014e0e:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    80014e12:	fe843783          	ld	a5,-24(s0)
    80014e16:	0785                	addi	a5,a5,1
    80014e18:	fef43423          	sd	a5,-24(s0)
    80014e1c:	fd042783          	lw	a5,-48(s0)
    80014e20:	fe843703          	ld	a4,-24(s0)
    80014e24:	fcf74de3          	blt	a4,a5,80014dfe <memset+0xcc>
    }

    return dst;
    80014e28:	fb843783          	ld	a5,-72(s0)
}
    80014e2c:	853e                	mv	a0,a5
    80014e2e:	6426                	ld	s0,72(sp)
    80014e30:	6161                	addi	sp,sp,80
    80014e32:	8082                	ret

0000000080014e34 <memcpy>:

void *memcpy(void *dst, const void *src, int size)
{
    80014e34:	711d                	addi	sp,sp,-96
    80014e36:	eca2                	sd	s0,88(sp)
    80014e38:	1080                	addi	s0,sp,96
    80014e3a:	faa43c23          	sd	a0,-72(s0)
    80014e3e:	fab43823          	sd	a1,-80(s0)
    80014e42:	87b2                	mv	a5,a2
    80014e44:	faf42623          	sw	a5,-84(s0)
    int i;
    char *cdst;
    const char *csrc;
    long *ldst            = (long *)dst;
    80014e48:	fb843783          	ld	a5,-72(s0)
    80014e4c:	fcf43823          	sd	a5,-48(s0)
    const long *lsrc      = (long *)src;
    80014e50:	fb043783          	ld	a5,-80(s0)
    80014e54:	fcf43423          	sd	a5,-56(s0)

    int num_8_byte_copies = size / 8;
    80014e58:	fac42783          	lw	a5,-84(s0)
    80014e5c:	41f7d71b          	sraiw	a4,a5,0x1f
    80014e60:	01d7571b          	srliw	a4,a4,0x1d
    80014e64:	9fb9                	addw	a5,a5,a4
    80014e66:	4037d79b          	sraiw	a5,a5,0x3
    80014e6a:	fcf42223          	sw	a5,-60(s0)
    int num_1_byte_copies = size % 8;
    80014e6e:	fac42703          	lw	a4,-84(s0)
    80014e72:	41f7579b          	sraiw	a5,a4,0x1f
    80014e76:	01d7d79b          	srliw	a5,a5,0x1d
    80014e7a:	9f3d                	addw	a4,a4,a5
    80014e7c:	8b1d                	andi	a4,a4,7
    80014e7e:	40f707bb          	subw	a5,a4,a5
    80014e82:	fcf42023          	sw	a5,-64(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    80014e86:	fe042623          	sw	zero,-20(s0)
    80014e8a:	a025                	j	80014eb2 <memcpy+0x7e>
        *ldst++ = *lsrc++;
    80014e8c:	fc843703          	ld	a4,-56(s0)
    80014e90:	00870793          	addi	a5,a4,8
    80014e94:	fcf43423          	sd	a5,-56(s0)
    80014e98:	fd043783          	ld	a5,-48(s0)
    80014e9c:	00878693          	addi	a3,a5,8
    80014ea0:	fcd43823          	sd	a3,-48(s0)
    80014ea4:	6318                	ld	a4,0(a4)
    80014ea6:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    80014ea8:	fec42783          	lw	a5,-20(s0)
    80014eac:	2785                	addiw	a5,a5,1
    80014eae:	fef42623          	sw	a5,-20(s0)
    80014eb2:	fec42703          	lw	a4,-20(s0)
    80014eb6:	fc442783          	lw	a5,-60(s0)
    80014eba:	2701                	sext.w	a4,a4
    80014ebc:	2781                	sext.w	a5,a5
    80014ebe:	fcf747e3          	blt	a4,a5,80014e8c <memcpy+0x58>
    }

    cdst = (char *)ldst;
    80014ec2:	fd043783          	ld	a5,-48(s0)
    80014ec6:	fef43023          	sd	a5,-32(s0)
    csrc = (char *)lsrc;
    80014eca:	fc843783          	ld	a5,-56(s0)
    80014ece:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    80014ed2:	fe042623          	sw	zero,-20(s0)
    80014ed6:	a035                	j	80014f02 <memcpy+0xce>
        *cdst++ = *csrc++;
    80014ed8:	fd843703          	ld	a4,-40(s0)
    80014edc:	00170793          	addi	a5,a4,1
    80014ee0:	fcf43c23          	sd	a5,-40(s0)
    80014ee4:	fe043783          	ld	a5,-32(s0)
    80014ee8:	00178693          	addi	a3,a5,1
    80014eec:	fed43023          	sd	a3,-32(s0)
    80014ef0:	00074703          	lbu	a4,0(a4)
    80014ef4:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    80014ef8:	fec42783          	lw	a5,-20(s0)
    80014efc:	2785                	addiw	a5,a5,1
    80014efe:	fef42623          	sw	a5,-20(s0)
    80014f02:	fec42703          	lw	a4,-20(s0)
    80014f06:	fc042783          	lw	a5,-64(s0)
    80014f0a:	2701                	sext.w	a4,a4
    80014f0c:	2781                	sext.w	a5,a5
    80014f0e:	fcf745e3          	blt	a4,a5,80014ed8 <memcpy+0xa4>
    }

    return dst;
    80014f12:	fb843783          	ld	a5,-72(s0)
}
    80014f16:	853e                	mv	a0,a5
    80014f18:	6466                	ld	s0,88(sp)
    80014f1a:	6125                	addi	sp,sp,96
    80014f1c:	8082                	ret

0000000080014f1e <memmove>:

void *memmove(void *_dst, const void *_src, int n)
{
    80014f1e:	7139                	addi	sp,sp,-64
    80014f20:	fc22                	sd	s0,56(sp)
    80014f22:	0080                	addi	s0,sp,64
    80014f24:	fca43c23          	sd	a0,-40(s0)
    80014f28:	fcb43823          	sd	a1,-48(s0)
    80014f2c:	87b2                	mv	a5,a2
    80014f2e:	fcf42623          	sw	a5,-52(s0)
    const char *src = _src;
    80014f32:	fd043783          	ld	a5,-48(s0)
    80014f36:	fef43423          	sd	a5,-24(s0)
    char *dst       = _dst;
    80014f3a:	fd843783          	ld	a5,-40(s0)
    80014f3e:	fef43023          	sd	a5,-32(s0)

    if (n == 0)
    80014f42:	fcc42783          	lw	a5,-52(s0)
    80014f46:	2781                	sext.w	a5,a5
    80014f48:	e781                	bnez	a5,80014f50 <memmove+0x32>
        return _dst;
    80014f4a:	fd843783          	ld	a5,-40(s0)
    80014f4e:	a845                	j	80014ffe <memmove+0xe0>

    if (src < dst && src + n > dst) {
    80014f50:	fe843703          	ld	a4,-24(s0)
    80014f54:	fe043783          	ld	a5,-32(s0)
    80014f58:	08f77c63          	bgeu	a4,a5,80014ff0 <memmove+0xd2>
    80014f5c:	fcc42783          	lw	a5,-52(s0)
    80014f60:	fe843703          	ld	a4,-24(s0)
    80014f64:	97ba                	add	a5,a5,a4
    80014f66:	fe043703          	ld	a4,-32(s0)
    80014f6a:	08f77363          	bgeu	a4,a5,80014ff0 <memmove+0xd2>
        src += n;
    80014f6e:	fcc42783          	lw	a5,-52(s0)
    80014f72:	fe843703          	ld	a4,-24(s0)
    80014f76:	97ba                	add	a5,a5,a4
    80014f78:	fef43423          	sd	a5,-24(s0)
        dst += n;
    80014f7c:	fcc42783          	lw	a5,-52(s0)
    80014f80:	fe043703          	ld	a4,-32(s0)
    80014f84:	97ba                	add	a5,a5,a4
    80014f86:	fef43023          	sd	a5,-32(s0)
        for (; n > 0; n -= 1) {
    80014f8a:	a805                	j	80014fba <memmove+0x9c>
            *--dst = *--src;
    80014f8c:	fe843783          	ld	a5,-24(s0)
    80014f90:	17fd                	addi	a5,a5,-1
    80014f92:	fef43423          	sd	a5,-24(s0)
    80014f96:	fe043783          	ld	a5,-32(s0)
    80014f9a:	17fd                	addi	a5,a5,-1
    80014f9c:	fef43023          	sd	a5,-32(s0)
    80014fa0:	fe843783          	ld	a5,-24(s0)
    80014fa4:	0007c703          	lbu	a4,0(a5)
    80014fa8:	fe043783          	ld	a5,-32(s0)
    80014fac:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    80014fb0:	fcc42783          	lw	a5,-52(s0)
    80014fb4:	37fd                	addiw	a5,a5,-1
    80014fb6:	fcf42623          	sw	a5,-52(s0)
    80014fba:	fcc42783          	lw	a5,-52(s0)
    80014fbe:	2781                	sext.w	a5,a5
    80014fc0:	fcf046e3          	bgtz	a5,80014f8c <memmove+0x6e>
    if (src < dst && src + n > dst) {
    80014fc4:	a81d                	j	80014ffa <memmove+0xdc>
        }
    }
    else {
        for (; n > 0; n -= 1) {
            *dst++ = *src++;
    80014fc6:	fe843703          	ld	a4,-24(s0)
    80014fca:	00170793          	addi	a5,a4,1
    80014fce:	fef43423          	sd	a5,-24(s0)
    80014fd2:	fe043783          	ld	a5,-32(s0)
    80014fd6:	00178693          	addi	a3,a5,1
    80014fda:	fed43023          	sd	a3,-32(s0)
    80014fde:	00074703          	lbu	a4,0(a4)
    80014fe2:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    80014fe6:	fcc42783          	lw	a5,-52(s0)
    80014fea:	37fd                	addiw	a5,a5,-1
    80014fec:	fcf42623          	sw	a5,-52(s0)
    80014ff0:	fcc42783          	lw	a5,-52(s0)
    80014ff4:	2781                	sext.w	a5,a5
    80014ff6:	fcf048e3          	bgtz	a5,80014fc6 <memmove+0xa8>
        }
    }

    return _dst;
    80014ffa:	fd843783          	ld	a5,-40(s0)
}
    80014ffe:	853e                	mv	a0,a5
    80015000:	7462                	ld	s0,56(sp)
    80015002:	6121                	addi	sp,sp,64
    80015004:	8082                	ret

0000000080015006 <memcmp>:

int memcmp(const void *haystack, const void *needle, int size)
{
    80015006:	715d                	addi	sp,sp,-80
    80015008:	e4a2                	sd	s0,72(sp)
    8001500a:	0880                	addi	s0,sp,80
    8001500c:	fca43423          	sd	a0,-56(s0)
    80015010:	fcb43023          	sd	a1,-64(s0)
    80015014:	87b2                	mv	a5,a2
    80015016:	faf42e23          	sw	a5,-68(s0)
    const char *hay  = (char *)haystack;
    8001501a:	fc843783          	ld	a5,-56(s0)
    8001501e:	fef43023          	sd	a5,-32(s0)
    const char *need = (char *)needle;
    80015022:	fc043783          	ld	a5,-64(s0)
    80015026:	fcf43c23          	sd	a5,-40(s0)
    int i;

    for (i = 0; i < (size - 1); i++) {
    8001502a:	fe042623          	sw	zero,-20(s0)
    8001502e:	a8a1                	j	80015086 <memcmp+0x80>
        if (hay[i] != need[i]) {
    80015030:	fec42783          	lw	a5,-20(s0)
    80015034:	fe043703          	ld	a4,-32(s0)
    80015038:	97ba                	add	a5,a5,a4
    8001503a:	0007c683          	lbu	a3,0(a5)
    8001503e:	fec42783          	lw	a5,-20(s0)
    80015042:	fd843703          	ld	a4,-40(s0)
    80015046:	97ba                	add	a5,a5,a4
    80015048:	0007c783          	lbu	a5,0(a5)
    8001504c:	8736                	mv	a4,a3
    8001504e:	02f70763          	beq	a4,a5,8001507c <memcmp+0x76>
            return hay[i] - need[i];
    80015052:	fec42783          	lw	a5,-20(s0)
    80015056:	fe043703          	ld	a4,-32(s0)
    8001505a:	97ba                	add	a5,a5,a4
    8001505c:	0007c783          	lbu	a5,0(a5)
    80015060:	0007871b          	sext.w	a4,a5
    80015064:	fec42783          	lw	a5,-20(s0)
    80015068:	fd843683          	ld	a3,-40(s0)
    8001506c:	97b6                	add	a5,a5,a3
    8001506e:	0007c783          	lbu	a5,0(a5)
    80015072:	2781                	sext.w	a5,a5
    80015074:	40f707bb          	subw	a5,a4,a5
    80015078:	2781                	sext.w	a5,a5
    8001507a:	a0a1                	j	800150c2 <memcmp+0xbc>
    for (i = 0; i < (size - 1); i++) {
    8001507c:	fec42783          	lw	a5,-20(s0)
    80015080:	2785                	addiw	a5,a5,1
    80015082:	fef42623          	sw	a5,-20(s0)
    80015086:	fbc42783          	lw	a5,-68(s0)
    8001508a:	37fd                	addiw	a5,a5,-1
    8001508c:	0007871b          	sext.w	a4,a5
    80015090:	fec42783          	lw	a5,-20(s0)
    80015094:	2781                	sext.w	a5,a5
    80015096:	f8e7cde3          	blt	a5,a4,80015030 <memcmp+0x2a>
        }
    }

    return hay[i] - need[i];
    8001509a:	fec42783          	lw	a5,-20(s0)
    8001509e:	fe043703          	ld	a4,-32(s0)
    800150a2:	97ba                	add	a5,a5,a4
    800150a4:	0007c783          	lbu	a5,0(a5)
    800150a8:	0007871b          	sext.w	a4,a5
    800150ac:	fec42783          	lw	a5,-20(s0)
    800150b0:	fd843683          	ld	a3,-40(s0)
    800150b4:	97b6                	add	a5,a5,a3
    800150b6:	0007c783          	lbu	a5,0(a5)
    800150ba:	2781                	sext.w	a5,a5
    800150bc:	40f707bb          	subw	a5,a4,a5
    800150c0:	2781                	sext.w	a5,a5
}
    800150c2:	853e                	mv	a0,a5
    800150c4:	6426                	ld	s0,72(sp)
    800150c6:	6161                	addi	sp,sp,80
    800150c8:	8082                	ret

00000000800150ca <atoi>:

int atoi(const char *st)
{
    800150ca:	7139                	addi	sp,sp,-64
    800150cc:	fc22                	sd	s0,56(sp)
    800150ce:	0080                	addi	s0,sp,64
    800150d0:	fca43423          	sd	a0,-56(s0)
    int r = 0;
    800150d4:	fe042623          	sw	zero,-20(s0)
    int p = 1;
    800150d8:	4785                	li	a5,1
    800150da:	fef42423          	sw	a5,-24(s0)
    int i;
    int l = 0;
    800150de:	fe042023          	sw	zero,-32(s0)
    int n = 0;
    800150e2:	fc042e23          	sw	zero,-36(s0)

    if (st[0] == '-') {
    800150e6:	fc843783          	ld	a5,-56(s0)
    800150ea:	0007c783          	lbu	a5,0(a5)
    800150ee:	873e                	mv	a4,a5
    800150f0:	02d00793          	li	a5,45
    800150f4:	02f71063          	bne	a4,a5,80015114 <atoi+0x4a>
        st++;
    800150f8:	fc843783          	ld	a5,-56(s0)
    800150fc:	0785                	addi	a5,a5,1
    800150fe:	fcf43423          	sd	a5,-56(s0)
        n = 1;
    80015102:	4785                	li	a5,1
    80015104:	fcf42e23          	sw	a5,-36(s0)
    }

    while (st[l] >= '0' && st[l] <= '9')
    80015108:	a031                	j	80015114 <atoi+0x4a>
        l++;
    8001510a:	fe042783          	lw	a5,-32(s0)
    8001510e:	2785                	addiw	a5,a5,1
    80015110:	fef42023          	sw	a5,-32(s0)
    while (st[l] >= '0' && st[l] <= '9')
    80015114:	fe042783          	lw	a5,-32(s0)
    80015118:	fc843703          	ld	a4,-56(s0)
    8001511c:	97ba                	add	a5,a5,a4
    8001511e:	0007c783          	lbu	a5,0(a5)
    80015122:	873e                	mv	a4,a5
    80015124:	02f00793          	li	a5,47
    80015128:	00e7fe63          	bgeu	a5,a4,80015144 <atoi+0x7a>
    8001512c:	fe042783          	lw	a5,-32(s0)
    80015130:	fc843703          	ld	a4,-56(s0)
    80015134:	97ba                	add	a5,a5,a4
    80015136:	0007c783          	lbu	a5,0(a5)
    8001513a:	873e                	mv	a4,a5
    8001513c:	03900793          	li	a5,57
    80015140:	fce7f5e3          	bgeu	a5,a4,8001510a <atoi+0x40>

    for (i = l - 1; i >= 0; i--) {
    80015144:	fe042783          	lw	a5,-32(s0)
    80015148:	37fd                	addiw	a5,a5,-1
    8001514a:	fef42223          	sw	a5,-28(s0)
    8001514e:	a0a9                	j	80015198 <atoi+0xce>
        r += p * (st[i] - '0');
    80015150:	fe442783          	lw	a5,-28(s0)
    80015154:	fc843703          	ld	a4,-56(s0)
    80015158:	97ba                	add	a5,a5,a4
    8001515a:	0007c783          	lbu	a5,0(a5)
    8001515e:	2781                	sext.w	a5,a5
    80015160:	fd07879b          	addiw	a5,a5,-48
    80015164:	2781                	sext.w	a5,a5
    80015166:	fe842703          	lw	a4,-24(s0)
    8001516a:	02f707bb          	mulw	a5,a4,a5
    8001516e:	2781                	sext.w	a5,a5
    80015170:	fec42703          	lw	a4,-20(s0)
    80015174:	9fb9                	addw	a5,a5,a4
    80015176:	fef42623          	sw	a5,-20(s0)
        p *= 10;
    8001517a:	fe842703          	lw	a4,-24(s0)
    8001517e:	87ba                	mv	a5,a4
    80015180:	0027979b          	slliw	a5,a5,0x2
    80015184:	9fb9                	addw	a5,a5,a4
    80015186:	0017979b          	slliw	a5,a5,0x1
    8001518a:	fef42423          	sw	a5,-24(s0)
    for (i = l - 1; i >= 0; i--) {
    8001518e:	fe442783          	lw	a5,-28(s0)
    80015192:	37fd                	addiw	a5,a5,-1
    80015194:	fef42223          	sw	a5,-28(s0)
    80015198:	fe442783          	lw	a5,-28(s0)
    8001519c:	2781                	sext.w	a5,a5
    8001519e:	fa07d9e3          	bgez	a5,80015150 <atoi+0x86>
    }

    return (n ? -r : r);
    800151a2:	fdc42783          	lw	a5,-36(s0)
    800151a6:	2781                	sext.w	a5,a5
    800151a8:	c799                	beqz	a5,800151b6 <atoi+0xec>
    800151aa:	fec42783          	lw	a5,-20(s0)
    800151ae:	40f007bb          	negw	a5,a5
    800151b2:	2781                	sext.w	a5,a5
    800151b4:	a019                	j	800151ba <atoi+0xf0>
    800151b6:	fec42783          	lw	a5,-20(s0)
}
    800151ba:	853e                	mv	a0,a5
    800151bc:	7462                	ld	s0,56(sp)
    800151be:	6121                	addi	sp,sp,64
    800151c0:	8082                	ret

00000000800151c2 <strcmp>:

int strcmp(const char *l, const char *r)
{
    800151c2:	7139                	addi	sp,sp,-64
    800151c4:	fc22                	sd	s0,56(sp)
    800151c6:	0080                	addi	s0,sp,64
    800151c8:	fca43423          	sd	a0,-56(s0)
    800151cc:	fcb43023          	sd	a1,-64(s0)
    const unsigned char *s1 = (const unsigned char *)l;
    800151d0:	fc843783          	ld	a5,-56(s0)
    800151d4:	fef43423          	sd	a5,-24(s0)
    const unsigned char *s2 = (const unsigned char *)r;
    800151d8:	fc043783          	ld	a5,-64(s0)
    800151dc:	fef43023          	sd	a5,-32(s0)
    unsigned int c1, c2;

    do {
        c1 = (unsigned char)*s1++;
    800151e0:	fe843783          	ld	a5,-24(s0)
    800151e4:	00178713          	addi	a4,a5,1
    800151e8:	fee43423          	sd	a4,-24(s0)
    800151ec:	0007c783          	lbu	a5,0(a5)
    800151f0:	fcf42e23          	sw	a5,-36(s0)
        c2 = (unsigned char)*s2++;
    800151f4:	fe043783          	ld	a5,-32(s0)
    800151f8:	00178713          	addi	a4,a5,1
    800151fc:	fee43023          	sd	a4,-32(s0)
    80015200:	0007c783          	lbu	a5,0(a5)
    80015204:	fcf42c23          	sw	a5,-40(s0)
        if (c1 == '\0')
    80015208:	fdc42783          	lw	a5,-36(s0)
    8001520c:	2781                	sext.w	a5,a5
    8001520e:	eb91                	bnez	a5,80015222 <strcmp+0x60>
            return c1 - c2;
    80015210:	fdc42703          	lw	a4,-36(s0)
    80015214:	fd842783          	lw	a5,-40(s0)
    80015218:	40f707bb          	subw	a5,a4,a5
    8001521c:	2781                	sext.w	a5,a5
    8001521e:	2781                	sext.w	a5,a5
    80015220:	a00d                	j	80015242 <strcmp+0x80>
    } while (c1 == c2);
    80015222:	fdc42703          	lw	a4,-36(s0)
    80015226:	fd842783          	lw	a5,-40(s0)
    8001522a:	2701                	sext.w	a4,a4
    8001522c:	2781                	sext.w	a5,a5
    8001522e:	faf709e3          	beq	a4,a5,800151e0 <strcmp+0x1e>

    return c1 - c2;
    80015232:	fdc42703          	lw	a4,-36(s0)
    80015236:	fd842783          	lw	a5,-40(s0)
    8001523a:	40f707bb          	subw	a5,a4,a5
    8001523e:	2781                	sext.w	a5,a5
    80015240:	2781                	sext.w	a5,a5
}
    80015242:	853e                	mv	a0,a5
    80015244:	7462                	ld	s0,56(sp)
    80015246:	6121                	addi	sp,sp,64
    80015248:	8082                	ret

000000008001524a <strncmp>:

int strncmp(const char *left, const char *right, int n)
{
    8001524a:	7139                	addi	sp,sp,-64
    8001524c:	fc22                	sd	s0,56(sp)
    8001524e:	0080                	addi	s0,sp,64
    80015250:	fca43c23          	sd	a0,-40(s0)
    80015254:	fcb43823          	sd	a1,-48(s0)
    80015258:	87b2                	mv	a5,a2
    8001525a:	fcf42623          	sw	a5,-52(s0)
    unsigned int c1 = '\0';
    8001525e:	fe042623          	sw	zero,-20(s0)
    unsigned int c2 = '\0';
    80015262:	fe042423          	sw	zero,-24(s0)

    if (n >= 4) {
    80015266:	fcc42783          	lw	a5,-52(s0)
    8001526a:	0007871b          	sext.w	a4,a5
    8001526e:	478d                	li	a5,3
    80015270:	1ce7da63          	bge	a5,a4,80015444 <strncmp+0x1fa>
        int n4 = n >> 2;
    80015274:	fcc42783          	lw	a5,-52(s0)
    80015278:	4027d79b          	sraiw	a5,a5,0x2
    8001527c:	fef42223          	sw	a5,-28(s0)
        do {
            c1 = (unsigned char)*left++;
    80015280:	fd843783          	ld	a5,-40(s0)
    80015284:	00178713          	addi	a4,a5,1
    80015288:	fce43c23          	sd	a4,-40(s0)
    8001528c:	0007c783          	lbu	a5,0(a5)
    80015290:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80015294:	fd043783          	ld	a5,-48(s0)
    80015298:	00178713          	addi	a4,a5,1
    8001529c:	fce43823          	sd	a4,-48(s0)
    800152a0:	0007c783          	lbu	a5,0(a5)
    800152a4:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    800152a8:	fec42783          	lw	a5,-20(s0)
    800152ac:	2781                	sext.w	a5,a5
    800152ae:	cb89                	beqz	a5,800152c0 <strncmp+0x76>
    800152b0:	fec42703          	lw	a4,-20(s0)
    800152b4:	fe842783          	lw	a5,-24(s0)
    800152b8:	2701                	sext.w	a4,a4
    800152ba:	2781                	sext.w	a5,a5
    800152bc:	00f70b63          	beq	a4,a5,800152d2 <strncmp+0x88>
                return c1 - c2;
    800152c0:	fec42703          	lw	a4,-20(s0)
    800152c4:	fe842783          	lw	a5,-24(s0)
    800152c8:	40f707bb          	subw	a5,a4,a5
    800152cc:	2781                	sext.w	a5,a5
    800152ce:	2781                	sext.w	a5,a5
    800152d0:	a279                	j	8001545e <strncmp+0x214>
            }

            c1 = (unsigned char)*left++;
    800152d2:	fd843783          	ld	a5,-40(s0)
    800152d6:	00178713          	addi	a4,a5,1
    800152da:	fce43c23          	sd	a4,-40(s0)
    800152de:	0007c783          	lbu	a5,0(a5)
    800152e2:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    800152e6:	fd043783          	ld	a5,-48(s0)
    800152ea:	00178713          	addi	a4,a5,1
    800152ee:	fce43823          	sd	a4,-48(s0)
    800152f2:	0007c783          	lbu	a5,0(a5)
    800152f6:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    800152fa:	fec42783          	lw	a5,-20(s0)
    800152fe:	2781                	sext.w	a5,a5
    80015300:	cb89                	beqz	a5,80015312 <strncmp+0xc8>
    80015302:	fec42703          	lw	a4,-20(s0)
    80015306:	fe842783          	lw	a5,-24(s0)
    8001530a:	2701                	sext.w	a4,a4
    8001530c:	2781                	sext.w	a5,a5
    8001530e:	00f70b63          	beq	a4,a5,80015324 <strncmp+0xda>
                return c1 - c2;
    80015312:	fec42703          	lw	a4,-20(s0)
    80015316:	fe842783          	lw	a5,-24(s0)
    8001531a:	40f707bb          	subw	a5,a4,a5
    8001531e:	2781                	sext.w	a5,a5
    80015320:	2781                	sext.w	a5,a5
    80015322:	aa35                	j	8001545e <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    80015324:	fd843783          	ld	a5,-40(s0)
    80015328:	00178713          	addi	a4,a5,1
    8001532c:	fce43c23          	sd	a4,-40(s0)
    80015330:	0007c783          	lbu	a5,0(a5)
    80015334:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80015338:	fd043783          	ld	a5,-48(s0)
    8001533c:	00178713          	addi	a4,a5,1
    80015340:	fce43823          	sd	a4,-48(s0)
    80015344:	0007c783          	lbu	a5,0(a5)
    80015348:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001534c:	fec42783          	lw	a5,-20(s0)
    80015350:	2781                	sext.w	a5,a5
    80015352:	cb89                	beqz	a5,80015364 <strncmp+0x11a>
    80015354:	fec42703          	lw	a4,-20(s0)
    80015358:	fe842783          	lw	a5,-24(s0)
    8001535c:	2701                	sext.w	a4,a4
    8001535e:	2781                	sext.w	a5,a5
    80015360:	00f70b63          	beq	a4,a5,80015376 <strncmp+0x12c>
                return c1 - c2;
    80015364:	fec42703          	lw	a4,-20(s0)
    80015368:	fe842783          	lw	a5,-24(s0)
    8001536c:	40f707bb          	subw	a5,a4,a5
    80015370:	2781                	sext.w	a5,a5
    80015372:	2781                	sext.w	a5,a5
    80015374:	a0ed                	j	8001545e <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    80015376:	fd843783          	ld	a5,-40(s0)
    8001537a:	00178713          	addi	a4,a5,1
    8001537e:	fce43c23          	sd	a4,-40(s0)
    80015382:	0007c783          	lbu	a5,0(a5)
    80015386:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8001538a:	fd043783          	ld	a5,-48(s0)
    8001538e:	00178713          	addi	a4,a5,1
    80015392:	fce43823          	sd	a4,-48(s0)
    80015396:	0007c783          	lbu	a5,0(a5)
    8001539a:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001539e:	fec42783          	lw	a5,-20(s0)
    800153a2:	2781                	sext.w	a5,a5
    800153a4:	cb89                	beqz	a5,800153b6 <strncmp+0x16c>
    800153a6:	fec42703          	lw	a4,-20(s0)
    800153aa:	fe842783          	lw	a5,-24(s0)
    800153ae:	2701                	sext.w	a4,a4
    800153b0:	2781                	sext.w	a5,a5
    800153b2:	00f70b63          	beq	a4,a5,800153c8 <strncmp+0x17e>
                return c1 - c2;
    800153b6:	fec42703          	lw	a4,-20(s0)
    800153ba:	fe842783          	lw	a5,-24(s0)
    800153be:	40f707bb          	subw	a5,a4,a5
    800153c2:	2781                	sext.w	a5,a5
    800153c4:	2781                	sext.w	a5,a5
    800153c6:	a861                	j	8001545e <strncmp+0x214>
            }
        } while (--n4 > 0);
    800153c8:	fe442783          	lw	a5,-28(s0)
    800153cc:	37fd                	addiw	a5,a5,-1
    800153ce:	fef42223          	sw	a5,-28(s0)
    800153d2:	fe442783          	lw	a5,-28(s0)
    800153d6:	2781                	sext.w	a5,a5
    800153d8:	eaf044e3          	bgtz	a5,80015280 <strncmp+0x36>
        n &= 3;
    800153dc:	fcc42783          	lw	a5,-52(s0)
    800153e0:	8b8d                	andi	a5,a5,3
    800153e2:	fcf42623          	sw	a5,-52(s0)
    }

    while (n > 0) {
    800153e6:	a8b9                	j	80015444 <strncmp+0x1fa>
        c1 = (unsigned char)*left++;
    800153e8:	fd843783          	ld	a5,-40(s0)
    800153ec:	00178713          	addi	a4,a5,1
    800153f0:	fce43c23          	sd	a4,-40(s0)
    800153f4:	0007c783          	lbu	a5,0(a5)
    800153f8:	fef42623          	sw	a5,-20(s0)
        c2 = (unsigned char)*right++;
    800153fc:	fd043783          	ld	a5,-48(s0)
    80015400:	00178713          	addi	a4,a5,1
    80015404:	fce43823          	sd	a4,-48(s0)
    80015408:	0007c783          	lbu	a5,0(a5)
    8001540c:	fef42423          	sw	a5,-24(s0)
        if (c1 == '\0' || c1 != c2)
    80015410:	fec42783          	lw	a5,-20(s0)
    80015414:	2781                	sext.w	a5,a5
    80015416:	cb89                	beqz	a5,80015428 <strncmp+0x1de>
    80015418:	fec42703          	lw	a4,-20(s0)
    8001541c:	fe842783          	lw	a5,-24(s0)
    80015420:	2701                	sext.w	a4,a4
    80015422:	2781                	sext.w	a5,a5
    80015424:	00f70b63          	beq	a4,a5,8001543a <strncmp+0x1f0>
            return c1 - c2;
    80015428:	fec42703          	lw	a4,-20(s0)
    8001542c:	fe842783          	lw	a5,-24(s0)
    80015430:	40f707bb          	subw	a5,a4,a5
    80015434:	2781                	sext.w	a5,a5
    80015436:	2781                	sext.w	a5,a5
    80015438:	a01d                	j	8001545e <strncmp+0x214>
        n--;
    8001543a:	fcc42783          	lw	a5,-52(s0)
    8001543e:	37fd                	addiw	a5,a5,-1
    80015440:	fcf42623          	sw	a5,-52(s0)
    while (n > 0) {
    80015444:	fcc42783          	lw	a5,-52(s0)
    80015448:	2781                	sext.w	a5,a5
    8001544a:	f8f04fe3          	bgtz	a5,800153e8 <strncmp+0x19e>
    }

    return c1 - c2;
    8001544e:	fec42703          	lw	a4,-20(s0)
    80015452:	fe842783          	lw	a5,-24(s0)
    80015456:	40f707bb          	subw	a5,a4,a5
    8001545a:	2781                	sext.w	a5,a5
    8001545c:	2781                	sext.w	a5,a5
}
    8001545e:	853e                	mv	a0,a5
    80015460:	7462                	ld	s0,56(sp)
    80015462:	6121                	addi	sp,sp,64
    80015464:	8082                	ret

0000000080015466 <strfindchr>:

int strfindchr(const char *r, char t)
{
    80015466:	7179                	addi	sp,sp,-48
    80015468:	f422                	sd	s0,40(sp)
    8001546a:	1800                	addi	s0,sp,48
    8001546c:	fca43c23          	sd	a0,-40(s0)
    80015470:	87ae                	mv	a5,a1
    80015472:	fcf40ba3          	sb	a5,-41(s0)
    int i = 0;
    80015476:	fe042623          	sw	zero,-20(s0)
    while (r[i] != t) {
    8001547a:	a005                	j	8001549a <strfindchr+0x34>
        if (r[i] == '\0') {
    8001547c:	fec42783          	lw	a5,-20(s0)
    80015480:	fd843703          	ld	a4,-40(s0)
    80015484:	97ba                	add	a5,a5,a4
    80015486:	0007c783          	lbu	a5,0(a5)
    8001548a:	e399                	bnez	a5,80015490 <strfindchr+0x2a>
            return -1;
    8001548c:	57fd                	li	a5,-1
    8001548e:	a02d                	j	800154b8 <strfindchr+0x52>
        }
        i++;
    80015490:	fec42783          	lw	a5,-20(s0)
    80015494:	2785                	addiw	a5,a5,1
    80015496:	fef42623          	sw	a5,-20(s0)
    while (r[i] != t) {
    8001549a:	fec42783          	lw	a5,-20(s0)
    8001549e:	fd843703          	ld	a4,-40(s0)
    800154a2:	97ba                	add	a5,a5,a4
    800154a4:	0007c703          	lbu	a4,0(a5)
    800154a8:	fd744783          	lbu	a5,-41(s0)
    800154ac:	0ff7f793          	andi	a5,a5,255
    800154b0:	fce796e3          	bne	a5,a4,8001547c <strfindchr+0x16>
    }
    return i;
    800154b4:	fec42783          	lw	a5,-20(s0)
}
    800154b8:	853e                	mv	a0,a5
    800154ba:	7422                	ld	s0,40(sp)
    800154bc:	6145                	addi	sp,sp,48
    800154be:	8082                	ret

00000000800154c0 <strlen>:

int strlen(const char *s)
{
    800154c0:	7179                	addi	sp,sp,-48
    800154c2:	f422                	sd	s0,40(sp)
    800154c4:	1800                	addi	s0,sp,48
    800154c6:	fca43c23          	sd	a0,-40(s0)
    int len = 0;
    800154ca:	fe042623          	sw	zero,-20(s0)
    while (s[len] && ++len)
    800154ce:	0001                	nop
    800154d0:	fec42783          	lw	a5,-20(s0)
    800154d4:	fd843703          	ld	a4,-40(s0)
    800154d8:	97ba                	add	a5,a5,a4
    800154da:	0007c783          	lbu	a5,0(a5)
    800154de:	cb91                	beqz	a5,800154f2 <strlen+0x32>
    800154e0:	fec42783          	lw	a5,-20(s0)
    800154e4:	2785                	addiw	a5,a5,1
    800154e6:	fef42623          	sw	a5,-20(s0)
    800154ea:	fec42783          	lw	a5,-20(s0)
    800154ee:	2781                	sext.w	a5,a5
    800154f0:	f3e5                	bnez	a5,800154d0 <strlen+0x10>
        ;
    return len;
    800154f2:	fec42783          	lw	a5,-20(s0)
}
    800154f6:	853e                	mv	a0,a5
    800154f8:	7422                	ld	s0,40(sp)
    800154fa:	6145                	addi	sp,sp,48
    800154fc:	8082                	ret

00000000800154fe <strcpy>:

char *strcpy(char *dest, const char *s)
{
    800154fe:	7179                	addi	sp,sp,-48
    80015500:	f422                	sd	s0,40(sp)
    80015502:	1800                	addi	s0,sp,48
    80015504:	fca43c23          	sd	a0,-40(s0)
    80015508:	fcb43823          	sd	a1,-48(s0)
    char *o = dest;
    8001550c:	fd843783          	ld	a5,-40(s0)
    80015510:	fef43423          	sd	a5,-24(s0)
    while (*s) {
    80015514:	a00d                	j	80015536 <strcpy+0x38>
        *dest++ = *s++;
    80015516:	fd043703          	ld	a4,-48(s0)
    8001551a:	00170793          	addi	a5,a4,1
    8001551e:	fcf43823          	sd	a5,-48(s0)
    80015522:	fd843783          	ld	a5,-40(s0)
    80015526:	00178693          	addi	a3,a5,1
    8001552a:	fcd43c23          	sd	a3,-40(s0)
    8001552e:	00074703          	lbu	a4,0(a4)
    80015532:	00e78023          	sb	a4,0(a5)
    while (*s) {
    80015536:	fd043783          	ld	a5,-48(s0)
    8001553a:	0007c783          	lbu	a5,0(a5)
    8001553e:	ffe1                	bnez	a5,80015516 <strcpy+0x18>
    }
    *dest = '\0';
    80015540:	fd843783          	ld	a5,-40(s0)
    80015544:	00078023          	sb	zero,0(a5)
    return o;
    80015548:	fe843783          	ld	a5,-24(s0)
}
    8001554c:	853e                	mv	a0,a5
    8001554e:	7422                	ld	s0,40(sp)
    80015550:	6145                	addi	sp,sp,48
    80015552:	8082                	ret

0000000080015554 <strncpy>:

char *strncpy(char *dest, const char *s, int n)
{
    80015554:	7139                	addi	sp,sp,-64
    80015556:	fc22                	sd	s0,56(sp)
    80015558:	0080                	addi	s0,sp,64
    8001555a:	fca43c23          	sd	a0,-40(s0)
    8001555e:	fcb43823          	sd	a1,-48(s0)
    80015562:	87b2                	mv	a5,a2
    80015564:	fcf42623          	sw	a5,-52(s0)
    char *o = dest;
    80015568:	fd843783          	ld	a5,-40(s0)
    8001556c:	fef43423          	sd	a5,-24(s0)
    while (*s && n-- > 0) {
    80015570:	a00d                	j	80015592 <strncpy+0x3e>
        *dest++ = *s++;
    80015572:	fd043703          	ld	a4,-48(s0)
    80015576:	00170793          	addi	a5,a4,1
    8001557a:	fcf43823          	sd	a5,-48(s0)
    8001557e:	fd843783          	ld	a5,-40(s0)
    80015582:	00178693          	addi	a3,a5,1
    80015586:	fcd43c23          	sd	a3,-40(s0)
    8001558a:	00074703          	lbu	a4,0(a4)
    8001558e:	00e78023          	sb	a4,0(a5)
    while (*s && n-- > 0) {
    80015592:	fd043783          	ld	a5,-48(s0)
    80015596:	0007c783          	lbu	a5,0(a5)
    8001559a:	cb89                	beqz	a5,800155ac <strncpy+0x58>
    8001559c:	fcc42783          	lw	a5,-52(s0)
    800155a0:	fff7871b          	addiw	a4,a5,-1
    800155a4:	fce42623          	sw	a4,-52(s0)
    800155a8:	fcf045e3          	bgtz	a5,80015572 <strncpy+0x1e>
    }
    *dest = '\0';
    800155ac:	fd843783          	ld	a5,-40(s0)
    800155b0:	00078023          	sb	zero,0(a5)
    return o;
    800155b4:	fe843783          	ld	a5,-24(s0)
}
    800155b8:	853e                	mv	a0,a5
    800155ba:	7462                	ld	s0,56(sp)
    800155bc:	6121                	addi	sp,sp,64
    800155be:	8082                	ret

00000000800155c0 <strdup>:


char *strdup(const char *src)
{
    800155c0:	7179                	addi	sp,sp,-48
    800155c2:	f406                	sd	ra,40(sp)
    800155c4:	f022                	sd	s0,32(sp)
    800155c6:	1800                	addi	s0,sp,48
    800155c8:	fca43c23          	sd	a0,-40(s0)
    int len   = strlen(src);
    800155cc:	fd843503          	ld	a0,-40(s0)
    800155d0:	ef1ff0ef          	jal	ra,800154c0 <strlen>
    800155d4:	87aa                	mv	a5,a0
    800155d6:	fef42623          	sw	a5,-20(s0)
    char *ret = (char *)g_kmalloc(len + 1);
    800155da:	fec42783          	lw	a5,-20(s0)
    800155de:	2785                	addiw	a5,a5,1
    800155e0:	2781                	sext.w	a5,a5
    800155e2:	853e                	mv	a0,a5
    800155e4:	47f000ef          	jal	ra,80016262 <g_kmalloc>
    800155e8:	fea43023          	sd	a0,-32(s0)
    if (!ret) {
    800155ec:	fe043783          	ld	a5,-32(s0)
    800155f0:	e399                	bnez	a5,800155f6 <strdup+0x36>
        return NULL;
    800155f2:	4781                	li	a5,0
    800155f4:	a801                	j	80015604 <strdup+0x44>
    }
    return strcpy(ret, src);
    800155f6:	fd843583          	ld	a1,-40(s0)
    800155fa:	fe043503          	ld	a0,-32(s0)
    800155fe:	f01ff0ef          	jal	ra,800154fe <strcpy>
    80015602:	87aa                	mv	a5,a0
}
    80015604:	853e                	mv	a0,a5
    80015606:	70a2                	ld	ra,40(sp)
    80015608:	7402                	ld	s0,32(sp)
    8001560a:	6145                	addi	sp,sp,48
    8001560c:	8082                	ret

000000008001560e <strstartswith>:

bool strstartswith(const char *src, const char *start)
{
    8001560e:	7179                	addi	sp,sp,-48
    80015610:	f406                	sd	ra,40(sp)
    80015612:	f022                	sd	s0,32(sp)
    80015614:	1800                	addi	s0,sp,48
    80015616:	fca43c23          	sd	a0,-40(s0)
    8001561a:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    8001561e:	fd843503          	ld	a0,-40(s0)
    80015622:	e9fff0ef          	jal	ra,800154c0 <strlen>
    80015626:	87aa                	mv	a5,a0
    80015628:	fef42423          	sw	a5,-24(s0)
    int start_len = strlen(start);
    8001562c:	fd043503          	ld	a0,-48(s0)
    80015630:	e91ff0ef          	jal	ra,800154c0 <strlen>
    80015634:	87aa                	mv	a5,a0
    80015636:	fef42223          	sw	a5,-28(s0)
    int i;
    
    if (src_len < start_len) {
    8001563a:	fe842703          	lw	a4,-24(s0)
    8001563e:	fe442783          	lw	a5,-28(s0)
    80015642:	2701                	sext.w	a4,a4
    80015644:	2781                	sext.w	a5,a5
    80015646:	00f75463          	bge	a4,a5,8001564e <strstartswith+0x40>
        return false;
    8001564a:	4781                	li	a5,0
    8001564c:	a0a9                	j	80015696 <strstartswith+0x88>
    }

    for (i = 0;i < start_len;i++) {
    8001564e:	fe042623          	sw	zero,-20(s0)
    80015652:	a80d                	j	80015684 <strstartswith+0x76>
        if (src[i] != start[i]) {
    80015654:	fec42783          	lw	a5,-20(s0)
    80015658:	fd843703          	ld	a4,-40(s0)
    8001565c:	97ba                	add	a5,a5,a4
    8001565e:	0007c683          	lbu	a3,0(a5)
    80015662:	fec42783          	lw	a5,-20(s0)
    80015666:	fd043703          	ld	a4,-48(s0)
    8001566a:	97ba                	add	a5,a5,a4
    8001566c:	0007c783          	lbu	a5,0(a5)
    80015670:	8736                	mv	a4,a3
    80015672:	00f70463          	beq	a4,a5,8001567a <strstartswith+0x6c>
            return false;
    80015676:	4781                	li	a5,0
    80015678:	a839                	j	80015696 <strstartswith+0x88>
    for (i = 0;i < start_len;i++) {
    8001567a:	fec42783          	lw	a5,-20(s0)
    8001567e:	2785                	addiw	a5,a5,1
    80015680:	fef42623          	sw	a5,-20(s0)
    80015684:	fec42703          	lw	a4,-20(s0)
    80015688:	fe442783          	lw	a5,-28(s0)
    8001568c:	2701                	sext.w	a4,a4
    8001568e:	2781                	sext.w	a5,a5
    80015690:	fcf742e3          	blt	a4,a5,80015654 <strstartswith+0x46>
        }
    }

    return true;
    80015694:	4785                	li	a5,1
}
    80015696:	853e                	mv	a0,a5
    80015698:	70a2                	ld	ra,40(sp)
    8001569a:	7402                	ld	s0,32(sp)
    8001569c:	6145                	addi	sp,sp,48
    8001569e:	8082                	ret

00000000800156a0 <strendswith>:

bool strendswith(const char *src, const char *end)
{
    800156a0:	7179                	addi	sp,sp,-48
    800156a2:	f406                	sd	ra,40(sp)
    800156a4:	f022                	sd	s0,32(sp)
    800156a6:	1800                	addi	s0,sp,48
    800156a8:	fca43c23          	sd	a0,-40(s0)
    800156ac:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    800156b0:	fd843503          	ld	a0,-40(s0)
    800156b4:	e0dff0ef          	jal	ra,800154c0 <strlen>
    800156b8:	87aa                	mv	a5,a0
    800156ba:	fef42423          	sw	a5,-24(s0)
    int end_len = strlen(end);
    800156be:	fd043503          	ld	a0,-48(s0)
    800156c2:	dffff0ef          	jal	ra,800154c0 <strlen>
    800156c6:	87aa                	mv	a5,a0
    800156c8:	fef42223          	sw	a5,-28(s0)
    int cmp = src_len - end_len;
    800156cc:	fe842703          	lw	a4,-24(s0)
    800156d0:	fe442783          	lw	a5,-28(s0)
    800156d4:	40f707bb          	subw	a5,a4,a5
    800156d8:	fef42023          	sw	a5,-32(s0)
    int i;
    
    if (src_len < end_len) {
    800156dc:	fe842703          	lw	a4,-24(s0)
    800156e0:	fe442783          	lw	a5,-28(s0)
    800156e4:	2701                	sext.w	a4,a4
    800156e6:	2781                	sext.w	a5,a5
    800156e8:	00f75463          	bge	a4,a5,800156f0 <strendswith+0x50>
        return false;
    800156ec:	4781                	li	a5,0
    800156ee:	a891                	j	80015742 <strendswith+0xa2>
    }

    for (i = 0;i < end_len;i++) {
    800156f0:	fe042623          	sw	zero,-20(s0)
    800156f4:	a835                	j	80015730 <strendswith+0x90>
        if (src[i + cmp] != end[i]) {
    800156f6:	fec42703          	lw	a4,-20(s0)
    800156fa:	fe042783          	lw	a5,-32(s0)
    800156fe:	9fb9                	addw	a5,a5,a4
    80015700:	2781                	sext.w	a5,a5
    80015702:	873e                	mv	a4,a5
    80015704:	fd843783          	ld	a5,-40(s0)
    80015708:	97ba                	add	a5,a5,a4
    8001570a:	0007c683          	lbu	a3,0(a5)
    8001570e:	fec42783          	lw	a5,-20(s0)
    80015712:	fd043703          	ld	a4,-48(s0)
    80015716:	97ba                	add	a5,a5,a4
    80015718:	0007c783          	lbu	a5,0(a5)
    8001571c:	8736                	mv	a4,a3
    8001571e:	00f70463          	beq	a4,a5,80015726 <strendswith+0x86>
            return false;
    80015722:	4781                	li	a5,0
    80015724:	a839                	j	80015742 <strendswith+0xa2>
    for (i = 0;i < end_len;i++) {
    80015726:	fec42783          	lw	a5,-20(s0)
    8001572a:	2785                	addiw	a5,a5,1
    8001572c:	fef42623          	sw	a5,-20(s0)
    80015730:	fec42703          	lw	a4,-20(s0)
    80015734:	fe442783          	lw	a5,-28(s0)
    80015738:	2701                	sext.w	a4,a4
    8001573a:	2781                	sext.w	a5,a5
    8001573c:	faf74de3          	blt	a4,a5,800156f6 <strendswith+0x56>
        }
    }

    return true;    
    80015740:	4785                	li	a5,1
}
    80015742:	853e                	mv	a0,a5
    80015744:	70a2                	ld	ra,40(sp)
    80015746:	7402                	ld	s0,32(sp)
    80015748:	6145                	addi	sp,sp,48
    8001574a:	8082                	ret

000000008001574c <vector_init>:
    uint32_t size;
    uint32_t capacity;
    uint64_t *values;
} Vector;

static Vector *vector_init(Vector *vec) {
    8001574c:	1101                	addi	sp,sp,-32
    8001574e:	ec22                	sd	s0,24(sp)
    80015750:	1000                	addi	s0,sp,32
    80015752:	fea43423          	sd	a0,-24(s0)
    if (vec == NULL) {
    80015756:	fe843783          	ld	a5,-24(s0)
    8001575a:	e399                	bnez	a5,80015760 <vector_init+0x14>
        return NULL;
    8001575c:	4781                	li	a5,0
    8001575e:	a839                	j	8001577c <vector_init+0x30>
    }
    vec->size = 0;
    80015760:	fe843783          	ld	a5,-24(s0)
    80015764:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    80015768:	fe843783          	ld	a5,-24(s0)
    8001576c:	0007a223          	sw	zero,4(a5)
    vec->values = NULL;
    80015770:	fe843783          	ld	a5,-24(s0)
    80015774:	0007b423          	sd	zero,8(a5)
    return vec;
    80015778:	fe843783          	ld	a5,-24(s0)
}
    8001577c:	853e                	mv	a0,a5
    8001577e:	6462                	ld	s0,24(sp)
    80015780:	6105                	addi	sp,sp,32
    80015782:	8082                	ret

0000000080015784 <vector_new>:

Vector *vector_new(void) {
    80015784:	1141                	addi	sp,sp,-16
    80015786:	e406                	sd	ra,8(sp)
    80015788:	e022                	sd	s0,0(sp)
    8001578a:	0800                	addi	s0,sp,16
    return vector_init((Vector *)g_kmalloc(sizeof(Vector)));
    8001578c:	4541                	li	a0,16
    8001578e:	2d5000ef          	jal	ra,80016262 <g_kmalloc>
    80015792:	87aa                	mv	a5,a0
    80015794:	853e                	mv	a0,a5
    80015796:	fb7ff0ef          	jal	ra,8001574c <vector_init>
    8001579a:	87aa                	mv	a5,a0
}
    8001579c:	853e                	mv	a0,a5
    8001579e:	60a2                	ld	ra,8(sp)
    800157a0:	6402                	ld	s0,0(sp)
    800157a2:	0141                	addi	sp,sp,16
    800157a4:	8082                	ret

00000000800157a6 <vector_init_with_capacity>:

static Vector *vector_init_with_capacity(Vector *vec, uint32_t capacity) {
    800157a6:	1101                	addi	sp,sp,-32
    800157a8:	ec06                	sd	ra,24(sp)
    800157aa:	e822                	sd	s0,16(sp)
    800157ac:	1000                	addi	s0,sp,32
    800157ae:	fea43423          	sd	a0,-24(s0)
    800157b2:	87ae                	mv	a5,a1
    800157b4:	fef42223          	sw	a5,-28(s0)
    if (vec == NULL) {
    800157b8:	fe843783          	ld	a5,-24(s0)
    800157bc:	e399                	bnez	a5,800157c2 <vector_init_with_capacity+0x1c>
        return NULL;
    800157be:	4781                	li	a5,0
    800157c0:	a035                	j	800157ec <vector_init_with_capacity+0x46>
    }
    vec->size = 0;
    800157c2:	fe843783          	ld	a5,-24(s0)
    800157c6:	0007a023          	sw	zero,0(a5)
    vec->capacity = capacity;
    800157ca:	fe843783          	ld	a5,-24(s0)
    800157ce:	fe442703          	lw	a4,-28(s0)
    800157d2:	c3d8                	sw	a4,4(a5)
    vec->values = (uint64_t *)g_kcalloc(capacity, sizeof(uint64_t));
    800157d4:	fe446783          	lwu	a5,-28(s0)
    800157d8:	45a1                	li	a1,8
    800157da:	853e                	mv	a0,a5
    800157dc:	2bf000ef          	jal	ra,8001629a <g_kcalloc>
    800157e0:	872a                	mv	a4,a0
    800157e2:	fe843783          	ld	a5,-24(s0)
    800157e6:	e798                	sd	a4,8(a5)
    return vec;
    800157e8:	fe843783          	ld	a5,-24(s0)
}
    800157ec:	853e                	mv	a0,a5
    800157ee:	60e2                	ld	ra,24(sp)
    800157f0:	6442                	ld	s0,16(sp)
    800157f2:	6105                	addi	sp,sp,32
    800157f4:	8082                	ret

00000000800157f6 <vector_new_with_capacity>:

Vector *vector_new_with_capacity(uint32_t capacity) {
    800157f6:	1101                	addi	sp,sp,-32
    800157f8:	ec06                	sd	ra,24(sp)
    800157fa:	e822                	sd	s0,16(sp)
    800157fc:	1000                	addi	s0,sp,32
    800157fe:	87aa                	mv	a5,a0
    80015800:	fef42623          	sw	a5,-20(s0)
    return vector_init_with_capacity((Vector *)g_kmalloc(sizeof(Vector)), capacity);
    80015804:	4541                	li	a0,16
    80015806:	25d000ef          	jal	ra,80016262 <g_kmalloc>
    8001580a:	872a                	mv	a4,a0
    8001580c:	fec42783          	lw	a5,-20(s0)
    80015810:	85be                	mv	a1,a5
    80015812:	853a                	mv	a0,a4
    80015814:	f93ff0ef          	jal	ra,800157a6 <vector_init_with_capacity>
    80015818:	87aa                	mv	a5,a0
}
    8001581a:	853e                	mv	a0,a5
    8001581c:	60e2                	ld	ra,24(sp)
    8001581e:	6442                	ld	s0,16(sp)
    80015820:	6105                	addi	sp,sp,32
    80015822:	8082                	ret

0000000080015824 <vector_push>:

void vector_push(Vector *vec, uint64_t value) {
    80015824:	1101                	addi	sp,sp,-32
    80015826:	ec06                	sd	ra,24(sp)
    80015828:	e822                	sd	s0,16(sp)
    8001582a:	1000                	addi	s0,sp,32
    8001582c:	fea43423          	sd	a0,-24(s0)
    80015830:	feb43023          	sd	a1,-32(s0)
    vector_insert(vec, vec->size, value);
    80015834:	fe843783          	ld	a5,-24(s0)
    80015838:	439c                	lw	a5,0(a5)
    8001583a:	fe043603          	ld	a2,-32(s0)
    8001583e:	85be                	mv	a1,a5
    80015840:	fe843503          	ld	a0,-24(s0)
    80015844:	00e000ef          	jal	ra,80015852 <vector_insert>
}
    80015848:	0001                	nop
    8001584a:	60e2                	ld	ra,24(sp)
    8001584c:	6442                	ld	s0,16(sp)
    8001584e:	6105                	addi	sp,sp,32
    80015850:	8082                	ret

0000000080015852 <vector_insert>:

void vector_insert(Vector *vec, uint32_t idx, uint64_t value) {
    80015852:	7139                	addi	sp,sp,-64
    80015854:	fc06                	sd	ra,56(sp)
    80015856:	f822                	sd	s0,48(sp)
    80015858:	0080                	addi	s0,sp,64
    8001585a:	fca43c23          	sd	a0,-40(s0)
    8001585e:	87ae                	mv	a5,a1
    80015860:	fcc43423          	sd	a2,-56(s0)
    80015864:	fcf42a23          	sw	a5,-44(s0)
    uint32_t i;
    vector_resize(vec, vec->size + 1);
    80015868:	fd843783          	ld	a5,-40(s0)
    8001586c:	439c                	lw	a5,0(a5)
    8001586e:	2785                	addiw	a5,a5,1
    80015870:	2781                	sext.w	a5,a5
    80015872:	85be                	mv	a1,a5
    80015874:	fd843503          	ld	a0,-40(s0)
    80015878:	214000ef          	jal	ra,80015a8c <vector_resize>
    for (i = vec->size - 1;i > idx;i--) {
    8001587c:	fd843783          	ld	a5,-40(s0)
    80015880:	439c                	lw	a5,0(a5)
    80015882:	37fd                	addiw	a5,a5,-1
    80015884:	fef42623          	sw	a5,-20(s0)
    80015888:	a805                	j	800158b8 <vector_insert+0x66>
        vector_set(vec, i, vector_get_unchecked(vec, i - 1));
    8001588a:	fec42783          	lw	a5,-20(s0)
    8001588e:	37fd                	addiw	a5,a5,-1
    80015890:	2781                	sext.w	a5,a5
    80015892:	85be                	mv	a1,a5
    80015894:	fd843503          	ld	a0,-40(s0)
    80015898:	13a000ef          	jal	ra,800159d2 <vector_get_unchecked>
    8001589c:	872a                	mv	a4,a0
    8001589e:	fec42783          	lw	a5,-20(s0)
    800158a2:	863a                	mv	a2,a4
    800158a4:	85be                	mv	a1,a5
    800158a6:	fd843503          	ld	a0,-40(s0)
    800158aa:	094000ef          	jal	ra,8001593e <vector_set>
    for (i = vec->size - 1;i > idx;i--) {
    800158ae:	fec42783          	lw	a5,-20(s0)
    800158b2:	37fd                	addiw	a5,a5,-1
    800158b4:	fef42623          	sw	a5,-20(s0)
    800158b8:	fec42703          	lw	a4,-20(s0)
    800158bc:	fd442783          	lw	a5,-44(s0)
    800158c0:	2701                	sext.w	a4,a4
    800158c2:	2781                	sext.w	a5,a5
    800158c4:	fce7e3e3          	bltu	a5,a4,8001588a <vector_insert+0x38>
    }
    vector_set(vec, idx, value);
    800158c8:	fd442783          	lw	a5,-44(s0)
    800158cc:	fc843603          	ld	a2,-56(s0)
    800158d0:	85be                	mv	a1,a5
    800158d2:	fd843503          	ld	a0,-40(s0)
    800158d6:	068000ef          	jal	ra,8001593e <vector_set>
}
    800158da:	0001                	nop
    800158dc:	70e2                	ld	ra,56(sp)
    800158de:	7442                	ld	s0,48(sp)
    800158e0:	6121                	addi	sp,sp,64
    800158e2:	8082                	ret

00000000800158e4 <vector_find>:

int vector_find(Vector *vec, uint64_t val) {
    800158e4:	7179                	addi	sp,sp,-48
    800158e6:	f422                	sd	s0,40(sp)
    800158e8:	1800                	addi	s0,sp,48
    800158ea:	fca43c23          	sd	a0,-40(s0)
    800158ee:	fcb43823          	sd	a1,-48(s0)
    int i;
    for (i = 0;i < (int)vec->size;i++) {
    800158f2:	fe042623          	sw	zero,-20(s0)
    800158f6:	a02d                	j	80015920 <vector_find+0x3c>
        if (vec->values[i] == val) {
    800158f8:	fd843783          	ld	a5,-40(s0)
    800158fc:	6798                	ld	a4,8(a5)
    800158fe:	fec42783          	lw	a5,-20(s0)
    80015902:	078e                	slli	a5,a5,0x3
    80015904:	97ba                	add	a5,a5,a4
    80015906:	639c                	ld	a5,0(a5)
    80015908:	fd043703          	ld	a4,-48(s0)
    8001590c:	00f71563          	bne	a4,a5,80015916 <vector_find+0x32>
            return i;
    80015910:	fec42783          	lw	a5,-20(s0)
    80015914:	a00d                	j	80015936 <vector_find+0x52>
    for (i = 0;i < (int)vec->size;i++) {
    80015916:	fec42783          	lw	a5,-20(s0)
    8001591a:	2785                	addiw	a5,a5,1
    8001591c:	fef42623          	sw	a5,-20(s0)
    80015920:	fd843783          	ld	a5,-40(s0)
    80015924:	439c                	lw	a5,0(a5)
    80015926:	0007871b          	sext.w	a4,a5
    8001592a:	fec42783          	lw	a5,-20(s0)
    8001592e:	2781                	sext.w	a5,a5
    80015930:	fce7c4e3          	blt	a5,a4,800158f8 <vector_find+0x14>
        }
    }
    return -1;
    80015934:	57fd                	li	a5,-1
}
    80015936:	853e                	mv	a0,a5
    80015938:	7422                	ld	s0,40(sp)
    8001593a:	6145                	addi	sp,sp,48
    8001593c:	8082                	ret

000000008001593e <vector_set>:

bool vector_set(Vector *vec, uint32_t idx, uint64_t val) {
    8001593e:	7179                	addi	sp,sp,-48
    80015940:	f422                	sd	s0,40(sp)
    80015942:	1800                	addi	s0,sp,48
    80015944:	fea43423          	sd	a0,-24(s0)
    80015948:	87ae                	mv	a5,a1
    8001594a:	fcc43c23          	sd	a2,-40(s0)
    8001594e:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80015952:	fe843783          	ld	a5,-24(s0)
    80015956:	4398                	lw	a4,0(a5)
    80015958:	fe442783          	lw	a5,-28(s0)
    8001595c:	2781                	sext.w	a5,a5
    8001595e:	00e7e463          	bltu	a5,a4,80015966 <vector_set+0x28>
        return false;
    80015962:	4781                	li	a5,0
    80015964:	a821                	j	8001597c <vector_set+0x3e>
    }
    vec->values[idx] = val;
    80015966:	fe843783          	ld	a5,-24(s0)
    8001596a:	6798                	ld	a4,8(a5)
    8001596c:	fe446783          	lwu	a5,-28(s0)
    80015970:	078e                	slli	a5,a5,0x3
    80015972:	97ba                	add	a5,a5,a4
    80015974:	fd843703          	ld	a4,-40(s0)
    80015978:	e398                	sd	a4,0(a5)
    return true;
    8001597a:	4785                	li	a5,1
}
    8001597c:	853e                	mv	a0,a5
    8001597e:	7422                	ld	s0,40(sp)
    80015980:	6145                	addi	sp,sp,48
    80015982:	8082                	ret

0000000080015984 <vector_get>:

bool vector_get(Vector *vec, uint32_t idx, uint64_t *val) {
    80015984:	7179                	addi	sp,sp,-48
    80015986:	f422                	sd	s0,40(sp)
    80015988:	1800                	addi	s0,sp,48
    8001598a:	fea43423          	sd	a0,-24(s0)
    8001598e:	87ae                	mv	a5,a1
    80015990:	fcc43c23          	sd	a2,-40(s0)
    80015994:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80015998:	fe843783          	ld	a5,-24(s0)
    8001599c:	4398                	lw	a4,0(a5)
    8001599e:	fe442783          	lw	a5,-28(s0)
    800159a2:	2781                	sext.w	a5,a5
    800159a4:	00e7e463          	bltu	a5,a4,800159ac <vector_get+0x28>
        return false;
    800159a8:	4781                	li	a5,0
    800159aa:	a005                	j	800159ca <vector_get+0x46>
    }
    if (val != NULL) {
    800159ac:	fd843783          	ld	a5,-40(s0)
    800159b0:	cf81                	beqz	a5,800159c8 <vector_get+0x44>
        *val = vec->values[idx];
    800159b2:	fe843783          	ld	a5,-24(s0)
    800159b6:	6798                	ld	a4,8(a5)
    800159b8:	fe446783          	lwu	a5,-28(s0)
    800159bc:	078e                	slli	a5,a5,0x3
    800159be:	97ba                	add	a5,a5,a4
    800159c0:	6398                	ld	a4,0(a5)
    800159c2:	fd843783          	ld	a5,-40(s0)
    800159c6:	e398                	sd	a4,0(a5)
    }
    return true;
    800159c8:	4785                	li	a5,1
}
    800159ca:	853e                	mv	a0,a5
    800159cc:	7422                	ld	s0,40(sp)
    800159ce:	6145                	addi	sp,sp,48
    800159d0:	8082                	ret

00000000800159d2 <vector_get_unchecked>:

uint64_t vector_get_unchecked(Vector *vec, uint32_t idx) {
    800159d2:	1101                	addi	sp,sp,-32
    800159d4:	ec22                	sd	s0,24(sp)
    800159d6:	1000                	addi	s0,sp,32
    800159d8:	fea43423          	sd	a0,-24(s0)
    800159dc:	87ae                	mv	a5,a1
    800159de:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    800159e2:	fe843783          	ld	a5,-24(s0)
    800159e6:	4398                	lw	a4,0(a5)
    800159e8:	fe442783          	lw	a5,-28(s0)
    800159ec:	2781                	sext.w	a5,a5
    800159ee:	00e7e463          	bltu	a5,a4,800159f6 <vector_get_unchecked+0x24>
        return 0;
    800159f2:	4781                	li	a5,0
    800159f4:	a809                	j	80015a06 <vector_get_unchecked+0x34>
    }
    return vec->values[idx];
    800159f6:	fe843783          	ld	a5,-24(s0)
    800159fa:	6798                	ld	a4,8(a5)
    800159fc:	fe446783          	lwu	a5,-28(s0)
    80015a00:	078e                	slli	a5,a5,0x3
    80015a02:	97ba                	add	a5,a5,a4
    80015a04:	639c                	ld	a5,0(a5)
}
    80015a06:	853e                	mv	a0,a5
    80015a08:	6462                	ld	s0,24(sp)
    80015a0a:	6105                	addi	sp,sp,32
    80015a0c:	8082                	ret

0000000080015a0e <vector_resize_with_default>:


void vector_resize_with_default(Vector *vec, uint32_t new_size, uint64_t def) {
    80015a0e:	7139                	addi	sp,sp,-64
    80015a10:	fc06                	sd	ra,56(sp)
    80015a12:	f822                	sd	s0,48(sp)
    80015a14:	0080                	addi	s0,sp,64
    80015a16:	fca43c23          	sd	a0,-40(s0)
    80015a1a:	87ae                	mv	a5,a1
    80015a1c:	fcc43423          	sd	a2,-56(s0)
    80015a20:	fcf42a23          	sw	a5,-44(s0)
    uint32_t old_size = vec->size;
    80015a24:	fd843783          	ld	a5,-40(s0)
    80015a28:	439c                	lw	a5,0(a5)
    80015a2a:	fef42423          	sw	a5,-24(s0)
    vector_resize(vec, new_size);
    80015a2e:	fd442783          	lw	a5,-44(s0)
    80015a32:	85be                	mv	a1,a5
    80015a34:	fd843503          	ld	a0,-40(s0)
    80015a38:	054000ef          	jal	ra,80015a8c <vector_resize>
    if (old_size < new_size) {
    80015a3c:	fe842703          	lw	a4,-24(s0)
    80015a40:	fd442783          	lw	a5,-44(s0)
    80015a44:	2701                	sext.w	a4,a4
    80015a46:	2781                	sext.w	a5,a5
    80015a48:	02f77d63          	bgeu	a4,a5,80015a82 <vector_resize_with_default+0x74>
        uint32_t i;
        for (i = old_size;i < new_size;i++) {
    80015a4c:	fe842783          	lw	a5,-24(s0)
    80015a50:	fef42623          	sw	a5,-20(s0)
    80015a54:	a839                	j	80015a72 <vector_resize_with_default+0x64>
            vector_set(vec, i, def);
    80015a56:	fec42783          	lw	a5,-20(s0)
    80015a5a:	fc843603          	ld	a2,-56(s0)
    80015a5e:	85be                	mv	a1,a5
    80015a60:	fd843503          	ld	a0,-40(s0)
    80015a64:	edbff0ef          	jal	ra,8001593e <vector_set>
        for (i = old_size;i < new_size;i++) {
    80015a68:	fec42783          	lw	a5,-20(s0)
    80015a6c:	2785                	addiw	a5,a5,1
    80015a6e:	fef42623          	sw	a5,-20(s0)
    80015a72:	fec42703          	lw	a4,-20(s0)
    80015a76:	fd442783          	lw	a5,-44(s0)
    80015a7a:	2701                	sext.w	a4,a4
    80015a7c:	2781                	sext.w	a5,a5
    80015a7e:	fcf76ce3          	bltu	a4,a5,80015a56 <vector_resize_with_default+0x48>
        }
    }
}
    80015a82:	0001                	nop
    80015a84:	70e2                	ld	ra,56(sp)
    80015a86:	7442                	ld	s0,48(sp)
    80015a88:	6121                	addi	sp,sp,64
    80015a8a:	8082                	ret

0000000080015a8c <vector_resize>:

void vector_resize(Vector *vec, uint32_t new_size) {
    80015a8c:	7179                	addi	sp,sp,-48
    80015a8e:	f406                	sd	ra,40(sp)
    80015a90:	f022                	sd	s0,32(sp)
    80015a92:	1800                	addi	s0,sp,48
    80015a94:	fca43c23          	sd	a0,-40(s0)
    80015a98:	87ae                	mv	a5,a1
    80015a9a:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_size > vec->capacity) {
    80015a9e:	fd843783          	ld	a5,-40(s0)
    80015aa2:	43d8                	lw	a4,4(a5)
    80015aa4:	fd442783          	lw	a5,-44(s0)
    80015aa8:	2781                	sext.w	a5,a5
    80015aaa:	06f77963          	bgeu	a4,a5,80015b1c <vector_resize+0x90>
        vals = (uint64_t *)g_kcalloc(new_size, sizeof(uint64_t));
    80015aae:	fd446783          	lwu	a5,-44(s0)
    80015ab2:	45a1                	li	a1,8
    80015ab4:	853e                	mv	a0,a5
    80015ab6:	7e4000ef          	jal	ra,8001629a <g_kcalloc>
    80015aba:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    80015abe:	fe042623          	sw	zero,-20(s0)
    80015ac2:	a02d                	j	80015aec <vector_resize+0x60>
            vals[i] = vec->values[i];
    80015ac4:	fd843783          	ld	a5,-40(s0)
    80015ac8:	6798                	ld	a4,8(a5)
    80015aca:	fec46783          	lwu	a5,-20(s0)
    80015ace:	078e                	slli	a5,a5,0x3
    80015ad0:	973e                	add	a4,a4,a5
    80015ad2:	fec46783          	lwu	a5,-20(s0)
    80015ad6:	078e                	slli	a5,a5,0x3
    80015ad8:	fe043683          	ld	a3,-32(s0)
    80015adc:	97b6                	add	a5,a5,a3
    80015ade:	6318                	ld	a4,0(a4)
    80015ae0:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80015ae2:	fec42783          	lw	a5,-20(s0)
    80015ae6:	2785                	addiw	a5,a5,1
    80015ae8:	fef42623          	sw	a5,-20(s0)
    80015aec:	fd843783          	ld	a5,-40(s0)
    80015af0:	4398                	lw	a4,0(a5)
    80015af2:	fec42783          	lw	a5,-20(s0)
    80015af6:	2781                	sext.w	a5,a5
    80015af8:	fce7e6e3          	bltu	a5,a4,80015ac4 <vector_resize+0x38>
        }
        g_kfree(vec->values);
    80015afc:	fd843783          	ld	a5,-40(s0)
    80015b00:	679c                	ld	a5,8(a5)
    80015b02:	853e                	mv	a0,a5
    80015b04:	7f8000ef          	jal	ra,800162fc <g_kfree>
        vec->values = vals;
    80015b08:	fd843783          	ld	a5,-40(s0)
    80015b0c:	fe043703          	ld	a4,-32(s0)
    80015b10:	e798                	sd	a4,8(a5)
        vec->capacity = new_size;
    80015b12:	fd843783          	ld	a5,-40(s0)
    80015b16:	fd442703          	lw	a4,-44(s0)
    80015b1a:	c3d8                	sw	a4,4(a5)
    }        
    vec->size = new_size;    
    80015b1c:	fd843783          	ld	a5,-40(s0)
    80015b20:	fd442703          	lw	a4,-44(s0)
    80015b24:	c398                	sw	a4,0(a5)
}
    80015b26:	0001                	nop
    80015b28:	70a2                	ld	ra,40(sp)
    80015b2a:	7402                	ld	s0,32(sp)
    80015b2c:	6145                	addi	sp,sp,48
    80015b2e:	8082                	ret

0000000080015b30 <vector_reserve>:

void vector_reserve(Vector *vec, uint32_t new_capacity) {
    80015b30:	7179                	addi	sp,sp,-48
    80015b32:	f406                	sd	ra,40(sp)
    80015b34:	f022                	sd	s0,32(sp)
    80015b36:	1800                	addi	s0,sp,48
    80015b38:	fca43c23          	sd	a0,-40(s0)
    80015b3c:	87ae                	mv	a5,a1
    80015b3e:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_capacity > vec->capacity) {
    80015b42:	fd843783          	ld	a5,-40(s0)
    80015b46:	43d8                	lw	a4,4(a5)
    80015b48:	fd442783          	lw	a5,-44(s0)
    80015b4c:	2781                	sext.w	a5,a5
    80015b4e:	06f77a63          	bgeu	a4,a5,80015bc2 <vector_reserve+0x92>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    80015b52:	fd446783          	lwu	a5,-44(s0)
    80015b56:	45a1                	li	a1,8
    80015b58:	853e                	mv	a0,a5
    80015b5a:	740000ef          	jal	ra,8001629a <g_kcalloc>
    80015b5e:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    80015b62:	fe042623          	sw	zero,-20(s0)
    80015b66:	a02d                	j	80015b90 <vector_reserve+0x60>
            vals[i] = vec->values[i];
    80015b68:	fd843783          	ld	a5,-40(s0)
    80015b6c:	6798                	ld	a4,8(a5)
    80015b6e:	fec46783          	lwu	a5,-20(s0)
    80015b72:	078e                	slli	a5,a5,0x3
    80015b74:	973e                	add	a4,a4,a5
    80015b76:	fec46783          	lwu	a5,-20(s0)
    80015b7a:	078e                	slli	a5,a5,0x3
    80015b7c:	fe043683          	ld	a3,-32(s0)
    80015b80:	97b6                	add	a5,a5,a3
    80015b82:	6318                	ld	a4,0(a4)
    80015b84:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80015b86:	fec42783          	lw	a5,-20(s0)
    80015b8a:	2785                	addiw	a5,a5,1
    80015b8c:	fef42623          	sw	a5,-20(s0)
    80015b90:	fd843783          	ld	a5,-40(s0)
    80015b94:	4398                	lw	a4,0(a5)
    80015b96:	fec42783          	lw	a5,-20(s0)
    80015b9a:	2781                	sext.w	a5,a5
    80015b9c:	fce7e6e3          	bltu	a5,a4,80015b68 <vector_reserve+0x38>
        }
        g_kfree(vec->values);
    80015ba0:	fd843783          	ld	a5,-40(s0)
    80015ba4:	679c                	ld	a5,8(a5)
    80015ba6:	853e                	mv	a0,a5
    80015ba8:	754000ef          	jal	ra,800162fc <g_kfree>
        vec->values = vals;
    80015bac:	fd843783          	ld	a5,-40(s0)
    80015bb0:	fe043703          	ld	a4,-32(s0)
    80015bb4:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    80015bb6:	fd843783          	ld	a5,-40(s0)
    80015bba:	fd442703          	lw	a4,-44(s0)
    80015bbe:	c3d8                	sw	a4,4(a5)
        }
        g_kfree(vec->values);
        vec->values = vals;
        vec->capacity = new_capacity;
    }
}
    80015bc0:	a04d                	j	80015c62 <vector_reserve+0x132>
    else if (new_capacity > 0 && new_capacity < vec->capacity) {
    80015bc2:	fd442783          	lw	a5,-44(s0)
    80015bc6:	2781                	sext.w	a5,a5
    80015bc8:	cfc9                	beqz	a5,80015c62 <vector_reserve+0x132>
    80015bca:	fd843783          	ld	a5,-40(s0)
    80015bce:	43d8                	lw	a4,4(a5)
    80015bd0:	fd442783          	lw	a5,-44(s0)
    80015bd4:	2781                	sext.w	a5,a5
    80015bd6:	08e7f663          	bgeu	a5,a4,80015c62 <vector_reserve+0x132>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    80015bda:	fd446783          	lwu	a5,-44(s0)
    80015bde:	45a1                	li	a1,8
    80015be0:	853e                	mv	a0,a5
    80015be2:	6b8000ef          	jal	ra,8001629a <g_kcalloc>
    80015be6:	fea43023          	sd	a0,-32(s0)
        if (new_capacity < vec->size) {
    80015bea:	fd843783          	ld	a5,-40(s0)
    80015bee:	4398                	lw	a4,0(a5)
    80015bf0:	fd442783          	lw	a5,-44(s0)
    80015bf4:	2781                	sext.w	a5,a5
    80015bf6:	00e7f763          	bgeu	a5,a4,80015c04 <vector_reserve+0xd4>
            vec->size = new_capacity;
    80015bfa:	fd843783          	ld	a5,-40(s0)
    80015bfe:	fd442703          	lw	a4,-44(s0)
    80015c02:	c398                	sw	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80015c04:	fe042623          	sw	zero,-20(s0)
    80015c08:	a02d                	j	80015c32 <vector_reserve+0x102>
            vals[i] = vec->values[i];
    80015c0a:	fd843783          	ld	a5,-40(s0)
    80015c0e:	6798                	ld	a4,8(a5)
    80015c10:	fec46783          	lwu	a5,-20(s0)
    80015c14:	078e                	slli	a5,a5,0x3
    80015c16:	973e                	add	a4,a4,a5
    80015c18:	fec46783          	lwu	a5,-20(s0)
    80015c1c:	078e                	slli	a5,a5,0x3
    80015c1e:	fe043683          	ld	a3,-32(s0)
    80015c22:	97b6                	add	a5,a5,a3
    80015c24:	6318                	ld	a4,0(a4)
    80015c26:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80015c28:	fec42783          	lw	a5,-20(s0)
    80015c2c:	2785                	addiw	a5,a5,1
    80015c2e:	fef42623          	sw	a5,-20(s0)
    80015c32:	fd843783          	ld	a5,-40(s0)
    80015c36:	4398                	lw	a4,0(a5)
    80015c38:	fec42783          	lw	a5,-20(s0)
    80015c3c:	2781                	sext.w	a5,a5
    80015c3e:	fce7e6e3          	bltu	a5,a4,80015c0a <vector_reserve+0xda>
        g_kfree(vec->values);
    80015c42:	fd843783          	ld	a5,-40(s0)
    80015c46:	679c                	ld	a5,8(a5)
    80015c48:	853e                	mv	a0,a5
    80015c4a:	6b2000ef          	jal	ra,800162fc <g_kfree>
        vec->values = vals;
    80015c4e:	fd843783          	ld	a5,-40(s0)
    80015c52:	fe043703          	ld	a4,-32(s0)
    80015c56:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    80015c58:	fd843783          	ld	a5,-40(s0)
    80015c5c:	fd442703          	lw	a4,-44(s0)
    80015c60:	c3d8                	sw	a4,4(a5)
}
    80015c62:	0001                	nop
    80015c64:	70a2                	ld	ra,40(sp)
    80015c66:	7402                	ld	s0,32(sp)
    80015c68:	6145                	addi	sp,sp,48
    80015c6a:	8082                	ret

0000000080015c6c <vector_remove>:

bool vector_remove(Vector *vec, uint32_t idx) {
    80015c6c:	1101                	addi	sp,sp,-32
    80015c6e:	ec22                	sd	s0,24(sp)
    80015c70:	1000                	addi	s0,sp,32
    80015c72:	fea43423          	sd	a0,-24(s0)
    80015c76:	87ae                	mv	a5,a1
    80015c78:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80015c7c:	fe843783          	ld	a5,-24(s0)
    80015c80:	4398                	lw	a4,0(a5)
    80015c82:	fe442783          	lw	a5,-28(s0)
    80015c86:	2781                	sext.w	a5,a5
    80015c88:	00e7e463          	bltu	a5,a4,80015c90 <vector_remove+0x24>
        return false;
    80015c8c:	4781                	li	a5,0
    80015c8e:	a8a9                	j	80015ce8 <vector_remove+0x7c>
    }
    vec->size -= 1;
    80015c90:	fe843783          	ld	a5,-24(s0)
    80015c94:	439c                	lw	a5,0(a5)
    80015c96:	37fd                	addiw	a5,a5,-1
    80015c98:	0007871b          	sext.w	a4,a5
    80015c9c:	fe843783          	ld	a5,-24(s0)
    80015ca0:	c398                	sw	a4,0(a5)
    for (;idx < vec->size;idx++) {
    80015ca2:	a815                	j	80015cd6 <vector_remove+0x6a>
        vec->values[idx] = vec->values[idx + 1];
    80015ca4:	fe843783          	ld	a5,-24(s0)
    80015ca8:	6798                	ld	a4,8(a5)
    80015caa:	fe442783          	lw	a5,-28(s0)
    80015cae:	2785                	addiw	a5,a5,1
    80015cb0:	2781                	sext.w	a5,a5
    80015cb2:	1782                	slli	a5,a5,0x20
    80015cb4:	9381                	srli	a5,a5,0x20
    80015cb6:	078e                	slli	a5,a5,0x3
    80015cb8:	973e                	add	a4,a4,a5
    80015cba:	fe843783          	ld	a5,-24(s0)
    80015cbe:	6794                	ld	a3,8(a5)
    80015cc0:	fe446783          	lwu	a5,-28(s0)
    80015cc4:	078e                	slli	a5,a5,0x3
    80015cc6:	97b6                	add	a5,a5,a3
    80015cc8:	6318                	ld	a4,0(a4)
    80015cca:	e398                	sd	a4,0(a5)
    for (;idx < vec->size;idx++) {
    80015ccc:	fe442783          	lw	a5,-28(s0)
    80015cd0:	2785                	addiw	a5,a5,1
    80015cd2:	fef42223          	sw	a5,-28(s0)
    80015cd6:	fe843783          	ld	a5,-24(s0)
    80015cda:	4398                	lw	a4,0(a5)
    80015cdc:	fe442783          	lw	a5,-28(s0)
    80015ce0:	2781                	sext.w	a5,a5
    80015ce2:	fce7e1e3          	bltu	a5,a4,80015ca4 <vector_remove+0x38>
    }
    return true;
    80015ce6:	4785                	li	a5,1
}
    80015ce8:	853e                	mv	a0,a5
    80015cea:	6462                	ld	s0,24(sp)
    80015cec:	6105                	addi	sp,sp,32
    80015cee:	8082                	ret

0000000080015cf0 <vector_remove_value>:

bool vector_remove_value(Vector *vec, uint64_t val) {
    80015cf0:	7179                	addi	sp,sp,-48
    80015cf2:	f406                	sd	ra,40(sp)
    80015cf4:	f022                	sd	s0,32(sp)
    80015cf6:	1800                	addi	s0,sp,48
    80015cf8:	fca43c23          	sd	a0,-40(s0)
    80015cfc:	fcb43823          	sd	a1,-48(s0)
    uint32_t i;
    for (i = 0;i < vec->size;i++) {
    80015d00:	fe042623          	sw	zero,-20(s0)
    80015d04:	a81d                	j	80015d3a <vector_remove_value+0x4a>
        if (vec->values[i] == val) {
    80015d06:	fd843783          	ld	a5,-40(s0)
    80015d0a:	6798                	ld	a4,8(a5)
    80015d0c:	fec46783          	lwu	a5,-20(s0)
    80015d10:	078e                	slli	a5,a5,0x3
    80015d12:	97ba                	add	a5,a5,a4
    80015d14:	639c                	ld	a5,0(a5)
    80015d16:	fd043703          	ld	a4,-48(s0)
    80015d1a:	00f71b63          	bne	a4,a5,80015d30 <vector_remove_value+0x40>
            vector_remove(vec, i);
    80015d1e:	fec42783          	lw	a5,-20(s0)
    80015d22:	85be                	mv	a1,a5
    80015d24:	fd843503          	ld	a0,-40(s0)
    80015d28:	f45ff0ef          	jal	ra,80015c6c <vector_remove>
            return true;
    80015d2c:	4785                	li	a5,1
    80015d2e:	a839                	j	80015d4c <vector_remove_value+0x5c>
    for (i = 0;i < vec->size;i++) {
    80015d30:	fec42783          	lw	a5,-20(s0)
    80015d34:	2785                	addiw	a5,a5,1
    80015d36:	fef42623          	sw	a5,-20(s0)
    80015d3a:	fd843783          	ld	a5,-40(s0)
    80015d3e:	4398                	lw	a4,0(a5)
    80015d40:	fec42783          	lw	a5,-20(s0)
    80015d44:	2781                	sext.w	a5,a5
    80015d46:	fce7e0e3          	bltu	a5,a4,80015d06 <vector_remove_value+0x16>
        }
    }
    return false;
    80015d4a:	4781                	li	a5,0
}
    80015d4c:	853e                	mv	a0,a5
    80015d4e:	70a2                	ld	ra,40(sp)
    80015d50:	7402                	ld	s0,32(sp)
    80015d52:	6145                	addi	sp,sp,48
    80015d54:	8082                	ret

0000000080015d56 <vector_clear>:

void vector_clear(Vector *vec) {
    80015d56:	1101                	addi	sp,sp,-32
    80015d58:	ec06                	sd	ra,24(sp)
    80015d5a:	e822                	sd	s0,16(sp)
    80015d5c:	1000                	addi	s0,sp,32
    80015d5e:	fea43423          	sd	a0,-24(s0)
    vector_resize(vec, 0);
    80015d62:	4581                	li	a1,0
    80015d64:	fe843503          	ld	a0,-24(s0)
    80015d68:	d25ff0ef          	jal	ra,80015a8c <vector_resize>
}
    80015d6c:	0001                	nop
    80015d6e:	60e2                	ld	ra,24(sp)
    80015d70:	6442                	ld	s0,16(sp)
    80015d72:	6105                	addi	sp,sp,32
    80015d74:	8082                	ret

0000000080015d76 <vector_binsearch_ascending>:

int vector_binsearch_ascending(struct Vector *vec, uint64_t key) {
    80015d76:	7179                	addi	sp,sp,-48
    80015d78:	f406                	sd	ra,40(sp)
    80015d7a:	f022                	sd	s0,32(sp)
    80015d7c:	1800                	addi	s0,sp,48
    80015d7e:	fca43c23          	sd	a0,-40(s0)
    80015d82:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    80015d86:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec);
    80015d8a:	fd843503          	ld	a0,-40(s0)
    80015d8e:	356000ef          	jal	ra,800160e4 <vector_size>
    80015d92:	87aa                	mv	a5,a0
    80015d94:	2781                	sext.w	a5,a5
    80015d96:	fef42423          	sw	a5,-24(s0)

    while (low < high) {
    80015d9a:	a0ad                	j	80015e04 <vector_binsearch_ascending+0x8e>
        int mid = (low + high) / 2;
    80015d9c:	fec42703          	lw	a4,-20(s0)
    80015da0:	fe842783          	lw	a5,-24(s0)
    80015da4:	9fb9                	addw	a5,a5,a4
    80015da6:	2781                	sext.w	a5,a5
    80015da8:	01f7d71b          	srliw	a4,a5,0x1f
    80015dac:	9fb9                	addw	a5,a5,a4
    80015dae:	4017d79b          	sraiw	a5,a5,0x1
    80015db2:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) > key) {
    80015db6:	fe442783          	lw	a5,-28(s0)
    80015dba:	85be                	mv	a1,a5
    80015dbc:	fd843503          	ld	a0,-40(s0)
    80015dc0:	c13ff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015dc4:	872a                	mv	a4,a0
    80015dc6:	fd043783          	ld	a5,-48(s0)
    80015dca:	00e7f863          	bgeu	a5,a4,80015dda <vector_binsearch_ascending+0x64>
            high = mid - 1;
    80015dce:	fe442783          	lw	a5,-28(s0)
    80015dd2:	37fd                	addiw	a5,a5,-1
    80015dd4:	fef42423          	sw	a5,-24(s0)
    80015dd8:	a035                	j	80015e04 <vector_binsearch_ascending+0x8e>
        }
        else if (vector_get_unchecked(vec, mid) < key) {
    80015dda:	fe442783          	lw	a5,-28(s0)
    80015dde:	85be                	mv	a1,a5
    80015de0:	fd843503          	ld	a0,-40(s0)
    80015de4:	befff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015de8:	872a                	mv	a4,a0
    80015dea:	fd043783          	ld	a5,-48(s0)
    80015dee:	00f77863          	bgeu	a4,a5,80015dfe <vector_binsearch_ascending+0x88>
            low = mid + 1;
    80015df2:	fe442783          	lw	a5,-28(s0)
    80015df6:	2785                	addiw	a5,a5,1
    80015df8:	fef42623          	sw	a5,-20(s0)
    80015dfc:	a021                	j	80015e04 <vector_binsearch_ascending+0x8e>
        }
        else {
            return mid;
    80015dfe:	fe442783          	lw	a5,-28(s0)
    80015e02:	a811                	j	80015e16 <vector_binsearch_ascending+0xa0>
    while (low < high) {
    80015e04:	fec42703          	lw	a4,-20(s0)
    80015e08:	fe842783          	lw	a5,-24(s0)
    80015e0c:	2701                	sext.w	a4,a4
    80015e0e:	2781                	sext.w	a5,a5
    80015e10:	f8f746e3          	blt	a4,a5,80015d9c <vector_binsearch_ascending+0x26>
        }
    }
    return -1;
    80015e14:	57fd                	li	a5,-1
}
    80015e16:	853e                	mv	a0,a5
    80015e18:	70a2                	ld	ra,40(sp)
    80015e1a:	7402                	ld	s0,32(sp)
    80015e1c:	6145                	addi	sp,sp,48
    80015e1e:	8082                	ret

0000000080015e20 <vector_binsearch_descending>:

int vector_binsearch_descending(struct Vector *vec, uint64_t key) {
    80015e20:	7179                	addi	sp,sp,-48
    80015e22:	f406                	sd	ra,40(sp)
    80015e24:	f022                	sd	s0,32(sp)
    80015e26:	1800                	addi	s0,sp,48
    80015e28:	fca43c23          	sd	a0,-40(s0)
    80015e2c:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    80015e30:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec) - 1;
    80015e34:	fd843503          	ld	a0,-40(s0)
    80015e38:	2ac000ef          	jal	ra,800160e4 <vector_size>
    80015e3c:	87aa                	mv	a5,a0
    80015e3e:	2781                	sext.w	a5,a5
    80015e40:	37fd                	addiw	a5,a5,-1
    80015e42:	2781                	sext.w	a5,a5
    80015e44:	fef42423          	sw	a5,-24(s0)

    while (low <= high) {
    80015e48:	a0ad                	j	80015eb2 <vector_binsearch_descending+0x92>
        int mid = (low + high) / 2;
    80015e4a:	fec42703          	lw	a4,-20(s0)
    80015e4e:	fe842783          	lw	a5,-24(s0)
    80015e52:	9fb9                	addw	a5,a5,a4
    80015e54:	2781                	sext.w	a5,a5
    80015e56:	01f7d71b          	srliw	a4,a5,0x1f
    80015e5a:	9fb9                	addw	a5,a5,a4
    80015e5c:	4017d79b          	sraiw	a5,a5,0x1
    80015e60:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) < key) {
    80015e64:	fe442783          	lw	a5,-28(s0)
    80015e68:	85be                	mv	a1,a5
    80015e6a:	fd843503          	ld	a0,-40(s0)
    80015e6e:	b65ff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015e72:	872a                	mv	a4,a0
    80015e74:	fd043783          	ld	a5,-48(s0)
    80015e78:	00f77863          	bgeu	a4,a5,80015e88 <vector_binsearch_descending+0x68>
            high = mid - 1;
    80015e7c:	fe442783          	lw	a5,-28(s0)
    80015e80:	37fd                	addiw	a5,a5,-1
    80015e82:	fef42423          	sw	a5,-24(s0)
    80015e86:	a035                	j	80015eb2 <vector_binsearch_descending+0x92>
        }
        else if (vector_get_unchecked(vec, mid) > key) {
    80015e88:	fe442783          	lw	a5,-28(s0)
    80015e8c:	85be                	mv	a1,a5
    80015e8e:	fd843503          	ld	a0,-40(s0)
    80015e92:	b41ff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015e96:	872a                	mv	a4,a0
    80015e98:	fd043783          	ld	a5,-48(s0)
    80015e9c:	00e7f863          	bgeu	a5,a4,80015eac <vector_binsearch_descending+0x8c>
            low = mid + 1;
    80015ea0:	fe442783          	lw	a5,-28(s0)
    80015ea4:	2785                	addiw	a5,a5,1
    80015ea6:	fef42623          	sw	a5,-20(s0)
    80015eaa:	a021                	j	80015eb2 <vector_binsearch_descending+0x92>
        }
        else {
            return mid;
    80015eac:	fe442783          	lw	a5,-28(s0)
    80015eb0:	a811                	j	80015ec4 <vector_binsearch_descending+0xa4>
    while (low <= high) {
    80015eb2:	fec42703          	lw	a4,-20(s0)
    80015eb6:	fe842783          	lw	a5,-24(s0)
    80015eba:	2701                	sext.w	a4,a4
    80015ebc:	2781                	sext.w	a5,a5
    80015ebe:	f8e7d6e3          	bge	a5,a4,80015e4a <vector_binsearch_descending+0x2a>
        }
    }
    return -1;
    80015ec2:	57fd                	li	a5,-1
}
    80015ec4:	853e                	mv	a0,a5
    80015ec6:	70a2                	ld	ra,40(sp)
    80015ec8:	7402                	ld	s0,32(sp)
    80015eca:	6145                	addi	sp,sp,48
    80015ecc:	8082                	ret

0000000080015ece <vector_sort>:

void vector_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80015ece:	1101                	addi	sp,sp,-32
    80015ed0:	ec06                	sd	ra,24(sp)
    80015ed2:	e822                	sd	s0,16(sp)
    80015ed4:	1000                	addi	s0,sp,32
    80015ed6:	fea43423          	sd	a0,-24(s0)
    80015eda:	feb43023          	sd	a1,-32(s0)
    vector_insertion_sort(vec, comp);
    80015ede:	fe043583          	ld	a1,-32(s0)
    80015ee2:	fe843503          	ld	a0,-24(s0)
    80015ee6:	10e000ef          	jal	ra,80015ff4 <vector_insertion_sort>
}
    80015eea:	0001                	nop
    80015eec:	60e2                	ld	ra,24(sp)
    80015eee:	6442                	ld	s0,16(sp)
    80015ef0:	6105                	addi	sp,sp,32
    80015ef2:	8082                	ret

0000000080015ef4 <vector_selection_sort>:

void vector_selection_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80015ef4:	715d                	addi	sp,sp,-80
    80015ef6:	e486                	sd	ra,72(sp)
    80015ef8:	e0a2                	sd	s0,64(sp)
    80015efa:	fc26                	sd	s1,56(sp)
    80015efc:	0880                	addi	s0,sp,80
    80015efe:	faa43c23          	sd	a0,-72(s0)
    80015f02:	fab43823          	sd	a1,-80(s0)
    uint32_t i;
    uint32_t j;
    uint32_t min_idx;
    uint64_t tmp;

    for (i = 0;i < vector_size(vec);i++) {
    80015f06:	fc042e23          	sw	zero,-36(s0)
    80015f0a:	a0d1                	j	80015fce <vector_selection_sort+0xda>
        min_idx = i;
    80015f0c:	fdc42783          	lw	a5,-36(s0)
    80015f10:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    80015f14:	fdc42783          	lw	a5,-36(s0)
    80015f18:	2785                	addiw	a5,a5,1
    80015f1a:	fcf42c23          	sw	a5,-40(s0)
    80015f1e:	a0a9                	j	80015f68 <vector_selection_sort+0x74>
            if (!comp(vector_get_unchecked(vec, min_idx), vector_get_unchecked(vec, j))) {
    80015f20:	fd442783          	lw	a5,-44(s0)
    80015f24:	85be                	mv	a1,a5
    80015f26:	fb843503          	ld	a0,-72(s0)
    80015f2a:	aa9ff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015f2e:	84aa                	mv	s1,a0
    80015f30:	fd842783          	lw	a5,-40(s0)
    80015f34:	85be                	mv	a1,a5
    80015f36:	fb843503          	ld	a0,-72(s0)
    80015f3a:	a99ff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015f3e:	87aa                	mv	a5,a0
    80015f40:	fb043703          	ld	a4,-80(s0)
    80015f44:	85be                	mv	a1,a5
    80015f46:	8526                	mv	a0,s1
    80015f48:	9702                	jalr	a4
    80015f4a:	87aa                	mv	a5,a0
    80015f4c:	0017c793          	xori	a5,a5,1
    80015f50:	0ff7f793          	andi	a5,a5,255
    80015f54:	c789                	beqz	a5,80015f5e <vector_selection_sort+0x6a>
                min_idx = j;
    80015f56:	fd842783          	lw	a5,-40(s0)
    80015f5a:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    80015f5e:	fd842783          	lw	a5,-40(s0)
    80015f62:	2785                	addiw	a5,a5,1
    80015f64:	fcf42c23          	sw	a5,-40(s0)
    80015f68:	fb843503          	ld	a0,-72(s0)
    80015f6c:	178000ef          	jal	ra,800160e4 <vector_size>
    80015f70:	87aa                	mv	a5,a0
    80015f72:	0007871b          	sext.w	a4,a5
    80015f76:	fd842783          	lw	a5,-40(s0)
    80015f7a:	2781                	sext.w	a5,a5
    80015f7c:	fae7e2e3          	bltu	a5,a4,80015f20 <vector_selection_sort+0x2c>
            }
        }
        tmp = vector_get_unchecked(vec, i);
    80015f80:	fdc42783          	lw	a5,-36(s0)
    80015f84:	85be                	mv	a1,a5
    80015f86:	fb843503          	ld	a0,-72(s0)
    80015f8a:	a49ff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015f8e:	fca43423          	sd	a0,-56(s0)
        vector_set(vec, i, vector_get_unchecked(vec, min_idx));
    80015f92:	fd442783          	lw	a5,-44(s0)
    80015f96:	85be                	mv	a1,a5
    80015f98:	fb843503          	ld	a0,-72(s0)
    80015f9c:	a37ff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    80015fa0:	872a                	mv	a4,a0
    80015fa2:	fdc42783          	lw	a5,-36(s0)
    80015fa6:	863a                	mv	a2,a4
    80015fa8:	85be                	mv	a1,a5
    80015faa:	fb843503          	ld	a0,-72(s0)
    80015fae:	991ff0ef          	jal	ra,8001593e <vector_set>
        vector_set(vec, min_idx, tmp);
    80015fb2:	fd442783          	lw	a5,-44(s0)
    80015fb6:	fc843603          	ld	a2,-56(s0)
    80015fba:	85be                	mv	a1,a5
    80015fbc:	fb843503          	ld	a0,-72(s0)
    80015fc0:	97fff0ef          	jal	ra,8001593e <vector_set>
    for (i = 0;i < vector_size(vec);i++) {
    80015fc4:	fdc42783          	lw	a5,-36(s0)
    80015fc8:	2785                	addiw	a5,a5,1
    80015fca:	fcf42e23          	sw	a5,-36(s0)
    80015fce:	fb843503          	ld	a0,-72(s0)
    80015fd2:	112000ef          	jal	ra,800160e4 <vector_size>
    80015fd6:	87aa                	mv	a5,a0
    80015fd8:	0007871b          	sext.w	a4,a5
    80015fdc:	fdc42783          	lw	a5,-36(s0)
    80015fe0:	2781                	sext.w	a5,a5
    80015fe2:	f2e7e5e3          	bltu	a5,a4,80015f0c <vector_selection_sort+0x18>
    }
}
    80015fe6:	0001                	nop
    80015fe8:	0001                	nop
    80015fea:	60a6                	ld	ra,72(sp)
    80015fec:	6406                	ld	s0,64(sp)
    80015fee:	74e2                	ld	s1,56(sp)
    80015ff0:	6161                	addi	sp,sp,80
    80015ff2:	8082                	ret

0000000080015ff4 <vector_insertion_sort>:

void vector_insertion_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80015ff4:	715d                	addi	sp,sp,-80
    80015ff6:	e486                	sd	ra,72(sp)
    80015ff8:	e0a2                	sd	s0,64(sp)
    80015ffa:	fc26                	sd	s1,56(sp)
    80015ffc:	0880                	addi	s0,sp,80
    80015ffe:	faa43c23          	sd	a0,-72(s0)
    80016002:	fab43823          	sd	a1,-80(s0)
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    80016006:	4785                	li	a5,1
    80016008:	fcf42e23          	sw	a5,-36(s0)
    8001600c:	a84d                	j	800160be <vector_insertion_sort+0xca>
        uint32_t j = i;
    8001600e:	fdc42783          	lw	a5,-36(s0)
    80016012:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    80016016:	a8b1                	j	80016072 <vector_insertion_sort+0x7e>
            uint64_t left = vector_get_unchecked(vec, j - 1);
    80016018:	fd842783          	lw	a5,-40(s0)
    8001601c:	37fd                	addiw	a5,a5,-1
    8001601e:	2781                	sext.w	a5,a5
    80016020:	85be                	mv	a1,a5
    80016022:	fb843503          	ld	a0,-72(s0)
    80016026:	9adff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    8001602a:	fca43823          	sd	a0,-48(s0)
            uint64_t right = vector_get_unchecked(vec, j);
    8001602e:	fd842783          	lw	a5,-40(s0)
    80016032:	85be                	mv	a1,a5
    80016034:	fb843503          	ld	a0,-72(s0)
    80016038:	99bff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    8001603c:	fca43423          	sd	a0,-56(s0)

            vector_set(vec, j, left);
    80016040:	fd842783          	lw	a5,-40(s0)
    80016044:	fd043603          	ld	a2,-48(s0)
    80016048:	85be                	mv	a1,a5
    8001604a:	fb843503          	ld	a0,-72(s0)
    8001604e:	8f1ff0ef          	jal	ra,8001593e <vector_set>
            vector_set(vec, j - 1, right);
    80016052:	fd842783          	lw	a5,-40(s0)
    80016056:	37fd                	addiw	a5,a5,-1
    80016058:	2781                	sext.w	a5,a5
    8001605a:	fc843603          	ld	a2,-56(s0)
    8001605e:	85be                	mv	a1,a5
    80016060:	fb843503          	ld	a0,-72(s0)
    80016064:	8dbff0ef          	jal	ra,8001593e <vector_set>

            j -= 1;
    80016068:	fd842783          	lw	a5,-40(s0)
    8001606c:	37fd                	addiw	a5,a5,-1
    8001606e:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    80016072:	fd842783          	lw	a5,-40(s0)
    80016076:	2781                	sext.w	a5,a5
    80016078:	cf95                	beqz	a5,800160b4 <vector_insertion_sort+0xc0>
    8001607a:	fd842783          	lw	a5,-40(s0)
    8001607e:	37fd                	addiw	a5,a5,-1
    80016080:	2781                	sext.w	a5,a5
    80016082:	85be                	mv	a1,a5
    80016084:	fb843503          	ld	a0,-72(s0)
    80016088:	94bff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    8001608c:	84aa                	mv	s1,a0
    8001608e:	fd842783          	lw	a5,-40(s0)
    80016092:	85be                	mv	a1,a5
    80016094:	fb843503          	ld	a0,-72(s0)
    80016098:	93bff0ef          	jal	ra,800159d2 <vector_get_unchecked>
    8001609c:	87aa                	mv	a5,a0
    8001609e:	fb043703          	ld	a4,-80(s0)
    800160a2:	85be                	mv	a1,a5
    800160a4:	8526                	mv	a0,s1
    800160a6:	9702                	jalr	a4
    800160a8:	87aa                	mv	a5,a0
    800160aa:	0017c793          	xori	a5,a5,1
    800160ae:	0ff7f793          	andi	a5,a5,255
    800160b2:	f3bd                	bnez	a5,80016018 <vector_insertion_sort+0x24>
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    800160b4:	fdc42783          	lw	a5,-36(s0)
    800160b8:	2785                	addiw	a5,a5,1
    800160ba:	fcf42e23          	sw	a5,-36(s0)
    800160be:	fb843503          	ld	a0,-72(s0)
    800160c2:	022000ef          	jal	ra,800160e4 <vector_size>
    800160c6:	87aa                	mv	a5,a0
    800160c8:	0007871b          	sext.w	a4,a5
    800160cc:	fdc42783          	lw	a5,-36(s0)
    800160d0:	2781                	sext.w	a5,a5
    800160d2:	f2e7eee3          	bltu	a5,a4,8001600e <vector_insertion_sort+0x1a>
        }
    }
}
    800160d6:	0001                	nop
    800160d8:	0001                	nop
    800160da:	60a6                	ld	ra,72(sp)
    800160dc:	6406                	ld	s0,64(sp)
    800160de:	74e2                	ld	s1,56(sp)
    800160e0:	6161                	addi	sp,sp,80
    800160e2:	8082                	ret

00000000800160e4 <vector_size>:

uint32_t vector_size(Vector *vec) {
    800160e4:	1101                	addi	sp,sp,-32
    800160e6:	ec22                	sd	s0,24(sp)
    800160e8:	1000                	addi	s0,sp,32
    800160ea:	fea43423          	sd	a0,-24(s0)
    return vec->size;
    800160ee:	fe843783          	ld	a5,-24(s0)
    800160f2:	439c                	lw	a5,0(a5)
}
    800160f4:	853e                	mv	a0,a5
    800160f6:	6462                	ld	s0,24(sp)
    800160f8:	6105                	addi	sp,sp,32
    800160fa:	8082                	ret

00000000800160fc <vector_capacity>:

uint32_t vector_capacity(Vector *vec) {
    800160fc:	1101                	addi	sp,sp,-32
    800160fe:	ec22                	sd	s0,24(sp)
    80016100:	1000                	addi	s0,sp,32
    80016102:	fea43423          	sd	a0,-24(s0)
    return vec->capacity;
    80016106:	fe843783          	ld	a5,-24(s0)
    8001610a:	43dc                	lw	a5,4(a5)
}
    8001610c:	853e                	mv	a0,a5
    8001610e:	6462                	ld	s0,24(sp)
    80016110:	6105                	addi	sp,sp,32
    80016112:	8082                	ret

0000000080016114 <vector_free>:

void vector_free(Vector *vec) {
    80016114:	1101                	addi	sp,sp,-32
    80016116:	ec06                	sd	ra,24(sp)
    80016118:	e822                	sd	s0,16(sp)
    8001611a:	1000                	addi	s0,sp,32
    8001611c:	fea43423          	sd	a0,-24(s0)
    g_kfree(vec->values);
    80016120:	fe843783          	ld	a5,-24(s0)
    80016124:	679c                	ld	a5,8(a5)
    80016126:	853e                	mv	a0,a5
    80016128:	1d4000ef          	jal	ra,800162fc <g_kfree>
    vec->size = 0;
    8001612c:	fe843783          	ld	a5,-24(s0)
    80016130:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    80016134:	fe843783          	ld	a5,-24(s0)
    80016138:	0007a223          	sw	zero,4(a5)
    g_kfree(vec);
    8001613c:	fe843503          	ld	a0,-24(s0)
    80016140:	1bc000ef          	jal	ra,800162fc <g_kfree>
}
    80016144:	0001                	nop
    80016146:	60e2                	ld	ra,24(sp)
    80016148:	6442                	ld	s0,16(sp)
    8001614a:	6105                	addi	sp,sp,32
    8001614c:	8082                	ret

000000008001614e <vector_sort_signed_long_comparator_ascending>:

VECTOR_COMPARATOR(vector_sort_signed_long_comparator_ascending) {
    8001614e:	1101                	addi	sp,sp,-32
    80016150:	ec22                	sd	s0,24(sp)
    80016152:	1000                	addi	s0,sp,32
    80016154:	fea43423          	sd	a0,-24(s0)
    80016158:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    8001615c:	fe843703          	ld	a4,-24(s0)
    80016160:	fe043783          	ld	a5,-32(s0)
    80016164:	00e7a7b3          	slt	a5,a5,a4
    80016168:	0017c793          	xori	a5,a5,1
    8001616c:	0ff7f793          	andi	a5,a5,255
}
    80016170:	853e                	mv	a0,a5
    80016172:	6462                	ld	s0,24(sp)
    80016174:	6105                	addi	sp,sp,32
    80016176:	8082                	ret

0000000080016178 <vector_sort_signed_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_signed_long_comparator_descending) {
    80016178:	1101                	addi	sp,sp,-32
    8001617a:	ec22                	sd	s0,24(sp)
    8001617c:	1000                	addi	s0,sp,32
    8001617e:	fea43423          	sd	a0,-24(s0)
    80016182:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    80016186:	fe843703          	ld	a4,-24(s0)
    8001618a:	fe043783          	ld	a5,-32(s0)
    8001618e:	00f727b3          	slt	a5,a4,a5
    80016192:	0017c793          	xori	a5,a5,1
    80016196:	0ff7f793          	andi	a5,a5,255
}
    8001619a:	853e                	mv	a0,a5
    8001619c:	6462                	ld	s0,24(sp)
    8001619e:	6105                	addi	sp,sp,32
    800161a0:	8082                	ret

00000000800161a2 <vector_sort_unsigned_long_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_ascending) {
    800161a2:	1101                	addi	sp,sp,-32
    800161a4:	ec22                	sd	s0,24(sp)
    800161a6:	1000                	addi	s0,sp,32
    800161a8:	fea43423          	sd	a0,-24(s0)
    800161ac:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    800161b0:	fe843703          	ld	a4,-24(s0)
    800161b4:	fe043783          	ld	a5,-32(s0)
    800161b8:	00e7b7b3          	sltu	a5,a5,a4
    800161bc:	0017c793          	xori	a5,a5,1
    800161c0:	0ff7f793          	andi	a5,a5,255
}
    800161c4:	853e                	mv	a0,a5
    800161c6:	6462                	ld	s0,24(sp)
    800161c8:	6105                	addi	sp,sp,32
    800161ca:	8082                	ret

00000000800161cc <vector_sort_unsigned_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_descending) {
    800161cc:	1101                	addi	sp,sp,-32
    800161ce:	ec22                	sd	s0,24(sp)
    800161d0:	1000                	addi	s0,sp,32
    800161d2:	fea43423          	sd	a0,-24(s0)
    800161d6:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    800161da:	fe843703          	ld	a4,-24(s0)
    800161de:	fe043783          	ld	a5,-32(s0)
    800161e2:	00f737b3          	sltu	a5,a4,a5
    800161e6:	0017c793          	xori	a5,a5,1
    800161ea:	0ff7f793          	andi	a5,a5,255
}
    800161ee:	853e                	mv	a0,a5
    800161f0:	6462                	ld	s0,24(sp)
    800161f2:	6105                	addi	sp,sp,32
    800161f4:	8082                	ret

00000000800161f6 <vector_sort_string_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_ascending) {
    800161f6:	1101                	addi	sp,sp,-32
    800161f8:	ec06                	sd	ra,24(sp)
    800161fa:	e822                	sd	s0,16(sp)
    800161fc:	1000                	addi	s0,sp,32
    800161fe:	fea43423          	sd	a0,-24(s0)
    80016202:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    80016206:	fe843783          	ld	a5,-24(s0)
    8001620a:	fe043703          	ld	a4,-32(s0)
    8001620e:	85ba                	mv	a1,a4
    80016210:	853e                	mv	a0,a5
    80016212:	fb1fe0ef          	jal	ra,800151c2 <strcmp>
    80016216:	87aa                	mv	a5,a0
    80016218:	0017a793          	slti	a5,a5,1
    8001621c:	0ff7f793          	andi	a5,a5,255
}
    80016220:	853e                	mv	a0,a5
    80016222:	60e2                	ld	ra,24(sp)
    80016224:	6442                	ld	s0,16(sp)
    80016226:	6105                	addi	sp,sp,32
    80016228:	8082                	ret

000000008001622a <vector_sort_string_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_descending) {
    8001622a:	1101                	addi	sp,sp,-32
    8001622c:	ec06                	sd	ra,24(sp)
    8001622e:	e822                	sd	s0,16(sp)
    80016230:	1000                	addi	s0,sp,32
    80016232:	fea43423          	sd	a0,-24(s0)
    80016236:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    8001623a:	fe843783          	ld	a5,-24(s0)
    8001623e:	fe043703          	ld	a4,-32(s0)
    80016242:	85ba                	mv	a1,a4
    80016244:	853e                	mv	a0,a5
    80016246:	f7dfe0ef          	jal	ra,800151c2 <strcmp>
    8001624a:	87aa                	mv	a5,a0
    8001624c:	fff7c793          	not	a5,a5
    80016250:	01f7d79b          	srliw	a5,a5,0x1f
    80016254:	0ff7f793          	andi	a5,a5,255
}
    80016258:	853e                	mv	a0,a5
    8001625a:	60e2                	ld	ra,24(sp)
    8001625c:	6442                	ld	s0,16(sp)
    8001625e:	6105                	addi	sp,sp,32
    80016260:	8082                	ret

0000000080016262 <g_kmalloc>:
void *(*__global_kmalloc)(uint64_t size);
void *(*__global_kcalloc)(uint64_t num, uint64_t size);
void (*__global_kfree)(void *ptr);

void *g_kmalloc(uint64_t size)
{
    80016262:	1101                	addi	sp,sp,-32
    80016264:	ec06                	sd	ra,24(sp)
    80016266:	e822                	sd	s0,16(sp)
    80016268:	1000                	addi	s0,sp,32
    8001626a:	fea43423          	sd	a0,-24(s0)
    if (__global_kmalloc == NULL) {
    8001626e:	00002797          	auipc	a5,0x2
    80016272:	da278793          	addi	a5,a5,-606 # 80018010 <__global_kmalloc>
    80016276:	639c                	ld	a5,0(a5)
    80016278:	e399                	bnez	a5,8001627e <g_kmalloc+0x1c>
        return NULL;
    8001627a:	4781                	li	a5,0
    8001627c:	a811                	j	80016290 <g_kmalloc+0x2e>
    }
    return __global_kmalloc(size);
    8001627e:	00002797          	auipc	a5,0x2
    80016282:	d9278793          	addi	a5,a5,-622 # 80018010 <__global_kmalloc>
    80016286:	639c                	ld	a5,0(a5)
    80016288:	fe843503          	ld	a0,-24(s0)
    8001628c:	9782                	jalr	a5
    8001628e:	87aa                	mv	a5,a0
}
    80016290:	853e                	mv	a0,a5
    80016292:	60e2                	ld	ra,24(sp)
    80016294:	6442                	ld	s0,16(sp)
    80016296:	6105                	addi	sp,sp,32
    80016298:	8082                	ret

000000008001629a <g_kcalloc>:
void *g_kcalloc(uint64_t num, uint64_t size)
{
    8001629a:	1101                	addi	sp,sp,-32
    8001629c:	ec06                	sd	ra,24(sp)
    8001629e:	e822                	sd	s0,16(sp)
    800162a0:	1000                	addi	s0,sp,32
    800162a2:	fea43423          	sd	a0,-24(s0)
    800162a6:	feb43023          	sd	a1,-32(s0)
    if (__global_kcalloc == NULL) {
    800162aa:	00002797          	auipc	a5,0x2
    800162ae:	d6e78793          	addi	a5,a5,-658 # 80018018 <__global_kcalloc>
    800162b2:	639c                	ld	a5,0(a5)
    800162b4:	e399                	bnez	a5,800162ba <g_kcalloc+0x20>
        return NULL;
    800162b6:	4781                	li	a5,0
    800162b8:	a821                	j	800162d0 <g_kcalloc+0x36>
    }
    return __global_kcalloc(num, size);
    800162ba:	00002797          	auipc	a5,0x2
    800162be:	d5e78793          	addi	a5,a5,-674 # 80018018 <__global_kcalloc>
    800162c2:	639c                	ld	a5,0(a5)
    800162c4:	fe043583          	ld	a1,-32(s0)
    800162c8:	fe843503          	ld	a0,-24(s0)
    800162cc:	9782                	jalr	a5
    800162ce:	87aa                	mv	a5,a0
}
    800162d0:	853e                	mv	a0,a5
    800162d2:	60e2                	ld	ra,24(sp)
    800162d4:	6442                	ld	s0,16(sp)
    800162d6:	6105                	addi	sp,sp,32
    800162d8:	8082                	ret

00000000800162da <g_kzalloc>:
void *g_kzalloc(uint64_t size)
{
    800162da:	1101                	addi	sp,sp,-32
    800162dc:	ec06                	sd	ra,24(sp)
    800162de:	e822                	sd	s0,16(sp)
    800162e0:	1000                	addi	s0,sp,32
    800162e2:	fea43423          	sd	a0,-24(s0)
    return g_kcalloc(1, size);
    800162e6:	fe843583          	ld	a1,-24(s0)
    800162ea:	4505                	li	a0,1
    800162ec:	fafff0ef          	jal	ra,8001629a <g_kcalloc>
    800162f0:	87aa                	mv	a5,a0
}
    800162f2:	853e                	mv	a0,a5
    800162f4:	60e2                	ld	ra,24(sp)
    800162f6:	6442                	ld	s0,16(sp)
    800162f8:	6105                	addi	sp,sp,32
    800162fa:	8082                	ret

00000000800162fc <g_kfree>:
void g_kfree(void *ptr)
{
    800162fc:	1101                	addi	sp,sp,-32
    800162fe:	ec06                	sd	ra,24(sp)
    80016300:	e822                	sd	s0,16(sp)
    80016302:	1000                	addi	s0,sp,32
    80016304:	fea43423          	sd	a0,-24(s0)
    if (__global_kfree != NULL) {
    80016308:	00002797          	auipc	a5,0x2
    8001630c:	d1878793          	addi	a5,a5,-744 # 80018020 <__global_kfree>
    80016310:	639c                	ld	a5,0(a5)
    80016312:	cb89                	beqz	a5,80016324 <g_kfree+0x28>
        __global_kfree(ptr);
    80016314:	00002797          	auipc	a5,0x2
    80016318:	d0c78793          	addi	a5,a5,-756 # 80018020 <__global_kfree>
    8001631c:	639c                	ld	a5,0(a5)
    8001631e:	fe843503          	ld	a0,-24(s0)
    80016322:	9782                	jalr	a5
    }
}
    80016324:	0001                	nop
    80016326:	60e2                	ld	ra,24(sp)
    80016328:	6442                	ld	s0,16(sp)
    8001632a:	6105                	addi	sp,sp,32
    8001632c:	8082                	ret

000000008001632e <util_connect_galloc>:

void util_connect_galloc(void *(*malloc)(uint64_t size),
                         void *(*calloc)(uint64_t elem, uint64_t size), void (*free)(void *ptr))
{
    8001632e:	7179                	addi	sp,sp,-48
    80016330:	f422                	sd	s0,40(sp)
    80016332:	1800                	addi	s0,sp,48
    80016334:	fea43423          	sd	a0,-24(s0)
    80016338:	feb43023          	sd	a1,-32(s0)
    8001633c:	fcc43c23          	sd	a2,-40(s0)
    __global_kmalloc = malloc;
    80016340:	00002797          	auipc	a5,0x2
    80016344:	cd078793          	addi	a5,a5,-816 # 80018010 <__global_kmalloc>
    80016348:	fe843703          	ld	a4,-24(s0)
    8001634c:	e398                	sd	a4,0(a5)
    __global_kcalloc = calloc;
    8001634e:	00002797          	auipc	a5,0x2
    80016352:	cca78793          	addi	a5,a5,-822 # 80018018 <__global_kcalloc>
    80016356:	fe043703          	ld	a4,-32(s0)
    8001635a:	e398                	sd	a4,0(a5)
    __global_kfree   = free;
    8001635c:	00002797          	auipc	a5,0x2
    80016360:	cc478793          	addi	a5,a5,-828 # 80018020 <__global_kfree>
    80016364:	fd843703          	ld	a4,-40(s0)
    80016368:	e398                	sd	a4,0(a5)
}
    8001636a:	0001                	nop
    8001636c:	7422                	ld	s0,40(sp)
    8001636e:	6145                	addi	sp,sp,48
    80016370:	8082                	ret
