
cosc562.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000080010000 <_memory_start>:
    80010000:	fe22                	sd	s0,312(sp)
    80010002:	f1ca                	sd	s2,224(sp)
    80010004:	0bee                	slli	s7,s7,0x1b
    80010006:	dead                	beqz	a3,8000ff80 <i+0x8000ff60>
    80010008:	bf20                	fsd	fs0,120(a4)
    8001000a:	8001                	c.srli64	s0
	...

0000000080010102 <copy_from>:
*/
unsigned long copy_from(void *dst, 
                        const struct page_table *from_table, 
                        const void *from, 
                        unsigned long size)
{
    80010102:	7119                	addi	sp,sp,-128
    80010104:	fc86                	sd	ra,120(sp)
    80010106:	f8a2                	sd	s0,112(sp)
    80010108:	0100                	addi	s0,sp,128
    8001010a:	f8a43c23          	sd	a0,-104(s0)
    8001010e:	f8b43823          	sd	a1,-112(s0)
    80010112:	f8c43423          	sd	a2,-120(s0)
    80010116:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    8001011a:	fe043423          	sd	zero,-24(s0)

    unsigned long src_start_addr = (unsigned long)from;
    8001011e:	f8843783          	ld	a5,-120(s0)
    80010122:	fcf43423          	sd	a5,-56(s0)
    unsigned long src_end_addr = (unsigned long)from+size;
    80010126:	f8843783          	ld	a5,-120(s0)
    8001012a:	f8043703          	ld	a4,-128(s0)
    8001012e:	97ba                	add	a5,a5,a4
    80010130:	fcf43023          	sd	a5,-64(s0)
    unsigned long src_first_page = ALIGN_DOWN_POT(src_start_addr, PAGE_SIZE_4K);
    80010134:	fc843703          	ld	a4,-56(s0)
    80010138:	77fd                	lui	a5,0xfffff
    8001013a:	8ff9                	and	a5,a5,a4
    8001013c:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    80010140:	fb843783          	ld	a5,-72(s0)
    80010144:	fef43023          	sd	a5,-32(s0)
    80010148:	a06d                	j	800101f2 <copy_from+0xf0>
        void *physical_address = (void*)mmu_translate(from_table, i);
    8001014a:	fe043583          	ld	a1,-32(s0)
    8001014e:	f9043503          	ld	a0,-112(s0)
    80010152:	719030ef          	jal	ra,8001406a <mmu_translate>
    80010156:	87aa                	mv	a5,a0
    80010158:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    8001015c:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == src_start_addr;
    80010160:	fe043703          	ld	a4,-32(s0)
    80010164:	fc843783          	ld	a5,-56(s0)
    80010168:	40f707b3          	sub	a5,a4,a5
    8001016c:	0017b793          	seqz	a5,a5
    80010170:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    80010174:	faf44783          	lbu	a5,-81(s0)
    80010178:	0ff7f793          	andi	a5,a5,255
    8001017c:	cb81                	beqz	a5,8001018c <copy_from+0x8a>
            offset = src_start_addr % PAGE_SIZE_4K;
    8001017e:	fc843703          	ld	a4,-56(s0)
    80010182:	6785                	lui	a5,0x1
    80010184:	17fd                	addi	a5,a5,-1
    80010186:	8ff9                	and	a5,a5,a4
    80010188:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    8001018c:	6785                	lui	a5,0x1
    8001018e:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > src_end_addr) {
    80010192:	fe043703          	ld	a4,-32(s0)
    80010196:	6785                	lui	a5,0x1
    80010198:	97ba                	add	a5,a5,a4
    8001019a:	fc043703          	ld	a4,-64(s0)
    8001019e:	00f77a63          	bgeu	a4,a5,800101b2 <copy_from+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = src_end_addr - i;
    800101a2:	fc043703          	ld	a4,-64(s0)
    800101a6:	fe043783          	ld	a5,-32(s0)
    800101aa:	40f707b3          	sub	a5,a4,a5
    800101ae:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(dst + bytes_copied, physical_address + offset, bytes_to_copy_from_page);
    800101b2:	f9843703          	ld	a4,-104(s0)
    800101b6:	fe843783          	ld	a5,-24(s0)
    800101ba:	00f706b3          	add	a3,a4,a5
    800101be:	fb043703          	ld	a4,-80(s0)
    800101c2:	fd843783          	ld	a5,-40(s0)
    800101c6:	97ba                	add	a5,a5,a4
    800101c8:	fd043703          	ld	a4,-48(s0)
    800101cc:	2701                	sext.w	a4,a4
    800101ce:	863a                	mv	a2,a4
    800101d0:	85be                	mv	a1,a5
    800101d2:	8536                	mv	a0,a3
    800101d4:	2580d0ef          	jal	ra,8001d42c <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800101d8:	fe843703          	ld	a4,-24(s0)
    800101dc:	fd043783          	ld	a5,-48(s0)
    800101e0:	97ba                	add	a5,a5,a4
    800101e2:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    800101e6:	fe043703          	ld	a4,-32(s0)
    800101ea:	6785                	lui	a5,0x1
    800101ec:	97ba                	add	a5,a5,a4
    800101ee:	fef43023          	sd	a5,-32(s0)
    800101f2:	fe043703          	ld	a4,-32(s0)
    800101f6:	fc043783          	ld	a5,-64(s0)
    800101fa:	f4f768e3          	bltu	a4,a5,8001014a <copy_from+0x48>
    }

    return bytes_copied;
    800101fe:	fe843783          	ld	a5,-24(s0)
}
    80010202:	853e                	mv	a0,a5
    80010204:	70e6                	ld	ra,120(sp)
    80010206:	7446                	ld	s0,112(sp)
    80010208:	6109                	addi	sp,sp,128
    8001020a:	8082                	ret

000000008001020c <copy_to>:
*/
unsigned long copy_to(void *to, 
                      const struct page_table *to_table, 
                      const void *src, 
                      unsigned long size)
{
    8001020c:	7119                	addi	sp,sp,-128
    8001020e:	fc86                	sd	ra,120(sp)
    80010210:	f8a2                	sd	s0,112(sp)
    80010212:	0100                	addi	s0,sp,128
    80010214:	f8a43c23          	sd	a0,-104(s0)
    80010218:	f8b43823          	sd	a1,-112(s0)
    8001021c:	f8c43423          	sd	a2,-120(s0)
    80010220:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    80010224:	fe043423          	sd	zero,-24(s0)

    unsigned long dst_start_addr = (unsigned long)to;
    80010228:	f9843783          	ld	a5,-104(s0)
    8001022c:	fcf43423          	sd	a5,-56(s0)
    unsigned long dst_end_addr = (unsigned long)to+size;
    80010230:	f9843783          	ld	a5,-104(s0)
    80010234:	f8043703          	ld	a4,-128(s0)
    80010238:	97ba                	add	a5,a5,a4
    8001023a:	fcf43023          	sd	a5,-64(s0)
    unsigned long dst_first_page = ALIGN_DOWN_POT(dst_start_addr, PAGE_SIZE_4K);
    8001023e:	fc843703          	ld	a4,-56(s0)
    80010242:	77fd                	lui	a5,0xfffff
    80010244:	8ff9                	and	a5,a5,a4
    80010246:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    8001024a:	fb843783          	ld	a5,-72(s0)
    8001024e:	fef43023          	sd	a5,-32(s0)
    80010252:	a06d                	j	800102fc <copy_to+0xf0>
        void *physical_address = (void*)mmu_translate(to_table, i);
    80010254:	fe043583          	ld	a1,-32(s0)
    80010258:	f9043503          	ld	a0,-112(s0)
    8001025c:	60f030ef          	jal	ra,8001406a <mmu_translate>
    80010260:	87aa                	mv	a5,a0
    80010262:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    80010266:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == dst_start_addr;
    8001026a:	fe043703          	ld	a4,-32(s0)
    8001026e:	fc843783          	ld	a5,-56(s0)
    80010272:	40f707b3          	sub	a5,a4,a5
    80010276:	0017b793          	seqz	a5,a5
    8001027a:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    8001027e:	faf44783          	lbu	a5,-81(s0)
    80010282:	0ff7f793          	andi	a5,a5,255
    80010286:	cb81                	beqz	a5,80010296 <copy_to+0x8a>
            offset = dst_start_addr % PAGE_SIZE_4K;
    80010288:	fc843703          	ld	a4,-56(s0)
    8001028c:	6785                	lui	a5,0x1
    8001028e:	17fd                	addi	a5,a5,-1
    80010290:	8ff9                	and	a5,a5,a4
    80010292:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    80010296:	6785                	lui	a5,0x1
    80010298:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > dst_end_addr) {
    8001029c:	fe043703          	ld	a4,-32(s0)
    800102a0:	6785                	lui	a5,0x1
    800102a2:	97ba                	add	a5,a5,a4
    800102a4:	fc043703          	ld	a4,-64(s0)
    800102a8:	00f77a63          	bgeu	a4,a5,800102bc <copy_to+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = dst_end_addr - i;
    800102ac:	fc043703          	ld	a4,-64(s0)
    800102b0:	fe043783          	ld	a5,-32(s0)
    800102b4:	40f707b3          	sub	a5,a4,a5
    800102b8:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(physical_address + offset, src + bytes_copied, bytes_to_copy_from_page);
    800102bc:	fb043703          	ld	a4,-80(s0)
    800102c0:	fd843783          	ld	a5,-40(s0)
    800102c4:	00f706b3          	add	a3,a4,a5
    800102c8:	f8843703          	ld	a4,-120(s0)
    800102cc:	fe843783          	ld	a5,-24(s0)
    800102d0:	97ba                	add	a5,a5,a4
    800102d2:	fd043703          	ld	a4,-48(s0)
    800102d6:	2701                	sext.w	a4,a4
    800102d8:	863a                	mv	a2,a4
    800102da:	85be                	mv	a1,a5
    800102dc:	8536                	mv	a0,a3
    800102de:	14e0d0ef          	jal	ra,8001d42c <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800102e2:	fe843703          	ld	a4,-24(s0)
    800102e6:	fd043783          	ld	a5,-48(s0)
    800102ea:	97ba                	add	a5,a5,a4
    800102ec:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    800102f0:	fe043703          	ld	a4,-32(s0)
    800102f4:	6785                	lui	a5,0x1
    800102f6:	97ba                	add	a5,a5,a4
    800102f8:	fef43023          	sd	a5,-32(s0)
    800102fc:	fe043703          	ld	a4,-32(s0)
    80010300:	fc043783          	ld	a5,-64(s0)
    80010304:	f4f768e3          	bltu	a4,a5,80010254 <copy_to+0x48>
    }

    return bytes_copied;
    80010308:	fe843783          	ld	a5,-24(s0)
    8001030c:	853e                	mv	a0,a5
    8001030e:	70e6                	ld	ra,120(sp)
    80010310:	7446                	ld	s0,112(sp)
    80010312:	6109                	addi	sp,sp,128
    80010314:	8082                	ret

0000000080010316 <syscall_exit>:
    (void)hart;         \
    (void)epc;          \
    (void)scratch

SYSCALL(exit)
{
    80010316:	7179                	addi	sp,sp,-48
    80010318:	f422                	sd	s0,40(sp)
    8001031a:	1800                	addi	s0,sp,48
    8001031c:	87aa                	mv	a5,a0
    8001031e:	feb43023          	sd	a1,-32(s0)
    80010322:	fcc43c23          	sd	a2,-40(s0)
    80010326:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Kill the current process on this HART and schedule the next
    // one.
}
    8001032a:	0001                	nop
    8001032c:	7422                	ld	s0,40(sp)
    8001032e:	6145                	addi	sp,sp,48
    80010330:	8082                	ret

0000000080010332 <syscall_putchar>:

SYSCALL(putchar)
{
    80010332:	7179                	addi	sp,sp,-48
    80010334:	f406                	sd	ra,40(sp)
    80010336:	f022                	sd	s0,32(sp)
    80010338:	1800                	addi	s0,sp,48
    8001033a:	87aa                	mv	a5,a0
    8001033c:	feb43023          	sd	a1,-32(s0)
    80010340:	fcc43c23          	sd	a2,-40(s0)
    80010344:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    sbi_putchar(XREG(A0));
    80010348:	fd843783          	ld	a5,-40(s0)
    8001034c:	05078793          	addi	a5,a5,80 # 1050 <i+0x1030>
    80010350:	639c                	ld	a5,0(a5)
    80010352:	0ff7f793          	andi	a5,a5,255
    80010356:	853e                	mv	a0,a5
    80010358:	0c8090ef          	jal	ra,80019420 <sbi_putchar>
}
    8001035c:	0001                	nop
    8001035e:	70a2                	ld	ra,40(sp)
    80010360:	7402                	ld	s0,32(sp)
    80010362:	6145                	addi	sp,sp,48
    80010364:	8082                	ret

0000000080010366 <syscall_getchar>:

SYSCALL(getchar)
{
    80010366:	7179                	addi	sp,sp,-48
    80010368:	f406                	sd	ra,40(sp)
    8001036a:	f022                	sd	s0,32(sp)
    8001036c:	1800                	addi	s0,sp,48
    8001036e:	87aa                	mv	a5,a0
    80010370:	feb43023          	sd	a1,-32(s0)
    80010374:	fcc43c23          	sd	a2,-40(s0)
    80010378:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    XREG(A0) = sbi_getchar();
    8001037c:	0c6090ef          	jal	ra,80019442 <sbi_getchar>
    80010380:	87aa                	mv	a5,a0
    80010382:	873e                	mv	a4,a5
    80010384:	fd843783          	ld	a5,-40(s0)
    80010388:	05078793          	addi	a5,a5,80
    8001038c:	e398                	sd	a4,0(a5)
}
    8001038e:	0001                	nop
    80010390:	70a2                	ld	ra,40(sp)
    80010392:	7402                	ld	s0,32(sp)
    80010394:	6145                	addi	sp,sp,48
    80010396:	8082                	ret

0000000080010398 <syscall_yield>:

SYSCALL(yield)
{
    80010398:	7179                	addi	sp,sp,-48
    8001039a:	f422                	sd	s0,40(sp)
    8001039c:	1800                	addi	s0,sp,48
    8001039e:	87aa                	mv	a5,a0
    800103a0:	feb43023          	sd	a1,-32(s0)
    800103a4:	fcc43c23          	sd	a2,-40(s0)
    800103a8:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // sched_invoke(hart);
}
    800103ac:	0001                	nop
    800103ae:	7422                	ld	s0,40(sp)
    800103b0:	6145                	addi	sp,sp,48
    800103b2:	8082                	ret

00000000800103b4 <syscall_sleep>:

SYSCALL(sleep)
{
    800103b4:	7179                	addi	sp,sp,-48
    800103b6:	f422                	sd	s0,40(sp)
    800103b8:	1800                	addi	s0,sp,48
    800103ba:	87aa                	mv	a5,a0
    800103bc:	feb43023          	sd	a1,-32(s0)
    800103c0:	fcc43c23          	sd	a2,-40(s0)
    800103c4:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Sleep the process. VIRT_TIMER_FREQ is 10MHz, divided by 1000, we get 10KHz
    //     p->sleep_until = sbi_get_time() + XREG(A0) * VIRT_TIMER_FREQ / 1000;
    //     p->state = PS_SLEEPING;
}
    800103c8:	0001                	nop
    800103ca:	7422                	ld	s0,40(sp)
    800103cc:	6145                	addi	sp,sp,48
    800103ce:	8082                	ret

00000000800103d0 <syscall_events>:

SYSCALL(events)
{
    800103d0:	7179                	addi	sp,sp,-48
    800103d2:	f422                	sd	s0,40(sp)
    800103d4:	1800                	addi	s0,sp,48
    800103d6:	87aa                	mv	a5,a0
    800103d8:	feb43023          	sd	a1,-32(s0)
    800103dc:	fcc43c23          	sd	a2,-40(s0)
    800103e0:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    
}
    800103e4:	0001                	nop
    800103e6:	7422                	ld	s0,40(sp)
    800103e8:	6145                	addi	sp,sp,48
    800103ea:	8082                	ret

00000000800103ec <syscall_handle>:

static const int NUM_SYSCALLS = sizeof(SYSCALLS) / sizeof(SYSCALLS[0]);

// We get here from the trap.c if this is an ECALL from U-MODE
void syscall_handle(int hart, uint64_t epc, int64_t *scratch)
{
    800103ec:	7179                	addi	sp,sp,-48
    800103ee:	f406                	sd	ra,40(sp)
    800103f0:	f022                	sd	s0,32(sp)
    800103f2:	1800                	addi	s0,sp,48
    800103f4:	87aa                	mv	a5,a0
    800103f6:	feb43023          	sd	a1,-32(s0)
    800103fa:	fcc43c23          	sd	a2,-40(s0)
    800103fe:	fef42623          	sw	a5,-20(s0)
    // Sched invoke will save sepc, so we want it to resume
    // 4 bytes ahead, which will be the next instruction.
    CSR_WRITE("sepc", epc + 4);
    80010402:	fe043783          	ld	a5,-32(s0)
    80010406:	0791                	addi	a5,a5,4
    80010408:	14179073          	csrw	sepc,a5

    if (XREG(A7) >= NUM_SYSCALLS || SYSCALLS[XREG(A7)] == NULL) {
    8001040c:	fd843783          	ld	a5,-40(s0)
    80010410:	08878793          	addi	a5,a5,136
    80010414:	639c                	ld	a5,0(a5)
    80010416:	4719                	li	a4,6
    80010418:	00e7df63          	bge	a5,a4,80010436 <syscall_handle+0x4a>
    8001041c:	fd843783          	ld	a5,-40(s0)
    80010420:	08878793          	addi	a5,a5,136
    80010424:	639c                	ld	a5,0(a5)
    80010426:	00011717          	auipc	a4,0x11
    8001042a:	bda70713          	addi	a4,a4,-1062 # 80021000 <SYSCALLS>
    8001042e:	078e                	slli	a5,a5,0x3
    80010430:	97ba                	add	a5,a5,a4
    80010432:	639c                	ld	a5,0(a5)
    80010434:	eb81                	bnez	a5,80010444 <syscall_handle+0x58>
        // Invalid syscall
        XREG(A0) = -EINVAL;
    80010436:	fd843783          	ld	a5,-40(s0)
    8001043a:	05078793          	addi	a5,a5,80
    8001043e:	5729                	li	a4,-22
    80010440:	e398                	sd	a4,0(a5)
    80010442:	a035                	j	8001046e <syscall_handle+0x82>
    }
    else {
        SYSCALL_EXEC(XREG(A7));
    80010444:	fd843783          	ld	a5,-40(s0)
    80010448:	08878793          	addi	a5,a5,136
    8001044c:	639c                	ld	a5,0(a5)
    8001044e:	00011717          	auipc	a4,0x11
    80010452:	bb270713          	addi	a4,a4,-1102 # 80021000 <SYSCALLS>
    80010456:	078e                	slli	a5,a5,0x3
    80010458:	97ba                	add	a5,a5,a4
    8001045a:	6398                	ld	a4,0(a5)
    8001045c:	fec42783          	lw	a5,-20(s0)
    80010460:	fd843603          	ld	a2,-40(s0)
    80010464:	fe043583          	ld	a1,-32(s0)
    80010468:	853e                	mv	a0,a5
    8001046a:	9702                	jalr	a4
    }
}
    8001046c:	0001                	nop
    8001046e:	0001                	nop
    80010470:	70a2                	ld	ra,40(sp)
    80010472:	7402                	ld	s0,32(sp)
    80010474:	6145                	addi	sp,sp,48
    80010476:	8082                	ret

0000000080010478 <_putchar>:
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#include "sbi.h"
void _putchar(char c) { sbi_putchar(c); }
    80010478:	1101                	addi	sp,sp,-32
    8001047a:	ec06                	sd	ra,24(sp)
    8001047c:	e822                	sd	s0,16(sp)
    8001047e:	1000                	addi	s0,sp,32
    80010480:	87aa                	mv	a5,a0
    80010482:	fef407a3          	sb	a5,-17(s0)
    80010486:	fef44783          	lbu	a5,-17(s0)
    8001048a:	853e                	mv	a0,a5
    8001048c:	795080ef          	jal	ra,80019420 <sbi_putchar>
    80010490:	0001                	nop
    80010492:	60e2                	ld	ra,24(sp)
    80010494:	6442                	ld	s0,16(sp)
    80010496:	6105                	addi	sp,sp,32
    80010498:	8082                	ret

000000008001049a <_out_buffer>:
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx,
                               size_t maxlen)
{
    8001049a:	7179                	addi	sp,sp,-48
    8001049c:	f422                	sd	s0,40(sp)
    8001049e:	1800                	addi	s0,sp,48
    800104a0:	87aa                	mv	a5,a0
    800104a2:	feb43023          	sd	a1,-32(s0)
    800104a6:	fcc43c23          	sd	a2,-40(s0)
    800104aa:	fcd43823          	sd	a3,-48(s0)
    800104ae:	fef407a3          	sb	a5,-17(s0)
    if (idx < maxlen) {
    800104b2:	fd843703          	ld	a4,-40(s0)
    800104b6:	fd043783          	ld	a5,-48(s0)
    800104ba:	00f77b63          	bgeu	a4,a5,800104d0 <_out_buffer+0x36>
        ((char *)buffer)[idx] = character;
    800104be:	fe043703          	ld	a4,-32(s0)
    800104c2:	fd843783          	ld	a5,-40(s0)
    800104c6:	97ba                	add	a5,a5,a4
    800104c8:	fef44703          	lbu	a4,-17(s0)
    800104cc:	00e78023          	sb	a4,0(a5)
    }
}
    800104d0:	0001                	nop
    800104d2:	7422                	ld	s0,40(sp)
    800104d4:	6145                	addi	sp,sp,48
    800104d6:	8082                	ret

00000000800104d8 <_out_null>:

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800104d8:	7179                	addi	sp,sp,-48
    800104da:	f422                	sd	s0,40(sp)
    800104dc:	1800                	addi	s0,sp,48
    800104de:	87aa                	mv	a5,a0
    800104e0:	feb43023          	sd	a1,-32(s0)
    800104e4:	fcc43c23          	sd	a2,-40(s0)
    800104e8:	fcd43823          	sd	a3,-48(s0)
    800104ec:	fef407a3          	sb	a5,-17(s0)
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}
    800104f0:	0001                	nop
    800104f2:	7422                	ld	s0,40(sp)
    800104f4:	6145                	addi	sp,sp,48
    800104f6:	8082                	ret

00000000800104f8 <_out_char>:

// internal _putchar wrapper
static inline void _out_char(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800104f8:	7179                	addi	sp,sp,-48
    800104fa:	f406                	sd	ra,40(sp)
    800104fc:	f022                	sd	s0,32(sp)
    800104fe:	1800                	addi	s0,sp,48
    80010500:	87aa                	mv	a5,a0
    80010502:	feb43023          	sd	a1,-32(s0)
    80010506:	fcc43c23          	sd	a2,-40(s0)
    8001050a:	fcd43823          	sd	a3,-48(s0)
    8001050e:	fef407a3          	sb	a5,-17(s0)
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
    80010512:	fef44783          	lbu	a5,-17(s0)
    80010516:	0ff7f793          	andi	a5,a5,255
    8001051a:	c791                	beqz	a5,80010526 <_out_char+0x2e>
        _putchar(character);
    8001051c:	fef44783          	lbu	a5,-17(s0)
    80010520:	853e                	mv	a0,a5
    80010522:	f57ff0ef          	jal	ra,80010478 <_putchar>
    }
}
    80010526:	0001                	nop
    80010528:	70a2                	ld	ra,40(sp)
    8001052a:	7402                	ld	s0,32(sp)
    8001052c:	6145                	addi	sp,sp,48
    8001052e:	8082                	ret

0000000080010530 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx,
                            size_t maxlen)
{
    80010530:	7179                	addi	sp,sp,-48
    80010532:	f406                	sd	ra,40(sp)
    80010534:	f022                	sd	s0,32(sp)
    80010536:	1800                	addi	s0,sp,48
    80010538:	87aa                	mv	a5,a0
    8001053a:	feb43023          	sd	a1,-32(s0)
    8001053e:	fcc43c23          	sd	a2,-40(s0)
    80010542:	fcd43823          	sd	a3,-48(s0)
    80010546:	fef407a3          	sb	a5,-17(s0)
    (void)idx;
    (void)maxlen;
    if (character) {
    8001054a:	fef44783          	lbu	a5,-17(s0)
    8001054e:	0ff7f793          	andi	a5,a5,255
    80010552:	cf81                	beqz	a5,8001056a <_out_fct+0x3a>
        // buffer is the output fct pointer
        ((out_fct_wrap_type *)buffer)
            ->fct(character, ((out_fct_wrap_type *)buffer)->arg);
    80010554:	fe043783          	ld	a5,-32(s0)
    80010558:	6394                	ld	a3,0(a5)
        ((out_fct_wrap_type *)buffer)
    8001055a:	fe043783          	ld	a5,-32(s0)
    8001055e:	6798                	ld	a4,8(a5)
    80010560:	fef44783          	lbu	a5,-17(s0)
    80010564:	85ba                	mv	a1,a4
    80010566:	853e                	mv	a0,a5
    80010568:	9682                	jalr	a3
    }
}
    8001056a:	0001                	nop
    8001056c:	70a2                	ld	ra,40(sp)
    8001056e:	7402                	ld	s0,32(sp)
    80010570:	6145                	addi	sp,sp,48
    80010572:	8082                	ret

0000000080010574 <_strnlen_s>:

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize)
{
    80010574:	7179                	addi	sp,sp,-48
    80010576:	f422                	sd	s0,40(sp)
    80010578:	1800                	addi	s0,sp,48
    8001057a:	fca43c23          	sd	a0,-40(s0)
    8001057e:	fcb43823          	sd	a1,-48(s0)
    const char *s;
    for (s = str; *s && maxsize--; ++s)
    80010582:	fd843783          	ld	a5,-40(s0)
    80010586:	fef43423          	sd	a5,-24(s0)
    8001058a:	a031                	j	80010596 <_strnlen_s+0x22>
    8001058c:	fe843783          	ld	a5,-24(s0)
    80010590:	0785                	addi	a5,a5,1
    80010592:	fef43423          	sd	a5,-24(s0)
    80010596:	fe843783          	ld	a5,-24(s0)
    8001059a:	0007c783          	lbu	a5,0(a5)
    8001059e:	cb81                	beqz	a5,800105ae <_strnlen_s+0x3a>
    800105a0:	fd043783          	ld	a5,-48(s0)
    800105a4:	fff78713          	addi	a4,a5,-1
    800105a8:	fce43823          	sd	a4,-48(s0)
    800105ac:	f3e5                	bnez	a5,8001058c <_strnlen_s+0x18>
        ;
    return (unsigned int)(s - str);
    800105ae:	fe843703          	ld	a4,-24(s0)
    800105b2:	fd843783          	ld	a5,-40(s0)
    800105b6:	40f707b3          	sub	a5,a4,a5
    800105ba:	2781                	sext.w	a5,a5
}
    800105bc:	853e                	mv	a0,a5
    800105be:	7422                	ld	s0,40(sp)
    800105c0:	6145                	addi	sp,sp,48
    800105c2:	8082                	ret

00000000800105c4 <_is_digit>:

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) { return (ch >= '0') && (ch <= '9'); }
    800105c4:	1101                	addi	sp,sp,-32
    800105c6:	ec22                	sd	s0,24(sp)
    800105c8:	1000                	addi	s0,sp,32
    800105ca:	87aa                	mv	a5,a0
    800105cc:	fef407a3          	sb	a5,-17(s0)
    800105d0:	fef44783          	lbu	a5,-17(s0)
    800105d4:	0ff7f713          	andi	a4,a5,255
    800105d8:	02f00793          	li	a5,47
    800105dc:	00e7fc63          	bgeu	a5,a4,800105f4 <_is_digit+0x30>
    800105e0:	fef44783          	lbu	a5,-17(s0)
    800105e4:	0ff7f713          	andi	a4,a5,255
    800105e8:	03900793          	li	a5,57
    800105ec:	00e7e463          	bltu	a5,a4,800105f4 <_is_digit+0x30>
    800105f0:	4785                	li	a5,1
    800105f2:	a011                	j	800105f6 <_is_digit+0x32>
    800105f4:	4781                	li	a5,0
    800105f6:	8b85                	andi	a5,a5,1
    800105f8:	0ff7f793          	andi	a5,a5,255
    800105fc:	853e                	mv	a0,a5
    800105fe:	6462                	ld	s0,24(sp)
    80010600:	6105                	addi	sp,sp,32
    80010602:	8082                	ret

0000000080010604 <_atoi>:

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str)
{
    80010604:	7179                	addi	sp,sp,-48
    80010606:	f406                	sd	ra,40(sp)
    80010608:	f022                	sd	s0,32(sp)
    8001060a:	1800                	addi	s0,sp,48
    8001060c:	fca43c23          	sd	a0,-40(s0)
    unsigned int i = 0U;
    80010610:	fe042623          	sw	zero,-20(s0)
    while (_is_digit(**str)) {
    80010614:	a825                	j	8001064c <_atoi+0x48>
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
    80010616:	fec42703          	lw	a4,-20(s0)
    8001061a:	87ba                	mv	a5,a4
    8001061c:	0027979b          	slliw	a5,a5,0x2
    80010620:	9fb9                	addw	a5,a5,a4
    80010622:	0017979b          	slliw	a5,a5,0x1
    80010626:	0007871b          	sext.w	a4,a5
    8001062a:	fd843783          	ld	a5,-40(s0)
    8001062e:	639c                	ld	a5,0(a5)
    80010630:	00178613          	addi	a2,a5,1
    80010634:	fd843683          	ld	a3,-40(s0)
    80010638:	e290                	sd	a2,0(a3)
    8001063a:	0007c783          	lbu	a5,0(a5)
    8001063e:	2781                	sext.w	a5,a5
    80010640:	9fb9                	addw	a5,a5,a4
    80010642:	2781                	sext.w	a5,a5
    80010644:	fd07879b          	addiw	a5,a5,-48
    80010648:	fef42623          	sw	a5,-20(s0)
    while (_is_digit(**str)) {
    8001064c:	fd843783          	ld	a5,-40(s0)
    80010650:	639c                	ld	a5,0(a5)
    80010652:	0007c783          	lbu	a5,0(a5)
    80010656:	853e                	mv	a0,a5
    80010658:	f6dff0ef          	jal	ra,800105c4 <_is_digit>
    8001065c:	87aa                	mv	a5,a0
    8001065e:	ffc5                	bnez	a5,80010616 <_atoi+0x12>
    }
    return i;
    80010660:	fec42783          	lw	a5,-20(s0)
}
    80010664:	853e                	mv	a0,a5
    80010666:	70a2                	ld	ra,40(sp)
    80010668:	7402                	ld	s0,32(sp)
    8001066a:	6145                	addi	sp,sp,48
    8001066c:	8082                	ret

000000008001066e <_out_rev>:

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx,
                       size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags)
{
    8001066e:	711d                	addi	sp,sp,-96
    80010670:	ec86                	sd	ra,88(sp)
    80010672:	e8a2                	sd	s0,80(sp)
    80010674:	1080                	addi	s0,sp,96
    80010676:	fca43c23          	sd	a0,-40(s0)
    8001067a:	fcb43823          	sd	a1,-48(s0)
    8001067e:	fcc43423          	sd	a2,-56(s0)
    80010682:	fcd43023          	sd	a3,-64(s0)
    80010686:	fae43c23          	sd	a4,-72(s0)
    8001068a:	faf43823          	sd	a5,-80(s0)
    8001068e:	87c2                	mv	a5,a6
    80010690:	8746                	mv	a4,a7
    80010692:	faf42623          	sw	a5,-84(s0)
    80010696:	87ba                	mv	a5,a4
    80010698:	faf42423          	sw	a5,-88(s0)
    const size_t start_idx = idx;
    8001069c:	fc843783          	ld	a5,-56(s0)
    800106a0:	fef43023          	sd	a5,-32(s0)

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    800106a4:	fa842783          	lw	a5,-88(s0)
    800106a8:	8b89                	andi	a5,a5,2
    800106aa:	2781                	sext.w	a5,a5
    800106ac:	e3c9                	bnez	a5,8001072e <_out_rev+0xc0>
    800106ae:	fa842783          	lw	a5,-88(s0)
    800106b2:	8b85                	andi	a5,a5,1
    800106b4:	2781                	sext.w	a5,a5
    800106b6:	efa5                	bnez	a5,8001072e <_out_rev+0xc0>
        for (size_t i = len; i < width; i++) {
    800106b8:	fb043783          	ld	a5,-80(s0)
    800106bc:	fef43423          	sd	a5,-24(s0)
    800106c0:	a035                	j	800106ec <_out_rev+0x7e>
            out(' ', buffer, idx++, maxlen);
    800106c2:	fc843783          	ld	a5,-56(s0)
    800106c6:	00178713          	addi	a4,a5,1
    800106ca:	fce43423          	sd	a4,-56(s0)
    800106ce:	fd843703          	ld	a4,-40(s0)
    800106d2:	fc043683          	ld	a3,-64(s0)
    800106d6:	863e                	mv	a2,a5
    800106d8:	fd043583          	ld	a1,-48(s0)
    800106dc:	02000513          	li	a0,32
    800106e0:	9702                	jalr	a4
        for (size_t i = len; i < width; i++) {
    800106e2:	fe843783          	ld	a5,-24(s0)
    800106e6:	0785                	addi	a5,a5,1
    800106e8:	fef43423          	sd	a5,-24(s0)
    800106ec:	fac46783          	lwu	a5,-84(s0)
    800106f0:	fe843703          	ld	a4,-24(s0)
    800106f4:	fcf767e3          	bltu	a4,a5,800106c2 <_out_rev+0x54>
        }
    }

    // reverse string
    while (len) {
    800106f8:	a81d                	j	8001072e <_out_rev+0xc0>
        out(buf[--len], buffer, idx++, maxlen);
    800106fa:	fb043783          	ld	a5,-80(s0)
    800106fe:	17fd                	addi	a5,a5,-1
    80010700:	faf43823          	sd	a5,-80(s0)
    80010704:	fb843703          	ld	a4,-72(s0)
    80010708:	fb043783          	ld	a5,-80(s0)
    8001070c:	97ba                	add	a5,a5,a4
    8001070e:	0007c503          	lbu	a0,0(a5)
    80010712:	fc843783          	ld	a5,-56(s0)
    80010716:	00178713          	addi	a4,a5,1
    8001071a:	fce43423          	sd	a4,-56(s0)
    8001071e:	fd843703          	ld	a4,-40(s0)
    80010722:	fc043683          	ld	a3,-64(s0)
    80010726:	863e                	mv	a2,a5
    80010728:	fd043583          	ld	a1,-48(s0)
    8001072c:	9702                	jalr	a4
    while (len) {
    8001072e:	fb043783          	ld	a5,-80(s0)
    80010732:	f7e1                	bnez	a5,800106fa <_out_rev+0x8c>
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
    80010734:	fa842783          	lw	a5,-88(s0)
    80010738:	8b89                	andi	a5,a5,2
    8001073a:	2781                	sext.w	a5,a5
    8001073c:	cb9d                	beqz	a5,80010772 <_out_rev+0x104>
        while (idx - start_idx < width) {
    8001073e:	a00d                	j	80010760 <_out_rev+0xf2>
            out(' ', buffer, idx++, maxlen);
    80010740:	fc843783          	ld	a5,-56(s0)
    80010744:	00178713          	addi	a4,a5,1
    80010748:	fce43423          	sd	a4,-56(s0)
    8001074c:	fd843703          	ld	a4,-40(s0)
    80010750:	fc043683          	ld	a3,-64(s0)
    80010754:	863e                	mv	a2,a5
    80010756:	fd043583          	ld	a1,-48(s0)
    8001075a:	02000513          	li	a0,32
    8001075e:	9702                	jalr	a4
        while (idx - start_idx < width) {
    80010760:	fc843703          	ld	a4,-56(s0)
    80010764:	fe043783          	ld	a5,-32(s0)
    80010768:	8f1d                	sub	a4,a4,a5
    8001076a:	fac46783          	lwu	a5,-84(s0)
    8001076e:	fcf769e3          	bltu	a4,a5,80010740 <_out_rev+0xd2>
        }
    }

    return idx;
    80010772:	fc843783          	ld	a5,-56(s0)
}
    80010776:	853e                	mv	a0,a5
    80010778:	60e6                	ld	ra,88(sp)
    8001077a:	6446                	ld	s0,80(sp)
    8001077c:	6125                	addi	sp,sp,96
    8001077e:	8082                	ret

0000000080010780 <_ntoa_format>:
// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx,
                           size_t maxlen, char *buf, size_t len, bool negative,
                           unsigned int base, unsigned int prec,
                           unsigned int width, unsigned int flags)
{
    80010780:	715d                	addi	sp,sp,-80
    80010782:	e486                	sd	ra,72(sp)
    80010784:	e0a2                	sd	s0,64(sp)
    80010786:	0880                	addi	s0,sp,80
    80010788:	fea43423          	sd	a0,-24(s0)
    8001078c:	feb43023          	sd	a1,-32(s0)
    80010790:	fcc43c23          	sd	a2,-40(s0)
    80010794:	fcd43823          	sd	a3,-48(s0)
    80010798:	fce43423          	sd	a4,-56(s0)
    8001079c:	fcf43023          	sd	a5,-64(s0)
    800107a0:	87c2                	mv	a5,a6
    800107a2:	8746                	mv	a4,a7
    800107a4:	faf40fa3          	sb	a5,-65(s0)
    800107a8:	87ba                	mv	a5,a4
    800107aa:	faf42c23          	sw	a5,-72(s0)
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
    800107ae:	481c                	lw	a5,16(s0)
    800107b0:	8b89                	andi	a5,a5,2
    800107b2:	2781                	sext.w	a5,a5
    800107b4:	ebd1                	bnez	a5,80010848 <_ntoa_format+0xc8>
        if (width && (flags & FLAGS_ZEROPAD) &&
    800107b6:	441c                	lw	a5,8(s0)
    800107b8:	2781                	sext.w	a5,a5
    800107ba:	cf9d                	beqz	a5,800107f8 <_ntoa_format+0x78>
    800107bc:	481c                	lw	a5,16(s0)
    800107be:	8b85                	andi	a5,a5,1
    800107c0:	2781                	sext.w	a5,a5
    800107c2:	cb9d                	beqz	a5,800107f8 <_ntoa_format+0x78>
    800107c4:	fbf44783          	lbu	a5,-65(s0)
    800107c8:	0ff7f793          	andi	a5,a5,255
    800107cc:	e789                	bnez	a5,800107d6 <_ntoa_format+0x56>
            (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    800107ce:	481c                	lw	a5,16(s0)
    800107d0:	8bb1                	andi	a5,a5,12
    800107d2:	2781                	sext.w	a5,a5
    800107d4:	c395                	beqz	a5,800107f8 <_ntoa_format+0x78>
            width--;
    800107d6:	441c                	lw	a5,8(s0)
    800107d8:	37fd                	addiw	a5,a5,-1
    800107da:	c41c                	sw	a5,8(s0)
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800107dc:	a831                	j	800107f8 <_ntoa_format+0x78>
            buf[len++] = '0';
    800107de:	fc043783          	ld	a5,-64(s0)
    800107e2:	00178713          	addi	a4,a5,1
    800107e6:	fce43023          	sd	a4,-64(s0)
    800107ea:	fc843703          	ld	a4,-56(s0)
    800107ee:	97ba                	add	a5,a5,a4
    800107f0:	03000713          	li	a4,48
    800107f4:	00e78023          	sb	a4,0(a5)
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800107f8:	00046783          	lwu	a5,0(s0)
    800107fc:	fc043703          	ld	a4,-64(s0)
    80010800:	02f77563          	bgeu	a4,a5,8001082a <_ntoa_format+0xaa>
    80010804:	fc043703          	ld	a4,-64(s0)
    80010808:	47fd                	li	a5,31
    8001080a:	fce7fae3          	bgeu	a5,a4,800107de <_ntoa_format+0x5e>
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    8001080e:	a831                	j	8001082a <_ntoa_format+0xaa>
               (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
    80010810:	fc043783          	ld	a5,-64(s0)
    80010814:	00178713          	addi	a4,a5,1
    80010818:	fce43023          	sd	a4,-64(s0)
    8001081c:	fc843703          	ld	a4,-56(s0)
    80010820:	97ba                	add	a5,a5,a4
    80010822:	03000713          	li	a4,48
    80010826:	00e78023          	sb	a4,0(a5)
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    8001082a:	481c                	lw	a5,16(s0)
    8001082c:	8b85                	andi	a5,a5,1
    8001082e:	2781                	sext.w	a5,a5
    80010830:	cf81                	beqz	a5,80010848 <_ntoa_format+0xc8>
    80010832:	00846783          	lwu	a5,8(s0)
    80010836:	fc043703          	ld	a4,-64(s0)
    8001083a:	00f77763          	bgeu	a4,a5,80010848 <_ntoa_format+0xc8>
    8001083e:	fc043703          	ld	a4,-64(s0)
    80010842:	47fd                	li	a5,31
    80010844:	fce7f6e3          	bgeu	a5,a4,80010810 <_ntoa_format+0x90>
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
    80010848:	481c                	lw	a5,16(s0)
    8001084a:	8bc1                	andi	a5,a5,16
    8001084c:	2781                	sext.w	a5,a5
    8001084e:	12078363          	beqz	a5,80010974 <_ntoa_format+0x1f4>
        if (!(flags & FLAGS_PRECISION) && len &&
    80010852:	481c                	lw	a5,16(s0)
    80010854:	4007f793          	andi	a5,a5,1024
    80010858:	2781                	sext.w	a5,a5
    8001085a:	e7a1                	bnez	a5,800108a2 <_ntoa_format+0x122>
    8001085c:	fc043783          	ld	a5,-64(s0)
    80010860:	c3a9                	beqz	a5,800108a2 <_ntoa_format+0x122>
            ((len == prec) || (len == width))) {
    80010862:	00046783          	lwu	a5,0(s0)
        if (!(flags & FLAGS_PRECISION) && len &&
    80010866:	fc043703          	ld	a4,-64(s0)
    8001086a:	00f70863          	beq	a4,a5,8001087a <_ntoa_format+0xfa>
            ((len == prec) || (len == width))) {
    8001086e:	00846783          	lwu	a5,8(s0)
    80010872:	fc043703          	ld	a4,-64(s0)
    80010876:	02f71663          	bne	a4,a5,800108a2 <_ntoa_format+0x122>
            len--;
    8001087a:	fc043783          	ld	a5,-64(s0)
    8001087e:	17fd                	addi	a5,a5,-1
    80010880:	fcf43023          	sd	a5,-64(s0)
            if (len && (base == 16U)) {
    80010884:	fc043783          	ld	a5,-64(s0)
    80010888:	cf89                	beqz	a5,800108a2 <_ntoa_format+0x122>
    8001088a:	fb842783          	lw	a5,-72(s0)
    8001088e:	0007871b          	sext.w	a4,a5
    80010892:	47c1                	li	a5,16
    80010894:	00f71763          	bne	a4,a5,800108a2 <_ntoa_format+0x122>
                len--;
    80010898:	fc043783          	ld	a5,-64(s0)
    8001089c:	17fd                	addi	a5,a5,-1
    8001089e:	fcf43023          	sd	a5,-64(s0)
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) &&
    800108a2:	fb842783          	lw	a5,-72(s0)
    800108a6:	0007871b          	sext.w	a4,a5
    800108aa:	47c1                	li	a5,16
    800108ac:	02f71a63          	bne	a4,a5,800108e0 <_ntoa_format+0x160>
    800108b0:	481c                	lw	a5,16(s0)
    800108b2:	0207f793          	andi	a5,a5,32
    800108b6:	2781                	sext.w	a5,a5
    800108b8:	e785                	bnez	a5,800108e0 <_ntoa_format+0x160>
    800108ba:	fc043703          	ld	a4,-64(s0)
    800108be:	47fd                	li	a5,31
    800108c0:	02e7e063          	bltu	a5,a4,800108e0 <_ntoa_format+0x160>
            (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'x';
    800108c4:	fc043783          	ld	a5,-64(s0)
    800108c8:	00178713          	addi	a4,a5,1
    800108cc:	fce43023          	sd	a4,-64(s0)
    800108d0:	fc843703          	ld	a4,-56(s0)
    800108d4:	97ba                	add	a5,a5,a4
    800108d6:	07800713          	li	a4,120
    800108da:	00e78023          	sb	a4,0(a5)
    800108de:	a88d                	j	80010950 <_ntoa_format+0x1d0>
        }
        else if ((base == 16U) && (flags & FLAGS_UPPERCASE) &&
    800108e0:	fb842783          	lw	a5,-72(s0)
    800108e4:	0007871b          	sext.w	a4,a5
    800108e8:	47c1                	li	a5,16
    800108ea:	02f71a63          	bne	a4,a5,8001091e <_ntoa_format+0x19e>
    800108ee:	481c                	lw	a5,16(s0)
    800108f0:	0207f793          	andi	a5,a5,32
    800108f4:	2781                	sext.w	a5,a5
    800108f6:	c785                	beqz	a5,8001091e <_ntoa_format+0x19e>
    800108f8:	fc043703          	ld	a4,-64(s0)
    800108fc:	47fd                	li	a5,31
    800108fe:	02e7e063          	bltu	a5,a4,8001091e <_ntoa_format+0x19e>
                 (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'X';
    80010902:	fc043783          	ld	a5,-64(s0)
    80010906:	00178713          	addi	a4,a5,1
    8001090a:	fce43023          	sd	a4,-64(s0)
    8001090e:	fc843703          	ld	a4,-56(s0)
    80010912:	97ba                	add	a5,a5,a4
    80010914:	05800713          	li	a4,88
    80010918:	00e78023          	sb	a4,0(a5)
    8001091c:	a815                	j	80010950 <_ntoa_format+0x1d0>
        }
        else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    8001091e:	fb842783          	lw	a5,-72(s0)
    80010922:	0007871b          	sext.w	a4,a5
    80010926:	4789                	li	a5,2
    80010928:	02f71463          	bne	a4,a5,80010950 <_ntoa_format+0x1d0>
    8001092c:	fc043703          	ld	a4,-64(s0)
    80010930:	47fd                	li	a5,31
    80010932:	00e7ef63          	bltu	a5,a4,80010950 <_ntoa_format+0x1d0>
            buf[len++] = 'b';
    80010936:	fc043783          	ld	a5,-64(s0)
    8001093a:	00178713          	addi	a4,a5,1
    8001093e:	fce43023          	sd	a4,-64(s0)
    80010942:	fc843703          	ld	a4,-56(s0)
    80010946:	97ba                	add	a5,a5,a4
    80010948:	06200713          	li	a4,98
    8001094c:	00e78023          	sb	a4,0(a5)
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80010950:	fc043703          	ld	a4,-64(s0)
    80010954:	47fd                	li	a5,31
    80010956:	00e7ef63          	bltu	a5,a4,80010974 <_ntoa_format+0x1f4>
            buf[len++] = '0';
    8001095a:	fc043783          	ld	a5,-64(s0)
    8001095e:	00178713          	addi	a4,a5,1
    80010962:	fce43023          	sd	a4,-64(s0)
    80010966:	fc843703          	ld	a4,-56(s0)
    8001096a:	97ba                	add	a5,a5,a4
    8001096c:	03000713          	li	a4,48
    80010970:	00e78023          	sb	a4,0(a5)
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80010974:	fc043703          	ld	a4,-64(s0)
    80010978:	47fd                	li	a5,31
    8001097a:	06e7e863          	bltu	a5,a4,800109ea <_ntoa_format+0x26a>
        if (negative) {
    8001097e:	fbf44783          	lbu	a5,-65(s0)
    80010982:	0ff7f793          	andi	a5,a5,255
    80010986:	cf99                	beqz	a5,800109a4 <_ntoa_format+0x224>
            buf[len++] = '-';
    80010988:	fc043783          	ld	a5,-64(s0)
    8001098c:	00178713          	addi	a4,a5,1
    80010990:	fce43023          	sd	a4,-64(s0)
    80010994:	fc843703          	ld	a4,-56(s0)
    80010998:	97ba                	add	a5,a5,a4
    8001099a:	02d00713          	li	a4,45
    8001099e:	00e78023          	sb	a4,0(a5)
    800109a2:	a0a1                	j	800109ea <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_PLUS) {
    800109a4:	481c                	lw	a5,16(s0)
    800109a6:	8b91                	andi	a5,a5,4
    800109a8:	2781                	sext.w	a5,a5
    800109aa:	cf99                	beqz	a5,800109c8 <_ntoa_format+0x248>
            buf[len++] = '+';  // ignore the space if the '+' exists
    800109ac:	fc043783          	ld	a5,-64(s0)
    800109b0:	00178713          	addi	a4,a5,1
    800109b4:	fce43023          	sd	a4,-64(s0)
    800109b8:	fc843703          	ld	a4,-56(s0)
    800109bc:	97ba                	add	a5,a5,a4
    800109be:	02b00713          	li	a4,43
    800109c2:	00e78023          	sb	a4,0(a5)
    800109c6:	a015                	j	800109ea <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_SPACE) {
    800109c8:	481c                	lw	a5,16(s0)
    800109ca:	8ba1                	andi	a5,a5,8
    800109cc:	2781                	sext.w	a5,a5
    800109ce:	cf91                	beqz	a5,800109ea <_ntoa_format+0x26a>
            buf[len++] = ' ';
    800109d0:	fc043783          	ld	a5,-64(s0)
    800109d4:	00178713          	addi	a4,a5,1
    800109d8:	fce43023          	sd	a4,-64(s0)
    800109dc:	fc843703          	ld	a4,-56(s0)
    800109e0:	97ba                	add	a5,a5,a4
    800109e2:	02000713          	li	a4,32
    800109e6:	00e78023          	sb	a4,0(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    800109ea:	4818                	lw	a4,16(s0)
    800109ec:	441c                	lw	a5,8(s0)
    800109ee:	88ba                	mv	a7,a4
    800109f0:	883e                	mv	a6,a5
    800109f2:	fc043783          	ld	a5,-64(s0)
    800109f6:	fc843703          	ld	a4,-56(s0)
    800109fa:	fd043683          	ld	a3,-48(s0)
    800109fe:	fd843603          	ld	a2,-40(s0)
    80010a02:	fe043583          	ld	a1,-32(s0)
    80010a06:	fe843503          	ld	a0,-24(s0)
    80010a0a:	c65ff0ef          	jal	ra,8001066e <_out_rev>
    80010a0e:	87aa                	mv	a5,a0
}
    80010a10:	853e                	mv	a0,a5
    80010a12:	60a6                	ld	ra,72(sp)
    80010a14:	6406                	ld	s0,64(sp)
    80010a16:	6161                	addi	sp,sp,80
    80010a18:	8082                	ret

0000000080010a1a <_ntoa_long>:
// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
                         size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec,
                         unsigned int width, unsigned int flags)
{
    80010a1a:	7135                	addi	sp,sp,-160
    80010a1c:	ed06                	sd	ra,152(sp)
    80010a1e:	e922                	sd	s0,144(sp)
    80010a20:	1100                	addi	s0,sp,160
    80010a22:	faa43c23          	sd	a0,-72(s0)
    80010a26:	fab43823          	sd	a1,-80(s0)
    80010a2a:	fac43423          	sd	a2,-88(s0)
    80010a2e:	fad43023          	sd	a3,-96(s0)
    80010a32:	f8e43c23          	sd	a4,-104(s0)
    80010a36:	f9043423          	sd	a6,-120(s0)
    80010a3a:	8746                	mv	a4,a7
    80010a3c:	f8f40ba3          	sb	a5,-105(s0)
    80010a40:	87ba                	mv	a5,a4
    80010a42:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80010a46:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80010a4a:	f9843783          	ld	a5,-104(s0)
    80010a4e:	e781                	bnez	a5,80010a56 <_ntoa_long+0x3c>
        flags &= ~FLAGS_HASH;
    80010a50:	441c                	lw	a5,8(s0)
    80010a52:	9bbd                	andi	a5,a5,-17
    80010a54:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80010a56:	441c                	lw	a5,8(s0)
    80010a58:	4007f793          	andi	a5,a5,1024
    80010a5c:	2781                	sext.w	a5,a5
    80010a5e:	c781                	beqz	a5,80010a66 <_ntoa_long+0x4c>
    80010a60:	f9843783          	ld	a5,-104(s0)
    80010a64:	c7c1                	beqz	a5,80010aec <_ntoa_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80010a66:	f9843703          	ld	a4,-104(s0)
    80010a6a:	f8843783          	ld	a5,-120(s0)
    80010a6e:	02f777b3          	remu	a5,a4,a5
    80010a72:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80010a76:	fe744783          	lbu	a5,-25(s0)
    80010a7a:	0ff7f713          	andi	a4,a5,255
    80010a7e:	47a5                	li	a5,9
    80010a80:	00e7e963          	bltu	a5,a4,80010a92 <_ntoa_long+0x78>
    80010a84:	fe744783          	lbu	a5,-25(s0)
    80010a88:	0307879b          	addiw	a5,a5,48
    80010a8c:	0ff7f793          	andi	a5,a5,255
    80010a90:	a01d                	j	80010ab6 <_ntoa_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80010a92:	441c                	lw	a5,8(s0)
    80010a94:	0207f793          	andi	a5,a5,32
    80010a98:	2781                	sext.w	a5,a5
    80010a9a:	c781                	beqz	a5,80010aa2 <_ntoa_long+0x88>
    80010a9c:	04100793          	li	a5,65
    80010aa0:	a019                	j	80010aa6 <_ntoa_long+0x8c>
    80010aa2:	06100793          	li	a5,97
    80010aa6:	fe744703          	lbu	a4,-25(s0)
    80010aaa:	9fb9                	addw	a5,a5,a4
    80010aac:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80010ab0:	37d9                	addiw	a5,a5,-10
    80010ab2:	0ff7f793          	andi	a5,a5,255
    80010ab6:	fe843703          	ld	a4,-24(s0)
    80010aba:	00170693          	addi	a3,a4,1
    80010abe:	fed43423          	sd	a3,-24(s0)
    80010ac2:	ff040693          	addi	a3,s0,-16
    80010ac6:	9736                	add	a4,a4,a3
    80010ac8:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010acc:	f9843703          	ld	a4,-104(s0)
    80010ad0:	f8843783          	ld	a5,-120(s0)
    80010ad4:	02f757b3          	divu	a5,a4,a5
    80010ad8:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010adc:	f9843783          	ld	a5,-104(s0)
    80010ae0:	c791                	beqz	a5,80010aec <_ntoa_long+0xd2>
    80010ae2:	fe843703          	ld	a4,-24(s0)
    80010ae6:	47fd                	li	a5,31
    80010ae8:	f6e7ffe3          	bgeu	a5,a4,80010a66 <_ntoa_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010aec:	f8843783          	ld	a5,-120(s0)
    80010af0:	0007861b          	sext.w	a2,a5
    80010af4:	f9744683          	lbu	a3,-105(s0)
    80010af8:	fc040713          	addi	a4,s0,-64
    80010afc:	441c                	lw	a5,8(s0)
    80010afe:	e83e                	sd	a5,16(sp)
    80010b00:	401c                	lw	a5,0(s0)
    80010b02:	e43e                	sd	a5,8(sp)
    80010b04:	f9042783          	lw	a5,-112(s0)
    80010b08:	e03e                	sd	a5,0(sp)
    80010b0a:	88b2                	mv	a7,a2
    80010b0c:	8836                	mv	a6,a3
    80010b0e:	fe843783          	ld	a5,-24(s0)
    80010b12:	fa043683          	ld	a3,-96(s0)
    80010b16:	fa843603          	ld	a2,-88(s0)
    80010b1a:	fb043583          	ld	a1,-80(s0)
    80010b1e:	fb843503          	ld	a0,-72(s0)
    80010b22:	c5fff0ef          	jal	ra,80010780 <_ntoa_format>
    80010b26:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010b28:	853e                	mv	a0,a5
    80010b2a:	60ea                	ld	ra,152(sp)
    80010b2c:	644a                	ld	s0,144(sp)
    80010b2e:	610d                	addi	sp,sp,160
    80010b30:	8082                	ret

0000000080010b32 <_ntoa_long_long>:
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
                              size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base,
                              unsigned int prec, unsigned int width,
                              unsigned int flags)
{
    80010b32:	7135                	addi	sp,sp,-160
    80010b34:	ed06                	sd	ra,152(sp)
    80010b36:	e922                	sd	s0,144(sp)
    80010b38:	1100                	addi	s0,sp,160
    80010b3a:	faa43c23          	sd	a0,-72(s0)
    80010b3e:	fab43823          	sd	a1,-80(s0)
    80010b42:	fac43423          	sd	a2,-88(s0)
    80010b46:	fad43023          	sd	a3,-96(s0)
    80010b4a:	f8e43c23          	sd	a4,-104(s0)
    80010b4e:	f9043423          	sd	a6,-120(s0)
    80010b52:	8746                	mv	a4,a7
    80010b54:	f8f40ba3          	sb	a5,-105(s0)
    80010b58:	87ba                	mv	a5,a4
    80010b5a:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80010b5e:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80010b62:	f9843783          	ld	a5,-104(s0)
    80010b66:	e781                	bnez	a5,80010b6e <_ntoa_long_long+0x3c>
        flags &= ~FLAGS_HASH;
    80010b68:	441c                	lw	a5,8(s0)
    80010b6a:	9bbd                	andi	a5,a5,-17
    80010b6c:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80010b6e:	441c                	lw	a5,8(s0)
    80010b70:	4007f793          	andi	a5,a5,1024
    80010b74:	2781                	sext.w	a5,a5
    80010b76:	c781                	beqz	a5,80010b7e <_ntoa_long_long+0x4c>
    80010b78:	f9843783          	ld	a5,-104(s0)
    80010b7c:	c7c1                	beqz	a5,80010c04 <_ntoa_long_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80010b7e:	f9843703          	ld	a4,-104(s0)
    80010b82:	f8843783          	ld	a5,-120(s0)
    80010b86:	02f777b3          	remu	a5,a4,a5
    80010b8a:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80010b8e:	fe744783          	lbu	a5,-25(s0)
    80010b92:	0ff7f713          	andi	a4,a5,255
    80010b96:	47a5                	li	a5,9
    80010b98:	00e7e963          	bltu	a5,a4,80010baa <_ntoa_long_long+0x78>
    80010b9c:	fe744783          	lbu	a5,-25(s0)
    80010ba0:	0307879b          	addiw	a5,a5,48
    80010ba4:	0ff7f793          	andi	a5,a5,255
    80010ba8:	a01d                	j	80010bce <_ntoa_long_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80010baa:	441c                	lw	a5,8(s0)
    80010bac:	0207f793          	andi	a5,a5,32
    80010bb0:	2781                	sext.w	a5,a5
    80010bb2:	c781                	beqz	a5,80010bba <_ntoa_long_long+0x88>
    80010bb4:	04100793          	li	a5,65
    80010bb8:	a019                	j	80010bbe <_ntoa_long_long+0x8c>
    80010bba:	06100793          	li	a5,97
    80010bbe:	fe744703          	lbu	a4,-25(s0)
    80010bc2:	9fb9                	addw	a5,a5,a4
    80010bc4:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80010bc8:	37d9                	addiw	a5,a5,-10
    80010bca:	0ff7f793          	andi	a5,a5,255
    80010bce:	fe843703          	ld	a4,-24(s0)
    80010bd2:	00170693          	addi	a3,a4,1
    80010bd6:	fed43423          	sd	a3,-24(s0)
    80010bda:	ff040693          	addi	a3,s0,-16
    80010bde:	9736                	add	a4,a4,a3
    80010be0:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010be4:	f9843703          	ld	a4,-104(s0)
    80010be8:	f8843783          	ld	a5,-120(s0)
    80010bec:	02f757b3          	divu	a5,a4,a5
    80010bf0:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010bf4:	f9843783          	ld	a5,-104(s0)
    80010bf8:	c791                	beqz	a5,80010c04 <_ntoa_long_long+0xd2>
    80010bfa:	fe843703          	ld	a4,-24(s0)
    80010bfe:	47fd                	li	a5,31
    80010c00:	f6e7ffe3          	bgeu	a5,a4,80010b7e <_ntoa_long_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010c04:	f8843783          	ld	a5,-120(s0)
    80010c08:	0007861b          	sext.w	a2,a5
    80010c0c:	f9744683          	lbu	a3,-105(s0)
    80010c10:	fc040713          	addi	a4,s0,-64
    80010c14:	441c                	lw	a5,8(s0)
    80010c16:	e83e                	sd	a5,16(sp)
    80010c18:	401c                	lw	a5,0(s0)
    80010c1a:	e43e                	sd	a5,8(sp)
    80010c1c:	f9042783          	lw	a5,-112(s0)
    80010c20:	e03e                	sd	a5,0(sp)
    80010c22:	88b2                	mv	a7,a2
    80010c24:	8836                	mv	a6,a3
    80010c26:	fe843783          	ld	a5,-24(s0)
    80010c2a:	fa043683          	ld	a3,-96(s0)
    80010c2e:	fa843603          	ld	a2,-88(s0)
    80010c32:	fb043583          	ld	a1,-80(s0)
    80010c36:	fb843503          	ld	a0,-72(s0)
    80010c3a:	b47ff0ef          	jal	ra,80010780 <_ntoa_format>
    80010c3e:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010c40:	853e                	mv	a0,a5
    80010c42:	60ea                	ld	ra,152(sp)
    80010c44:	644a                	ld	s0,144(sp)
    80010c46:	610d                	addi	sp,sp,160
    80010c48:	8082                	ret

0000000080010c4a <_ftoa>:

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80010c4a:	7135                	addi	sp,sp,-160
    80010c4c:	ed06                	sd	ra,152(sp)
    80010c4e:	e922                	sd	s0,144(sp)
    80010c50:	1100                	addi	s0,sp,160
    80010c52:	f8a43c23          	sd	a0,-104(s0)
    80010c56:	f8b43823          	sd	a1,-112(s0)
    80010c5a:	f8c43423          	sd	a2,-120(s0)
    80010c5e:	f8d43023          	sd	a3,-128(s0)
    80010c62:	f6a43c27          	fsd	fa0,-136(s0)
    80010c66:	863a                	mv	a2,a4
    80010c68:	86be                	mv	a3,a5
    80010c6a:	8742                	mv	a4,a6
    80010c6c:	87b2                	mv	a5,a2
    80010c6e:	f6f42a23          	sw	a5,-140(s0)
    80010c72:	87b6                	mv	a5,a3
    80010c74:	f6f42823          	sw	a5,-144(s0)
    80010c78:	87ba                	mv	a5,a4
    80010c7a:	f6f42623          	sw	a5,-148(s0)
    char buf[PRINTF_FTOA_BUFFER_SIZE];
    size_t len                  = 0U;
    80010c7e:	fe043423          	sd	zero,-24(s0)
    double diff                 = 0.0;
    80010c82:	fc043423          	sd	zero,-56(s0)
    static const double pow10[] = {1,         10,        100,     1000,
                                   10000,     100000,    1000000, 10000000,
                                   100000000, 1000000000};

    // test for special values
    if (value != value)
    80010c86:	f7843707          	fld	fa4,-136(s0)
    80010c8a:	f7843787          	fld	fa5,-136(s0)
    80010c8e:	a2f727d3          	feq.d	a5,fa4,fa5
    80010c92:	eb85                	bnez	a5,80010cc2 <_ftoa+0x78>
        return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
    80010c94:	f6c42703          	lw	a4,-148(s0)
    80010c98:	f7042783          	lw	a5,-144(s0)
    80010c9c:	88ba                	mv	a7,a4
    80010c9e:	883e                	mv	a6,a5
    80010ca0:	478d                	li	a5,3
    80010ca2:	00010717          	auipc	a4,0x10
    80010ca6:	38e70713          	addi	a4,a4,910 # 80021030 <SYSCALLS+0x30>
    80010caa:	f8043683          	ld	a3,-128(s0)
    80010cae:	f8843603          	ld	a2,-120(s0)
    80010cb2:	f9043583          	ld	a1,-112(s0)
    80010cb6:	f9843503          	ld	a0,-104(s0)
    80010cba:	9b5ff0ef          	jal	ra,8001066e <_out_rev>
    80010cbe:	87aa                	mv	a5,a0
    80010cc0:	a1f1                	j	8001118c <_ftoa+0x542>
    if (value < -DBL_MAX)
    80010cc2:	f7843707          	fld	fa4,-136(s0)
    80010cc6:	00010797          	auipc	a5,0x10
    80010cca:	5ba78793          	addi	a5,a5,1466 # 80021280 <pow10.0+0x50>
    80010cce:	239c                	fld	fa5,0(a5)
    80010cd0:	a2f717d3          	flt.d	a5,fa4,fa5
    80010cd4:	cb85                	beqz	a5,80010d04 <_ftoa+0xba>
        return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    80010cd6:	f6c42703          	lw	a4,-148(s0)
    80010cda:	f7042783          	lw	a5,-144(s0)
    80010cde:	88ba                	mv	a7,a4
    80010ce0:	883e                	mv	a6,a5
    80010ce2:	4791                	li	a5,4
    80010ce4:	00010717          	auipc	a4,0x10
    80010ce8:	35470713          	addi	a4,a4,852 # 80021038 <SYSCALLS+0x38>
    80010cec:	f8043683          	ld	a3,-128(s0)
    80010cf0:	f8843603          	ld	a2,-120(s0)
    80010cf4:	f9043583          	ld	a1,-112(s0)
    80010cf8:	f9843503          	ld	a0,-104(s0)
    80010cfc:	973ff0ef          	jal	ra,8001066e <_out_rev>
    80010d00:	87aa                	mv	a5,a0
    80010d02:	a169                	j	8001118c <_ftoa+0x542>
    if (value > DBL_MAX)
    80010d04:	f7843707          	fld	fa4,-136(s0)
    80010d08:	00010797          	auipc	a5,0x10
    80010d0c:	58078793          	addi	a5,a5,1408 # 80021288 <pow10.0+0x58>
    80010d10:	239c                	fld	fa5,0(a5)
    80010d12:	a2e797d3          	flt.d	a5,fa5,fa4
    80010d16:	cba9                	beqz	a5,80010d68 <_ftoa+0x11e>
        return _out_rev(out, buffer, idx, maxlen,
                        (flags & FLAGS_PLUS) ? "fni+" : "fni",
    80010d18:	f6c42783          	lw	a5,-148(s0)
    80010d1c:	8b91                	andi	a5,a5,4
    80010d1e:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010d20:	c791                	beqz	a5,80010d2c <_ftoa+0xe2>
    80010d22:	00010717          	auipc	a4,0x10
    80010d26:	31e70713          	addi	a4,a4,798 # 80021040 <SYSCALLS+0x40>
    80010d2a:	a029                	j	80010d34 <_ftoa+0xea>
    80010d2c:	00010717          	auipc	a4,0x10
    80010d30:	31c70713          	addi	a4,a4,796 # 80021048 <SYSCALLS+0x48>
                        (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
    80010d34:	f6c42783          	lw	a5,-148(s0)
    80010d38:	8b91                	andi	a5,a5,4
    80010d3a:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010d3c:	c399                	beqz	a5,80010d42 <_ftoa+0xf8>
    80010d3e:	4791                	li	a5,4
    80010d40:	a011                	j	80010d44 <_ftoa+0xfa>
    80010d42:	478d                	li	a5,3
    80010d44:	f6c42603          	lw	a2,-148(s0)
    80010d48:	f7042683          	lw	a3,-144(s0)
    80010d4c:	88b2                	mv	a7,a2
    80010d4e:	8836                	mv	a6,a3
    80010d50:	f8043683          	ld	a3,-128(s0)
    80010d54:	f8843603          	ld	a2,-120(s0)
    80010d58:	f9043583          	ld	a1,-112(s0)
    80010d5c:	f9843503          	ld	a0,-104(s0)
    80010d60:	90fff0ef          	jal	ra,8001066e <_out_rev>
    80010d64:	87aa                	mv	a5,a0
    80010d66:	a11d                	j	8001118c <_ftoa+0x542>

    // test for very large values
    // standard printf behavior is to print EVERY whole number digit -- which
    // could be 100s of characters overflowing your buffers == bad
    if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
    80010d68:	f7843707          	fld	fa4,-136(s0)
    80010d6c:	00010797          	auipc	a5,0x10
    80010d70:	52478793          	addi	a5,a5,1316 # 80021290 <pow10.0+0x60>
    80010d74:	239c                	fld	fa5,0(a5)
    80010d76:	a2e797d3          	flt.d	a5,fa5,fa4
    80010d7a:	eb99                	bnez	a5,80010d90 <_ftoa+0x146>
    80010d7c:	f7843707          	fld	fa4,-136(s0)
    80010d80:	00010797          	auipc	a5,0x10
    80010d84:	51878793          	addi	a5,a5,1304 # 80021298 <pow10.0+0x68>
    80010d88:	239c                	fld	fa5,0(a5)
    80010d8a:	a2f717d3          	flt.d	a5,fa4,fa5
    80010d8e:	c795                	beqz	a5,80010dba <_ftoa+0x170>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80010d90:	f6c42683          	lw	a3,-148(s0)
    80010d94:	f7042783          	lw	a5,-144(s0)
    80010d98:	f7442703          	lw	a4,-140(s0)
    80010d9c:	8836                	mv	a6,a3
    80010d9e:	f7843507          	fld	fa0,-136(s0)
    80010da2:	f8043683          	ld	a3,-128(s0)
    80010da6:	f8843603          	ld	a2,-120(s0)
    80010daa:	f9043583          	ld	a1,-112(s0)
    80010dae:	f9843503          	ld	a0,-104(s0)
    80010db2:	3e4000ef          	jal	ra,80011196 <_etoa>
    80010db6:	87aa                	mv	a5,a0
    80010db8:	aed1                	j	8001118c <_ftoa+0x542>
        return 0U;
#endif
    }

    // test for negative
    bool negative = false;
    80010dba:	fe0403a3          	sb	zero,-25(s0)
    if (value < 0) {
    80010dbe:	f7843787          	fld	fa5,-136(s0)
    80010dc2:	f2000753          	fmv.d.x	fa4,zero
    80010dc6:	a2e797d3          	flt.d	a5,fa5,fa4
    80010dca:	cf81                	beqz	a5,80010de2 <_ftoa+0x198>
        negative = true;
    80010dcc:	4785                	li	a5,1
    80010dce:	fef403a3          	sb	a5,-25(s0)
        value    = 0 - value;
    80010dd2:	f2000753          	fmv.d.x	fa4,zero
    80010dd6:	f7843787          	fld	fa5,-136(s0)
    80010dda:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010dde:	f6f43c27          	fsd	fa5,-136(s0)
    }

    // set default precision, if not set explicitly
    if (!(flags & FLAGS_PRECISION)) {
    80010de2:	f6c42783          	lw	a5,-148(s0)
    80010de6:	4007f793          	andi	a5,a5,1024
    80010dea:	2781                	sext.w	a5,a5
    80010dec:	e79d                	bnez	a5,80010e1a <_ftoa+0x1d0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80010dee:	4799                	li	a5,6
    80010df0:	f6f42a23          	sw	a5,-140(s0)
    }
    // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010df4:	a01d                	j	80010e1a <_ftoa+0x1d0>
        buf[len++] = '0';
    80010df6:	fe843783          	ld	a5,-24(s0)
    80010dfa:	00178713          	addi	a4,a5,1
    80010dfe:	fee43423          	sd	a4,-24(s0)
    80010e02:	ff040713          	addi	a4,s0,-16
    80010e06:	97ba                	add	a5,a5,a4
    80010e08:	03000713          	li	a4,48
    80010e0c:	fae78823          	sb	a4,-80(a5)
        prec--;
    80010e10:	f7442783          	lw	a5,-140(s0)
    80010e14:	37fd                	addiw	a5,a5,-1
    80010e16:	f6f42a23          	sw	a5,-140(s0)
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010e1a:	fe843703          	ld	a4,-24(s0)
    80010e1e:	47fd                	li	a5,31
    80010e20:	00e7e963          	bltu	a5,a4,80010e32 <_ftoa+0x1e8>
    80010e24:	f7442783          	lw	a5,-140(s0)
    80010e28:	0007871b          	sext.w	a4,a5
    80010e2c:	47a5                	li	a5,9
    80010e2e:	fce7e4e3          	bltu	a5,a4,80010df6 <_ftoa+0x1ac>
    }

    int whole          = (int)value;
    80010e32:	f7843787          	fld	fa5,-136(s0)
    80010e36:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80010e3a:	fef42023          	sw	a5,-32(s0)
    double tmp         = (value - whole) * pow10[prec];
    80010e3e:	fe042783          	lw	a5,-32(s0)
    80010e42:	d20787d3          	fcvt.d.w	fa5,a5
    80010e46:	f7843707          	fld	fa4,-136(s0)
    80010e4a:	0af77753          	fsub.d	fa4,fa4,fa5
    80010e4e:	00010717          	auipc	a4,0x10
    80010e52:	3e270713          	addi	a4,a4,994 # 80021230 <pow10.0>
    80010e56:	f7446783          	lwu	a5,-140(s0)
    80010e5a:	078e                	slli	a5,a5,0x3
    80010e5c:	97ba                	add	a5,a5,a4
    80010e5e:	239c                	fld	fa5,0(a5)
    80010e60:	12f777d3          	fmul.d	fa5,fa4,fa5
    80010e64:	fcf43027          	fsd	fa5,-64(s0)
    unsigned long frac = (unsigned long)tmp;
    80010e68:	fc043787          	fld	fa5,-64(s0)
    80010e6c:	c23797d3          	fcvt.lu.d	a5,fa5,rtz
    80010e70:	fcf43c23          	sd	a5,-40(s0)
    diff               = tmp - frac;
    80010e74:	fd843783          	ld	a5,-40(s0)
    80010e78:	d237f7d3          	fcvt.d.lu	fa5,a5
    80010e7c:	fc043707          	fld	fa4,-64(s0)
    80010e80:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010e84:	fcf43427          	fsd	fa5,-56(s0)

    if (diff > 0.5) {
    80010e88:	fc843707          	fld	fa4,-56(s0)
    80010e8c:	00010797          	auipc	a5,0x10
    80010e90:	41478793          	addi	a5,a5,1044 # 800212a0 <pow10.0+0x70>
    80010e94:	239c                	fld	fa5,0(a5)
    80010e96:	a2e797d3          	flt.d	a5,fa5,fa4
    80010e9a:	cf95                	beqz	a5,80010ed6 <_ftoa+0x28c>
        ++frac;
    80010e9c:	fd843783          	ld	a5,-40(s0)
    80010ea0:	0785                	addi	a5,a5,1
    80010ea2:	fcf43c23          	sd	a5,-40(s0)
        // handle rollover, e.g. case 0.99 with prec 1 is 1.0
        if (frac >= pow10[prec]) {
    80010ea6:	fd843783          	ld	a5,-40(s0)
    80010eaa:	d237f753          	fcvt.d.lu	fa4,a5
    80010eae:	00010717          	auipc	a4,0x10
    80010eb2:	38270713          	addi	a4,a4,898 # 80021230 <pow10.0>
    80010eb6:	f7446783          	lwu	a5,-140(s0)
    80010eba:	078e                	slli	a5,a5,0x3
    80010ebc:	97ba                	add	a5,a5,a4
    80010ebe:	239c                	fld	fa5,0(a5)
    80010ec0:	a2e787d3          	fle.d	a5,fa5,fa4
    80010ec4:	cf9d                	beqz	a5,80010f02 <_ftoa+0x2b8>
            frac = 0;
    80010ec6:	fc043c23          	sd	zero,-40(s0)
            ++whole;
    80010eca:	fe042783          	lw	a5,-32(s0)
    80010ece:	2785                	addiw	a5,a5,1
    80010ed0:	fef42023          	sw	a5,-32(s0)
    80010ed4:	a03d                	j	80010f02 <_ftoa+0x2b8>
        }
    }
    else if (diff < 0.5) {
    80010ed6:	fc843707          	fld	fa4,-56(s0)
    80010eda:	00010797          	auipc	a5,0x10
    80010ede:	3c678793          	addi	a5,a5,966 # 800212a0 <pow10.0+0x70>
    80010ee2:	239c                	fld	fa5,0(a5)
    80010ee4:	a2f717d3          	flt.d	a5,fa4,fa5
    80010ee8:	ef89                	bnez	a5,80010f02 <_ftoa+0x2b8>
    }
    else if ((frac == 0U) || (frac & 1U)) {
    80010eea:	fd843783          	ld	a5,-40(s0)
    80010eee:	c789                	beqz	a5,80010ef8 <_ftoa+0x2ae>
    80010ef0:	fd843783          	ld	a5,-40(s0)
    80010ef4:	8b85                	andi	a5,a5,1
    80010ef6:	c791                	beqz	a5,80010f02 <_ftoa+0x2b8>
        // if halfway, round up if odd OR if last digit is 0
        ++frac;
    80010ef8:	fd843783          	ld	a5,-40(s0)
    80010efc:	0785                	addi	a5,a5,1
    80010efe:	fcf43c23          	sd	a5,-40(s0)
    }

    if (prec == 0U) {
    80010f02:	f7442783          	lw	a5,-140(s0)
    80010f06:	2781                	sext.w	a5,a5
    80010f08:	e3bd                	bnez	a5,80010f6e <_ftoa+0x324>
        diff = value - (double)whole;
    80010f0a:	fe042783          	lw	a5,-32(s0)
    80010f0e:	d20787d3          	fcvt.d.w	fa5,a5
    80010f12:	f7843707          	fld	fa4,-136(s0)
    80010f16:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010f1a:	fcf43427          	fsd	fa5,-56(s0)
        if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    80010f1e:	fc843707          	fld	fa4,-56(s0)
    80010f22:	00010797          	auipc	a5,0x10
    80010f26:	37e78793          	addi	a5,a5,894 # 800212a0 <pow10.0+0x70>
    80010f2a:	239c                	fld	fa5,0(a5)
    80010f2c:	a2f717d3          	flt.d	a5,fa4,fa5
    80010f30:	00f037b3          	snez	a5,a5
    80010f34:	0ff7f793          	andi	a5,a5,255
    80010f38:	0017c793          	xori	a5,a5,1
    80010f3c:	0ff7f793          	andi	a5,a5,255
    80010f40:	eb99                	bnez	a5,80010f56 <_ftoa+0x30c>
    80010f42:	fc843707          	fld	fa4,-56(s0)
    80010f46:	00010797          	auipc	a5,0x10
    80010f4a:	35a78793          	addi	a5,a5,858 # 800212a0 <pow10.0+0x70>
    80010f4e:	239c                	fld	fa5,0(a5)
    80010f50:	a2e797d3          	flt.d	a5,fa5,fa4
    80010f54:	cbf1                	beqz	a5,80011028 <_ftoa+0x3de>
    80010f56:	fe042783          	lw	a5,-32(s0)
    80010f5a:	8b85                	andi	a5,a5,1
    80010f5c:	2781                	sext.w	a5,a5
    80010f5e:	10078863          	beqz	a5,8001106e <_ftoa+0x424>
            // exactly 0.5 and ODD, then round up
            // 1.5 -> 2, but 2.5 -> 2
            ++whole;
    80010f62:	fe042783          	lw	a5,-32(s0)
    80010f66:	2785                	addiw	a5,a5,1
    80010f68:	fef42023          	sw	a5,-32(s0)
    80010f6c:	a209                	j	8001106e <_ftoa+0x424>
        }
    }
    else {
        unsigned int count = prec;
    80010f6e:	f7442783          	lw	a5,-140(s0)
    80010f72:	fcf42a23          	sw	a5,-44(s0)
        // now do fractional part, as an unsigned number
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010f76:	a0b1                	j	80010fc2 <_ftoa+0x378>
            --count;
    80010f78:	fd442783          	lw	a5,-44(s0)
    80010f7c:	37fd                	addiw	a5,a5,-1
    80010f7e:	fcf42a23          	sw	a5,-44(s0)
            buf[len++] = (char)(48U + (frac % 10U));
    80010f82:	fd843703          	ld	a4,-40(s0)
    80010f86:	47a9                	li	a5,10
    80010f88:	02f777b3          	remu	a5,a4,a5
    80010f8c:	0ff7f713          	andi	a4,a5,255
    80010f90:	fe843783          	ld	a5,-24(s0)
    80010f94:	00178693          	addi	a3,a5,1
    80010f98:	fed43423          	sd	a3,-24(s0)
    80010f9c:	0307071b          	addiw	a4,a4,48
    80010fa0:	0ff77713          	andi	a4,a4,255
    80010fa4:	ff040693          	addi	a3,s0,-16
    80010fa8:	97b6                	add	a5,a5,a3
    80010faa:	fae78823          	sb	a4,-80(a5)
            if (!(frac /= 10U)) {
    80010fae:	fd843703          	ld	a4,-40(s0)
    80010fb2:	47a9                	li	a5,10
    80010fb4:	02f757b3          	divu	a5,a4,a5
    80010fb8:	fcf43c23          	sd	a5,-40(s0)
    80010fbc:	fd843783          	ld	a5,-40(s0)
    80010fc0:	c799                	beqz	a5,80010fce <_ftoa+0x384>
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010fc2:	fe843703          	ld	a4,-24(s0)
    80010fc6:	47fd                	li	a5,31
    80010fc8:	fae7f8e3          	bgeu	a5,a4,80010f78 <_ftoa+0x32e>
    80010fcc:	a005                	j	80010fec <_ftoa+0x3a2>
                break;
    80010fce:	0001                	nop
            }
        }
        // add extra 0s
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010fd0:	a831                	j	80010fec <_ftoa+0x3a2>
            buf[len++] = '0';
    80010fd2:	fe843783          	ld	a5,-24(s0)
    80010fd6:	00178713          	addi	a4,a5,1
    80010fda:	fee43423          	sd	a4,-24(s0)
    80010fde:	ff040713          	addi	a4,s0,-16
    80010fe2:	97ba                	add	a5,a5,a4
    80010fe4:	03000713          	li	a4,48
    80010fe8:	fae78823          	sb	a4,-80(a5)
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010fec:	fe843703          	ld	a4,-24(s0)
    80010ff0:	47fd                	li	a5,31
    80010ff2:	00e7e963          	bltu	a5,a4,80011004 <_ftoa+0x3ba>
    80010ff6:	fd442783          	lw	a5,-44(s0)
    80010ffa:	fff7871b          	addiw	a4,a5,-1
    80010ffe:	fce42a23          	sw	a4,-44(s0)
    80011002:	fbe1                	bnez	a5,80010fd2 <_ftoa+0x388>
        }
        if (len < PRINTF_FTOA_BUFFER_SIZE) {
    80011004:	fe843703          	ld	a4,-24(s0)
    80011008:	47fd                	li	a5,31
    8001100a:	06e7e263          	bltu	a5,a4,8001106e <_ftoa+0x424>
            // add decimal
            buf[len++] = '.';
    8001100e:	fe843783          	ld	a5,-24(s0)
    80011012:	00178713          	addi	a4,a5,1
    80011016:	fee43423          	sd	a4,-24(s0)
    8001101a:	ff040713          	addi	a4,s0,-16
    8001101e:	97ba                	add	a5,a5,a4
    80011020:	02e00713          	li	a4,46
    80011024:	fae78823          	sb	a4,-80(a5)
        }
    }

    // do whole part, number is reversed
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80011028:	a099                	j	8001106e <_ftoa+0x424>
        buf[len++] = (char)(48 + (whole % 10));
    8001102a:	fe042703          	lw	a4,-32(s0)
    8001102e:	47a9                	li	a5,10
    80011030:	02f767bb          	remw	a5,a4,a5
    80011034:	2781                	sext.w	a5,a5
    80011036:	0ff7f713          	andi	a4,a5,255
    8001103a:	fe843783          	ld	a5,-24(s0)
    8001103e:	00178693          	addi	a3,a5,1
    80011042:	fed43423          	sd	a3,-24(s0)
    80011046:	0307071b          	addiw	a4,a4,48
    8001104a:	0ff77713          	andi	a4,a4,255
    8001104e:	ff040693          	addi	a3,s0,-16
    80011052:	97b6                	add	a5,a5,a3
    80011054:	fae78823          	sb	a4,-80(a5)
        if (!(whole /= 10)) {
    80011058:	fe042703          	lw	a4,-32(s0)
    8001105c:	47a9                	li	a5,10
    8001105e:	02f747bb          	divw	a5,a4,a5
    80011062:	fef42023          	sw	a5,-32(s0)
    80011066:	fe042783          	lw	a5,-32(s0)
    8001106a:	2781                	sext.w	a5,a5
    8001106c:	c799                	beqz	a5,8001107a <_ftoa+0x430>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    8001106e:	fe843703          	ld	a4,-24(s0)
    80011072:	47fd                	li	a5,31
    80011074:	fae7fbe3          	bgeu	a5,a4,8001102a <_ftoa+0x3e0>
    80011078:	a011                	j	8001107c <_ftoa+0x432>
            break;
    8001107a:	0001                	nop
        }
    }

    // pad leading zeros
    if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    8001107c:	f6c42783          	lw	a5,-148(s0)
    80011080:	8b89                	andi	a5,a5,2
    80011082:	2781                	sext.w	a5,a5
    80011084:	e3b5                	bnez	a5,800110e8 <_ftoa+0x49e>
    80011086:	f6c42783          	lw	a5,-148(s0)
    8001108a:	8b85                	andi	a5,a5,1
    8001108c:	2781                	sext.w	a5,a5
    8001108e:	cfa9                	beqz	a5,800110e8 <_ftoa+0x49e>
        if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80011090:	f7042783          	lw	a5,-144(s0)
    80011094:	2781                	sext.w	a5,a5
    80011096:	cf95                	beqz	a5,800110d2 <_ftoa+0x488>
    80011098:	fe744783          	lbu	a5,-25(s0)
    8001109c:	0ff7f793          	andi	a5,a5,255
    800110a0:	e791                	bnez	a5,800110ac <_ftoa+0x462>
    800110a2:	f6c42783          	lw	a5,-148(s0)
    800110a6:	8bb1                	andi	a5,a5,12
    800110a8:	2781                	sext.w	a5,a5
    800110aa:	c785                	beqz	a5,800110d2 <_ftoa+0x488>
            width--;
    800110ac:	f7042783          	lw	a5,-144(s0)
    800110b0:	37fd                	addiw	a5,a5,-1
    800110b2:	f6f42823          	sw	a5,-144(s0)
        }
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800110b6:	a831                	j	800110d2 <_ftoa+0x488>
            buf[len++] = '0';
    800110b8:	fe843783          	ld	a5,-24(s0)
    800110bc:	00178713          	addi	a4,a5,1
    800110c0:	fee43423          	sd	a4,-24(s0)
    800110c4:	ff040713          	addi	a4,s0,-16
    800110c8:	97ba                	add	a5,a5,a4
    800110ca:	03000713          	li	a4,48
    800110ce:	fae78823          	sb	a4,-80(a5)
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800110d2:	f7046783          	lwu	a5,-144(s0)
    800110d6:	fe843703          	ld	a4,-24(s0)
    800110da:	00f77763          	bgeu	a4,a5,800110e8 <_ftoa+0x49e>
    800110de:	fe843703          	ld	a4,-24(s0)
    800110e2:	47fd                	li	a5,31
    800110e4:	fce7fae3          	bgeu	a5,a4,800110b8 <_ftoa+0x46e>
        }
    }

    if (len < PRINTF_FTOA_BUFFER_SIZE) {
    800110e8:	fe843703          	ld	a4,-24(s0)
    800110ec:	47fd                	li	a5,31
    800110ee:	06e7ea63          	bltu	a5,a4,80011162 <_ftoa+0x518>
        if (negative) {
    800110f2:	fe744783          	lbu	a5,-25(s0)
    800110f6:	0ff7f793          	andi	a5,a5,255
    800110fa:	cf99                	beqz	a5,80011118 <_ftoa+0x4ce>
            buf[len++] = '-';
    800110fc:	fe843783          	ld	a5,-24(s0)
    80011100:	00178713          	addi	a4,a5,1
    80011104:	fee43423          	sd	a4,-24(s0)
    80011108:	ff040713          	addi	a4,s0,-16
    8001110c:	97ba                	add	a5,a5,a4
    8001110e:	02d00713          	li	a4,45
    80011112:	fae78823          	sb	a4,-80(a5)
    80011116:	a0b1                	j	80011162 <_ftoa+0x518>
        }
        else if (flags & FLAGS_PLUS) {
    80011118:	f6c42783          	lw	a5,-148(s0)
    8001111c:	8b91                	andi	a5,a5,4
    8001111e:	2781                	sext.w	a5,a5
    80011120:	cf99                	beqz	a5,8001113e <_ftoa+0x4f4>
            buf[len++] = '+';  // ignore the space if the '+' exists
    80011122:	fe843783          	ld	a5,-24(s0)
    80011126:	00178713          	addi	a4,a5,1
    8001112a:	fee43423          	sd	a4,-24(s0)
    8001112e:	ff040713          	addi	a4,s0,-16
    80011132:	97ba                	add	a5,a5,a4
    80011134:	02b00713          	li	a4,43
    80011138:	fae78823          	sb	a4,-80(a5)
    8001113c:	a01d                	j	80011162 <_ftoa+0x518>
        }
        else if (flags & FLAGS_SPACE) {
    8001113e:	f6c42783          	lw	a5,-148(s0)
    80011142:	8ba1                	andi	a5,a5,8
    80011144:	2781                	sext.w	a5,a5
    80011146:	cf91                	beqz	a5,80011162 <_ftoa+0x518>
            buf[len++] = ' ';
    80011148:	fe843783          	ld	a5,-24(s0)
    8001114c:	00178713          	addi	a4,a5,1
    80011150:	fee43423          	sd	a4,-24(s0)
    80011154:	ff040713          	addi	a4,s0,-16
    80011158:	97ba                	add	a5,a5,a4
    8001115a:	02000713          	li	a4,32
    8001115e:	fae78823          	sb	a4,-80(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    80011162:	f6c42683          	lw	a3,-148(s0)
    80011166:	f7042783          	lw	a5,-144(s0)
    8001116a:	fa040713          	addi	a4,s0,-96
    8001116e:	88b6                	mv	a7,a3
    80011170:	883e                	mv	a6,a5
    80011172:	fe843783          	ld	a5,-24(s0)
    80011176:	f8043683          	ld	a3,-128(s0)
    8001117a:	f8843603          	ld	a2,-120(s0)
    8001117e:	f9043583          	ld	a1,-112(s0)
    80011182:	f9843503          	ld	a0,-104(s0)
    80011186:	ce8ff0ef          	jal	ra,8001066e <_out_rev>
    8001118a:	87aa                	mv	a5,a0
}
    8001118c:	853e                	mv	a0,a5
    8001118e:	60ea                	ld	ra,152(sp)
    80011190:	644a                	ld	s0,144(sp)
    80011192:	610d                	addi	sp,sp,160
    80011194:	8082                	ret

0000000080011196 <_etoa>:
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80011196:	7135                	addi	sp,sp,-160
    80011198:	ed06                	sd	ra,152(sp)
    8001119a:	e922                	sd	s0,144(sp)
    8001119c:	1100                	addi	s0,sp,160
    8001119e:	faa43423          	sd	a0,-88(s0)
    800111a2:	fab43023          	sd	a1,-96(s0)
    800111a6:	f8c43c23          	sd	a2,-104(s0)
    800111aa:	f8d43823          	sd	a3,-112(s0)
    800111ae:	f8a43427          	fsd	fa0,-120(s0)
    800111b2:	863a                	mv	a2,a4
    800111b4:	86be                	mv	a3,a5
    800111b6:	8742                	mv	a4,a6
    800111b8:	87b2                	mv	a5,a2
    800111ba:	f8f42223          	sw	a5,-124(s0)
    800111be:	87b6                	mv	a5,a3
    800111c0:	f8f42023          	sw	a5,-128(s0)
    800111c4:	87ba                	mv	a5,a4
    800111c6:	f6f42e23          	sw	a5,-132(s0)
    // check for NaN and special values
    if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    800111ca:	f8843707          	fld	fa4,-120(s0)
    800111ce:	f8843787          	fld	fa5,-120(s0)
    800111d2:	a2f727d3          	feq.d	a5,fa4,fa5
    800111d6:	c78d                	beqz	a5,80011200 <_etoa+0x6a>
    800111d8:	f8843707          	fld	fa4,-120(s0)
    800111dc:	00010797          	auipc	a5,0x10
    800111e0:	0ac78793          	addi	a5,a5,172 # 80021288 <pow10.0+0x58>
    800111e4:	239c                	fld	fa5,0(a5)
    800111e6:	a2e797d3          	flt.d	a5,fa5,fa4
    800111ea:	eb99                	bnez	a5,80011200 <_etoa+0x6a>
    800111ec:	f8843707          	fld	fa4,-120(s0)
    800111f0:	00010797          	auipc	a5,0x10
    800111f4:	09078793          	addi	a5,a5,144 # 80021280 <pow10.0+0x50>
    800111f8:	239c                	fld	fa5,0(a5)
    800111fa:	a2f717d3          	flt.d	a5,fa4,fa5
    800111fe:	c795                	beqz	a5,8001122a <_etoa+0x94>
        return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80011200:	f7c42683          	lw	a3,-132(s0)
    80011204:	f8042783          	lw	a5,-128(s0)
    80011208:	f8442703          	lw	a4,-124(s0)
    8001120c:	8836                	mv	a6,a3
    8001120e:	f8843507          	fld	fa0,-120(s0)
    80011212:	f9043683          	ld	a3,-112(s0)
    80011216:	f9843603          	ld	a2,-104(s0)
    8001121a:	fa043583          	ld	a1,-96(s0)
    8001121e:	fa843503          	ld	a0,-88(s0)
    80011222:	a29ff0ef          	jal	ra,80010c4a <_ftoa>
    80011226:	87aa                	mv	a5,a0
    80011228:	a11d                	j	8001164e <_etoa+0x4b8>
    }

    // determine the sign
    const bool negative = value < 0;
    8001122a:	f8843787          	fld	fa5,-120(s0)
    8001122e:	f2000753          	fmv.d.x	fa4,zero
    80011232:	a2e797d3          	flt.d	a5,fa5,fa4
    80011236:	00f037b3          	snez	a5,a5
    8001123a:	fef401a3          	sb	a5,-29(s0)
    if (negative) {
    8001123e:	fe344783          	lbu	a5,-29(s0)
    80011242:	0ff7f793          	andi	a5,a5,255
    80011246:	c799                	beqz	a5,80011254 <_etoa+0xbe>
        value = -value;
    80011248:	f8843787          	fld	fa5,-120(s0)
    8001124c:	22f797d3          	fneg.d	fa5,fa5
    80011250:	f8f43427          	fsd	fa5,-120(s0)
    }

    // default precision
    if (!(flags & FLAGS_PRECISION)) {
    80011254:	f7c42783          	lw	a5,-132(s0)
    80011258:	4007f793          	andi	a5,a5,1024
    8001125c:	2781                	sext.w	a5,a5
    8001125e:	e781                	bnez	a5,80011266 <_etoa+0xd0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80011260:	4799                	li	a5,6
    80011262:	f8f42223          	sw	a5,-124(s0)
    union {
        uint64_t U;
        double F;
    } conv;

    conv.F   = value;
    80011266:	f8843787          	fld	fa5,-120(s0)
    8001126a:	faf43c27          	fsd	fa5,-72(s0)
    int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;  // effectively log2
    8001126e:	fb843783          	ld	a5,-72(s0)
    80011272:	93d1                	srli	a5,a5,0x34
    80011274:	2781                	sext.w	a5,a5
    80011276:	7ff7f793          	andi	a5,a5,2047
    8001127a:	2781                	sext.w	a5,a5
    8001127c:	c017879b          	addiw	a5,a5,-1023
    80011280:	fcf42e23          	sw	a5,-36(s0)
    conv.U   = (conv.U & ((1ULL << 52U) - 1U)) |
    80011284:	fb843703          	ld	a4,-72(s0)
    80011288:	57fd                	li	a5,-1
    8001128a:	83b1                	srli	a5,a5,0xc
    8001128c:	8f7d                	and	a4,a4,a5
    8001128e:	3ff00793          	li	a5,1023
    80011292:	17d2                	slli	a5,a5,0x34
    80011294:	8fd9                	or	a5,a5,a4
    80011296:	faf43c23          	sd	a5,-72(s0)
             (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    // now approximate log10 from the log2 integer part and an expansion of ln
    // around 1.5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    8001129a:	fdc42783          	lw	a5,-36(s0)
    8001129e:	d2078753          	fcvt.d.w	fa4,a5
    800112a2:	00010797          	auipc	a5,0x10
    800112a6:	00678793          	addi	a5,a5,6 # 800212a8 <pow10.0+0x78>
    800112aa:	239c                	fld	fa5,0(a5)
    800112ac:	12f77753          	fmul.d	fa4,fa4,fa5
    800112b0:	00010797          	auipc	a5,0x10
    800112b4:	00078793          	mv	a5,a5
    800112b8:	239c                	fld	fa5,0(a5)
    800112ba:	02f77753          	fadd.d	fa4,fa4,fa5
                       (conv.F - 1.5) * 0.289529654602168);
    800112be:	fb843687          	fld	fa3,-72(s0)
    800112c2:	00010797          	auipc	a5,0x10
    800112c6:	ff678793          	addi	a5,a5,-10 # 800212b8 <pow10.0+0x88>
    800112ca:	239c                	fld	fa5,0(a5)
    800112cc:	0af6f6d3          	fsub.d	fa3,fa3,fa5
    800112d0:	00010797          	auipc	a5,0x10
    800112d4:	ff078793          	addi	a5,a5,-16 # 800212c0 <pow10.0+0x90>
    800112d8:	239c                	fld	fa5,0(a5)
    800112da:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    800112de:	02f777d3          	fadd.d	fa5,fa4,fa5
    800112e2:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    800112e6:	fef42623          	sw	a5,-20(s0)
    // now we want to compute 10^expval but we want to be sure it won't overflow
    exp2            = (int)(expval * 3.321928094887362 + 0.5);
    800112ea:	fec42783          	lw	a5,-20(s0)
    800112ee:	d2078753          	fcvt.d.w	fa4,a5
    800112f2:	00010797          	auipc	a5,0x10
    800112f6:	fd678793          	addi	a5,a5,-42 # 800212c8 <pow10.0+0x98>
    800112fa:	239c                	fld	fa5,0(a5)
    800112fc:	12f77753          	fmul.d	fa4,fa4,fa5
    80011300:	00010797          	auipc	a5,0x10
    80011304:	fa078793          	addi	a5,a5,-96 # 800212a0 <pow10.0+0x70>
    80011308:	239c                	fld	fa5,0(a5)
    8001130a:	02f777d3          	fadd.d	fa5,fa4,fa5
    8001130e:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80011312:	fcf42e23          	sw	a5,-36(s0)
    const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    80011316:	fec42783          	lw	a5,-20(s0)
    8001131a:	d2078753          	fcvt.d.w	fa4,a5
    8001131e:	00010797          	auipc	a5,0x10
    80011322:	fb278793          	addi	a5,a5,-78 # 800212d0 <pow10.0+0xa0>
    80011326:	239c                	fld	fa5,0(a5)
    80011328:	12f77753          	fmul.d	fa4,fa4,fa5
    8001132c:	fdc42783          	lw	a5,-36(s0)
    80011330:	d20786d3          	fcvt.d.w	fa3,a5
    80011334:	00010797          	auipc	a5,0x10
    80011338:	fa478793          	addi	a5,a5,-92 # 800212d8 <pow10.0+0xa8>
    8001133c:	239c                	fld	fa5,0(a5)
    8001133e:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    80011342:	0af777d3          	fsub.d	fa5,fa4,fa5
    80011346:	fcf43827          	fsd	fa5,-48(s0)
    const double z2 = z * z;
    8001134a:	fd043787          	fld	fa5,-48(s0)
    8001134e:	12f7f7d3          	fmul.d	fa5,fa5,fa5
    80011352:	fcf43427          	fsd	fa5,-56(s0)
    conv.U          = (uint64_t)(exp2 + 1023) << 52U;
    80011356:	fdc42783          	lw	a5,-36(s0)
    8001135a:	3ff7879b          	addiw	a5,a5,1023
    8001135e:	2781                	sext.w	a5,a5
    80011360:	17d2                	slli	a5,a5,0x34
    80011362:	faf43c23          	sd	a5,-72(s0)
    // compute exp(z) using continued fractions, see
    // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    80011366:	fb843707          	fld	fa4,-72(s0)
    8001136a:	fd043787          	fld	fa5,-48(s0)
    8001136e:	02f7f6d3          	fadd.d	fa3,fa5,fa5
    80011372:	00010797          	auipc	a5,0x10
    80011376:	f6e78793          	addi	a5,a5,-146 # 800212e0 <pow10.0+0xb0>
    8001137a:	2390                	fld	fa2,0(a5)
    8001137c:	fd043787          	fld	fa5,-48(s0)
    80011380:	0af67653          	fsub.d	fa2,fa2,fa5
    80011384:	fc843587          	fld	fa1,-56(s0)
    80011388:	00010797          	auipc	a5,0x10
    8001138c:	f6078793          	addi	a5,a5,-160 # 800212e8 <pow10.0+0xb8>
    80011390:	239c                	fld	fa5,0(a5)
    80011392:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    80011396:	00010797          	auipc	a5,0x10
    8001139a:	f5a78793          	addi	a5,a5,-166 # 800212f0 <pow10.0+0xc0>
    8001139e:	239c                	fld	fa5,0(a5)
    800113a0:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800113a4:	fc843587          	fld	fa1,-56(s0)
    800113a8:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    800113ac:	00010797          	auipc	a5,0x10
    800113b0:	f4c78793          	addi	a5,a5,-180 # 800212f8 <pow10.0+0xc8>
    800113b4:	239c                	fld	fa5,0(a5)
    800113b6:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800113ba:	fc843587          	fld	fa1,-56(s0)
    800113be:	1af5f7d3          	fdiv.d	fa5,fa1,fa5
    800113c2:	02f677d3          	fadd.d	fa5,fa2,fa5
    800113c6:	1af6f6d3          	fdiv.d	fa3,fa3,fa5
    800113ca:	00010797          	auipc	a5,0x10
    800113ce:	f3678793          	addi	a5,a5,-202 # 80021300 <pow10.0+0xd0>
    800113d2:	239c                	fld	fa5,0(a5)
    800113d4:	02f6f7d3          	fadd.d	fa5,fa3,fa5
    800113d8:	12f777d3          	fmul.d	fa5,fa4,fa5
    800113dc:	faf43c27          	fsd	fa5,-72(s0)
    // correct for rounding errors
    if (value < conv.F) {
    800113e0:	fb843787          	fld	fa5,-72(s0)
    800113e4:	f8843707          	fld	fa4,-120(s0)
    800113e8:	a2f717d3          	flt.d	a5,fa4,fa5
    800113ec:	c38d                	beqz	a5,8001140e <_etoa+0x278>
        expval--;
    800113ee:	fec42783          	lw	a5,-20(s0)
    800113f2:	37fd                	addiw	a5,a5,-1
    800113f4:	fef42623          	sw	a5,-20(s0)
        conv.F /= 10;
    800113f8:	fb843707          	fld	fa4,-72(s0)
    800113fc:	00010797          	auipc	a5,0x10
    80011400:	ef478793          	addi	a5,a5,-268 # 800212f0 <pow10.0+0xc0>
    80011404:	239c                	fld	fa5,0(a5)
    80011406:	1af777d3          	fdiv.d	fa5,fa4,fa5
    8001140a:	faf43c27          	fsd	fa5,-72(s0)
    }

    // the exponent format is "%+03d" and largest value is "307", so set aside
    // 4-5 characters
    unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    8001140e:	fec42783          	lw	a5,-20(s0)
    80011412:	0007871b          	sext.w	a4,a5
    80011416:	06300793          	li	a5,99
    8001141a:	00e7cc63          	blt	a5,a4,80011432 <_etoa+0x29c>
    8001141e:	fec42783          	lw	a5,-20(s0)
    80011422:	0007871b          	sext.w	a4,a5
    80011426:	f9d00793          	li	a5,-99
    8001142a:	00f74463          	blt	a4,a5,80011432 <_etoa+0x29c>
    8001142e:	4791                	li	a5,4
    80011430:	a011                	j	80011434 <_etoa+0x29e>
    80011432:	4795                	li	a5,5
    80011434:	fef42423          	sw	a5,-24(s0)

    // in "%g" mode, "prec" is the number of *significant figures* not decimals
    if (flags & FLAGS_ADAPT_EXP) {
    80011438:	f7c42703          	lw	a4,-132(s0)
    8001143c:	6785                	lui	a5,0x1
    8001143e:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80011442:	8ff9                	and	a5,a5,a4
    80011444:	2781                	sext.w	a5,a5
    80011446:	c7c1                	beqz	a5,800114ce <_etoa+0x338>
        // do we want to fall-back to "%f" mode?
        if ((value >= 1e-4) && (value < 1e6)) {
    80011448:	f8843707          	fld	fa4,-120(s0)
    8001144c:	00010797          	auipc	a5,0x10
    80011450:	ebc78793          	addi	a5,a5,-324 # 80021308 <pow10.0+0xd8>
    80011454:	239c                	fld	fa5,0(a5)
    80011456:	a2e787d3          	fle.d	a5,fa5,fa4
    8001145a:	cbb9                	beqz	a5,800114b0 <_etoa+0x31a>
    8001145c:	f8843707          	fld	fa4,-120(s0)
    80011460:	00010797          	auipc	a5,0x10
    80011464:	eb078793          	addi	a5,a5,-336 # 80021310 <pow10.0+0xe0>
    80011468:	239c                	fld	fa5,0(a5)
    8001146a:	a2f717d3          	flt.d	a5,fa4,fa5
    8001146e:	c3a9                	beqz	a5,800114b0 <_etoa+0x31a>
            if ((int)prec > expval) {
    80011470:	f8442703          	lw	a4,-124(s0)
    80011474:	fec42783          	lw	a5,-20(s0)
    80011478:	2781                	sext.w	a5,a5
    8001147a:	00e7de63          	bge	a5,a4,80011496 <_etoa+0x300>
                prec = (unsigned)((int)prec - expval - 1);
    8001147e:	f8442703          	lw	a4,-124(s0)
    80011482:	fec42783          	lw	a5,-20(s0)
    80011486:	40f707bb          	subw	a5,a4,a5
    8001148a:	2781                	sext.w	a5,a5
    8001148c:	37fd                	addiw	a5,a5,-1
    8001148e:	2781                	sext.w	a5,a5
    80011490:	f8f42223          	sw	a5,-124(s0)
    80011494:	a019                	j	8001149a <_etoa+0x304>
            }
            else {
                prec = 0;
    80011496:	f8042223          	sw	zero,-124(s0)
            }
            flags |= FLAGS_PRECISION;  // make sure _ftoa respects precision
    8001149a:	f7c42783          	lw	a5,-132(s0)
    8001149e:	4007e793          	ori	a5,a5,1024
    800114a2:	f6f42e23          	sw	a5,-132(s0)
            // no characters in exponent
            minwidth = 0U;
    800114a6:	fe042423          	sw	zero,-24(s0)
            expval   = 0;
    800114aa:	fe042623          	sw	zero,-20(s0)
    800114ae:	a005                	j	800114ce <_etoa+0x338>
        }
        else {
            // we use one sigfig for the whole part
            if ((prec > 0) && (flags & FLAGS_PRECISION)) {
    800114b0:	f8442783          	lw	a5,-124(s0)
    800114b4:	2781                	sext.w	a5,a5
    800114b6:	cf81                	beqz	a5,800114ce <_etoa+0x338>
    800114b8:	f7c42783          	lw	a5,-132(s0)
    800114bc:	4007f793          	andi	a5,a5,1024
    800114c0:	2781                	sext.w	a5,a5
    800114c2:	c791                	beqz	a5,800114ce <_etoa+0x338>
                --prec;
    800114c4:	f8442783          	lw	a5,-124(s0)
    800114c8:	37fd                	addiw	a5,a5,-1
    800114ca:	f8f42223          	sw	a5,-124(s0)
            }
        }
    }

    // will everything fit?
    unsigned int fwidth = width;
    800114ce:	f8042783          	lw	a5,-128(s0)
    800114d2:	fef42223          	sw	a5,-28(s0)
    if (width > minwidth) {
    800114d6:	f8042703          	lw	a4,-128(s0)
    800114da:	fe842783          	lw	a5,-24(s0)
    800114de:	2701                	sext.w	a4,a4
    800114e0:	2781                	sext.w	a5,a5
    800114e2:	00e7fb63          	bgeu	a5,a4,800114f8 <_etoa+0x362>
        // we didn't fall-back so subtract the characters required for the
        // exponent
        fwidth -= minwidth;
    800114e6:	fe442703          	lw	a4,-28(s0)
    800114ea:	fe842783          	lw	a5,-24(s0)
    800114ee:	40f707bb          	subw	a5,a4,a5
    800114f2:	fef42223          	sw	a5,-28(s0)
    800114f6:	a019                	j	800114fc <_etoa+0x366>
    }
    else {
        // not enough characters, so go back to default sizing
        fwidth = 0U;
    800114f8:	fe042223          	sw	zero,-28(s0)
    }
    if ((flags & FLAGS_LEFT) && minwidth) {
    800114fc:	f7c42783          	lw	a5,-132(s0)
    80011500:	8b89                	andi	a5,a5,2
    80011502:	2781                	sext.w	a5,a5
    80011504:	c799                	beqz	a5,80011512 <_etoa+0x37c>
    80011506:	fe842783          	lw	a5,-24(s0)
    8001150a:	2781                	sext.w	a5,a5
    8001150c:	c399                	beqz	a5,80011512 <_etoa+0x37c>
        // if we're padding on the right, DON'T pad the floating part
        fwidth = 0U;
    8001150e:	fe042223          	sw	zero,-28(s0)
    }

    // rescale the float value
    if (expval) {
    80011512:	fec42783          	lw	a5,-20(s0)
    80011516:	2781                	sext.w	a5,a5
    80011518:	cb89                	beqz	a5,8001152a <_etoa+0x394>
        value /= conv.F;
    8001151a:	fb843787          	fld	fa5,-72(s0)
    8001151e:	f8843707          	fld	fa4,-120(s0)
    80011522:	1af777d3          	fdiv.d	fa5,fa4,fa5
    80011526:	f8f43427          	fsd	fa5,-120(s0)
    }

    // output the floating part
    const size_t start_idx = idx;
    8001152a:	f9843783          	ld	a5,-104(s0)
    8001152e:	fcf43023          	sd	a5,-64(s0)
    idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec,
    80011532:	fe344783          	lbu	a5,-29(s0)
    80011536:	0ff7f793          	andi	a5,a5,255
    8001153a:	c791                	beqz	a5,80011546 <_etoa+0x3b0>
    8001153c:	f8843787          	fld	fa5,-120(s0)
    80011540:	22f797d3          	fneg.d	fa5,fa5
    80011544:	a019                	j	8001154a <_etoa+0x3b4>
    80011546:	f8843787          	fld	fa5,-120(s0)
    8001154a:	f7c42703          	lw	a4,-132(s0)
    8001154e:	77fd                	lui	a5,0xfffff
    80011550:	7ff78793          	addi	a5,a5,2047 # fffffffffffff7ff <_heap_end+0xffffffff77fef7ff>
    80011554:	8ff9                	and	a5,a5,a4
    80011556:	0007869b          	sext.w	a3,a5
    8001155a:	fe442783          	lw	a5,-28(s0)
    8001155e:	f8442703          	lw	a4,-124(s0)
    80011562:	8836                	mv	a6,a3
    80011564:	22f78553          	fmv.d	fa0,fa5
    80011568:	f9043683          	ld	a3,-112(s0)
    8001156c:	f9843603          	ld	a2,-104(s0)
    80011570:	fa043583          	ld	a1,-96(s0)
    80011574:	fa843503          	ld	a0,-88(s0)
    80011578:	ed2ff0ef          	jal	ra,80010c4a <_ftoa>
    8001157c:	f8a43c23          	sd	a0,-104(s0)
                fwidth, flags & ~FLAGS_ADAPT_EXP);

    // output the exponent part
    if (minwidth) {
    80011580:	fe842783          	lw	a5,-24(s0)
    80011584:	2781                	sext.w	a5,a5
    80011586:	c3f1                	beqz	a5,8001164a <_etoa+0x4b4>
        // output the exponential symbol
        out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    80011588:	f7c42783          	lw	a5,-132(s0)
    8001158c:	0207f793          	andi	a5,a5,32
    80011590:	2781                	sext.w	a5,a5
    80011592:	c781                	beqz	a5,8001159a <_etoa+0x404>
    80011594:	04500793          	li	a5,69
    80011598:	a019                	j	8001159e <_etoa+0x408>
    8001159a:	06500793          	li	a5,101
    8001159e:	f9843703          	ld	a4,-104(s0)
    800115a2:	00170693          	addi	a3,a4,1
    800115a6:	f8d43c23          	sd	a3,-104(s0)
    800115aa:	fa843803          	ld	a6,-88(s0)
    800115ae:	f9043683          	ld	a3,-112(s0)
    800115b2:	863a                	mv	a2,a4
    800115b4:	fa043583          	ld	a1,-96(s0)
    800115b8:	853e                	mv	a0,a5
    800115ba:	9802                	jalr	a6
        // output the exponent value
        idx = _ntoa_long(out, buffer, idx, maxlen,
                         (expval < 0) ? -expval : expval, expval < 0, 10, 0,
    800115bc:	fec42783          	lw	a5,-20(s0)
    800115c0:	41f7d79b          	sraiw	a5,a5,0x1f
    800115c4:	fec42703          	lw	a4,-20(s0)
    800115c8:	8f3d                	xor	a4,a4,a5
    800115ca:	40f707bb          	subw	a5,a4,a5
    800115ce:	2781                	sext.w	a5,a5
        idx = _ntoa_long(out, buffer, idx, maxlen,
    800115d0:	863e                	mv	a2,a5
    800115d2:	fec42783          	lw	a5,-20(s0)
    800115d6:	01f7d79b          	srliw	a5,a5,0x1f
    800115da:	0ff7f693          	andi	a3,a5,255
    800115de:	fe842783          	lw	a5,-24(s0)
    800115e2:	37fd                	addiw	a5,a5,-1
    800115e4:	2781                	sext.w	a5,a5
    800115e6:	4715                	li	a4,5
    800115e8:	e43a                	sd	a4,8(sp)
    800115ea:	e03e                	sd	a5,0(sp)
    800115ec:	4881                	li	a7,0
    800115ee:	4829                	li	a6,10
    800115f0:	87b6                	mv	a5,a3
    800115f2:	8732                	mv	a4,a2
    800115f4:	f9043683          	ld	a3,-112(s0)
    800115f8:	f9843603          	ld	a2,-104(s0)
    800115fc:	fa043583          	ld	a1,-96(s0)
    80011600:	fa843503          	ld	a0,-88(s0)
    80011604:	c16ff0ef          	jal	ra,80010a1a <_ntoa_long>
    80011608:	f8a43c23          	sd	a0,-104(s0)
                         minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
        // might need to right-pad spaces
        if (flags & FLAGS_LEFT) {
    8001160c:	f7c42783          	lw	a5,-132(s0)
    80011610:	8b89                	andi	a5,a5,2
    80011612:	2781                	sext.w	a5,a5
    80011614:	cb9d                	beqz	a5,8001164a <_etoa+0x4b4>
            while (idx - start_idx < width)
    80011616:	a00d                	j	80011638 <_etoa+0x4a2>
                out(' ', buffer, idx++, maxlen);
    80011618:	f9843783          	ld	a5,-104(s0)
    8001161c:	00178713          	addi	a4,a5,1
    80011620:	f8e43c23          	sd	a4,-104(s0)
    80011624:	fa843703          	ld	a4,-88(s0)
    80011628:	f9043683          	ld	a3,-112(s0)
    8001162c:	863e                	mv	a2,a5
    8001162e:	fa043583          	ld	a1,-96(s0)
    80011632:	02000513          	li	a0,32
    80011636:	9702                	jalr	a4
            while (idx - start_idx < width)
    80011638:	f9843703          	ld	a4,-104(s0)
    8001163c:	fc043783          	ld	a5,-64(s0)
    80011640:	8f1d                	sub	a4,a4,a5
    80011642:	f8046783          	lwu	a5,-128(s0)
    80011646:	fcf769e3          	bltu	a4,a5,80011618 <_etoa+0x482>
        }
    }
    return idx;
    8001164a:	f9843783          	ld	a5,-104(s0)
}
    8001164e:	853e                	mv	a0,a5
    80011650:	60ea                	ld	ra,152(sp)
    80011652:	644a                	ld	s0,144(sp)
    80011654:	610d                	addi	sp,sp,160
    80011656:	8082                	ret

0000000080011658 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
                      const char *format, va_list va)
{
    80011658:	7135                	addi	sp,sp,-160
    8001165a:	ed06                	sd	ra,152(sp)
    8001165c:	e922                	sd	s0,144(sp)
    8001165e:	1100                	addi	s0,sp,160
    80011660:	f8a43c23          	sd	a0,-104(s0)
    80011664:	f8b43823          	sd	a1,-112(s0)
    80011668:	f8c43423          	sd	a2,-120(s0)
    8001166c:	f8d43023          	sd	a3,-128(s0)
    80011670:	f6e43c23          	sd	a4,-136(s0)
    unsigned int flags, width, precision, n;
    size_t idx = 0U;
    80011674:	fc043c23          	sd	zero,-40(s0)

    if (!buffer) {
    80011678:	f9043783          	ld	a5,-112(s0)
    8001167c:	380792e3          	bnez	a5,80012200 <_vsnprintf+0xba8>
        // use null output function
        out = _out_null;
    80011680:	fffff797          	auipc	a5,0xfffff
    80011684:	e5878793          	addi	a5,a5,-424 # 800104d8 <_out_null>
    80011688:	f8f43c23          	sd	a5,-104(s0)
    }

    while (*format) {
    8001168c:	3750006f          	j	80012200 <_vsnprintf+0xba8>
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
    80011690:	f8043783          	ld	a5,-128(s0)
    80011694:	0007c783          	lbu	a5,0(a5)
    80011698:	873e                	mv	a4,a5
    8001169a:	02500793          	li	a5,37
    8001169e:	02f70b63          	beq	a4,a5,800116d4 <_vsnprintf+0x7c>
            // no
            out(*format, buffer, idx++, maxlen);
    800116a2:	f8043783          	ld	a5,-128(s0)
    800116a6:	0007c503          	lbu	a0,0(a5)
    800116aa:	fd843783          	ld	a5,-40(s0)
    800116ae:	00178713          	addi	a4,a5,1
    800116b2:	fce43c23          	sd	a4,-40(s0)
    800116b6:	f9843703          	ld	a4,-104(s0)
    800116ba:	f8843683          	ld	a3,-120(s0)
    800116be:	863e                	mv	a2,a5
    800116c0:	f9043583          	ld	a1,-112(s0)
    800116c4:	9702                	jalr	a4
            format++;
    800116c6:	f8043783          	ld	a5,-128(s0)
    800116ca:	0785                	addi	a5,a5,1
    800116cc:	f8f43023          	sd	a5,-128(s0)
            continue;
    800116d0:	3310006f          	j	80012200 <_vsnprintf+0xba8>
        }
        else {
            // yes, evaluate it
            format++;
    800116d4:	f8043783          	ld	a5,-128(s0)
    800116d8:	0785                	addi	a5,a5,1
    800116da:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate flags
        flags = 0U;
    800116de:	fe042623          	sw	zero,-20(s0)
        do {
            switch (*format) {
    800116e2:	f8043783          	ld	a5,-128(s0)
    800116e6:	0007c783          	lbu	a5,0(a5)
    800116ea:	2781                	sext.w	a5,a5
    800116ec:	fe07869b          	addiw	a3,a5,-32
    800116f0:	0006871b          	sext.w	a4,a3
    800116f4:	47c1                	li	a5,16
    800116f6:	0ce7e063          	bltu	a5,a4,800117b6 <_vsnprintf+0x15e>
    800116fa:	02069793          	slli	a5,a3,0x20
    800116fe:	9381                	srli	a5,a5,0x20
    80011700:	00279713          	slli	a4,a5,0x2
    80011704:	00010797          	auipc	a5,0x10
    80011708:	94878793          	addi	a5,a5,-1720 # 8002104c <SYSCALLS+0x4c>
    8001170c:	97ba                	add	a5,a5,a4
    8001170e:	439c                	lw	a5,0(a5)
    80011710:	0007871b          	sext.w	a4,a5
    80011714:	00010797          	auipc	a5,0x10
    80011718:	93878793          	addi	a5,a5,-1736 # 8002104c <SYSCALLS+0x4c>
    8001171c:	97ba                	add	a5,a5,a4
    8001171e:	8782                	jr	a5
                case '0':
                    flags |= FLAGS_ZEROPAD;
    80011720:	fec42783          	lw	a5,-20(s0)
    80011724:	0017e793          	ori	a5,a5,1
    80011728:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001172c:	f8043783          	ld	a5,-128(s0)
    80011730:	0785                	addi	a5,a5,1
    80011732:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011736:	4785                	li	a5,1
    80011738:	fef42023          	sw	a5,-32(s0)
                    break;
    8001173c:	a041                	j	800117bc <_vsnprintf+0x164>
                case '-':
                    flags |= FLAGS_LEFT;
    8001173e:	fec42783          	lw	a5,-20(s0)
    80011742:	0027e793          	ori	a5,a5,2
    80011746:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001174a:	f8043783          	ld	a5,-128(s0)
    8001174e:	0785                	addi	a5,a5,1
    80011750:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011754:	4785                	li	a5,1
    80011756:	fef42023          	sw	a5,-32(s0)
                    break;
    8001175a:	a08d                	j	800117bc <_vsnprintf+0x164>
                case '+':
                    flags |= FLAGS_PLUS;
    8001175c:	fec42783          	lw	a5,-20(s0)
    80011760:	0047e793          	ori	a5,a5,4
    80011764:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011768:	f8043783          	ld	a5,-128(s0)
    8001176c:	0785                	addi	a5,a5,1
    8001176e:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011772:	4785                	li	a5,1
    80011774:	fef42023          	sw	a5,-32(s0)
                    break;
    80011778:	a091                	j	800117bc <_vsnprintf+0x164>
                case ' ':
                    flags |= FLAGS_SPACE;
    8001177a:	fec42783          	lw	a5,-20(s0)
    8001177e:	0087e793          	ori	a5,a5,8
    80011782:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011786:	f8043783          	ld	a5,-128(s0)
    8001178a:	0785                	addi	a5,a5,1
    8001178c:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011790:	4785                	li	a5,1
    80011792:	fef42023          	sw	a5,-32(s0)
                    break;
    80011796:	a01d                	j	800117bc <_vsnprintf+0x164>
                case '#':
                    flags |= FLAGS_HASH;
    80011798:	fec42783          	lw	a5,-20(s0)
    8001179c:	0107e793          	ori	a5,a5,16
    800117a0:	fef42623          	sw	a5,-20(s0)
                    format++;
    800117a4:	f8043783          	ld	a5,-128(s0)
    800117a8:	0785                	addi	a5,a5,1
    800117aa:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    800117ae:	4785                	li	a5,1
    800117b0:	fef42023          	sw	a5,-32(s0)
                    break;
    800117b4:	a021                	j	800117bc <_vsnprintf+0x164>
                default:
                    n = 0U;
    800117b6:	fe042023          	sw	zero,-32(s0)
                    break;
    800117ba:	0001                	nop
            }
        } while (n);
    800117bc:	fe042783          	lw	a5,-32(s0)
    800117c0:	2781                	sext.w	a5,a5
    800117c2:	f385                	bnez	a5,800116e2 <_vsnprintf+0x8a>

        // evaluate width field
        width = 0U;
    800117c4:	fe042423          	sw	zero,-24(s0)
        if (_is_digit(*format)) {
    800117c8:	f8043783          	ld	a5,-128(s0)
    800117cc:	0007c783          	lbu	a5,0(a5)
    800117d0:	853e                	mv	a0,a5
    800117d2:	df3fe0ef          	jal	ra,800105c4 <_is_digit>
    800117d6:	87aa                	mv	a5,a0
    800117d8:	cb91                	beqz	a5,800117ec <_vsnprintf+0x194>
            width = _atoi(&format);
    800117da:	f8040793          	addi	a5,s0,-128
    800117de:	853e                	mv	a0,a5
    800117e0:	e25fe0ef          	jal	ra,80010604 <_atoi>
    800117e4:	87aa                	mv	a5,a0
    800117e6:	fef42423          	sw	a5,-24(s0)
    800117ea:	a8b9                	j	80011848 <_vsnprintf+0x1f0>
        }
        else if (*format == '*') {
    800117ec:	f8043783          	ld	a5,-128(s0)
    800117f0:	0007c783          	lbu	a5,0(a5)
    800117f4:	873e                	mv	a4,a5
    800117f6:	02a00793          	li	a5,42
    800117fa:	04f71763          	bne	a4,a5,80011848 <_vsnprintf+0x1f0>
            const int w = va_arg(va, int);
    800117fe:	f7843783          	ld	a5,-136(s0)
    80011802:	00878713          	addi	a4,a5,8
    80011806:	f6e43c23          	sd	a4,-136(s0)
    8001180a:	439c                	lw	a5,0(a5)
    8001180c:	fcf42023          	sw	a5,-64(s0)
            if (w < 0) {
    80011810:	fc042783          	lw	a5,-64(s0)
    80011814:	2781                	sext.w	a5,a5
    80011816:	0207d063          	bgez	a5,80011836 <_vsnprintf+0x1de>
                flags |= FLAGS_LEFT;  // reverse padding
    8001181a:	fec42783          	lw	a5,-20(s0)
    8001181e:	0027e793          	ori	a5,a5,2
    80011822:	fef42623          	sw	a5,-20(s0)
                width = (unsigned int)-w;
    80011826:	fc042783          	lw	a5,-64(s0)
    8001182a:	40f007bb          	negw	a5,a5
    8001182e:	2781                	sext.w	a5,a5
    80011830:	fef42423          	sw	a5,-24(s0)
    80011834:	a029                	j	8001183e <_vsnprintf+0x1e6>
            }
            else {
                width = (unsigned int)w;
    80011836:	fc042783          	lw	a5,-64(s0)
    8001183a:	fef42423          	sw	a5,-24(s0)
            }
            format++;
    8001183e:	f8043783          	ld	a5,-128(s0)
    80011842:	0785                	addi	a5,a5,1
    80011844:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate precision field
        precision = 0U;
    80011848:	fe042223          	sw	zero,-28(s0)
        if (*format == '.') {
    8001184c:	f8043783          	ld	a5,-128(s0)
    80011850:	0007c783          	lbu	a5,0(a5)
    80011854:	873e                	mv	a4,a5
    80011856:	02e00793          	li	a5,46
    8001185a:	08f71063          	bne	a4,a5,800118da <_vsnprintf+0x282>
            flags |= FLAGS_PRECISION;
    8001185e:	fec42783          	lw	a5,-20(s0)
    80011862:	4007e793          	ori	a5,a5,1024
    80011866:	fef42623          	sw	a5,-20(s0)
            format++;
    8001186a:	f8043783          	ld	a5,-128(s0)
    8001186e:	0785                	addi	a5,a5,1
    80011870:	f8f43023          	sd	a5,-128(s0)
            if (_is_digit(*format)) {
    80011874:	f8043783          	ld	a5,-128(s0)
    80011878:	0007c783          	lbu	a5,0(a5)
    8001187c:	853e                	mv	a0,a5
    8001187e:	d47fe0ef          	jal	ra,800105c4 <_is_digit>
    80011882:	87aa                	mv	a5,a0
    80011884:	cb91                	beqz	a5,80011898 <_vsnprintf+0x240>
                precision = _atoi(&format);
    80011886:	f8040793          	addi	a5,s0,-128
    8001188a:	853e                	mv	a0,a5
    8001188c:	d79fe0ef          	jal	ra,80010604 <_atoi>
    80011890:	87aa                	mv	a5,a0
    80011892:	fef42223          	sw	a5,-28(s0)
    80011896:	a091                	j	800118da <_vsnprintf+0x282>
            }
            else if (*format == '*') {
    80011898:	f8043783          	ld	a5,-128(s0)
    8001189c:	0007c783          	lbu	a5,0(a5)
    800118a0:	873e                	mv	a4,a5
    800118a2:	02a00793          	li	a5,42
    800118a6:	02f71a63          	bne	a4,a5,800118da <_vsnprintf+0x282>
                const int prec = (int)va_arg(va, int);
    800118aa:	f7843783          	ld	a5,-136(s0)
    800118ae:	00878713          	addi	a4,a5,8
    800118b2:	f6e43c23          	sd	a4,-136(s0)
    800118b6:	439c                	lw	a5,0(a5)
    800118b8:	faf42e23          	sw	a5,-68(s0)
                precision      = prec > 0 ? (unsigned int)prec : 0U;
    800118bc:	fbc42783          	lw	a5,-68(s0)
    800118c0:	0007871b          	sext.w	a4,a5
    800118c4:	00075363          	bgez	a4,800118ca <_vsnprintf+0x272>
    800118c8:	4781                	li	a5,0
    800118ca:	2781                	sext.w	a5,a5
    800118cc:	fef42223          	sw	a5,-28(s0)
                format++;
    800118d0:	f8043783          	ld	a5,-128(s0)
    800118d4:	0785                	addi	a5,a5,1
    800118d6:	f8f43023          	sd	a5,-128(s0)
            }
        }

        // evaluate length field
        switch (*format) {
    800118da:	f8043783          	ld	a5,-128(s0)
    800118de:	0007c783          	lbu	a5,0(a5)
    800118e2:	2781                	sext.w	a5,a5
    800118e4:	f987869b          	addiw	a3,a5,-104
    800118e8:	0006871b          	sext.w	a4,a3
    800118ec:	47c9                	li	a5,18
    800118ee:	0ee7e963          	bltu	a5,a4,800119e0 <_vsnprintf+0x388>
    800118f2:	02069793          	slli	a5,a3,0x20
    800118f6:	9381                	srli	a5,a5,0x20
    800118f8:	00279713          	slli	a4,a5,0x2
    800118fc:	0000f797          	auipc	a5,0xf
    80011900:	79478793          	addi	a5,a5,1940 # 80021090 <SYSCALLS+0x90>
    80011904:	97ba                	add	a5,a5,a4
    80011906:	439c                	lw	a5,0(a5)
    80011908:	0007871b          	sext.w	a4,a5
    8001190c:	0000f797          	auipc	a5,0xf
    80011910:	78478793          	addi	a5,a5,1924 # 80021090 <SYSCALLS+0x90>
    80011914:	97ba                	add	a5,a5,a4
    80011916:	8782                	jr	a5
            case 'l':
                flags |= FLAGS_LONG;
    80011918:	fec42783          	lw	a5,-20(s0)
    8001191c:	1007e793          	ori	a5,a5,256
    80011920:	fef42623          	sw	a5,-20(s0)
                format++;
    80011924:	f8043783          	ld	a5,-128(s0)
    80011928:	0785                	addi	a5,a5,1
    8001192a:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'l') {
    8001192e:	f8043783          	ld	a5,-128(s0)
    80011932:	0007c783          	lbu	a5,0(a5)
    80011936:	873e                	mv	a4,a5
    80011938:	06c00793          	li	a5,108
    8001193c:	0af71463          	bne	a4,a5,800119e4 <_vsnprintf+0x38c>
                    flags |= FLAGS_LONG_LONG;
    80011940:	fec42783          	lw	a5,-20(s0)
    80011944:	2007e793          	ori	a5,a5,512
    80011948:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001194c:	f8043783          	ld	a5,-128(s0)
    80011950:	0785                	addi	a5,a5,1
    80011952:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80011956:	a079                	j	800119e4 <_vsnprintf+0x38c>
            case 'h':
                flags |= FLAGS_SHORT;
    80011958:	fec42783          	lw	a5,-20(s0)
    8001195c:	0807e793          	ori	a5,a5,128
    80011960:	fef42623          	sw	a5,-20(s0)
                format++;
    80011964:	f8043783          	ld	a5,-128(s0)
    80011968:	0785                	addi	a5,a5,1
    8001196a:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'h') {
    8001196e:	f8043783          	ld	a5,-128(s0)
    80011972:	0007c783          	lbu	a5,0(a5)
    80011976:	873e                	mv	a4,a5
    80011978:	06800793          	li	a5,104
    8001197c:	06f71663          	bne	a4,a5,800119e8 <_vsnprintf+0x390>
                    flags |= FLAGS_CHAR;
    80011980:	fec42783          	lw	a5,-20(s0)
    80011984:	0407e793          	ori	a5,a5,64
    80011988:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001198c:	f8043783          	ld	a5,-128(s0)
    80011990:	0785                	addi	a5,a5,1
    80011992:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80011996:	a889                	j	800119e8 <_vsnprintf+0x390>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
            case 't':
                flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG
    80011998:	fec42783          	lw	a5,-20(s0)
    8001199c:	1007e793          	ori	a5,a5,256
    800119a0:	fef42623          	sw	a5,-20(s0)
                                                            : FLAGS_LONG_LONG);
                format++;
    800119a4:	f8043783          	ld	a5,-128(s0)
    800119a8:	0785                	addi	a5,a5,1
    800119aa:	f8f43023          	sd	a5,-128(s0)
                break;
    800119ae:	a835                	j	800119ea <_vsnprintf+0x392>
#endif
            case 'j':
                flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG
    800119b0:	fec42783          	lw	a5,-20(s0)
    800119b4:	1007e793          	ori	a5,a5,256
    800119b8:	fef42623          	sw	a5,-20(s0)
                                                           : FLAGS_LONG_LONG);
                format++;
    800119bc:	f8043783          	ld	a5,-128(s0)
    800119c0:	0785                	addi	a5,a5,1
    800119c2:	f8f43023          	sd	a5,-128(s0)
                break;
    800119c6:	a015                	j	800119ea <_vsnprintf+0x392>
            case 'z':
                flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG
    800119c8:	fec42783          	lw	a5,-20(s0)
    800119cc:	1007e793          	ori	a5,a5,256
    800119d0:	fef42623          	sw	a5,-20(s0)
                                                         : FLAGS_LONG_LONG);
                format++;
    800119d4:	f8043783          	ld	a5,-128(s0)
    800119d8:	0785                	addi	a5,a5,1
    800119da:	f8f43023          	sd	a5,-128(s0)
                break;
    800119de:	a031                	j	800119ea <_vsnprintf+0x392>
            default:
                break;
    800119e0:	0001                	nop
    800119e2:	a021                	j	800119ea <_vsnprintf+0x392>
                break;
    800119e4:	0001                	nop
    800119e6:	a011                	j	800119ea <_vsnprintf+0x392>
                break;
    800119e8:	0001                	nop
        }

        // evaluate specifier
        switch (*format) {
    800119ea:	f8043783          	ld	a5,-128(s0)
    800119ee:	0007c783          	lbu	a5,0(a5)
    800119f2:	2781                	sext.w	a5,a5
    800119f4:	fdb7869b          	addiw	a3,a5,-37
    800119f8:	0006871b          	sext.w	a4,a3
    800119fc:	05300793          	li	a5,83
    80011a00:	7ce7e863          	bltu	a5,a4,800121d0 <_vsnprintf+0xb78>
    80011a04:	02069793          	slli	a5,a3,0x20
    80011a08:	9381                	srli	a5,a5,0x20
    80011a0a:	00279713          	slli	a4,a5,0x2
    80011a0e:	0000f797          	auipc	a5,0xf
    80011a12:	6ce78793          	addi	a5,a5,1742 # 800210dc <SYSCALLS+0xdc>
    80011a16:	97ba                	add	a5,a5,a4
    80011a18:	439c                	lw	a5,0(a5)
    80011a1a:	0007871b          	sext.w	a4,a5
    80011a1e:	0000f797          	auipc	a5,0xf
    80011a22:	6be78793          	addi	a5,a5,1726 # 800210dc <SYSCALLS+0xdc>
    80011a26:	97ba                	add	a5,a5,a4
    80011a28:	8782                	jr	a5
            case 'X':
            case 'o':
            case 'b': {
                // set the base
                unsigned int base;
                if (*format == 'x' || *format == 'X') {
    80011a2a:	f8043783          	ld	a5,-128(s0)
    80011a2e:	0007c783          	lbu	a5,0(a5)
    80011a32:	873e                	mv	a4,a5
    80011a34:	07800793          	li	a5,120
    80011a38:	00f70b63          	beq	a4,a5,80011a4e <_vsnprintf+0x3f6>
    80011a3c:	f8043783          	ld	a5,-128(s0)
    80011a40:	0007c783          	lbu	a5,0(a5)
    80011a44:	873e                	mv	a4,a5
    80011a46:	05800793          	li	a5,88
    80011a4a:	00f71663          	bne	a4,a5,80011a56 <_vsnprintf+0x3fe>
                    base = 16U;
    80011a4e:	47c1                	li	a5,16
    80011a50:	fcf42a23          	sw	a5,-44(s0)
    80011a54:	a099                	j	80011a9a <_vsnprintf+0x442>
                }
                else if (*format == 'o') {
    80011a56:	f8043783          	ld	a5,-128(s0)
    80011a5a:	0007c783          	lbu	a5,0(a5)
    80011a5e:	873e                	mv	a4,a5
    80011a60:	06f00793          	li	a5,111
    80011a64:	00f71663          	bne	a4,a5,80011a70 <_vsnprintf+0x418>
                    base = 8U;
    80011a68:	47a1                	li	a5,8
    80011a6a:	fcf42a23          	sw	a5,-44(s0)
    80011a6e:	a035                	j	80011a9a <_vsnprintf+0x442>
                }
                else if (*format == 'b') {
    80011a70:	f8043783          	ld	a5,-128(s0)
    80011a74:	0007c783          	lbu	a5,0(a5)
    80011a78:	873e                	mv	a4,a5
    80011a7a:	06200793          	li	a5,98
    80011a7e:	00f71663          	bne	a4,a5,80011a8a <_vsnprintf+0x432>
                    base = 2U;
    80011a82:	4789                	li	a5,2
    80011a84:	fcf42a23          	sw	a5,-44(s0)
    80011a88:	a809                	j	80011a9a <_vsnprintf+0x442>
                }
                else {
                    base = 10U;
    80011a8a:	47a9                	li	a5,10
    80011a8c:	fcf42a23          	sw	a5,-44(s0)
                    flags &= ~FLAGS_HASH;  // no hash for dec format
    80011a90:	fec42783          	lw	a5,-20(s0)
    80011a94:	9bbd                	andi	a5,a5,-17
    80011a96:	fef42623          	sw	a5,-20(s0)
                }
                // uppercase
                if (*format == 'X') {
    80011a9a:	f8043783          	ld	a5,-128(s0)
    80011a9e:	0007c783          	lbu	a5,0(a5)
    80011aa2:	873e                	mv	a4,a5
    80011aa4:	05800793          	li	a5,88
    80011aa8:	00f71863          	bne	a4,a5,80011ab8 <_vsnprintf+0x460>
                    flags |= FLAGS_UPPERCASE;
    80011aac:	fec42783          	lw	a5,-20(s0)
    80011ab0:	0207e793          	ori	a5,a5,32
    80011ab4:	fef42623          	sw	a5,-20(s0)
                }

                // no plus or space flag for u, x, X, o, b
                if ((*format != 'i') && (*format != 'd')) {
    80011ab8:	f8043783          	ld	a5,-128(s0)
    80011abc:	0007c783          	lbu	a5,0(a5)
    80011ac0:	873e                	mv	a4,a5
    80011ac2:	06900793          	li	a5,105
    80011ac6:	02f70063          	beq	a4,a5,80011ae6 <_vsnprintf+0x48e>
    80011aca:	f8043783          	ld	a5,-128(s0)
    80011ace:	0007c783          	lbu	a5,0(a5)
    80011ad2:	873e                	mv	a4,a5
    80011ad4:	06400793          	li	a5,100
    80011ad8:	00f70763          	beq	a4,a5,80011ae6 <_vsnprintf+0x48e>
                    flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    80011adc:	fec42783          	lw	a5,-20(s0)
    80011ae0:	9bcd                	andi	a5,a5,-13
    80011ae2:	fef42623          	sw	a5,-20(s0)
                }

                // ignore '0' flag when precision is given
                if (flags & FLAGS_PRECISION) {
    80011ae6:	fec42783          	lw	a5,-20(s0)
    80011aea:	4007f793          	andi	a5,a5,1024
    80011aee:	2781                	sext.w	a5,a5
    80011af0:	c791                	beqz	a5,80011afc <_vsnprintf+0x4a4>
                    flags &= ~FLAGS_ZEROPAD;
    80011af2:	fec42783          	lw	a5,-20(s0)
    80011af6:	9bf9                	andi	a5,a5,-2
    80011af8:	fef42623          	sw	a5,-20(s0)
                }

                // convert the integer
                if ((*format == 'i') || (*format == 'd')) {
    80011afc:	f8043783          	ld	a5,-128(s0)
    80011b00:	0007c783          	lbu	a5,0(a5)
    80011b04:	873e                	mv	a4,a5
    80011b06:	06900793          	li	a5,105
    80011b0a:	00f70b63          	beq	a4,a5,80011b20 <_vsnprintf+0x4c8>
    80011b0e:	f8043783          	ld	a5,-128(s0)
    80011b12:	0007c783          	lbu	a5,0(a5)
    80011b16:	873e                	mv	a4,a5
    80011b18:	06400793          	li	a5,100
    80011b1c:	18f71d63          	bne	a4,a5,80011cb6 <_vsnprintf+0x65e>
                    // signed
                    if (flags & FLAGS_LONG_LONG) {
    80011b20:	fec42783          	lw	a5,-20(s0)
    80011b24:	2007f793          	andi	a5,a5,512
    80011b28:	2781                	sext.w	a5,a5
    80011b2a:	c3bd                	beqz	a5,80011b90 <_vsnprintf+0x538>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        const long long value = va_arg(va, long long);
    80011b2c:	f7843783          	ld	a5,-136(s0)
    80011b30:	00878713          	addi	a4,a5,8
    80011b34:	f6e43c23          	sd	a4,-136(s0)
    80011b38:	639c                	ld	a5,0(a5)
    80011b3a:	faf43023          	sd	a5,-96(s0)
                        idx                   = _ntoa_long_long(
                                              out, buffer, idx, maxlen,
                                              (unsigned long long)(value > 0 ? value : 0 - value),
    80011b3e:	fa043783          	ld	a5,-96(s0)
    80011b42:	43f7d713          	srai	a4,a5,0x3f
    80011b46:	fa043783          	ld	a5,-96(s0)
    80011b4a:	8fb9                	xor	a5,a5,a4
    80011b4c:	8f99                	sub	a5,a5,a4
                        idx                   = _ntoa_long_long(
    80011b4e:	85be                	mv	a1,a5
    80011b50:	fa043783          	ld	a5,-96(s0)
    80011b54:	93fd                	srli	a5,a5,0x3f
    80011b56:	0ff7f713          	andi	a4,a5,255
    80011b5a:	fd446683          	lwu	a3,-44(s0)
    80011b5e:	fe442603          	lw	a2,-28(s0)
    80011b62:	fec42783          	lw	a5,-20(s0)
    80011b66:	e43e                	sd	a5,8(sp)
    80011b68:	fe842783          	lw	a5,-24(s0)
    80011b6c:	e03e                	sd	a5,0(sp)
    80011b6e:	88b2                	mv	a7,a2
    80011b70:	8836                	mv	a6,a3
    80011b72:	87ba                	mv	a5,a4
    80011b74:	872e                	mv	a4,a1
    80011b76:	f8843683          	ld	a3,-120(s0)
    80011b7a:	fd843603          	ld	a2,-40(s0)
    80011b7e:	f9043583          	ld	a1,-112(s0)
    80011b82:	f9843503          	ld	a0,-104(s0)
    80011b86:	fadfe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80011b8a:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011b8e:	ac89                	j	80011de0 <_vsnprintf+0x788>
                                              value < 0, base, precision, width, flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80011b90:	fec42783          	lw	a5,-20(s0)
    80011b94:	1007f793          	andi	a5,a5,256
    80011b98:	2781                	sext.w	a5,a5
    80011b9a:	c3bd                	beqz	a5,80011c00 <_vsnprintf+0x5a8>
                        const long value = va_arg(va, long);
    80011b9c:	f7843783          	ld	a5,-136(s0)
    80011ba0:	00878713          	addi	a4,a5,8
    80011ba4:	f6e43c23          	sd	a4,-136(s0)
    80011ba8:	639c                	ld	a5,0(a5)
    80011baa:	faf43423          	sd	a5,-88(s0)
                        idx              = _ntoa_long(
                                         out, buffer, idx, maxlen,
                                         (unsigned long)(value > 0 ? value : 0 - value),
    80011bae:	fa843783          	ld	a5,-88(s0)
    80011bb2:	43f7d713          	srai	a4,a5,0x3f
    80011bb6:	fa843783          	ld	a5,-88(s0)
    80011bba:	8fb9                	xor	a5,a5,a4
    80011bbc:	8f99                	sub	a5,a5,a4
                        idx              = _ntoa_long(
    80011bbe:	85be                	mv	a1,a5
    80011bc0:	fa843783          	ld	a5,-88(s0)
    80011bc4:	93fd                	srli	a5,a5,0x3f
    80011bc6:	0ff7f713          	andi	a4,a5,255
    80011bca:	fd446683          	lwu	a3,-44(s0)
    80011bce:	fe442603          	lw	a2,-28(s0)
    80011bd2:	fec42783          	lw	a5,-20(s0)
    80011bd6:	e43e                	sd	a5,8(sp)
    80011bd8:	fe842783          	lw	a5,-24(s0)
    80011bdc:	e03e                	sd	a5,0(sp)
    80011bde:	88b2                	mv	a7,a2
    80011be0:	8836                	mv	a6,a3
    80011be2:	87ba                	mv	a5,a4
    80011be4:	872e                	mv	a4,a1
    80011be6:	f8843683          	ld	a3,-120(s0)
    80011bea:	fd843603          	ld	a2,-40(s0)
    80011bee:	f9043583          	ld	a1,-112(s0)
    80011bf2:	f9843503          	ld	a0,-104(s0)
    80011bf6:	e25fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011bfa:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011bfe:	a2cd                	j	80011de0 <_vsnprintf+0x788>
                                         value < 0, base, precision, width, flags);
                    }
                    else {
                        const int value =
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011c00:	fec42783          	lw	a5,-20(s0)
    80011c04:	0407f793          	andi	a5,a5,64
    80011c08:	2781                	sext.w	a5,a5
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c0a:	cf81                	beqz	a5,80011c22 <_vsnprintf+0x5ca>
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011c0c:	f7843783          	ld	a5,-136(s0)
    80011c10:	00878713          	addi	a4,a5,8
    80011c14:	f6e43c23          	sd	a4,-136(s0)
    80011c18:	439c                	lw	a5,0(a5)
    80011c1a:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c1e:	2781                	sext.w	a5,a5
    80011c20:	a81d                	j	80011c56 <_vsnprintf+0x5fe>
    80011c22:	fec42783          	lw	a5,-20(s0)
    80011c26:	0807f793          	andi	a5,a5,128
    80011c2a:	2781                	sext.w	a5,a5
                                                    : va_arg(va, int);
    80011c2c:	cf91                	beqz	a5,80011c48 <_vsnprintf+0x5f0>
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c2e:	f7843783          	ld	a5,-136(s0)
    80011c32:	00878713          	addi	a4,a5,8
    80011c36:	f6e43c23          	sd	a4,-136(s0)
    80011c3a:	439c                	lw	a5,0(a5)
    80011c3c:	0107979b          	slliw	a5,a5,0x10
    80011c40:	4107d79b          	sraiw	a5,a5,0x10
                                                    : va_arg(va, int);
    80011c44:	2781                	sext.w	a5,a5
    80011c46:	a801                	j	80011c56 <_vsnprintf+0x5fe>
    80011c48:	f7843783          	ld	a5,-136(s0)
    80011c4c:	00878713          	addi	a4,a5,8
    80011c50:	f6e43c23          	sd	a4,-136(s0)
    80011c54:	439c                	lw	a5,0(a5)
                        const int value =
    80011c56:	faf42823          	sw	a5,-80(s0)
                        idx = _ntoa_long(
                            out, buffer, idx, maxlen,
                            (unsigned int)(value > 0 ? value : 0 - value),
    80011c5a:	fb042783          	lw	a5,-80(s0)
    80011c5e:	41f7d79b          	sraiw	a5,a5,0x1f
    80011c62:	fb042703          	lw	a4,-80(s0)
    80011c66:	8f3d                	xor	a4,a4,a5
    80011c68:	40f707bb          	subw	a5,a4,a5
    80011c6c:	2781                	sext.w	a5,a5
    80011c6e:	2781                	sext.w	a5,a5
                        idx = _ntoa_long(
    80011c70:	02079713          	slli	a4,a5,0x20
    80011c74:	9301                	srli	a4,a4,0x20
    80011c76:	fb042783          	lw	a5,-80(s0)
    80011c7a:	01f7d79b          	srliw	a5,a5,0x1f
    80011c7e:	0ff7f693          	andi	a3,a5,255
    80011c82:	fd446603          	lwu	a2,-44(s0)
    80011c86:	fe442583          	lw	a1,-28(s0)
    80011c8a:	fec42783          	lw	a5,-20(s0)
    80011c8e:	e43e                	sd	a5,8(sp)
    80011c90:	fe842783          	lw	a5,-24(s0)
    80011c94:	e03e                	sd	a5,0(sp)
    80011c96:	88ae                	mv	a7,a1
    80011c98:	8832                	mv	a6,a2
    80011c9a:	87b6                	mv	a5,a3
    80011c9c:	f8843683          	ld	a3,-120(s0)
    80011ca0:	fd843603          	ld	a2,-40(s0)
    80011ca4:	f9043583          	ld	a1,-112(s0)
    80011ca8:	f9843503          	ld	a0,-104(s0)
    80011cac:	d6ffe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011cb0:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011cb4:	a235                	j	80011de0 <_vsnprintf+0x788>
                            value < 0, base, precision, width, flags);
                    }
                }
                else {
                    // unsigned
                    if (flags & FLAGS_LONG_LONG) {
    80011cb6:	fec42783          	lw	a5,-20(s0)
    80011cba:	2007f793          	andi	a5,a5,512
    80011cbe:	2781                	sext.w	a5,a5
    80011cc0:	c3b1                	beqz	a5,80011d04 <_vsnprintf+0x6ac>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80011cc2:	f7843783          	ld	a5,-136(s0)
    80011cc6:	00878713          	addi	a4,a5,8
    80011cca:	f6e43c23          	sd	a4,-136(s0)
    80011cce:	6398                	ld	a4,0(a5)
    80011cd0:	fd446683          	lwu	a3,-44(s0)
    80011cd4:	fe442603          	lw	a2,-28(s0)
    80011cd8:	fec42783          	lw	a5,-20(s0)
    80011cdc:	e43e                	sd	a5,8(sp)
    80011cde:	fe842783          	lw	a5,-24(s0)
    80011ce2:	e03e                	sd	a5,0(sp)
    80011ce4:	88b2                	mv	a7,a2
    80011ce6:	8836                	mv	a6,a3
    80011ce8:	4781                	li	a5,0
    80011cea:	f8843683          	ld	a3,-120(s0)
    80011cee:	fd843603          	ld	a2,-40(s0)
    80011cf2:	f9043583          	ld	a1,-112(s0)
    80011cf6:	f9843503          	ld	a0,-104(s0)
    80011cfa:	e39fe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80011cfe:	fca43c23          	sd	a0,-40(s0)
    80011d02:	a8f9                	j	80011de0 <_vsnprintf+0x788>
                                              va_arg(va, unsigned long long),
                                              false, base, precision, width,
                                              flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80011d04:	fec42783          	lw	a5,-20(s0)
    80011d08:	1007f793          	andi	a5,a5,256
    80011d0c:	2781                	sext.w	a5,a5
    80011d0e:	c3b1                	beqz	a5,80011d52 <_vsnprintf+0x6fa>
                        idx = _ntoa_long(out, buffer, idx, maxlen,
    80011d10:	f7843783          	ld	a5,-136(s0)
    80011d14:	00878713          	addi	a4,a5,8
    80011d18:	f6e43c23          	sd	a4,-136(s0)
    80011d1c:	6398                	ld	a4,0(a5)
    80011d1e:	fd446683          	lwu	a3,-44(s0)
    80011d22:	fe442603          	lw	a2,-28(s0)
    80011d26:	fec42783          	lw	a5,-20(s0)
    80011d2a:	e43e                	sd	a5,8(sp)
    80011d2c:	fe842783          	lw	a5,-24(s0)
    80011d30:	e03e                	sd	a5,0(sp)
    80011d32:	88b2                	mv	a7,a2
    80011d34:	8836                	mv	a6,a3
    80011d36:	4781                	li	a5,0
    80011d38:	f8843683          	ld	a3,-120(s0)
    80011d3c:	fd843603          	ld	a2,-40(s0)
    80011d40:	f9043583          	ld	a1,-112(s0)
    80011d44:	f9843503          	ld	a0,-104(s0)
    80011d48:	cd3fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011d4c:	fca43c23          	sd	a0,-40(s0)
    80011d50:	a841                	j	80011de0 <_vsnprintf+0x788>
                                         va_arg(va, unsigned long), false, base,
                                         precision, width, flags);
                    }
                    else {
                        const unsigned int value =
                            (flags & FLAGS_CHAR)
    80011d52:	fec42783          	lw	a5,-20(s0)
    80011d56:	0407f793          	andi	a5,a5,64
    80011d5a:	2781                	sext.w	a5,a5
                                ? (unsigned char)va_arg(va, unsigned int)
                            : (flags & FLAGS_SHORT)
    80011d5c:	cf81                	beqz	a5,80011d74 <_vsnprintf+0x71c>
                                ? (unsigned char)va_arg(va, unsigned int)
    80011d5e:	f7843783          	ld	a5,-136(s0)
    80011d62:	00878713          	addi	a4,a5,8
    80011d66:	f6e43c23          	sd	a4,-136(s0)
    80011d6a:	439c                	lw	a5,0(a5)
    80011d6c:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT)
    80011d70:	2781                	sext.w	a5,a5
    80011d72:	a815                	j	80011da6 <_vsnprintf+0x74e>
    80011d74:	fec42783          	lw	a5,-20(s0)
    80011d78:	0807f793          	andi	a5,a5,128
    80011d7c:	2781                	sext.w	a5,a5
                                ? (unsigned short int)va_arg(va, unsigned int)
                                : va_arg(va, unsigned int);
    80011d7e:	cf81                	beqz	a5,80011d96 <_vsnprintf+0x73e>
                                ? (unsigned short int)va_arg(va, unsigned int)
    80011d80:	f7843783          	ld	a5,-136(s0)
    80011d84:	00878713          	addi	a4,a5,8
    80011d88:	f6e43c23          	sd	a4,-136(s0)
    80011d8c:	439c                	lw	a5,0(a5)
    80011d8e:	17c2                	slli	a5,a5,0x30
    80011d90:	93c1                	srli	a5,a5,0x30
                                : va_arg(va, unsigned int);
    80011d92:	2781                	sext.w	a5,a5
    80011d94:	a801                	j	80011da4 <_vsnprintf+0x74c>
    80011d96:	f7843783          	ld	a5,-136(s0)
    80011d9a:	00878713          	addi	a4,a5,8
    80011d9e:	f6e43c23          	sd	a4,-136(s0)
    80011da2:	439c                	lw	a5,0(a5)
                            : (flags & FLAGS_SHORT)
    80011da4:	2781                	sext.w	a5,a5
                        const unsigned int value =
    80011da6:	faf42a23          	sw	a5,-76(s0)
                        idx = _ntoa_long(out, buffer, idx, maxlen, value, false,
    80011daa:	fb446703          	lwu	a4,-76(s0)
    80011dae:	fd446683          	lwu	a3,-44(s0)
    80011db2:	fe442603          	lw	a2,-28(s0)
    80011db6:	fec42783          	lw	a5,-20(s0)
    80011dba:	e43e                	sd	a5,8(sp)
    80011dbc:	fe842783          	lw	a5,-24(s0)
    80011dc0:	e03e                	sd	a5,0(sp)
    80011dc2:	88b2                	mv	a7,a2
    80011dc4:	8836                	mv	a6,a3
    80011dc6:	4781                	li	a5,0
    80011dc8:	f8843683          	ld	a3,-120(s0)
    80011dcc:	fd843603          	ld	a2,-40(s0)
    80011dd0:	f9043583          	ld	a1,-112(s0)
    80011dd4:	f9843503          	ld	a0,-104(s0)
    80011dd8:	c43fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011ddc:	fca43c23          	sd	a0,-40(s0)
                                         base, precision, width, flags);
                    }
                }
                format++;
    80011de0:	f8043783          	ld	a5,-128(s0)
    80011de4:	0785                	addi	a5,a5,1
    80011de6:	f8f43023          	sd	a5,-128(s0)
                break;
    80011dea:	a919                	j	80012200 <_vsnprintf+0xba8>
            }
#if defined(PRINTF_SUPPORT_FLOAT)
            case 'f':
            case 'F':
                if (*format == 'F')
    80011dec:	f8043783          	ld	a5,-128(s0)
    80011df0:	0007c783          	lbu	a5,0(a5)
    80011df4:	873e                	mv	a4,a5
    80011df6:	04600793          	li	a5,70
    80011dfa:	00f71863          	bne	a4,a5,80011e0a <_vsnprintf+0x7b2>
                    flags |= FLAGS_UPPERCASE;
    80011dfe:	fec42783          	lw	a5,-20(s0)
    80011e02:	0207e793          	ori	a5,a5,32
    80011e06:	fef42623          	sw	a5,-20(s0)
                idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011e0a:	f7843783          	ld	a5,-136(s0)
    80011e0e:	00878713          	addi	a4,a5,8
    80011e12:	f6e43c23          	sd	a4,-136(s0)
    80011e16:	239c                	fld	fa5,0(a5)
    80011e18:	fec42683          	lw	a3,-20(s0)
    80011e1c:	fe842783          	lw	a5,-24(s0)
    80011e20:	fe442703          	lw	a4,-28(s0)
    80011e24:	8836                	mv	a6,a3
    80011e26:	22f78553          	fmv.d	fa0,fa5
    80011e2a:	f8843683          	ld	a3,-120(s0)
    80011e2e:	fd843603          	ld	a2,-40(s0)
    80011e32:	f9043583          	ld	a1,-112(s0)
    80011e36:	f9843503          	ld	a0,-104(s0)
    80011e3a:	e11fe0ef          	jal	ra,80010c4a <_ftoa>
    80011e3e:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011e42:	f8043783          	ld	a5,-128(s0)
    80011e46:	0785                	addi	a5,a5,1
    80011e48:	f8f43023          	sd	a5,-128(s0)
                break;
    80011e4c:	ae55                	j	80012200 <_vsnprintf+0xba8>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
            case 'e':
            case 'E':
            case 'g':
            case 'G':
                if ((*format == 'g') || (*format == 'G'))
    80011e4e:	f8043783          	ld	a5,-128(s0)
    80011e52:	0007c783          	lbu	a5,0(a5)
    80011e56:	873e                	mv	a4,a5
    80011e58:	06700793          	li	a5,103
    80011e5c:	00f70b63          	beq	a4,a5,80011e72 <_vsnprintf+0x81a>
    80011e60:	f8043783          	ld	a5,-128(s0)
    80011e64:	0007c783          	lbu	a5,0(a5)
    80011e68:	873e                	mv	a4,a5
    80011e6a:	04700793          	li	a5,71
    80011e6e:	00f71a63          	bne	a4,a5,80011e82 <_vsnprintf+0x82a>
                    flags |= FLAGS_ADAPT_EXP;
    80011e72:	fec42703          	lw	a4,-20(s0)
    80011e76:	6785                	lui	a5,0x1
    80011e78:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80011e7c:	8fd9                	or	a5,a5,a4
    80011e7e:	fef42623          	sw	a5,-20(s0)
                if ((*format == 'E') || (*format == 'G'))
    80011e82:	f8043783          	ld	a5,-128(s0)
    80011e86:	0007c783          	lbu	a5,0(a5)
    80011e8a:	873e                	mv	a4,a5
    80011e8c:	04500793          	li	a5,69
    80011e90:	00f70b63          	beq	a4,a5,80011ea6 <_vsnprintf+0x84e>
    80011e94:	f8043783          	ld	a5,-128(s0)
    80011e98:	0007c783          	lbu	a5,0(a5)
    80011e9c:	873e                	mv	a4,a5
    80011e9e:	04700793          	li	a5,71
    80011ea2:	00f71863          	bne	a4,a5,80011eb2 <_vsnprintf+0x85a>
                    flags |= FLAGS_UPPERCASE;
    80011ea6:	fec42783          	lw	a5,-20(s0)
    80011eaa:	0207e793          	ori	a5,a5,32
    80011eae:	fef42623          	sw	a5,-20(s0)
                idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011eb2:	f7843783          	ld	a5,-136(s0)
    80011eb6:	00878713          	addi	a4,a5,8
    80011eba:	f6e43c23          	sd	a4,-136(s0)
    80011ebe:	239c                	fld	fa5,0(a5)
    80011ec0:	fec42683          	lw	a3,-20(s0)
    80011ec4:	fe842783          	lw	a5,-24(s0)
    80011ec8:	fe442703          	lw	a4,-28(s0)
    80011ecc:	8836                	mv	a6,a3
    80011ece:	22f78553          	fmv.d	fa0,fa5
    80011ed2:	f8843683          	ld	a3,-120(s0)
    80011ed6:	fd843603          	ld	a2,-40(s0)
    80011eda:	f9043583          	ld	a1,-112(s0)
    80011ede:	f9843503          	ld	a0,-104(s0)
    80011ee2:	ab4ff0ef          	jal	ra,80011196 <_etoa>
    80011ee6:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011eea:	f8043783          	ld	a5,-128(s0)
    80011eee:	0785                	addi	a5,a5,1
    80011ef0:	f8f43023          	sd	a5,-128(s0)
                break;
    80011ef4:	a631                	j	80012200 <_vsnprintf+0xba8>
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
            case 'c': {
                unsigned int l = 1U;
    80011ef6:	4785                	li	a5,1
    80011ef8:	fcf42823          	sw	a5,-48(s0)
                // pre padding
                if (!(flags & FLAGS_LEFT)) {
    80011efc:	fec42783          	lw	a5,-20(s0)
    80011f00:	8b89                	andi	a5,a5,2
    80011f02:	2781                	sext.w	a5,a5
    80011f04:	ef8d                	bnez	a5,80011f3e <_vsnprintf+0x8e6>
                    while (l++ < width) {
    80011f06:	a00d                	j	80011f28 <_vsnprintf+0x8d0>
                        out(' ', buffer, idx++, maxlen);
    80011f08:	fd843783          	ld	a5,-40(s0)
    80011f0c:	00178713          	addi	a4,a5,1
    80011f10:	fce43c23          	sd	a4,-40(s0)
    80011f14:	f9843703          	ld	a4,-104(s0)
    80011f18:	f8843683          	ld	a3,-120(s0)
    80011f1c:	863e                	mv	a2,a5
    80011f1e:	f9043583          	ld	a1,-112(s0)
    80011f22:	02000513          	li	a0,32
    80011f26:	9702                	jalr	a4
                    while (l++ < width) {
    80011f28:	fd042783          	lw	a5,-48(s0)
    80011f2c:	0017871b          	addiw	a4,a5,1
    80011f30:	fce42823          	sw	a4,-48(s0)
    80011f34:	fe842703          	lw	a4,-24(s0)
    80011f38:	2701                	sext.w	a4,a4
    80011f3a:	fce7e7e3          	bltu	a5,a4,80011f08 <_vsnprintf+0x8b0>
                    }
                }
                // char output
                out((char)va_arg(va, int), buffer, idx++, maxlen);
    80011f3e:	f7843783          	ld	a5,-136(s0)
    80011f42:	00878713          	addi	a4,a5,8
    80011f46:	f6e43c23          	sd	a4,-136(s0)
    80011f4a:	439c                	lw	a5,0(a5)
    80011f4c:	0ff7f513          	andi	a0,a5,255
    80011f50:	fd843783          	ld	a5,-40(s0)
    80011f54:	00178713          	addi	a4,a5,1
    80011f58:	fce43c23          	sd	a4,-40(s0)
    80011f5c:	f9843703          	ld	a4,-104(s0)
    80011f60:	f8843683          	ld	a3,-120(s0)
    80011f64:	863e                	mv	a2,a5
    80011f66:	f9043583          	ld	a1,-112(s0)
    80011f6a:	9702                	jalr	a4
                // post padding
                if (flags & FLAGS_LEFT) {
    80011f6c:	fec42783          	lw	a5,-20(s0)
    80011f70:	8b89                	andi	a5,a5,2
    80011f72:	2781                	sext.w	a5,a5
    80011f74:	cf8d                	beqz	a5,80011fae <_vsnprintf+0x956>
                    while (l++ < width) {
    80011f76:	a00d                	j	80011f98 <_vsnprintf+0x940>
                        out(' ', buffer, idx++, maxlen);
    80011f78:	fd843783          	ld	a5,-40(s0)
    80011f7c:	00178713          	addi	a4,a5,1
    80011f80:	fce43c23          	sd	a4,-40(s0)
    80011f84:	f9843703          	ld	a4,-104(s0)
    80011f88:	f8843683          	ld	a3,-120(s0)
    80011f8c:	863e                	mv	a2,a5
    80011f8e:	f9043583          	ld	a1,-112(s0)
    80011f92:	02000513          	li	a0,32
    80011f96:	9702                	jalr	a4
                    while (l++ < width) {
    80011f98:	fd042783          	lw	a5,-48(s0)
    80011f9c:	0017871b          	addiw	a4,a5,1
    80011fa0:	fce42823          	sw	a4,-48(s0)
    80011fa4:	fe842703          	lw	a4,-24(s0)
    80011fa8:	2701                	sext.w	a4,a4
    80011faa:	fce7e7e3          	bltu	a5,a4,80011f78 <_vsnprintf+0x920>
                    }
                }
                format++;
    80011fae:	f8043783          	ld	a5,-128(s0)
    80011fb2:	0785                	addi	a5,a5,1
    80011fb4:	f8f43023          	sd	a5,-128(s0)
                break;
    80011fb8:	a4a1                	j	80012200 <_vsnprintf+0xba8>
            }

            case 's': {
                const char *p = va_arg(va, char *);
    80011fba:	f7843783          	ld	a5,-136(s0)
    80011fbe:	00878713          	addi	a4,a5,8
    80011fc2:	f6e43c23          	sd	a4,-136(s0)
    80011fc6:	639c                	ld	a5,0(a5)
    80011fc8:	fcf43423          	sd	a5,-56(s0)
                unsigned int l =
                    _strnlen_s(p, precision ? precision : (size_t)-1);
    80011fcc:	fe442783          	lw	a5,-28(s0)
    80011fd0:	2781                	sext.w	a5,a5
    80011fd2:	c781                	beqz	a5,80011fda <_vsnprintf+0x982>
    80011fd4:	fe446783          	lwu	a5,-28(s0)
    80011fd8:	a011                	j	80011fdc <_vsnprintf+0x984>
    80011fda:	57fd                	li	a5,-1
    80011fdc:	85be                	mv	a1,a5
    80011fde:	fc843503          	ld	a0,-56(s0)
    80011fe2:	d92fe0ef          	jal	ra,80010574 <_strnlen_s>
    80011fe6:	87aa                	mv	a5,a0
    80011fe8:	fcf42223          	sw	a5,-60(s0)
                // pre padding
                if (flags & FLAGS_PRECISION) {
    80011fec:	fec42783          	lw	a5,-20(s0)
    80011ff0:	4007f793          	andi	a5,a5,1024
    80011ff4:	2781                	sext.w	a5,a5
    80011ff6:	cf91                	beqz	a5,80012012 <_vsnprintf+0x9ba>
                    l = (l < precision ? l : precision);
    80011ff8:	fc442603          	lw	a2,-60(s0)
    80011ffc:	fe442783          	lw	a5,-28(s0)
    80012000:	0007869b          	sext.w	a3,a5
    80012004:	0006071b          	sext.w	a4,a2
    80012008:	00d77363          	bgeu	a4,a3,8001200e <_vsnprintf+0x9b6>
    8001200c:	87b2                	mv	a5,a2
    8001200e:	fcf42223          	sw	a5,-60(s0)
                }
                if (!(flags & FLAGS_LEFT)) {
    80012012:	fec42783          	lw	a5,-20(s0)
    80012016:	8b89                	andi	a5,a5,2
    80012018:	2781                	sext.w	a5,a5
    8001201a:	e7a5                	bnez	a5,80012082 <_vsnprintf+0xa2a>
                    while (l++ < width) {
    8001201c:	a00d                	j	8001203e <_vsnprintf+0x9e6>
                        out(' ', buffer, idx++, maxlen);
    8001201e:	fd843783          	ld	a5,-40(s0)
    80012022:	00178713          	addi	a4,a5,1
    80012026:	fce43c23          	sd	a4,-40(s0)
    8001202a:	f9843703          	ld	a4,-104(s0)
    8001202e:	f8843683          	ld	a3,-120(s0)
    80012032:	863e                	mv	a2,a5
    80012034:	f9043583          	ld	a1,-112(s0)
    80012038:	02000513          	li	a0,32
    8001203c:	9702                	jalr	a4
                    while (l++ < width) {
    8001203e:	fc442783          	lw	a5,-60(s0)
    80012042:	0017871b          	addiw	a4,a5,1
    80012046:	fce42223          	sw	a4,-60(s0)
    8001204a:	fe842703          	lw	a4,-24(s0)
    8001204e:	2701                	sext.w	a4,a4
    80012050:	fce7e7e3          	bltu	a5,a4,8001201e <_vsnprintf+0x9c6>
                    }
                }
                // string output
                while ((*p != 0) &&
    80012054:	a03d                	j	80012082 <_vsnprintf+0xa2a>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
                    out(*(p++), buffer, idx++, maxlen);
    80012056:	fc843783          	ld	a5,-56(s0)
    8001205a:	00178713          	addi	a4,a5,1
    8001205e:	fce43423          	sd	a4,-56(s0)
    80012062:	0007c503          	lbu	a0,0(a5)
    80012066:	fd843783          	ld	a5,-40(s0)
    8001206a:	00178713          	addi	a4,a5,1
    8001206e:	fce43c23          	sd	a4,-40(s0)
    80012072:	f9843703          	ld	a4,-104(s0)
    80012076:	f8843683          	ld	a3,-120(s0)
    8001207a:	863e                	mv	a2,a5
    8001207c:	f9043583          	ld	a1,-112(s0)
    80012080:	9702                	jalr	a4
                while ((*p != 0) &&
    80012082:	fc843783          	ld	a5,-56(s0)
    80012086:	0007c783          	lbu	a5,0(a5)
    8001208a:	cf91                	beqz	a5,800120a6 <_vsnprintf+0xa4e>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    8001208c:	fec42783          	lw	a5,-20(s0)
    80012090:	4007f793          	andi	a5,a5,1024
    80012094:	2781                	sext.w	a5,a5
                while ((*p != 0) &&
    80012096:	d3e1                	beqz	a5,80012056 <_vsnprintf+0x9fe>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    80012098:	fe442783          	lw	a5,-28(s0)
    8001209c:	fff7871b          	addiw	a4,a5,-1
    800120a0:	fee42223          	sw	a4,-28(s0)
    800120a4:	fbcd                	bnez	a5,80012056 <_vsnprintf+0x9fe>
                }
                // post padding
                if (flags & FLAGS_LEFT) {
    800120a6:	fec42783          	lw	a5,-20(s0)
    800120aa:	8b89                	andi	a5,a5,2
    800120ac:	2781                	sext.w	a5,a5
    800120ae:	cf8d                	beqz	a5,800120e8 <_vsnprintf+0xa90>
                    while (l++ < width) {
    800120b0:	a00d                	j	800120d2 <_vsnprintf+0xa7a>
                        out(' ', buffer, idx++, maxlen);
    800120b2:	fd843783          	ld	a5,-40(s0)
    800120b6:	00178713          	addi	a4,a5,1
    800120ba:	fce43c23          	sd	a4,-40(s0)
    800120be:	f9843703          	ld	a4,-104(s0)
    800120c2:	f8843683          	ld	a3,-120(s0)
    800120c6:	863e                	mv	a2,a5
    800120c8:	f9043583          	ld	a1,-112(s0)
    800120cc:	02000513          	li	a0,32
    800120d0:	9702                	jalr	a4
                    while (l++ < width) {
    800120d2:	fc442783          	lw	a5,-60(s0)
    800120d6:	0017871b          	addiw	a4,a5,1
    800120da:	fce42223          	sw	a4,-60(s0)
    800120de:	fe842703          	lw	a4,-24(s0)
    800120e2:	2701                	sext.w	a4,a4
    800120e4:	fce7e7e3          	bltu	a5,a4,800120b2 <_vsnprintf+0xa5a>
                    }
                }
                format++;
    800120e8:	f8043783          	ld	a5,-128(s0)
    800120ec:	0785                	addi	a5,a5,1
    800120ee:	f8f43023          	sd	a5,-128(s0)
                break;
    800120f2:	a239                	j	80012200 <_vsnprintf+0xba8>
            }

            case 'p': {
                width = sizeof(void *) * 2U;
    800120f4:	47c1                	li	a5,16
    800120f6:	fef42423          	sw	a5,-24(s0)
                flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    800120fa:	fec42783          	lw	a5,-20(s0)
    800120fe:	0217e793          	ori	a5,a5,33
    80012102:	fef42623          	sw	a5,-20(s0)
#if defined(PRINTF_SUPPORT_LONG_LONG)
                const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
    80012106:	4785                	li	a5,1
    80012108:	faf40da3          	sb	a5,-69(s0)
                if (is_ll) {
    8001210c:	fbb44783          	lbu	a5,-69(s0)
    80012110:	0ff7f793          	andi	a5,a5,255
    80012114:	c3b1                	beqz	a5,80012158 <_vsnprintf+0xb00>
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
                                          (uintptr_t)va_arg(va, void *), false,
    80012116:	f7843783          	ld	a5,-136(s0)
    8001211a:	00878713          	addi	a4,a5,8
    8001211e:	f6e43c23          	sd	a4,-136(s0)
    80012122:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80012124:	86be                	mv	a3,a5
    80012126:	fe442703          	lw	a4,-28(s0)
    8001212a:	fec42783          	lw	a5,-20(s0)
    8001212e:	e43e                	sd	a5,8(sp)
    80012130:	fe842783          	lw	a5,-24(s0)
    80012134:	e03e                	sd	a5,0(sp)
    80012136:	88ba                	mv	a7,a4
    80012138:	4841                	li	a6,16
    8001213a:	4781                	li	a5,0
    8001213c:	8736                	mv	a4,a3
    8001213e:	f8843683          	ld	a3,-120(s0)
    80012142:	fd843603          	ld	a2,-40(s0)
    80012146:	f9043583          	ld	a1,-112(s0)
    8001214a:	f9843503          	ld	a0,-104(s0)
    8001214e:	9e5fe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80012152:	fca43c23          	sd	a0,-40(s0)
    80012156:	a089                	j	80012198 <_vsnprintf+0xb40>
                }
                else {
#endif
                    idx = _ntoa_long(
                        out, buffer, idx, maxlen,
                        (unsigned long)((uintptr_t)va_arg(va, void *)), false,
    80012158:	f7843783          	ld	a5,-136(s0)
    8001215c:	00878713          	addi	a4,a5,8
    80012160:	f6e43c23          	sd	a4,-136(s0)
    80012164:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long(
    80012166:	86be                	mv	a3,a5
    80012168:	fe442703          	lw	a4,-28(s0)
    8001216c:	fec42783          	lw	a5,-20(s0)
    80012170:	e43e                	sd	a5,8(sp)
    80012172:	fe842783          	lw	a5,-24(s0)
    80012176:	e03e                	sd	a5,0(sp)
    80012178:	88ba                	mv	a7,a4
    8001217a:	4841                	li	a6,16
    8001217c:	4781                	li	a5,0
    8001217e:	8736                	mv	a4,a3
    80012180:	f8843683          	ld	a3,-120(s0)
    80012184:	fd843603          	ld	a2,-40(s0)
    80012188:	f9043583          	ld	a1,-112(s0)
    8001218c:	f9843503          	ld	a0,-104(s0)
    80012190:	88bfe0ef          	jal	ra,80010a1a <_ntoa_long>
    80012194:	fca43c23          	sd	a0,-40(s0)
                        16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
                }
#endif
                format++;
    80012198:	f8043783          	ld	a5,-128(s0)
    8001219c:	0785                	addi	a5,a5,1
    8001219e:	f8f43023          	sd	a5,-128(s0)
                break;
    800121a2:	a8b9                	j	80012200 <_vsnprintf+0xba8>
            }

            case '%':
                out('%', buffer, idx++, maxlen);
    800121a4:	fd843783          	ld	a5,-40(s0)
    800121a8:	00178713          	addi	a4,a5,1
    800121ac:	fce43c23          	sd	a4,-40(s0)
    800121b0:	f9843703          	ld	a4,-104(s0)
    800121b4:	f8843683          	ld	a3,-120(s0)
    800121b8:	863e                	mv	a2,a5
    800121ba:	f9043583          	ld	a1,-112(s0)
    800121be:	02500513          	li	a0,37
    800121c2:	9702                	jalr	a4
                format++;
    800121c4:	f8043783          	ld	a5,-128(s0)
    800121c8:	0785                	addi	a5,a5,1
    800121ca:	f8f43023          	sd	a5,-128(s0)
                break;
    800121ce:	a80d                	j	80012200 <_vsnprintf+0xba8>

            default:
                out(*format, buffer, idx++, maxlen);
    800121d0:	f8043783          	ld	a5,-128(s0)
    800121d4:	0007c503          	lbu	a0,0(a5)
    800121d8:	fd843783          	ld	a5,-40(s0)
    800121dc:	00178713          	addi	a4,a5,1
    800121e0:	fce43c23          	sd	a4,-40(s0)
    800121e4:	f9843703          	ld	a4,-104(s0)
    800121e8:	f8843683          	ld	a3,-120(s0)
    800121ec:	863e                	mv	a2,a5
    800121ee:	f9043583          	ld	a1,-112(s0)
    800121f2:	9702                	jalr	a4
                format++;
    800121f4:	f8043783          	ld	a5,-128(s0)
    800121f8:	0785                	addi	a5,a5,1
    800121fa:	f8f43023          	sd	a5,-128(s0)
                break;
    800121fe:	0001                	nop
    while (*format) {
    80012200:	f8043783          	ld	a5,-128(s0)
    80012204:	0007c783          	lbu	a5,0(a5)
    80012208:	c8079463          	bnez	a5,80011690 <_vsnprintf+0x38>
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    8001220c:	fd843703          	ld	a4,-40(s0)
    80012210:	f8843783          	ld	a5,-120(s0)
    80012214:	00f76663          	bltu	a4,a5,80012220 <_vsnprintf+0xbc8>
    80012218:	f8843783          	ld	a5,-120(s0)
    8001221c:	17fd                	addi	a5,a5,-1
    8001221e:	a019                	j	80012224 <_vsnprintf+0xbcc>
    80012220:	fd843783          	ld	a5,-40(s0)
    80012224:	f9843703          	ld	a4,-104(s0)
    80012228:	f8843683          	ld	a3,-120(s0)
    8001222c:	863e                	mv	a2,a5
    8001222e:	f9043583          	ld	a1,-112(s0)
    80012232:	4501                	li	a0,0
    80012234:	9702                	jalr	a4

    // return written chars without terminating \0
    return (int)idx;
    80012236:	fd843783          	ld	a5,-40(s0)
    8001223a:	2781                	sext.w	a5,a5
}
    8001223c:	853e                	mv	a0,a5
    8001223e:	60ea                	ld	ra,152(sp)
    80012240:	644a                	ld	s0,144(sp)
    80012242:	610d                	addi	sp,sp,160
    80012244:	8082                	ret

0000000080012246 <printf>:

///////////////////////////////////////////////////////////////////////////////

int printf(const char *format, ...)
{
    80012246:	7119                	addi	sp,sp,-128
    80012248:	fc06                	sd	ra,56(sp)
    8001224a:	f822                	sd	s0,48(sp)
    8001224c:	0080                	addi	s0,sp,64
    8001224e:	fca43423          	sd	a0,-56(s0)
    80012252:	e40c                	sd	a1,8(s0)
    80012254:	e810                	sd	a2,16(s0)
    80012256:	ec14                	sd	a3,24(s0)
    80012258:	f018                	sd	a4,32(s0)
    8001225a:	f41c                	sd	a5,40(s0)
    8001225c:	03043823          	sd	a6,48(s0)
    80012260:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, format);
    80012264:	04040793          	addi	a5,s0,64
    80012268:	fcf43023          	sd	a5,-64(s0)
    8001226c:	fc043783          	ld	a5,-64(s0)
    80012270:	fc878793          	addi	a5,a5,-56
    80012274:	fef43023          	sd	a5,-32(s0)
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80012278:	fe043703          	ld	a4,-32(s0)
    8001227c:	fd840793          	addi	a5,s0,-40
    80012280:	fc843683          	ld	a3,-56(s0)
    80012284:	567d                	li	a2,-1
    80012286:	85be                	mv	a1,a5
    80012288:	ffffe517          	auipc	a0,0xffffe
    8001228c:	27050513          	addi	a0,a0,624 # 800104f8 <_out_char>
    80012290:	bc8ff0ef          	jal	ra,80011658 <_vsnprintf>
    80012294:	87aa                	mv	a5,a0
    80012296:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    8001229a:	fec42783          	lw	a5,-20(s0)
}
    8001229e:	853e                	mv	a0,a5
    800122a0:	70e2                	ld	ra,56(sp)
    800122a2:	7442                	ld	s0,48(sp)
    800122a4:	6109                	addi	sp,sp,128
    800122a6:	8082                	ret

00000000800122a8 <sprintf>:

int sprintf(char *buffer, const char *format, ...)
{
    800122a8:	7159                	addi	sp,sp,-112
    800122aa:	fc06                	sd	ra,56(sp)
    800122ac:	f822                	sd	s0,48(sp)
    800122ae:	0080                	addi	s0,sp,64
    800122b0:	fca43c23          	sd	a0,-40(s0)
    800122b4:	fcb43823          	sd	a1,-48(s0)
    800122b8:	e010                	sd	a2,0(s0)
    800122ba:	e414                	sd	a3,8(s0)
    800122bc:	e818                	sd	a4,16(s0)
    800122be:	ec1c                	sd	a5,24(s0)
    800122c0:	03043023          	sd	a6,32(s0)
    800122c4:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    800122c8:	03040793          	addi	a5,s0,48
    800122cc:	fcf43423          	sd	a5,-56(s0)
    800122d0:	fc843783          	ld	a5,-56(s0)
    800122d4:	fd078793          	addi	a5,a5,-48
    800122d8:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
    800122dc:	fe043783          	ld	a5,-32(s0)
    800122e0:	873e                	mv	a4,a5
    800122e2:	fd043683          	ld	a3,-48(s0)
    800122e6:	567d                	li	a2,-1
    800122e8:	fd843583          	ld	a1,-40(s0)
    800122ec:	ffffe517          	auipc	a0,0xffffe
    800122f0:	1ae50513          	addi	a0,a0,430 # 8001049a <_out_buffer>
    800122f4:	b64ff0ef          	jal	ra,80011658 <_vsnprintf>
    800122f8:	87aa                	mv	a5,a0
    800122fa:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    800122fe:	fec42783          	lw	a5,-20(s0)
}
    80012302:	853e                	mv	a0,a5
    80012304:	70e2                	ld	ra,56(sp)
    80012306:	7442                	ld	s0,48(sp)
    80012308:	6165                	addi	sp,sp,112
    8001230a:	8082                	ret

000000008001230c <snprintf>:

int snprintf(char *buffer, size_t count, const char *format, ...)
{
    8001230c:	7159                	addi	sp,sp,-112
    8001230e:	fc06                	sd	ra,56(sp)
    80012310:	f822                	sd	s0,48(sp)
    80012312:	0080                	addi	s0,sp,64
    80012314:	fca43c23          	sd	a0,-40(s0)
    80012318:	fcb43823          	sd	a1,-48(s0)
    8001231c:	fcc43423          	sd	a2,-56(s0)
    80012320:	e414                	sd	a3,8(s0)
    80012322:	e818                	sd	a4,16(s0)
    80012324:	ec1c                	sd	a5,24(s0)
    80012326:	03043023          	sd	a6,32(s0)
    8001232a:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    8001232e:	03040793          	addi	a5,s0,48
    80012332:	fcf43023          	sd	a5,-64(s0)
    80012336:	fc043783          	ld	a5,-64(s0)
    8001233a:	fd878793          	addi	a5,a5,-40
    8001233e:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    80012342:	fe043783          	ld	a5,-32(s0)
    80012346:	873e                	mv	a4,a5
    80012348:	fc843683          	ld	a3,-56(s0)
    8001234c:	fd043603          	ld	a2,-48(s0)
    80012350:	fd843583          	ld	a1,-40(s0)
    80012354:	ffffe517          	auipc	a0,0xffffe
    80012358:	14650513          	addi	a0,a0,326 # 8001049a <_out_buffer>
    8001235c:	afcff0ef          	jal	ra,80011658 <_vsnprintf>
    80012360:	87aa                	mv	a5,a0
    80012362:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80012366:	fec42783          	lw	a5,-20(s0)
}
    8001236a:	853e                	mv	a0,a5
    8001236c:	70e2                	ld	ra,56(sp)
    8001236e:	7442                	ld	s0,48(sp)
    80012370:	6165                	addi	sp,sp,112
    80012372:	8082                	ret

0000000080012374 <vprintf_>:

int vprintf_(const char *format, va_list va)
{
    80012374:	7179                	addi	sp,sp,-48
    80012376:	f406                	sd	ra,40(sp)
    80012378:	f022                	sd	s0,32(sp)
    8001237a:	1800                	addi	s0,sp,48
    8001237c:	fca43c23          	sd	a0,-40(s0)
    80012380:	fcb43823          	sd	a1,-48(s0)
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80012384:	fe840793          	addi	a5,s0,-24
    80012388:	fd043703          	ld	a4,-48(s0)
    8001238c:	fd843683          	ld	a3,-40(s0)
    80012390:	567d                	li	a2,-1
    80012392:	85be                	mv	a1,a5
    80012394:	ffffe517          	auipc	a0,0xffffe
    80012398:	16450513          	addi	a0,a0,356 # 800104f8 <_out_char>
    8001239c:	abcff0ef          	jal	ra,80011658 <_vsnprintf>
    800123a0:	87aa                	mv	a5,a0
}
    800123a2:	853e                	mv	a0,a5
    800123a4:	70a2                	ld	ra,40(sp)
    800123a6:	7402                	ld	s0,32(sp)
    800123a8:	6145                	addi	sp,sp,48
    800123aa:	8082                	ret

00000000800123ac <vsnprintf_>:

int vsnprintf_(char *buffer, size_t count, const char *format, va_list va)
{
    800123ac:	7179                	addi	sp,sp,-48
    800123ae:	f406                	sd	ra,40(sp)
    800123b0:	f022                	sd	s0,32(sp)
    800123b2:	1800                	addi	s0,sp,48
    800123b4:	fea43423          	sd	a0,-24(s0)
    800123b8:	feb43023          	sd	a1,-32(s0)
    800123bc:	fcc43c23          	sd	a2,-40(s0)
    800123c0:	fcd43823          	sd	a3,-48(s0)
    return _vsnprintf(_out_buffer, buffer, count, format, va);
    800123c4:	fd043703          	ld	a4,-48(s0)
    800123c8:	fd843683          	ld	a3,-40(s0)
    800123cc:	fe043603          	ld	a2,-32(s0)
    800123d0:	fe843583          	ld	a1,-24(s0)
    800123d4:	ffffe517          	auipc	a0,0xffffe
    800123d8:	0c650513          	addi	a0,a0,198 # 8001049a <_out_buffer>
    800123dc:	a7cff0ef          	jal	ra,80011658 <_vsnprintf>
    800123e0:	87aa                	mv	a5,a0
}
    800123e2:	853e                	mv	a0,a5
    800123e4:	70a2                	ld	ra,40(sp)
    800123e6:	7402                	ld	s0,32(sp)
    800123e8:	6145                	addi	sp,sp,48
    800123ea:	8082                	ret

00000000800123ec <fctprintf>:

int fctprintf(void (*out)(char character, void *arg), void *arg,
              const char *format, ...)
{
    800123ec:	7119                	addi	sp,sp,-128
    800123ee:	e486                	sd	ra,72(sp)
    800123f0:	e0a2                	sd	s0,64(sp)
    800123f2:	0880                	addi	s0,sp,80
    800123f4:	fca43423          	sd	a0,-56(s0)
    800123f8:	fcb43023          	sd	a1,-64(s0)
    800123fc:	fac43c23          	sd	a2,-72(s0)
    80012400:	e414                	sd	a3,8(s0)
    80012402:	e818                	sd	a4,16(s0)
    80012404:	ec1c                	sd	a5,24(s0)
    80012406:	03043023          	sd	a6,32(s0)
    8001240a:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    8001240e:	03040793          	addi	a5,s0,48
    80012412:	faf43823          	sd	a5,-80(s0)
    80012416:	fb043783          	ld	a5,-80(s0)
    8001241a:	fd878793          	addi	a5,a5,-40
    8001241e:	fef43023          	sd	a5,-32(s0)
    const out_fct_wrap_type out_fct_wrap = {out, arg};
    80012422:	fc843783          	ld	a5,-56(s0)
    80012426:	fcf43823          	sd	a5,-48(s0)
    8001242a:	fc043783          	ld	a5,-64(s0)
    8001242e:	fcf43c23          	sd	a5,-40(s0)
    const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap,
    80012432:	fe043703          	ld	a4,-32(s0)
    80012436:	fd040793          	addi	a5,s0,-48
    8001243a:	fb843683          	ld	a3,-72(s0)
    8001243e:	567d                	li	a2,-1
    80012440:	85be                	mv	a1,a5
    80012442:	ffffe517          	auipc	a0,0xffffe
    80012446:	0ee50513          	addi	a0,a0,238 # 80010530 <_out_fct>
    8001244a:	a0eff0ef          	jal	ra,80011658 <_vsnprintf>
    8001244e:	87aa                	mv	a5,a0
    80012450:	fef42623          	sw	a5,-20(s0)
                               (size_t)-1, format, va);
    va_end(va);
    return ret;
    80012454:	fec42783          	lw	a5,-20(s0)
}
    80012458:	853e                	mv	a0,a5
    8001245a:	60a6                	ld	ra,72(sp)
    8001245c:	6406                	ld	s0,64(sp)
    8001245e:	6109                	addi	sp,sp,128
    80012460:	8082                	ret

0000000080012462 <os_trap_handler>:
// From src/syscall.c
void syscall_handle(int hart, uint64_t epc, int64_t *scratch);

// Called from asm/spawn.S: _spawn_kthread
void os_trap_handler(void)
{
    80012462:	7139                	addi	sp,sp,-64
    80012464:	fc06                	sd	ra,56(sp)
    80012466:	f822                	sd	s0,48(sp)
    80012468:	0080                	addi	s0,sp,64
    unsigned long cause;
    long *scratch;
    unsigned long epc;
    unsigned long tval;
    unsigned long sie;
    CSR_READ(cause, "scause");
    8001246a:	142027f3          	csrr	a5,scause
    8001246e:	fef43423          	sd	a5,-24(s0)
    CSR_READ(scratch, "sscratch");
    80012472:	140027f3          	csrr	a5,sscratch
    80012476:	fef43023          	sd	a5,-32(s0)
    CSR_READ(epc, "sepc");
    8001247a:	141027f3          	csrr	a5,sepc
    8001247e:	fcf43c23          	sd	a5,-40(s0)
    CSR_READ(tval, "stval");
    80012482:	143027f3          	csrr	a5,stval
    80012486:	fcf43823          	sd	a5,-48(s0)
    CSR_READ(sie, "sie");
    8001248a:	104027f3          	csrr	a5,sie
    8001248e:	fcf43423          	sd	a5,-56(s0)
    // debugf("SPP: %lx\n", status & SSTATUS_SPP_BIT);

    // debugf("Scause: %lx\n", cause);
    // debugf("Sscratch: %lx\n", scratch);

    int hart = sbi_whoami();
    80012492:	124070ef          	jal	ra,800195b6 <sbi_whoami>
    80012496:	87aa                	mv	a5,a0
    80012498:	fcf42223          	sw	a5,-60(s0)
    //                 "csrs sie, t1\n");


    debugf("Is async: %d\n", SCAUSE_IS_ASYNC(cause));

    if (SCAUSE_IS_ASYNC(cause)) {
    8001249c:	fe843783          	ld	a5,-24(s0)
    800124a0:	0407d963          	bgez	a5,800124f2 <os_trap_handler+0x90>
        debugf("Is async!\n");
        cause = SCAUSE_NUM(cause);
    800124a4:	fe843783          	ld	a5,-24(s0)
    800124a8:	0ff7f793          	andi	a5,a5,255
    800124ac:	fef43423          	sd	a5,-24(s0)
        switch (cause) {
    800124b0:	fe843703          	ld	a4,-24(s0)
    800124b4:	4795                	li	a5,5
    800124b6:	00f70863          	beq	a4,a5,800124c6 <os_trap_handler+0x64>
    800124ba:	fe843703          	ld	a4,-24(s0)
    800124be:	47a5                	li	a5,9
    800124c0:	00f70863          	beq	a4,a5,800124d0 <os_trap_handler+0x6e>
    800124c4:	a821                	j	800124dc <os_trap_handler+0x7a>
            case CAUSE_STIP:
                // Ack timer will reset the timer to INFINITE
                // In src/sbi.c
                debugf("HANDLING TIMER!!!!!!!!!!!!!!!\n");
                CSR_CLEAR("sip");
    800124c6:	14401073          	csrw	sip,zero
                sbi_ack_timer();
    800124ca:	0b6070ef          	jal	ra,80019580 <sbi_ack_timer>
                // We typically invoke our scheduler if we get a timer
                // sched_invoke(hart);
                break;
    800124ce:	a211                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_SEIP:
                // Forward to src/plic.c
                debugf("Entering plic handle\n");
                plic_handle_irq(hart);
    800124d0:	fc442783          	lw	a5,-60(s0)
    800124d4:	853e                	mv	a0,a5
    800124d6:	394070ef          	jal	ra,8001986a <plic_handle_irq>
                debugf("Left plic handle\n");
                
                // fatalf("Could not return from trap\n");
                break;
    800124da:	a8e5                	j	800125d2 <os_trap_handler+0x170>
            default:
                fatalf("Unhandled Asynchronous interrupt %ld\n", cause);
    800124dc:	fe843583          	ld	a1,-24(s0)
    800124e0:	0000f517          	auipc	a0,0xf
    800124e4:	e3850513          	addi	a0,a0,-456 # 80021318 <pow10.0+0xe8>
    800124e8:	677060ef          	jal	ra,8001935e <fatalf>
                WFI_LOOP();
    800124ec:	10500073          	wfi
    800124f0:	bff5                	j	800124ec <os_trap_handler+0x8a>
    800124f2:	fe843703          	ld	a4,-24(s0)
    800124f6:	47b5                	li	a5,13
    800124f8:	0ae7eb63          	bltu	a5,a4,800125ae <os_trap_handler+0x14c>
    800124fc:	fe843783          	ld	a5,-24(s0)
    80012500:	00279713          	slli	a4,a5,0x2
    80012504:	0000f797          	auipc	a5,0xf
    80012508:	f4078793          	addi	a5,a5,-192 # 80021444 <pow10.0+0x214>
    8001250c:	97ba                	add	a5,a5,a4
    8001250e:	439c                	lw	a5,0(a5)
    80012510:	0007871b          	sext.w	a4,a5
    80012514:	0000f797          	auipc	a5,0xf
    80012518:	f3078793          	addi	a5,a5,-208 # 80021444 <pow10.0+0x214>
    8001251c:	97ba                	add	a5,a5,a4
    8001251e:	8782                	jr	a5
    }
    else {
        debugf("Is sync!\n");
        switch (cause) {
            case CAUSE_ILLEGAL_INSTRUCTION:
                fatalf("Illegal instruction \"%x\" at %p\n", *((uint64_t*)epc), epc);
    80012520:	fd843783          	ld	a5,-40(s0)
    80012524:	639c                	ld	a5,0(a5)
    80012526:	fd843603          	ld	a2,-40(s0)
    8001252a:	85be                	mv	a1,a5
    8001252c:	0000f517          	auipc	a0,0xf
    80012530:	e1450513          	addi	a0,a0,-492 # 80021340 <pow10.0+0x110>
    80012534:	62b060ef          	jal	ra,8001935e <fatalf>
                CSR_WRITE("sepc", epc + 4);
    80012538:	fd843783          	ld	a5,-40(s0)
    8001253c:	0791                	addi	a5,a5,4
    8001253e:	14179073          	csrw	sepc,a5
                break;
    80012542:	a841                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_INSTRUCTION_ACCESS_FAULT:
                fatalf("Couldn't access instruction=%p at instruction %p\n", tval, epc);
    80012544:	fd843603          	ld	a2,-40(s0)
    80012548:	fd043583          	ld	a1,-48(s0)
    8001254c:	0000f517          	auipc	a0,0xf
    80012550:	e1450513          	addi	a0,a0,-492 # 80021360 <pow10.0+0x130>
    80012554:	60b060ef          	jal	ra,8001935e <fatalf>
                break;
    80012558:	a8ad                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_INSTRUCTION_PAGE_FAULT:
                fatalf("Instruction page fault at instruction %p accessing address %p\n", epc, tval);
    8001255a:	fd043603          	ld	a2,-48(s0)
    8001255e:	fd843583          	ld	a1,-40(s0)
    80012562:	0000f517          	auipc	a0,0xf
    80012566:	e3650513          	addi	a0,a0,-458 # 80021398 <pow10.0+0x168>
    8001256a:	5f5060ef          	jal	ra,8001935e <fatalf>
                break;
    8001256e:	a095                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_LOAD_PAGE_FAULT:
                fatalf("Load page fault at %p = %p", epc, tval);
    80012570:	fd043603          	ld	a2,-48(s0)
    80012574:	fd843583          	ld	a1,-40(s0)
    80012578:	0000f517          	auipc	a0,0xf
    8001257c:	e6050513          	addi	a0,a0,-416 # 800213d8 <pow10.0+0x1a8>
    80012580:	5df060ef          	jal	ra,8001935e <fatalf>
                break;
    80012584:	a0b9                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_ECALL_U_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                debugf("Handling syscall\n");
                syscall_handle(hart, epc, scratch);
    80012586:	fc442783          	lw	a5,-60(s0)
    8001258a:	fe043603          	ld	a2,-32(s0)
    8001258e:	fd843583          	ld	a1,-40(s0)
    80012592:	853e                	mv	a0,a5
    80012594:	e59fd0ef          	jal	ra,800103ec <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    80012598:	a82d                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_ECALL_S_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                debugf("Handling syscall\n");
                syscall_handle(hart, epc, scratch);
    8001259a:	fc442783          	lw	a5,-60(s0)
    8001259e:	fe043603          	ld	a2,-32(s0)
    800125a2:	fd843583          	ld	a1,-40(s0)
    800125a6:	853e                	mv	a0,a5
    800125a8:	e45fd0ef          	jal	ra,800103ec <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    800125ac:	a01d                	j	800125d2 <os_trap_handler+0x170>
            default:
                fatalf(
    800125ae:	fc442783          	lw	a5,-60(s0)
    800125b2:	873e                	mv	a4,a5
    800125b4:	fd043683          	ld	a3,-48(s0)
    800125b8:	fd843603          	ld	a2,-40(s0)
    800125bc:	fe843583          	ld	a1,-24(s0)
    800125c0:	0000f517          	auipc	a0,0xf
    800125c4:	e3850513          	addi	a0,a0,-456 # 800213f8 <pow10.0+0x1c8>
    800125c8:	597060ef          	jal	ra,8001935e <fatalf>
                    "Unhandled Synchronous interrupt %ld @ 0x%08lx [0x%08lx]. "
                    "Hanging hart %d\n",
                    cause, epc, tval, hart);
                WFI_LOOP();
    800125cc:	10500073          	wfi
    800125d0:	bff5                	j	800125cc <os_trap_handler+0x16a>
    // __asm__ volatile ("savegp");

    // SRET();
    debugf("Leaving OS trap handler\n");
    // fatalf("Could not return from trap\n");
    800125d2:	0001                	nop
    800125d4:	70e2                	ld	ra,56(sp)
    800125d6:	7442                	ld	s0,48(sp)
    800125d8:	6121                	addi	sp,sp,64
    800125da:	8082                	ret

00000000800125dc <rng_device_init>:

//use this like a queue
static Vector *rng_active_jobs;
static VirtioDevice *rng_device;

void rng_device_init() {
    800125dc:	1141                	addi	sp,sp,-16
    800125de:	e406                	sd	ra,8(sp)
    800125e0:	e022                	sd	s0,0(sp)
    800125e2:	0800                	addi	s0,sp,16
    rng_active_jobs = vector_new();
    800125e4:	7980b0ef          	jal	ra,8001dd7c <vector_new>
    800125e8:	872a                	mv	a4,a0
    800125ea:	0000e797          	auipc	a5,0xe
    800125ee:	a3e78793          	addi	a5,a5,-1474 # 80020028 <rng_active_jobs>
    800125f2:	e398                	sd	a4,0(a5)
    rng_device = virtio_get_rng_device();
    800125f4:	2b5070ef          	jal	ra,8001a0a8 <virtio_get_rng_device>
    800125f8:	872a                	mv	a4,a0
    800125fa:	0000e797          	auipc	a5,0xe
    800125fe:	a3678793          	addi	a5,a5,-1482 # 80020030 <rng_device>
    80012602:	e398                	sd	a4,0(a5)
    debugf("RNG init done for device at %p\n", rng_device->pcidev->ecam_header);
    80012604:	0000e797          	auipc	a5,0xe
    80012608:	a2c78793          	addi	a5,a5,-1492 # 80020030 <rng_device>
    8001260c:	639c                	ld	a5,0(a5)
    8001260e:	63bc                	ld	a5,64(a5)
    80012610:	639c                	ld	a5,0(a5)
    80012612:	85be                	mv	a1,a5
    80012614:	0000f517          	auipc	a0,0xf
    80012618:	e6c50513          	addi	a0,a0,-404 # 80021480 <pow10.0+0x250>
    8001261c:	3e9060ef          	jal	ra,80019204 <debugf>
    virtio_set_device_name(rng_device, "RNG Device");
    80012620:	0000e797          	auipc	a5,0xe
    80012624:	a1078793          	addi	a5,a5,-1520 # 80020030 <rng_device>
    80012628:	639c                	ld	a5,0(a5)
    8001262a:	0000f597          	auipc	a1,0xf
    8001262e:	e7658593          	addi	a1,a1,-394 # 800214a0 <pow10.0+0x270>
    80012632:	853e                	mv	a0,a5
    80012634:	7ed070ef          	jal	ra,8001a620 <virtio_set_device_name>
    rng_device->ready = true;
    80012638:	0000e797          	auipc	a5,0xe
    8001263c:	9f878793          	addi	a5,a5,-1544 # 80020030 <rng_device>
    80012640:	639c                	ld	a5,0(a5)
    80012642:	4705                	li	a4,1
    80012644:	08e78723          	sb	a4,142(a5)
}
    80012648:	0001                	nop
    8001264a:	60a2                	ld	ra,8(sp)
    8001264c:	6402                	ld	s0,0(sp)
    8001264e:	0141                	addi	sp,sp,16
    80012650:	8082                	ret

0000000080012652 <rng_fill>:


void rng_fill(void *virtual_buffer_address, uint16_t size) {
    80012652:	7179                	addi	sp,sp,-48
    80012654:	f406                	sd	ra,40(sp)
    80012656:	f022                	sd	s0,32(sp)
    80012658:	1800                	addi	s0,sp,48
    8001265a:	fca43c23          	sd	a0,-40(s0)
    8001265e:	87ae                	mv	a5,a1
    80012660:	fcf41b23          	sh	a5,-42(s0)
    if (!virtio_is_rng_device(rng_device)) {
    80012664:	0000e797          	auipc	a5,0xe
    80012668:	9cc78793          	addi	a5,a5,-1588 # 80020030 <rng_device>
    8001266c:	639c                	ld	a5,0(a5)
    8001266e:	853e                	mv	a0,a5
    80012670:	0bf070ef          	jal	ra,80019f2e <virtio_is_rng_device>
    80012674:	87aa                	mv	a5,a0
    80012676:	0017c793          	xori	a5,a5,1
    8001267a:	0ff7f793          	andi	a5,a5,255
    8001267e:	c799                	beqz	a5,8001268c <rng_fill+0x3a>
        fatalf("[RNG] Incorrect device provided\n");
    80012680:	0000f517          	auipc	a0,0xf
    80012684:	e3050513          	addi	a0,a0,-464 # 800214b0 <pow10.0+0x280>
    80012688:	4d7060ef          	jal	ra,8001935e <fatalf>
    }

    if (!rng_device->ready) {
    8001268c:	0000e797          	auipc	a5,0xe
    80012690:	9a478793          	addi	a5,a5,-1628 # 80020030 <rng_device>
    80012694:	639c                	ld	a5,0(a5)
    80012696:	08e7c783          	lbu	a5,142(a5)
    8001269a:	0017c793          	xori	a5,a5,1
    8001269e:	0ff7f793          	andi	a5,a5,255
    800126a2:	cb81                	beqz	a5,800126b2 <rng_fill+0x60>
        fatalf("RNG is not ready\n");
    800126a4:	0000f517          	auipc	a0,0xf
    800126a8:	e3450513          	addi	a0,a0,-460 # 800214d8 <pow10.0+0x2a8>
    800126ac:	4b3060ef          	jal	ra,8001935e <fatalf>
    800126b0:	a089                	j	800126f2 <rng_fill+0xa0>
        return;
    }

    VirtioDescriptor desc;
    desc.addr = kernel_mmu_translate((uintptr_t)virtual_buffer_address);
    800126b2:	fd843783          	ld	a5,-40(s0)
    800126b6:	853e                	mv	a0,a5
    800126b8:	331010ef          	jal	ra,800141e8 <kernel_mmu_translate>
    800126bc:	87aa                	mv	a5,a0
    800126be:	fef43023          	sd	a5,-32(s0)
    desc.len = size;
    800126c2:	fd645783          	lhu	a5,-42(s0)
    800126c6:	2781                	sext.w	a5,a5
    800126c8:	fef42423          	sw	a5,-24(s0)
    desc.flags = VIRTQ_DESC_F_WRITE;
    800126cc:	4789                	li	a5,2
    800126ce:	fef41623          	sh	a5,-20(s0)
    desc.next = 0;
    800126d2:	fe041723          	sh	zero,-18(s0)

    virtio_send_one_descriptor(rng_device, 0, desc, true);
    800126d6:	0000e797          	auipc	a5,0xe
    800126da:	95a78793          	addi	a5,a5,-1702 # 80020030 <rng_device>
    800126de:	639c                	ld	a5,0(a5)
    800126e0:	4705                	li	a4,1
    800126e2:	fe043603          	ld	a2,-32(s0)
    800126e6:	fe843683          	ld	a3,-24(s0)
    800126ea:	4581                	li	a1,0
    800126ec:	853e                	mv	a0,a5
    800126ee:	116080ef          	jal	ra,8001a804 <virtio_send_one_descriptor>
}
    800126f2:	70a2                	ld	ra,40(sp)
    800126f4:	7402                	ld	s0,32(sp)
    800126f6:	6145                	addi	sp,sp,48
    800126f8:	8082                	ret

00000000800126fa <pci_device_exists>:
// `irq_pci_devices` vector contains devices that share an IRQ number (32, 33, 34, and 35).
// These vectors contain the pointers to the devices in the ECAM address space.
static struct Vector *all_pci_devices, *irq_pci_devices[4];

static inline bool pci_device_exists(uint16_t vendor_id)
{
    800126fa:	1101                	addi	sp,sp,-32
    800126fc:	ec22                	sd	s0,24(sp)
    800126fe:	1000                	addi	s0,sp,32
    80012700:	87aa                	mv	a5,a0
    80012702:	fef41723          	sh	a5,-18(s0)
    return !((vendor_id == 0x0000) || (vendor_id == 0xFFFF));
    80012706:	fee45783          	lhu	a5,-18(s0)
    8001270a:	2781                	sext.w	a5,a5
    8001270c:	cb99                	beqz	a5,80012722 <pci_device_exists+0x28>
    8001270e:	fee45783          	lhu	a5,-18(s0)
    80012712:	0007871b          	sext.w	a4,a5
    80012716:	67c1                	lui	a5,0x10
    80012718:	17fd                	addi	a5,a5,-1
    8001271a:	00f70463          	beq	a4,a5,80012722 <pci_device_exists+0x28>
    8001271e:	4785                	li	a5,1
    80012720:	a011                	j	80012724 <pci_device_exists+0x2a>
    80012722:	4781                	li	a5,0
    80012724:	8b85                	andi	a5,a5,1
    80012726:	0ff7f793          	andi	a5,a5,255
}
    8001272a:	853e                	mv	a0,a5
    8001272c:	6462                	ld	s0,24(sp)
    8001272e:	6105                	addi	sp,sp,32
    80012730:	8082                	ret

0000000080012732 <pci_is_virtio_device>:

// Is this a virtio device?
bool pci_is_virtio_device(PCIDevice *dev) {
    80012732:	1101                	addi	sp,sp,-32
    80012734:	ec22                	sd	s0,24(sp)
    80012736:	1000                	addi	s0,sp,32
    80012738:	fea43423          	sd	a0,-24(s0)
    return dev->ecam_header->vendor_id == 0x1AF4;
    8001273c:	fe843783          	ld	a5,-24(s0)
    80012740:	639c                	ld	a5,0(a5)
    80012742:	0007d783          	lhu	a5,0(a5) # 10000 <i+0xffe0>
    80012746:	17c2                	slli	a5,a5,0x30
    80012748:	93c1                	srli	a5,a5,0x30
    8001274a:	0007871b          	sext.w	a4,a5
    8001274e:	6789                	lui	a5,0x2
    80012750:	af478793          	addi	a5,a5,-1292 # 1af4 <i+0x1ad4>
    80012754:	40f707b3          	sub	a5,a4,a5
    80012758:	0017b793          	seqz	a5,a5
    8001275c:	0ff7f793          	andi	a5,a5,255
}
    80012760:	853e                	mv	a0,a5
    80012762:	6462                	ld	s0,24(sp)
    80012764:	6105                	addi	sp,sp,32
    80012766:	8082                	ret

0000000080012768 <pci_find_saved_device>:

// Find the saved PCI device with the given vendor and device ID.
// This will retrieve the bookkeeping structure for the PCI device
// maintained by the OS.
PCIDevice *pci_find_saved_device(uint16_t vendor_id, uint16_t device_id) {
    80012768:	7179                	addi	sp,sp,-48
    8001276a:	f406                	sd	ra,40(sp)
    8001276c:	f022                	sd	s0,32(sp)
    8001276e:	1800                	addi	s0,sp,48
    80012770:	87aa                	mv	a5,a0
    80012772:	872e                	mv	a4,a1
    80012774:	fcf41f23          	sh	a5,-34(s0)
    80012778:	87ba                	mv	a5,a4
    8001277a:	fcf41e23          	sh	a5,-36(s0)
    // debugf("Searching for device with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    // Iterate through the devices
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    8001277e:	fe042623          	sw	zero,-20(s0)
    80012782:	a8a1                	j	800127da <pci_find_saved_device+0x72>
        // Check if the device has the given vendor and device ID
        PCIDevice *pcidev = pci_get_nth_saved_device(i);
    80012784:	fec42783          	lw	a5,-20(s0)
    80012788:	17c2                	slli	a5,a5,0x30
    8001278a:	93c1                	srli	a5,a5,0x30
    8001278c:	853e                	mv	a0,a5
    8001278e:	32e000ef          	jal	ra,80012abc <pci_get_nth_saved_device>
    80012792:	fea43023          	sd	a0,-32(s0)
        // debugf("Checking device with vendor ID: 0x%04x, device ID: 0x%04x\n", pcidev->ecam_header->vendor_id, pcidev->ecam_header->device_id);
        if (pcidev->ecam_header->vendor_id == vendor_id && pcidev->ecam_header->device_id == device_id) {
    80012796:	fe043783          	ld	a5,-32(s0)
    8001279a:	639c                	ld	a5,0(a5)
    8001279c:	0007d783          	lhu	a5,0(a5)
    800127a0:	17c2                	slli	a5,a5,0x30
    800127a2:	93c1                	srli	a5,a5,0x30
    800127a4:	fde45703          	lhu	a4,-34(s0)
    800127a8:	2701                	sext.w	a4,a4
    800127aa:	2781                	sext.w	a5,a5
    800127ac:	02f71263          	bne	a4,a5,800127d0 <pci_find_saved_device+0x68>
    800127b0:	fe043783          	ld	a5,-32(s0)
    800127b4:	639c                	ld	a5,0(a5)
    800127b6:	0027d783          	lhu	a5,2(a5)
    800127ba:	17c2                	slli	a5,a5,0x30
    800127bc:	93c1                	srli	a5,a5,0x30
    800127be:	fdc45703          	lhu	a4,-36(s0)
    800127c2:	2701                	sext.w	a4,a4
    800127c4:	2781                	sext.w	a5,a5
    800127c6:	00f71563          	bne	a4,a5,800127d0 <pci_find_saved_device+0x68>
            return pcidev;
    800127ca:	fe043783          	ld	a5,-32(s0)
    800127ce:	a03d                	j	800127fc <pci_find_saved_device+0x94>
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    800127d0:	fec42783          	lw	a5,-20(s0)
    800127d4:	2785                	addiw	a5,a5,1
    800127d6:	fef42623          	sw	a5,-20(s0)
    800127da:	0000e797          	auipc	a5,0xe
    800127de:	85e78793          	addi	a5,a5,-1954 # 80020038 <all_pci_devices>
    800127e2:	639c                	ld	a5,0(a5)
    800127e4:	853e                	mv	a0,a5
    800127e6:	6f70b0ef          	jal	ra,8001e6dc <vector_size>
    800127ea:	87aa                	mv	a5,a0
    800127ec:	0007871b          	sext.w	a4,a5
    800127f0:	fec42783          	lw	a5,-20(s0)
    800127f4:	2781                	sext.w	a5,a5
    800127f6:	f8e7e7e3          	bltu	a5,a4,80012784 <pci_find_saved_device+0x1c>
        }
    }
    // If we get here, we didn't find the device
    // debugf("No device found with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    return NULL;
    800127fa:	4781                	li	a5,0
}
    800127fc:	853e                	mv	a0,a5
    800127fe:	70a2                	ld	ra,40(sp)
    80012800:	7402                	ld	s0,32(sp)
    80012802:	6145                	addi	sp,sp,48
    80012804:	8082                	ret

0000000080012806 <pci_get_capability>:

// Get the nth PCI capability for the PCI device. This is used with `0x9` as the type
// to enumerate all of the several Virtio capabilities for a PCI device with the Virtio
// vendor ID.
volatile struct pci_cape *pci_get_capability(PCIDevice *device, uint8_t type, uint8_t nth) {
    80012806:	7139                	addi	sp,sp,-64
    80012808:	fc22                	sd	s0,56(sp)
    8001280a:	0080                	addi	s0,sp,64
    8001280c:	fca43423          	sd	a0,-56(s0)
    80012810:	87ae                	mv	a5,a1
    80012812:	8732                	mv	a4,a2
    80012814:	fcf403a3          	sb	a5,-57(s0)
    80012818:	87ba                	mv	a5,a4
    8001281a:	fcf40323          	sb	a5,-58(s0)
    // Get the header for the device
    volatile struct pci_ecam *header = device->ecam_header;
    8001281e:	fc843783          	ld	a5,-56(s0)
    80012822:	639c                	ld	a5,0(a5)
    80012824:	fef43023          	sd	a5,-32(s0)
    if (!(header->status_reg & (1 << 4))) {
    80012828:	fe043783          	ld	a5,-32(s0)
    8001282c:	0067d783          	lhu	a5,6(a5)
    80012830:	17c2                	slli	a5,a5,0x30
    80012832:	93c1                	srli	a5,a5,0x30
    80012834:	2781                	sext.w	a5,a5
    80012836:	8bc1                	andi	a5,a5,16
    80012838:	2781                	sext.w	a5,a5
    8001283a:	e399                	bnez	a5,80012840 <pci_get_capability+0x3a>
        debugf("Status reg bit 4 not set; no capabilities for device\n");
        return NULL;
    8001283c:	4781                	li	a5,0
    8001283e:	a055                	j	800128e2 <pci_get_capability+0xdc>
    }
    
    // Get the offset of the first capability
    uint8_t cap_pointer = header->type0.capes_pointer;
    80012840:	fe043783          	ld	a5,-32(s0)
    80012844:	0347c783          	lbu	a5,52(a5)
    80012848:	fef407a3          	sb	a5,-17(s0)
    // Count the number of capabilities we've seen
    uint8_t count = 0;
    8001284c:	fe040723          	sb	zero,-18(s0)
    
    // While the capability pointer is not zero
    while (cap_pointer) {
    80012850:	a059                	j	800128d6 <pci_get_capability+0xd0>
        // Get the capability at the offset
        volatile struct pci_cape* cape = (struct pci_cape*)((uintptr_t)header + cap_pointer);
    80012852:	fef44703          	lbu	a4,-17(s0)
    80012856:	fe043783          	ld	a5,-32(s0)
    8001285a:	97ba                	add	a5,a5,a4
    8001285c:	fcf43c23          	sd	a5,-40(s0)
        // If the capability ID matches the type we're looking for
        switch (cape->id) {
    80012860:	fd843783          	ld	a5,-40(s0)
    80012864:	0007c783          	lbu	a5,0(a5)
    80012868:	0ff7f793          	andi	a5,a5,255
    8001286c:	2781                	sext.w	a5,a5
    8001286e:	86be                	mv	a3,a5
    80012870:	4725                	li	a4,9
    80012872:	00e68e63          	beq	a3,a4,8001288e <pci_get_capability+0x88>
    80012876:	86be                	mv	a3,a5
    80012878:	4725                	li	a4,9
    8001287a:	00e6cc63          	blt	a3,a4,80012892 <pci_get_capability+0x8c>
    8001287e:	2781                	sext.w	a5,a5
    80012880:	37c1                	addiw	a5,a5,-16
    80012882:	2781                	sext.w	a5,a5
    80012884:	873e                	mv	a4,a5
    80012886:	4785                	li	a5,1
    80012888:	00e7e563          	bltu	a5,a4,80012892 <pci_get_capability+0x8c>
            {
            }
            case 0x11: /* MSI-x */
            {
            }
            break;
    8001288c:	a021                	j	80012894 <pci_get_capability+0x8e>
            break;
    8001288e:	0001                	nop
    80012890:	a011                	j	80012894 <pci_get_capability+0x8e>
            default:
                debugf("Unknown capability ID 0x%02x (next: 0x%02x)\n", cape->id, cape->next);
            break;
    80012892:	0001                	nop
        }

        if (cape->id == type) {
    80012894:	fd843783          	ld	a5,-40(s0)
    80012898:	0007c783          	lbu	a5,0(a5)
    8001289c:	0ff7f713          	andi	a4,a5,255
    800128a0:	fc744783          	lbu	a5,-57(s0)
    800128a4:	0ff7f793          	andi	a5,a5,255
    800128a8:	02e79163          	bne	a5,a4,800128ca <pci_get_capability+0xc4>
            // If we've seen the nth capability, return it
            if (count++ == nth) {
    800128ac:	fee44783          	lbu	a5,-18(s0)
    800128b0:	0017871b          	addiw	a4,a5,1
    800128b4:	fee40723          	sb	a4,-18(s0)
    800128b8:	fc644703          	lbu	a4,-58(s0)
    800128bc:	0ff77713          	andi	a4,a4,255
    800128c0:	00f71563          	bne	a4,a5,800128ca <pci_get_capability+0xc4>
                return cape;
    800128c4:	fd843783          	ld	a5,-40(s0)
    800128c8:	a829                	j	800128e2 <pci_get_capability+0xdc>
            }
        }
        // Otherwise, continue to the next capability
        cap_pointer = cape->next; 
    800128ca:	fd843783          	ld	a5,-40(s0)
    800128ce:	0017c783          	lbu	a5,1(a5)
    800128d2:	fef407a3          	sb	a5,-17(s0)
    while (cap_pointer) {
    800128d6:	fef44783          	lbu	a5,-17(s0)
    800128da:	0ff7f793          	andi	a5,a5,255
    800128de:	fbb5                	bnez	a5,80012852 <pci_get_capability+0x4c>
    }
    return NULL;
    800128e0:	4781                	li	a5,0
}
    800128e2:	853e                	mv	a0,a5
    800128e4:	7462                	ld	s0,56(sp)
    800128e6:	6121                	addi	sp,sp,64
    800128e8:	8082                	ret

00000000800128ea <pci_get_virtio_capability>:
// For the common configuration capability, use `VIRTIO_PCI_CAP_COMMON_CFG`.
// For the notify capability, use `VIRTIO_PCI_CAP_NOTIFY_CFG`.
// For the ISR capability, use `VIRTIO_PCI_CAP_ISR_CFG`.
// For the device configuration capability, use `VIRTIO_PCI_CAP_DEVICE_CFG`.
// For the PCI configuration access capability, use `VIRTIO_PCI_CAP_PCI_CFG`.
volatile struct VirtioCapability *pci_get_virtio_capability(PCIDevice *device, uint8_t virtio_cap_type) {
    800128ea:	7139                	addi	sp,sp,-64
    800128ec:	fc06                	sd	ra,56(sp)
    800128ee:	f822                	sd	s0,48(sp)
    800128f0:	0080                	addi	s0,sp,64
    800128f2:	fca43423          	sd	a0,-56(s0)
    800128f6:	87ae                	mv	a5,a1
    800128f8:	fcf403a3          	sb	a5,-57(s0)
    // Iterate through the first 10 capabilities
    for (uint8_t i=0; i<10; i++) {
    800128fc:	fe0407a3          	sb	zero,-17(s0)
    80012900:	a0b1                	j	8001294c <pci_get_virtio_capability+0x62>
        // Get the capability
        volatile struct pci_cape *cape = pci_get_capability(device, 0x09, i);
    80012902:	fef44783          	lbu	a5,-17(s0)
    80012906:	863e                	mv	a2,a5
    80012908:	45a5                	li	a1,9
    8001290a:	fc843503          	ld	a0,-56(s0)
    8001290e:	ef9ff0ef          	jal	ra,80012806 <pci_get_capability>
    80012912:	fea43023          	sd	a0,-32(s0)
        volatile struct VirtioCapability *virtio_cap = (struct VirtioCapability *)cape;
    80012916:	fe043783          	ld	a5,-32(s0)
    8001291a:	fcf43c23          	sd	a5,-40(s0)
        // If the capability isnt NULL and the type matches, return it
        if (virtio_cap && virtio_cap->type == virtio_cap_type) {
    8001291e:	fd843783          	ld	a5,-40(s0)
    80012922:	c385                	beqz	a5,80012942 <pci_get_virtio_capability+0x58>
    80012924:	fd843783          	ld	a5,-40(s0)
    80012928:	0037c783          	lbu	a5,3(a5)
    8001292c:	0ff7f713          	andi	a4,a5,255
    80012930:	fc744783          	lbu	a5,-57(s0)
    80012934:	0ff7f793          	andi	a5,a5,255
    80012938:	00e79563          	bne	a5,a4,80012942 <pci_get_virtio_capability+0x58>
            debugf("Got capability of type %x at %p\n", virtio_cap_type, virtio_cap);
            return virtio_cap;
    8001293c:	fd843783          	ld	a5,-40(s0)
    80012940:	a831                	j	8001295c <pci_get_virtio_capability+0x72>
    for (uint8_t i=0; i<10; i++) {
    80012942:	fef44783          	lbu	a5,-17(s0)
    80012946:	2785                	addiw	a5,a5,1
    80012948:	fef407a3          	sb	a5,-17(s0)
    8001294c:	fef44783          	lbu	a5,-17(s0)
    80012950:	0ff7f713          	andi	a4,a5,255
    80012954:	47a5                	li	a5,9
    80012956:	fae7f6e3          	bgeu	a5,a4,80012902 <pci_get_virtio_capability+0x18>
        }
    }
    // If we get here, we didn't find the capability
    debugf("No virtio capability found with type %d\n", virtio_cap_type);
    return NULL;
    8001295a:	4781                	li	a5,0
}
    8001295c:	853e                	mv	a0,a5
    8001295e:	70e2                	ld	ra,56(sp)
    80012960:	7442                	ld	s0,48(sp)
    80012962:	6121                	addi	sp,sp,64
    80012964:	8082                	ret

0000000080012966 <pci_count_saved_devices>:

// Return the number of bookkeeping PCI devices saved by the OS.
uint64_t pci_count_saved_devices(void) {
    80012966:	1141                	addi	sp,sp,-16
    80012968:	e406                	sd	ra,8(sp)
    8001296a:	e022                	sd	s0,0(sp)
    8001296c:	0800                	addi	s0,sp,16
    return vector_size(all_pci_devices);
    8001296e:	0000d797          	auipc	a5,0xd
    80012972:	6ca78793          	addi	a5,a5,1738 # 80020038 <all_pci_devices>
    80012976:	639c                	ld	a5,0(a5)
    80012978:	853e                	mv	a0,a5
    8001297a:	5630b0ef          	jal	ra,8001e6dc <vector_size>
    8001297e:	87aa                	mv	a5,a0
    80012980:	2781                	sext.w	a5,a5
    80012982:	1782                	slli	a5,a5,0x20
    80012984:	9381                	srli	a5,a5,0x20
}
    80012986:	853e                	mv	a0,a5
    80012988:	60a2                	ld	ra,8(sp)
    8001298a:	6402                	ld	s0,0(sp)
    8001298c:	0141                	addi	sp,sp,16
    8001298e:	8082                	ret

0000000080012990 <pci_count_irq_listeners>:

// Count how many devices are listening for the given IRQ.
uint64_t pci_count_irq_listeners(uint8_t irq) {
    80012990:	7179                	addi	sp,sp,-48
    80012992:	f406                	sd	ra,40(sp)
    80012994:	f022                	sd	s0,32(sp)
    80012996:	1800                	addi	s0,sp,48
    80012998:	87aa                	mv	a5,a0
    8001299a:	fcf40fa3          	sb	a5,-33(s0)
    uint32_t vector_idx = irq - 32;
    8001299e:	fdf44783          	lbu	a5,-33(s0)
    800129a2:	2781                	sext.w	a5,a5
    800129a4:	3781                	addiw	a5,a5,-32
    800129a6:	2781                	sext.w	a5,a5
    800129a8:	fef42623          	sw	a5,-20(s0)
    return vector_size(irq_pci_devices[vector_idx]);
    800129ac:	0000d717          	auipc	a4,0xd
    800129b0:	69470713          	addi	a4,a4,1684 # 80020040 <irq_pci_devices>
    800129b4:	fec46783          	lwu	a5,-20(s0)
    800129b8:	078e                	slli	a5,a5,0x3
    800129ba:	97ba                	add	a5,a5,a4
    800129bc:	639c                	ld	a5,0(a5)
    800129be:	853e                	mv	a0,a5
    800129c0:	51d0b0ef          	jal	ra,8001e6dc <vector_size>
    800129c4:	87aa                	mv	a5,a0
    800129c6:	2781                	sext.w	a5,a5
    800129c8:	1782                	slli	a5,a5,0x20
    800129ca:	9381                	srli	a5,a5,0x20
}
    800129cc:	853e                	mv	a0,a5
    800129ce:	70a2                	ld	ra,40(sp)
    800129d0:	7402                	ld	s0,32(sp)
    800129d2:	6145                	addi	sp,sp,48
    800129d4:	8082                	ret

00000000800129d6 <pci_get_bus_number>:

// Get the bus number for the given PCI device.
uint8_t pci_get_bus_number(PCIDevice *dev) {
    800129d6:	1101                	addi	sp,sp,-32
    800129d8:	ec22                	sd	s0,24(sp)
    800129da:	1000                	addi	s0,sp,32
    800129dc:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 20) & 0xF;
    800129e0:	fe843783          	ld	a5,-24(s0)
    800129e4:	639c                	ld	a5,0(a5)
    800129e6:	83d1                	srli	a5,a5,0x14
    800129e8:	0ff7f793          	andi	a5,a5,255
    800129ec:	8bbd                	andi	a5,a5,15
    800129ee:	0ff7f793          	andi	a5,a5,255
}
    800129f2:	853e                	mv	a0,a5
    800129f4:	6462                	ld	s0,24(sp)
    800129f6:	6105                	addi	sp,sp,32
    800129f8:	8082                	ret

00000000800129fa <pci_get_slot_number>:

// Get the slot number for the given PCI device.
uint8_t pci_get_slot_number(PCIDevice *dev) {
    800129fa:	1101                	addi	sp,sp,-32
    800129fc:	ec22                	sd	s0,24(sp)
    800129fe:	1000                	addi	s0,sp,32
    80012a00:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 15) & 0x1F;
    80012a04:	fe843783          	ld	a5,-24(s0)
    80012a08:	639c                	ld	a5,0(a5)
    80012a0a:	83bd                	srli	a5,a5,0xf
    80012a0c:	0ff7f793          	andi	a5,a5,255
    80012a10:	8bfd                	andi	a5,a5,31
    80012a12:	0ff7f793          	andi	a5,a5,255
}
    80012a16:	853e                	mv	a0,a5
    80012a18:	6462                	ld	s0,24(sp)
    80012a1a:	6105                	addi	sp,sp,32
    80012a1c:	8082                	ret

0000000080012a1e <pci_save_device>:

// Save the PCI device for bookkeeping. This will save some
// information about the device for quick access later.
PCIDevice *pci_save_device(PCIDevice device) {
    80012a1e:	7179                	addi	sp,sp,-48
    80012a20:	f406                	sd	ra,40(sp)
    80012a22:	f022                	sd	s0,32(sp)
    80012a24:	ec26                	sd	s1,24(sp)
    80012a26:	1800                	addi	s0,sp,48
    80012a28:	84aa                	mv	s1,a0
    // Allocate some memory for the device's bookkeeping structure
    PCIDevice *pcidev = (PCIDevice *)kzalloc(sizeof(PCIDevice));
    80012a2a:	03800593          	li	a1,56
    80012a2e:	4505                	li	a0,1
    80012a30:	286010ef          	jal	ra,80013cb6 <kcalloc>
    80012a34:	fca43c23          	sd	a0,-40(s0)
    // Record the device's ECAM header
    memcpy(pcidev, &device, sizeof(PCIDevice));
    80012a38:	03800613          	li	a2,56
    80012a3c:	85a6                	mv	a1,s1
    80012a3e:	fd843503          	ld	a0,-40(s0)
    80012a42:	1eb0a0ef          	jal	ra,8001d42c <memcpy>
    // Store the device in the all devices vector
    vector_push_ptr(all_pci_devices, pcidev);
    80012a46:	0000d797          	auipc	a5,0xd
    80012a4a:	5f278793          	addi	a5,a5,1522 # 80020038 <all_pci_devices>
    80012a4e:	639c                	ld	a5,0(a5)
    80012a50:	fd843703          	ld	a4,-40(s0)
    80012a54:	85ba                	mv	a1,a4
    80012a56:	853e                	mv	a0,a5
    80012a58:	3c40b0ef          	jal	ra,8001de1c <vector_push>
    // Store the device in the appropriate IRQ vector
    uint8_t bus = pci_get_bus_number(pcidev);
    80012a5c:	fd843503          	ld	a0,-40(s0)
    80012a60:	f77ff0ef          	jal	ra,800129d6 <pci_get_bus_number>
    80012a64:	87aa                	mv	a5,a0
    80012a66:	fcf40ba3          	sb	a5,-41(s0)
    uint8_t slot = pci_get_slot_number(pcidev);
    80012a6a:	fd843503          	ld	a0,-40(s0)
    80012a6e:	f8dff0ef          	jal	ra,800129fa <pci_get_slot_number>
    80012a72:	87aa                	mv	a5,a0
    80012a74:	fcf40b23          	sb	a5,-42(s0)
    debugf("Saving device with vendor ID: 0x%04x, device ID: 0x%04x, class code: 0x%04x\n", device.ecam_header->vendor_id, device.ecam_header->device_id, device.ecam_header->class_code);
    debugf("  Bus: %d, slot: %d\n", bus, slot);
    uint32_t vector_idx = (bus + slot) % 4;
    80012a78:	fd744703          	lbu	a4,-41(s0)
    80012a7c:	fd644783          	lbu	a5,-42(s0)
    80012a80:	9fb9                	addw	a5,a5,a4
    80012a82:	0ff7f793          	andi	a5,a5,255
    80012a86:	2781                	sext.w	a5,a5
    80012a88:	8b8d                	andi	a5,a5,3
    80012a8a:	fcf42823          	sw	a5,-48(s0)
    vector_push_ptr(irq_pci_devices[vector_idx], pcidev);
    80012a8e:	0000d717          	auipc	a4,0xd
    80012a92:	5b270713          	addi	a4,a4,1458 # 80020040 <irq_pci_devices>
    80012a96:	fd046783          	lwu	a5,-48(s0)
    80012a9a:	078e                	slli	a5,a5,0x3
    80012a9c:	97ba                	add	a5,a5,a4
    80012a9e:	639c                	ld	a5,0(a5)
    80012aa0:	fd843703          	ld	a4,-40(s0)
    80012aa4:	85ba                	mv	a1,a4
    80012aa6:	853e                	mv	a0,a5
    80012aa8:	3740b0ef          	jal	ra,8001de1c <vector_push>
    // Return the device's bookkeeping structure in memory
    return pcidev;
    80012aac:	fd843783          	ld	a5,-40(s0)
}
    80012ab0:	853e                	mv	a0,a5
    80012ab2:	70a2                	ld	ra,40(sp)
    80012ab4:	7402                	ld	s0,32(sp)
    80012ab6:	64e2                	ld	s1,24(sp)
    80012ab8:	6145                	addi	sp,sp,48
    80012aba:	8082                	ret

0000000080012abc <pci_get_nth_saved_device>:

// Get the nth saved PCI device structure kept by the OS.
PCIDevice *pci_get_nth_saved_device(uint16_t n) {
    80012abc:	7179                	addi	sp,sp,-48
    80012abe:	f406                	sd	ra,40(sp)
    80012ac0:	f022                	sd	s0,32(sp)
    80012ac2:	1800                	addi	s0,sp,48
    80012ac4:	87aa                	mv	a5,a0
    80012ac6:	fcf41f23          	sh	a5,-34(s0)
    PCIDevice *pcidev;
    vector_get_ptr(all_pci_devices, n, &pcidev);
    80012aca:	0000d797          	auipc	a5,0xd
    80012ace:	56e78793          	addi	a5,a5,1390 # 80020038 <all_pci_devices>
    80012ad2:	639c                	ld	a5,0(a5)
    80012ad4:	fde45703          	lhu	a4,-34(s0)
    80012ad8:	2701                	sext.w	a4,a4
    80012ada:	fe840693          	addi	a3,s0,-24
    80012ade:	8636                	mv	a2,a3
    80012ae0:	85ba                	mv	a1,a4
    80012ae2:	853e                	mv	a0,a5
    80012ae4:	4980b0ef          	jal	ra,8001df7c <vector_get>
    return pcidev;
    80012ae8:	fe843783          	ld	a5,-24(s0)
}
    80012aec:	853e                	mv	a0,a5
    80012aee:	70a2                	ld	ra,40(sp)
    80012af0:	7402                	ld	s0,32(sp)
    80012af2:	6145                	addi	sp,sp,48
    80012af4:	8082                	ret

0000000080012af6 <pci_find_device_by_irq>:

// Get the device responsible for a given IRQ.
PCIDevice *pci_find_device_by_irq(uint8_t irq) {
    80012af6:	7139                	addi	sp,sp,-64
    80012af8:	fc06                	sd	ra,56(sp)
    80012afa:	f822                	sd	s0,48(sp)
    80012afc:	0080                	addi	s0,sp,64
    80012afe:	87aa                	mv	a5,a0
    80012b00:	fcf407a3          	sb	a5,-49(s0)
    uint32_t vector_idx = irq - 32;
    80012b04:	fcf44783          	lbu	a5,-49(s0)
    80012b08:	2781                	sext.w	a5,a5
    80012b0a:	3781                	addiw	a5,a5,-32
    80012b0c:	2781                	sext.w	a5,a5
    80012b0e:	fef42423          	sw	a5,-24(s0)
    debugf("Finding device with IRQ %d\n", irq);

    // Check all devices in the vector
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    80012b12:	fe042623          	sw	zero,-20(s0)
    80012b16:	a875                	j	80012bd2 <pci_find_device_by_irq+0xdc>
        // Get the nth PCI device listening for the IRQ
        PCIDevice *device = NULL;
    80012b18:	fc043823          	sd	zero,-48(s0)
        vector_get_ptr(irq_pci_devices[vector_idx], i, &device);
    80012b1c:	0000d717          	auipc	a4,0xd
    80012b20:	52470713          	addi	a4,a4,1316 # 80020040 <irq_pci_devices>
    80012b24:	fe846783          	lwu	a5,-24(s0)
    80012b28:	078e                	slli	a5,a5,0x3
    80012b2a:	97ba                	add	a5,a5,a4
    80012b2c:	639c                	ld	a5,0(a5)
    80012b2e:	fd040693          	addi	a3,s0,-48
    80012b32:	fec42703          	lw	a4,-20(s0)
    80012b36:	8636                	mv	a2,a3
    80012b38:	85ba                	mv	a1,a4
    80012b3a:	853e                	mv	a0,a5
    80012b3c:	4400b0ef          	jal	ra,8001df7c <vector_get>
        debugf("Device: %p\n", device->ecam_header);
        // If the device is a Virtio device, check the Virtio ISR status
        if (!pci_is_virtio_device(device)) {
    80012b40:	fd043783          	ld	a5,-48(s0)
    80012b44:	853e                	mv	a0,a5
    80012b46:	bedff0ef          	jal	ra,80012732 <pci_is_virtio_device>
    80012b4a:	87aa                	mv	a5,a0
    80012b4c:	0017c793          	xori	a5,a5,1
    80012b50:	0ff7f793          	andi	a5,a5,255
    80012b54:	e7bd                	bnez	a5,80012bc2 <pci_find_device_by_irq+0xcc>
            debugf("%p not a virtio device\n", device);
            continue;
        }
        
        // Confirm that the device exists
        if (!pci_device_exists(device->ecam_header->vendor_id)) {
    80012b56:	fd043783          	ld	a5,-48(s0)
    80012b5a:	639c                	ld	a5,0(a5)
    80012b5c:	0007d783          	lhu	a5,0(a5)
    80012b60:	17c2                	slli	a5,a5,0x30
    80012b62:	93c1                	srli	a5,a5,0x30
    80012b64:	853e                	mv	a0,a5
    80012b66:	b95ff0ef          	jal	ra,800126fa <pci_device_exists>
    80012b6a:	87aa                	mv	a5,a0
    80012b6c:	0017c793          	xori	a5,a5,1
    80012b70:	0ff7f793          	andi	a5,a5,255
    80012b74:	eba9                	bnez	a5,80012bc6 <pci_find_device_by_irq+0xd0>
            debugf("%p device doesn't exist\n", device);
            continue;
        }

        // Get the Virtio ISR status
        volatile struct VirtioPciIsrCfg *isr = pci_get_virtio_isr_status(device);
    80012b76:	fd043783          	ld	a5,-48(s0)
    80012b7a:	853e                	mv	a0,a5
    80012b7c:	19e000ef          	jal	ra,80012d1a <pci_get_virtio_isr_status>
    80012b80:	fea43023          	sd	a0,-32(s0)
        int result = isr->isr_cap;
    80012b84:	fe043783          	ld	a5,-32(s0)
    80012b88:	439c                	lw	a5,0(a5)
    80012b8a:	2781                	sext.w	a5,a5
    80012b8c:	fcf42e23          	sw	a5,-36(s0)
        debugf("ISR at %p=0x%x\n", isr, result);
        if (result) {
    80012b90:	fdc42783          	lw	a5,-36(s0)
    80012b94:	2781                	sext.w	a5,a5
    80012b96:	c781                	beqz	a5,80012b9e <pci_find_device_by_irq+0xa8>
            debugf("IRQ device responsible: %p\n", device);
            return device;
    80012b98:	fd043783          	ld	a5,-48(s0)
    80012b9c:	a085                	j	80012bfc <pci_find_device_by_irq+0x106>
        }

        // Check if the device's configuration has changed
        if (isr->isr_cap) {
    80012b9e:	fe043783          	ld	a5,-32(s0)
    80012ba2:	439c                	lw	a5,0(a5)
    80012ba4:	2781                	sext.w	a5,a5
    80012ba6:	c781                	beqz	a5,80012bae <pci_find_device_by_irq+0xb8>
            debugf("Device configuration interrupt from device 0x%04x\n", device->ecam_header->device_id);
            return device;
    80012ba8:	fd043783          	ld	a5,-48(s0)
    80012bac:	a881                	j	80012bfc <pci_find_device_by_irq+0x106>
        }

        // Check if the device's queue has an interrupt
        if (isr->queue_interrupt) {
    80012bae:	fe043783          	ld	a5,-32(s0)
    80012bb2:	439c                	lw	a5,0(a5)
    80012bb4:	8b85                	andi	a5,a5,1
    80012bb6:	0ff7f793          	andi	a5,a5,255
    80012bba:	c799                	beqz	a5,80012bc8 <pci_find_device_by_irq+0xd2>
            debugf("Device queue interrupt from device 0x%04x\n", device->ecam_header->device_id);
            return device;
    80012bbc:	fd043783          	ld	a5,-48(s0)
    80012bc0:	a835                	j	80012bfc <pci_find_device_by_irq+0x106>
            continue;
    80012bc2:	0001                	nop
    80012bc4:	a011                	j	80012bc8 <pci_find_device_by_irq+0xd2>
            continue;
    80012bc6:	0001                	nop
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    80012bc8:	fec42783          	lw	a5,-20(s0)
    80012bcc:	2785                	addiw	a5,a5,1
    80012bce:	fef42623          	sw	a5,-20(s0)
    80012bd2:	0000d717          	auipc	a4,0xd
    80012bd6:	46e70713          	addi	a4,a4,1134 # 80020040 <irq_pci_devices>
    80012bda:	fe846783          	lwu	a5,-24(s0)
    80012bde:	078e                	slli	a5,a5,0x3
    80012be0:	97ba                	add	a5,a5,a4
    80012be2:	639c                	ld	a5,0(a5)
    80012be4:	853e                	mv	a0,a5
    80012be6:	2f70b0ef          	jal	ra,8001e6dc <vector_size>
    80012bea:	87aa                	mv	a5,a0
    80012bec:	0007871b          	sext.w	a4,a5
    80012bf0:	fec42783          	lw	a5,-20(s0)
    80012bf4:	2781                	sext.w	a5,a5
    80012bf6:	f2e7e1e3          	bltu	a5,a4,80012b18 <pci_find_device_by_irq+0x22>
        }
    }
    debugf("No device found with IRQ %d\n", irq);
    return NULL;
    80012bfa:	4781                	li	a5,0
}
    80012bfc:	853e                	mv	a0,a5
    80012bfe:	70e2                	ld	ra,56(sp)
    80012c00:	7442                	ld	s0,48(sp)
    80012c02:	6121                	addi	sp,sp,64
    80012c04:	8082                	ret

0000000080012c06 <pci_get_device_specific_config>:


// Get the common configuration capability for the given virtio device.
volatile void *pci_get_device_specific_config(PCIDevice *device) {
    80012c06:	7179                	addi	sp,sp,-48
    80012c08:	f406                	sd	ra,40(sp)
    80012c0a:	f022                	sd	s0,32(sp)
    80012c0c:	1800                	addi	s0,sp,48
    80012c0e:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_DEVICE_CFG);
    80012c12:	4591                	li	a1,4
    80012c14:	fd843503          	ld	a0,-40(s0)
    80012c18:	cd3ff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012c1c:	fea43423          	sd	a0,-24(s0)
    debugf("Getting device specific config from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uint64_t)vio_cap->offset);
    return (volatile void*)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    80012c20:	fd843783          	ld	a5,-40(s0)
    80012c24:	6398                	ld	a4,0(a5)
    80012c26:	fe843783          	ld	a5,-24(s0)
    80012c2a:	0047c783          	lbu	a5,4(a5)
    80012c2e:	0ff7f793          	andi	a5,a5,255
    80012c32:	2781                	sext.w	a5,a5
    80012c34:	0791                	addi	a5,a5,4
    80012c36:	078a                	slli	a5,a5,0x2
    80012c38:	97ba                	add	a5,a5,a4
    80012c3a:	439c                	lw	a5,0(a5)
    80012c3c:	2781                	sext.w	a5,a5
    80012c3e:	1782                	slli	a5,a5,0x20
    80012c40:	9381                	srli	a5,a5,0x20
    80012c42:	ff07f713          	andi	a4,a5,-16
    80012c46:	fe843783          	ld	a5,-24(s0)
    80012c4a:	479c                	lw	a5,8(a5)
    80012c4c:	2781                	sext.w	a5,a5
    80012c4e:	1782                	slli	a5,a5,0x20
    80012c50:	9381                	srli	a5,a5,0x20
    80012c52:	97ba                	add	a5,a5,a4
}
    80012c54:	853e                	mv	a0,a5
    80012c56:	70a2                	ld	ra,40(sp)
    80012c58:	7402                	ld	s0,32(sp)
    80012c5a:	6145                	addi	sp,sp,48
    80012c5c:	8082                	ret

0000000080012c5e <pci_get_virtio_common_config>:

// Get the common configuration capability for the given virtio device.
volatile struct VirtioPciCommonCfg *pci_get_virtio_common_config(PCIDevice *device) {
    80012c5e:	7179                	addi	sp,sp,-48
    80012c60:	f406                	sd	ra,40(sp)
    80012c62:	f022                	sd	s0,32(sp)
    80012c64:	1800                	addi	s0,sp,48
    80012c66:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_COMMON_CFG);
    80012c6a:	4585                	li	a1,1
    80012c6c:	fd843503          	ld	a0,-40(s0)
    80012c70:	c7bff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012c74:	fea43423          	sd	a0,-24(s0)
    debugf("Getting common capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset);
    return (volatile struct VirtioPciCommonCfg *)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    80012c78:	fd843783          	ld	a5,-40(s0)
    80012c7c:	6398                	ld	a4,0(a5)
    80012c7e:	fe843783          	ld	a5,-24(s0)
    80012c82:	0047c783          	lbu	a5,4(a5)
    80012c86:	0ff7f793          	andi	a5,a5,255
    80012c8a:	2781                	sext.w	a5,a5
    80012c8c:	0791                	addi	a5,a5,4
    80012c8e:	078a                	slli	a5,a5,0x2
    80012c90:	97ba                	add	a5,a5,a4
    80012c92:	439c                	lw	a5,0(a5)
    80012c94:	2781                	sext.w	a5,a5
    80012c96:	1782                	slli	a5,a5,0x20
    80012c98:	9381                	srli	a5,a5,0x20
    80012c9a:	ff07f713          	andi	a4,a5,-16
    80012c9e:	fe843783          	ld	a5,-24(s0)
    80012ca2:	479c                	lw	a5,8(a5)
    80012ca4:	2781                	sext.w	a5,a5
    80012ca6:	1782                	slli	a5,a5,0x20
    80012ca8:	9381                	srli	a5,a5,0x20
    80012caa:	97ba                	add	a5,a5,a4
}
    80012cac:	853e                	mv	a0,a5
    80012cae:	70a2                	ld	ra,40(sp)
    80012cb0:	7402                	ld	s0,32(sp)
    80012cb2:	6145                	addi	sp,sp,48
    80012cb4:	8082                	ret

0000000080012cb6 <pci_get_virtio_notify_capability>:

// Get the notify capability for the given virtio device.
volatile struct VirtioPciNotifyCfg *pci_get_virtio_notify_capability(PCIDevice *device) {
    80012cb6:	7179                	addi	sp,sp,-48
    80012cb8:	f406                	sd	ra,40(sp)
    80012cba:	f022                	sd	s0,32(sp)
    80012cbc:	1800                	addi	s0,sp,48
    80012cbe:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_NOTIFY_CFG);
    80012cc2:	4589                	li	a1,2
    80012cc4:	fd843503          	ld	a0,-40(s0)
    80012cc8:	c23ff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012ccc:	fea43423          	sd	a0,-24(s0)
    debugf("Cap at %p\n", vio_cap);
    debugf("Getting notify capability from bar #%d = %p + 0x%x (len=%d) %d\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset, vio_cap->len, sizeof(VirtioPciNotifyCfg));
    return (volatile struct VirtioPciNotifyCfg*)vio_cap;
    80012cd0:	fe843783          	ld	a5,-24(s0)
}
    80012cd4:	853e                	mv	a0,a5
    80012cd6:	70a2                	ld	ra,40(sp)
    80012cd8:	7402                	ld	s0,32(sp)
    80012cda:	6145                	addi	sp,sp,48
    80012cdc:	8082                	ret

0000000080012cde <pci_get_device_bar>:

volatile uint8_t *pci_get_device_bar(PCIDevice *device, uint8_t bar_num) {
    80012cde:	1101                	addi	sp,sp,-32
    80012ce0:	ec22                	sd	s0,24(sp)
    80012ce2:	1000                	addi	s0,sp,32
    80012ce4:	fea43423          	sd	a0,-24(s0)
    80012ce8:	87ae                	mv	a5,a1
    80012cea:	fef403a3          	sb	a5,-25(s0)
    return (volatile uint8_t*)(uintptr_t)(device->ecam_header->type0.bar[bar_num] & ~0xf);
    80012cee:	fe843783          	ld	a5,-24(s0)
    80012cf2:	6398                	ld	a4,0(a5)
    80012cf4:	fe744783          	lbu	a5,-25(s0)
    80012cf8:	2781                	sext.w	a5,a5
    80012cfa:	0791                	addi	a5,a5,4
    80012cfc:	078a                	slli	a5,a5,0x2
    80012cfe:	97ba                	add	a5,a5,a4
    80012d00:	439c                	lw	a5,0(a5)
    80012d02:	2781                	sext.w	a5,a5
    80012d04:	02079713          	slli	a4,a5,0x20
    80012d08:	9301                	srli	a4,a4,0x20
    80012d0a:	4785                	li	a5,1
    80012d0c:	1782                	slli	a5,a5,0x20
    80012d0e:	17c1                	addi	a5,a5,-16
    80012d10:	8ff9                	and	a5,a5,a4
}
    80012d12:	853e                	mv	a0,a5
    80012d14:	6462                	ld	s0,24(sp)
    80012d16:	6105                	addi	sp,sp,32
    80012d18:	8082                	ret

0000000080012d1a <pci_get_virtio_isr_status>:


// Get the ISR capability for the given virtio device.
volatile struct VirtioPciIsrCfg *pci_get_virtio_isr_status(PCIDevice *device) {
    80012d1a:	7179                	addi	sp,sp,-48
    80012d1c:	f406                	sd	ra,40(sp)
    80012d1e:	f022                	sd	s0,32(sp)
    80012d20:	1800                	addi	s0,sp,48
    80012d22:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_ISR_CFG);
    80012d26:	458d                	li	a1,3
    80012d28:	fd843503          	ld	a0,-40(s0)
    80012d2c:	bbfff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012d30:	fea43423          	sd	a0,-24(s0)
    debugf("Getting ISR capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset);
    return (volatile struct VirtioPciIsrCfg *)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    80012d34:	fd843783          	ld	a5,-40(s0)
    80012d38:	6398                	ld	a4,0(a5)
    80012d3a:	fe843783          	ld	a5,-24(s0)
    80012d3e:	0047c783          	lbu	a5,4(a5)
    80012d42:	0ff7f793          	andi	a5,a5,255
    80012d46:	2781                	sext.w	a5,a5
    80012d48:	0791                	addi	a5,a5,4
    80012d4a:	078a                	slli	a5,a5,0x2
    80012d4c:	97ba                	add	a5,a5,a4
    80012d4e:	439c                	lw	a5,0(a5)
    80012d50:	2781                	sext.w	a5,a5
    80012d52:	1782                	slli	a5,a5,0x20
    80012d54:	9381                	srli	a5,a5,0x20
    80012d56:	ff07f713          	andi	a4,a5,-16
    80012d5a:	fe843783          	ld	a5,-24(s0)
    80012d5e:	479c                	lw	a5,8(a5)
    80012d60:	2781                	sext.w	a5,a5
    80012d62:	1782                	slli	a5,a5,0x20
    80012d64:	9381                	srli	a5,a5,0x20
    80012d66:	97ba                	add	a5,a5,a4
}
    80012d68:	853e                	mv	a0,a5
    80012d6a:	70a2                	ld	ra,40(sp)
    80012d6c:	7402                	ld	s0,32(sp)
    80012d6e:	6145                	addi	sp,sp,48
    80012d70:	8082                	ret

0000000080012d72 <pci_get_ecam>:

static volatile struct pci_ecam *pci_get_ecam(uint8_t bus,
                                              uint8_t device,
                                              uint8_t function,
                                              uint16_t reg) 
{
    80012d72:	715d                	addi	sp,sp,-80
    80012d74:	e486                	sd	ra,72(sp)
    80012d76:	e0a2                	sd	s0,64(sp)
    80012d78:	0880                	addi	s0,sp,80
    80012d7a:	87aa                	mv	a5,a0
    80012d7c:	8736                	mv	a4,a3
    80012d7e:	faf40fa3          	sb	a5,-65(s0)
    80012d82:	87ae                	mv	a5,a1
    80012d84:	faf40f23          	sb	a5,-66(s0)
    80012d88:	87b2                	mv	a5,a2
    80012d8a:	faf40ea3          	sb	a5,-67(s0)
    80012d8e:	87ba                	mv	a5,a4
    80012d90:	faf41d23          	sh	a5,-70(s0)
    // Since we're shifting, we need to make sure we
    // have enough space to shift into.
    uint64_t bus64 = bus & 0xff;
    80012d94:	fbf44783          	lbu	a5,-65(s0)
    80012d98:	fef43423          	sd	a5,-24(s0)
    uint64_t device64 = device & 0x1f;
    80012d9c:	fbe44783          	lbu	a5,-66(s0)
    80012da0:	8bfd                	andi	a5,a5,31
    80012da2:	fef43023          	sd	a5,-32(s0)
    uint64_t function64 = function & 0x7;
    80012da6:	fbd44783          	lbu	a5,-67(s0)
    80012daa:	8b9d                	andi	a5,a5,7
    80012dac:	fcf43c23          	sd	a5,-40(s0)
    uint64_t reg64 = reg & 0x3ff; 
    80012db0:	fba45783          	lhu	a5,-70(s0)
    80012db4:	3ff7f793          	andi	a5,a5,1023
    80012db8:	fcf43823          	sd	a5,-48(s0)
    
    // Finally, put the address together
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    80012dbc:	fe843783          	ld	a5,-24(s0)
    80012dc0:	01479713          	slli	a4,a5,0x14
                     (device64 << 15) |   // device number A[19:15]
    80012dc4:	fe043783          	ld	a5,-32(s0)
    80012dc8:	07be                	slli	a5,a5,0xf
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    80012dca:	8f5d                	or	a4,a4,a5
                     (function64 << 12) | // function number A[14:12]
    80012dcc:	fd843783          	ld	a5,-40(s0)
    80012dd0:	07b2                	slli	a5,a5,0xc
                     (device64 << 15) |   // device number A[19:15]
    80012dd2:	8f5d                	or	a4,a4,a5
                     (reg64 << 2));       // register number A[11:2]
    80012dd4:	fd043783          	ld	a5,-48(s0)
    80012dd8:	078a                	slli	a5,a5,0x2
                     (function64 << 12) | // function number A[14:12]
    80012dda:	8f5d                	or	a4,a4,a5
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
    80012ddc:	300007b7          	lui	a5,0x30000
    80012de0:	8fd9                	or	a5,a5,a4
    80012de2:	fcf43423          	sd	a5,-56(s0)
        
    if (addr < PCIE_ECAM_BASE || addr > PCIE_ECAM_END) {
    80012de6:	fc843703          	ld	a4,-56(s0)
    80012dea:	300007b7          	lui	a5,0x30000
    80012dee:	00f76863          	bltu	a4,a5,80012dfe <pci_get_ecam+0x8c>
    80012df2:	fc843703          	ld	a4,-56(s0)
    80012df6:	400007b7          	lui	a5,0x40000
    80012dfa:	00f76c63          	bltu	a4,a5,80012e12 <pci_get_ecam+0xa0>
        fatalf("pci_get_ecam: PCI address (0x%08x) out of bounds!\n", addr);
    80012dfe:	fc843583          	ld	a1,-56(s0)
    80012e02:	0000e517          	auipc	a0,0xe
    80012e06:	6ee50513          	addi	a0,a0,1774 # 800214f0 <pow10.0+0x2c0>
    80012e0a:	554060ef          	jal	ra,8001935e <fatalf>
        return 0; 
    80012e0e:	4781                	li	a5,0
    80012e10:	a019                	j	80012e16 <pci_get_ecam+0xa4>
    }
    return (struct pci_ecam *)addr;
    80012e12:	fc843783          	ld	a5,-56(s0)
}
    80012e16:	853e                	mv	a0,a5
    80012e18:	60a6                	ld	ra,72(sp)
    80012e1a:	6406                	ld	s0,64(sp)
    80012e1c:	6161                	addi	sp,sp,80
    80012e1e:	8082                	ret

0000000080012e20 <pci_enumerate_bus>:

static uint64_t next_mmio_address;
static uint8_t subordinate = 1;

static void pci_enumerate_bus() 
{
    80012e20:	1101                	addi	sp,sp,-32
    80012e22:	ec06                	sd	ra,24(sp)
    80012e24:	e822                	sd	s0,16(sp)
    80012e26:	1000                	addi	s0,sp,32
    for (int bus = 0; bus < 256; bus++) {
    80012e28:	fe042623          	sw	zero,-20(s0)
    80012e2c:	a0f9                	j	80012efa <pci_enumerate_bus+0xda>
        for (int device = 0; device < 32; device++) {
    80012e2e:	fe042423          	sw	zero,-24(s0)
    80012e32:	a845                	j	80012ee2 <pci_enumerate_bus+0xc2>
            volatile struct pci_ecam *ecam = pci_get_ecam(bus, device, 0, 0);
    80012e34:	fec42783          	lw	a5,-20(s0)
    80012e38:	0ff7f793          	andi	a5,a5,255
    80012e3c:	fe842703          	lw	a4,-24(s0)
    80012e40:	0ff77713          	andi	a4,a4,255
    80012e44:	4681                	li	a3,0
    80012e46:	4601                	li	a2,0
    80012e48:	85ba                	mv	a1,a4
    80012e4a:	853e                	mv	a0,a5
    80012e4c:	f27ff0ef          	jal	ra,80012d72 <pci_get_ecam>
    80012e50:	fea43023          	sd	a0,-32(s0)

            if (!pci_device_exists(ecam->vendor_id)) {
    80012e54:	fe043783          	ld	a5,-32(s0)
    80012e58:	0007d783          	lhu	a5,0(a5) # 40000000 <i+0x3fffffe0>
    80012e5c:	17c2                	slli	a5,a5,0x30
    80012e5e:	93c1                	srli	a5,a5,0x30
    80012e60:	853e                	mv	a0,a5
    80012e62:	899ff0ef          	jal	ra,800126fa <pci_device_exists>
    80012e66:	87aa                	mv	a5,a0
    80012e68:	0017c793          	xori	a5,a5,1
    80012e6c:	0ff7f793          	andi	a5,a5,255
    80012e70:	e3bd                	bnez	a5,80012ed6 <pci_enumerate_bus+0xb6>
                // debugf("pci_enumerate_bus: No device found at bus %d, device %d\n", bus, device);
                continue;
            }

            if ((ecam->header_type & 0x7F) == 1) {
    80012e72:	fe043783          	ld	a5,-32(s0)
    80012e76:	00e7c783          	lbu	a5,14(a5)
    80012e7a:	0ff7f793          	andi	a5,a5,255
    80012e7e:	2781                	sext.w	a5,a5
    80012e80:	07f7f793          	andi	a5,a5,127
    80012e84:	2781                	sext.w	a5,a5
    80012e86:	873e                	mv	a4,a5
    80012e88:	4785                	li	a5,1
    80012e8a:	00f71c63          	bne	a4,a5,80012ea2 <pci_enumerate_bus+0x82>
                // debugf("pci_enumerate_bus: Found bridge at bus %d, device %d, \n", bus, device);
                pci_configure_bridge(ecam, bus);
    80012e8e:	fec42783          	lw	a5,-20(s0)
    80012e92:	0ff7f793          	andi	a5,a5,255
    80012e96:	85be                	mv	a1,a5
    80012e98:	fe043503          	ld	a0,-32(s0)
    80012e9c:	07a000ef          	jal	ra,80012f16 <pci_configure_bridge>
    80012ea0:	a825                	j	80012ed8 <pci_enumerate_bus+0xb8>
            } else if ((ecam->header_type & 0x7F) == 0) {
    80012ea2:	fe043783          	ld	a5,-32(s0)
    80012ea6:	00e7c783          	lbu	a5,14(a5)
    80012eaa:	0ff7f793          	andi	a5,a5,255
    80012eae:	2781                	sext.w	a5,a5
    80012eb0:	07f7f793          	andi	a5,a5,127
    80012eb4:	2781                	sext.w	a5,a5
    80012eb6:	e38d                	bnez	a5,80012ed8 <pci_enumerate_bus+0xb8>
                // debugf("pci_enumerate_bus: Found device at bus %d, device %d, \n", bus, device);
                pci_configure_device(ecam, bus, device);
    80012eb8:	fec42783          	lw	a5,-20(s0)
    80012ebc:	0ff7f793          	andi	a5,a5,255
    80012ec0:	fe842703          	lw	a4,-24(s0)
    80012ec4:	0ff77713          	andi	a4,a4,255
    80012ec8:	863a                	mv	a2,a4
    80012eca:	85be                	mv	a1,a5
    80012ecc:	fe043503          	ld	a0,-32(s0)
    80012ed0:	190000ef          	jal	ra,80013060 <pci_configure_device>
    80012ed4:	a011                	j	80012ed8 <pci_enumerate_bus+0xb8>
                continue;
    80012ed6:	0001                	nop
        for (int device = 0; device < 32; device++) {
    80012ed8:	fe842783          	lw	a5,-24(s0)
    80012edc:	2785                	addiw	a5,a5,1
    80012ede:	fef42423          	sw	a5,-24(s0)
    80012ee2:	fe842783          	lw	a5,-24(s0)
    80012ee6:	0007871b          	sext.w	a4,a5
    80012eea:	47fd                	li	a5,31
    80012eec:	f4e7d4e3          	bge	a5,a4,80012e34 <pci_enumerate_bus+0x14>
    for (int bus = 0; bus < 256; bus++) {
    80012ef0:	fec42783          	lw	a5,-20(s0)
    80012ef4:	2785                	addiw	a5,a5,1
    80012ef6:	fef42623          	sw	a5,-20(s0)
    80012efa:	fec42783          	lw	a5,-20(s0)
    80012efe:	0007871b          	sext.w	a4,a5
    80012f02:	0ff00793          	li	a5,255
    80012f06:	f2e7d4e3          	bge	a5,a4,80012e2e <pci_enumerate_bus+0xe>
                // PCIDevice *device = pci_find_saved_device(ecam->vendor_id, ecam->device_id);
                // print_vendor_specific_capabilities(device);
            }
        }
    }
}
    80012f0a:	0001                	nop
    80012f0c:	0001                	nop
    80012f0e:	60e2                	ld	ra,24(sp)
    80012f10:	6442                	ld	s0,16(sp)
    80012f12:	6105                	addi	sp,sp,32
    80012f14:	8082                	ret

0000000080012f16 <pci_configure_bridge>:


static void pci_configure_bridge(volatile struct pci_ecam *bridge, uint8_t bus_no)
{
    80012f16:	7179                	addi	sp,sp,-48
    80012f18:	f422                	sd	s0,40(sp)
    80012f1a:	1800                	addi	s0,sp,48
    80012f1c:	fca43c23          	sd	a0,-40(s0)
    80012f20:	87ae                	mv	a5,a1
    80012f22:	fcf40ba3          	sb	a5,-41(s0)
    next_mmio_address += 0x01000000;
    */

    // Make sure to set the bus master (2) and memory space (1) bits and clear
    // I/O space bit (0) before configuring the bridges
    bridge->command_reg |= COMMAND_REG_BUSMASTER;
    80012f26:	fd843783          	ld	a5,-40(s0)
    80012f2a:	0047d783          	lhu	a5,4(a5)
    80012f2e:	17c2                	slli	a5,a5,0x30
    80012f30:	93c1                	srli	a5,a5,0x30
    80012f32:	0047e793          	ori	a5,a5,4
    80012f36:	03079713          	slli	a4,a5,0x30
    80012f3a:	9341                	srli	a4,a4,0x30
    80012f3c:	fd843783          	ld	a5,-40(s0)
    80012f40:	00e79223          	sh	a4,4(a5)
    bridge->command_reg |= COMMAND_REG_MMIO;
    80012f44:	fd843783          	ld	a5,-40(s0)
    80012f48:	0047d783          	lhu	a5,4(a5)
    80012f4c:	17c2                	slli	a5,a5,0x30
    80012f4e:	93c1                	srli	a5,a5,0x30
    80012f50:	0027e793          	ori	a5,a5,2
    80012f54:	03079713          	slli	a4,a5,0x30
    80012f58:	9341                	srli	a4,a4,0x30
    80012f5a:	fd843783          	ld	a5,-40(s0)
    80012f5e:	00e79223          	sh	a4,4(a5)
    bridge->command_reg &= ~COMMAND_REG_PIO;
    80012f62:	fd843783          	ld	a5,-40(s0)
    80012f66:	0047d783          	lhu	a5,4(a5)
    80012f6a:	17c2                	slli	a5,a5,0x30
    80012f6c:	93c1                	srli	a5,a5,0x30
    80012f6e:	9bf9                	andi	a5,a5,-2
    80012f70:	03079713          	slli	a4,a5,0x30
    80012f74:	9341                	srli	a4,a4,0x30
    80012f76:	fd843783          	ld	a5,-40(s0)
    80012f7a:	00e79223          	sh	a4,4(a5)

    uint64_t addrst = 0x40000000 | ((uint64_t)subordinate << 20);
    80012f7e:	00011797          	auipc	a5,0x11
    80012f82:	08278793          	addi	a5,a5,130 # 80024000 <subordinate>
    80012f86:	0007c783          	lbu	a5,0(a5)
    80012f8a:	01479713          	slli	a4,a5,0x14
    80012f8e:	400007b7          	lui	a5,0x40000
    80012f92:	8fd9                	or	a5,a5,a4
    80012f94:	fef43423          	sd	a5,-24(s0)
    uint64_t addred = addrst + ((1 << 20) - 1);
    80012f98:	fe843703          	ld	a4,-24(s0)
    80012f9c:	001007b7          	lui	a5,0x100
    80012fa0:	17fd                	addi	a5,a5,-1
    80012fa2:	97ba                	add	a5,a5,a4
    80012fa4:	fef43023          	sd	a5,-32(s0)
    next_mmio_address = addrst;
    80012fa8:	0000d797          	auipc	a5,0xd
    80012fac:	0b878793          	addi	a5,a5,184 # 80020060 <next_mmio_address>
    80012fb0:	fe843703          	ld	a4,-24(s0)
    80012fb4:	e398                	sd	a4,0(a5)
    
    bridge->type1.memory_base = addrst >> 16;
    80012fb6:	fe843783          	ld	a5,-24(s0)
    80012fba:	83c1                	srli	a5,a5,0x10
    80012fbc:	03079713          	slli	a4,a5,0x30
    80012fc0:	9341                	srli	a4,a4,0x30
    80012fc2:	fd843783          	ld	a5,-40(s0)
    80012fc6:	02e79023          	sh	a4,32(a5)
    bridge->type1.memory_limit = addred >> 16;
    80012fca:	fe043783          	ld	a5,-32(s0)
    80012fce:	83c1                	srli	a5,a5,0x10
    80012fd0:	03079713          	slli	a4,a5,0x30
    80012fd4:	9341                	srli	a4,a4,0x30
    80012fd6:	fd843783          	ld	a5,-40(s0)
    80012fda:	02e79123          	sh	a4,34(a5)
    bridge->type1.prefetch_memory_base = addrst >> 16;
    80012fde:	fe843783          	ld	a5,-24(s0)
    80012fe2:	83c1                	srli	a5,a5,0x10
    80012fe4:	03079713          	slli	a4,a5,0x30
    80012fe8:	9341                	srli	a4,a4,0x30
    80012fea:	fd843783          	ld	a5,-40(s0)
    80012fee:	02e79223          	sh	a4,36(a5)
    bridge->type1.prefetch_memory_limit = addred >> 16;
    80012ff2:	fe043783          	ld	a5,-32(s0)
    80012ff6:	83c1                	srli	a5,a5,0x10
    80012ff8:	03079713          	slli	a4,a5,0x30
    80012ffc:	9341                	srli	a4,a4,0x30
    80012ffe:	fd843783          	ld	a5,-40(s0)
    80013002:	02e79323          	sh	a4,38(a5)
    bridge->type1.primary_bus_no = bus_no;
    80013006:	fd843783          	ld	a5,-40(s0)
    8001300a:	fd744703          	lbu	a4,-41(s0)
    8001300e:	00e78c23          	sb	a4,24(a5)
    bridge->type1.secondary_bus_no = subordinate;
    80013012:	00011797          	auipc	a5,0x11
    80013016:	fee78793          	addi	a5,a5,-18 # 80024000 <subordinate>
    8001301a:	0007c703          	lbu	a4,0(a5)
    8001301e:	fd843783          	ld	a5,-40(s0)
    80013022:	00e78ca3          	sb	a4,25(a5)
    bridge->type1.subordinate_bus_no = subordinate;
    80013026:	00011797          	auipc	a5,0x11
    8001302a:	fda78793          	addi	a5,a5,-38 # 80024000 <subordinate>
    8001302e:	0007c703          	lbu	a4,0(a5)
    80013032:	fd843783          	ld	a5,-40(s0)
    80013036:	00e78d23          	sb	a4,26(a5)
    subordinate += 1;
    8001303a:	00011797          	auipc	a5,0x11
    8001303e:	fc678793          	addi	a5,a5,-58 # 80024000 <subordinate>
    80013042:	0007c783          	lbu	a5,0(a5)
    80013046:	2785                	addiw	a5,a5,1
    80013048:	0ff7f713          	andi	a4,a5,255
    8001304c:	00011797          	auipc	a5,0x11
    80013050:	fb478793          	addi	a5,a5,-76 # 80024000 <subordinate>
    80013054:	00e78023          	sb	a4,0(a5)
}
    80013058:	0001                	nop
    8001305a:	7422                	ld	s0,40(sp)
    8001305c:	6145                	addi	sp,sp,48
    8001305e:	8082                	ret

0000000080013060 <pci_configure_device>:

static void pci_configure_device(volatile struct pci_ecam *device, uint8_t bus_no, uint8_t device_no)
{
    80013060:	7171                	addi	sp,sp,-176
    80013062:	f506                	sd	ra,168(sp)
    80013064:	f122                	sd	s0,160(sp)
    80013066:	1900                	addi	s0,sp,176
    80013068:	f8a43c23          	sd	a0,-104(s0)
    8001306c:	87ae                	mv	a5,a1
    8001306e:	8732                	mv	a4,a2
    80013070:	f8f40ba3          	sb	a5,-105(s0)
    80013074:	87ba                	mv	a5,a4
    80013076:	f8f40b23          	sb	a5,-106(s0)
    // vector_push(irq_pci_devices[vector_idx], (uint64_t)device);

    debugf("pci_configure_device: At bus %d, device %d = (%p)\n", bus_no, device_no, device);

    // Disable the device before modifying the BAR
    device->command_reg &= ~COMMAND_REG_MMIO; // Clear memory space bit
    8001307a:	f9843783          	ld	a5,-104(s0)
    8001307e:	0047d783          	lhu	a5,4(a5)
    80013082:	17c2                	slli	a5,a5,0x30
    80013084:	93c1                	srli	a5,a5,0x30
    80013086:	9bf5                	andi	a5,a5,-3
    80013088:	03079713          	slli	a4,a5,0x30
    8001308c:	9341                	srli	a4,a4,0x30
    8001308e:	f9843783          	ld	a5,-104(s0)
    80013092:	00e79223          	sh	a4,4(a5)
    device->command_reg &= ~COMMAND_REG_PIO; // Clear I/O space bit
    80013096:	f9843783          	ld	a5,-104(s0)
    8001309a:	0047d783          	lhu	a5,4(a5)
    8001309e:	17c2                	slli	a5,a5,0x30
    800130a0:	93c1                	srli	a5,a5,0x30
    800130a2:	9bf9                	andi	a5,a5,-2
    800130a4:	03079713          	slli	a4,a5,0x30
    800130a8:	9341                	srli	a4,a4,0x30
    800130aa:	f9843783          	ld	a5,-104(s0)
    800130ae:	00e79223          	sh	a4,4(a5)

    uint32_t addr = PCIE_MMIO_BASE + (bus_no << 20) + (device_no << 16);
    800130b2:	f9744783          	lbu	a5,-105(s0)
    800130b6:	2781                	sext.w	a5,a5
    800130b8:	0147979b          	slliw	a5,a5,0x14
    800130bc:	0007871b          	sext.w	a4,a5
    800130c0:	400007b7          	lui	a5,0x40000
    800130c4:	9fb9                	addw	a5,a5,a4
    800130c6:	0007871b          	sext.w	a4,a5
    800130ca:	f9644783          	lbu	a5,-106(s0)
    800130ce:	2781                	sext.w	a5,a5
    800130d0:	0107979b          	slliw	a5,a5,0x10
    800130d4:	2781                	sext.w	a5,a5
    800130d6:	9fb9                	addw	a5,a5,a4
    800130d8:	2781                	sext.w	a5,a5
    800130da:	fef42623          	sw	a5,-20(s0)
    PCIDevice pcidev;
    pcidev.ecam_header = device;
    800130de:	f9843783          	ld	a5,-104(s0)
    800130e2:	faf43023          	sd	a5,-96(s0)
    
    for (int i = 0; i < 6; i++) {
    800130e6:	fe042423          	sw	zero,-24(s0)
    800130ea:	aa5d                	j	800132a0 <pci_configure_device+0x240>
        device->type0.bar[i] = -1U;
    800130ec:	f9843703          	ld	a4,-104(s0)
    800130f0:	fe842783          	lw	a5,-24(s0)
    800130f4:	0791                	addi	a5,a5,4
    800130f6:	078a                	slli	a5,a5,0x2
    800130f8:	97ba                	add	a5,a5,a4
    800130fa:	577d                	li	a4,-1
    800130fc:	c398                	sw	a4,0(a5)
        pcidev.bars[i] = NULL;
    800130fe:	fe842783          	lw	a5,-24(s0)
    80013102:	078e                	slli	a5,a5,0x3
    80013104:	ff040713          	addi	a4,s0,-16
    80013108:	97ba                	add	a5,a5,a4
    8001310a:	fa07bc23          	sd	zero,-72(a5) # 3fffffb8 <i+0x3fffff98>
        
        // BAR not writable
        if (device->type0.bar[i] == 0) {
    8001310e:	f9843703          	ld	a4,-104(s0)
    80013112:	fe842783          	lw	a5,-24(s0)
    80013116:	0791                	addi	a5,a5,4
    80013118:	078a                	slli	a5,a5,0x2
    8001311a:	97ba                	add	a5,a5,a4
    8001311c:	439c                	lw	a5,0(a5)
    8001311e:	2781                	sext.w	a5,a5
    80013120:	16078a63          	beqz	a5,80013294 <pci_configure_device+0x234>
            continue;
        }

        uint64_t size;

        if ((device->type0.bar[i] & 0x6) == 0x4) {
    80013124:	f9843703          	ld	a4,-104(s0)
    80013128:	fe842783          	lw	a5,-24(s0)
    8001312c:	0791                	addi	a5,a5,4
    8001312e:	078a                	slli	a5,a5,0x2
    80013130:	97ba                	add	a5,a5,a4
    80013132:	439c                	lw	a5,0(a5)
    80013134:	2781                	sext.w	a5,a5
    80013136:	8b99                	andi	a5,a5,6
    80013138:	2781                	sext.w	a5,a5
    8001313a:	873e                	mv	a4,a5
    8001313c:	4791                	li	a5,4
    8001313e:	0ef71763          	bne	a4,a5,8001322c <pci_configure_device+0x1cc>
            debugf("  BAR[%d] is 64-bit\n", i);
            device->type0.bar[i+1] = -1U;
    80013142:	fe842783          	lw	a5,-24(s0)
    80013146:	2785                	addiw	a5,a5,1
    80013148:	2781                	sext.w	a5,a5
    8001314a:	f9843703          	ld	a4,-104(s0)
    8001314e:	0791                	addi	a5,a5,4
    80013150:	078a                	slli	a5,a5,0x2
    80013152:	97ba                	add	a5,a5,a4
    80013154:	577d                	li	a4,-1
    80013156:	c398                	sw	a4,0(a5)
            uint64_t bar_value = (uint64_t) device->type0.bar[i+1] << 32 | device->type0.bar[i];
    80013158:	fe842783          	lw	a5,-24(s0)
    8001315c:	2785                	addiw	a5,a5,1
    8001315e:	2781                	sext.w	a5,a5
    80013160:	f9843703          	ld	a4,-104(s0)
    80013164:	0791                	addi	a5,a5,4
    80013166:	078a                	slli	a5,a5,0x2
    80013168:	97ba                	add	a5,a5,a4
    8001316a:	439c                	lw	a5,0(a5)
    8001316c:	2781                	sext.w	a5,a5
    8001316e:	1782                	slli	a5,a5,0x20
    80013170:	9381                	srli	a5,a5,0x20
    80013172:	02079713          	slli	a4,a5,0x20
    80013176:	f9843683          	ld	a3,-104(s0)
    8001317a:	fe842783          	lw	a5,-24(s0)
    8001317e:	0791                	addi	a5,a5,4
    80013180:	078a                	slli	a5,a5,0x2
    80013182:	97b6                	add	a5,a5,a3
    80013184:	439c                	lw	a5,0(a5)
    80013186:	2781                	sext.w	a5,a5
    80013188:	1782                	slli	a5,a5,0x20
    8001318a:	9381                	srli	a5,a5,0x20
    8001318c:	8fd9                	or	a5,a5,a4
    8001318e:	fcf43c23          	sd	a5,-40(s0)
            size = ~(bar_value & ~0xF) + 1;
    80013192:	fd843783          	ld	a5,-40(s0)
    80013196:	9bc1                	andi	a5,a5,-16
    80013198:	40f007b3          	neg	a5,a5
    8001319c:	fef43023          	sd	a5,-32(s0)
            addr += size;
    800131a0:	fe043783          	ld	a5,-32(s0)
    800131a4:	2781                	sext.w	a5,a5
    800131a6:	fec42703          	lw	a4,-20(s0)
    800131aa:	9fb9                	addw	a5,a5,a4
    800131ac:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    800131b0:	f9843703          	ld	a4,-104(s0)
    800131b4:	fe842783          	lw	a5,-24(s0)
    800131b8:	0791                	addi	a5,a5,4
    800131ba:	078a                	slli	a5,a5,0x2
    800131bc:	97ba                	add	a5,a5,a4
    800131be:	fec42703          	lw	a4,-20(s0)
    800131c2:	c398                	sw	a4,0(a5)
            device->type0.bar[i+1] = 0;
    800131c4:	fe842783          	lw	a5,-24(s0)
    800131c8:	2785                	addiw	a5,a5,1
    800131ca:	2781                	sext.w	a5,a5
    800131cc:	f9843703          	ld	a4,-104(s0)
    800131d0:	0791                	addi	a5,a5,4
    800131d2:	078a                	slli	a5,a5,0x2
    800131d4:	97ba                	add	a5,a5,a4
    800131d6:	0007a023          	sw	zero,0(a5)
            pcidev.bars[i] = (volatile void*)(uint64_t)(device->type0.bar[i] & ~0xf);
    800131da:	f9843703          	ld	a4,-104(s0)
    800131de:	fe842783          	lw	a5,-24(s0)
    800131e2:	0791                	addi	a5,a5,4
    800131e4:	078a                	slli	a5,a5,0x2
    800131e6:	97ba                	add	a5,a5,a4
    800131e8:	439c                	lw	a5,0(a5)
    800131ea:	2781                	sext.w	a5,a5
    800131ec:	02079713          	slli	a4,a5,0x20
    800131f0:	9301                	srli	a4,a4,0x20
    800131f2:	4785                	li	a5,1
    800131f4:	1782                	slli	a5,a5,0x20
    800131f6:	17c1                	addi	a5,a5,-16
    800131f8:	8ff9                	and	a5,a5,a4
    800131fa:	873e                	mv	a4,a5
    800131fc:	fe842783          	lw	a5,-24(s0)
    80013200:	078e                	slli	a5,a5,0x3
    80013202:	ff040693          	addi	a3,s0,-16
    80013206:	97b6                	add	a5,a5,a3
    80013208:	fae7bc23          	sd	a4,-72(a5)
            pcidev.bars[i+1] = 0;
    8001320c:	fe842783          	lw	a5,-24(s0)
    80013210:	2785                	addiw	a5,a5,1
    80013212:	2781                	sext.w	a5,a5
    80013214:	078e                	slli	a5,a5,0x3
    80013216:	ff040713          	addi	a4,s0,-16
    8001321a:	97ba                	add	a5,a5,a4
    8001321c:	fa07bc23          	sd	zero,-72(a5)
            // pcidev.bars[i+1] = 0;
            debugf("    device->type0.bar[i] == 0x%08x\n", device->type0.bar[i]);
            debugf("    device->type0.bar[i+1] == 0x%08x\n", device->type0.bar[i+1]);
            debugf("    bar_value == 0x%016llx\n", bar_value);
            debugf("    size == %016llx\n", size);
            ++i;
    80013220:	fe842783          	lw	a5,-24(s0)
    80013224:	2785                	addiw	a5,a5,1
    80013226:	fef42423          	sw	a5,-24(s0)
    8001322a:	a0b5                	j	80013296 <pci_configure_device+0x236>
        } else {
            debugf("  BAR[%d] is 32-bit\n", i);
            size = ~(device->type0.bar[i] & ~0xF) + 1;
    8001322c:	f9843703          	ld	a4,-104(s0)
    80013230:	fe842783          	lw	a5,-24(s0)
    80013234:	0791                	addi	a5,a5,4
    80013236:	078a                	slli	a5,a5,0x2
    80013238:	97ba                	add	a5,a5,a4
    8001323a:	439c                	lw	a5,0(a5)
    8001323c:	2781                	sext.w	a5,a5
    8001323e:	9bc1                	andi	a5,a5,-16
    80013240:	2781                	sext.w	a5,a5
    80013242:	40f007bb          	negw	a5,a5
    80013246:	2781                	sext.w	a5,a5
    80013248:	1782                	slli	a5,a5,0x20
    8001324a:	9381                	srli	a5,a5,0x20
    8001324c:	fef43023          	sd	a5,-32(s0)
            debugf("    size == %016llx\n", size);
            addr += size;
    80013250:	fe043783          	ld	a5,-32(s0)
    80013254:	2781                	sext.w	a5,a5
    80013256:	fec42703          	lw	a4,-20(s0)
    8001325a:	9fb9                	addw	a5,a5,a4
    8001325c:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    80013260:	f9843703          	ld	a4,-104(s0)
    80013264:	fe842783          	lw	a5,-24(s0)
    80013268:	0791                	addi	a5,a5,4
    8001326a:	078a                	slli	a5,a5,0x2
    8001326c:	97ba                	add	a5,a5,a4
    8001326e:	fec42703          	lw	a4,-20(s0)
    80013272:	c398                	sw	a4,0(a5)
            pcidev.bars[i] = (volatile void*)(uint64_t)(addr & ~0xf);
    80013274:	fec46703          	lwu	a4,-20(s0)
    80013278:	4785                	li	a5,1
    8001327a:	1782                	slli	a5,a5,0x20
    8001327c:	17c1                	addi	a5,a5,-16
    8001327e:	8ff9                	and	a5,a5,a4
    80013280:	873e                	mv	a4,a5
    80013282:	fe842783          	lw	a5,-24(s0)
    80013286:	078e                	slli	a5,a5,0x3
    80013288:	ff040693          	addi	a3,s0,-16
    8001328c:	97b6                	add	a5,a5,a3
    8001328e:	fae7bc23          	sd	a4,-72(a5)
    80013292:	a011                	j	80013296 <pci_configure_device+0x236>
            continue;
    80013294:	0001                	nop
    for (int i = 0; i < 6; i++) {
    80013296:	fe842783          	lw	a5,-24(s0)
    8001329a:	2785                	addiw	a5,a5,1
    8001329c:	fef42423          	sw	a5,-24(s0)
    800132a0:	fe842783          	lw	a5,-24(s0)
    800132a4:	0007871b          	sext.w	a4,a5
    800132a8:	4795                	li	a5,5
    800132aa:	e4e7d1e3          	bge	a5,a4,800130ec <pci_configure_device+0x8c>
        }
    }

    // Re-enable the device after modifying the BAR
    device->command_reg |= COMMAND_REG_MMIO;
    800132ae:	f9843783          	ld	a5,-104(s0)
    800132b2:	0047d783          	lhu	a5,4(a5)
    800132b6:	17c2                	slli	a5,a5,0x30
    800132b8:	93c1                	srli	a5,a5,0x30
    800132ba:	0027e793          	ori	a5,a5,2
    800132be:	03079713          	slli	a4,a5,0x30
    800132c2:	9341                	srli	a4,a4,0x30
    800132c4:	f9843783          	ld	a5,-104(s0)
    800132c8:	00e79223          	sh	a4,4(a5)
    pcidev.ecam_header = device;
    800132cc:	f9843783          	ld	a5,-104(s0)
    800132d0:	faf43023          	sd	a5,-96(s0)
    pci_save_device(pcidev);
    800132d4:	fa043803          	ld	a6,-96(s0)
    800132d8:	fa843503          	ld	a0,-88(s0)
    800132dc:	fb043583          	ld	a1,-80(s0)
    800132e0:	fb843603          	ld	a2,-72(s0)
    800132e4:	fc043683          	ld	a3,-64(s0)
    800132e8:	fc843703          	ld	a4,-56(s0)
    800132ec:	fd043783          	ld	a5,-48(s0)
    800132f0:	f5043823          	sd	a6,-176(s0)
    800132f4:	f4a43c23          	sd	a0,-168(s0)
    800132f8:	f6b43023          	sd	a1,-160(s0)
    800132fc:	f6c43423          	sd	a2,-152(s0)
    80013300:	f6d43823          	sd	a3,-144(s0)
    80013304:	f6e43c23          	sd	a4,-136(s0)
    80013308:	f8f43023          	sd	a5,-128(s0)
    8001330c:	f5040793          	addi	a5,s0,-176
    80013310:	853e                	mv	a0,a5
    80013312:	f0cff0ef          	jal	ra,80012a1e <pci_save_device>
}
    80013316:	0001                	nop
    80013318:	70aa                	ld	ra,168(sp)
    8001331a:	740a                	ld	s0,160(sp)
    8001331c:	614d                	addi	sp,sp,176
    8001331e:	8082                	ret

0000000080013320 <print_vendor_specific_capabilities>:

void print_vendor_specific_capabilities(PCIDevice *pcidevice)
{
    80013320:	7179                	addi	sp,sp,-48
    80013322:	f406                	sd	ra,40(sp)
    80013324:	f022                	sd	s0,32(sp)
    80013326:	1800                	addi	s0,sp,48
    80013328:	fca43c23          	sd	a0,-40(s0)
    if (!pci_is_virtio_device(pcidevice)) return;
    8001332c:	fd843503          	ld	a0,-40(s0)
    80013330:	c02ff0ef          	jal	ra,80012732 <pci_is_virtio_device>
    80013334:	87aa                	mv	a5,a0
    80013336:	0017c793          	xori	a5,a5,1
    8001333a:	0ff7f793          	andi	a5,a5,255
    8001333e:	ef89                	bnez	a5,80013358 <print_vendor_specific_capabilities+0x38>
    volatile struct pci_ecam *header = pcidevice->ecam_header;
    80013340:	fd843783          	ld	a5,-40(s0)
    80013344:	639c                	ld	a5,0(a5)
    80013346:	fef43423          	sd	a5,-24(s0)

    uint8_t cap_pointer = header->type0.capes_pointer;
    8001334a:	fe843783          	ld	a5,-24(s0)
    8001334e:	0347c783          	lbu	a5,52(a5)
    80013352:	fef403a3          	sb	a5,-25(s0)
    80013356:	a011                	j	8001335a <print_vendor_specific_capabilities+0x3a>
    if (!pci_is_virtio_device(pcidevice)) return;
    80013358:	0001                	nop
        }

        cap_pointer = cape->next;  
    }
    */
}
    8001335a:	70a2                	ld	ra,40(sp)
    8001335c:	7402                	ld	s0,32(sp)
    8001335e:	6145                	addi	sp,sp,48
    80013360:	8082                	ret

0000000080013362 <pci_init>:

void pci_init(void)
{
    80013362:	1101                	addi	sp,sp,-32
    80013364:	ec06                	sd	ra,24(sp)
    80013366:	e822                	sd	s0,16(sp)
    80013368:	1000                	addi	s0,sp,32
    all_pci_devices = vector_new();
    8001336a:	2130a0ef          	jal	ra,8001dd7c <vector_new>
    8001336e:	872a                	mv	a4,a0
    80013370:	0000d797          	auipc	a5,0xd
    80013374:	cc878793          	addi	a5,a5,-824 # 80020038 <all_pci_devices>
    80013378:	e398                	sd	a4,0(a5)
    for (int i=0; i<4; i++) {
    8001337a:	fe042623          	sw	zero,-20(s0)
    8001337e:	a015                	j	800133a2 <pci_init+0x40>
        irq_pci_devices[i] = vector_new();
    80013380:	1fd0a0ef          	jal	ra,8001dd7c <vector_new>
    80013384:	86aa                	mv	a3,a0
    80013386:	0000d717          	auipc	a4,0xd
    8001338a:	cba70713          	addi	a4,a4,-838 # 80020040 <irq_pci_devices>
    8001338e:	fec42783          	lw	a5,-20(s0)
    80013392:	078e                	slli	a5,a5,0x3
    80013394:	97ba                	add	a5,a5,a4
    80013396:	e394                	sd	a3,0(a5)
    for (int i=0; i<4; i++) {
    80013398:	fec42783          	lw	a5,-20(s0)
    8001339c:	2785                	addiw	a5,a5,1
    8001339e:	fef42623          	sw	a5,-20(s0)
    800133a2:	fec42783          	lw	a5,-20(s0)
    800133a6:	0007871b          	sext.w	a4,a5
    800133aa:	478d                	li	a5,3
    800133ac:	fce7dae3          	bge	a5,a4,80013380 <pci_init+0x1e>
    }

    pci_enumerate_bus();
    800133b0:	a71ff0ef          	jal	ra,80012e20 <pci_enumerate_bus>
    debugf("PCI devices: %d\n", pci_count_saved_devices());
    debugf("PCI devices sharing IRQ 32: %d\n", pci_count_irq_listeners(32));
    debugf("PCI devices sharing IRQ 33: %d\n", pci_count_irq_listeners(33));
    debugf("PCI devices sharing IRQ 34: %d\n", pci_count_irq_listeners(34));
    debugf("PCI devices sharing IRQ 35: %d\n", pci_count_irq_listeners(35));
}
    800133b4:	0001                	nop
    800133b6:	60e2                	ld	ra,24(sp)
    800133b8:	6442                	ld	s0,16(sp)
    800133ba:	6105                	addi	sp,sp,32
    800133bc:	8082                	ret

00000000800133be <pci_dispatch_irq>:
/**
 * @brief Dispatch an interrupt to the PCI subsystem
 * @param irq - the IRQ number that interrupted
 */
void pci_dispatch_irq(int irq)
{
    800133be:	7129                	addi	sp,sp,-320
    800133c0:	fe06                	sd	ra,312(sp)
    800133c2:	fa22                	sd	s0,304(sp)
    800133c4:	0280                	addi	s0,sp,320
    800133c6:	87aa                	mv	a5,a0
    800133c8:	ecf42623          	sw	a5,-308(s0)
    // device changed its configuration, and that was the reason
    // the interrupt occurred.

    // IRQ#=32+(bus+slot)mod4
    // uint32_t vector_idx = irq - 32;
    PCIDevice *pcidevice = pci_find_device_by_irq(irq);
    800133cc:	ecc42783          	lw	a5,-308(s0)
    800133d0:	0ff7f793          	andi	a5,a5,255
    800133d4:	853e                	mv	a0,a5
    800133d6:	f20ff0ef          	jal	ra,80012af6 <pci_find_device_by_irq>
    800133da:	fea43423          	sd	a0,-24(s0)
    if (pcidevice == NULL) {
    800133de:	fe843783          	ld	a5,-24(s0)
    800133e2:	eb99                	bnez	a5,800133f8 <pci_dispatch_irq+0x3a>
        warnf("No PCI device found with IRQ %d\n", irq);
    800133e4:	ecc42783          	lw	a5,-308(s0)
    800133e8:	85be                	mv	a1,a5
    800133ea:	0000e517          	auipc	a0,0xe
    800133ee:	13e50513          	addi	a0,a0,318 # 80021528 <pow10.0+0x2f8>
    800133f2:	669050ef          	jal	ra,8001925a <warnf>
        return;
    800133f6:	a0d5                	j	800134da <pci_dispatch_irq+0x11c>
    }
    debugf("PCI device with IRQ %d: 0x%04x\n", irq, pcidevice->ecam_header->device_id);
    // Is this a virtio device?
    if (pci_is_virtio_device(pcidevice)) { 
    800133f8:	fe843503          	ld	a0,-24(s0)
    800133fc:	b36ff0ef          	jal	ra,80012732 <pci_is_virtio_device>
    80013400:	87aa                	mv	a5,a0
    80013402:	0c078c63          	beqz	a5,800134da <pci_dispatch_irq+0x11c>
        // Access through ecam_header
        VirtioDevice *virtdevice = virtio_from_pci_device(pcidevice);
    80013406:	fe843503          	ld	a0,-24(s0)
    8001340a:	58b060ef          	jal	ra,8001a194 <virtio_from_pci_device>
    8001340e:	fea43023          	sd	a0,-32(s0)
        debugf("Virtio device! %p\n", virtdevice->pcidev->ecam_header);

        if (virtio_is_rng_device(virtdevice)) {
    80013412:	fe043503          	ld	a0,-32(s0)
    80013416:	319060ef          	jal	ra,80019f2e <virtio_is_rng_device>
    8001341a:	87aa                	mv	a5,a0
    8001341c:	cb8d                	beqz	a5,8001344e <pci_dispatch_irq+0x90>
            debugf("RNG sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 1, true);
    8001341e:	ed840793          	addi	a5,s0,-296
    80013422:	4705                	li	a4,1
    80013424:	4685                	li	a3,1
    80013426:	863e                	mv	a2,a5
    80013428:	4581                	li	a1,0
    8001342a:	fe043503          	ld	a0,-32(s0)
    8001342e:	63a070ef          	jal	ra,8001aa68 <virtio_receive_descriptor_chain>
    80013432:	87aa                	mv	a5,a0
    80013434:	fcf41d23          	sh	a5,-38(s0)

            virtio_handle_interrupt(virtdevice, descriptors, received);
    80013438:	fda45703          	lhu	a4,-38(s0)
    8001343c:	ed840793          	addi	a5,s0,-296
    80013440:	863a                	mv	a2,a4
    80013442:	85be                	mv	a1,a5
    80013444:	fe043503          	ld	a0,-32(s0)
    80013448:	0b5060ef          	jal	ra,80019cfc <virtio_handle_interrupt>
    8001344c:	a079                	j	800134da <pci_dispatch_irq+0x11c>
            debugf("Received %d descriptors\n", received);
        }

        else if (virtio_is_block_device(virtdevice)) {
    8001344e:	fe043503          	ld	a0,-32(s0)
    80013452:	313060ef          	jal	ra,80019f64 <virtio_is_block_device>
    80013456:	87aa                	mv	a5,a0
    80013458:	cb8d                	beqz	a5,8001348a <pci_dispatch_irq+0xcc>
            debugf("Block device sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 3, true);
    8001345a:	ed840793          	addi	a5,s0,-296
    8001345e:	4705                	li	a4,1
    80013460:	468d                	li	a3,3
    80013462:	863e                	mv	a2,a5
    80013464:	4581                	li	a1,0
    80013466:	fe043503          	ld	a0,-32(s0)
    8001346a:	5fe070ef          	jal	ra,8001aa68 <virtio_receive_descriptor_chain>
    8001346e:	87aa                	mv	a5,a0
    80013470:	fcf41e23          	sh	a5,-36(s0)
            virtio_handle_interrupt(virtdevice, descriptors, received);
    80013474:	fdc45703          	lhu	a4,-36(s0)
    80013478:	ed840793          	addi	a5,s0,-296
    8001347c:	863a                	mv	a2,a4
    8001347e:	85be                	mv	a1,a5
    80013480:	fe043503          	ld	a0,-32(s0)
    80013484:	079060ef          	jal	ra,80019cfc <virtio_handle_interrupt>
    80013488:	a889                	j	800134da <pci_dispatch_irq+0x11c>
            debugf("Received %d descriptors\n", received);
        }

        else if (virtio_is_input_device(virtdevice)) {
    8001348a:	fe043503          	ld	a0,-32(s0)
    8001348e:	30d060ef          	jal	ra,80019f9a <virtio_is_input_device>
    80013492:	87aa                	mv	a5,a0
    80013494:	c791                	beqz	a5,800134a0 <pci_dispatch_irq+0xe2>
            debugf("input device sent interrupt!\n");
            input_device_interrupt_handler(virtdevice);
    80013496:	fe043503          	ld	a0,-32(s0)
    8001349a:	286080ef          	jal	ra,8001b720 <input_device_interrupt_handler>
    8001349e:	a835                	j	800134da <pci_dispatch_irq+0x11c>
        //     VirtioDescriptor descriptors[16];
        //     uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 16, true);
        //     uint16_t received2 = virtio_receive_descriptor_chain(virtdevice, 1, descriptors, 16, true);
        //     debugf("Received %d descriptors\n", received);
        // }
        else if (virtio_is_gpu_device(virtdevice)) {
    800134a0:	fe043503          	ld	a0,-32(s0)
    800134a4:	32d060ef          	jal	ra,80019fd0 <virtio_is_gpu_device>
    800134a8:	87aa                	mv	a5,a0
    800134aa:	cb85                	beqz	a5,800134da <pci_dispatch_irq+0x11c>
            debugf("GPU device sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 3, true);
    800134ac:	ed840793          	addi	a5,s0,-296
    800134b0:	4705                	li	a4,1
    800134b2:	468d                	li	a3,3
    800134b4:	863e                	mv	a2,a5
    800134b6:	4581                	li	a1,0
    800134b8:	fe043503          	ld	a0,-32(s0)
    800134bc:	5ac070ef          	jal	ra,8001aa68 <virtio_receive_descriptor_chain>
    800134c0:	87aa                	mv	a5,a0
    800134c2:	fcf41f23          	sh	a5,-34(s0)
            debugf("Received %d descriptors\n", received);
            virtio_handle_interrupt(virtdevice, descriptors, received);
    800134c6:	fde45703          	lhu	a4,-34(s0)
    800134ca:	ed840793          	addi	a5,s0,-296
    800134ce:	863a                	mv	a2,a4
    800134d0:	85be                	mv	a1,a5
    800134d2:	fe043503          	ld	a0,-32(s0)
    800134d6:	027060ef          	jal	ra,80019cfc <virtio_handle_interrupt>
            
        }
    }

    debugf("Leaving dispatch IRQ\n");
}
    800134da:	70f2                	ld	ra,312(sp)
    800134dc:	7452                	ld	s0,304(sp)
    800134de:	6131                	addi	sp,sp,320
    800134e0:	8082                	ret

00000000800134e2 <insert_block>:
 * into free list, sorted by addr.
 * If disabled, add block has new head of
 * the free list.
 */
static void insert_block(Block *block)
{
    800134e2:	7179                	addi	sp,sp,-48
    800134e4:	f422                	sd	s0,40(sp)
    800134e6:	1800                	addi	s0,sp,48
    800134e8:	fca43c23          	sd	a0,-40(s0)
    Block *ptr  = heap->free;
    800134ec:	0000d797          	auipc	a5,0xd
    800134f0:	b7c78793          	addi	a5,a5,-1156 # 80020068 <heap>
    800134f4:	639c                	ld	a5,0(a5)
    800134f6:	639c                	ld	a5,0(a5)
    800134f8:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    800134fc:	fe043023          	sd	zero,-32(s0)
    while (ptr != NULL) {
    80013500:	a01d                	j	80013526 <insert_block+0x44>
        if ((size_t)block->addr <= (size_t)ptr->addr) {
    80013502:	fd843783          	ld	a5,-40(s0)
    80013506:	639c                	ld	a5,0(a5)
    80013508:	873e                	mv	a4,a5
    8001350a:	fe843783          	ld	a5,-24(s0)
    8001350e:	639c                	ld	a5,0(a5)
    80013510:	00e7ff63          	bgeu	a5,a4,8001352e <insert_block+0x4c>
            break;
        }
        prev = ptr;
    80013514:	fe843783          	ld	a5,-24(s0)
    80013518:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    8001351c:	fe843783          	ld	a5,-24(s0)
    80013520:	679c                	ld	a5,8(a5)
    80013522:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80013526:	fe843783          	ld	a5,-24(s0)
    8001352a:	ffe1                	bnez	a5,80013502 <insert_block+0x20>
    8001352c:	a011                	j	80013530 <insert_block+0x4e>
            break;
    8001352e:	0001                	nop
    }
    if (prev != NULL) {
    80013530:	fe043783          	ld	a5,-32(s0)
    80013534:	c799                	beqz	a5,80013542 <insert_block+0x60>
        prev->next = block;
    80013536:	fe043783          	ld	a5,-32(s0)
    8001353a:	fd843703          	ld	a4,-40(s0)
    8001353e:	e798                	sd	a4,8(a5)
    80013540:	a809                	j	80013552 <insert_block+0x70>
    }
    else {
        heap->free = block;
    80013542:	0000d797          	auipc	a5,0xd
    80013546:	b2678793          	addi	a5,a5,-1242 # 80020068 <heap>
    8001354a:	639c                	ld	a5,0(a5)
    8001354c:	fd843703          	ld	a4,-40(s0)
    80013550:	e398                	sd	a4,0(a5)
    }
    block->next = ptr;
    80013552:	fd843783          	ld	a5,-40(s0)
    80013556:	fe843703          	ld	a4,-24(s0)
    8001355a:	e798                	sd	a4,8(a5)
}
    8001355c:	0001                	nop
    8001355e:	7422                	ld	s0,40(sp)
    80013560:	6145                	addi	sp,sp,48
    80013562:	8082                	ret

0000000080013564 <release_blocks>:

#ifndef TA_DISABLE_COMPACT
static void release_blocks(Block *scan, Block *to)
{
    80013564:	7179                	addi	sp,sp,-48
    80013566:	f422                	sd	s0,40(sp)
    80013568:	1800                	addi	s0,sp,48
    8001356a:	fca43c23          	sd	a0,-40(s0)
    8001356e:	fcb43823          	sd	a1,-48(s0)
    Block *scan_next;
    while (scan != to) {
    80013572:	a099                	j	800135b8 <release_blocks+0x54>
        scan_next   = scan->next;
    80013574:	fd843783          	ld	a5,-40(s0)
    80013578:	679c                	ld	a5,8(a5)
    8001357a:	fef43423          	sd	a5,-24(s0)
        scan->next  = heap->fresh;
    8001357e:	0000d797          	auipc	a5,0xd
    80013582:	aea78793          	addi	a5,a5,-1302 # 80020068 <heap>
    80013586:	639c                	ld	a5,0(a5)
    80013588:	6b98                	ld	a4,16(a5)
    8001358a:	fd843783          	ld	a5,-40(s0)
    8001358e:	e798                	sd	a4,8(a5)
        heap->fresh = scan;
    80013590:	0000d797          	auipc	a5,0xd
    80013594:	ad878793          	addi	a5,a5,-1320 # 80020068 <heap>
    80013598:	639c                	ld	a5,0(a5)
    8001359a:	fd843703          	ld	a4,-40(s0)
    8001359e:	eb98                	sd	a4,16(a5)
        scan->addr  = 0;
    800135a0:	fd843783          	ld	a5,-40(s0)
    800135a4:	0007b023          	sd	zero,0(a5)
        scan->size  = 0;
    800135a8:	fd843783          	ld	a5,-40(s0)
    800135ac:	0007b823          	sd	zero,16(a5)
        scan        = scan_next;
    800135b0:	fe843783          	ld	a5,-24(s0)
    800135b4:	fcf43c23          	sd	a5,-40(s0)
    while (scan != to) {
    800135b8:	fd843703          	ld	a4,-40(s0)
    800135bc:	fd043783          	ld	a5,-48(s0)
    800135c0:	faf71ae3          	bne	a4,a5,80013574 <release_blocks+0x10>
    }
}
    800135c4:	0001                	nop
    800135c6:	0001                	nop
    800135c8:	7422                	ld	s0,40(sp)
    800135ca:	6145                	addi	sp,sp,48
    800135cc:	8082                	ret

00000000800135ce <compact>:

static void compact()
{
    800135ce:	7139                	addi	sp,sp,-64
    800135d0:	fc06                	sd	ra,56(sp)
    800135d2:	f822                	sd	s0,48(sp)
    800135d4:	0080                	addi	s0,sp,64
    Block *ptr = heap->free;
    800135d6:	0000d797          	auipc	a5,0xd
    800135da:	a9278793          	addi	a5,a5,-1390 # 80020068 <heap>
    800135de:	639c                	ld	a5,0(a5)
    800135e0:	639c                	ld	a5,0(a5)
    800135e2:	fef43423          	sd	a5,-24(s0)
    Block *prev;
    Block *scan;
    while (ptr != NULL) {
    800135e6:	a075                	j	80013692 <compact+0xc4>
        prev = ptr;
    800135e8:	fe843783          	ld	a5,-24(s0)
    800135ec:	fef43023          	sd	a5,-32(s0)
        scan = ptr->next;
    800135f0:	fe843783          	ld	a5,-24(s0)
    800135f4:	679c                	ld	a5,8(a5)
    800135f6:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    800135fa:	a811                	j	8001360e <compact+0x40>
            prev = scan;
    800135fc:	fd843783          	ld	a5,-40(s0)
    80013600:	fef43023          	sd	a5,-32(s0)
            scan = scan->next;
    80013604:	fd843783          	ld	a5,-40(s0)
    80013608:	679c                	ld	a5,8(a5)
    8001360a:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    8001360e:	fd843783          	ld	a5,-40(s0)
    80013612:	cf91                	beqz	a5,8001362e <compact+0x60>
    80013614:	fe043783          	ld	a5,-32(s0)
    80013618:	639c                	ld	a5,0(a5)
    8001361a:	873e                	mv	a4,a5
    8001361c:	fe043783          	ld	a5,-32(s0)
    80013620:	6b9c                	ld	a5,16(a5)
    80013622:	97ba                	add	a5,a5,a4
    80013624:	fd843703          	ld	a4,-40(s0)
    80013628:	6318                	ld	a4,0(a4)
    8001362a:	fce789e3          	beq	a5,a4,800135fc <compact+0x2e>
        }
        if (prev != ptr) {
    8001362e:	fe043703          	ld	a4,-32(s0)
    80013632:	fe843783          	ld	a5,-24(s0)
    80013636:	04f70963          	beq	a4,a5,80013688 <compact+0xba>
            size_t new_size = (size_t)prev->addr - (size_t)ptr->addr + prev->size;
    8001363a:	fe043783          	ld	a5,-32(s0)
    8001363e:	639c                	ld	a5,0(a5)
    80013640:	873e                	mv	a4,a5
    80013642:	fe843783          	ld	a5,-24(s0)
    80013646:	639c                	ld	a5,0(a5)
    80013648:	8f1d                	sub	a4,a4,a5
    8001364a:	fe043783          	ld	a5,-32(s0)
    8001364e:	6b9c                	ld	a5,16(a5)
    80013650:	97ba                	add	a5,a5,a4
    80013652:	fcf43823          	sd	a5,-48(s0)
            ptr->size       = new_size;
    80013656:	fe843783          	ld	a5,-24(s0)
    8001365a:	fd043703          	ld	a4,-48(s0)
    8001365e:	eb98                	sd	a4,16(a5)
            Block *next     = prev->next;
    80013660:	fe043783          	ld	a5,-32(s0)
    80013664:	679c                	ld	a5,8(a5)
    80013666:	fcf43423          	sd	a5,-56(s0)
            // make merged blocks available
            release_blocks(ptr->next, prev->next);
    8001366a:	fe843783          	ld	a5,-24(s0)
    8001366e:	6798                	ld	a4,8(a5)
    80013670:	fe043783          	ld	a5,-32(s0)
    80013674:	679c                	ld	a5,8(a5)
    80013676:	85be                	mv	a1,a5
    80013678:	853a                	mv	a0,a4
    8001367a:	eebff0ef          	jal	ra,80013564 <release_blocks>
            // relink
            ptr->next = next;
    8001367e:	fe843783          	ld	a5,-24(s0)
    80013682:	fc843703          	ld	a4,-56(s0)
    80013686:	e798                	sd	a4,8(a5)
        }
        ptr = ptr->next;
    80013688:	fe843783          	ld	a5,-24(s0)
    8001368c:	679c                	ld	a5,8(a5)
    8001368e:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80013692:	fe843783          	ld	a5,-24(s0)
    80013696:	fba9                	bnez	a5,800135e8 <compact+0x1a>
    }
}
    80013698:	0001                	nop
    8001369a:	0001                	nop
    8001369c:	70e2                	ld	ra,56(sp)
    8001369e:	7442                	ld	s0,48(sp)
    800136a0:	6121                	addi	sp,sp,64
    800136a2:	8082                	ret

00000000800136a4 <init>:
#endif

static bool init(const void *base, const void *limit, const size_t heap_blocks,
                 const size_t split_thresh, const size_t alignment)
{
    800136a4:	715d                	addi	sp,sp,-80
    800136a6:	e4a2                	sd	s0,72(sp)
    800136a8:	0880                	addi	s0,sp,80
    800136aa:	fca43c23          	sd	a0,-40(s0)
    800136ae:	fcb43823          	sd	a1,-48(s0)
    800136b2:	fcc43423          	sd	a2,-56(s0)
    800136b6:	fcd43023          	sd	a3,-64(s0)
    800136ba:	fae43c23          	sd	a4,-72(s0)
    heap              = (Heap *)base;
    800136be:	0000d797          	auipc	a5,0xd
    800136c2:	9aa78793          	addi	a5,a5,-1622 # 80020068 <heap>
    800136c6:	fd843703          	ld	a4,-40(s0)
    800136ca:	e398                	sd	a4,0(a5)
    heap_limit        = limit;
    800136cc:	0000d797          	auipc	a5,0xd
    800136d0:	9a478793          	addi	a5,a5,-1628 # 80020070 <heap_limit>
    800136d4:	fd043703          	ld	a4,-48(s0)
    800136d8:	e398                	sd	a4,0(a5)
    heap_split_thresh = split_thresh;
    800136da:	0000d797          	auipc	a5,0xd
    800136de:	99e78793          	addi	a5,a5,-1634 # 80020078 <heap_split_thresh>
    800136e2:	fc043703          	ld	a4,-64(s0)
    800136e6:	e398                	sd	a4,0(a5)
    heap_alignment    = alignment;
    800136e8:	0000d797          	auipc	a5,0xd
    800136ec:	99878793          	addi	a5,a5,-1640 # 80020080 <heap_alignment>
    800136f0:	fb843703          	ld	a4,-72(s0)
    800136f4:	e398                	sd	a4,0(a5)
    heap_max_blocks   = heap_blocks;
    800136f6:	0000d797          	auipc	a5,0xd
    800136fa:	99278793          	addi	a5,a5,-1646 # 80020088 <heap_max_blocks>
    800136fe:	fc843703          	ld	a4,-56(s0)
    80013702:	e398                	sd	a4,0(a5)

    heap->free        = NULL;
    80013704:	0000d797          	auipc	a5,0xd
    80013708:	96478793          	addi	a5,a5,-1692 # 80020068 <heap>
    8001370c:	639c                	ld	a5,0(a5)
    8001370e:	0007b023          	sd	zero,0(a5)
    heap->used        = NULL;
    80013712:	0000d797          	auipc	a5,0xd
    80013716:	95678793          	addi	a5,a5,-1706 # 80020068 <heap>
    8001371a:	639c                	ld	a5,0(a5)
    8001371c:	0007b423          	sd	zero,8(a5)
    heap->fresh       = (Block *)(heap + 1);
    80013720:	0000d797          	auipc	a5,0xd
    80013724:	94878793          	addi	a5,a5,-1720 # 80020068 <heap>
    80013728:	6398                	ld	a4,0(a5)
    8001372a:	0000d797          	auipc	a5,0xd
    8001372e:	93e78793          	addi	a5,a5,-1730 # 80020068 <heap>
    80013732:	639c                	ld	a5,0(a5)
    80013734:	02070713          	addi	a4,a4,32
    80013738:	eb98                	sd	a4,16(a5)
    heap->top         = (size_t)(heap->fresh + heap_blocks);
    8001373a:	0000d797          	auipc	a5,0xd
    8001373e:	92e78793          	addi	a5,a5,-1746 # 80020068 <heap>
    80013742:	639c                	ld	a5,0(a5)
    80013744:	6b94                	ld	a3,16(a5)
    80013746:	fc843703          	ld	a4,-56(s0)
    8001374a:	87ba                	mv	a5,a4
    8001374c:	0786                	slli	a5,a5,0x1
    8001374e:	97ba                	add	a5,a5,a4
    80013750:	078e                	slli	a5,a5,0x3
    80013752:	00f68733          	add	a4,a3,a5
    80013756:	0000d797          	auipc	a5,0xd
    8001375a:	91278793          	addi	a5,a5,-1774 # 80020068 <heap>
    8001375e:	639c                	ld	a5,0(a5)
    80013760:	ef98                	sd	a4,24(a5)

    Block *block      = heap->fresh;
    80013762:	0000d797          	auipc	a5,0xd
    80013766:	90678793          	addi	a5,a5,-1786 # 80020068 <heap>
    8001376a:	639c                	ld	a5,0(a5)
    8001376c:	6b9c                	ld	a5,16(a5)
    8001376e:	fef43423          	sd	a5,-24(s0)
    size_t i          = heap_max_blocks - 1;
    80013772:	0000d797          	auipc	a5,0xd
    80013776:	91678793          	addi	a5,a5,-1770 # 80020088 <heap_max_blocks>
    8001377a:	639c                	ld	a5,0(a5)
    8001377c:	17fd                	addi	a5,a5,-1
    8001377e:	fef43023          	sd	a5,-32(s0)
    while (i--) {
    80013782:	a829                	j	8001379c <init+0xf8>
        block->next = block + 1;
    80013784:	fe843783          	ld	a5,-24(s0)
    80013788:	01878713          	addi	a4,a5,24
    8001378c:	fe843783          	ld	a5,-24(s0)
    80013790:	e798                	sd	a4,8(a5)
        block++;
    80013792:	fe843783          	ld	a5,-24(s0)
    80013796:	07e1                	addi	a5,a5,24
    80013798:	fef43423          	sd	a5,-24(s0)
    while (i--) {
    8001379c:	fe043783          	ld	a5,-32(s0)
    800137a0:	fff78713          	addi	a4,a5,-1
    800137a4:	fee43023          	sd	a4,-32(s0)
    800137a8:	fff1                	bnez	a5,80013784 <init+0xe0>
    }
    block->next = NULL;
    800137aa:	fe843783          	ld	a5,-24(s0)
    800137ae:	0007b423          	sd	zero,8(a5)
    return true;
    800137b2:	4785                	li	a5,1
}
    800137b4:	853e                	mv	a0,a5
    800137b6:	6426                	ld	s0,72(sp)
    800137b8:	6161                	addi	sp,sp,80
    800137ba:	8082                	ret

00000000800137bc <free>:

static bool free(const void *free)
{
    800137bc:	7179                	addi	sp,sp,-48
    800137be:	f406                	sd	ra,40(sp)
    800137c0:	f022                	sd	s0,32(sp)
    800137c2:	1800                	addi	s0,sp,48
    800137c4:	fca43c23          	sd	a0,-40(s0)
    Block *block = heap->used;
    800137c8:	0000d797          	auipc	a5,0xd
    800137cc:	8a078793          	addi	a5,a5,-1888 # 80020068 <heap>
    800137d0:	639c                	ld	a5,0(a5)
    800137d2:	679c                	ld	a5,8(a5)
    800137d4:	fef43423          	sd	a5,-24(s0)
    Block *prev  = NULL;
    800137d8:	fe043023          	sd	zero,-32(s0)
    while (block != NULL) {
    800137dc:	a8a1                	j	80013834 <free+0x78>
        if (free == block->addr) {
    800137de:	fe843783          	ld	a5,-24(s0)
    800137e2:	639c                	ld	a5,0(a5)
    800137e4:	fd843703          	ld	a4,-40(s0)
    800137e8:	02f71d63          	bne	a4,a5,80013822 <free+0x66>
            if (prev) {
    800137ec:	fe043783          	ld	a5,-32(s0)
    800137f0:	cb81                	beqz	a5,80013800 <free+0x44>
                prev->next = block->next;
    800137f2:	fe843783          	ld	a5,-24(s0)
    800137f6:	6798                	ld	a4,8(a5)
    800137f8:	fe043783          	ld	a5,-32(s0)
    800137fc:	e798                	sd	a4,8(a5)
    800137fe:	a811                	j	80013812 <free+0x56>
            }
            else {
                heap->used = block->next;
    80013800:	0000d797          	auipc	a5,0xd
    80013804:	86878793          	addi	a5,a5,-1944 # 80020068 <heap>
    80013808:	639c                	ld	a5,0(a5)
    8001380a:	fe843703          	ld	a4,-24(s0)
    8001380e:	6718                	ld	a4,8(a4)
    80013810:	e798                	sd	a4,8(a5)
            }
            insert_block(block);
    80013812:	fe843503          	ld	a0,-24(s0)
    80013816:	ccdff0ef          	jal	ra,800134e2 <insert_block>
            compact();
    8001381a:	db5ff0ef          	jal	ra,800135ce <compact>
            return true;
    8001381e:	4785                	li	a5,1
    80013820:	a831                	j	8001383c <free+0x80>
        }
        prev  = block;
    80013822:	fe843783          	ld	a5,-24(s0)
    80013826:	fef43023          	sd	a5,-32(s0)
        block = block->next;
    8001382a:	fe843783          	ld	a5,-24(s0)
    8001382e:	679c                	ld	a5,8(a5)
    80013830:	fef43423          	sd	a5,-24(s0)
    while (block != NULL) {
    80013834:	fe843783          	ld	a5,-24(s0)
    80013838:	f3dd                	bnez	a5,800137de <free+0x22>
    }
    return false;
    8001383a:	4781                	li	a5,0
}
    8001383c:	853e                	mv	a0,a5
    8001383e:	70a2                	ld	ra,40(sp)
    80013840:	7402                	ld	s0,32(sp)
    80013842:	6145                	addi	sp,sp,48
    80013844:	8082                	ret

0000000080013846 <alloc_block>:

static Block *alloc_block(size_t num)
{
    80013846:	711d                	addi	sp,sp,-96
    80013848:	ec86                	sd	ra,88(sp)
    8001384a:	e8a2                	sd	s0,80(sp)
    8001384c:	1080                	addi	s0,sp,96
    8001384e:	faa43423          	sd	a0,-88(s0)
    Block *ptr  = heap->free;
    80013852:	0000d797          	auipc	a5,0xd
    80013856:	81678793          	addi	a5,a5,-2026 # 80020068 <heap>
    8001385a:	639c                	ld	a5,0(a5)
    8001385c:	639c                	ld	a5,0(a5)
    8001385e:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    80013862:	fe043023          	sd	zero,-32(s0)
    size_t top  = heap->top;
    80013866:	0000d797          	auipc	a5,0xd
    8001386a:	80278793          	addi	a5,a5,-2046 # 80020068 <heap>
    8001386e:	639c                	ld	a5,0(a5)
    80013870:	6f9c                	ld	a5,24(a5)
    80013872:	fcf43c23          	sd	a5,-40(s0)
    num         = (num + heap_alignment - 1) & -heap_alignment;
    80013876:	0000d797          	auipc	a5,0xd
    8001387a:	80a78793          	addi	a5,a5,-2038 # 80020080 <heap_alignment>
    8001387e:	6398                	ld	a4,0(a5)
    80013880:	fa843783          	ld	a5,-88(s0)
    80013884:	97ba                	add	a5,a5,a4
    80013886:	fff78713          	addi	a4,a5,-1
    8001388a:	0000c797          	auipc	a5,0xc
    8001388e:	7f678793          	addi	a5,a5,2038 # 80020080 <heap_alignment>
    80013892:	639c                	ld	a5,0(a5)
    80013894:	40f007b3          	neg	a5,a5
    80013898:	8ff9                	and	a5,a5,a4
    8001389a:	faf43423          	sd	a5,-88(s0)
    while (ptr != NULL) {
    8001389e:	a2bd                	j	80013a0c <alloc_block+0x1c6>
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    800138a0:	fe843783          	ld	a5,-24(s0)
    800138a4:	639c                	ld	a5,0(a5)
    800138a6:	873e                	mv	a4,a5
    800138a8:	fe843783          	ld	a5,-24(s0)
    800138ac:	6b9c                	ld	a5,16(a5)
    800138ae:	97ba                	add	a5,a5,a4
    800138b0:	fd843703          	ld	a4,-40(s0)
    800138b4:	02e7e263          	bltu	a5,a4,800138d8 <alloc_block+0x92>
                           ((size_t)ptr->addr + num <= (size_t)heap_limit);
    800138b8:	fe843783          	ld	a5,-24(s0)
    800138bc:	639c                	ld	a5,0(a5)
    800138be:	873e                	mv	a4,a5
    800138c0:	fa843783          	ld	a5,-88(s0)
    800138c4:	97ba                	add	a5,a5,a4
    800138c6:	0000c717          	auipc	a4,0xc
    800138ca:	7aa70713          	addi	a4,a4,1962 # 80020070 <heap_limit>
    800138ce:	6318                	ld	a4,0(a4)
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    800138d0:	00f76463          	bltu	a4,a5,800138d8 <alloc_block+0x92>
    800138d4:	4785                	li	a5,1
    800138d6:	a011                	j	800138da <alloc_block+0x94>
    800138d8:	4781                	li	a5,0
    800138da:	fcf42623          	sw	a5,-52(s0)
        if (is_top || ptr->size >= num) {
    800138de:	fcc42783          	lw	a5,-52(s0)
    800138e2:	2781                	sext.w	a5,a5
    800138e4:	eb81                	bnez	a5,800138f4 <alloc_block+0xae>
    800138e6:	fe843783          	ld	a5,-24(s0)
    800138ea:	6b9c                	ld	a5,16(a5)
    800138ec:	fa843703          	ld	a4,-88(s0)
    800138f0:	10e7e563          	bltu	a5,a4,800139fa <alloc_block+0x1b4>
            if (prev != NULL) {
    800138f4:	fe043783          	ld	a5,-32(s0)
    800138f8:	cb81                	beqz	a5,80013908 <alloc_block+0xc2>
                prev->next = ptr->next;
    800138fa:	fe843783          	ld	a5,-24(s0)
    800138fe:	6798                	ld	a4,8(a5)
    80013900:	fe043783          	ld	a5,-32(s0)
    80013904:	e798                	sd	a4,8(a5)
    80013906:	a811                	j	8001391a <alloc_block+0xd4>
            }
            else {
                heap->free = ptr->next;
    80013908:	0000c797          	auipc	a5,0xc
    8001390c:	76078793          	addi	a5,a5,1888 # 80020068 <heap>
    80013910:	639c                	ld	a5,0(a5)
    80013912:	fe843703          	ld	a4,-24(s0)
    80013916:	6718                	ld	a4,8(a4)
    80013918:	e398                	sd	a4,0(a5)
            }
            ptr->next  = heap->used;
    8001391a:	0000c797          	auipc	a5,0xc
    8001391e:	74e78793          	addi	a5,a5,1870 # 80020068 <heap>
    80013922:	639c                	ld	a5,0(a5)
    80013924:	6798                	ld	a4,8(a5)
    80013926:	fe843783          	ld	a5,-24(s0)
    8001392a:	e798                	sd	a4,8(a5)
            heap->used = ptr;
    8001392c:	0000c797          	auipc	a5,0xc
    80013930:	73c78793          	addi	a5,a5,1852 # 80020068 <heap>
    80013934:	639c                	ld	a5,0(a5)
    80013936:	fe843703          	ld	a4,-24(s0)
    8001393a:	e798                	sd	a4,8(a5)
            if (is_top) {
    8001393c:	fcc42783          	lw	a5,-52(s0)
    80013940:	2781                	sext.w	a5,a5
    80013942:	c785                	beqz	a5,8001396a <alloc_block+0x124>
                ptr->size = num;
    80013944:	fe843783          	ld	a5,-24(s0)
    80013948:	fa843703          	ld	a4,-88(s0)
    8001394c:	eb98                	sd	a4,16(a5)
                heap->top = (size_t)ptr->addr + num;
    8001394e:	fe843783          	ld	a5,-24(s0)
    80013952:	639c                	ld	a5,0(a5)
    80013954:	86be                	mv	a3,a5
    80013956:	0000c797          	auipc	a5,0xc
    8001395a:	71278793          	addi	a5,a5,1810 # 80020068 <heap>
    8001395e:	639c                	ld	a5,0(a5)
    80013960:	fa843703          	ld	a4,-88(s0)
    80013964:	9736                	add	a4,a4,a3
    80013966:	ef98                	sd	a4,24(a5)
    80013968:	a071                	j	800139f4 <alloc_block+0x1ae>
            }
            else if (heap->fresh != NULL) {
    8001396a:	0000c797          	auipc	a5,0xc
    8001396e:	6fe78793          	addi	a5,a5,1790 # 80020068 <heap>
    80013972:	639c                	ld	a5,0(a5)
    80013974:	6b9c                	ld	a5,16(a5)
    80013976:	cfbd                	beqz	a5,800139f4 <alloc_block+0x1ae>
                size_t excess = ptr->size - num;
    80013978:	fe843783          	ld	a5,-24(s0)
    8001397c:	6b98                	ld	a4,16(a5)
    8001397e:	fa843783          	ld	a5,-88(s0)
    80013982:	40f707b3          	sub	a5,a4,a5
    80013986:	fcf43023          	sd	a5,-64(s0)
                if (excess >= heap_split_thresh) {
    8001398a:	0000c797          	auipc	a5,0xc
    8001398e:	6ee78793          	addi	a5,a5,1774 # 80020078 <heap_split_thresh>
    80013992:	639c                	ld	a5,0(a5)
    80013994:	fc043703          	ld	a4,-64(s0)
    80013998:	04f76e63          	bltu	a4,a5,800139f4 <alloc_block+0x1ae>
                    ptr->size    = num;
    8001399c:	fe843783          	ld	a5,-24(s0)
    800139a0:	fa843703          	ld	a4,-88(s0)
    800139a4:	eb98                	sd	a4,16(a5)
                    Block *split = heap->fresh;
    800139a6:	0000c797          	auipc	a5,0xc
    800139aa:	6c278793          	addi	a5,a5,1730 # 80020068 <heap>
    800139ae:	639c                	ld	a5,0(a5)
    800139b0:	6b9c                	ld	a5,16(a5)
    800139b2:	faf43c23          	sd	a5,-72(s0)
                    heap->fresh  = split->next;
    800139b6:	0000c797          	auipc	a5,0xc
    800139ba:	6b278793          	addi	a5,a5,1714 # 80020068 <heap>
    800139be:	639c                	ld	a5,0(a5)
    800139c0:	fb843703          	ld	a4,-72(s0)
    800139c4:	6718                	ld	a4,8(a4)
    800139c6:	eb98                	sd	a4,16(a5)
                    split->addr  = (void *)((size_t)ptr->addr + num);
    800139c8:	fe843783          	ld	a5,-24(s0)
    800139cc:	639c                	ld	a5,0(a5)
    800139ce:	873e                	mv	a4,a5
    800139d0:	fa843783          	ld	a5,-88(s0)
    800139d4:	97ba                	add	a5,a5,a4
    800139d6:	873e                	mv	a4,a5
    800139d8:	fb843783          	ld	a5,-72(s0)
    800139dc:	e398                	sd	a4,0(a5)
                    split->size  = excess;
    800139de:	fb843783          	ld	a5,-72(s0)
    800139e2:	fc043703          	ld	a4,-64(s0)
    800139e6:	eb98                	sd	a4,16(a5)
                    insert_block(split);
    800139e8:	fb843503          	ld	a0,-72(s0)
    800139ec:	af7ff0ef          	jal	ra,800134e2 <insert_block>
                    compact();
    800139f0:	bdfff0ef          	jal	ra,800135ce <compact>
                }
            }
            return ptr;
    800139f4:	fe843783          	ld	a5,-24(s0)
    800139f8:	a875                	j	80013ab4 <alloc_block+0x26e>
        }
        prev = ptr;
    800139fa:	fe843783          	ld	a5,-24(s0)
    800139fe:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    80013a02:	fe843783          	ld	a5,-24(s0)
    80013a06:	679c                	ld	a5,8(a5)
    80013a08:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80013a0c:	fe843783          	ld	a5,-24(s0)
    80013a10:	e80798e3          	bnez	a5,800138a0 <alloc_block+0x5a>
    }
    // no matching free blocks
    // see if any other blocks available
    size_t new_top = top + num;
    80013a14:	fd843703          	ld	a4,-40(s0)
    80013a18:	fa843783          	ld	a5,-88(s0)
    80013a1c:	97ba                	add	a5,a5,a4
    80013a1e:	fcf43823          	sd	a5,-48(s0)
    if (heap->fresh != NULL && new_top <= (size_t)heap_limit) {
    80013a22:	0000c797          	auipc	a5,0xc
    80013a26:	64678793          	addi	a5,a5,1606 # 80020068 <heap>
    80013a2a:	639c                	ld	a5,0(a5)
    80013a2c:	6b9c                	ld	a5,16(a5)
    80013a2e:	c3d1                	beqz	a5,80013ab2 <alloc_block+0x26c>
    80013a30:	0000c797          	auipc	a5,0xc
    80013a34:	64078793          	addi	a5,a5,1600 # 80020070 <heap_limit>
    80013a38:	639c                	ld	a5,0(a5)
    80013a3a:	873e                	mv	a4,a5
    80013a3c:	fd043783          	ld	a5,-48(s0)
    80013a40:	06f76963          	bltu	a4,a5,80013ab2 <alloc_block+0x26c>
        ptr         = heap->fresh;
    80013a44:	0000c797          	auipc	a5,0xc
    80013a48:	62478793          	addi	a5,a5,1572 # 80020068 <heap>
    80013a4c:	639c                	ld	a5,0(a5)
    80013a4e:	6b9c                	ld	a5,16(a5)
    80013a50:	fef43423          	sd	a5,-24(s0)
        heap->fresh = ptr->next;
    80013a54:	0000c797          	auipc	a5,0xc
    80013a58:	61478793          	addi	a5,a5,1556 # 80020068 <heap>
    80013a5c:	639c                	ld	a5,0(a5)
    80013a5e:	fe843703          	ld	a4,-24(s0)
    80013a62:	6718                	ld	a4,8(a4)
    80013a64:	eb98                	sd	a4,16(a5)
        ptr->addr   = (void *)top;
    80013a66:	fd843703          	ld	a4,-40(s0)
    80013a6a:	fe843783          	ld	a5,-24(s0)
    80013a6e:	e398                	sd	a4,0(a5)
        ptr->next   = heap->used;
    80013a70:	0000c797          	auipc	a5,0xc
    80013a74:	5f878793          	addi	a5,a5,1528 # 80020068 <heap>
    80013a78:	639c                	ld	a5,0(a5)
    80013a7a:	6798                	ld	a4,8(a5)
    80013a7c:	fe843783          	ld	a5,-24(s0)
    80013a80:	e798                	sd	a4,8(a5)
        ptr->size   = num;
    80013a82:	fe843783          	ld	a5,-24(s0)
    80013a86:	fa843703          	ld	a4,-88(s0)
    80013a8a:	eb98                	sd	a4,16(a5)
        heap->used  = ptr;
    80013a8c:	0000c797          	auipc	a5,0xc
    80013a90:	5dc78793          	addi	a5,a5,1500 # 80020068 <heap>
    80013a94:	639c                	ld	a5,0(a5)
    80013a96:	fe843703          	ld	a4,-24(s0)
    80013a9a:	e798                	sd	a4,8(a5)
        heap->top   = new_top;
    80013a9c:	0000c797          	auipc	a5,0xc
    80013aa0:	5cc78793          	addi	a5,a5,1484 # 80020068 <heap>
    80013aa4:	639c                	ld	a5,0(a5)
    80013aa6:	fd043703          	ld	a4,-48(s0)
    80013aaa:	ef98                	sd	a4,24(a5)
        return ptr;
    80013aac:	fe843783          	ld	a5,-24(s0)
    80013ab0:	a011                	j	80013ab4 <alloc_block+0x26e>
    }
    return NULL;
    80013ab2:	4781                	li	a5,0
}
    80013ab4:	853e                	mv	a0,a5
    80013ab6:	60e6                	ld	ra,88(sp)
    80013ab8:	6446                	ld	s0,80(sp)
    80013aba:	6125                	addi	sp,sp,96
    80013abc:	8082                	ret

0000000080013abe <alloc>:

static void *alloc(size_t num)
{
    80013abe:	7179                	addi	sp,sp,-48
    80013ac0:	f406                	sd	ra,40(sp)
    80013ac2:	f022                	sd	s0,32(sp)
    80013ac4:	1800                	addi	s0,sp,48
    80013ac6:	fca43c23          	sd	a0,-40(s0)
    Block *block = alloc_block(num);
    80013aca:	fd843503          	ld	a0,-40(s0)
    80013ace:	d79ff0ef          	jal	ra,80013846 <alloc_block>
    80013ad2:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80013ad6:	fe843783          	ld	a5,-24(s0)
    80013ada:	c789                	beqz	a5,80013ae4 <alloc+0x26>
        return block->addr;
    80013adc:	fe843783          	ld	a5,-24(s0)
    80013ae0:	639c                	ld	a5,0(a5)
    80013ae2:	a011                	j	80013ae6 <alloc+0x28>
    }
    return NULL;
    80013ae4:	4781                	li	a5,0
}
    80013ae6:	853e                	mv	a0,a5
    80013ae8:	70a2                	ld	ra,40(sp)
    80013aea:	7402                	ld	s0,32(sp)
    80013aec:	6145                	addi	sp,sp,48
    80013aee:	8082                	ret

0000000080013af0 <calloc>:

static void *calloc(size_t num, size_t size)
{
    80013af0:	7179                	addi	sp,sp,-48
    80013af2:	f406                	sd	ra,40(sp)
    80013af4:	f022                	sd	s0,32(sp)
    80013af6:	1800                	addi	s0,sp,48
    80013af8:	fca43c23          	sd	a0,-40(s0)
    80013afc:	fcb43823          	sd	a1,-48(s0)
    num *= size;
    80013b00:	fd843703          	ld	a4,-40(s0)
    80013b04:	fd043783          	ld	a5,-48(s0)
    80013b08:	02f707b3          	mul	a5,a4,a5
    80013b0c:	fcf43c23          	sd	a5,-40(s0)
    Block *block = alloc_block(num);
    80013b10:	fd843503          	ld	a0,-40(s0)
    80013b14:	d33ff0ef          	jal	ra,80013846 <alloc_block>
    80013b18:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80013b1c:	fe843783          	ld	a5,-24(s0)
    80013b20:	c385                	beqz	a5,80013b40 <calloc+0x50>
        memset(block->addr, 0, num);
    80013b22:	fe843783          	ld	a5,-24(s0)
    80013b26:	639c                	ld	a5,0(a5)
    80013b28:	fd843703          	ld	a4,-40(s0)
    80013b2c:	2701                	sext.w	a4,a4
    80013b2e:	863a                	mv	a2,a4
    80013b30:	4581                	li	a1,0
    80013b32:	853e                	mv	a0,a5
    80013b34:	7f6090ef          	jal	ra,8001d32a <memset>
        return block->addr;
    80013b38:	fe843783          	ld	a5,-24(s0)
    80013b3c:	639c                	ld	a5,0(a5)
    80013b3e:	a011                	j	80013b42 <calloc+0x52>
    }
    return NULL;
    80013b40:	4781                	li	a5,0
}
    80013b42:	853e                	mv	a0,a5
    80013b44:	70a2                	ld	ra,40(sp)
    80013b46:	7402                	ld	s0,32(sp)
    80013b48:	6145                	addi	sp,sp,48
    80013b4a:	8082                	ret

0000000080013b4c <count_blocks>:

static size_t count_blocks(Block *ptr)
{
    80013b4c:	7179                	addi	sp,sp,-48
    80013b4e:	f422                	sd	s0,40(sp)
    80013b50:	1800                	addi	s0,sp,48
    80013b52:	fca43c23          	sd	a0,-40(s0)
    size_t num = 0;
    80013b56:	fe043423          	sd	zero,-24(s0)
    while (ptr != NULL) {
    80013b5a:	a819                	j	80013b70 <count_blocks+0x24>
        num++;
    80013b5c:	fe843783          	ld	a5,-24(s0)
    80013b60:	0785                	addi	a5,a5,1
    80013b62:	fef43423          	sd	a5,-24(s0)
        ptr = ptr->next;
    80013b66:	fd843783          	ld	a5,-40(s0)
    80013b6a:	679c                	ld	a5,8(a5)
    80013b6c:	fcf43c23          	sd	a5,-40(s0)
    while (ptr != NULL) {
    80013b70:	fd843783          	ld	a5,-40(s0)
    80013b74:	f7e5                	bnez	a5,80013b5c <count_blocks+0x10>
    }
    return num;
    80013b76:	fe843783          	ld	a5,-24(s0)
}
    80013b7a:	853e                	mv	a0,a5
    80013b7c:	7422                	ld	s0,40(sp)
    80013b7e:	6145                	addi	sp,sp,48
    80013b80:	8082                	ret

0000000080013b82 <heap_num_free>:
static size_t heap_num_free()
{
    80013b82:	1141                	addi	sp,sp,-16
    80013b84:	e406                	sd	ra,8(sp)
    80013b86:	e022                	sd	s0,0(sp)
    80013b88:	0800                	addi	s0,sp,16
    return count_blocks(heap->free);
    80013b8a:	0000c797          	auipc	a5,0xc
    80013b8e:	4de78793          	addi	a5,a5,1246 # 80020068 <heap>
    80013b92:	639c                	ld	a5,0(a5)
    80013b94:	639c                	ld	a5,0(a5)
    80013b96:	853e                	mv	a0,a5
    80013b98:	fb5ff0ef          	jal	ra,80013b4c <count_blocks>
    80013b9c:	87aa                	mv	a5,a0
}
    80013b9e:	853e                	mv	a0,a5
    80013ba0:	60a2                	ld	ra,8(sp)
    80013ba2:	6402                	ld	s0,0(sp)
    80013ba4:	0141                	addi	sp,sp,16
    80013ba6:	8082                	ret

0000000080013ba8 <heap_num_used>:
static size_t heap_num_used()
{
    80013ba8:	1141                	addi	sp,sp,-16
    80013baa:	e406                	sd	ra,8(sp)
    80013bac:	e022                	sd	s0,0(sp)
    80013bae:	0800                	addi	s0,sp,16
    return count_blocks(heap->used);
    80013bb0:	0000c797          	auipc	a5,0xc
    80013bb4:	4b878793          	addi	a5,a5,1208 # 80020068 <heap>
    80013bb8:	639c                	ld	a5,0(a5)
    80013bba:	679c                	ld	a5,8(a5)
    80013bbc:	853e                	mv	a0,a5
    80013bbe:	f8fff0ef          	jal	ra,80013b4c <count_blocks>
    80013bc2:	87aa                	mv	a5,a0
}
    80013bc4:	853e                	mv	a0,a5
    80013bc6:	60a2                	ld	ra,8(sp)
    80013bc8:	6402                	ld	s0,0(sp)
    80013bca:	0141                	addi	sp,sp,16
    80013bcc:	8082                	ret

0000000080013bce <heap_num_fresh>:
static size_t heap_num_fresh()
{
    80013bce:	1141                	addi	sp,sp,-16
    80013bd0:	e406                	sd	ra,8(sp)
    80013bd2:	e022                	sd	s0,0(sp)
    80013bd4:	0800                	addi	s0,sp,16
    return count_blocks(heap->fresh);
    80013bd6:	0000c797          	auipc	a5,0xc
    80013bda:	49278793          	addi	a5,a5,1170 # 80020068 <heap>
    80013bde:	639c                	ld	a5,0(a5)
    80013be0:	6b9c                	ld	a5,16(a5)
    80013be2:	853e                	mv	a0,a5
    80013be4:	f69ff0ef          	jal	ra,80013b4c <count_blocks>
    80013be8:	87aa                	mv	a5,a0
}
    80013bea:	853e                	mv	a0,a5
    80013bec:	60a2                	ld	ra,8(sp)
    80013bee:	6402                	ld	s0,0(sp)
    80013bf0:	0141                	addi	sp,sp,16
    80013bf2:	8082                	ret

0000000080013bf4 <heap_check>:
static bool heap_check()
{
    80013bf4:	1101                	addi	sp,sp,-32
    80013bf6:	ec06                	sd	ra,24(sp)
    80013bf8:	e822                	sd	s0,16(sp)
    80013bfa:	e426                	sd	s1,8(sp)
    80013bfc:	1000                	addi	s0,sp,32
    return heap_max_blocks == heap_num_free() + heap_num_used() + heap_num_fresh();
    80013bfe:	f85ff0ef          	jal	ra,80013b82 <heap_num_free>
    80013c02:	84aa                	mv	s1,a0
    80013c04:	fa5ff0ef          	jal	ra,80013ba8 <heap_num_used>
    80013c08:	87aa                	mv	a5,a0
    80013c0a:	94be                	add	s1,s1,a5
    80013c0c:	fc3ff0ef          	jal	ra,80013bce <heap_num_fresh>
    80013c10:	87aa                	mv	a5,a0
    80013c12:	00f48733          	add	a4,s1,a5
    80013c16:	0000c797          	auipc	a5,0xc
    80013c1a:	47278793          	addi	a5,a5,1138 # 80020088 <heap_max_blocks>
    80013c1e:	639c                	ld	a5,0(a5)
    80013c20:	40f707b3          	sub	a5,a4,a5
    80013c24:	0017b793          	seqz	a5,a5
    80013c28:	0ff7f793          	andi	a5,a5,255
}
    80013c2c:	853e                	mv	a0,a5
    80013c2e:	60e2                	ld	ra,24(sp)
    80013c30:	6442                	ld	s0,16(sp)
    80013c32:	64a2                	ld	s1,8(sp)
    80013c34:	6105                	addi	sp,sp,32
    80013c36:	8082                	ret

0000000080013c38 <heap_print_stats>:

void heap_print_stats(void)
{
    80013c38:	7179                	addi	sp,sp,-48
    80013c3a:	f406                	sd	ra,40(sp)
    80013c3c:	f022                	sd	s0,32(sp)
    80013c3e:	ec26                	sd	s1,24(sp)
    80013c40:	e84a                	sd	s2,16(sp)
    80013c42:	e44e                	sd	s3,8(sp)
    80013c44:	1800                	addi	s0,sp,48
    debugf(
    80013c46:	f3dff0ef          	jal	ra,80013b82 <heap_num_free>
    80013c4a:	84aa                	mv	s1,a0
    80013c4c:	f5dff0ef          	jal	ra,80013ba8 <heap_num_used>
    80013c50:	892a                	mv	s2,a0
    80013c52:	f7dff0ef          	jal	ra,80013bce <heap_num_fresh>
    80013c56:	89aa                	mv	s3,a0
        "HEAP\n~~~~\nFree blocks:    %lu\nUsed blocks:    %lu\nFresh blocks:   %lu\nHeap "
        "check:     %s\n",
        heap_num_free(), heap_num_used(), heap_num_fresh(), heap_check() ? "good" : "bad");
    80013c58:	f9dff0ef          	jal	ra,80013bf4 <heap_check>
    80013c5c:	87aa                	mv	a5,a0
    debugf(
    80013c5e:	c791                	beqz	a5,80013c6a <heap_print_stats+0x32>
    80013c60:	0000e797          	auipc	a5,0xe
    80013c64:	8f078793          	addi	a5,a5,-1808 # 80021550 <pow10.0+0x320>
    80013c68:	a029                	j	80013c72 <heap_print_stats+0x3a>
    80013c6a:	0000e797          	auipc	a5,0xe
    80013c6e:	8ee78793          	addi	a5,a5,-1810 # 80021558 <pow10.0+0x328>
    80013c72:	873e                	mv	a4,a5
    80013c74:	86ce                	mv	a3,s3
    80013c76:	864a                	mv	a2,s2
    80013c78:	85a6                	mv	a1,s1
    80013c7a:	0000e517          	auipc	a0,0xe
    80013c7e:	8e650513          	addi	a0,a0,-1818 # 80021560 <pow10.0+0x330>
    80013c82:	582050ef          	jal	ra,80019204 <debugf>
}
    80013c86:	0001                	nop
    80013c88:	70a2                	ld	ra,40(sp)
    80013c8a:	7402                	ld	s0,32(sp)
    80013c8c:	64e2                	ld	s1,24(sp)
    80013c8e:	6942                	ld	s2,16(sp)
    80013c90:	69a2                	ld	s3,8(sp)
    80013c92:	6145                	addi	sp,sp,48
    80013c94:	8082                	ret

0000000080013c96 <kmalloc>:
void *kmalloc(size_t sz)
{
    80013c96:	1101                	addi	sp,sp,-32
    80013c98:	ec06                	sd	ra,24(sp)
    80013c9a:	e822                	sd	s0,16(sp)
    80013c9c:	1000                	addi	s0,sp,32
    80013c9e:	fea43423          	sd	a0,-24(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kmalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return alloc(sz);
    80013ca2:	fe843503          	ld	a0,-24(s0)
    80013ca6:	e19ff0ef          	jal	ra,80013abe <alloc>
    80013caa:	87aa                	mv	a5,a0
}
    80013cac:	853e                	mv	a0,a5
    80013cae:	60e2                	ld	ra,24(sp)
    80013cb0:	6442                	ld	s0,16(sp)
    80013cb2:	6105                	addi	sp,sp,32
    80013cb4:	8082                	ret

0000000080013cb6 <kcalloc>:
void *kcalloc(size_t n, size_t sz)
{
    80013cb6:	1101                	addi	sp,sp,-32
    80013cb8:	ec06                	sd	ra,24(sp)
    80013cba:	e822                	sd	s0,16(sp)
    80013cbc:	1000                	addi	s0,sp,32
    80013cbe:	fea43423          	sd	a0,-24(s0)
    80013cc2:	feb43023          	sd	a1,-32(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kcalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return calloc(n, sz);
    80013cc6:	fe043583          	ld	a1,-32(s0)
    80013cca:	fe843503          	ld	a0,-24(s0)
    80013cce:	e23ff0ef          	jal	ra,80013af0 <calloc>
    80013cd2:	87aa                	mv	a5,a0
}
    80013cd4:	853e                	mv	a0,a5
    80013cd6:	60e2                	ld	ra,24(sp)
    80013cd8:	6442                	ld	s0,16(sp)
    80013cda:	6105                	addi	sp,sp,32
    80013cdc:	8082                	ret

0000000080013cde <kfree>:
void kfree(void *m)
{
    80013cde:	1101                	addi	sp,sp,-32
    80013ce0:	ec06                	sd	ra,24(sp)
    80013ce2:	e822                	sd	s0,16(sp)
    80013ce4:	1000                	addi	s0,sp,32
    80013ce6:	fea43423          	sd	a0,-24(s0)
    if (m != NULL) {
    80013cea:	fe843783          	ld	a5,-24(s0)
    80013cee:	c789                	beqz	a5,80013cf8 <kfree+0x1a>
        free(m);
    80013cf0:	fe843503          	ld	a0,-24(s0)
    80013cf4:	ac9ff0ef          	jal	ra,800137bc <free>
    }
#ifdef DEBUG_KMALLOC
    debugf("[kfree]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
}
    80013cf8:	0001                	nop
    80013cfa:	60e2                	ld	ra,24(sp)
    80013cfc:	6442                	ld	s0,16(sp)
    80013cfe:	6105                	addi	sp,sp,32
    80013d00:	8082                	ret

0000000080013d02 <heap_init>:

void heap_init(void)
{
    80013d02:	1101                	addi	sp,sp,-32
    80013d04:	ec06                	sd	ra,24(sp)
    80013d06:	e822                	sd	s0,16(sp)
    80013d08:	1000                	addi	s0,sp,32
#ifdef DEBUG_HEAP
    debugf("[heap_init]: Prior to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif
    void *start = page_znalloc(KERNEL_HEAP_PAGES);
    80013d0a:	6505                	lui	a0,0x1
    80013d0c:	63e070ef          	jal	ra,8001b34a <page_znalloc>
    80013d10:	fea43423          	sd	a0,-24(s0)
    debugf("[heap_init]: Heap start at 0x%08lx\n", start);
    debugf("[heap_init]: After to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif

    mmu_map_range(kernel_mmu_table, KERNEL_HEAP_START_VADDR, KERNEL_HEAP_END_VADDR, (uint64_t)start,
    80013d14:	0000c797          	auipc	a5,0xc
    80013d18:	2ec78793          	addi	a5,a5,748 # 80020000 <kernel_mmu_table>
    80013d1c:	6388                	ld	a0,0(a5)
    80013d1e:	fe843683          	ld	a3,-24(s0)
    80013d22:	4799                	li	a5,6
    80013d24:	4701                	li	a4,0
    80013d26:	00e08637          	lui	a2,0xe08
    80013d2a:	7f760613          	addi	a2,a2,2039 # e087f7 <i+0xe087d7>
    80013d2e:	0636                	slli	a2,a2,0xd
    80013d30:	00e085b7          	lui	a1,0xe08
    80013d34:	15dd                	addi	a1,a1,-9
    80013d36:	05b6                	slli	a1,a1,0xd
    80013d38:	4dc000ef          	jal	ra,80014214 <mmu_map_range>
                  MMU_LEVEL_4K, PB_READ | PB_WRITE);
    init((void *)KERNEL_HEAP_START_VADDR, (void *)KERNEL_HEAP_END_VADDR, KERNEL_HEAP_PAGES / 4, 16,
    80013d3c:	4721                	li	a4,8
    80013d3e:	46c1                	li	a3,16
    80013d40:	40000613          	li	a2,1024
    80013d44:	00e087b7          	lui	a5,0xe08
    80013d48:	7f778793          	addi	a5,a5,2039 # e087f7 <i+0xe087d7>
    80013d4c:	00d79593          	slli	a1,a5,0xd
    80013d50:	00e087b7          	lui	a5,0xe08
    80013d54:	17dd                	addi	a5,a5,-9
    80013d56:	00d79513          	slli	a0,a5,0xd
    80013d5a:	94bff0ef          	jal	ra,800136a4 <init>
         8);

}
    80013d5e:	0001                	nop
    80013d60:	60e2                	ld	ra,24(sp)
    80013d62:	6442                	ld	s0,16(sp)
    80013d64:	6105                	addi	sp,sp,32
    80013d66:	8082                	ret

0000000080013d68 <mutex_trylock>:
#include <config.h>
#include <lock.h>
#include <compiler.h>

bool mutex_trylock(Mutex *mutex)
{
    80013d68:	7179                	addi	sp,sp,-48
    80013d6a:	f422                	sd	s0,40(sp)
    80013d6c:	1800                	addi	s0,sp,48
    80013d6e:	fca43c23          	sd	a0,-40(s0)
    int old;
    asm volatile("amoswap.w.aq %0, %1, (%2)" : "=r"(old) : "r"(MUTEX_LOCKED), "r"(mutex));
    80013d72:	4785                	li	a5,1
    80013d74:	fd843703          	ld	a4,-40(s0)
    80013d78:	0cf727af          	amoswap.w.aq	a5,a5,(a4)
    80013d7c:	fef42623          	sw	a5,-20(s0)
    // If old == MUTEX_LOCKED, that means the mutex was already
    // locked when we tried to lock it. That means we didn't acquire
    // it.
    return old != MUTEX_LOCKED;
    80013d80:	fec42783          	lw	a5,-20(s0)
    80013d84:	0007871b          	sext.w	a4,a5
    80013d88:	4785                	li	a5,1
    80013d8a:	40f707b3          	sub	a5,a4,a5
    80013d8e:	00f037b3          	snez	a5,a5
    80013d92:	0ff7f793          	andi	a5,a5,255
}
    80013d96:	853e                	mv	a0,a5
    80013d98:	7422                	ld	s0,40(sp)
    80013d9a:	6145                	addi	sp,sp,48
    80013d9c:	8082                	ret

0000000080013d9e <mutex_spinlock>:

void mutex_spinlock(Mutex *mutex)
{
    80013d9e:	1101                	addi	sp,sp,-32
    80013da0:	ec06                	sd	ra,24(sp)
    80013da2:	e822                	sd	s0,16(sp)
    80013da4:	1000                	addi	s0,sp,32
    80013da6:	fea43423          	sd	a0,-24(s0)
    while (!mutex_trylock(mutex))
    80013daa:	0001                	nop
    80013dac:	fe843503          	ld	a0,-24(s0)
    80013db0:	fb9ff0ef          	jal	ra,80013d68 <mutex_trylock>
    80013db4:	87aa                	mv	a5,a0
    80013db6:	0017c793          	xori	a5,a5,1
    80013dba:	0ff7f793          	andi	a5,a5,255
    80013dbe:	f7fd                	bnez	a5,80013dac <mutex_spinlock+0xe>
        ;
}
    80013dc0:	0001                	nop
    80013dc2:	0001                	nop
    80013dc4:	60e2                	ld	ra,24(sp)
    80013dc6:	6442                	ld	s0,16(sp)
    80013dc8:	6105                	addi	sp,sp,32
    80013dca:	8082                	ret

0000000080013dcc <mutex_unlock>:

void mutex_unlock(Mutex *mutex)
{
    80013dcc:	1101                	addi	sp,sp,-32
    80013dce:	ec22                	sd	s0,24(sp)
    80013dd0:	1000                	addi	s0,sp,32
    80013dd2:	fea43423          	sd	a0,-24(s0)
    asm volatile("amoswap.w.rl zero, zero, (%0)" : : "r"(mutex));
    80013dd6:	fe843783          	ld	a5,-24(s0)
    80013dda:	0a07a02f          	amoswap.w.rl	zero,zero,(a5)
}
    80013dde:	0001                	nop
    80013de0:	6462                	ld	s0,24(sp)
    80013de2:	6105                	addi	sp,sp,32
    80013de4:	8082                	ret

0000000080013de6 <mmu_table_create>:
#define ADDR_1_BIT   21
#define ADDR_2_BIT   30


struct page_table *mmu_table_create(void)
{
    80013de6:	1141                	addi	sp,sp,-16
    80013de8:	e406                	sd	ra,8(sp)
    80013dea:	e022                	sd	s0,0(sp)
    80013dec:	0800                	addi	s0,sp,16
    return page_zalloc();
    80013dee:	4505                	li	a0,1
    80013df0:	55a070ef          	jal	ra,8001b34a <page_znalloc>
    80013df4:	87aa                	mv	a5,a0
}
    80013df6:	853e                	mv	a0,a5
    80013df8:	60a2                	ld	ra,8(sp)
    80013dfa:	6402                	ld	s0,0(sp)
    80013dfc:	0141                	addi	sp,sp,16
    80013dfe:	8082                	ret

0000000080013e00 <is_valid>:

// Check the valid bit of a page table entry.
static inline bool is_valid(unsigned long pte)
{
    80013e00:	1101                	addi	sp,sp,-32
    80013e02:	ec22                	sd	s0,24(sp)
    80013e04:	1000                	addi	s0,sp,32
    80013e06:	fea43423          	sd	a0,-24(s0)
    return pte & 1UL;
    80013e0a:	fe843783          	ld	a5,-24(s0)
    80013e0e:	8b85                	andi	a5,a5,1
    80013e10:	00f037b3          	snez	a5,a5
    80013e14:	0ff7f793          	andi	a5,a5,255
}
    80013e18:	853e                	mv	a0,a5
    80013e1a:	6462                	ld	s0,24(sp)
    80013e1c:	6105                	addi	sp,sp,32
    80013e1e:	8082                	ret

0000000080013e20 <is_leaf>:

// Check if a page table entry is a leaf, return false if it's a branch.
static inline bool is_leaf(unsigned long pte)
{
    80013e20:	1101                	addi	sp,sp,-32
    80013e22:	ec22                	sd	s0,24(sp)
    80013e24:	1000                	addi	s0,sp,32
    80013e26:	fea43423          	sd	a0,-24(s0)
    return (pte & 0xE) != 0;
    80013e2a:	fe843783          	ld	a5,-24(s0)
    80013e2e:	8bb9                	andi	a5,a5,14
    80013e30:	00f037b3          	snez	a5,a5
    80013e34:	0ff7f793          	andi	a5,a5,255
}
    80013e38:	853e                	mv	a0,a5
    80013e3a:	6462                	ld	s0,24(sp)
    80013e3c:	6105                	addi	sp,sp,32
    80013e3e:	8082                	ret

0000000080013e40 <mmu_map>:

bool mmu_map(struct page_table *tab, uint64_t vaddr, uint64_t paddr, uint8_t lvl, uint64_t bits)
{
    80013e40:	7135                	addi	sp,sp,-160
    80013e42:	ed06                	sd	ra,152(sp)
    80013e44:	e922                	sd	s0,144(sp)
    80013e46:	1100                	addi	s0,sp,160
    80013e48:	f8a43423          	sd	a0,-120(s0)
    80013e4c:	f8b43023          	sd	a1,-128(s0)
    80013e50:	f6c43c23          	sd	a2,-136(s0)
    80013e54:	87b6                	mv	a5,a3
    80013e56:	f6e43423          	sd	a4,-152(s0)
    80013e5a:	f6f40ba3          	sb	a5,-137(s0)
    if (tab == NULL || lvl > MMU_LEVEL_1G || (bits & 0xE) == 0) {
    80013e5e:	f8843783          	ld	a5,-120(s0)
    80013e62:	cf81                	beqz	a5,80013e7a <mmu_map+0x3a>
    80013e64:	f7744783          	lbu	a5,-137(s0)
    80013e68:	0ff7f713          	andi	a4,a5,255
    80013e6c:	4789                	li	a5,2
    80013e6e:	00e7e663          	bltu	a5,a4,80013e7a <mmu_map+0x3a>
    80013e72:	f6843783          	ld	a5,-152(s0)
    80013e76:	8bb9                	andi	a5,a5,14
    80013e78:	e399                	bnez	a5,80013e7e <mmu_map+0x3e>
        // debugf("mmu_map: invalid argument");
        return false;
    80013e7a:	4781                	li	a5,0
    80013e7c:	aab9                	j	80013fda <mmu_map+0x19a>

    // debugf("mmu_map: page table at 0x%08lx\n", tab);
    // debugf("mmu_map: vaddr == 0x%08lx\n", vaddr);
    // debugf("mmu_map: paddr == 0x%08lx\n", paddr);

    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80013e7e:	f8043783          	ld	a5,-128(s0)
    80013e82:	83b1                	srli	a5,a5,0xc
    80013e84:	1ff7f793          	andi	a5,a5,511
    80013e88:	faf43823          	sd	a5,-80(s0)
    80013e8c:	f8043783          	ld	a5,-128(s0)
    80013e90:	83d5                	srli	a5,a5,0x15
    80013e92:	1ff7f793          	andi	a5,a5,511
    80013e96:	faf43c23          	sd	a5,-72(s0)
                            (vaddr >> ADDR_2_BIT) & 0x1FF};
    80013e9a:	f8043783          	ld	a5,-128(s0)
    80013e9e:	83f9                	srli	a5,a5,0x1e
    80013ea0:	1ff7f793          	andi	a5,a5,511
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80013ea4:	fcf43023          	sd	a5,-64(s0)
    // debugf("mmu_map: vpn = {%d, %d, %d}\n", vpn[0], vpn[1], vpn[2]);
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80013ea8:	f7843783          	ld	a5,-136(s0)
    80013eac:	83b1                	srli	a5,a5,0xc
    80013eae:	1ff7f793          	andi	a5,a5,511
    80013eb2:	f8f43c23          	sd	a5,-104(s0)
    80013eb6:	f7843783          	ld	a5,-136(s0)
    80013eba:	83d5                	srli	a5,a5,0x15
    80013ebc:	1ff7f793          	andi	a5,a5,511
    80013ec0:	faf43023          	sd	a5,-96(s0)
                            (paddr >> ADDR_2_BIT) & 0x3FFFFFF};
    80013ec4:	f7843783          	ld	a5,-136(s0)
    80013ec8:	01e7d713          	srli	a4,a5,0x1e
    80013ecc:	040007b7          	lui	a5,0x4000
    80013ed0:	17fd                	addi	a5,a5,-1
    80013ed2:	8ff9                	and	a5,a5,a4
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80013ed4:	faf43423          	sd	a5,-88(s0)

    int i;
    struct page_table *pt = tab;
    80013ed8:	f8843783          	ld	a5,-120(s0)
    80013edc:	fef43023          	sd	a5,-32(s0)

    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    80013ee0:	4789                	li	a5,2
    80013ee2:	fef42623          	sw	a5,-20(s0)
    80013ee6:	a871                	j	80013f82 <mmu_map+0x142>
        unsigned long pte = pt->entries[vpn[i]];
    80013ee8:	fec42783          	lw	a5,-20(s0)
    80013eec:	078e                	slli	a5,a5,0x3
    80013eee:	ff040713          	addi	a4,s0,-16
    80013ef2:	97ba                	add	a5,a5,a4
    80013ef4:	fc07b783          	ld	a5,-64(a5) # 3ffffc0 <i+0x3ffffa0>
    80013ef8:	fe043703          	ld	a4,-32(s0)
    80013efc:	078e                	slli	a5,a5,0x3
    80013efe:	97ba                	add	a5,a5,a4
    80013f00:	639c                	ld	a5,0(a5)
    80013f02:	fcf43823          	sd	a5,-48(s0)

        if (!is_valid(pte)) {
    80013f06:	fd043503          	ld	a0,-48(s0)
    80013f0a:	ef7ff0ef          	jal	ra,80013e00 <is_valid>
    80013f0e:	87aa                	mv	a5,a0
    80013f10:	0017c793          	xori	a5,a5,1
    80013f14:	0ff7f793          	andi	a5,a5,255
    80013f18:	cf8d                	beqz	a5,80013f52 <mmu_map+0x112>
            // debugf("mmu_map: entry %d in page table at 0x%08lx is invalid\n", vpn[i], pt);
            struct page_table *new_pt = mmu_table_create();
    80013f1a:	ecdff0ef          	jal	ra,80013de6 <mmu_table_create>
    80013f1e:	fca43423          	sd	a0,-56(s0)
            if (new_pt == NULL) {
    80013f22:	fc843783          	ld	a5,-56(s0)
    80013f26:	e399                	bnez	a5,80013f2c <mmu_map+0xec>
                // debugf("mmu_map: mmu_table_create returned null");
                return false;
    80013f28:	4781                	li	a5,0
    80013f2a:	a845                	j	80013fda <mmu_map+0x19a>
            }
            // debugf("mmu_map: create a new page table at 0x%08lx\n", new_pt);
            pt->entries[vpn[i]] = (unsigned long)new_pt >> 2 | PB_VALID;
    80013f2c:	fc843783          	ld	a5,-56(s0)
    80013f30:	0027d713          	srli	a4,a5,0x2
    80013f34:	fec42783          	lw	a5,-20(s0)
    80013f38:	078e                	slli	a5,a5,0x3
    80013f3a:	ff040693          	addi	a3,s0,-16
    80013f3e:	97b6                	add	a5,a5,a3
    80013f40:	fc07b783          	ld	a5,-64(a5)
    80013f44:	00176713          	ori	a4,a4,1
    80013f48:	fe043683          	ld	a3,-32(s0)
    80013f4c:	078e                	slli	a5,a5,0x3
    80013f4e:	97b6                	add	a5,a5,a3
    80013f50:	e398                	sd	a4,0(a5)
            // debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d branch to 0x%08lx\n", vpn[i], pt, i, new_pt);
        } else {
            // debugf("mmu_map: entry %d in page table at 0x%08lx is valid\n", vpn[i], pt);
        }
        pt = (struct page_table*)((pt->entries[vpn[i]] & ~0x3FF) << 2);
    80013f52:	fec42783          	lw	a5,-20(s0)
    80013f56:	078e                	slli	a5,a5,0x3
    80013f58:	ff040713          	addi	a4,s0,-16
    80013f5c:	97ba                	add	a5,a5,a4
    80013f5e:	fc07b783          	ld	a5,-64(a5)
    80013f62:	fe043703          	ld	a4,-32(s0)
    80013f66:	078e                	slli	a5,a5,0x3
    80013f68:	97ba                	add	a5,a5,a4
    80013f6a:	639c                	ld	a5,0(a5)
    80013f6c:	00279713          	slli	a4,a5,0x2
    80013f70:	77fd                	lui	a5,0xfffff
    80013f72:	8ff9                	and	a5,a5,a4
    80013f74:	fef43023          	sd	a5,-32(s0)
    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    80013f78:	fec42783          	lw	a5,-20(s0)
    80013f7c:	37fd                	addiw	a5,a5,-1
    80013f7e:	fef42623          	sw	a5,-20(s0)
    80013f82:	f7744783          	lbu	a5,-137(s0)
    80013f86:	0007871b          	sext.w	a4,a5
    80013f8a:	fec42783          	lw	a5,-20(s0)
    80013f8e:	2781                	sext.w	a5,a5
    80013f90:	f4f74ce3          	blt	a4,a5,80013ee8 <mmu_map+0xa8>
    }

    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80013f94:	fa843783          	ld	a5,-88(s0)
    80013f98:	01c79713          	slli	a4,a5,0x1c
                             ppn[1] << PTE_PPN1_BIT |
    80013f9c:	fa043783          	ld	a5,-96(s0)
    80013fa0:	07ce                	slli	a5,a5,0x13
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80013fa2:	8f5d                	or	a4,a4,a5
                             ppn[0] << PTE_PPN0_BIT;
    80013fa4:	f9843783          	ld	a5,-104(s0)
    80013fa8:	07aa                	slli	a5,a5,0xa
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80013faa:	8fd9                	or	a5,a5,a4
    80013fac:	fcf43c23          	sd	a5,-40(s0)
    
    // debugf("mmu_map: ppn_leaf == 0x%x\n", (ppn_leaf << 2));
    pt->entries[vpn[i]] = ppn_leaf | bits | PB_VALID;
    80013fb0:	fd843703          	ld	a4,-40(s0)
    80013fb4:	f6843783          	ld	a5,-152(s0)
    80013fb8:	8f5d                	or	a4,a4,a5
    80013fba:	fec42783          	lw	a5,-20(s0)
    80013fbe:	078e                	slli	a5,a5,0x3
    80013fc0:	ff040693          	addi	a3,s0,-16
    80013fc4:	97b6                	add	a5,a5,a3
    80013fc6:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    80013fca:	00176713          	ori	a4,a4,1
    80013fce:	fe043683          	ld	a3,-32(s0)
    80013fd2:	078e                	slli	a5,a5,0x3
    80013fd4:	97b6                	add	a5,a5,a3
    80013fd6:	e398                	sd	a4,0(a5)

    // debugf("mmu_map: set bits of address 0x%08lx to 0x%08lx\n", &pt->entries[vpn[i]], ppn_leaf | bits | PB_VALID);

    // debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d leaf to 0x%08lx\n", vpn[i], pt, i, ppn_leaf << 2);
    return true;
    80013fd8:	4785                	li	a5,1
}
    80013fda:	853e                	mv	a0,a5
    80013fdc:	60ea                	ld	ra,152(sp)
    80013fde:	644a                	ld	s0,144(sp)
    80013fe0:	610d                	addi	sp,sp,160
    80013fe2:	8082                	ret

0000000080013fe4 <mmu_free>:

void mmu_free(struct page_table *tab) 
{ 
    80013fe4:	7179                	addi	sp,sp,-48
    80013fe6:	f406                	sd	ra,40(sp)
    80013fe8:	f022                	sd	s0,32(sp)
    80013fea:	1800                	addi	s0,sp,48
    80013fec:	fca43c23          	sd	a0,-40(s0)
    uint64_t entry; 
    int i; 

    if (tab == NULL) { 
    80013ff0:	fd843783          	ld	a5,-40(s0)
    80013ff4:	c7b5                	beqz	a5,80014060 <mmu_free+0x7c>
        return; 
    } 

    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    80013ff6:	fe042623          	sw	zero,-20(s0)
    80013ffa:	a0a1                	j	80014042 <mmu_free+0x5e>
        entry = tab->entries[i]; 
    80013ffc:	fd843703          	ld	a4,-40(s0)
    80014000:	fec42783          	lw	a5,-20(s0)
    80014004:	078e                	slli	a5,a5,0x3
    80014006:	97ba                	add	a5,a5,a4
    80014008:	639c                	ld	a5,0(a5)
    8001400a:	fef43023          	sd	a5,-32(s0)
        if (entry & PB_VALID) {
    8001400e:	fe043783          	ld	a5,-32(s0)
    80014012:	8b85                	andi	a5,a5,1
    80014014:	cb91                	beqz	a5,80014028 <mmu_free+0x44>
            mmu_free((struct page_table *)((entry & ~0x3FF) << 2)); // Recurse into the next level
    80014016:	fe043783          	ld	a5,-32(s0)
    8001401a:	00279713          	slli	a4,a5,0x2
    8001401e:	77fd                	lui	a5,0xfffff
    80014020:	8ff9                	and	a5,a5,a4
    80014022:	853e                	mv	a0,a5
    80014024:	fc1ff0ef          	jal	ra,80013fe4 <mmu_free>
        }
        tab->entries[i] = 0; 
    80014028:	fd843703          	ld	a4,-40(s0)
    8001402c:	fec42783          	lw	a5,-20(s0)
    80014030:	078e                	slli	a5,a5,0x3
    80014032:	97ba                	add	a5,a5,a4
    80014034:	0007b023          	sd	zero,0(a5) # fffffffffffff000 <_heap_end+0xffffffff77fef000>
    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    80014038:	fec42783          	lw	a5,-20(s0)
    8001403c:	2785                	addiw	a5,a5,1
    8001403e:	fef42623          	sw	a5,-20(s0)
    80014042:	fec42783          	lw	a5,-20(s0)
    80014046:	0007871b          	sext.w	a4,a5
    8001404a:	1ff00793          	li	a5,511
    8001404e:	fae7d7e3          	bge	a5,a4,80013ffc <mmu_free+0x18>
    } 

    page_free(tab); 
    80014052:	fd843503          	ld	a0,-40(s0)
    80014056:	390070ef          	jal	ra,8001b3e6 <page_free>
    SFENCE_ALL();
    8001405a:	12000073          	sfence.vma
    8001405e:	a011                	j	80014062 <mmu_free+0x7e>
        return; 
    80014060:	0001                	nop
}
    80014062:	70a2                	ld	ra,40(sp)
    80014064:	7402                	ld	s0,32(sp)
    80014066:	6145                	addi	sp,sp,48
    80014068:	8082                	ret

000000008001406a <mmu_translate>:

uint64_t mmu_translate(const struct page_table *tab, uint64_t vaddr) 
{ 
    8001406a:	711d                	addi	sp,sp,-96
    8001406c:	ec86                	sd	ra,88(sp)
    8001406e:	e8a2                	sd	s0,80(sp)
    80014070:	1080                	addi	s0,sp,96
    80014072:	faa43423          	sd	a0,-88(s0)
    80014076:	fab43023          	sd	a1,-96(s0)

    // debugf("mmu_translate: page table at 0x%016lx\n", tab);
    // debugf("mmu_translate: vaddr == 0x%016lx\n", vaddr);

    if (tab == NULL) { 
    8001407a:	fa843783          	ld	a5,-88(s0)
    8001407e:	e399                	bnez	a5,80014084 <mmu_translate+0x1a>
        // debugf("mmu_translate: tab == NULL\n");
        return MMU_TRANSLATE_PAGE_FAULT; 
    80014080:	57fd                	li	a5,-1
    80014082:	aab1                	j	800141de <mmu_translate+0x174>
    } 

    // Extract the virtual page numbers
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80014084:	fa043783          	ld	a5,-96(s0)
    80014088:	83b1                	srli	a5,a5,0xc
    8001408a:	1ff7f793          	andi	a5,a5,511
    8001408e:	faf43823          	sd	a5,-80(s0)
                      (vaddr >> ADDR_1_BIT) & 0x1FF, 
    80014092:	fa043783          	ld	a5,-96(s0)
    80014096:	83d5                	srli	a5,a5,0x15
    80014098:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    8001409c:	faf43c23          	sd	a5,-72(s0)
                      (vaddr >> ADDR_2_BIT) & 0x1FF};
    800140a0:	fa043783          	ld	a5,-96(s0)
    800140a4:	83f9                	srli	a5,a5,0x1e
    800140a6:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    800140aa:	fcf43023          	sd	a5,-64(s0)
    // debugf("mmu_translate: vpn[0] == 0x%03lx\n", vpn[0]);
    // debugf("mmu_translate: vpn[1] == 0x%03lx\n", vpn[1]);
    // debugf("mmu_translate: vpn[2] == 0x%03lx\n", vpn[2]);

    uint64_t lvl = MMU_LEVEL_1G;
    800140ae:	4789                	li	a5,2
    800140b0:	fef43423          	sd	a5,-24(s0)
    // Traverse the page table hierarchy using the virtual page numbers
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    800140b4:	4789                	li	a5,2
    800140b6:	fef42223          	sw	a5,-28(s0)
    800140ba:	a075                	j	80014166 <mmu_translate+0xfc>
        // Iterate through and print the page table entries
        // debugf("mmu_translate: tab->entries == 0x%08lx\n", tab->entries);
        for (int j = 0; j < (PAGE_SIZE / 8); j++) {
    800140bc:	fe042023          	sw	zero,-32(s0)
    800140c0:	a031                	j	800140cc <mmu_translate+0x62>
    800140c2:	fe042783          	lw	a5,-32(s0)
    800140c6:	2785                	addiw	a5,a5,1
    800140c8:	fef42023          	sw	a5,-32(s0)
    800140cc:	fe042783          	lw	a5,-32(s0)
    800140d0:	0007871b          	sext.w	a4,a5
    800140d4:	1ff00793          	li	a5,511
    800140d8:	fee7d5e3          	bge	a5,a4,800140c2 <mmu_translate+0x58>
            if (tab->entries[j] & PB_VALID) {
                // debugf("mmu_translate: tab->entries[%x] == 0x%0lx\n", j, tab->entries[j]);
            }
        }

        if (!(tab->entries[vpn[i]] & PB_VALID)) {
    800140dc:	fe442783          	lw	a5,-28(s0)
    800140e0:	078e                	slli	a5,a5,0x3
    800140e2:	ff040713          	addi	a4,s0,-16
    800140e6:	97ba                	add	a5,a5,a4
    800140e8:	fc07b783          	ld	a5,-64(a5)
    800140ec:	fa843703          	ld	a4,-88(s0)
    800140f0:	078e                	slli	a5,a5,0x3
    800140f2:	97ba                	add	a5,a5,a4
    800140f4:	639c                	ld	a5,0(a5)
    800140f6:	8b85                	andi	a5,a5,1
    800140f8:	e399                	bnez	a5,800140fe <mmu_translate+0x94>
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is invalid\n", vpn[i], tab);
            return MMU_TRANSLATE_PAGE_FAULT; // Entry is not valid
    800140fa:	57fd                	li	a5,-1
    800140fc:	a0cd                	j	800141de <mmu_translate+0x174>
        } else if (!is_leaf(tab->entries[vpn[i]])) {
    800140fe:	fe442783          	lw	a5,-28(s0)
    80014102:	078e                	slli	a5,a5,0x3
    80014104:	ff040713          	addi	a4,s0,-16
    80014108:	97ba                	add	a5,a5,a4
    8001410a:	fc07b783          	ld	a5,-64(a5)
    8001410e:	fa843703          	ld	a4,-88(s0)
    80014112:	078e                	slli	a5,a5,0x3
    80014114:	97ba                	add	a5,a5,a4
    80014116:	639c                	ld	a5,0(a5)
    80014118:	853e                	mv	a0,a5
    8001411a:	d07ff0ef          	jal	ra,80013e20 <is_leaf>
    8001411e:	87aa                	mv	a5,a0
    80014120:	0017c793          	xori	a5,a5,1
    80014124:	0ff7f793          	andi	a5,a5,255
    80014128:	c78d                	beqz	a5,80014152 <mmu_translate+0xe8>
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is a branch to 0x%08lx\n", vpn[i], tab, (tab->entries[vpn[i]] & ~0x3FF) << 2);
            tab = (struct page_table *)((tab->entries[vpn[i]] & ~0x3FF) << 2);
    8001412a:	fe442783          	lw	a5,-28(s0)
    8001412e:	078e                	slli	a5,a5,0x3
    80014130:	ff040713          	addi	a4,s0,-16
    80014134:	97ba                	add	a5,a5,a4
    80014136:	fc07b783          	ld	a5,-64(a5)
    8001413a:	fa843703          	ld	a4,-88(s0)
    8001413e:	078e                	slli	a5,a5,0x3
    80014140:	97ba                	add	a5,a5,a4
    80014142:	639c                	ld	a5,0(a5)
    80014144:	00279713          	slli	a4,a5,0x2
    80014148:	77fd                	lui	a5,0xfffff
    8001414a:	8ff9                	and	a5,a5,a4
    8001414c:	faf43423          	sd	a5,-88(s0)
    80014150:	a031                	j	8001415c <mmu_translate+0xf2>
        } else {
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is a leaf\n", vpn[i], tab);
            lvl = i;
    80014152:	fe442783          	lw	a5,-28(s0)
    80014156:	fef43423          	sd	a5,-24(s0)
            break; // Entry is a leaf
    8001415a:	a819                	j	80014170 <mmu_translate+0x106>
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    8001415c:	fe442783          	lw	a5,-28(s0)
    80014160:	37fd                	addiw	a5,a5,-1
    80014162:	fef42223          	sw	a5,-28(s0)
    80014166:	fe442783          	lw	a5,-28(s0)
    8001416a:	2781                	sext.w	a5,a5
    8001416c:	f407d8e3          	bgez	a5,800140bc <mmu_translate+0x52>
        }
    }

    // debugf("mmu_translate: vaddr == 0x%08lx\n", vaddr);

    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    80014170:	fe843783          	ld	a5,-24(s0)
    80014174:	2781                	sext.w	a5,a5
    80014176:	873e                	mv	a4,a5
    80014178:	87ba                	mv	a5,a4
    8001417a:	0037979b          	slliw	a5,a5,0x3
    8001417e:	9fb9                	addw	a5,a5,a4
    80014180:	2781                	sext.w	a5,a5
    80014182:	27b1                	addiw	a5,a5,12
    80014184:	2781                	sext.w	a5,a5
    80014186:	4705                	li	a4,1
    80014188:	00f717bb          	sllw	a5,a4,a5
    8001418c:	2781                	sext.w	a5,a5
    8001418e:	37fd                	addiw	a5,a5,-1
    80014190:	2781                	sext.w	a5,a5
    80014192:	fcf43c23          	sd	a5,-40(s0)
    
    // Extract the physical address from the final page table entry
    uint64_t paddr = ((tab->entries[vpn[lvl]] & ~0x3FF) << 2) & ~page_mask;
    80014196:	fe843783          	ld	a5,-24(s0)
    8001419a:	078e                	slli	a5,a5,0x3
    8001419c:	ff040713          	addi	a4,s0,-16
    800141a0:	97ba                	add	a5,a5,a4
    800141a2:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    800141a6:	fa843703          	ld	a4,-88(s0)
    800141aa:	078e                	slli	a5,a5,0x3
    800141ac:	97ba                	add	a5,a5,a4
    800141ae:	639c                	ld	a5,0(a5)
    800141b0:	00279713          	slli	a4,a5,0x2
    800141b4:	fd843783          	ld	a5,-40(s0)
    800141b8:	fff7c793          	not	a5,a5
    800141bc:	8f7d                	and	a4,a4,a5
    800141be:	77fd                	lui	a5,0xfffff
    800141c0:	8ff9                	and	a5,a5,a4
    800141c2:	fcf43823          	sd	a5,-48(s0)

    uint64_t result = paddr | (vaddr & page_mask);
    800141c6:	fa043703          	ld	a4,-96(s0)
    800141ca:	fd843783          	ld	a5,-40(s0)
    800141ce:	8ff9                	and	a5,a5,a4
    800141d0:	fd043703          	ld	a4,-48(s0)
    800141d4:	8fd9                	or	a5,a5,a4
    800141d6:	fcf43423          	sd	a5,-56(s0)
    // debugf("mmu_translate: paddr == 0x%08lx\n", result);

    return result; // Combine with the offset within the page
    800141da:	fc843783          	ld	a5,-56(s0)
}
    800141de:	853e                	mv	a0,a5
    800141e0:	60e6                	ld	ra,88(sp)
    800141e2:	6446                	ld	s0,80(sp)
    800141e4:	6125                	addi	sp,sp,96
    800141e6:	8082                	ret

00000000800141e8 <kernel_mmu_translate>:

uint64_t kernel_mmu_translate(uint64_t vaddr) 
{ 
    800141e8:	1101                	addi	sp,sp,-32
    800141ea:	ec06                	sd	ra,24(sp)
    800141ec:	e822                	sd	s0,16(sp)
    800141ee:	1000                	addi	s0,sp,32
    800141f0:	fea43423          	sd	a0,-24(s0)
    return mmu_translate(kernel_mmu_table, vaddr); 
    800141f4:	0000c797          	auipc	a5,0xc
    800141f8:	e0c78793          	addi	a5,a5,-500 # 80020000 <kernel_mmu_table>
    800141fc:	639c                	ld	a5,0(a5)
    800141fe:	fe843583          	ld	a1,-24(s0)
    80014202:	853e                	mv	a0,a5
    80014204:	e67ff0ef          	jal	ra,8001406a <mmu_translate>
    80014208:	87aa                	mv	a5,a0
}
    8001420a:	853e                	mv	a0,a5
    8001420c:	60e2                	ld	ra,24(sp)
    8001420e:	6442                	ld	s0,16(sp)
    80014210:	6105                	addi	sp,sp,32
    80014212:	8082                	ret

0000000080014214 <mmu_map_range>:
                       uint64_t start_virt, 
                       uint64_t end_virt, 
                       uint64_t start_phys,
                       uint8_t lvl, 
                       uint64_t bits)
{
    80014214:	711d                	addi	sp,sp,-96
    80014216:	ec86                	sd	ra,88(sp)
    80014218:	e8a2                	sd	s0,80(sp)
    8001421a:	1080                	addi	s0,sp,96
    8001421c:	fca43423          	sd	a0,-56(s0)
    80014220:	fcb43023          	sd	a1,-64(s0)
    80014224:	fac43c23          	sd	a2,-72(s0)
    80014228:	fad43823          	sd	a3,-80(s0)
    8001422c:	faf43023          	sd	a5,-96(s0)
    80014230:	87ba                	mv	a5,a4
    80014232:	faf407a3          	sb	a5,-81(s0)
    // debugf("mmu_map_range: page table at 0x%08lx\n", tab);
    start_virt            = ALIGN_DOWN_POT(start_virt, PAGE_SIZE_AT_LVL(lvl));
    80014236:	faf44783          	lbu	a5,-81(s0)
    8001423a:	2781                	sext.w	a5,a5
    8001423c:	873e                	mv	a4,a5
    8001423e:	87ba                	mv	a5,a4
    80014240:	0037979b          	slliw	a5,a5,0x3
    80014244:	9fb9                	addw	a5,a5,a4
    80014246:	2781                	sext.w	a5,a5
    80014248:	27b1                	addiw	a5,a5,12
    8001424a:	2781                	sext.w	a5,a5
    8001424c:	4705                	li	a4,1
    8001424e:	00f717bb          	sllw	a5,a4,a5
    80014252:	2781                	sext.w	a5,a5
    80014254:	40f007bb          	negw	a5,a5
    80014258:	2781                	sext.w	a5,a5
    8001425a:	873e                	mv	a4,a5
    8001425c:	fc043783          	ld	a5,-64(s0)
    80014260:	8ff9                	and	a5,a5,a4
    80014262:	fcf43023          	sd	a5,-64(s0)
    start_phys            = ALIGN_DOWN_POT(start_phys, PAGE_SIZE_AT_LVL(lvl));
    80014266:	faf44783          	lbu	a5,-81(s0)
    8001426a:	2781                	sext.w	a5,a5
    8001426c:	873e                	mv	a4,a5
    8001426e:	87ba                	mv	a5,a4
    80014270:	0037979b          	slliw	a5,a5,0x3
    80014274:	9fb9                	addw	a5,a5,a4
    80014276:	2781                	sext.w	a5,a5
    80014278:	27b1                	addiw	a5,a5,12
    8001427a:	2781                	sext.w	a5,a5
    8001427c:	4705                	li	a4,1
    8001427e:	00f717bb          	sllw	a5,a4,a5
    80014282:	2781                	sext.w	a5,a5
    80014284:	40f007bb          	negw	a5,a5
    80014288:	2781                	sext.w	a5,a5
    8001428a:	873e                	mv	a4,a5
    8001428c:	fb043783          	ld	a5,-80(s0)
    80014290:	8ff9                	and	a5,a5,a4
    80014292:	faf43823          	sd	a5,-80(s0)
    end_virt              = ALIGN_UP_POT(end_virt, PAGE_SIZE_AT_LVL(lvl));
    80014296:	faf44783          	lbu	a5,-81(s0)
    8001429a:	2781                	sext.w	a5,a5
    8001429c:	873e                	mv	a4,a5
    8001429e:	87ba                	mv	a5,a4
    800142a0:	0037979b          	slliw	a5,a5,0x3
    800142a4:	9fb9                	addw	a5,a5,a4
    800142a6:	2781                	sext.w	a5,a5
    800142a8:	27b1                	addiw	a5,a5,12
    800142aa:	2781                	sext.w	a5,a5
    800142ac:	4705                	li	a4,1
    800142ae:	00f717bb          	sllw	a5,a4,a5
    800142b2:	2781                	sext.w	a5,a5
    800142b4:	873e                	mv	a4,a5
    800142b6:	fb843783          	ld	a5,-72(s0)
    800142ba:	97ba                	add	a5,a5,a4
    800142bc:	fff78713          	addi	a4,a5,-1
    800142c0:	faf44783          	lbu	a5,-81(s0)
    800142c4:	2781                	sext.w	a5,a5
    800142c6:	86be                	mv	a3,a5
    800142c8:	87b6                	mv	a5,a3
    800142ca:	0037979b          	slliw	a5,a5,0x3
    800142ce:	9fb5                	addw	a5,a5,a3
    800142d0:	2781                	sext.w	a5,a5
    800142d2:	27b1                	addiw	a5,a5,12
    800142d4:	2781                	sext.w	a5,a5
    800142d6:	4685                	li	a3,1
    800142d8:	00f697bb          	sllw	a5,a3,a5
    800142dc:	2781                	sext.w	a5,a5
    800142de:	40f007bb          	negw	a5,a5
    800142e2:	2781                	sext.w	a5,a5
    800142e4:	8ff9                	and	a5,a5,a4
    800142e6:	faf43c23          	sd	a5,-72(s0)
    uint64_t num_bytes    = end_virt - start_virt;
    800142ea:	fb843703          	ld	a4,-72(s0)
    800142ee:	fc043783          	ld	a5,-64(s0)
    800142f2:	40f707b3          	sub	a5,a4,a5
    800142f6:	fcf43c23          	sd	a5,-40(s0)
    // debugf("mmu_map_range: start_virt = 0x%08lx\n", start_virt);
    // debugf("mmu_map_range: start_phys = 0x%08lx\n", start_phys);
    // debugf("mmu_map_range: mapping = %d bytes\n", num_bytes);
    uint64_t pages_mapped = 0;
    800142fa:	fe043423          	sd	zero,-24(s0)

    uint64_t i;
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    800142fe:	fe043023          	sd	zero,-32(s0)
    80014302:	a0ad                	j	8001436c <mmu_map_range+0x158>
        // debugf("mmu_map_range: mapping %d bytes for page %d\n", PAGE_SIZE_AT_LVL(lvl), i / PAGE_SIZE_AT_LVL(lvl));
        if (!mmu_map(tab, start_virt + i, start_phys + i, lvl, bits)) {
    80014304:	fc043703          	ld	a4,-64(s0)
    80014308:	fe043783          	ld	a5,-32(s0)
    8001430c:	00f705b3          	add	a1,a4,a5
    80014310:	fb043703          	ld	a4,-80(s0)
    80014314:	fe043783          	ld	a5,-32(s0)
    80014318:	97ba                	add	a5,a5,a4
    8001431a:	faf44683          	lbu	a3,-81(s0)
    8001431e:	fa043703          	ld	a4,-96(s0)
    80014322:	863e                	mv	a2,a5
    80014324:	fc843503          	ld	a0,-56(s0)
    80014328:	b19ff0ef          	jal	ra,80013e40 <mmu_map>
    8001432c:	87aa                	mv	a5,a0
    8001432e:	0017c793          	xori	a5,a5,1
    80014332:	0ff7f793          	andi	a5,a5,255
    80014336:	e3b1                	bnez	a5,8001437a <mmu_map_range+0x166>
            break;
        }
        pages_mapped += 1;
    80014338:	fe843783          	ld	a5,-24(s0)
    8001433c:	0785                	addi	a5,a5,1
    8001433e:	fef43423          	sd	a5,-24(s0)
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80014342:	faf44783          	lbu	a5,-81(s0)
    80014346:	2781                	sext.w	a5,a5
    80014348:	873e                	mv	a4,a5
    8001434a:	87ba                	mv	a5,a4
    8001434c:	0037979b          	slliw	a5,a5,0x3
    80014350:	9fb9                	addw	a5,a5,a4
    80014352:	2781                	sext.w	a5,a5
    80014354:	27b1                	addiw	a5,a5,12
    80014356:	2781                	sext.w	a5,a5
    80014358:	4705                	li	a4,1
    8001435a:	00f717bb          	sllw	a5,a4,a5
    8001435e:	2781                	sext.w	a5,a5
    80014360:	873e                	mv	a4,a5
    80014362:	fe043783          	ld	a5,-32(s0)
    80014366:	97ba                	add	a5,a5,a4
    80014368:	fef43023          	sd	a5,-32(s0)
    8001436c:	fe043703          	ld	a4,-32(s0)
    80014370:	fd843783          	ld	a5,-40(s0)
    80014374:	f8f768e3          	bltu	a4,a5,80014304 <mmu_map_range+0xf0>
    80014378:	a011                	j	8001437c <mmu_map_range+0x168>
            break;
    8001437a:	0001                	nop
    }
    // debugf("mmu_map_range: mapped %d pages\n", pages_mapped);
    SFENCE_ALL();
    8001437c:	12000073          	sfence.vma
    return pages_mapped;
    80014380:	fe843783          	ld	a5,-24(s0)
} 
    80014384:	853e                	mv	a0,a5
    80014386:	60e6                	ld	ra,88(sp)
    80014388:	6446                	ld	s0,80(sp)
    8001438a:	6125                	addi	sp,sp,96
    8001438c:	8082                	ret

000000008001438e <debug_page_table>:

// This function performs some basic sanity checks on the page table.
// For each level of the page table, it prints out the entries that are valid.
void debug_page_table(struct page_table *tab, uint8_t lvl) {
    8001438e:	715d                	addi	sp,sp,-80
    80014390:	e486                	sd	ra,72(sp)
    80014392:	e0a2                	sd	s0,64(sp)
    80014394:	0880                	addi	s0,sp,80
    80014396:	faa43c23          	sd	a0,-72(s0)
    8001439a:	87ae                	mv	a5,a1
    8001439c:	faf40ba3          	sb	a5,-73(s0)
    // debugf("debug_page_table: debugging page table at 0x%016lx\n", tab);
    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    800143a0:	fb744783          	lbu	a5,-73(s0)
    800143a4:	2781                	sext.w	a5,a5
    800143a6:	873e                	mv	a4,a5
    800143a8:	87ba                	mv	a5,a4
    800143aa:	0037979b          	slliw	a5,a5,0x3
    800143ae:	9fb9                	addw	a5,a5,a4
    800143b0:	2781                	sext.w	a5,a5
    800143b2:	27b1                	addiw	a5,a5,12
    800143b4:	2781                	sext.w	a5,a5
    800143b6:	4705                	li	a4,1
    800143b8:	00f717bb          	sllw	a5,a4,a5
    800143bc:	2781                	sext.w	a5,a5
    800143be:	37fd                	addiw	a5,a5,-1
    800143c0:	2781                	sext.w	a5,a5
    800143c2:	fef43023          	sd	a5,-32(s0)

    for (uint64_t i=0; i < 512; i++) {
    800143c6:	fe043423          	sd	zero,-24(s0)
    800143ca:	a21d                	j	800144f0 <debug_page_table+0x162>
        // Is the entry a leaf?
        bool is_leaf = (tab->entries[i] & 0xE) != 0;
    800143cc:	fb843703          	ld	a4,-72(s0)
    800143d0:	fe843783          	ld	a5,-24(s0)
    800143d4:	078e                	slli	a5,a5,0x3
    800143d6:	97ba                	add	a5,a5,a4
    800143d8:	639c                	ld	a5,0(a5)
    800143da:	8bb9                	andi	a5,a5,14
    800143dc:	00f037b3          	snez	a5,a5
    800143e0:	fcf40fa3          	sb	a5,-33(s0)

        // Is the entry valid?
        bool is_valid = tab->entries[i] & PB_VALID;
    800143e4:	fb843703          	ld	a4,-72(s0)
    800143e8:	fe843783          	ld	a5,-24(s0)
    800143ec:	078e                	slli	a5,a5,0x3
    800143ee:	97ba                	add	a5,a5,a4
    800143f0:	639c                	ld	a5,0(a5)
    800143f2:	8b85                	andi	a5,a5,1
    800143f4:	00f037b3          	snez	a5,a5
    800143f8:	fcf40f23          	sb	a5,-34(s0)

        // Is the entry a branch?
        bool is_branch = is_valid && !is_leaf;
    800143fc:	fde44783          	lbu	a5,-34(s0)
    80014400:	0ff7f793          	andi	a5,a5,255
    80014404:	cb91                	beqz	a5,80014418 <debug_page_table+0x8a>
    80014406:	fdf44783          	lbu	a5,-33(s0)
    8001440a:	0017c793          	xori	a5,a5,1
    8001440e:	0ff7f793          	andi	a5,a5,255
    80014412:	c399                	beqz	a5,80014418 <debug_page_table+0x8a>
    80014414:	4785                	li	a5,1
    80014416:	a011                	j	8001441a <debug_page_table+0x8c>
    80014418:	4781                	li	a5,0
    8001441a:	fcf40ea3          	sb	a5,-35(s0)
    8001441e:	fdd44783          	lbu	a5,-35(s0)
    80014422:	8b85                	andi	a5,a5,1
    80014424:	fcf40ea3          	sb	a5,-35(s0)

        uint64_t paddr = ((tab->entries[i] & ~0x3FF) << 2) & ~page_mask;
    80014428:	fb843703          	ld	a4,-72(s0)
    8001442c:	fe843783          	ld	a5,-24(s0)
    80014430:	078e                	slli	a5,a5,0x3
    80014432:	97ba                	add	a5,a5,a4
    80014434:	639c                	ld	a5,0(a5)
    80014436:	00279713          	slli	a4,a5,0x2
    8001443a:	fe043783          	ld	a5,-32(s0)
    8001443e:	fff7c793          	not	a5,a5
    80014442:	8f7d                	and	a4,a4,a5
    80014444:	77fd                	lui	a5,0xfffff
    80014446:	8ff9                	and	a5,a5,a4
    80014448:	fcf43823          	sd	a5,-48(s0)
        if (paddr == (uint64_t)tab) {
    8001444c:	fb843783          	ld	a5,-72(s0)
    80014450:	fd043703          	ld	a4,-48(s0)
    80014454:	08f70663          	beq	a4,a5,800144e0 <debug_page_table+0x152>
            continue;
        }

        uint64_t vaddr = paddr;
    80014458:	fd043783          	ld	a5,-48(s0)
    8001445c:	fcf43423          	sd	a5,-56(s0)
        if (is_valid && is_leaf) {
    80014460:	fde44783          	lbu	a5,-34(s0)
    80014464:	0ff7f793          	andi	a5,a5,255
    80014468:	cf9d                	beqz	a5,800144a6 <debug_page_table+0x118>
    8001446a:	fdf44783          	lbu	a5,-33(s0)
    8001446e:	0ff7f793          	andi	a5,a5,255
    80014472:	cb95                	beqz	a5,800144a6 <debug_page_table+0x118>
            // Confirm that we can translate the address
            uint64_t translated = mmu_translate(tab, vaddr);
    80014474:	fc843583          	ld	a1,-56(s0)
    80014478:	fb843503          	ld	a0,-72(s0)
    8001447c:	befff0ef          	jal	ra,8001406a <mmu_translate>
    80014480:	fca43023          	sd	a0,-64(s0)
            if (translated != paddr) {
    80014484:	fc043703          	ld	a4,-64(s0)
    80014488:	fd043783          	ld	a5,-48(s0)
    8001448c:	04f70c63          	beq	a4,a5,800144e4 <debug_page_table+0x156>
                // debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                // debugf("debug_page_table: expected 0x%08lx, got 0x%08lx\n", paddr, translated);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    80014490:	fb843603          	ld	a2,-72(s0)
    80014494:	fe843583          	ld	a1,-24(s0)
    80014498:	0000d517          	auipc	a0,0xd
    8001449c:	12850513          	addi	a0,a0,296 # 800215c0 <pow10.0+0x390>
    800144a0:	6bf040ef          	jal	ra,8001935e <fatalf>
        if (is_valid && is_leaf) {
    800144a4:	a081                	j	800144e4 <debug_page_table+0x156>
            } else {
                // debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
            }
        } else if (is_branch && lvl > MMU_LEVEL_4K) {
    800144a6:	fdd44783          	lbu	a5,-35(s0)
    800144aa:	0ff7f793          	andi	a5,a5,255
    800144ae:	c791                	beqz	a5,800144ba <debug_page_table+0x12c>
    800144b0:	fb744783          	lbu	a5,-73(s0)
    800144b4:	0ff7f793          	andi	a5,a5,255
    800144b8:	e79d                	bnez	a5,800144e6 <debug_page_table+0x158>
            // Recurse into the next level
            // debugf("debug_page_table: entry %d in page table at 0x%08lx is a branch to 0x%08lx\n", i, tab, (tab->entries[i] & ~0x3FF) << 2);
            // debug_page_table((struct page_table *)((tab->entries[i] & ~0x3FF) << 2), lvl - 1);
        } else {
            // Invalid entry, confirm that it's all zeroes
            if (tab->entries[i] != 0) {
    800144ba:	fb843703          	ld	a4,-72(s0)
    800144be:	fe843783          	ld	a5,-24(s0)
    800144c2:	078e                	slli	a5,a5,0x3
    800144c4:	97ba                	add	a5,a5,a4
    800144c6:	639c                	ld	a5,0(a5)
    800144c8:	cf99                	beqz	a5,800144e6 <debug_page_table+0x158>
                // debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                // debugf("debug_page_table: expected all zeroes, got 0x%08lx\n", tab->entries[i]);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    800144ca:	fb843603          	ld	a2,-72(s0)
    800144ce:	fe843583          	ld	a1,-24(s0)
    800144d2:	0000d517          	auipc	a0,0xd
    800144d6:	0ee50513          	addi	a0,a0,238 # 800215c0 <pow10.0+0x390>
    800144da:	685040ef          	jal	ra,8001935e <fatalf>
    800144de:	a021                	j	800144e6 <debug_page_table+0x158>
            continue;
    800144e0:	0001                	nop
    800144e2:	a011                	j	800144e6 <debug_page_table+0x158>
        if (is_valid && is_leaf) {
    800144e4:	0001                	nop
    for (uint64_t i=0; i < 512; i++) {
    800144e6:	fe843783          	ld	a5,-24(s0)
    800144ea:	0785                	addi	a5,a5,1
    800144ec:	fef43423          	sd	a5,-24(s0)
    800144f0:	fe843703          	ld	a4,-24(s0)
    800144f4:	1ff00793          	li	a5,511
    800144f8:	ece7fae3          	bgeu	a5,a4,800143cc <debug_page_table+0x3e>
            }
        }
    }

    // debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
}
    800144fc:	0001                	nop
    800144fe:	0001                	nop
    80014500:	60a6                	ld	ra,72(sp)
    80014502:	6406                	ld	s0,64(sp)
    80014504:	6161                	addi	sp,sp,80
    80014506:	8082                	ret

0000000080014508 <gpu_test>:

static Vector *device_active_jobs;
static VirtioDevice *gpu_device;
static Console console; // NOTE: Figure how this is supposed to be interfaced, allocate appropriately

bool gpu_test() {
    80014508:	1141                	addi	sp,sp,-16
    8001450a:	e406                	sd	ra,8(sp)
    8001450c:	e022                	sd	s0,0(sp)
    8001450e:	0800                	addi	s0,sp,16
    return gpu_init(gpu_device);
    80014510:	0000c797          	auipc	a5,0xc
    80014514:	b8878793          	addi	a5,a5,-1144 # 80020098 <gpu_device>
    80014518:	639c                	ld	a5,0(a5)
    8001451a:	853e                	mv	a0,a5
    8001451c:	0aa000ef          	jal	ra,800145c6 <gpu_init>
    80014520:	87aa                	mv	a5,a0
}
    80014522:	853e                	mv	a0,a5
    80014524:	60a2                	ld	ra,8(sp)
    80014526:	6402                	ld	s0,0(sp)
    80014528:	0141                	addi	sp,sp,16
    8001452a:	8082                	ret

000000008001452c <gpu_device_init>:

void gpu_device_init() {
    8001452c:	1101                	addi	sp,sp,-32
    8001452e:	ec06                	sd	ra,24(sp)
    80014530:	e822                	sd	s0,16(sp)
    80014532:	1000                	addi	s0,sp,32
    device_active_jobs = vector_new();
    80014534:	049090ef          	jal	ra,8001dd7c <vector_new>
    80014538:	872a                	mv	a4,a0
    8001453a:	0000c797          	auipc	a5,0xc
    8001453e:	b5678793          	addi	a5,a5,-1194 # 80020090 <device_active_jobs>
    80014542:	e398                	sd	a4,0(a5)
    gpu_device = virtio_get_gpu_device();
    80014544:	3b3050ef          	jal	ra,8001a0f6 <virtio_get_gpu_device>
    80014548:	872a                	mv	a4,a0
    8001454a:	0000c797          	auipc	a5,0xc
    8001454e:	b4e78793          	addi	a5,a5,-1202 # 80020098 <gpu_device>
    80014552:	e398                	sd	a4,0(a5)
    // debugf("GPU device init done for device at %p\n", gpu_device->pcidev->ecam_header);
    virtio_set_device_name(gpu_device, "GPU Device");
    80014554:	0000c797          	auipc	a5,0xc
    80014558:	b4478793          	addi	a5,a5,-1212 # 80020098 <gpu_device>
    8001455c:	639c                	ld	a5,0(a5)
    8001455e:	0000d597          	auipc	a1,0xd
    80014562:	0aa58593          	addi	a1,a1,170 # 80021608 <pow10.0+0x3d8>
    80014566:	853e                	mv	a0,a5
    80014568:	0b8060ef          	jal	ra,8001a620 <virtio_set_device_name>
    gpu_device->ready = true;
    8001456c:	0000c797          	auipc	a5,0xc
    80014570:	b2c78793          	addi	a5,a5,-1236 # 80020098 <gpu_device>
    80014574:	639c                	ld	a5,0(a5)
    80014576:	4705                	li	a4,1
    80014578:	08e78723          	sb	a4,142(a5)
    volatile VirtioGpuConfig *config = virtio_get_gpu_config(gpu_device);
    8001457c:	0000c797          	auipc	a5,0xc
    80014580:	b1c78793          	addi	a5,a5,-1252 # 80020098 <gpu_device>
    80014584:	639c                	ld	a5,0(a5)
    80014586:	853e                	mv	a0,a5
    80014588:	161050ef          	jal	ra,80019ee8 <virtio_get_gpu_config>
    8001458c:	fea43423          	sd	a0,-24(s0)
    debugf("GPU device has %d events that needs to be read\n", config->events_read);
    80014590:	fe843783          	ld	a5,-24(s0)
    80014594:	439c                	lw	a5,0(a5)
    80014596:	2781                	sext.w	a5,a5
    80014598:	85be                	mv	a1,a5
    8001459a:	0000d517          	auipc	a0,0xd
    8001459e:	07e50513          	addi	a0,a0,126 # 80021618 <pow10.0+0x3e8>
    800145a2:	463040ef          	jal	ra,80019204 <debugf>
    debugf("GPU device has %d scanouts\n", config->num_scanouts);
    800145a6:	fe843783          	ld	a5,-24(s0)
    800145aa:	479c                	lw	a5,8(a5)
    800145ac:	2781                	sext.w	a5,a5
    800145ae:	85be                	mv	a1,a5
    800145b0:	0000d517          	auipc	a0,0xd
    800145b4:	09850513          	addi	a0,a0,152 # 80021648 <pow10.0+0x418>
    800145b8:	44d040ef          	jal	ra,80019204 <debugf>
}
    800145bc:	0001                	nop
    800145be:	60e2                	ld	ra,24(sp)
    800145c0:	6442                	ld	s0,16(sp)
    800145c2:	6105                	addi	sp,sp,32
    800145c4:	8082                	ret

00000000800145c6 <gpu_init>:

// TODO: Implement checking for error responses
bool gpu_init(VirtioDevice *gpu_device) {
    800145c6:	d1010113          	addi	sp,sp,-752
    800145ca:	2e113423          	sd	ra,744(sp)
    800145ce:	2e813023          	sd	s0,736(sp)
    800145d2:	1d80                	addi	s0,sp,752
    800145d4:	d0a43c23          	sd	a0,-744(s0)
    VirtioGpuDispInfoResp disp_info;
    gpu_get_display_info(gpu_device, &disp_info);
    800145d8:	e5840793          	addi	a5,s0,-424
    800145dc:	85be                	mv	a1,a5
    800145de:	d1843503          	ld	a0,-744(s0)
    800145e2:	52c000ef          	jal	ra,80014b0e <gpu_get_display_info>
    
    // Allocate memory for frame buffer
    console.width = disp_info.displays[0].rect.width;
    800145e6:	e7842703          	lw	a4,-392(s0)
    800145ea:	0000c797          	auipc	a5,0xc
    800145ee:	ab678793          	addi	a5,a5,-1354 # 800200a0 <console>
    800145f2:	c398                	sw	a4,0(a5)
    console.height = disp_info.displays[0].rect.height;
    800145f4:	e7c42703          	lw	a4,-388(s0)
    800145f8:	0000c797          	auipc	a5,0xc
    800145fc:	aa878793          	addi	a5,a5,-1368 # 800200a0 <console>
    80014600:	c3d8                	sw	a4,4(a5)
    console.frame_buf = kcalloc(console.width * console.height, sizeof(Pixel));
    80014602:	0000c797          	auipc	a5,0xc
    80014606:	a9e78793          	addi	a5,a5,-1378 # 800200a0 <console>
    8001460a:	4398                	lw	a4,0(a5)
    8001460c:	0000c797          	auipc	a5,0xc
    80014610:	a9478793          	addi	a5,a5,-1388 # 800200a0 <console>
    80014614:	43dc                	lw	a5,4(a5)
    80014616:	02f707bb          	mulw	a5,a4,a5
    8001461a:	2781                	sext.w	a5,a5
    8001461c:	1782                	slli	a5,a5,0x20
    8001461e:	9381                	srli	a5,a5,0x20
    80014620:	4591                	li	a1,4
    80014622:	853e                	mv	a0,a5
    80014624:	e92ff0ef          	jal	ra,80013cb6 <kcalloc>
    80014628:	872a                	mv	a4,a0
    8001462a:	0000c797          	auipc	a5,0xc
    8001462e:	a7678793          	addi	a5,a5,-1418 # 800200a0 <console>
    80014632:	e798                	sd	a4,8(a5)
    debugf("gpu_init: Allocated frame buffer of (%d * %d) bytes at %p\n",
           sizeof(Pixel), console.width * console.height, console.frame_buf);
    80014634:	0000c797          	auipc	a5,0xc
    80014638:	a6c78793          	addi	a5,a5,-1428 # 800200a0 <console>
    8001463c:	4398                	lw	a4,0(a5)
    8001463e:	0000c797          	auipc	a5,0xc
    80014642:	a6278793          	addi	a5,a5,-1438 # 800200a0 <console>
    80014646:	43dc                	lw	a5,4(a5)
    debugf("gpu_init: Allocated frame buffer of (%d * %d) bytes at %p\n",
    80014648:	02f707bb          	mulw	a5,a4,a5
    8001464c:	0007871b          	sext.w	a4,a5
    80014650:	0000c797          	auipc	a5,0xc
    80014654:	a5078793          	addi	a5,a5,-1456 # 800200a0 <console>
    80014658:	679c                	ld	a5,8(a5)
    8001465a:	86be                	mv	a3,a5
    8001465c:	863a                	mv	a2,a4
    8001465e:	4591                	li	a1,4
    80014660:	0000d517          	auipc	a0,0xd
    80014664:	00850513          	addi	a0,a0,8 # 80021668 <pow10.0+0x438>
    80014668:	39d040ef          	jal	ra,80019204 <debugf>

    VirtioGpuResCreate2d res2d;
    res2d.hdr.type = VIRTIO_GPU_CMD_RESOURCE_CREATE_2D;
    8001466c:	10100793          	li	a5,257
    80014670:	e2f42823          	sw	a5,-464(s0)
    res2d.resource_id = 1; // Give an arbitrary unique number
    80014674:	4785                	li	a5,1
    80014676:	e4f42423          	sw	a5,-440(s0)
    res2d.format = R8G8B8A8_UNORM;
    8001467a:	04300793          	li	a5,67
    8001467e:	e4f42623          	sw	a5,-436(s0)
    res2d.width = console.width;
    80014682:	0000c797          	auipc	a5,0xc
    80014686:	a1e78793          	addi	a5,a5,-1506 # 800200a0 <console>
    8001468a:	439c                	lw	a5,0(a5)
    8001468c:	e4f42823          	sw	a5,-432(s0)
    res2d.height = console.height;
    80014690:	0000c797          	auipc	a5,0xc
    80014694:	a1078793          	addi	a5,a5,-1520 # 800200a0 <console>
    80014698:	43dc                	lw	a5,4(a5)
    8001469a:	e4f42a23          	sw	a5,-428(s0)

    VirtioGpuCtrlHdr resp_hdr;
    resp_hdr.type = 0;
    8001469e:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &res2d, sizeof(res2d), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    800146a2:	e1840793          	addi	a5,s0,-488
    800146a6:	e3040613          	addi	a2,s0,-464
    800146aa:	48e1                	li	a7,24
    800146ac:	883e                	mv	a6,a5
    800146ae:	4781                	li	a5,0
    800146b0:	4701                	li	a4,0
    800146b2:	02800693          	li	a3,40
    800146b6:	4581                	li	a1,0
    800146b8:	d1843503          	ld	a0,-744(s0)
    800146bc:	2f4000ef          	jal	ra,800149b0 <gpu_send_command>
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    800146c0:	e1842783          	lw	a5,-488(s0)
    800146c4:	873e                	mv	a4,a5
    800146c6:	6785                	lui	a5,0x1
    800146c8:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    800146cc:	00f71863          	bne	a4,a5,800146dc <gpu_init+0x116>
        debugf("gpu_init: Create 2D resource OK\n");
    800146d0:	0000d517          	auipc	a0,0xd
    800146d4:	fd850513          	addi	a0,a0,-40 # 800216a8 <pow10.0+0x478>
    800146d8:	32d040ef          	jal	ra,80019204 <debugf>
        // return false;
    }

    // Attach resource 2D
    VirtioGpuResourceAttachBacking attach_backing;
    attach_backing.hdr.type = VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING;
    800146dc:	10600793          	li	a5,262
    800146e0:	def42c23          	sw	a5,-520(s0)
    attach_backing.resource_id = 1;
    800146e4:	4785                	li	a5,1
    800146e6:	e0f42823          	sw	a5,-496(s0)
    attach_backing.nr_entries = 1;
    800146ea:	4785                	li	a5,1
    800146ec:	e0f42a23          	sw	a5,-492(s0)
    VirtioGpuMemEntry mem;
    // mem.addr = kernel_mmu_translate((uintptr_t)console.frame_buf
    mem.addr = kernel_mmu_translate((uintptr_t)console.frame_buf);
    800146f0:	0000c797          	auipc	a5,0xc
    800146f4:	9b078793          	addi	a5,a5,-1616 # 800200a0 <console>
    800146f8:	679c                	ld	a5,8(a5)
    800146fa:	853e                	mv	a0,a5
    800146fc:	aedff0ef          	jal	ra,800141e8 <kernel_mmu_translate>
    80014700:	87aa                	mv	a5,a0
    80014702:	def43423          	sd	a5,-536(s0)
    mem.length = console.width * console.width * sizeof(Pixel);
    80014706:	0000c797          	auipc	a5,0xc
    8001470a:	99a78793          	addi	a5,a5,-1638 # 800200a0 <console>
    8001470e:	4398                	lw	a4,0(a5)
    80014710:	0000c797          	auipc	a5,0xc
    80014714:	99078793          	addi	a5,a5,-1648 # 800200a0 <console>
    80014718:	439c                	lw	a5,0(a5)
    8001471a:	02f707bb          	mulw	a5,a4,a5
    8001471e:	2781                	sext.w	a5,a5
    80014720:	0027979b          	slliw	a5,a5,0x2
    80014724:	2781                	sext.w	a5,a5
    80014726:	def42823          	sw	a5,-528(s0)
    mem.padding = 0;
    8001472a:	de042a23          	sw	zero,-524(s0)
    resp_hdr.type = 0;
    8001472e:	e0042c23          	sw	zero,-488(s0)
    
    gpu_send_command(gpu_device, 0, &attach_backing, sizeof(attach_backing), &mem, sizeof(mem), &resp_hdr, sizeof(resp_hdr));
    80014732:	e1840793          	addi	a5,s0,-488
    80014736:	de840713          	addi	a4,s0,-536
    8001473a:	df840613          	addi	a2,s0,-520
    8001473e:	48e1                	li	a7,24
    80014740:	883e                	mv	a6,a5
    80014742:	47c1                	li	a5,16
    80014744:	02000693          	li	a3,32
    80014748:	4581                	li	a1,0
    8001474a:	d1843503          	ld	a0,-744(s0)
    8001474e:	262000ef          	jal	ra,800149b0 <gpu_send_command>

    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    80014752:	e1842783          	lw	a5,-488(s0)
    80014756:	873e                	mv	a4,a5
    80014758:	6785                	lui	a5,0x1
    8001475a:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    8001475e:	00f71863          	bne	a4,a5,8001476e <gpu_init+0x1a8>
        debugf("gpu_init: Attach backing OK\n");
    80014762:	0000d517          	auipc	a0,0xd
    80014766:	f6e50513          	addi	a0,a0,-146 # 800216d0 <pow10.0+0x4a0>
    8001476a:	29b040ef          	jal	ra,80019204 <debugf>
        // debugf("gpu_init: Attach backing failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    VirtioGpuSetScanout scan;
    scan.hdr.type = VIRTIO_GPU_CMD_SET_SCANOUT;
    8001476e:	10300793          	li	a5,259
    80014772:	daf42c23          	sw	a5,-584(s0)
    scan.rect.x = 0;
    80014776:	dc042823          	sw	zero,-560(s0)
    scan.rect.y = 0;
    8001477a:	dc042a23          	sw	zero,-556(s0)
    scan.rect.width = console.width;
    8001477e:	0000c797          	auipc	a5,0xc
    80014782:	92278793          	addi	a5,a5,-1758 # 800200a0 <console>
    80014786:	439c                	lw	a5,0(a5)
    80014788:	dcf42c23          	sw	a5,-552(s0)
    scan.rect.height = console.height;
    8001478c:	0000c797          	auipc	a5,0xc
    80014790:	91478793          	addi	a5,a5,-1772 # 800200a0 <console>
    80014794:	43dc                	lw	a5,4(a5)
    80014796:	dcf42e23          	sw	a5,-548(s0)
    scan.resource_id = 1;
    8001479a:	4785                	li	a5,1
    8001479c:	def42223          	sw	a5,-540(s0)
    scan.scanout_id = 0;
    800147a0:	de042023          	sw	zero,-544(s0)
    resp_hdr.type = 0;
    800147a4:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &scan, sizeof(scan), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    800147a8:	e1840793          	addi	a5,s0,-488
    800147ac:	db840613          	addi	a2,s0,-584
    800147b0:	48e1                	li	a7,24
    800147b2:	883e                	mv	a6,a5
    800147b4:	4781                	li	a5,0
    800147b6:	4701                	li	a4,0
    800147b8:	03000693          	li	a3,48
    800147bc:	4581                	li	a1,0
    800147be:	d1843503          	ld	a0,-744(s0)
    800147c2:	1ee000ef          	jal	ra,800149b0 <gpu_send_command>

    Rectangle r1 = {0, 0, console.width, console.height};
    800147c6:	da042423          	sw	zero,-600(s0)
    800147ca:	da042623          	sw	zero,-596(s0)
    800147ce:	0000c797          	auipc	a5,0xc
    800147d2:	8d278793          	addi	a5,a5,-1838 # 800200a0 <console>
    800147d6:	439c                	lw	a5,0(a5)
    800147d8:	daf42823          	sw	a5,-592(s0)
    800147dc:	0000c797          	auipc	a5,0xc
    800147e0:	8c478793          	addi	a5,a5,-1852 # 800200a0 <console>
    800147e4:	43dc                	lw	a5,4(a5)
    800147e6:	daf42a23          	sw	a5,-588(s0)
    Rectangle r2 = {100, 100, console.width - 150, console.height - 150};
    800147ea:	06400793          	li	a5,100
    800147ee:	d8f42c23          	sw	a5,-616(s0)
    800147f2:	06400793          	li	a5,100
    800147f6:	d8f42e23          	sw	a5,-612(s0)
    800147fa:	0000c797          	auipc	a5,0xc
    800147fe:	8a678793          	addi	a5,a5,-1882 # 800200a0 <console>
    80014802:	439c                	lw	a5,0(a5)
    80014804:	f6a7879b          	addiw	a5,a5,-150
    80014808:	2781                	sext.w	a5,a5
    8001480a:	daf42023          	sw	a5,-608(s0)
    8001480e:	0000c797          	auipc	a5,0xc
    80014812:	89278793          	addi	a5,a5,-1902 # 800200a0 <console>
    80014816:	43dc                	lw	a5,4(a5)
    80014818:	f6a7879b          	addiw	a5,a5,-150
    8001481c:	2781                	sext.w	a5,a5
    8001481e:	daf42223          	sw	a5,-604(s0)
    Pixel p1 = {255, 100, 50, 255};
    80014822:	0000f797          	auipc	a5,0xf
    80014826:	bae78793          	addi	a5,a5,-1106 # 800233d0 <NUM_SYSCALLS+0x8>
    8001482a:	439c                	lw	a5,0(a5)
    8001482c:	d8f42823          	sw	a5,-624(s0)
    Pixel p2 = {88, 89, 91, 255};
    80014830:	0000f797          	auipc	a5,0xf
    80014834:	ba878793          	addi	a5,a5,-1112 # 800233d8 <NUM_SYSCALLS+0x10>
    80014838:	439c                	lw	a5,0(a5)
    8001483a:	d8f42423          	sw	a5,-632(s0)

    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    8001483e:	e1842783          	lw	a5,-488(s0)
    80014842:	873e                	mv	a4,a5
    80014844:	6785                	lui	a5,0x1
    80014846:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    8001484a:	00f71863          	bne	a4,a5,8001485a <gpu_init+0x294>
        debugf("gpu_init: Set scanout OK\n");
    8001484e:	0000d517          	auipc	a0,0xd
    80014852:	ea250513          	addi	a0,a0,-350 # 800216f0 <pow10.0+0x4c0>
    80014856:	1af040ef          	jal	ra,80019204 <debugf>
    } else {
        // debugf("gpu_init: Set scanout failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    fill_rect(console.width, console.height, console.frame_buf, &r1, &p1);
    8001485a:	0000c797          	auipc	a5,0xc
    8001485e:	84678793          	addi	a5,a5,-1978 # 800200a0 <console>
    80014862:	4388                	lw	a0,0(a5)
    80014864:	0000c797          	auipc	a5,0xc
    80014868:	83c78793          	addi	a5,a5,-1988 # 800200a0 <console>
    8001486c:	43cc                	lw	a1,4(a5)
    8001486e:	0000c797          	auipc	a5,0xc
    80014872:	83278793          	addi	a5,a5,-1998 # 800200a0 <console>
    80014876:	679c                	ld	a5,8(a5)
    80014878:	d9040713          	addi	a4,s0,-624
    8001487c:	da840693          	addi	a3,s0,-600
    80014880:	863e                	mv	a2,a5
    80014882:	448000ef          	jal	ra,80014cca <fill_rect>
    stroke_rect(console.width, console.height, console.frame_buf, &r2, &p2, 10);
    80014886:	0000c797          	auipc	a5,0xc
    8001488a:	81a78793          	addi	a5,a5,-2022 # 800200a0 <console>
    8001488e:	4388                	lw	a0,0(a5)
    80014890:	0000c797          	auipc	a5,0xc
    80014894:	81078793          	addi	a5,a5,-2032 # 800200a0 <console>
    80014898:	43cc                	lw	a1,4(a5)
    8001489a:	0000c797          	auipc	a5,0xc
    8001489e:	80678793          	addi	a5,a5,-2042 # 800200a0 <console>
    800148a2:	6790                	ld	a2,8(a5)
    800148a4:	d8840713          	addi	a4,s0,-632
    800148a8:	d9840693          	addi	a3,s0,-616
    800148ac:	47a9                	li	a5,10
    800148ae:	58c000ef          	jal	ra,80014e3a <stroke_rect>

    VirtioGpuTransferToHost2d tx;
    tx.hdr.type = VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D;
    800148b2:	10500793          	li	a5,261
    800148b6:	d4f42823          	sw	a5,-688(s0)
    tx.rect.x = 0;
    800148ba:	d6042423          	sw	zero,-664(s0)
    tx.rect.y = 0;
    800148be:	d6042623          	sw	zero,-660(s0)
    tx.rect.width = console.width;
    800148c2:	0000b797          	auipc	a5,0xb
    800148c6:	7de78793          	addi	a5,a5,2014 # 800200a0 <console>
    800148ca:	439c                	lw	a5,0(a5)
    800148cc:	d6f42823          	sw	a5,-656(s0)
    tx.rect.height = console.height;
    800148d0:	0000b797          	auipc	a5,0xb
    800148d4:	7d078793          	addi	a5,a5,2000 # 800200a0 <console>
    800148d8:	43dc                	lw	a5,4(a5)
    800148da:	d6f42a23          	sw	a5,-652(s0)
    tx.offset = 0;
    800148de:	d6043c23          	sd	zero,-648(s0)
    tx.resource_id = 1;
    800148e2:	4785                	li	a5,1
    800148e4:	d8f42023          	sw	a5,-640(s0)
    tx.padding = 0;
    800148e8:	d8042223          	sw	zero,-636(s0)
    resp_hdr.type = 0;
    800148ec:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &tx, sizeof(tx), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    800148f0:	e1840793          	addi	a5,s0,-488
    800148f4:	d5040613          	addi	a2,s0,-688
    800148f8:	48e1                	li	a7,24
    800148fa:	883e                	mv	a6,a5
    800148fc:	4781                	li	a5,0
    800148fe:	4701                	li	a4,0
    80014900:	03800693          	li	a3,56
    80014904:	4581                	li	a1,0
    80014906:	d1843503          	ld	a0,-744(s0)
    8001490a:	0a6000ef          	jal	ra,800149b0 <gpu_send_command>
    
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    8001490e:	e1842783          	lw	a5,-488(s0)
    80014912:	873e                	mv	a4,a5
    80014914:	6785                	lui	a5,0x1
    80014916:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    8001491a:	00f71863          	bne	a4,a5,8001492a <gpu_init+0x364>
        debugf("gpu_init: Transfer OK\n");
    8001491e:	0000d517          	auipc	a0,0xd
    80014922:	df250513          	addi	a0,a0,-526 # 80021710 <pow10.0+0x4e0>
    80014926:	0df040ef          	jal	ra,80019204 <debugf>
        // debugf("gpu_init: Transfer failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    VirtioGpuResourceFlush flush;
    flush.hdr.type = VIRTIO_GPU_CMD_RESOURCE_FLUSH;
    8001492a:	10400793          	li	a5,260
    8001492e:	d2f42023          	sw	a5,-736(s0)
    flush.rect.x = 0;
    80014932:	d2042c23          	sw	zero,-712(s0)
    flush.rect.y = 0;
    80014936:	d2042e23          	sw	zero,-708(s0)
    flush.rect.width = console.width;
    8001493a:	0000b797          	auipc	a5,0xb
    8001493e:	76678793          	addi	a5,a5,1894 # 800200a0 <console>
    80014942:	439c                	lw	a5,0(a5)
    80014944:	d4f42023          	sw	a5,-704(s0)
    flush.rect.height = console.height;
    80014948:	0000b797          	auipc	a5,0xb
    8001494c:	75878793          	addi	a5,a5,1880 # 800200a0 <console>
    80014950:	43dc                	lw	a5,4(a5)
    80014952:	d4f42223          	sw	a5,-700(s0)
    flush.resource_id = 1;
    80014956:	4785                	li	a5,1
    80014958:	d4f42423          	sw	a5,-696(s0)
    flush.padding = 0;
    8001495c:	d4042623          	sw	zero,-692(s0)
    resp_hdr.type = 0;
    80014960:	e0042c23          	sw	zero,-488(s0)
    gpu_send_command(gpu_device, 0, &flush, sizeof(flush), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    80014964:	e1840793          	addi	a5,s0,-488
    80014968:	d2040613          	addi	a2,s0,-736
    8001496c:	48e1                	li	a7,24
    8001496e:	883e                	mv	a6,a5
    80014970:	4781                	li	a5,0
    80014972:	4701                	li	a4,0
    80014974:	03000693          	li	a3,48
    80014978:	4581                	li	a1,0
    8001497a:	d1843503          	ld	a0,-744(s0)
    8001497e:	032000ef          	jal	ra,800149b0 <gpu_send_command>
    
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    80014982:	e1842783          	lw	a5,-488(s0)
    80014986:	873e                	mv	a4,a5
    80014988:	6785                	lui	a5,0x1
    8001498a:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    8001498e:	00f71863          	bne	a4,a5,8001499e <gpu_init+0x3d8>
        debugf("gpu_init: Flush OK\n");
    80014992:	0000d517          	auipc	a0,0xd
    80014996:	d9650513          	addi	a0,a0,-618 # 80021728 <pow10.0+0x4f8>
    8001499a:	06b040ef          	jal	ra,80019204 <debugf>
    } else {
        // debugf("gpu_init: Flush failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    return true;
    8001499e:	4785                	li	a5,1
}
    800149a0:	853e                	mv	a0,a5
    800149a2:	2e813083          	ld	ra,744(sp)
    800149a6:	2e013403          	ld	s0,736(sp)
    800149aa:	2f010113          	addi	sp,sp,752
    800149ae:	8082                	ret

00000000800149b0 <gpu_send_command>:
                      void *cmd,
                      size_t cmd_size,
                      void *resp0,
                      size_t resp0_size,
                      void *resp1,
                      size_t resp1_size) {
    800149b0:	7115                	addi	sp,sp,-224
    800149b2:	ed86                	sd	ra,216(sp)
    800149b4:	e9a2                	sd	s0,208(sp)
    800149b6:	1180                	addi	s0,sp,224
    800149b8:	f4a43c23          	sd	a0,-168(s0)
    800149bc:	f4c43423          	sd	a2,-184(s0)
    800149c0:	f4d43023          	sd	a3,-192(s0)
    800149c4:	f2e43c23          	sd	a4,-200(s0)
    800149c8:	f2f43823          	sd	a5,-208(s0)
    800149cc:	f3043423          	sd	a6,-216(s0)
    800149d0:	f3143023          	sd	a7,-224(s0)
    800149d4:	87ae                	mv	a5,a1
    800149d6:	f4f41b23          	sh	a5,-170(s0)
    VirtioDescriptor cmd_desc;
    cmd_desc.addr = kernel_mmu_translate((uintptr_t)cmd);
    800149da:	f4843783          	ld	a5,-184(s0)
    800149de:	853e                	mv	a0,a5
    800149e0:	809ff0ef          	jal	ra,800141e8 <kernel_mmu_translate>
    800149e4:	87aa                	mv	a5,a0
    800149e6:	fcf43823          	sd	a5,-48(s0)
    cmd_desc.len = cmd_size;
    800149ea:	f4043783          	ld	a5,-192(s0)
    800149ee:	2781                	sext.w	a5,a5
    800149f0:	fcf42c23          	sw	a5,-40(s0)
    cmd_desc.flags = VIRTQ_DESC_F_NEXT;
    800149f4:	4785                	li	a5,1
    800149f6:	fcf41e23          	sh	a5,-36(s0)

    VirtioDescriptor resp0_desc;
    resp0_desc.addr = kernel_mmu_translate((uintptr_t)resp0);
    800149fa:	f3843783          	ld	a5,-200(s0)
    800149fe:	853e                	mv	a0,a5
    80014a00:	fe8ff0ef          	jal	ra,800141e8 <kernel_mmu_translate>
    80014a04:	87aa                	mv	a5,a0
    80014a06:	fcf43023          	sd	a5,-64(s0)
    resp0_desc.len = resp0_size;
    80014a0a:	f3043783          	ld	a5,-208(s0)
    80014a0e:	2781                	sext.w	a5,a5
    80014a10:	fcf42423          	sw	a5,-56(s0)
    resp0_desc.flags = VIRTQ_DESC_F_NEXT;
    80014a14:	4785                	li	a5,1
    80014a16:	fcf41623          	sh	a5,-52(s0)
    
    VirtioDescriptor resp1_desc;
    resp1_desc.addr = kernel_mmu_translate((uintptr_t)resp1);
    80014a1a:	f2843783          	ld	a5,-216(s0)
    80014a1e:	853e                	mv	a0,a5
    80014a20:	fc8ff0ef          	jal	ra,800141e8 <kernel_mmu_translate>
    80014a24:	87aa                	mv	a5,a0
    80014a26:	faf43823          	sd	a5,-80(s0)
    resp1_desc.len = resp1_size;
    80014a2a:	f2043783          	ld	a5,-224(s0)
    80014a2e:	2781                	sext.w	a5,a5
    80014a30:	faf42c23          	sw	a5,-72(s0)
    resp1_desc.flags = VIRTQ_DESC_F_WRITE;
    80014a34:	4789                	li	a5,2
    80014a36:	faf41e23          	sh	a5,-68(s0)

    VirtioDescriptor chain0[2] = {cmd_desc, resp1_desc};
    80014a3a:	fd043783          	ld	a5,-48(s0)
    80014a3e:	f8f43823          	sd	a5,-112(s0)
    80014a42:	fd843783          	ld	a5,-40(s0)
    80014a46:	f8f43c23          	sd	a5,-104(s0)
    80014a4a:	fb043783          	ld	a5,-80(s0)
    80014a4e:	faf43023          	sd	a5,-96(s0)
    80014a52:	fb843783          	ld	a5,-72(s0)
    80014a56:	faf43423          	sd	a5,-88(s0)
    VirtioDescriptor chain1[3] = {cmd_desc, resp0_desc, resp1_desc};
    80014a5a:	fd043783          	ld	a5,-48(s0)
    80014a5e:	f6f43023          	sd	a5,-160(s0)
    80014a62:	fd843783          	ld	a5,-40(s0)
    80014a66:	f6f43423          	sd	a5,-152(s0)
    80014a6a:	fc043783          	ld	a5,-64(s0)
    80014a6e:	f6f43823          	sd	a5,-144(s0)
    80014a72:	fc843783          	ld	a5,-56(s0)
    80014a76:	f6f43c23          	sd	a5,-136(s0)
    80014a7a:	fb043783          	ld	a5,-80(s0)
    80014a7e:	f8f43023          	sd	a5,-128(s0)
    80014a82:	fb843783          	ld	a5,-72(s0)
    80014a86:	f8f43423          	sd	a5,-120(s0)
    VirtioDescriptor *chain = resp0 == NULL ? chain0 : chain1;
    80014a8a:	f3843783          	ld	a5,-200(s0)
    80014a8e:	e781                	bnez	a5,80014a96 <gpu_send_command+0xe6>
    80014a90:	f9040793          	addi	a5,s0,-112
    80014a94:	a019                	j	80014a9a <gpu_send_command+0xea>
    80014a96:	f6040793          	addi	a5,s0,-160
    80014a9a:	fef43423          	sd	a5,-24(s0)
    unsigned num_descriptors = resp0 == NULL ? 2 : 3;
    80014a9e:	f3843783          	ld	a5,-200(s0)
    80014aa2:	e399                	bnez	a5,80014aa8 <gpu_send_command+0xf8>
    80014aa4:	4789                	li	a5,2
    80014aa6:	a011                	j	80014aaa <gpu_send_command+0xfa>
    80014aa8:	478d                	li	a5,3
    80014aaa:	fef42223          	sw	a5,-28(s0)
    virtio_send_descriptor_chain(gpu_device, which_queue, chain, num_descriptors, true);
    80014aae:	fe442783          	lw	a5,-28(s0)
    80014ab2:	03079693          	slli	a3,a5,0x30
    80014ab6:	92c1                	srli	a3,a3,0x30
    80014ab8:	f5645783          	lhu	a5,-170(s0)
    80014abc:	4705                	li	a4,1
    80014abe:	fe843603          	ld	a2,-24(s0)
    80014ac2:	85be                	mv	a1,a5
    80014ac4:	f5843503          	ld	a0,-168(s0)
    80014ac8:	57f050ef          	jal	ra,8001a846 <virtio_send_descriptor_chain>
    
    // Wait until device_idx catches up 
    while (gpu_device->device_idx != gpu_device->device->idx) {
    80014acc:	a039                	j	80014ada <gpu_send_command+0x12a>
        debugf("GPU WAITING\n");
    80014ace:	0000d517          	auipc	a0,0xd
    80014ad2:	c7250513          	addi	a0,a0,-910 # 80021740 <pow10.0+0x510>
    80014ad6:	72e040ef          	jal	ra,80019204 <debugf>
    while (gpu_device->device_idx != gpu_device->device->idx) {
    80014ada:	f5843783          	ld	a5,-168(s0)
    80014ade:	08c7d703          	lhu	a4,140(a5)
    80014ae2:	f5843783          	ld	a5,-168(s0)
    80014ae6:	7bbc                	ld	a5,112(a5)
    80014ae8:	0027d783          	lhu	a5,2(a5)
    80014aec:	17c2                	slli	a5,a5,0x30
    80014aee:	93c1                	srli	a5,a5,0x30
    80014af0:	2701                	sext.w	a4,a4
    80014af2:	2781                	sext.w	a5,a5
    80014af4:	fcf71de3          	bne	a4,a5,80014ace <gpu_send_command+0x11e>
    }
    debugf("gpu_send_command: device_idx caught up\n");
    80014af8:	0000d517          	auipc	a0,0xd
    80014afc:	c5850513          	addi	a0,a0,-936 # 80021750 <pow10.0+0x520>
    80014b00:	704040ef          	jal	ra,80019204 <debugf>
}
    80014b04:	0001                	nop
    80014b06:	60ee                	ld	ra,216(sp)
    80014b08:	644e                	ld	s0,208(sp)
    80014b0a:	612d                	addi	sp,sp,224
    80014b0c:	8082                	ret

0000000080014b0e <gpu_get_display_info>:

// Get display info and set frame buffer's info.
// Return true if display is enabled. Return false if not.
bool gpu_get_display_info(VirtioDevice *gpu_device,
                          VirtioGpuDispInfoResp *disp_resp) {
    80014b0e:	7119                	addi	sp,sp,-128
    80014b10:	fc86                	sd	ra,120(sp)
    80014b12:	f8a2                	sd	s0,112(sp)
    80014b14:	0100                	addi	s0,sp,128
    80014b16:	f8a43423          	sd	a0,-120(s0)
    80014b1a:	f8b43023          	sd	a1,-128(s0)
    VirtioGpuCtrlHdr hdr;
    hdr.type = VIRTIO_GPU_CMD_GET_DISPLAY_INFO;
    80014b1e:	10000793          	li	a5,256
    80014b22:	fcf42c23          	sw	a5,-40(s0)
    hdr.flags = 0;
    80014b26:	fc042e23          	sw	zero,-36(s0)
    hdr.fence_id = 0;
    80014b2a:	fe043023          	sd	zero,-32(s0)
    hdr.context_id = 0;
    80014b2e:	fe042423          	sw	zero,-24(s0)
    hdr.padding = 0;
    80014b32:	fe042623          	sw	zero,-20(s0)

    VirtioDescriptor hdr_desc;
    hdr_desc.addr = kernel_mmu_translate((uintptr_t)&hdr);
    80014b36:	fd840793          	addi	a5,s0,-40
    80014b3a:	853e                	mv	a0,a5
    80014b3c:	eacff0ef          	jal	ra,800141e8 <kernel_mmu_translate>
    80014b40:	87aa                	mv	a5,a0
    80014b42:	fcf43423          	sd	a5,-56(s0)
    hdr_desc.len = sizeof(hdr);
    80014b46:	47e1                	li	a5,24
    80014b48:	fcf42823          	sw	a5,-48(s0)
    hdr_desc.flags = VIRTQ_DESC_F_NEXT;
    80014b4c:	4785                	li	a5,1
    80014b4e:	fcf41a23          	sh	a5,-44(s0)

    VirtioDescriptor disp_resp_desc;
    disp_resp_desc.addr = kernel_mmu_translate((uintptr_t)disp_resp);
    80014b52:	f8043783          	ld	a5,-128(s0)
    80014b56:	853e                	mv	a0,a5
    80014b58:	e90ff0ef          	jal	ra,800141e8 <kernel_mmu_translate>
    80014b5c:	87aa                	mv	a5,a0
    80014b5e:	faf43c23          	sd	a5,-72(s0)
    disp_resp_desc.len = sizeof(VirtioGpuDispInfoResp);
    80014b62:	19800793          	li	a5,408
    80014b66:	fcf42023          	sw	a5,-64(s0)
    disp_resp_desc.flags = VIRTQ_DESC_F_WRITE;
    80014b6a:	4789                	li	a5,2
    80014b6c:	fcf41223          	sh	a5,-60(s0)

    VirtioDescriptor chain[2] = {hdr_desc, disp_resp_desc};
    80014b70:	fc843783          	ld	a5,-56(s0)
    80014b74:	f8f43c23          	sd	a5,-104(s0)
    80014b78:	fd043783          	ld	a5,-48(s0)
    80014b7c:	faf43023          	sd	a5,-96(s0)
    80014b80:	fb843783          	ld	a5,-72(s0)
    80014b84:	faf43423          	sd	a5,-88(s0)
    80014b88:	fc043783          	ld	a5,-64(s0)
    80014b8c:	faf43823          	sd	a5,-80(s0)

    virtio_send_descriptor_chain(gpu_device, 0, chain, 2, true);
    80014b90:	f9840793          	addi	a5,s0,-104
    80014b94:	4705                	li	a4,1
    80014b96:	4689                	li	a3,2
    80014b98:	863e                	mv	a2,a5
    80014b9a:	4581                	li	a1,0
    80014b9c:	f8843503          	ld	a0,-120(s0)
    80014ba0:	4a7050ef          	jal	ra,8001a846 <virtio_send_descriptor_chain>

    debugf("Internal desc_idx: %d\n", gpu_device->desc_idx);
    80014ba4:	f8843783          	ld	a5,-120(s0)
    80014ba8:	0887d783          	lhu	a5,136(a5)
    80014bac:	2781                	sext.w	a5,a5
    80014bae:	85be                	mv	a1,a5
    80014bb0:	0000d517          	auipc	a0,0xd
    80014bb4:	bc850513          	addi	a0,a0,-1080 # 80021778 <pow10.0+0x548>
    80014bb8:	64c040ef          	jal	ra,80019204 <debugf>
    debugf("Internal driver_idx: %d\n", gpu_device->driver_idx);
    80014bbc:	f8843783          	ld	a5,-120(s0)
    80014bc0:	08a7d783          	lhu	a5,138(a5)
    80014bc4:	2781                	sext.w	a5,a5
    80014bc6:	85be                	mv	a1,a5
    80014bc8:	0000d517          	auipc	a0,0xd
    80014bcc:	bc850513          	addi	a0,a0,-1080 # 80021790 <pow10.0+0x560>
    80014bd0:	634040ef          	jal	ra,80019204 <debugf>
    debugf("Internal device_idx: %d\n", gpu_device->device_idx);
    80014bd4:	f8843783          	ld	a5,-120(s0)
    80014bd8:	08c7d783          	lhu	a5,140(a5)
    80014bdc:	2781                	sext.w	a5,a5
    80014bde:	85be                	mv	a1,a5
    80014be0:	0000d517          	auipc	a0,0xd
    80014be4:	bd050513          	addi	a0,a0,-1072 # 800217b0 <pow10.0+0x580>
    80014be8:	61c040ef          	jal	ra,80019204 <debugf>
    debugf("Driver ring index: %d\n", gpu_device->driver->idx);
    80014bec:	f8843783          	ld	a5,-120(s0)
    80014bf0:	77bc                	ld	a5,104(a5)
    80014bf2:	0027d783          	lhu	a5,2(a5)
    80014bf6:	17c2                	slli	a5,a5,0x30
    80014bf8:	93c1                	srli	a5,a5,0x30
    80014bfa:	2781                	sext.w	a5,a5
    80014bfc:	85be                	mv	a1,a5
    80014bfe:	0000d517          	auipc	a0,0xd
    80014c02:	bd250513          	addi	a0,a0,-1070 # 800217d0 <pow10.0+0x5a0>
    80014c06:	5fe040ef          	jal	ra,80019204 <debugf>
    debugf("Device ring index: %d\n", gpu_device->device->idx);
    80014c0a:	f8843783          	ld	a5,-120(s0)
    80014c0e:	7bbc                	ld	a5,112(a5)
    80014c10:	0027d783          	lhu	a5,2(a5)
    80014c14:	17c2                	slli	a5,a5,0x30
    80014c16:	93c1                	srli	a5,a5,0x30
    80014c18:	2781                	sext.w	a5,a5
    80014c1a:	85be                	mv	a1,a5
    80014c1c:	0000d517          	auipc	a0,0xd
    80014c20:	bcc50513          	addi	a0,a0,-1076 # 800217e8 <pow10.0+0x5b8>
    80014c24:	5e0040ef          	jal	ra,80019204 <debugf>

    debugf("used element id: %d\n", gpu_device->device->ring[0].id);
    80014c28:	f8843783          	ld	a5,-120(s0)
    80014c2c:	7bbc                	ld	a5,112(a5)
    80014c2e:	43dc                	lw	a5,4(a5)
    80014c30:	2781                	sext.w	a5,a5
    80014c32:	85be                	mv	a1,a5
    80014c34:	0000d517          	auipc	a0,0xd
    80014c38:	bcc50513          	addi	a0,a0,-1076 # 80021800 <pow10.0+0x5d0>
    80014c3c:	5c8040ef          	jal	ra,80019204 <debugf>
    debugf("used element len: %d\n", gpu_device->device->ring[0].len);
    80014c40:	f8843783          	ld	a5,-120(s0)
    80014c44:	7bbc                	ld	a5,112(a5)
    80014c46:	479c                	lw	a5,8(a5)
    80014c48:	2781                	sext.w	a5,a5
    80014c4a:	85be                	mv	a1,a5
    80014c4c:	0000d517          	auipc	a0,0xd
    80014c50:	bcc50513          	addi	a0,a0,-1076 # 80021818 <pow10.0+0x5e8>
    80014c54:	5b0040ef          	jal	ra,80019204 <debugf>
    debugf("used element id: %d\n", gpu_device->device->ring[1].id);
    80014c58:	f8843783          	ld	a5,-120(s0)
    80014c5c:	7bbc                	ld	a5,112(a5)
    80014c5e:	47dc                	lw	a5,12(a5)
    80014c60:	2781                	sext.w	a5,a5
    80014c62:	85be                	mv	a1,a5
    80014c64:	0000d517          	auipc	a0,0xd
    80014c68:	b9c50513          	addi	a0,a0,-1124 # 80021800 <pow10.0+0x5d0>
    80014c6c:	598040ef          	jal	ra,80019204 <debugf>
    debugf("used element len: %d\n", gpu_device->device->ring[1].len);
    80014c70:	f8843783          	ld	a5,-120(s0)
    80014c74:	7bbc                	ld	a5,112(a5)
    80014c76:	4b9c                	lw	a5,16(a5)
    80014c78:	2781                	sext.w	a5,a5
    80014c7a:	85be                	mv	a1,a5
    80014c7c:	0000d517          	auipc	a0,0xd
    80014c80:	b9c50513          	addi	a0,a0,-1124 # 80021818 <pow10.0+0x5e8>
    80014c84:	580040ef          	jal	ra,80019204 <debugf>

    if (disp_resp->hdr.type == VIRTIO_GPU_RESP_OK_DISPLAY_INFO)
    80014c88:	f8043783          	ld	a5,-128(s0)
    80014c8c:	439c                	lw	a5,0(a5)
    80014c8e:	873e                	mv	a4,a5
    80014c90:	6785                	lui	a5,0x1
    80014c92:	10178793          	addi	a5,a5,257 # 1101 <i+0x10e1>
    80014c96:	00f71863          	bne	a4,a5,80014ca6 <gpu_get_display_info+0x198>
        debugf("gpu_get_display_info: Received display info\n");
    80014c9a:	0000d517          	auipc	a0,0xd
    80014c9e:	b9650513          	addi	a0,a0,-1130 # 80021830 <pow10.0+0x600>
    80014ca2:	562040ef          	jal	ra,80019204 <debugf>

    if (!disp_resp->displays[0].enabled)
    80014ca6:	f8043783          	ld	a5,-128(s0)
    80014caa:	579c                	lw	a5,40(a5)
    80014cac:	e399                	bnez	a5,80014cb2 <gpu_get_display_info+0x1a4>
        return false;
    80014cae:	4781                	li	a5,0
    80014cb0:	a801                	j	80014cc0 <gpu_get_display_info+0x1b2>
    debugf("gpu_get_display_info: Display 0 enabled\n");
    80014cb2:	0000d517          	auipc	a0,0xd
    80014cb6:	bae50513          	addi	a0,a0,-1106 # 80021860 <pow10.0+0x630>
    80014cba:	54a040ef          	jal	ra,80019204 <debugf>

    return true;
    80014cbe:	4785                	li	a5,1
}
    80014cc0:	853e                	mv	a0,a5
    80014cc2:	70e6                	ld	ra,120(sp)
    80014cc4:	7446                	ld	s0,112(sp)
    80014cc6:	6109                	addi	sp,sp,128
    80014cc8:	8082                	ret

0000000080014cca <fill_rect>:
void fill_rect(uint32_t screen_width,
               uint32_t screen_height,
               Pixel *frame_buf,
               const Rectangle *rect,
               const Pixel *fill_color)
               {
    80014cca:	715d                	addi	sp,sp,-80
    80014ccc:	e4a2                	sd	s0,72(sp)
    80014cce:	0880                	addi	s0,sp,80
    80014cd0:	87aa                	mv	a5,a0
    80014cd2:	fcc43023          	sd	a2,-64(s0)
    80014cd6:	fad43c23          	sd	a3,-72(s0)
    80014cda:	fae43823          	sd	a4,-80(s0)
    80014cde:	fcf42623          	sw	a5,-52(s0)
    80014ce2:	87ae                	mv	a5,a1
    80014ce4:	fcf42423          	sw	a5,-56(s0)
    uint32_t top = rect->y;
    80014ce8:	fb843783          	ld	a5,-72(s0)
    80014cec:	43dc                	lw	a5,4(a5)
    80014cee:	fcf42e23          	sw	a5,-36(s0)
    uint32_t bottom = rect->y + rect->height;
    80014cf2:	fb843783          	ld	a5,-72(s0)
    80014cf6:	43d8                	lw	a4,4(a5)
    80014cf8:	fb843783          	ld	a5,-72(s0)
    80014cfc:	47dc                	lw	a5,12(a5)
    80014cfe:	9fb9                	addw	a5,a5,a4
    80014d00:	fef42623          	sw	a5,-20(s0)
    uint32_t left = rect->x;
    80014d04:	fb843783          	ld	a5,-72(s0)
    80014d08:	439c                	lw	a5,0(a5)
    80014d0a:	fcf42c23          	sw	a5,-40(s0)
    uint32_t right = rect->x + rect->width;
    80014d0e:	fb843783          	ld	a5,-72(s0)
    80014d12:	4398                	lw	a4,0(a5)
    80014d14:	fb843783          	ld	a5,-72(s0)
    80014d18:	479c                	lw	a5,8(a5)
    80014d1a:	9fb9                	addw	a5,a5,a4
    80014d1c:	fef42423          	sw	a5,-24(s0)
    uint32_t row;
    uint32_t col;
    uint32_t offset;

    if (bottom > screen_height) {
    80014d20:	fec42703          	lw	a4,-20(s0)
    80014d24:	fc842783          	lw	a5,-56(s0)
    80014d28:	2701                	sext.w	a4,a4
    80014d2a:	2781                	sext.w	a5,a5
    80014d2c:	00e7f663          	bgeu	a5,a4,80014d38 <fill_rect+0x6e>
        bottom = screen_height;
    80014d30:	fc842783          	lw	a5,-56(s0)
    80014d34:	fef42623          	sw	a5,-20(s0)
    }
    if (right > screen_width) {
    80014d38:	fe842703          	lw	a4,-24(s0)
    80014d3c:	fcc42783          	lw	a5,-52(s0)
    80014d40:	2701                	sext.w	a4,a4
    80014d42:	2781                	sext.w	a5,a5
    80014d44:	00e7f663          	bgeu	a5,a4,80014d50 <fill_rect+0x86>
        right = screen_width;
    80014d48:	fcc42783          	lw	a5,-52(s0)
    80014d4c:	fef42423          	sw	a5,-24(s0)
    }

    for (row = top; row < bottom; row++) {
    80014d50:	fdc42783          	lw	a5,-36(s0)
    80014d54:	fef42223          	sw	a5,-28(s0)
    80014d58:	a89d                	j	80014dce <fill_rect+0x104>
        for (col = left;col < right;col++) {
    80014d5a:	fd842783          	lw	a5,-40(s0)
    80014d5e:	fef42023          	sw	a5,-32(s0)
    80014d62:	a889                	j	80014db4 <fill_rect+0xea>
            frame_buf[row * screen_width + col] = *fill_color;
    80014d64:	fe442703          	lw	a4,-28(s0)
    80014d68:	fcc42783          	lw	a5,-52(s0)
    80014d6c:	02f707bb          	mulw	a5,a4,a5
    80014d70:	2781                	sext.w	a5,a5
    80014d72:	fe042703          	lw	a4,-32(s0)
    80014d76:	9fb9                	addw	a5,a5,a4
    80014d78:	2781                	sext.w	a5,a5
    80014d7a:	1782                	slli	a5,a5,0x20
    80014d7c:	9381                	srli	a5,a5,0x20
    80014d7e:	078a                	slli	a5,a5,0x2
    80014d80:	fc043703          	ld	a4,-64(s0)
    80014d84:	97ba                	add	a5,a5,a4
    80014d86:	fb043703          	ld	a4,-80(s0)
    80014d8a:	00074583          	lbu	a1,0(a4)
    80014d8e:	00174603          	lbu	a2,1(a4)
    80014d92:	00274683          	lbu	a3,2(a4)
    80014d96:	00374703          	lbu	a4,3(a4)
    80014d9a:	00b78023          	sb	a1,0(a5)
    80014d9e:	00c780a3          	sb	a2,1(a5)
    80014da2:	00d78123          	sb	a3,2(a5)
    80014da6:	00e781a3          	sb	a4,3(a5)
        for (col = left;col < right;col++) {
    80014daa:	fe042783          	lw	a5,-32(s0)
    80014dae:	2785                	addiw	a5,a5,1
    80014db0:	fef42023          	sw	a5,-32(s0)
    80014db4:	fe042703          	lw	a4,-32(s0)
    80014db8:	fe842783          	lw	a5,-24(s0)
    80014dbc:	2701                	sext.w	a4,a4
    80014dbe:	2781                	sext.w	a5,a5
    80014dc0:	faf762e3          	bltu	a4,a5,80014d64 <fill_rect+0x9a>
    for (row = top; row < bottom; row++) {
    80014dc4:	fe442783          	lw	a5,-28(s0)
    80014dc8:	2785                	addiw	a5,a5,1
    80014dca:	fef42223          	sw	a5,-28(s0)
    80014dce:	fe442703          	lw	a4,-28(s0)
    80014dd2:	fec42783          	lw	a5,-20(s0)
    80014dd6:	2701                	sext.w	a4,a4
    80014dd8:	2781                	sext.w	a5,a5
    80014dda:	f8f760e3          	bltu	a4,a5,80014d5a <fill_rect+0x90>
        }
   }
}
    80014dde:	0001                	nop
    80014de0:	0001                	nop
    80014de2:	6426                	ld	s0,72(sp)
    80014de4:	6161                	addi	sp,sp,80
    80014de6:	8082                	ret

0000000080014de8 <RVALS>:
static inline void RVALS(Rectangle *r,
                         uint32_t x,
                         uint32_t y,
                         uint32_t width,
                         uint32_t height)
{
    80014de8:	7179                	addi	sp,sp,-48
    80014dea:	f422                	sd	s0,40(sp)
    80014dec:	1800                	addi	s0,sp,48
    80014dee:	fea43423          	sd	a0,-24(s0)
    80014df2:	87ae                	mv	a5,a1
    80014df4:	fef42223          	sw	a5,-28(s0)
    80014df8:	87b2                	mv	a5,a2
    80014dfa:	fef42023          	sw	a5,-32(s0)
    80014dfe:	87b6                	mv	a5,a3
    80014e00:	fcf42e23          	sw	a5,-36(s0)
    80014e04:	87ba                	mv	a5,a4
    80014e06:	fcf42c23          	sw	a5,-40(s0)
    r->x = x;
    80014e0a:	fe843783          	ld	a5,-24(s0)
    80014e0e:	fe442703          	lw	a4,-28(s0)
    80014e12:	c398                	sw	a4,0(a5)
    r->y = y;
    80014e14:	fe843783          	ld	a5,-24(s0)
    80014e18:	fe042703          	lw	a4,-32(s0)
    80014e1c:	c3d8                	sw	a4,4(a5)
    r->width = width;
    80014e1e:	fe843783          	ld	a5,-24(s0)
    80014e22:	fdc42703          	lw	a4,-36(s0)
    80014e26:	c798                	sw	a4,8(a5)
    r->height = height;
    80014e28:	fe843783          	ld	a5,-24(s0)
    80014e2c:	fd842703          	lw	a4,-40(s0)
    80014e30:	c7d8                	sw	a4,12(a5)
}
    80014e32:	0001                	nop
    80014e34:	7422                	ld	s0,40(sp)
    80014e36:	6145                	addi	sp,sp,48
    80014e38:	8082                	ret

0000000080014e3a <stroke_rect>:
                 uint32_t screen_height,
                 Pixel *frame_buf,
                 const Rectangle *rect,
                 const Pixel *line_color,
                 uint32_t line_size)
{
    80014e3a:	715d                	addi	sp,sp,-80
    80014e3c:	e486                	sd	ra,72(sp)
    80014e3e:	e0a2                	sd	s0,64(sp)
    80014e40:	0880                	addi	s0,sp,80
    80014e42:	fcc43823          	sd	a2,-48(s0)
    80014e46:	fcd43423          	sd	a3,-56(s0)
    80014e4a:	fce43023          	sd	a4,-64(s0)
    80014e4e:	873e                	mv	a4,a5
    80014e50:	87aa                	mv	a5,a0
    80014e52:	fcf42e23          	sw	a5,-36(s0)
    80014e56:	87ae                	mv	a5,a1
    80014e58:	fcf42c23          	sw	a5,-40(s0)
    80014e5c:	87ba                	mv	a5,a4
    80014e5e:	faf42e23          	sw	a5,-68(s0)
    struct Rectangle r;
    // Top
    RVALS(&r, rect->x, rect->y,
    80014e62:	fc843783          	ld	a5,-56(s0)
    80014e66:	438c                	lw	a1,0(a5)
    80014e68:	fc843783          	ld	a5,-56(s0)
    80014e6c:	43d0                	lw	a2,4(a5)
    80014e6e:	fc843783          	ld	a5,-56(s0)
    80014e72:	4794                	lw	a3,8(a5)
    80014e74:	fbc42703          	lw	a4,-68(s0)
    80014e78:	fe040793          	addi	a5,s0,-32
    80014e7c:	853e                	mv	a0,a5
    80014e7e:	f6bff0ef          	jal	ra,80014de8 <RVALS>
              rect->width, line_size);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80014e82:	fe040693          	addi	a3,s0,-32
    80014e86:	fd842583          	lw	a1,-40(s0)
    80014e8a:	fdc42783          	lw	a5,-36(s0)
    80014e8e:	fc043703          	ld	a4,-64(s0)
    80014e92:	fd043603          	ld	a2,-48(s0)
    80014e96:	853e                	mv	a0,a5
    80014e98:	e33ff0ef          	jal	ra,80014cca <fill_rect>

    // Bottom
    RVALS(&r, rect->x, rect->height + rect->y,
    80014e9c:	fc843783          	ld	a5,-56(s0)
    80014ea0:	438c                	lw	a1,0(a5)
    80014ea2:	fc843783          	ld	a5,-56(s0)
    80014ea6:	47d8                	lw	a4,12(a5)
    80014ea8:	fc843783          	ld	a5,-56(s0)
    80014eac:	43dc                	lw	a5,4(a5)
    80014eae:	9fb9                	addw	a5,a5,a4
    80014eb0:	0007861b          	sext.w	a2,a5
    80014eb4:	fc843783          	ld	a5,-56(s0)
    80014eb8:	4794                	lw	a3,8(a5)
    80014eba:	fbc42703          	lw	a4,-68(s0)
    80014ebe:	fe040793          	addi	a5,s0,-32
    80014ec2:	853e                	mv	a0,a5
    80014ec4:	f25ff0ef          	jal	ra,80014de8 <RVALS>
              rect->width, line_size);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80014ec8:	fe040693          	addi	a3,s0,-32
    80014ecc:	fd842583          	lw	a1,-40(s0)
    80014ed0:	fdc42783          	lw	a5,-36(s0)
    80014ed4:	fc043703          	ld	a4,-64(s0)
    80014ed8:	fd043603          	ld	a2,-48(s0)
    80014edc:	853e                	mv	a0,a5
    80014ede:	dedff0ef          	jal	ra,80014cca <fill_rect>

    // Left
    RVALS(&r, rect->x, rect->y,
    80014ee2:	fc843783          	ld	a5,-56(s0)
    80014ee6:	438c                	lw	a1,0(a5)
    80014ee8:	fc843783          	ld	a5,-56(s0)
    80014eec:	43d0                	lw	a2,4(a5)
    80014eee:	fc843783          	ld	a5,-56(s0)
    80014ef2:	47d8                	lw	a4,12(a5)
    80014ef4:	fbc42683          	lw	a3,-68(s0)
    80014ef8:	fe040793          	addi	a5,s0,-32
    80014efc:	853e                	mv	a0,a5
    80014efe:	eebff0ef          	jal	ra,80014de8 <RVALS>
              line_size, rect->height);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80014f02:	fe040693          	addi	a3,s0,-32
    80014f06:	fd842583          	lw	a1,-40(s0)
    80014f0a:	fdc42783          	lw	a5,-36(s0)
    80014f0e:	fc043703          	ld	a4,-64(s0)
    80014f12:	fd043603          	ld	a2,-48(s0)
    80014f16:	853e                	mv	a0,a5
    80014f18:	db3ff0ef          	jal	ra,80014cca <fill_rect>

    // Right
    RVALS(&r, rect->x + rect->width, rect->y,
    80014f1c:	fc843783          	ld	a5,-56(s0)
    80014f20:	4398                	lw	a4,0(a5)
    80014f22:	fc843783          	ld	a5,-56(s0)
    80014f26:	479c                	lw	a5,8(a5)
    80014f28:	9fb9                	addw	a5,a5,a4
    80014f2a:	0007859b          	sext.w	a1,a5
    80014f2e:	fc843783          	ld	a5,-56(s0)
    80014f32:	43d0                	lw	a2,4(a5)
              line_size, rect->height + line_size);
    80014f34:	fc843783          	ld	a5,-56(s0)
    80014f38:	47dc                	lw	a5,12(a5)
    RVALS(&r, rect->x + rect->width, rect->y,
    80014f3a:	fbc42703          	lw	a4,-68(s0)
    80014f3e:	9fb9                	addw	a5,a5,a4
    80014f40:	0007871b          	sext.w	a4,a5
    80014f44:	fbc42683          	lw	a3,-68(s0)
    80014f48:	fe040793          	addi	a5,s0,-32
    80014f4c:	853e                	mv	a0,a5
    80014f4e:	e9bff0ef          	jal	ra,80014de8 <RVALS>
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80014f52:	fe040693          	addi	a3,s0,-32
    80014f56:	fd842583          	lw	a1,-40(s0)
    80014f5a:	fdc42783          	lw	a5,-36(s0)
    80014f5e:	fc043703          	ld	a4,-64(s0)
    80014f62:	fd043603          	ld	a2,-48(s0)
    80014f66:	853e                	mv	a0,a5
    80014f68:	d63ff0ef          	jal	ra,80014cca <fill_rect>
}
    80014f6c:	0001                	nop
    80014f6e:	60a6                	ld	ra,72(sp)
    80014f70:	6406                	ld	s0,64(sp)
    80014f72:	6161                	addi	sp,sp,80
    80014f74:	8082                	ret

0000000080014f76 <gpu_get_resp_string>:

// Return the respective response message string
static char *gpu_get_resp_string(VirtioGpuCtrlType type) {
    80014f76:	1101                	addi	sp,sp,-32
    80014f78:	ec22                	sd	s0,24(sp)
    80014f7a:	1000                	addi	s0,sp,32
    80014f7c:	87aa                	mv	a5,a0
    80014f7e:	fef42623          	sw	a5,-20(s0)
    switch (type) {
    80014f82:	fec42783          	lw	a5,-20(s0)
    80014f86:	0007871b          	sext.w	a4,a5
    80014f8a:	6785                	lui	a5,0x1
    80014f8c:	10478793          	addi	a5,a5,260 # 1104 <i+0x10e4>
    80014f90:	08e7ea63          	bltu	a5,a4,80015024 <gpu_get_resp_string+0xae>
    80014f94:	fec42783          	lw	a5,-20(s0)
    80014f98:	0007871b          	sext.w	a4,a5
    80014f9c:	6785                	lui	a5,0x1
    80014f9e:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    80014fa2:	04f77263          	bgeu	a4,a5,80014fe6 <gpu_get_resp_string+0x70>
    80014fa6:	aa09                	j	800150b8 <gpu_get_resp_string+0x142>
    80014fa8:	fec42703          	lw	a4,-20(s0)
    80014fac:	77fd                	lui	a5,0xfffff
    80014fae:	e007879b          	addiw	a5,a5,-512
    80014fb2:	00f706bb          	addw	a3,a4,a5
    80014fb6:	0006871b          	sext.w	a4,a3
    80014fba:	4795                	li	a5,5
    80014fbc:	0ee7ee63          	bltu	a5,a4,800150b8 <gpu_get_resp_string+0x142>
    80014fc0:	02069793          	slli	a5,a3,0x20
    80014fc4:	9381                	srli	a5,a5,0x20
    80014fc6:	00279713          	slli	a4,a5,0x2
    80014fca:	0000d797          	auipc	a5,0xd
    80014fce:	a7678793          	addi	a5,a5,-1418 # 80021a40 <pow10.0+0x810>
    80014fd2:	97ba                	add	a5,a5,a4
    80014fd4:	439c                	lw	a5,0(a5)
    80014fd6:	0007871b          	sext.w	a4,a5
    80014fda:	0000d797          	auipc	a5,0xd
    80014fde:	a6678793          	addi	a5,a5,-1434 # 80021a40 <pow10.0+0x810>
    80014fe2:	97ba                	add	a5,a5,a4
    80014fe4:	8782                	jr	a5
    80014fe6:	fec42703          	lw	a4,-20(s0)
    80014fea:	77fd                	lui	a5,0xfffff
    80014fec:	f007879b          	addiw	a5,a5,-256
    80014ff0:	00f706bb          	addw	a3,a4,a5
    80014ff4:	0006871b          	sext.w	a4,a3
    80014ff8:	4791                	li	a5,4
    80014ffa:	0ae7ef63          	bltu	a5,a4,800150b8 <gpu_get_resp_string+0x142>
    80014ffe:	02069793          	slli	a5,a3,0x20
    80015002:	9381                	srli	a5,a5,0x20
    80015004:	00279713          	slli	a4,a5,0x2
    80015008:	0000d797          	auipc	a5,0xd
    8001500c:	a5078793          	addi	a5,a5,-1456 # 80021a58 <pow10.0+0x828>
    80015010:	97ba                	add	a5,a5,a4
    80015012:	439c                	lw	a5,0(a5)
    80015014:	0007871b          	sext.w	a4,a5
    80015018:	0000d797          	auipc	a5,0xd
    8001501c:	a4078793          	addi	a5,a5,-1472 # 80021a58 <pow10.0+0x828>
    80015020:	97ba                	add	a5,a5,a4
    80015022:	8782                	jr	a5
    80015024:	fec42783          	lw	a5,-20(s0)
    80015028:	0007871b          	sext.w	a4,a5
    8001502c:	6785                	lui	a5,0x1
    8001502e:	20578793          	addi	a5,a5,517 # 1205 <i+0x11e5>
    80015032:	08e7e363          	bltu	a5,a4,800150b8 <gpu_get_resp_string+0x142>
    80015036:	fec42783          	lw	a5,-20(s0)
    8001503a:	0007871b          	sext.w	a4,a5
    8001503e:	6785                	lui	a5,0x1
    80015040:	20078793          	addi	a5,a5,512 # 1200 <i+0x11e0>
    80015044:	f6f772e3          	bgeu	a4,a5,80014fa8 <gpu_get_resp_string+0x32>
    80015048:	a885                	j	800150b8 <gpu_get_resp_string+0x142>
        // Success responses
        case VIRTIO_GPU_RESP_OK_NODATA: return "VIRTIO_GPU_RESP_OK_NODATA";
    8001504a:	0000d797          	auipc	a5,0xd
    8001504e:	84678793          	addi	a5,a5,-1978 # 80021890 <pow10.0+0x660>
    80015052:	a0bd                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_DISPLAY_INFO: return "VIRTIO_GPU_RESP_OK_DISPLAY_INFO";
    80015054:	0000d797          	auipc	a5,0xd
    80015058:	85c78793          	addi	a5,a5,-1956 # 800218b0 <pow10.0+0x680>
    8001505c:	a095                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_CAPSET_INFO: return "VIRTIO_GPU_RESP_OK_CAPSET_INFO";
    8001505e:	0000d797          	auipc	a5,0xd
    80015062:	87278793          	addi	a5,a5,-1934 # 800218d0 <pow10.0+0x6a0>
    80015066:	a8a9                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_CAPSET: return "VIRTIO_GPU_RESP_OK_CAPSET";
    80015068:	0000d797          	auipc	a5,0xd
    8001506c:	88878793          	addi	a5,a5,-1912 # 800218f0 <pow10.0+0x6c0>
    80015070:	a881                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_EDID: return "VIRTIO_GPU_RESP_OK_EDID";
    80015072:	0000d797          	auipc	a5,0xd
    80015076:	89e78793          	addi	a5,a5,-1890 # 80021910 <pow10.0+0x6e0>
    8001507a:	a099                	j	800150c0 <gpu_get_resp_string+0x14a>
        // Error responses
        case VIRTIO_GPU_RESP_ERR_UNSPEC: return "VIRTIO_GPU_RESP_ERR_UNSPEC";
    8001507c:	0000d797          	auipc	a5,0xd
    80015080:	8ac78793          	addi	a5,a5,-1876 # 80021928 <pow10.0+0x6f8>
    80015084:	a835                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY: return "VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY";
    80015086:	0000d797          	auipc	a5,0xd
    8001508a:	8c278793          	addi	a5,a5,-1854 # 80021948 <pow10.0+0x718>
    8001508e:	a80d                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID";
    80015090:	0000d797          	auipc	a5,0xd
    80015094:	8e078793          	addi	a5,a5,-1824 # 80021970 <pow10.0+0x740>
    80015098:	a025                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID";
    8001509a:	0000d797          	auipc	a5,0xd
    8001509e:	8fe78793          	addi	a5,a5,-1794 # 80021998 <pow10.0+0x768>
    800150a2:	a839                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID";
    800150a4:	0000d797          	auipc	a5,0xd
    800150a8:	91c78793          	addi	a5,a5,-1764 # 800219c0 <pow10.0+0x790>
    800150ac:	a811                	j	800150c0 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER: return "VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER";
    800150ae:	0000d797          	auipc	a5,0xd
    800150b2:	93a78793          	addi	a5,a5,-1734 # 800219e8 <pow10.0+0x7b8>
    800150b6:	a029                	j	800150c0 <gpu_get_resp_string+0x14a>
        default: return "Invalid type argument to gpu_get_resp_string"; break;
    800150b8:	0000d797          	auipc	a5,0xd
    800150bc:	95878793          	addi	a5,a5,-1704 # 80021a10 <pow10.0+0x7e0>
    }
}
    800150c0:	853e                	mv	a0,a5
    800150c2:	6462                	ld	s0,24(sp)
    800150c4:	6105                	addi	sp,sp,32
    800150c6:	8082                	ret

00000000800150c8 <init_systems>:
// the kernel.
// Defined in src/include/mmu.h
struct page_table *kernel_mmu_table;

static void init_systems(void)
{
    800150c8:	711d                	addi	sp,sp,-96
    800150ca:	ec86                	sd	ra,88(sp)
    800150cc:	e8a2                	sd	s0,80(sp)
    800150ce:	1080                	addi	s0,sp,96
    void plic_init(void);
    plic_init();
    800150d0:	7f0040ef          	jal	ra,800198c0 <plic_init>
    debugf("plic_init() done\n");
    800150d4:	0000d517          	auipc	a0,0xd
    800150d8:	99c50513          	addi	a0,a0,-1636 # 80021a70 <pow10.0+0x840>
    800150dc:	128040ef          	jal	ra,80019204 <debugf>
    void page_init(void);
    page_init();
    800150e0:	673050ef          	jal	ra,8001af52 <page_init>
    debugf("page_init() done\n");
    800150e4:	0000d517          	auipc	a0,0xd
    800150e8:	9a450513          	addi	a0,a0,-1628 # 80021a88 <pow10.0+0x858>
    800150ec:	118040ef          	jal	ra,80019204 <debugf>

#ifdef USE_MMU
    struct page_table *pt = mmu_table_create();
    800150f0:	cf7fe0ef          	jal	ra,80013de6 <mmu_table_create>
    800150f4:	fca43823          	sd	a0,-48(s0)
    kernel_mmu_table = pt;
    800150f8:	0000b797          	auipc	a5,0xb
    800150fc:	f0878793          	addi	a5,a5,-248 # 80020000 <kernel_mmu_table>
    80015100:	fd043703          	ld	a4,-48(s0)
    80015104:	e398                	sd	a4,0(a5)

    debugf("Kernel page table at %p\n", pt);
    80015106:	fd043583          	ld	a1,-48(s0)
    8001510a:	0000d517          	auipc	a0,0xd
    8001510e:	99650513          	addi	a0,a0,-1642 # 80021aa0 <pow10.0+0x870>
    80015112:	0f2040ef          	jal	ra,80019204 <debugf>
    // Map memory segments for our kernel
    debugf("Mapping kernel segments\n");
    80015116:	0000d517          	auipc	a0,0xd
    8001511a:	9aa50513          	addi	a0,a0,-1622 # 80021ac0 <pow10.0+0x890>
    8001511e:	0e6040ef          	jal	ra,80019204 <debugf>
    mmu_map_range(pt, sym_start(text), sym_end(heap), sym_start(text), MMU_LEVEL_1G,
    80015122:	ffffb597          	auipc	a1,0xffffb
    80015126:	ede58593          	addi	a1,a1,-290 # 80010000 <_memory_start>
    8001512a:	07ffb617          	auipc	a2,0x7ffb
    8001512e:	ed660613          	addi	a2,a2,-298 # 88010000 <_heap_end>
    80015132:	ffffb697          	auipc	a3,0xffffb
    80015136:	ece68693          	addi	a3,a3,-306 # 80010000 <_memory_start>
    8001513a:	47b9                	li	a5,14
    8001513c:	4709                	li	a4,2
    8001513e:	fd043503          	ld	a0,-48(s0)
    80015142:	8d2ff0ef          	jal	ra,80014214 <mmu_map_range>
                  PB_READ | PB_WRITE | PB_EXECUTE);
    // PLIC
    debugf("Mapping PLIC\n");
    80015146:	0000d517          	auipc	a0,0xd
    8001514a:	99a50513          	addi	a0,a0,-1638 # 80021ae0 <pow10.0+0x8b0>
    8001514e:	0b6040ef          	jal	ra,80019204 <debugf>
    mmu_map_range(pt, 0x0C000000, 0x0C2FFFFF, 0x0C000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80015152:	4799                	li	a5,6
    80015154:	4705                	li	a4,1
    80015156:	0c0006b7          	lui	a3,0xc000
    8001515a:	0c300637          	lui	a2,0xc300
    8001515e:	167d                	addi	a2,a2,-1
    80015160:	0c0005b7          	lui	a1,0xc000
    80015164:	fd043503          	ld	a0,-48(s0)
    80015168:	8acff0ef          	jal	ra,80014214 <mmu_map_range>
    // PCIe ECAM
    debugf("Mapping PCIe ECAM\n");
    8001516c:	0000d517          	auipc	a0,0xd
    80015170:	98450513          	addi	a0,a0,-1660 # 80021af0 <pow10.0+0x8c0>
    80015174:	090040ef          	jal	ra,80019204 <debugf>
    mmu_map_range(pt, 0x30000000, 0x3FFFFFFF, 0x30000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80015178:	4799                	li	a5,6
    8001517a:	4705                	li	a4,1
    8001517c:	300006b7          	lui	a3,0x30000
    80015180:	40000637          	lui	a2,0x40000
    80015184:	167d                	addi	a2,a2,-1
    80015186:	300005b7          	lui	a1,0x30000
    8001518a:	fd043503          	ld	a0,-48(s0)
    8001518e:	886ff0ef          	jal	ra,80014214 <mmu_map_range>
    // PCIe MMIO
    debugf("Mapping PCIe MMIO\n");
    80015192:	0000d517          	auipc	a0,0xd
    80015196:	97650513          	addi	a0,a0,-1674 # 80021b08 <pow10.0+0x8d8>
    8001519a:	06a040ef          	jal	ra,80019204 <debugf>
    mmu_map_range(pt, 0x40000000, 0x5FFFFFFF, 0x40000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    8001519e:	4799                	li	a5,6
    800151a0:	4705                	li	a4,1
    800151a2:	400006b7          	lui	a3,0x40000
    800151a6:	60000637          	lui	a2,0x60000
    800151aa:	167d                	addi	a2,a2,-1
    800151ac:	400005b7          	lui	a1,0x40000
    800151b0:	fd043503          	ld	a0,-48(s0)
    800151b4:	860ff0ef          	jal	ra,80014214 <mmu_map_range>
    //                    uint64_t start_virt, 
    //                    uint64_t end_virt, 
    //                    uint64_t start_phys)
    // debug_page_table(pt, MMU_LEVEL_1G);

    debugf("About to set SATP to %016lx\n", SATP_KERNEL);
    800151b8:	0000b797          	auipc	a5,0xb
    800151bc:	e4878793          	addi	a5,a5,-440 # 80020000 <kernel_mmu_table>
    800151c0:	639c                	ld	a5,0(a5)
    800151c2:	00c7d713          	srli	a4,a5,0xc
    800151c6:	57fd                	li	a5,-1
    800151c8:	83d1                	srli	a5,a5,0x14
    800151ca:	8f7d                	and	a4,a4,a5
    800151cc:	8ffff7b7          	lui	a5,0x8ffff
    800151d0:	1782                	slli	a5,a5,0x20
    800151d2:	8fd9                	or	a5,a5,a4
    800151d4:	85be                	mv	a1,a5
    800151d6:	0000d517          	auipc	a0,0xd
    800151da:	94a50513          	addi	a0,a0,-1718 # 80021b20 <pow10.0+0x8f0>
    800151de:	026040ef          	jal	ra,80019204 <debugf>
    // TODO: turn on the MMU when you've written the src/mmu.c functions
    CSR_WRITE("satp", SATP_KERNEL); 
    800151e2:	0000b797          	auipc	a5,0xb
    800151e6:	e1e78793          	addi	a5,a5,-482 # 80020000 <kernel_mmu_table>
    800151ea:	639c                	ld	a5,0(a5)
    800151ec:	00c7d713          	srli	a4,a5,0xc
    800151f0:	57fd                	li	a5,-1
    800151f2:	83d1                	srli	a5,a5,0x14
    800151f4:	8f7d                	and	a4,a4,a5
    800151f6:	8ffff7b7          	lui	a5,0x8ffff
    800151fa:	1782                	slli	a5,a5,0x20
    800151fc:	8fd9                	or	a5,a5,a4
    800151fe:	18079073          	csrw	satp,a5
    SFENCE_ALL();
    80015202:	12000073          	sfence.vma
    debugf("MMU enabled\n");
    80015206:	0000d517          	auipc	a0,0xd
    8001520a:	93a50513          	addi	a0,a0,-1734 # 80021b40 <pow10.0+0x910>
    8001520e:	7f7030ef          	jal	ra,80019204 <debugf>
    void *kcalloc(uint64_t elem, uint64_t size);
    void kfree(void *ptr);
    void util_connect_galloc(void *(*malloc)(uint64_t size),
                             void *(*calloc)(uint64_t elem, uint64_t size),
                             void (*free)(void *ptr));
    util_connect_galloc(kmalloc, kcalloc, kfree);
    80015212:	fffff617          	auipc	a2,0xfffff
    80015216:	acc60613          	addi	a2,a2,-1332 # 80013cde <kfree>
    8001521a:	fffff597          	auipc	a1,0xfffff
    8001521e:	a9c58593          	addi	a1,a1,-1380 # 80013cb6 <kcalloc>
    80015222:	fffff517          	auipc	a0,0xfffff
    80015226:	a7450513          	addi	a0,a0,-1420 # 80013c96 <kmalloc>
    8001522a:	61f060ef          	jal	ra,8001c048 <util_connect_galloc>
    heap_init();
    8001522e:	ad5fe0ef          	jal	ra,80013d02 <heap_init>
    debugf("heap_init() done\n");
    80015232:	0000d517          	auipc	a0,0xd
    80015236:	91e50513          	addi	a0,a0,-1762 # 80021b50 <pow10.0+0x920>
    8001523a:	7cb030ef          	jal	ra,80019204 <debugf>

    // Call kmalloc() here to ensure it works.
    void *ptr = kmalloc(1024);
    8001523e:	40000513          	li	a0,1024
    80015242:	a55fe0ef          	jal	ra,80013c96 <kmalloc>
    80015246:	fca43423          	sd	a0,-56(s0)
    strcpy(ptr, "Hello, world!");
    8001524a:	0000d597          	auipc	a1,0xd
    8001524e:	91e58593          	addi	a1,a1,-1762 # 80021b68 <pow10.0+0x938>
    80015252:	fc843503          	ld	a0,-56(s0)
    80015256:	0a1080ef          	jal	ra,8001daf6 <strcpy>
    debugf("kmalloc(1024) = %p\n", ptr);
    8001525a:	fc843583          	ld	a1,-56(s0)
    8001525e:	0000d517          	auipc	a0,0xd
    80015262:	91a50513          	addi	a0,a0,-1766 # 80021b78 <pow10.0+0x948>
    80015266:	79f030ef          	jal	ra,80019204 <debugf>
    debugf("kmalloc(1024) = %s\n", ptr);
    8001526a:	fc843583          	ld	a1,-56(s0)
    8001526e:	0000d517          	auipc	a0,0xd
    80015272:	92250513          	addi	a0,a0,-1758 # 80021b90 <pow10.0+0x960>
    80015276:	78f030ef          	jal	ra,80019204 <debugf>
    kfree(ptr);
    8001527a:	fc843503          	ld	a0,-56(s0)
    8001527e:	a61fe0ef          	jal	ra,80013cde <kfree>
#endif
#ifdef USE_PCI
    pci_init();
    80015282:	8e0fe0ef          	jal	ra,80013362 <pci_init>
#endif
#ifdef USE_VIRTIO
    uint64_t stvec = trampoline_trap_start;
    80015286:	0000e797          	auipc	a5,0xe
    8001528a:	11e78793          	addi	a5,a5,286 # 800233a4 <trampoline_trap_start>
    8001528e:	639c                	ld	a5,0(a5)
    80015290:	fcf43023          	sd	a5,-64(s0)
    // # 552  - stvec
    // # 560  - trap_satp
    // # 568  - trap_stack
    // trampoline_thread_start();

    stvec &= ~0x3;
    80015294:	fc043783          	ld	a5,-64(s0)
    80015298:	9bf1                	andi	a5,a5,-4
    8001529a:	fcf43023          	sd	a5,-64(s0)
    CSR_WRITE("stvec", trampoline_trap_start);
    8001529e:	0000e797          	auipc	a5,0xe
    800152a2:	10678793          	addi	a5,a5,262 # 800233a4 <trampoline_trap_start>
    800152a6:	639c                	ld	a5,0(a5)
    800152a8:	10579073          	csrw	stvec,a5
    debugf("STVEC: 0x%p, 0x%p\n", stvec, trampoline_trap_start);
    800152ac:	0000e797          	auipc	a5,0xe
    800152b0:	0f878793          	addi	a5,a5,248 # 800233a4 <trampoline_trap_start>
    800152b4:	639c                	ld	a5,0(a5)
    800152b6:	863e                	mv	a2,a5
    800152b8:	fc043583          	ld	a1,-64(s0)
    800152bc:	0000d517          	auipc	a0,0xd
    800152c0:	8ec50513          	addi	a0,a0,-1812 # 80021ba8 <pow10.0+0x978>
    800152c4:	741030ef          	jal	ra,80019204 <debugf>

    Trapframe *sscratch = kzalloc(sizeof(Trapframe) * 0x1000);
    800152c8:	002405b7          	lui	a1,0x240
    800152cc:	4505                	li	a0,1
    800152ce:	9e9fe0ef          	jal	ra,80013cb6 <kcalloc>
    800152d2:	faa43c23          	sd	a0,-72(s0)
    
    CSR_READ(sscratch->sepc, "sepc");
    800152d6:	14102773          	csrr	a4,sepc
    800152da:	fb843783          	ld	a5,-72(s0)
    800152de:	20e7b023          	sd	a4,512(a5)
    CSR_READ(sscratch->sstatus, "sstatus");
    800152e2:	10002773          	csrr	a4,sstatus
    800152e6:	fb843783          	ld	a5,-72(s0)
    800152ea:	20e7b423          	sd	a4,520(a5)
    CSR_READ(sscratch->sie, "sie");
    800152ee:	10402773          	csrr	a4,sie
    800152f2:	fb843783          	ld	a5,-72(s0)
    800152f6:	20e7b823          	sd	a4,528(a5)
    CSR_READ(sscratch->satp, "satp");
    800152fa:	18002773          	csrr	a4,satp
    800152fe:	fb843783          	ld	a5,-72(s0)
    80015302:	20e7bc23          	sd	a4,536(a5)
    CSR_READ(sscratch->stvec, "stvec");
    80015306:	10502773          	csrr	a4,stvec
    8001530a:	fb843783          	ld	a5,-72(s0)
    8001530e:	22e7b423          	sd	a4,552(a5)
    CSR_READ(sscratch->trap_satp, "satp");
    80015312:	18002773          	csrr	a4,satp
    80015316:	fb843783          	ld	a5,-72(s0)
    8001531a:	22e7b823          	sd	a4,560(a5)
    sscratch->trap_stack = (uint64_t)kmalloc(0x4000);
    8001531e:	6511                	lui	a0,0x4
    80015320:	977fe0ef          	jal	ra,80013c96 <kmalloc>
    80015324:	87aa                	mv	a5,a0
    80015326:	873e                	mv	a4,a5
    80015328:	fb843783          	ld	a5,-72(s0)
    8001532c:	22e7bc23          	sd	a4,568(a5)
    CSR_WRITE("sscratch", sscratch);
    80015330:	fb843783          	ld	a5,-72(s0)
    80015334:	14079073          	csrw	sscratch,a5

    virtio_init();
    80015338:	733040ef          	jal	ra,8001a26a <virtio_init>
    uint8_t buffer[16] = {0};
    8001533c:	fa043423          	sd	zero,-88(s0)
    80015340:	fa043823          	sd	zero,-80(s0)
    debugf("RNG State Before:");
    80015344:	0000d517          	auipc	a0,0xd
    80015348:	87c50513          	addi	a0,a0,-1924 # 80021bc0 <pow10.0+0x990>
    8001534c:	6b9030ef          	jal	ra,80019204 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80015350:	fe043423          	sd	zero,-24(s0)
    80015354:	a02d                	j	8001537e <init_systems+0x2b6>
        debugf(" %d ", buffer[i]);
    80015356:	fe843783          	ld	a5,-24(s0)
    8001535a:	ff040713          	addi	a4,s0,-16
    8001535e:	97ba                	add	a5,a5,a4
    80015360:	fb87c783          	lbu	a5,-72(a5)
    80015364:	2781                	sext.w	a5,a5
    80015366:	85be                	mv	a1,a5
    80015368:	0000d517          	auipc	a0,0xd
    8001536c:	87050513          	addi	a0,a0,-1936 # 80021bd8 <pow10.0+0x9a8>
    80015370:	695030ef          	jal	ra,80019204 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80015374:	fe843783          	ld	a5,-24(s0)
    80015378:	0785                	addi	a5,a5,1
    8001537a:	fef43423          	sd	a5,-24(s0)
    8001537e:	fe843703          	ld	a4,-24(s0)
    80015382:	47bd                	li	a5,15
    80015384:	fce7f9e3          	bgeu	a5,a4,80015356 <init_systems+0x28e>
    }
    debugf("\n");
    80015388:	0000d517          	auipc	a0,0xd
    8001538c:	85850513          	addi	a0,a0,-1960 # 80021be0 <pow10.0+0x9b0>
    80015390:	675030ef          	jal	ra,80019204 <debugf>

    debugf("RNG init done; about to fill\n");
    80015394:	0000d517          	auipc	a0,0xd
    80015398:	85450513          	addi	a0,a0,-1964 # 80021be8 <pow10.0+0x9b8>
    8001539c:	669030ef          	jal	ra,80019204 <debugf>
    rng_fill(buffer, 16);
    800153a0:	fa840793          	addi	a5,s0,-88
    800153a4:	45c1                	li	a1,16
    800153a6:	853e                	mv	a0,a5
    800153a8:	aaafd0ef          	jal	ra,80012652 <rng_fill>
    debugf("RNG State After:");
    800153ac:	0000d517          	auipc	a0,0xd
    800153b0:	85c50513          	addi	a0,a0,-1956 # 80021c08 <pow10.0+0x9d8>
    800153b4:	651030ef          	jal	ra,80019204 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    800153b8:	fe043023          	sd	zero,-32(s0)
    800153bc:	a02d                	j	800153e6 <init_systems+0x31e>
        debugf(" %d ", buffer[i]);
    800153be:	fe043783          	ld	a5,-32(s0)
    800153c2:	ff040713          	addi	a4,s0,-16
    800153c6:	97ba                	add	a5,a5,a4
    800153c8:	fb87c783          	lbu	a5,-72(a5)
    800153cc:	2781                	sext.w	a5,a5
    800153ce:	85be                	mv	a1,a5
    800153d0:	0000d517          	auipc	a0,0xd
    800153d4:	80850513          	addi	a0,a0,-2040 # 80021bd8 <pow10.0+0x9a8>
    800153d8:	62d030ef          	jal	ra,80019204 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    800153dc:	fe043783          	ld	a5,-32(s0)
    800153e0:	0785                	addi	a5,a5,1
    800153e2:	fef43023          	sd	a5,-32(s0)
    800153e6:	fe043703          	ld	a4,-32(s0)
    800153ea:	47bd                	li	a5,15
    800153ec:	fce7f9e3          	bgeu	a5,a4,800153be <init_systems+0x2f6>
    }
    
    rng_fill(buffer, 16);
    800153f0:	fa840793          	addi	a5,s0,-88
    800153f4:	45c1                	li	a1,16
    800153f6:	853e                	mv	a0,a5
    800153f8:	a5afd0ef          	jal	ra,80012652 <rng_fill>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    800153fc:	fc043c23          	sd	zero,-40(s0)
    80015400:	a02d                	j	8001542a <init_systems+0x362>
        debugf(" %d ", buffer[i]);
    80015402:	fd843783          	ld	a5,-40(s0)
    80015406:	ff040713          	addi	a4,s0,-16
    8001540a:	97ba                	add	a5,a5,a4
    8001540c:	fb87c783          	lbu	a5,-72(a5)
    80015410:	2781                	sext.w	a5,a5
    80015412:	85be                	mv	a1,a5
    80015414:	0000c517          	auipc	a0,0xc
    80015418:	7c450513          	addi	a0,a0,1988 # 80021bd8 <pow10.0+0x9a8>
    8001541c:	5e9030ef          	jal	ra,80019204 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80015420:	fd843783          	ld	a5,-40(s0)
    80015424:	0785                	addi	a5,a5,1
    80015426:	fcf43c23          	sd	a5,-40(s0)
    8001542a:	fd843703          	ld	a4,-40(s0)
    8001542e:	47bd                	li	a5,15
    80015430:	fce7f9e3          	bgeu	a5,a4,80015402 <init_systems+0x33a>
            buf[i], buf[i+1], buf[i+2], buf[i+3],
            buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
    }
    */
    // TEST GPU
    debugf("GPU init %s\n", gpu_test() ? "successful" : "failed");
    80015434:	8d4ff0ef          	jal	ra,80014508 <gpu_test>
    80015438:	87aa                	mv	a5,a0
    8001543a:	c791                	beqz	a5,80015446 <init_systems+0x37e>
    8001543c:	0000c797          	auipc	a5,0xc
    80015440:	7e478793          	addi	a5,a5,2020 # 80021c20 <pow10.0+0x9f0>
    80015444:	a029                	j	8001544e <init_systems+0x386>
    80015446:	0000c797          	auipc	a5,0xc
    8001544a:	7ea78793          	addi	a5,a5,2026 # 80021c30 <pow10.0+0xa00>
    8001544e:	85be                	mv	a1,a5
    80015450:	0000c517          	auipc	a0,0xc
    80015454:	7e850513          	addi	a0,a0,2024 # 80021c38 <pow10.0+0xa08>
    80015458:	5ad030ef          	jal	ra,80019204 <debugf>
#endif
}
    8001545c:	0001                	nop
    8001545e:	60e6                	ld	ra,88(sp)
    80015460:	6446                	ld	s0,80(sp)
    80015462:	6125                	addi	sp,sp,96
    80015464:	8082                	ret

0000000080015466 <main>:
static const char *hart_status_values[] = {"NOT PRESENT", "STOPPED", "STARTING", "RUNNING"};
#ifdef RUN_INTERNAL_CONSOLE
static void console(void);
#endif
void main(unsigned int hart)
{
    80015466:	7179                	addi	sp,sp,-48
    80015468:	f406                	sd	ra,40(sp)
    8001546a:	f022                	sd	s0,32(sp)
    8001546c:	1800                	addi	s0,sp,48
    8001546e:	87aa                	mv	a5,a0
    80015470:	fcf42e23          	sw	a5,-36(s0)
    // Initialize the page allocator
    // Allocate and zero the kernel's page table.

    // Kind of neat to see our memory mappings to ensure they make sense.
    logf(LOG_INFO, "[[ MEMORY MAPPINGS ]]\n");
    80015474:	0000d597          	auipc	a1,0xd
    80015478:	80458593          	addi	a1,a1,-2044 # 80021c78 <pow10.0+0xa48>
    8001547c:	4511                	li	a0,4
    8001547e:	529030ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  [TEXT]  : 0x%08lx -> 0x%08lx\n", sym_start(text), sym_end(text));
    80015482:	ffffb797          	auipc	a5,0xffffb
    80015486:	b7e78793          	addi	a5,a5,-1154 # 80010000 <_memory_start>
    8001548a:	00009717          	auipc	a4,0x9
    8001548e:	3d070713          	addi	a4,a4,976 # 8001e85a <_text_end>
    80015492:	86ba                	mv	a3,a4
    80015494:	863e                	mv	a2,a5
    80015496:	0000c597          	auipc	a1,0xc
    8001549a:	7fa58593          	addi	a1,a1,2042 # 80021c90 <pow10.0+0xa60>
    8001549e:	4511                	li	a0,4
    800154a0:	507030ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  [BSS]   : 0x%08lx -> 0x%08lx\n", sym_start(bss), sym_end(bss));
    800154a4:	0000b797          	auipc	a5,0xb
    800154a8:	b5c78793          	addi	a5,a5,-1188 # 80020000 <kernel_mmu_table>
    800154ac:	0000b717          	auipc	a4,0xb
    800154b0:	cc070713          	addi	a4,a4,-832 # 8002016c <_bss_end>
    800154b4:	86ba                	mv	a3,a4
    800154b6:	863e                	mv	a2,a5
    800154b8:	0000c597          	auipc	a1,0xc
    800154bc:	7f858593          	addi	a1,a1,2040 # 80021cb0 <pow10.0+0xa80>
    800154c0:	4511                	li	a0,4
    800154c2:	4e5030ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  [RODATA]: 0x%08lx -> 0x%08lx\n", sym_start(rodata), sym_end(rodata));
    800154c6:	0000c797          	auipc	a5,0xc
    800154ca:	b3a78793          	addi	a5,a5,-1222 # 80021000 <SYSCALLS>
    800154ce:	0000e717          	auipc	a4,0xe
    800154d2:	efa70713          	addi	a4,a4,-262 # 800233c8 <NUM_SYSCALLS>
    800154d6:	86ba                	mv	a3,a4
    800154d8:	863e                	mv	a2,a5
    800154da:	0000c597          	auipc	a1,0xc
    800154de:	7f658593          	addi	a1,a1,2038 # 80021cd0 <pow10.0+0xaa0>
    800154e2:	4511                	li	a0,4
    800154e4:	4c3030ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  [DATA]  : 0x%08lx -> 0x%08lx\n", sym_start(data), sym_end(data));
    800154e8:	0000f797          	auipc	a5,0xf
    800154ec:	b1878793          	addi	a5,a5,-1256 # 80024000 <subordinate>
    800154f0:	0000f717          	auipc	a4,0xf
    800154f4:	b4070713          	addi	a4,a4,-1216 # 80024030 <_data_end>
    800154f8:	86ba                	mv	a3,a4
    800154fa:	863e                	mv	a2,a5
    800154fc:	0000c597          	auipc	a1,0xc
    80015500:	7f458593          	addi	a1,a1,2036 # 80021cf0 <pow10.0+0xac0>
    80015504:	4511                	li	a0,4
    80015506:	4a1030ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  [STACK] : 0x%08lx -> 0x%08lx\n", sym_start(stack), sym_end(stack));
    8001550a:	00010797          	auipc	a5,0x10
    8001550e:	af678793          	addi	a5,a5,-1290 # 80025000 <_stack_start>
    80015512:	00018717          	auipc	a4,0x18
    80015516:	aee70713          	addi	a4,a4,-1298 # 8002d000 <_heap_start>
    8001551a:	86ba                	mv	a3,a4
    8001551c:	863e                	mv	a2,a5
    8001551e:	0000c597          	auipc	a1,0xc
    80015522:	7f258593          	addi	a1,a1,2034 # 80021d10 <pow10.0+0xae0>
    80015526:	4511                	li	a0,4
    80015528:	47f030ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  [HEAP]  : 0x%08lx -> 0x%08lx\n", sym_start(heap), sym_end(heap));
    8001552c:	00018797          	auipc	a5,0x18
    80015530:	ad478793          	addi	a5,a5,-1324 # 8002d000 <_heap_start>
    80015534:	07ffb717          	auipc	a4,0x7ffb
    80015538:	acc70713          	addi	a4,a4,-1332 # 88010000 <_heap_end>
    8001553c:	86ba                	mv	a3,a4
    8001553e:	863e                	mv	a2,a5
    80015540:	0000c597          	auipc	a1,0xc
    80015544:	7f058593          	addi	a1,a1,2032 # 80021d30 <pow10.0+0xb00>
    80015548:	4511                	li	a0,4
    8001554a:	45d030ef          	jal	ra,800191a6 <logf>

    logf(LOG_INFO, "[[ HART MAPPINGS ]]\n");
    8001554e:	0000d597          	auipc	a1,0xd
    80015552:	80258593          	addi	a1,a1,-2046 # 80021d50 <pow10.0+0xb20>
    80015556:	4511                	li	a0,4
    80015558:	44f030ef          	jal	ra,800191a6 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    8001555c:	fe042623          	sw	zero,-20(s0)
    80015560:	a8bd                	j	800155de <main+0x178>
        if (i == hart) {
    80015562:	fec42703          	lw	a4,-20(s0)
    80015566:	fdc42783          	lw	a5,-36(s0)
    8001556a:	2701                	sext.w	a4,a4
    8001556c:	2781                	sext.w	a5,a5
    8001556e:	02f71b63          	bne	a4,a5,800155a4 <main+0x13e>
            logf(LOG_INFO, "  [HART#%d]: %s (this HART).\n", i, hart_status_values[sbi_hart_get_status(i)]);
    80015572:	fec42783          	lw	a5,-20(s0)
    80015576:	853e                	mv	a0,a5
    80015578:	6eb030ef          	jal	ra,80019462 <sbi_hart_get_status>
    8001557c:	87aa                	mv	a5,a0
    8001557e:	0000f717          	auipc	a4,0xf
    80015582:	a9270713          	addi	a4,a4,-1390 # 80024010 <hart_status_values>
    80015586:	078e                	slli	a5,a5,0x3
    80015588:	97ba                	add	a5,a5,a4
    8001558a:	6398                	ld	a4,0(a5)
    8001558c:	fec42783          	lw	a5,-20(s0)
    80015590:	86ba                	mv	a3,a4
    80015592:	863e                	mv	a2,a5
    80015594:	0000c597          	auipc	a1,0xc
    80015598:	7d458593          	addi	a1,a1,2004 # 80021d68 <pow10.0+0xb38>
    8001559c:	4511                	li	a0,4
    8001559e:	409030ef          	jal	ra,800191a6 <logf>
    800155a2:	a80d                	j	800155d4 <main+0x16e>
        }
        else {
            logf(LOG_INFO, "  [HART#%d]: %s.\n", i, hart_status_values[sbi_hart_get_status(i)]);
    800155a4:	fec42783          	lw	a5,-20(s0)
    800155a8:	853e                	mv	a0,a5
    800155aa:	6b9030ef          	jal	ra,80019462 <sbi_hart_get_status>
    800155ae:	87aa                	mv	a5,a0
    800155b0:	0000f717          	auipc	a4,0xf
    800155b4:	a6070713          	addi	a4,a4,-1440 # 80024010 <hart_status_values>
    800155b8:	078e                	slli	a5,a5,0x3
    800155ba:	97ba                	add	a5,a5,a4
    800155bc:	6398                	ld	a4,0(a5)
    800155be:	fec42783          	lw	a5,-20(s0)
    800155c2:	86ba                	mv	a3,a4
    800155c4:	863e                	mv	a2,a5
    800155c6:	0000c597          	auipc	a1,0xc
    800155ca:	7c258593          	addi	a1,a1,1986 # 80021d88 <pow10.0+0xb58>
    800155ce:	4511                	li	a0,4
    800155d0:	3d7030ef          	jal	ra,800191a6 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800155d4:	fec42783          	lw	a5,-20(s0)
    800155d8:	2785                	addiw	a5,a5,1
    800155da:	fef42623          	sw	a5,-20(s0)
    800155de:	fec42783          	lw	a5,-20(s0)
    800155e2:	0007871b          	sext.w	a4,a5
    800155e6:	478d                	li	a5,3
    800155e8:	f6e7fde3          	bgeu	a5,a4,80015562 <main+0xfc>
        }
    }

    // Initialize all submodules here, including PCI, VirtIO, Heap, etc.
    // Many will require the MMU, so write those functions first.
    init_systems();
    800155ec:	addff0ef          	jal	ra,800150c8 <init_systems>

    // Now that all submodules are initialized, you need to schedule the init process
    // and the idle processes for each HART.
    logf(LOG_INFO, "Congratulations! You made it to the OS! Going back to sleep.\n");
    800155f0:	0000c597          	auipc	a1,0xc
    800155f4:	7b058593          	addi	a1,a1,1968 # 80021da0 <pow10.0+0xb70>
    800155f8:	4511                	li	a0,4
    800155fa:	3ad030ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, 
    800155fe:	0000c597          	auipc	a1,0xc
    80015602:	7e258593          	addi	a1,a1,2018 # 80021de0 <pow10.0+0xbb0>
    80015606:	4511                	li	a0,4
    80015608:	39f030ef          	jal	ra,800191a6 <logf>
        "The logf function in the OS uses sbi_putchar(), so this means ECALLs from S-mode are "
        "working!\n");
    logf(LOG_INFO, 
    8001560c:	0000d597          	auipc	a1,0xd
    80015610:	83458593          	addi	a1,a1,-1996 # 80021e40 <pow10.0+0xc10>
    80015614:	4511                	li	a0,4
    80015616:	391030ef          	jal	ra,800191a6 <logf>
    // Below is just a little shell that demonstrates the sbi_getchar and
    // how the console works.

    // This is defined above main()
#ifdef RUN_INTERNAL_CONSOLE
    minix3_init();
    8001561a:	31f000ef          	jal	ra,80016138 <minix3_init>
    console();
    8001561e:	004000ef          	jal	ra,80015622 <console>

0000000080015622 <console>:
#endif
}

#ifdef RUN_INTERNAL_CONSOLE
ATTR_NORET static void console(void)
{
    80015622:	7179                	addi	sp,sp,-48
    80015624:	f406                	sd	ra,40(sp)
    80015626:	f022                	sd	s0,32(sp)
    80015628:	1800                	addi	s0,sp,48
    const int BUFFER_SIZE = 56;
    8001562a:	03800313          	li	t1,56
    8001562e:	fe642423          	sw	t1,-24(s0)
    int at                = 0;
    80015632:	fe042623          	sw	zero,-20(s0)
    char input[BUFFER_SIZE];
    80015636:	fe842303          	lw	t1,-24(s0)
    8001563a:	137d                	addi	t1,t1,-1
    8001563c:	fe643023          	sd	t1,-32(s0)
    80015640:	fe842303          	lw	t1,-24(s0)
    80015644:	881a                	mv	a6,t1
    80015646:	4881                	li	a7,0
    80015648:	03d85313          	srli	t1,a6,0x3d
    8001564c:	00389693          	slli	a3,a7,0x3
    80015650:	00d366b3          	or	a3,t1,a3
    80015654:	00381613          	slli	a2,a6,0x3
    80015658:	fe842683          	lw	a3,-24(s0)
    8001565c:	8536                	mv	a0,a3
    8001565e:	4581                	li	a1,0
    80015660:	03d55693          	srli	a3,a0,0x3d
    80015664:	00359793          	slli	a5,a1,0x3
    80015668:	8fd5                	or	a5,a5,a3
    8001566a:	00351713          	slli	a4,a0,0x3
    8001566e:	fe842783          	lw	a5,-24(s0)
    80015672:	07bd                	addi	a5,a5,15
    80015674:	8391                	srli	a5,a5,0x4
    80015676:	0792                	slli	a5,a5,0x4
    80015678:	40f10133          	sub	sp,sp,a5
    8001567c:	878a                	mv	a5,sp
    8001567e:	00078793          	mv	a5,a5
    80015682:	fcf43c23          	sd	a5,-40(s0)
    logf(LOG_TEXT, "> ");
    80015686:	0000d597          	auipc	a1,0xd
    8001568a:	81a58593          	addi	a1,a1,-2022 # 80021ea0 <pow10.0+0xc70>
    8001568e:	02000513          	li	a0,32
    80015692:	315030ef          	jal	ra,800191a6 <logf>
    do {
        char c;
        // Recall that sbi_getchar() will return -1, 0xff, 255
        // if the receiver is empty.
        if ((c = sbi_getchar()) != 0xff) {
    80015696:	5ad030ef          	jal	ra,80019442 <sbi_getchar>
    8001569a:	87aa                	mv	a5,a0
    8001569c:	fcf40ba3          	sb	a5,-41(s0)
    800156a0:	fd744783          	lbu	a5,-41(s0)
    800156a4:	0ff7f713          	andi	a4,a5,255
    800156a8:	0ff00793          	li	a5,255
    800156ac:	22f70963          	beq	a4,a5,800158de <console+0x2bc>
            if (c == '\r' || c == '\n') {
    800156b0:	fd744783          	lbu	a5,-41(s0)
    800156b4:	0ff7f713          	andi	a4,a5,255
    800156b8:	47b5                	li	a5,13
    800156ba:	00f70963          	beq	a4,a5,800156cc <console+0xaa>
    800156be:	fd744783          	lbu	a5,-41(s0)
    800156c2:	0ff7f713          	andi	a4,a5,255
    800156c6:	47a9                	li	a5,10
    800156c8:	0ef71163          	bne	a4,a5,800157aa <console+0x188>
                if (at > 0) {
    800156cc:	fec42783          	lw	a5,-20(s0)
    800156d0:	2781                	sext.w	a5,a5
    800156d2:	0cf05363          	blez	a5,80015798 <console+0x176>
                    input[at] = '\0';
    800156d6:	fd843703          	ld	a4,-40(s0)
    800156da:	fec42783          	lw	a5,-20(s0)
    800156de:	97ba                	add	a5,a5,a4
    800156e0:	00078023          	sb	zero,0(a5)
                    if (!strcmp(input, "quit")) {
    800156e4:	0000c597          	auipc	a1,0xc
    800156e8:	7c458593          	addi	a1,a1,1988 # 80021ea8 <pow10.0+0xc78>
    800156ec:	fd843503          	ld	a0,-40(s0)
    800156f0:	0ca080ef          	jal	ra,8001d7ba <strcmp>
    800156f4:	87aa                	mv	a5,a0
    800156f6:	ef81                	bnez	a5,8001570e <console+0xec>
                        logf(LOG_TEXT, "\nShutting down...\n\n");
    800156f8:	0000c597          	auipc	a1,0xc
    800156fc:	7b858593          	addi	a1,a1,1976 # 80021eb0 <pow10.0+0xc80>
    80015700:	02000513          	li	a0,32
    80015704:	2a3030ef          	jal	ra,800191a6 <logf>
                        sbi_poweroff();
    80015708:	5eb030ef          	jal	ra,800194f2 <sbi_poweroff>
    8001570c:	a061                	j	80015794 <console+0x172>
                    }
                    else if (!strcmp(input, "fatal")) {
    8001570e:	0000c597          	auipc	a1,0xc
    80015712:	7ba58593          	addi	a1,a1,1978 # 80021ec8 <pow10.0+0xc98>
    80015716:	fd843503          	ld	a0,-40(s0)
    8001571a:	0a0080ef          	jal	ra,8001d7ba <strcmp>
    8001571e:	87aa                	mv	a5,a0
    80015720:	eb9d                	bnez	a5,80015756 <console+0x134>
                        logf(LOG_TEXT, "\n");
    80015722:	0000c597          	auipc	a1,0xc
    80015726:	4be58593          	addi	a1,a1,1214 # 80021be0 <pow10.0+0x9b0>
    8001572a:	02000513          	li	a0,32
    8001572e:	279030ef          	jal	ra,800191a6 <logf>
                        fatalf("Testing fatal error @ %lu.\nHanging HART...\n", sbi_rtc_get_time());
    80015732:	665030ef          	jal	ra,80019596 <sbi_rtc_get_time>
    80015736:	87aa                	mv	a5,a0
    80015738:	85be                	mv	a1,a5
    8001573a:	0000c517          	auipc	a0,0xc
    8001573e:	79650513          	addi	a0,a0,1942 # 80021ed0 <pow10.0+0xca0>
    80015742:	41d030ef          	jal	ra,8001935e <fatalf>
                        logf(LOG_ERROR, "If I get here, fatal didn't work :'(.\n");
    80015746:	0000c597          	auipc	a1,0xc
    8001574a:	7ba58593          	addi	a1,a1,1978 # 80021f00 <pow10.0+0xcd0>
    8001574e:	4505                	li	a0,1
    80015750:	257030ef          	jal	ra,800191a6 <logf>
    80015754:	a081                	j	80015794 <console+0x172>
                    }
                    else if (!strcmp(input, "heap")) {
    80015756:	0000c597          	auipc	a1,0xc
    8001575a:	7d258593          	addi	a1,a1,2002 # 80021f28 <pow10.0+0xcf8>
    8001575e:	fd843503          	ld	a0,-40(s0)
    80015762:	058080ef          	jal	ra,8001d7ba <strcmp>
    80015766:	87aa                	mv	a5,a0
    80015768:	ef81                	bnez	a5,80015780 <console+0x15e>
                        logf(LOG_TEXT, "\n");
    8001576a:	0000c597          	auipc	a1,0xc
    8001576e:	47658593          	addi	a1,a1,1142 # 80021be0 <pow10.0+0x9b0>
    80015772:	02000513          	li	a0,32
    80015776:	231030ef          	jal	ra,800191a6 <logf>
                        void heap_print_stats(void);
                        heap_print_stats();
    8001577a:	cbefe0ef          	jal	ra,80013c38 <heap_print_stats>
    8001577e:	a819                	j	80015794 <console+0x172>
                    }
                    else {
                        logf(LOG_TEXT, "\nUnknown command '%s'\n", input);
    80015780:	fd843603          	ld	a2,-40(s0)
    80015784:	0000c597          	auipc	a1,0xc
    80015788:	7ac58593          	addi	a1,a1,1964 # 80021f30 <pow10.0+0xd00>
    8001578c:	02000513          	li	a0,32
    80015790:	217030ef          	jal	ra,800191a6 <logf>
                    }
                    at = 0;
    80015794:	fe042623          	sw	zero,-20(s0)
                }
                logf(LOG_TEXT, "\n> ");
    80015798:	0000c597          	auipc	a1,0xc
    8001579c:	7b058593          	addi	a1,a1,1968 # 80021f48 <pow10.0+0xd18>
    800157a0:	02000513          	li	a0,32
    800157a4:	203030ef          	jal	ra,800191a6 <logf>
    800157a8:	aa3d                	j	800158e6 <console+0x2c4>
            }
            else if (c == 127) {
    800157aa:	fd744783          	lbu	a5,-41(s0)
    800157ae:	0ff7f713          	andi	a4,a5,255
    800157b2:	07f00793          	li	a5,127
    800157b6:	02f71563          	bne	a4,a5,800157e0 <console+0x1be>
                // BACKSPACE
                if (at > 0) {
    800157ba:	fec42783          	lw	a5,-20(s0)
    800157be:	2781                	sext.w	a5,a5
    800157c0:	ecf05be3          	blez	a5,80015696 <console+0x74>
                    logf(LOG_TEXT, "\b \b");
    800157c4:	0000c597          	auipc	a1,0xc
    800157c8:	78c58593          	addi	a1,a1,1932 # 80021f50 <pow10.0+0xd20>
    800157cc:	02000513          	li	a0,32
    800157d0:	1d7030ef          	jal	ra,800191a6 <logf>
                    at -= 1;
    800157d4:	fec42783          	lw	a5,-20(s0)
    800157d8:	37fd                	addiw	a5,a5,-1
    800157da:	fef42623          	sw	a5,-20(s0)
    800157de:	bd65                	j	80015696 <console+0x74>
                }
            }
            else if (c == 0x1B) {
    800157e0:	fd744783          	lbu	a5,-41(s0)
    800157e4:	0ff7f713          	andi	a4,a5,255
    800157e8:	47ed                	li	a5,27
    800157ea:	0af71663          	bne	a4,a5,80015896 <console+0x274>
                // Escape sequence
                char esc1 = sbi_getchar();
    800157ee:	455030ef          	jal	ra,80019442 <sbi_getchar>
    800157f2:	87aa                	mv	a5,a0
    800157f4:	fcf40b23          	sb	a5,-42(s0)
                char esc2 = sbi_getchar();
    800157f8:	44b030ef          	jal	ra,80019442 <sbi_getchar>
    800157fc:	87aa                	mv	a5,a0
    800157fe:	fcf40aa3          	sb	a5,-43(s0)
                if (esc1 == 0x5B) {
    80015802:	fd644783          	lbu	a5,-42(s0)
    80015806:	0ff7f713          	andi	a4,a5,255
    8001580a:	05b00793          	li	a5,91
    8001580e:	0cf71b63          	bne	a4,a5,800158e4 <console+0x2c2>
                    switch (esc2) {
    80015812:	fd544783          	lbu	a5,-43(s0)
    80015816:	2781                	sext.w	a5,a5
    80015818:	86be                	mv	a3,a5
    8001581a:	04400713          	li	a4,68
    8001581e:	06e68463          	beq	a3,a4,80015886 <console+0x264>
    80015822:	86be                	mv	a3,a5
    80015824:	04400713          	li	a4,68
    80015828:	e6d747e3          	blt	a4,a3,80015696 <console+0x74>
    8001582c:	86be                	mv	a3,a5
    8001582e:	04300713          	li	a4,67
    80015832:	04e68263          	beq	a3,a4,80015876 <console+0x254>
    80015836:	86be                	mv	a3,a5
    80015838:	04300713          	li	a4,67
    8001583c:	e4d74de3          	blt	a4,a3,80015696 <console+0x74>
    80015840:	86be                	mv	a3,a5
    80015842:	04100713          	li	a4,65
    80015846:	00e68863          	beq	a3,a4,80015856 <console+0x234>
    8001584a:	873e                	mv	a4,a5
    8001584c:	04200793          	li	a5,66
    80015850:	00f70b63          	beq	a4,a5,80015866 <console+0x244>
    80015854:	a849                	j	800158e6 <console+0x2c4>
                        case 0x41:
                            logf(LOG_INFO, "UP\n");
    80015856:	0000c597          	auipc	a1,0xc
    8001585a:	70258593          	addi	a1,a1,1794 # 80021f58 <pow10.0+0xd28>
    8001585e:	4511                	li	a0,4
    80015860:	147030ef          	jal	ra,800191a6 <logf>
                            break;
    80015864:	a049                	j	800158e6 <console+0x2c4>
                        case 0x42:
                            logf(LOG_INFO, "DOWN\n");
    80015866:	0000c597          	auipc	a1,0xc
    8001586a:	6fa58593          	addi	a1,a1,1786 # 80021f60 <pow10.0+0xd30>
    8001586e:	4511                	li	a0,4
    80015870:	137030ef          	jal	ra,800191a6 <logf>
                            break;
    80015874:	a88d                	j	800158e6 <console+0x2c4>
                        case 0x43:
                            logf(LOG_INFO, "RIGHT\n");
    80015876:	0000c597          	auipc	a1,0xc
    8001587a:	6f258593          	addi	a1,a1,1778 # 80021f68 <pow10.0+0xd38>
    8001587e:	4511                	li	a0,4
    80015880:	127030ef          	jal	ra,800191a6 <logf>
                            break;
    80015884:	a08d                	j	800158e6 <console+0x2c4>
                        case 0x44:
                            logf(LOG_INFO, "LEFT\n");
    80015886:	0000c597          	auipc	a1,0xc
    8001588a:	6ea58593          	addi	a1,a1,1770 # 80021f70 <pow10.0+0xd40>
    8001588e:	4511                	li	a0,4
    80015890:	117030ef          	jal	ra,800191a6 <logf>
                            break;
    80015894:	a889                	j	800158e6 <console+0x2c4>
                    }
                }
            }
            else {
                if (at < (BUFFER_SIZE - 1)) {
    80015896:	fe842783          	lw	a5,-24(s0)
    8001589a:	37fd                	addiw	a5,a5,-1
    8001589c:	0007871b          	sext.w	a4,a5
    800158a0:	fec42783          	lw	a5,-20(s0)
    800158a4:	2781                	sext.w	a5,a5
    800158a6:	dee7d8e3          	bge	a5,a4,80015696 <console+0x74>
                    input[at++] = c;
    800158aa:	fec42783          	lw	a5,-20(s0)
    800158ae:	0017871b          	addiw	a4,a5,1
    800158b2:	fee42623          	sw	a4,-20(s0)
    800158b6:	fd843703          	ld	a4,-40(s0)
    800158ba:	97ba                	add	a5,a5,a4
    800158bc:	fd744703          	lbu	a4,-41(s0)
    800158c0:	00e78023          	sb	a4,0(a5)
                    logf(LOG_TEXT, "%c", c);
    800158c4:	fd744783          	lbu	a5,-41(s0)
    800158c8:	2781                	sext.w	a5,a5
    800158ca:	863e                	mv	a2,a5
    800158cc:	0000c597          	auipc	a1,0xc
    800158d0:	6ac58593          	addi	a1,a1,1708 # 80021f78 <pow10.0+0xd48>
    800158d4:	02000513          	li	a0,32
    800158d8:	0cf030ef          	jal	ra,800191a6 <logf>
    800158dc:	bb6d                	j	80015696 <console+0x74>
            }
        }
        else {
            // We can WFI here since interrupts are enabled
            // for the UART.
            WFI();
    800158de:	10500073          	wfi
    800158e2:	bb55                	j	80015696 <console+0x74>
                }
    800158e4:	0001                	nop
    do {
    800158e6:	bb45                	j	80015696 <console+0x74>

00000000800158e8 <minix3_inode_to_path>:
static Map *mapped_paths;

// A map of inodes to file paths (absolute path strings)
static Map *mapped_inodes;

const char *minix3_inode_to_path(uint32_t inode) {
    800158e8:	7179                	addi	sp,sp,-48
    800158ea:	f406                	sd	ra,40(sp)
    800158ec:	f022                	sd	s0,32(sp)
    800158ee:	1800                	addi	s0,sp,48
    800158f0:	87aa                	mv	a5,a0
    800158f2:	fcf42e23          	sw	a5,-36(s0)
    uint64_t path;
    map_get_int(mapped_inodes, inode, &path);
    800158f6:	0000a797          	auipc	a5,0xa
    800158fa:	7e278793          	addi	a5,a5,2018 # 800200d8 <mapped_inodes>
    800158fe:	639c                	ld	a5,0(a5)
    80015900:	fdc46703          	lwu	a4,-36(s0)
    80015904:	fe840693          	addi	a3,s0,-24
    80015908:	8636                	mv	a2,a3
    8001590a:	85ba                	mv	a1,a4
    8001590c:	853e                	mv	a0,a5
    8001590e:	43c070ef          	jal	ra,8001cd4a <map_get_int>
    return (const char *)path;
    80015912:	fe843783          	ld	a5,-24(s0)
}
    80015916:	853e                	mv	a0,a5
    80015918:	70a2                	ld	ra,40(sp)
    8001591a:	7402                	ld	s0,32(sp)
    8001591c:	6145                	addi	sp,sp,48
    8001591e:	8082                	ret

0000000080015920 <minix3_path_to_inode>:

uint32_t minix3_path_to_inode(const char *path) {
    80015920:	7179                	addi	sp,sp,-48
    80015922:	f406                	sd	ra,40(sp)
    80015924:	f022                	sd	s0,32(sp)
    80015926:	1800                	addi	s0,sp,48
    80015928:	fca43c23          	sd	a0,-40(s0)
    uint64_t inode;
    map_get(mapped_paths, path, &inode);
    8001592c:	0000a797          	auipc	a5,0xa
    80015930:	7a478793          	addi	a5,a5,1956 # 800200d0 <mapped_paths>
    80015934:	639c                	ld	a5,0(a5)
    80015936:	fe840713          	addi	a4,s0,-24
    8001593a:	863a                	mv	a2,a4
    8001593c:	fd843583          	ld	a1,-40(s0)
    80015940:	853e                	mv	a0,a5
    80015942:	3bc070ef          	jal	ra,8001ccfe <map_get>
    return inode;
    80015946:	fe843783          	ld	a5,-24(s0)
    8001594a:	2781                	sext.w	a5,a5
}
    8001594c:	853e                	mv	a0,a5
    8001594e:	70a2                	ld	ra,40(sp)
    80015950:	7402                	ld	s0,32(sp)
    80015952:	6145                	addi	sp,sp,48
    80015954:	8082                	ret

0000000080015956 <map_callback>:

void map_callback(uint32_t inode, const char *path, char *name, void *data, uint32_t depth) {
    80015956:	7179                	addi	sp,sp,-48
    80015958:	f406                	sd	ra,40(sp)
    8001595a:	f022                	sd	s0,32(sp)
    8001595c:	1800                	addi	s0,sp,48
    8001595e:	87aa                	mv	a5,a0
    80015960:	feb43023          	sd	a1,-32(s0)
    80015964:	fcc43c23          	sd	a2,-40(s0)
    80015968:	fcd43823          	sd	a3,-48(s0)
    8001596c:	fef42623          	sw	a5,-20(s0)
    80015970:	87ba                	mv	a5,a4
    80015972:	fef42423          	sw	a5,-24(s0)
    infof("Mapping %s to %u\n", path, inode);
    80015976:	fec42783          	lw	a5,-20(s0)
    8001597a:	863e                	mv	a2,a5
    8001597c:	fe043583          	ld	a1,-32(s0)
    80015980:	0000c517          	auipc	a0,0xc
    80015984:	60050513          	addi	a0,a0,1536 # 80021f80 <pow10.0+0xd50>
    80015988:	181030ef          	jal	ra,80019308 <infof>
    map_set(mapped_paths, path, inode);
    8001598c:	0000a797          	auipc	a5,0xa
    80015990:	74478793          	addi	a5,a5,1860 # 800200d0 <mapped_paths>
    80015994:	639c                	ld	a5,0(a5)
    80015996:	fec46703          	lwu	a4,-20(s0)
    8001599a:	863a                	mv	a2,a4
    8001599c:	fe043583          	ld	a1,-32(s0)
    800159a0:	853e                	mv	a0,a5
    800159a2:	29a070ef          	jal	ra,8001cc3c <map_set>
    map_set_int(mapped_inodes, inode, (uintptr_t)path);
    800159a6:	0000a797          	auipc	a5,0xa
    800159aa:	73278793          	addi	a5,a5,1842 # 800200d8 <mapped_inodes>
    800159ae:	639c                	ld	a5,0(a5)
    800159b0:	fec46703          	lwu	a4,-20(s0)
    800159b4:	fe043683          	ld	a3,-32(s0)
    800159b8:	8636                	mv	a2,a3
    800159ba:	85ba                	mv	a1,a4
    800159bc:	853e                	mv	a0,a5
    800159be:	2d0070ef          	jal	ra,8001cc8e <map_set_int>
}
    800159c2:	0001                	nop
    800159c4:	70a2                	ld	ra,40(sp)
    800159c6:	7402                	ld	s0,32(sp)
    800159c8:	6145                	addi	sp,sp,48
    800159ca:	8082                	ret

00000000800159cc <minix3_map_files>:

// This creates the `mapped_paths` and `mapped_inodes` maps
// for caching the paths of files and their inodes
void minix3_map_files(void) {
    800159cc:	1141                	addi	sp,sp,-16
    800159ce:	e406                	sd	ra,8(sp)
    800159d0:	e022                	sd	s0,0(sp)
    800159d2:	0800                	addi	s0,sp,16
    infof("Mapping files...\n");
    800159d4:	0000c517          	auipc	a0,0xc
    800159d8:	5c450513          	addi	a0,a0,1476 # 80021f98 <pow10.0+0xd68>
    800159dc:	12d030ef          	jal	ra,80019308 <infof>
    mapped_paths = map_new();
    800159e0:	1d6070ef          	jal	ra,8001cbb6 <map_new>
    800159e4:	872a                	mv	a4,a0
    800159e6:	0000a797          	auipc	a5,0xa
    800159ea:	6ea78793          	addi	a5,a5,1770 # 800200d0 <mapped_paths>
    800159ee:	e398                	sd	a4,0(a5)
    mapped_inodes = map_new();
    800159f0:	1c6070ef          	jal	ra,8001cbb6 <map_new>
    800159f4:	872a                	mv	a4,a0
    800159f6:	0000a797          	auipc	a5,0xa
    800159fa:	6e278793          	addi	a5,a5,1762 # 800200d8 <mapped_inodes>
    800159fe:	e398                	sd	a4,0(a5)

    minix3_traverse(1, "/", NULL, 0, 10, map_callback);
    80015a00:	00000797          	auipc	a5,0x0
    80015a04:	f5678793          	addi	a5,a5,-170 # 80015956 <map_callback>
    80015a08:	4729                	li	a4,10
    80015a0a:	4681                	li	a3,0
    80015a0c:	4601                	li	a2,0
    80015a0e:	0000c597          	auipc	a1,0xc
    80015a12:	5a258593          	addi	a1,a1,1442 # 80021fb0 <pow10.0+0xd80>
    80015a16:	4505                	li	a0,1
    80015a18:	022030ef          	jal	ra,80018a3a <minix3_traverse>
}
    80015a1c:	0001                	nop
    80015a1e:	60a2                	ld	ra,8(sp)
    80015a20:	6402                	ld	s0,0(sp)
    80015a22:	0141                	addi	sp,sp,16
    80015a24:	8082                	ret

0000000080015a26 <debug_dir_entry>:

static uint8_t *inode_bitmap;
static uint8_t *zone_bitmap;

void debug_dir_entry(DirEntry entry) {
    80015a26:	1101                	addi	sp,sp,-32
    80015a28:	ec22                	sd	s0,24(sp)
    80015a2a:	1000                	addi	s0,sp,32
    debugf("Entry: %u `", entry.inode);
    for (uint8_t i=0; i<60; i++) {
    80015a2c:	fe0407a3          	sb	zero,-17(s0)
    80015a30:	a031                	j	80015a3c <debug_dir_entry+0x16>
    80015a32:	fef44783          	lbu	a5,-17(s0)
    80015a36:	2785                	addiw	a5,a5,1
    80015a38:	fef407a3          	sb	a5,-17(s0)
    80015a3c:	fef44783          	lbu	a5,-17(s0)
    80015a40:	0ff7f713          	andi	a4,a5,255
    80015a44:	03b00793          	li	a5,59
    80015a48:	fee7f5e3          	bgeu	a5,a4,80015a32 <debug_dir_entry+0xc>
        #endif
    }
    #ifdef minix3_DEBUG
    infof("`\n");
    #endif
}
    80015a4c:	0001                	nop
    80015a4e:	0001                	nop
    80015a50:	6462                	ld	s0,24(sp)
    80015a52:	6105                	addi	sp,sp,32
    80015a54:	8082                	ret

0000000080015a56 <minix3_get_inode_from_path>:

uint32_t minix3_get_inode_from_path(const char *path) {
    80015a56:	715d                	addi	sp,sp,-80
    80015a58:	e486                	sd	ra,72(sp)
    80015a5a:	e0a2                	sd	s0,64(sp)
    80015a5c:	0880                	addi	s0,sp,80
    80015a5e:	faa43c23          	sd	a0,-72(s0)
    List *path_items = path_split(path);
    80015a62:	fb843503          	ld	a0,-72(s0)
    80015a66:	78a070ef          	jal	ra,8001d1f0 <path_split>
    80015a6a:	fca43c23          	sd	a0,-40(s0)

    uint32_t parent = 1; // Root inode
    80015a6e:	4785                	li	a5,1
    80015a70:	fef42623          	sw	a5,-20(s0)

    uint32_t i = 0, num_items = list_size(path_items);
    80015a74:	fe042423          	sw	zero,-24(s0)
    80015a78:	fd843503          	ld	a0,-40(s0)
    80015a7c:	153060ef          	jal	ra,8001c3ce <list_size>
    80015a80:	87aa                	mv	a5,a0
    80015a82:	fcf42a23          	sw	a5,-44(s0)
    ListElem *elem;
    list_for_each(path_items, elem) {
    80015a86:	fd843503          	ld	a0,-40(s0)
    80015a8a:	27d060ef          	jal	ra,8001c506 <list_elem_start_ascending>
    80015a8e:	fea43023          	sd	a0,-32(s0)
    80015a92:	a861                	j	80015b2a <minix3_get_inode_from_path+0xd4>
        char *name = (char *)list_elem_value(elem);
    80015a94:	fe043503          	ld	a0,-32(s0)
    80015a98:	2cf060ef          	jal	ra,8001c566 <list_elem_value>
    80015a9c:	87aa                	mv	a5,a0
    80015a9e:	fcf43423          	sd	a5,-56(s0)
        infof("Getting inode from relative path %s, num_items = %u\n", name, num_items);
    80015aa2:	fd442783          	lw	a5,-44(s0)
    80015aa6:	863e                	mv	a2,a5
    80015aa8:	fc843583          	ld	a1,-56(s0)
    80015aac:	0000c517          	auipc	a0,0xc
    80015ab0:	50c50513          	addi	a0,a0,1292 # 80021fb8 <pow10.0+0xd88>
    80015ab4:	055030ef          	jal	ra,80019308 <infof>
        if (strcmp(name, "/") == 0 || strcmp(name, "") == 0) {
    80015ab8:	0000c597          	auipc	a1,0xc
    80015abc:	4f858593          	addi	a1,a1,1272 # 80021fb0 <pow10.0+0xd80>
    80015ac0:	fc843503          	ld	a0,-56(s0)
    80015ac4:	4f7070ef          	jal	ra,8001d7ba <strcmp>
    80015ac8:	87aa                	mv	a5,a0
    80015aca:	cb99                	beqz	a5,80015ae0 <minix3_get_inode_from_path+0x8a>
    80015acc:	0000c597          	auipc	a1,0xc
    80015ad0:	52458593          	addi	a1,a1,1316 # 80021ff0 <pow10.0+0xdc0>
    80015ad4:	fc843503          	ld	a0,-56(s0)
    80015ad8:	4e3070ef          	jal	ra,8001d7ba <strcmp>
    80015adc:	87aa                	mv	a5,a0
    80015ade:	e781                	bnez	a5,80015ae6 <minix3_get_inode_from_path+0x90>
            return parent;
    80015ae0:	fec42783          	lw	a5,-20(s0)
    80015ae4:	a8a9                	j	80015b3e <minix3_get_inode_from_path+0xe8>
        }
        uint32_t child = minix3_find_dir_entry(parent, name);
    80015ae6:	fec42783          	lw	a5,-20(s0)
    80015aea:	fc843583          	ld	a1,-56(s0)
    80015aee:	853e                	mv	a0,a5
    80015af0:	5cd020ef          	jal	ra,800188bc <minix3_find_dir_entry>
    80015af4:	87aa                	mv	a5,a0
    80015af6:	fcf42223          	sw	a5,-60(s0)
        infof("Got child %u\n", child);
    80015afa:	fc442783          	lw	a5,-60(s0)
    80015afe:	85be                	mv	a1,a5
    80015b00:	0000c517          	auipc	a0,0xc
    80015b04:	4f850513          	addi	a0,a0,1272 # 80021ff8 <pow10.0+0xdc8>
    80015b08:	001030ef          	jal	ra,80019308 <infof>
        parent = child;
    80015b0c:	fc442783          	lw	a5,-60(s0)
    80015b10:	fef42623          	sw	a5,-20(s0)
        i++;
    80015b14:	fe842783          	lw	a5,-24(s0)
    80015b18:	2785                	addiw	a5,a5,1
    80015b1a:	fef42423          	sw	a5,-24(s0)
    list_for_each(path_items, elem) {
    80015b1e:	fe043503          	ld	a0,-32(s0)
    80015b22:	22d060ef          	jal	ra,8001c54e <list_elem_prev>
    80015b26:	fea43023          	sd	a0,-32(s0)
    80015b2a:	fe043583          	ld	a1,-32(s0)
    80015b2e:	fd843503          	ld	a0,-40(s0)
    80015b32:	147060ef          	jal	ra,8001c478 <list_elem_valid>
    80015b36:	87aa                	mv	a5,a0
    80015b38:	ffb1                	bnez	a5,80015a94 <minix3_get_inode_from_path+0x3e>
    }

    return parent;
    80015b3a:	fec42783          	lw	a5,-20(s0)
}
    80015b3e:	853e                	mv	a0,a5
    80015b40:	60a6                	ld	ra,72(sp)
    80015b42:	6406                	ld	s0,64(sp)
    80015b44:	6161                	addi	sp,sp,80
    80015b46:	8082                	ret

0000000080015b48 <minix3_get_min_inode>:


uint32_t minix3_get_min_inode() {
    80015b48:	1141                	addi	sp,sp,-16
    80015b4a:	e422                	sd	s0,8(sp)
    80015b4c:	0800                	addi	s0,sp,16
    return 1;
    80015b4e:	4785                	li	a5,1
}
    80015b50:	853e                	mv	a0,a5
    80015b52:	6422                	ld	s0,8(sp)
    80015b54:	0141                	addi	sp,sp,16
    80015b56:	8082                	ret

0000000080015b58 <minix3_get_max_inode>:

uint32_t minix3_get_max_inode() {
    80015b58:	7139                	addi	sp,sp,-64
    80015b5a:	fc06                	sd	ra,56(sp)
    80015b5c:	f822                	sd	s0,48(sp)
    80015b5e:	f426                	sd	s1,40(sp)
    80015b60:	0080                	addi	s0,sp,64
    return minix3_get_block_size() * minix3_get_superblock().imap_blocks * 8;
    80015b62:	05d000ef          	jal	ra,800163be <minix3_get_block_size>
    80015b66:	87aa                	mv	a5,a0
    80015b68:	0007849b          	sext.w	s1,a5
    80015b6c:	fc040793          	addi	a5,s0,-64
    80015b70:	853e                	mv	a0,a5
    80015b72:	7ac000ef          	jal	ra,8001631e <minix3_get_superblock>
    80015b76:	fc645783          	lhu	a5,-58(s0)
    80015b7a:	2781                	sext.w	a5,a5
    80015b7c:	02f487bb          	mulw	a5,s1,a5
    80015b80:	2781                	sext.w	a5,a5
    80015b82:	0037979b          	slliw	a5,a5,0x3
    80015b86:	2781                	sext.w	a5,a5
    80015b88:	2781                	sext.w	a5,a5
}
    80015b8a:	853e                	mv	a0,a5
    80015b8c:	70e2                	ld	ra,56(sp)
    80015b8e:	7442                	ld	s0,48(sp)
    80015b90:	74a2                	ld	s1,40(sp)
    80015b92:	6121                	addi	sp,sp,64
    80015b94:	8082                	ret

0000000080015b96 <minix3_get_inode_byte_offset>:

uintptr_t minix3_get_inode_byte_offset(SuperBlock sb, uint32_t inode) {
    80015b96:	7179                	addi	sp,sp,-48
    80015b98:	f406                	sd	ra,40(sp)
    80015b9a:	f022                	sd	s0,32(sp)
    80015b9c:	ec26                	sd	s1,24(sp)
    80015b9e:	1800                	addi	s0,sp,48
    80015ba0:	80aa                	mv	ra,a0
    80015ba2:	87ae                	mv	a5,a1
    80015ba4:	fcf42e23          	sw	a5,-36(s0)
    if (inode == INVALID_INODE) {
    80015ba8:	fdc42783          	lw	a5,-36(s0)
    80015bac:	2781                	sext.w	a5,a5
    80015bae:	ef81                	bnez	a5,80015bc6 <minix3_get_inode_byte_offset+0x30>
        fatalf("Invalid inode %u\n", inode);
    80015bb0:	fdc42783          	lw	a5,-36(s0)
    80015bb4:	85be                	mv	a1,a5
    80015bb6:	0000c517          	auipc	a0,0xc
    80015bba:	45250513          	addi	a0,a0,1106 # 80022008 <pow10.0+0xdd8>
    80015bbe:	7a0030ef          	jal	ra,8001935e <fatalf>
        return 0;
    80015bc2:	4781                	li	a5,0
    80015bc4:	a82d                	j	80015bfe <minix3_get_inode_byte_offset+0x68>
    }
    return (FS_IMAP_IDX + sb.imap_blocks + sb.zmap_blocks) * minix3_get_block_size() + (inode - 1) * sizeof(Inode);
    80015bc6:	0060d783          	lhu	a5,6(ra)
    80015bca:	2781                	sext.w	a5,a5
    80015bcc:	2789                	addiw	a5,a5,2
    80015bce:	0007871b          	sext.w	a4,a5
    80015bd2:	0080d783          	lhu	a5,8(ra)
    80015bd6:	2781                	sext.w	a5,a5
    80015bd8:	9fb9                	addw	a5,a5,a4
    80015bda:	0007849b          	sext.w	s1,a5
    80015bde:	7e0000ef          	jal	ra,800163be <minix3_get_block_size>
    80015be2:	87aa                	mv	a5,a0
    80015be4:	2781                	sext.w	a5,a5
    80015be6:	02f487bb          	mulw	a5,s1,a5
    80015bea:	2781                	sext.w	a5,a5
    80015bec:	873e                	mv	a4,a5
    80015bee:	fdc42783          	lw	a5,-36(s0)
    80015bf2:	37fd                	addiw	a5,a5,-1
    80015bf4:	2781                	sext.w	a5,a5
    80015bf6:	1782                	slli	a5,a5,0x20
    80015bf8:	9381                	srli	a5,a5,0x20
    80015bfa:	079a                	slli	a5,a5,0x6
    80015bfc:	97ba                	add	a5,a5,a4
}
    80015bfe:	853e                	mv	a0,a5
    80015c00:	70a2                	ld	ra,40(sp)
    80015c02:	7402                	ld	s0,32(sp)
    80015c04:	64e2                	ld	s1,24(sp)
    80015c06:	6145                	addi	sp,sp,48
    80015c08:	8082                	ret

0000000080015c0a <minix3_superblock_init>:
// uintptr_t minix3_get_inode_bitmap_byte_offset(SuperBlock sb, uint32_t inode) {
//     return FS_IMAP_IDX * minix3_get_block_size() + inode / 8;
// }


void minix3_superblock_init(void) {
    80015c0a:	7159                	addi	sp,sp,-112
    80015c0c:	f486                	sd	ra,104(sp)
    80015c0e:	f0a2                	sd	s0,96(sp)
    80015c10:	1880                	addi	s0,sp,112
    // uint64_t sector_size = block_device_get_sector_size();
    // Initialize the superblock
    // uint64_t num_sectors = block_device_get_sector_count();
    uint64_t device_bytes = block_device_get_bytes();
    80015c12:	617050ef          	jal	ra,8001ba28 <block_device_get_bytes>
    80015c16:	fea43423          	sd	a0,-24(s0)
    uint64_t bytes_per_block = 1024;
    80015c1a:	40000793          	li	a5,1024
    80015c1e:	fef43023          	sd	a5,-32(s0)
    uint64_t num_blocks = device_bytes / bytes_per_block / 2;
    80015c22:	fe843703          	ld	a4,-24(s0)
    80015c26:	fe043783          	ld	a5,-32(s0)
    80015c2a:	02f757b3          	divu	a5,a4,a5
    80015c2e:	8385                	srli	a5,a5,0x1
    80015c30:	fcf43c23          	sd	a5,-40(s0)
    SuperBlock superblock;
    superblock.magic = 0x4d5a;
    80015c34:	6795                	lui	a5,0x5
    80015c36:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    80015c3a:	fcf41823          	sh	a5,-48(s0)
    superblock.log_zone_size = 0;
    80015c3e:	fc041223          	sh	zero,-60(s0)
    superblock.max_size = num_blocks * bytes_per_block;
    80015c42:	fd843783          	ld	a5,-40(s0)
    80015c46:	0007871b          	sext.w	a4,a5
    80015c4a:	fe043783          	ld	a5,-32(s0)
    80015c4e:	2781                	sext.w	a5,a5
    80015c50:	02f707bb          	mulw	a5,a4,a5
    80015c54:	2781                	sext.w	a5,a5
    80015c56:	fcf42423          	sw	a5,-56(s0)
    superblock.num_zones = num_blocks;
    80015c5a:	fd843783          	ld	a5,-40(s0)
    80015c5e:	2781                	sext.w	a5,a5
    80015c60:	fcf42623          	sw	a5,-52(s0)
    superblock.block_size = bytes_per_block;
    80015c64:	fe043783          	ld	a5,-32(s0)
    80015c68:	17c2                	slli	a5,a5,0x30
    80015c6a:	93c1                	srli	a5,a5,0x30
    80015c6c:	fcf41a23          	sh	a5,-44(s0)
    superblock.disk_version = 0;
    80015c70:	fc040b23          	sb	zero,-42(s0)
    superblock.num_inodes = num_blocks / 8;
    80015c74:	fd843783          	ld	a5,-40(s0)
    80015c78:	838d                	srli	a5,a5,0x3
    80015c7a:	2781                	sext.w	a5,a5
    80015c7c:	faf42c23          	sw	a5,-72(s0)
    superblock.imap_blocks = superblock.num_inodes / (bytes_per_block * 8);
    80015c80:	fb842783          	lw	a5,-72(s0)
    80015c84:	02079713          	slli	a4,a5,0x20
    80015c88:	9301                	srli	a4,a4,0x20
    80015c8a:	fe043783          	ld	a5,-32(s0)
    80015c8e:	078e                	slli	a5,a5,0x3
    80015c90:	02f757b3          	divu	a5,a4,a5
    80015c94:	17c2                	slli	a5,a5,0x30
    80015c96:	93c1                	srli	a5,a5,0x30
    80015c98:	faf41f23          	sh	a5,-66(s0)
    superblock.zmap_blocks = superblock.num_zones / (bytes_per_block * 8);
    80015c9c:	fcc42783          	lw	a5,-52(s0)
    80015ca0:	02079713          	slli	a4,a5,0x20
    80015ca4:	9301                	srli	a4,a4,0x20
    80015ca6:	fe043783          	ld	a5,-32(s0)
    80015caa:	078e                	slli	a5,a5,0x3
    80015cac:	02f757b3          	divu	a5,a4,a5
    80015cb0:	17c2                	slli	a5,a5,0x30
    80015cb2:	93c1                	srli	a5,a5,0x30
    80015cb4:	fcf41023          	sh	a5,-64(s0)
    superblock.first_data_zone = 0;
    80015cb8:	fc041123          	sh	zero,-62(s0)
    minix3_put_superblock(superblock);
    80015cbc:	fb843603          	ld	a2,-72(s0)
    80015cc0:	fc043683          	ld	a3,-64(s0)
    80015cc4:	fc843703          	ld	a4,-56(s0)
    80015cc8:	fd043783          	ld	a5,-48(s0)
    80015ccc:	f8c43823          	sd	a2,-112(s0)
    80015cd0:	f8d43c23          	sd	a3,-104(s0)
    80015cd4:	fae43023          	sd	a4,-96(s0)
    80015cd8:	faf43423          	sd	a5,-88(s0)
    80015cdc:	f9040793          	addi	a5,s0,-112
    80015ce0:	853e                	mv	a0,a5
    80015ce2:	6ba000ef          	jal	ra,8001639c <minix3_put_superblock>
}
    80015ce6:	0001                	nop
    80015ce8:	70a6                	ld	ra,104(sp)
    80015cea:	7406                	ld	s0,96(sp)
    80015cec:	6165                	addi	sp,sp,112
    80015cee:	8082                	ret

0000000080015cf0 <minix3_has_zone>:

bool minix3_has_zone(uint32_t zone) {
    80015cf0:	1101                	addi	sp,sp,-32
    80015cf2:	ec22                	sd	s0,24(sp)
    80015cf4:	1000                	addi	s0,sp,32
    80015cf6:	87aa                	mv	a5,a0
    80015cf8:	fef42623          	sw	a5,-20(s0)
    return inode_bitmap[zone / 8] & (1 << zone % 8);
    80015cfc:	0000a797          	auipc	a5,0xa
    80015d00:	3e478793          	addi	a5,a5,996 # 800200e0 <inode_bitmap>
    80015d04:	6398                	ld	a4,0(a5)
    80015d06:	fec42783          	lw	a5,-20(s0)
    80015d0a:	0037d79b          	srliw	a5,a5,0x3
    80015d0e:	2781                	sext.w	a5,a5
    80015d10:	1782                	slli	a5,a5,0x20
    80015d12:	9381                	srli	a5,a5,0x20
    80015d14:	97ba                	add	a5,a5,a4
    80015d16:	0007c783          	lbu	a5,0(a5)
    80015d1a:	0007871b          	sext.w	a4,a5
    80015d1e:	fec42783          	lw	a5,-20(s0)
    80015d22:	8b9d                	andi	a5,a5,7
    80015d24:	2781                	sext.w	a5,a5
    80015d26:	4685                	li	a3,1
    80015d28:	00f697bb          	sllw	a5,a3,a5
    80015d2c:	2781                	sext.w	a5,a5
    80015d2e:	8ff9                	and	a5,a5,a4
    80015d30:	2781                	sext.w	a5,a5
    80015d32:	00f037b3          	snez	a5,a5
    80015d36:	0ff7f793          	andi	a5,a5,255
}
    80015d3a:	853e                	mv	a0,a5
    80015d3c:	6462                	ld	s0,24(sp)
    80015d3e:	6105                	addi	sp,sp,32
    80015d40:	8082                	ret

0000000080015d42 <minix3_take_zone>:

bool minix3_take_zone(uint32_t zone) {
    80015d42:	1101                	addi	sp,sp,-32
    80015d44:	ec22                	sd	s0,24(sp)
    80015d46:	1000                	addi	s0,sp,32
    80015d48:	87aa                	mv	a5,a0
    80015d4a:	fef42623          	sw	a5,-20(s0)
    return inode_bitmap[zone / 8] |= (1 << zone % 8);
    80015d4e:	0000a797          	auipc	a5,0xa
    80015d52:	39278793          	addi	a5,a5,914 # 800200e0 <inode_bitmap>
    80015d56:	6398                	ld	a4,0(a5)
    80015d58:	fec42783          	lw	a5,-20(s0)
    80015d5c:	0037d79b          	srliw	a5,a5,0x3
    80015d60:	0007861b          	sext.w	a2,a5
    80015d64:	02061793          	slli	a5,a2,0x20
    80015d68:	9381                	srli	a5,a5,0x20
    80015d6a:	97ba                	add	a5,a5,a4
    80015d6c:	0007c783          	lbu	a5,0(a5)
    80015d70:	0187971b          	slliw	a4,a5,0x18
    80015d74:	4187571b          	sraiw	a4,a4,0x18
    80015d78:	fec42783          	lw	a5,-20(s0)
    80015d7c:	8b9d                	andi	a5,a5,7
    80015d7e:	2781                	sext.w	a5,a5
    80015d80:	4685                	li	a3,1
    80015d82:	00f697bb          	sllw	a5,a3,a5
    80015d86:	2781                	sext.w	a5,a5
    80015d88:	0187979b          	slliw	a5,a5,0x18
    80015d8c:	4187d79b          	sraiw	a5,a5,0x18
    80015d90:	8fd9                	or	a5,a5,a4
    80015d92:	0187969b          	slliw	a3,a5,0x18
    80015d96:	4186d69b          	sraiw	a3,a3,0x18
    80015d9a:	0000a797          	auipc	a5,0xa
    80015d9e:	34678793          	addi	a5,a5,838 # 800200e0 <inode_bitmap>
    80015da2:	6398                	ld	a4,0(a5)
    80015da4:	02061793          	slli	a5,a2,0x20
    80015da8:	9381                	srli	a5,a5,0x20
    80015daa:	97ba                	add	a5,a5,a4
    80015dac:	0ff6f713          	andi	a4,a3,255
    80015db0:	00e78023          	sb	a4,0(a5)
    80015db4:	0007c783          	lbu	a5,0(a5)
    80015db8:	2781                	sext.w	a5,a5
    80015dba:	00f037b3          	snez	a5,a5
    80015dbe:	0ff7f793          	andi	a5,a5,255
}
    80015dc2:	853e                	mv	a0,a5
    80015dc4:	6462                	ld	s0,24(sp)
    80015dc6:	6105                	addi	sp,sp,32
    80015dc8:	8082                	ret

0000000080015dca <minix3_get_next_free_zone>:

uint32_t minix3_get_next_free_zone() {
    80015dca:	7179                	addi	sp,sp,-48
    80015dcc:	f406                	sd	ra,40(sp)
    80015dce:	f022                	sd	s0,32(sp)
    80015dd0:	1800                	addi	s0,sp,48
    size_t zone_bitmap_size = minix3_get_zone_size();
    80015dd2:	61c000ef          	jal	ra,800163ee <minix3_get_zone_size>
    80015dd6:	87aa                	mv	a5,a0
    80015dd8:	fef43023          	sd	a5,-32(s0)
    for (int i = 0; i < zone_bitmap_size; i++) {
    80015ddc:	fe042623          	sw	zero,-20(s0)
    80015de0:	a8ad                	j	80015e5a <minix3_get_next_free_zone+0x90>
        if (zone_bitmap[i] != 0xFF) {
    80015de2:	0000a797          	auipc	a5,0xa
    80015de6:	30678793          	addi	a5,a5,774 # 800200e8 <zone_bitmap>
    80015dea:	6398                	ld	a4,0(a5)
    80015dec:	fec42783          	lw	a5,-20(s0)
    80015df0:	97ba                	add	a5,a5,a4
    80015df2:	0007c783          	lbu	a5,0(a5)
    80015df6:	873e                	mv	a4,a5
    80015df8:	0ff00793          	li	a5,255
    80015dfc:	04f70a63          	beq	a4,a5,80015e50 <minix3_get_next_free_zone+0x86>
            for (int j = 0; j < 8; j++) {
    80015e00:	fe042423          	sw	zero,-24(s0)
    80015e04:	a83d                	j	80015e42 <minix3_get_next_free_zone+0x78>
                uint32_t zone = 8 * i + j;
    80015e06:	fec42783          	lw	a5,-20(s0)
    80015e0a:	0037979b          	slliw	a5,a5,0x3
    80015e0e:	2781                	sext.w	a5,a5
    80015e10:	fe842703          	lw	a4,-24(s0)
    80015e14:	9fb9                	addw	a5,a5,a4
    80015e16:	2781                	sext.w	a5,a5
    80015e18:	fcf42e23          	sw	a5,-36(s0)
                if (!minix3_has_zone(zone))
    80015e1c:	fdc42783          	lw	a5,-36(s0)
    80015e20:	853e                	mv	a0,a5
    80015e22:	ecfff0ef          	jal	ra,80015cf0 <minix3_has_zone>
    80015e26:	87aa                	mv	a5,a0
    80015e28:	0017c793          	xori	a5,a5,1
    80015e2c:	0ff7f793          	andi	a5,a5,255
    80015e30:	c781                	beqz	a5,80015e38 <minix3_get_next_free_zone+0x6e>
                    return zone;
    80015e32:	fdc42783          	lw	a5,-36(s0)
    80015e36:	a83d                	j	80015e74 <minix3_get_next_free_zone+0xaa>
            for (int j = 0; j < 8; j++) {
    80015e38:	fe842783          	lw	a5,-24(s0)
    80015e3c:	2785                	addiw	a5,a5,1
    80015e3e:	fef42423          	sw	a5,-24(s0)
    80015e42:	fe842783          	lw	a5,-24(s0)
    80015e46:	0007871b          	sext.w	a4,a5
    80015e4a:	479d                	li	a5,7
    80015e4c:	fae7dde3          	bge	a5,a4,80015e06 <minix3_get_next_free_zone+0x3c>
    for (int i = 0; i < zone_bitmap_size; i++) {
    80015e50:	fec42783          	lw	a5,-20(s0)
    80015e54:	2785                	addiw	a5,a5,1
    80015e56:	fef42623          	sw	a5,-20(s0)
    80015e5a:	fec42783          	lw	a5,-20(s0)
    80015e5e:	fe043703          	ld	a4,-32(s0)
    80015e62:	f8e7e0e3          	bltu	a5,a4,80015de2 <minix3_get_next_free_zone+0x18>
            }
        }
    }
    warnf("minix3_get_next_free_zone: Couldn't find free zone\n");
    80015e66:	0000c517          	auipc	a0,0xc
    80015e6a:	1ba50513          	addi	a0,a0,442 # 80022020 <pow10.0+0xdf0>
    80015e6e:	3ec030ef          	jal	ra,8001925a <warnf>
    return 0;
    80015e72:	4781                	li	a5,0
}
    80015e74:	853e                	mv	a0,a5
    80015e76:	70a2                	ld	ra,40(sp)
    80015e78:	7402                	ld	s0,32(sp)
    80015e7a:	6145                	addi	sp,sp,48
    80015e7c:	8082                	ret

0000000080015e7e <minix3_get_zone>:

void minix3_get_zone(uint32_t zone, uint8_t *data) {
    80015e7e:	7139                	addi	sp,sp,-64
    80015e80:	fc06                	sd	ra,56(sp)
    80015e82:	f822                	sd	s0,48(sp)
    80015e84:	0080                	addi	s0,sp,64
    80015e86:	87aa                	mv	a5,a0
    80015e88:	fcb43023          	sd	a1,-64(s0)
    80015e8c:	fcf42623          	sw	a5,-52(s0)
    SuperBlock sb = minix3_get_superblock();
    80015e90:	fd040793          	addi	a5,s0,-48
    80015e94:	853e                	mv	a0,a5
    80015e96:	488000ef          	jal	ra,8001631e <minix3_get_superblock>
    if (zone > sb.num_zones + sb.first_data_zone) {
    80015e9a:	fe442703          	lw	a4,-28(s0)
    80015e9e:	fda45783          	lhu	a5,-38(s0)
    80015ea2:	2781                	sext.w	a5,a5
    80015ea4:	9fb9                	addw	a5,a5,a4
    80015ea6:	0007871b          	sext.w	a4,a5
    80015eaa:	fcc42783          	lw	a5,-52(s0)
    80015eae:	2781                	sext.w	a5,a5
    80015eb0:	00f77f63          	bgeu	a4,a5,80015ece <minix3_get_zone+0x50>
        fatalf("Zone %u (%x) is out of bounds\n", zone, zone);
    80015eb4:	fcc42703          	lw	a4,-52(s0)
    80015eb8:	fcc42783          	lw	a5,-52(s0)
    80015ebc:	863a                	mv	a2,a4
    80015ebe:	85be                	mv	a1,a5
    80015ec0:	0000c517          	auipc	a0,0xc
    80015ec4:	19850513          	addi	a0,a0,408 # 80022058 <pow10.0+0xe28>
    80015ec8:	496030ef          	jal	ra,8001935e <fatalf>
        return;
    80015ecc:	a0a9                	j	80015f16 <minix3_get_zone+0x98>
    }

    if (zone < sb.first_data_zone) {
    80015ece:	fda45783          	lhu	a5,-38(s0)
    80015ed2:	0007871b          	sext.w	a4,a5
    80015ed6:	fcc42783          	lw	a5,-52(s0)
    80015eda:	2781                	sext.w	a5,a5
    80015edc:	02e7f663          	bgeu	a5,a4,80015f08 <minix3_get_zone+0x8a>
        fatalf("Zone %u (%x) is before the first data zone %u (%x)\n", zone, zone, sb.first_data_zone, sb.first_data_zone);
    80015ee0:	fda45783          	lhu	a5,-38(s0)
    80015ee4:	0007869b          	sext.w	a3,a5
    80015ee8:	fda45783          	lhu	a5,-38(s0)
    80015eec:	0007871b          	sext.w	a4,a5
    80015ef0:	fcc42603          	lw	a2,-52(s0)
    80015ef4:	fcc42783          	lw	a5,-52(s0)
    80015ef8:	85be                	mv	a1,a5
    80015efa:	0000c517          	auipc	a0,0xc
    80015efe:	17e50513          	addi	a0,a0,382 # 80022078 <pow10.0+0xe48>
    80015f02:	45c030ef          	jal	ra,8001935e <fatalf>
        return;
    80015f06:	a801                	j	80015f16 <minix3_get_zone+0x98>
    }
    
    // minix3_get_block(minix3_get_superblock().first_data_zone + zone, data);
    minix3_get_block(zone, data);
    80015f08:	fcc42783          	lw	a5,-52(s0)
    80015f0c:	fc043583          	ld	a1,-64(s0)
    80015f10:	853e                	mv	a0,a5
    80015f12:	728000ef          	jal	ra,8001663a <minix3_get_block>
}
    80015f16:	70e2                	ld	ra,56(sp)
    80015f18:	7442                	ld	s0,48(sp)
    80015f1a:	6121                	addi	sp,sp,64
    80015f1c:	8082                	ret

0000000080015f1e <minix3_put_zone>:
void minix3_put_zone(uint32_t zone, uint8_t *data) {
    80015f1e:	7139                	addi	sp,sp,-64
    80015f20:	fc06                	sd	ra,56(sp)
    80015f22:	f822                	sd	s0,48(sp)
    80015f24:	0080                	addi	s0,sp,64
    80015f26:	87aa                	mv	a5,a0
    80015f28:	fcb43023          	sd	a1,-64(s0)
    80015f2c:	fcf42623          	sw	a5,-52(s0)
    SuperBlock sb = minix3_get_superblock();
    80015f30:	fd040793          	addi	a5,s0,-48
    80015f34:	853e                	mv	a0,a5
    80015f36:	3e8000ef          	jal	ra,8001631e <minix3_get_superblock>
    if (zone > sb.num_zones + sb.first_data_zone) {
    80015f3a:	fe442703          	lw	a4,-28(s0)
    80015f3e:	fda45783          	lhu	a5,-38(s0)
    80015f42:	2781                	sext.w	a5,a5
    80015f44:	9fb9                	addw	a5,a5,a4
    80015f46:	0007871b          	sext.w	a4,a5
    80015f4a:	fcc42783          	lw	a5,-52(s0)
    80015f4e:	2781                	sext.w	a5,a5
    80015f50:	00f77f63          	bgeu	a4,a5,80015f6e <minix3_put_zone+0x50>
        fatalf("Zone %u (%x) is out of bounds\n", zone, zone);
    80015f54:	fcc42703          	lw	a4,-52(s0)
    80015f58:	fcc42783          	lw	a5,-52(s0)
    80015f5c:	863a                	mv	a2,a4
    80015f5e:	85be                	mv	a1,a5
    80015f60:	0000c517          	auipc	a0,0xc
    80015f64:	0f850513          	addi	a0,a0,248 # 80022058 <pow10.0+0xe28>
    80015f68:	3f6030ef          	jal	ra,8001935e <fatalf>
        return;
    80015f6c:	a0a9                	j	80015fb6 <minix3_put_zone+0x98>
    }

    if (zone < sb.first_data_zone) {
    80015f6e:	fda45783          	lhu	a5,-38(s0)
    80015f72:	0007871b          	sext.w	a4,a5
    80015f76:	fcc42783          	lw	a5,-52(s0)
    80015f7a:	2781                	sext.w	a5,a5
    80015f7c:	02e7f663          	bgeu	a5,a4,80015fa8 <minix3_put_zone+0x8a>
        fatalf("Zone %u (%x) is before the first data zone %u (%x)\n", zone, zone, sb.first_data_zone, sb.first_data_zone);
    80015f80:	fda45783          	lhu	a5,-38(s0)
    80015f84:	0007869b          	sext.w	a3,a5
    80015f88:	fda45783          	lhu	a5,-38(s0)
    80015f8c:	0007871b          	sext.w	a4,a5
    80015f90:	fcc42603          	lw	a2,-52(s0)
    80015f94:	fcc42783          	lw	a5,-52(s0)
    80015f98:	85be                	mv	a1,a5
    80015f9a:	0000c517          	auipc	a0,0xc
    80015f9e:	0de50513          	addi	a0,a0,222 # 80022078 <pow10.0+0xe48>
    80015fa2:	3bc030ef          	jal	ra,8001935e <fatalf>
        return;
    80015fa6:	a801                	j	80015fb6 <minix3_put_zone+0x98>
    }

    minix3_put_block(zone, data);
    80015fa8:	fcc42783          	lw	a5,-52(s0)
    80015fac:	fc043583          	ld	a1,-64(s0)
    80015fb0:	853e                	mv	a0,a5
    80015fb2:	6b4000ef          	jal	ra,80016666 <minix3_put_block>
}
    80015fb6:	70e2                	ld	ra,56(sp)
    80015fb8:	7442                	ld	s0,48(sp)
    80015fba:	6121                	addi	sp,sp,64
    80015fbc:	8082                	ret

0000000080015fbe <minix3_get_file_size>:

uint64_t minix3_get_file_size(uint32_t inode) {
    80015fbe:	711d                	addi	sp,sp,-96
    80015fc0:	ec86                	sd	ra,88(sp)
    80015fc2:	e8a2                	sd	s0,80(sp)
    80015fc4:	1080                	addi	s0,sp,96
    80015fc6:	87aa                	mv	a5,a0
    80015fc8:	faf42623          	sw	a5,-84(s0)
    Inode inode_data = minix3_get_inode(inode);
    80015fcc:	fb040793          	addi	a5,s0,-80
    80015fd0:	fac42703          	lw	a4,-84(s0)
    80015fd4:	85ba                	mv	a1,a4
    80015fd6:	853e                	mv	a0,a5
    80015fd8:	053000ef          	jal	ra,8001682a <minix3_get_inode>
    if (S_ISREG(inode_data.mode)) {
    80015fdc:	fb045783          	lhu	a5,-80(s0)
    80015fe0:	0007871b          	sext.w	a4,a5
    80015fe4:	67bd                	lui	a5,0xf
    80015fe6:	8ff9                	and	a5,a5,a4
    80015fe8:	2781                	sext.w	a5,a5
    80015fea:	873e                	mv	a4,a5
    80015fec:	67a1                	lui	a5,0x8
    80015fee:	00f71763          	bne	a4,a5,80015ffc <minix3_get_file_size+0x3e>
        return inode_data.size;
    80015ff2:	fb842783          	lw	a5,-72(s0)
    80015ff6:	1782                	slli	a5,a5,0x20
    80015ff8:	9381                	srli	a5,a5,0x20
    80015ffa:	a80d                	j	8001602c <minix3_get_file_size+0x6e>
    } else if (S_ISDIR(inode_data.mode)) {
    80015ffc:	fb045783          	lhu	a5,-80(s0)
    80016000:	0007871b          	sext.w	a4,a5
    80016004:	67bd                	lui	a5,0xf
    80016006:	8ff9                	and	a5,a5,a4
    80016008:	2781                	sext.w	a5,a5
    8001600a:	873e                	mv	a4,a5
    8001600c:	6791                	lui	a5,0x4
    8001600e:	00f71463          	bne	a4,a5,80016016 <minix3_get_file_size+0x58>
        return 0;
    80016012:	4781                	li	a5,0
    80016014:	a821                	j	8001602c <minix3_get_file_size+0x6e>
    } else {
        fatalf("Unknown inode type %x\n", inode_data.mode);
    80016016:	fb045783          	lhu	a5,-80(s0)
    8001601a:	2781                	sext.w	a5,a5
    8001601c:	85be                	mv	a1,a5
    8001601e:	0000c517          	auipc	a0,0xc
    80016022:	09250513          	addi	a0,a0,146 # 800220b0 <pow10.0+0xe80>
    80016026:	338030ef          	jal	ra,8001935e <fatalf>
        return 0;
    8001602a:	4781                	li	a5,0
    }
}
    8001602c:	853e                	mv	a0,a5
    8001602e:	60e6                	ld	ra,88(sp)
    80016030:	6446                	ld	s0,80(sp)
    80016032:	6125                	addi	sp,sp,96
    80016034:	8082                	ret

0000000080016036 <debug_inode>:

void debug_inode(uint32_t i) {
    80016036:	7159                	addi	sp,sp,-112
    80016038:	f486                	sd	ra,104(sp)
    8001603a:	f0a2                	sd	s0,96(sp)
    8001603c:	1880                	addi	s0,sp,112
    8001603e:	87aa                	mv	a5,a0
    80016040:	f8f42e23          	sw	a5,-100(s0)
    Inode inode = minix3_get_inode(i);
    80016044:	fa840793          	addi	a5,s0,-88
    80016048:	f9c42703          	lw	a4,-100(s0)
    8001604c:	85ba                	mv	a1,a4
    8001604e:	853e                	mv	a0,a5
    80016050:	7da000ef          	jal	ra,8001682a <minix3_get_inode>
    debugf("   size: %d\n", inode.size);
    debugf("   atime: %d\n", inode.atime);
    debugf("   mtime: %d\n", inode.mtime);
    debugf("   ctime: %d\n", inode.ctime);
    debugf("   zones[]:\n");
    for (uint8_t j=0; j<10; j++) {
    80016054:	fe0407a3          	sb	zero,-17(s0)
    80016058:	a031                	j	80016064 <debug_inode+0x2e>
    8001605a:	fef44783          	lbu	a5,-17(s0)
    8001605e:	2785                	addiw	a5,a5,1
    80016060:	fef407a3          	sb	a5,-17(s0)
    80016064:	fef44783          	lbu	a5,-17(s0)
    80016068:	0ff7f713          	andi	a4,a5,255
    8001606c:	47a5                	li	a5,9
    8001606e:	fee7f6e3          	bgeu	a5,a4,8001605a <debug_inode+0x24>
        debugf("   zones[%d] = %x (*1024 = %x)\n", j, inode.zones[j], inode.zones[j] * 1024);
    }
}
    80016072:	0001                	nop
    80016074:	0001                	nop
    80016076:	70a6                	ld	ra,104(sp)
    80016078:	7406                	ld	s0,96(sp)
    8001607a:	6165                	addi	sp,sp,112
    8001607c:	8082                	ret

000000008001607e <callback>:
    uint32_t file_count;
    uint32_t dir_count;
} CallbackData;

// A callback function for counting up the files and printing them out
void callback(uint32_t inode, const char *path, char *name, void *data, uint32_t depth) {
    8001607e:	7139                	addi	sp,sp,-64
    80016080:	fc06                	sd	ra,56(sp)
    80016082:	f822                	sd	s0,48(sp)
    80016084:	0080                	addi	s0,sp,64
    80016086:	87aa                	mv	a5,a0
    80016088:	fcb43823          	sd	a1,-48(s0)
    8001608c:	fcc43423          	sd	a2,-56(s0)
    80016090:	fcd43023          	sd	a3,-64(s0)
    80016094:	fcf42e23          	sw	a5,-36(s0)
    80016098:	87ba                	mv	a5,a4
    8001609a:	fcf42c23          	sw	a5,-40(s0)
    CallbackData *cb_data = (CallbackData *)data;
    8001609e:	fc043783          	ld	a5,-64(s0)
    800160a2:	fef43023          	sd	a5,-32(s0)

    for (uint32_t i=0; i<depth; i++) {
    800160a6:	fe042623          	sw	zero,-20(s0)
    800160aa:	a821                	j	800160c2 <callback+0x44>
        infof("   ");
    800160ac:	0000c517          	auipc	a0,0xc
    800160b0:	01c50513          	addi	a0,a0,28 # 800220c8 <pow10.0+0xe98>
    800160b4:	254030ef          	jal	ra,80019308 <infof>
    for (uint32_t i=0; i<depth; i++) {
    800160b8:	fec42783          	lw	a5,-20(s0)
    800160bc:	2785                	addiw	a5,a5,1
    800160be:	fef42623          	sw	a5,-20(s0)
    800160c2:	fec42703          	lw	a4,-20(s0)
    800160c6:	fd842783          	lw	a5,-40(s0)
    800160ca:	2701                	sext.w	a4,a4
    800160cc:	2781                	sext.w	a5,a5
    800160ce:	fcf76fe3          	bltu	a4,a5,800160ac <callback+0x2e>
    }
    infof("%s", name);
    800160d2:	fc843583          	ld	a1,-56(s0)
    800160d6:	0000c517          	auipc	a0,0xc
    800160da:	ffa50513          	addi	a0,a0,-6 # 800220d0 <pow10.0+0xea0>
    800160de:	22a030ef          	jal	ra,80019308 <infof>
    // infof("name: %s", name);
    
    if (minix3_is_dir(inode)) {
    800160e2:	fdc42783          	lw	a5,-36(s0)
    800160e6:	853e                	mv	a0,a5
    800160e8:	1cb000ef          	jal	ra,80016ab2 <minix3_is_dir>
    800160ec:	87aa                	mv	a5,a0
    800160ee:	c38d                	beqz	a5,80016110 <callback+0x92>
        infof("/\n");
    800160f0:	0000c517          	auipc	a0,0xc
    800160f4:	fe850513          	addi	a0,a0,-24 # 800220d8 <pow10.0+0xea8>
    800160f8:	210030ef          	jal	ra,80019308 <infof>
        cb_data->dir_count++;
    800160fc:	fe043783          	ld	a5,-32(s0)
    80016100:	43dc                	lw	a5,4(a5)
    80016102:	2785                	addiw	a5,a5,1
    80016104:	0007871b          	sext.w	a4,a5
    80016108:	fe043783          	ld	a5,-32(s0)
    8001610c:	c3d8                	sw	a4,4(a5)

    // for (uint32_t i=0; i<depth; i++) {
    //     infof("   ");
    // }
    // infof("path: %s\n\n", path);
}
    8001610e:	a005                	j	8001612e <callback+0xb0>
        infof("\n");
    80016110:	0000c517          	auipc	a0,0xc
    80016114:	fd050513          	addi	a0,a0,-48 # 800220e0 <pow10.0+0xeb0>
    80016118:	1f0030ef          	jal	ra,80019308 <infof>
        cb_data->file_count++;
    8001611c:	fe043783          	ld	a5,-32(s0)
    80016120:	439c                	lw	a5,0(a5)
    80016122:	2785                	addiw	a5,a5,1
    80016124:	0007871b          	sext.w	a4,a5
    80016128:	fe043783          	ld	a5,-32(s0)
    8001612c:	c398                	sw	a4,0(a5)
}
    8001612e:	0001                	nop
    80016130:	70e2                	ld	ra,56(sp)
    80016132:	7442                	ld	s0,48(sp)
    80016134:	6121                	addi	sp,sp,64
    80016136:	8082                	ret

0000000080016138 <minix3_init>:

void minix3_init(void)
{
    80016138:	7119                	addi	sp,sp,-128
    8001613a:	fc86                	sd	ra,120(sp)
    8001613c:	f8a2                	sd	s0,112(sp)
    8001613e:	0100                	addi	s0,sp,128
    // Initialize the filesystem
    minix3_get_superblock();
    80016140:	f8040793          	addi	a5,s0,-128
    80016144:	853e                	mv	a0,a5
    80016146:	1d8000ef          	jal	ra,8001631e <minix3_get_superblock>
    debugf("   num_zones: 0x%x (%d)\n", sb.num_zones, sb.num_zones);
    debugf("   magic: 0x%x\n", sb.magic);
    debugf("   block_size: %d\n", sb.block_size);
    debugf("   disk_version: %d\n", sb.disk_version);

    if (sb.magic != MINIX3_MAGIC) {
    8001614a:	0000a797          	auipc	a5,0xa
    8001614e:	f6678793          	addi	a5,a5,-154 # 800200b0 <sb>
    80016152:	0187d783          	lhu	a5,24(a5)
    80016156:	0007871b          	sext.w	a4,a5
    8001615a:	6795                	lui	a5,0x5
    8001615c:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    80016160:	00f70a63          	beq	a4,a5,80016174 <minix3_init+0x3c>
        // We need to initialize the superblock
        warnf("Minix3 magic is not correct, initializing superblock ourselves...\n");
    80016164:	0000c517          	auipc	a0,0xc
    80016168:	f8450513          	addi	a0,a0,-124 # 800220e8 <pow10.0+0xeb8>
    8001616c:	0ee030ef          	jal	ra,8001925a <warnf>
        minix3_superblock_init();
    80016170:	a9bff0ef          	jal	ra,80015c0a <minix3_superblock_init>
    // }
    debugf("Max inode: %d\n", minix3_get_max_inode());
    // This does not work yet, broken

    // Copy the inode bitmap into memory
    inode_bitmap = (uint8_t *)kmalloc(minix3_get_inode_bitmap_size());
    80016174:	2be000ef          	jal	ra,80016432 <minix3_get_inode_bitmap_size>
    80016178:	87aa                	mv	a5,a0
    8001617a:	853e                	mv	a0,a5
    8001617c:	b1bfd0ef          	jal	ra,80013c96 <kmalloc>
    80016180:	872a                	mv	a4,a0
    80016182:	0000a797          	auipc	a5,0xa
    80016186:	f5e78793          	addi	a5,a5,-162 # 800200e0 <inode_bitmap>
    8001618a:	e398                	sd	a4,0(a5)
    minix3_get_inode_bitmap(inode_bitmap);
    8001618c:	0000a797          	auipc	a5,0xa
    80016190:	f5478793          	addi	a5,a5,-172 # 800200e0 <inode_bitmap>
    80016194:	639c                	ld	a5,0(a5)
    80016196:	853e                	mv	a0,a5
    80016198:	306000ef          	jal	ra,8001649e <minix3_get_inode_bitmap>
    // Copy the zone bitmap into memory
    zone_bitmap = (uint8_t*)kmalloc(minix3_get_zone_bitmap_size());
    8001619c:	2cc000ef          	jal	ra,80016468 <minix3_get_zone_bitmap_size>
    800161a0:	87aa                	mv	a5,a0
    800161a2:	853e                	mv	a0,a5
    800161a4:	af3fd0ef          	jal	ra,80013c96 <kmalloc>
    800161a8:	872a                	mv	a4,a0
    800161aa:	0000a797          	auipc	a5,0xa
    800161ae:	f3e78793          	addi	a5,a5,-194 # 800200e8 <zone_bitmap>
    800161b2:	e398                	sd	a4,0(a5)
    minix3_get_zone_bitmap(zone_bitmap);
    800161b4:	0000a797          	auipc	a5,0xa
    800161b8:	f3478793          	addi	a5,a5,-204 # 800200e8 <zone_bitmap>
    800161bc:	639c                	ld	a5,0(a5)
    800161be:	853e                	mv	a0,a5
    800161c0:	33e000ef          	jal	ra,800164fe <minix3_get_zone_bitmap>

        break;
    }
    */

    const char *path = "/home/cosc562";
    800161c4:	0000c797          	auipc	a5,0xc
    800161c8:	f6c78793          	addi	a5,a5,-148 # 80022130 <pow10.0+0xf00>
    800161cc:	fef43023          	sd	a5,-32(s0)

    CallbackData cb_data2 = {0};
    800161d0:	fa043823          	sd	zero,-80(s0)
    uint32_t inode = minix3_get_inode_from_path(path);
    800161d4:	fe043503          	ld	a0,-32(s0)
    800161d8:	87fff0ef          	jal	ra,80015a56 <minix3_get_inode_from_path>
    800161dc:	87aa                	mv	a5,a0
    800161de:	fcf42e23          	sw	a5,-36(s0)
    infof("%s has inode %u\n", path, inode);
    800161e2:	fdc42783          	lw	a5,-36(s0)
    800161e6:	863e                	mv	a2,a5
    800161e8:	fe043583          	ld	a1,-32(s0)
    800161ec:	0000c517          	auipc	a0,0xc
    800161f0:	f5450513          	addi	a0,a0,-172 # 80022140 <pow10.0+0xf10>
    800161f4:	114030ef          	jal	ra,80019308 <infof>
    minix3_traverse(inode, path, &cb_data2, 0, 10, callback);
    800161f8:	fb040613          	addi	a2,s0,-80
    800161fc:	fdc42503          	lw	a0,-36(s0)
    80016200:	00000797          	auipc	a5,0x0
    80016204:	e7e78793          	addi	a5,a5,-386 # 8001607e <callback>
    80016208:	4729                	li	a4,10
    8001620a:	4681                	li	a3,0
    8001620c:	fe043583          	ld	a1,-32(s0)
    80016210:	02b020ef          	jal	ra,80018a3a <minix3_traverse>

    infof("Found %u files and %u directories in %s\n", cb_data2.file_count, cb_data2.dir_count, path);
    80016214:	fb042783          	lw	a5,-80(s0)
    80016218:	fb442703          	lw	a4,-76(s0)
    8001621c:	fe043683          	ld	a3,-32(s0)
    80016220:	863a                	mv	a2,a4
    80016222:	85be                	mv	a1,a5
    80016224:	0000c517          	auipc	a0,0xc
    80016228:	f3450513          	addi	a0,a0,-204 # 80022158 <pow10.0+0xf28>
    8001622c:	0dc030ef          	jal	ra,80019308 <infof>

    minix3_map_files();
    80016230:	f9cff0ef          	jal	ra,800159cc <minix3_map_files>

    // Path of the book
    const char *book_path = "/home/cosc562/subdir1/subdir2/subdir3/subdir4/subdir5/book1.txt";
    80016234:	0000c797          	auipc	a5,0xc
    80016238:	f5478793          	addi	a5,a5,-172 # 80022188 <pow10.0+0xf58>
    8001623c:	fcf43823          	sd	a5,-48(s0)
    // Get the inode of the book
    uint32_t book_inode = minix3_path_to_inode(book_path);
    80016240:	fd043503          	ld	a0,-48(s0)
    80016244:	edcff0ef          	jal	ra,80015920 <minix3_path_to_inode>
    80016248:	87aa                	mv	a5,a0
    8001624a:	fcf42623          	sw	a5,-52(s0)
    // Get the size of the book
    uint64_t book_size = minix3_get_file_size(book_inode);
    8001624e:	fcc42783          	lw	a5,-52(s0)
    80016252:	853e                	mv	a0,a5
    80016254:	d6bff0ef          	jal	ra,80015fbe <minix3_get_file_size>
    80016258:	fca43023          	sd	a0,-64(s0)
    // Allocate a buffer for the book
    uint8_t *contents = kmalloc(book_size);
    8001625c:	fc043503          	ld	a0,-64(s0)
    80016260:	a37fd0ef          	jal	ra,80013c96 <kmalloc>
    80016264:	faa43c23          	sd	a0,-72(s0)
    // Read the book into the buffer
    minix3_read_file(book_inode, contents, book_size);
    80016268:	fc043783          	ld	a5,-64(s0)
    8001626c:	0007871b          	sext.w	a4,a5
    80016270:	fcc42783          	lw	a5,-52(s0)
    80016274:	863a                	mv	a2,a4
    80016276:	fb843583          	ld	a1,-72(s0)
    8001627a:	853e                	mv	a0,a5
    8001627c:	107000ef          	jal	ra,80016b82 <minix3_read_file>
    // Print the book
    for (uint64_t i=0; i<book_size; i++) {
    80016280:	fe043423          	sd	zero,-24(s0)
    80016284:	a02d                	j	800162ae <minix3_init+0x176>
        infof("%c", contents[i]);
    80016286:	fb843703          	ld	a4,-72(s0)
    8001628a:	fe843783          	ld	a5,-24(s0)
    8001628e:	97ba                	add	a5,a5,a4
    80016290:	0007c783          	lbu	a5,0(a5)
    80016294:	2781                	sext.w	a5,a5
    80016296:	85be                	mv	a1,a5
    80016298:	0000c517          	auipc	a0,0xc
    8001629c:	f3050513          	addi	a0,a0,-208 # 800221c8 <pow10.0+0xf98>
    800162a0:	068030ef          	jal	ra,80019308 <infof>
    for (uint64_t i=0; i<book_size; i++) {
    800162a4:	fe843783          	ld	a5,-24(s0)
    800162a8:	0785                	addi	a5,a5,1
    800162aa:	fef43423          	sd	a5,-24(s0)
    800162ae:	fe843703          	ld	a4,-24(s0)
    800162b2:	fc043783          	ld	a5,-64(s0)
    800162b6:	fcf768e3          	bltu	a4,a5,80016286 <minix3_init+0x14e>
    }
    infof("\n");
    800162ba:	0000c517          	auipc	a0,0xc
    800162be:	e2650513          	addi	a0,a0,-474 # 800220e0 <pow10.0+0xeb0>
    800162c2:	046030ef          	jal	ra,80019308 <infof>
    // Free the buffer
    kfree(contents);
    800162c6:	fb843503          	ld	a0,-72(s0)
    800162ca:	a15fd0ef          	jal	ra,80013cde <kfree>

    
    infof("Files:\n");
    800162ce:	0000c517          	auipc	a0,0xc
    800162d2:	f0250513          	addi	a0,a0,-254 # 800221d0 <pow10.0+0xfa0>
    800162d6:	032030ef          	jal	ra,80019308 <infof>
    CallbackData cb_data = {0};
    800162da:	fa043423          	sd	zero,-88(s0)
    minix3_traverse(1, "/", &cb_data, 0, 10, callback);
    800162de:	fa840613          	addi	a2,s0,-88
    800162e2:	00000797          	auipc	a5,0x0
    800162e6:	d9c78793          	addi	a5,a5,-612 # 8001607e <callback>
    800162ea:	4729                	li	a4,10
    800162ec:	4681                	li	a3,0
    800162ee:	0000c597          	auipc	a1,0xc
    800162f2:	cc258593          	addi	a1,a1,-830 # 80021fb0 <pow10.0+0xd80>
    800162f6:	4505                	li	a0,1
    800162f8:	742020ef          	jal	ra,80018a3a <minix3_traverse>
    infof("Found %u files and %u directories in /\n", cb_data.file_count, cb_data.dir_count);
    800162fc:	fa842783          	lw	a5,-88(s0)
    80016300:	fac42703          	lw	a4,-84(s0)
    80016304:	863a                	mv	a2,a4
    80016306:	85be                	mv	a1,a5
    80016308:	0000c517          	auipc	a0,0xc
    8001630c:	ed050513          	addi	a0,a0,-304 # 800221d8 <pow10.0+0xfa8>
    80016310:	7f9020ef          	jal	ra,80019308 <infof>
}
    80016314:	0001                	nop
    80016316:	70e6                	ld	ra,120(sp)
    80016318:	7446                	ld	s0,112(sp)
    8001631a:	6109                	addi	sp,sp,128
    8001631c:	8082                	ret

000000008001631e <minix3_get_superblock>:

SuperBlock minix3_get_superblock() {
    8001631e:	1101                	addi	sp,sp,-32
    80016320:	ec06                	sd	ra,24(sp)
    80016322:	e822                	sd	s0,16(sp)
    80016324:	1000                	addi	s0,sp,32
    80016326:	fea43423          	sd	a0,-24(s0)
    // Get the superblock
    // SuperBlock superblock;
    // Superblock begins at bytes 1024
    if (sb.magic != MINIX3_MAGIC) {
    8001632a:	0000a797          	auipc	a5,0xa
    8001632e:	d8678793          	addi	a5,a5,-634 # 800200b0 <sb>
    80016332:	0187d783          	lhu	a5,24(a5)
    80016336:	0007871b          	sext.w	a4,a5
    8001633a:	6795                	lui	a5,0x5
    8001633c:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    80016340:	00f70c63          	beq	a4,a5,80016358 <minix3_get_superblock+0x3a>
        block_device_read_bytes(1024, (uint8_t *)&sb, sizeof(SuperBlock));
    80016344:	02000613          	li	a2,32
    80016348:	0000a597          	auipc	a1,0xa
    8001634c:	d6858593          	addi	a1,a1,-664 # 800200b0 <sb>
    80016350:	40000513          	li	a0,1024
    80016354:	1bf050ef          	jal	ra,8001bd12 <block_device_read_bytes>
    }
    return sb;
    80016358:	fe843783          	ld	a5,-24(s0)
    8001635c:	0000a717          	auipc	a4,0xa
    80016360:	d5470713          	addi	a4,a4,-684 # 800200b0 <sb>
    80016364:	00072303          	lw	t1,0(a4)
    80016368:	00472883          	lw	a7,4(a4)
    8001636c:	00872803          	lw	a6,8(a4)
    80016370:	4748                	lw	a0,12(a4)
    80016372:	4b0c                	lw	a1,16(a4)
    80016374:	4b50                	lw	a2,20(a4)
    80016376:	4f14                	lw	a3,24(a4)
    80016378:	4f58                	lw	a4,28(a4)
    8001637a:	0067a023          	sw	t1,0(a5)
    8001637e:	0117a223          	sw	a7,4(a5)
    80016382:	0107a423          	sw	a6,8(a5)
    80016386:	c7c8                	sw	a0,12(a5)
    80016388:	cb8c                	sw	a1,16(a5)
    8001638a:	cbd0                	sw	a2,20(a5)
    8001638c:	cf94                	sw	a3,24(a5)
    8001638e:	cfd8                	sw	a4,28(a5)
}
    80016390:	fe843503          	ld	a0,-24(s0)
    80016394:	60e2                	ld	ra,24(sp)
    80016396:	6442                	ld	s0,16(sp)
    80016398:	6105                	addi	sp,sp,32
    8001639a:	8082                	ret

000000008001639c <minix3_put_superblock>:

void minix3_put_superblock(SuperBlock superblock) {
    8001639c:	1141                	addi	sp,sp,-16
    8001639e:	e406                	sd	ra,8(sp)
    800163a0:	e022                	sd	s0,0(sp)
    800163a2:	0800                	addi	s0,sp,16
    800163a4:	80aa                	mv	ra,a0
    // Put the superblock
    block_device_write_bytes(1024, (uint8_t *)&superblock, sizeof(SuperBlock));
    800163a6:	02000613          	li	a2,32
    800163aa:	8586                	mv	a1,ra
    800163ac:	40000513          	li	a0,1024
    800163b0:	25b050ef          	jal	ra,8001be0a <block_device_write_bytes>
}
    800163b4:	0001                	nop
    800163b6:	60a2                	ld	ra,8(sp)
    800163b8:	6402                	ld	s0,0(sp)
    800163ba:	0141                	addi	sp,sp,16
    800163bc:	8082                	ret

00000000800163be <minix3_get_block_size>:


uint16_t minix3_get_block_size(void) {
    800163be:	7179                	addi	sp,sp,-48
    800163c0:	f406                	sd	ra,40(sp)
    800163c2:	f022                	sd	s0,32(sp)
    800163c4:	1800                	addi	s0,sp,48
    SuperBlock superblock = minix3_get_superblock();
    800163c6:	fd040793          	addi	a5,s0,-48
    800163ca:	853e                	mv	a0,a5
    800163cc:	f53ff0ef          	jal	ra,8001631e <minix3_get_superblock>
    return 1024 << superblock.log_zone_size;
    800163d0:	fdc45783          	lhu	a5,-36(s0)
    800163d4:	2781                	sext.w	a5,a5
    800163d6:	40000713          	li	a4,1024
    800163da:	00f717bb          	sllw	a5,a4,a5
    800163de:	2781                	sext.w	a5,a5
    800163e0:	17c2                	slli	a5,a5,0x30
    800163e2:	93c1                	srli	a5,a5,0x30
}
    800163e4:	853e                	mv	a0,a5
    800163e6:	70a2                	ld	ra,40(sp)
    800163e8:	7402                	ld	s0,32(sp)
    800163ea:	6145                	addi	sp,sp,48
    800163ec:	8082                	ret

00000000800163ee <minix3_get_zone_size>:

uint16_t minix3_get_zone_size(void) {
    800163ee:	1141                	addi	sp,sp,-16
    800163f0:	e406                	sd	ra,8(sp)
    800163f2:	e022                	sd	s0,0(sp)
    800163f4:	0800                	addi	s0,sp,16
    return minix3_get_block_size();
    800163f6:	fc9ff0ef          	jal	ra,800163be <minix3_get_block_size>
    800163fa:	87aa                	mv	a5,a0
}
    800163fc:	853e                	mv	a0,a5
    800163fe:	60a2                	ld	ra,8(sp)
    80016400:	6402                	ld	s0,0(sp)
    80016402:	0141                	addi	sp,sp,16
    80016404:	8082                	ret

0000000080016406 <minix3_sectors_per_block>:

uint16_t minix3_sectors_per_block(void) {
    80016406:	1101                	addi	sp,sp,-32
    80016408:	ec06                	sd	ra,24(sp)
    8001640a:	e822                	sd	s0,16(sp)
    8001640c:	e426                	sd	s1,8(sp)
    8001640e:	1000                	addi	s0,sp,32
    return minix3_get_block_size() / block_device_get_sector_size();
    80016410:	fafff0ef          	jal	ra,800163be <minix3_get_block_size>
    80016414:	87aa                	mv	a5,a0
    80016416:	84be                	mv	s1,a5
    80016418:	5b2050ef          	jal	ra,8001b9ca <block_device_get_sector_size>
    8001641c:	87aa                	mv	a5,a0
    8001641e:	02f4d7b3          	divu	a5,s1,a5
    80016422:	17c2                	slli	a5,a5,0x30
    80016424:	93c1                	srli	a5,a5,0x30
}
    80016426:	853e                	mv	a0,a5
    80016428:	60e2                	ld	ra,24(sp)
    8001642a:	6442                	ld	s0,16(sp)
    8001642c:	64a2                	ld	s1,8(sp)
    8001642e:	6105                	addi	sp,sp,32
    80016430:	8082                	ret

0000000080016432 <minix3_get_inode_bitmap_size>:

size_t minix3_get_inode_bitmap_size(void) {
    80016432:	7139                	addi	sp,sp,-64
    80016434:	fc06                	sd	ra,56(sp)
    80016436:	f822                	sd	s0,48(sp)
    80016438:	f426                	sd	s1,40(sp)
    8001643a:	0080                	addi	s0,sp,64
    return minix3_get_superblock().imap_blocks * minix3_get_block_size();
    8001643c:	fc040793          	addi	a5,s0,-64
    80016440:	853e                	mv	a0,a5
    80016442:	eddff0ef          	jal	ra,8001631e <minix3_get_superblock>
    80016446:	fc645783          	lhu	a5,-58(s0)
    8001644a:	0007849b          	sext.w	s1,a5
    8001644e:	f71ff0ef          	jal	ra,800163be <minix3_get_block_size>
    80016452:	87aa                	mv	a5,a0
    80016454:	2781                	sext.w	a5,a5
    80016456:	02f487bb          	mulw	a5,s1,a5
    8001645a:	2781                	sext.w	a5,a5
}
    8001645c:	853e                	mv	a0,a5
    8001645e:	70e2                	ld	ra,56(sp)
    80016460:	7442                	ld	s0,48(sp)
    80016462:	74a2                	ld	s1,40(sp)
    80016464:	6121                	addi	sp,sp,64
    80016466:	8082                	ret

0000000080016468 <minix3_get_zone_bitmap_size>:

size_t minix3_get_zone_bitmap_size(void) {
    80016468:	7139                	addi	sp,sp,-64
    8001646a:	fc06                	sd	ra,56(sp)
    8001646c:	f822                	sd	s0,48(sp)
    8001646e:	f426                	sd	s1,40(sp)
    80016470:	0080                	addi	s0,sp,64
    return minix3_get_superblock().zmap_blocks * minix3_get_block_size();
    80016472:	fc040793          	addi	a5,s0,-64
    80016476:	853e                	mv	a0,a5
    80016478:	ea7ff0ef          	jal	ra,8001631e <minix3_get_superblock>
    8001647c:	fc845783          	lhu	a5,-56(s0)
    80016480:	0007849b          	sext.w	s1,a5
    80016484:	f3bff0ef          	jal	ra,800163be <minix3_get_block_size>
    80016488:	87aa                	mv	a5,a0
    8001648a:	2781                	sext.w	a5,a5
    8001648c:	02f487bb          	mulw	a5,s1,a5
    80016490:	2781                	sext.w	a5,a5
}
    80016492:	853e                	mv	a0,a5
    80016494:	70e2                	ld	ra,56(sp)
    80016496:	7442                	ld	s0,48(sp)
    80016498:	74a2                	ld	s1,40(sp)
    8001649a:	6121                	addi	sp,sp,64
    8001649c:	8082                	ret

000000008001649e <minix3_get_inode_bitmap>:

// Read the inode bitmap into the given buffer
void minix3_get_inode_bitmap(uint8_t *bitmap_buf) {
    8001649e:	7139                	addi	sp,sp,-64
    800164a0:	fc06                	sd	ra,56(sp)
    800164a2:	f822                	sd	s0,48(sp)
    800164a4:	0080                	addi	s0,sp,64
    800164a6:	fca43423          	sd	a0,-56(s0)
    debugf("Getting inode bitmap...\n");
    SuperBlock sb = minix3_get_superblock();
    800164aa:	fd040793          	addi	a5,s0,-48
    800164ae:	853e                	mv	a0,a5
    800164b0:	e6fff0ef          	jal	ra,8001631e <minix3_get_superblock>

    minix3_get_blocks(FS_IMAP_IDX, bitmap_buf, sb.imap_blocks);
    800164b4:	fd645783          	lhu	a5,-42(s0)
    800164b8:	863e                	mv	a2,a5
    800164ba:	fc843583          	ld	a1,-56(s0)
    800164be:	4509                	li	a0,2
    800164c0:	0b6000ef          	jal	ra,80016576 <minix3_get_blocks>
    // debugf("About to read inode byte at %u (%x)...\n", byte_offset, byte_offset);
    // block_device_read_bytes(byte_offset, &inode_byte, 1);
    // debugf("Inode byte: %x\n", inode_byte);
    // return inode_byte & (1 << inode % 8);
    // block_device_read_bytes(FS_IMAP_IDX * minix3_get_block_size(), bitmap_buf, minix3_get_block_size() * sb.imap_blocks);
}
    800164c4:	0001                	nop
    800164c6:	70e2                	ld	ra,56(sp)
    800164c8:	7442                	ld	s0,48(sp)
    800164ca:	6121                	addi	sp,sp,64
    800164cc:	8082                	ret

00000000800164ce <minix3_put_inode_bitmap>:
// Write the inode bitmap from the given buffer
void minix3_put_inode_bitmap(uint8_t *bitmap_buf) {
    800164ce:	7139                	addi	sp,sp,-64
    800164d0:	fc06                	sd	ra,56(sp)
    800164d2:	f822                	sd	s0,48(sp)
    800164d4:	0080                	addi	s0,sp,64
    800164d6:	fca43423          	sd	a0,-56(s0)
    debugf("Setting inode bitmap...\n");
    SuperBlock sb = minix3_get_superblock();
    800164da:	fd040793          	addi	a5,s0,-48
    800164de:	853e                	mv	a0,a5
    800164e0:	e3fff0ef          	jal	ra,8001631e <minix3_get_superblock>
    minix3_put_blocks(FS_IMAP_IDX, bitmap_buf, sb.imap_blocks);
    800164e4:	fd645783          	lhu	a5,-42(s0)
    800164e8:	863e                	mv	a2,a5
    800164ea:	fc843583          	ld	a1,-56(s0)
    800164ee:	4509                	li	a0,2
    800164f0:	0e8000ef          	jal	ra,800165d8 <minix3_put_blocks>
    // block_device_write_bytes(FS_IMAP_IDX * minix3_get_block_size(), bitmap_buf, minix3_get_block_size() * sb.imap_blocks);
}
    800164f4:	0001                	nop
    800164f6:	70e2                	ld	ra,56(sp)
    800164f8:	7442                	ld	s0,48(sp)
    800164fa:	6121                	addi	sp,sp,64
    800164fc:	8082                	ret

00000000800164fe <minix3_get_zone_bitmap>:
// Read the zone bitmap into the given buffer
void minix3_get_zone_bitmap(uint8_t *bitmap_buf) {
    800164fe:	7139                	addi	sp,sp,-64
    80016500:	fc06                	sd	ra,56(sp)
    80016502:	f822                	sd	s0,48(sp)
    80016504:	0080                	addi	s0,sp,64
    80016506:	fca43423          	sd	a0,-56(s0)
    debugf("Getting zone bitmap...\n");
    SuperBlock sb = minix3_get_superblock();
    8001650a:	fd040793          	addi	a5,s0,-48
    8001650e:	853e                	mv	a0,a5
    80016510:	e0fff0ef          	jal	ra,8001631e <minix3_get_superblock>
    minix3_get_blocks(FS_IMAP_IDX + sb.imap_blocks, bitmap_buf, sb.zmap_blocks);
    80016514:	fd645783          	lhu	a5,-42(s0)
    80016518:	2781                	sext.w	a5,a5
    8001651a:	2789                	addiw	a5,a5,2
    8001651c:	2781                	sext.w	a5,a5
    8001651e:	2781                	sext.w	a5,a5
    80016520:	fd845703          	lhu	a4,-40(s0)
    80016524:	863a                	mv	a2,a4
    80016526:	fc843583          	ld	a1,-56(s0)
    8001652a:	853e                	mv	a0,a5
    8001652c:	04a000ef          	jal	ra,80016576 <minix3_get_blocks>
    // block_device_read_bytes((FS_IMAP_IDX + sb.imap_blocks) * minix3_get_block_size(), bitmap_buf, minix3_get_block_size() * sb.zmap_blocks);
}
    80016530:	0001                	nop
    80016532:	70e2                	ld	ra,56(sp)
    80016534:	7442                	ld	s0,48(sp)
    80016536:	6121                	addi	sp,sp,64
    80016538:	8082                	ret

000000008001653a <minix3_put_zone_bitmap>:
// Write the zone bitmap from the given buffer
void minix3_put_zone_bitmap(uint8_t *bitmap_buf) {
    8001653a:	7139                	addi	sp,sp,-64
    8001653c:	fc06                	sd	ra,56(sp)
    8001653e:	f822                	sd	s0,48(sp)
    80016540:	0080                	addi	s0,sp,64
    80016542:	fca43423          	sd	a0,-56(s0)
    debugf("Setting zone bitmap...\n");
    SuperBlock sb = minix3_get_superblock();
    80016546:	fd040793          	addi	a5,s0,-48
    8001654a:	853e                	mv	a0,a5
    8001654c:	dd3ff0ef          	jal	ra,8001631e <minix3_get_superblock>
    minix3_put_blocks(FS_IMAP_IDX + sb.imap_blocks, bitmap_buf, sb.zmap_blocks);
    80016550:	fd645783          	lhu	a5,-42(s0)
    80016554:	2781                	sext.w	a5,a5
    80016556:	2789                	addiw	a5,a5,2
    80016558:	2781                	sext.w	a5,a5
    8001655a:	2781                	sext.w	a5,a5
    8001655c:	fd845703          	lhu	a4,-40(s0)
    80016560:	863a                	mv	a2,a4
    80016562:	fc843583          	ld	a1,-56(s0)
    80016566:	853e                	mv	a0,a5
    80016568:	070000ef          	jal	ra,800165d8 <minix3_put_blocks>
}
    8001656c:	0001                	nop
    8001656e:	70e2                	ld	ra,56(sp)
    80016570:	7442                	ld	s0,48(sp)
    80016572:	6121                	addi	sp,sp,64
    80016574:	8082                	ret

0000000080016576 <minix3_get_blocks>:

void minix3_get_blocks(uint32_t start_block, uint8_t *data, uint16_t count) {
    80016576:	7179                	addi	sp,sp,-48
    80016578:	f406                	sd	ra,40(sp)
    8001657a:	f022                	sd	s0,32(sp)
    8001657c:	ec26                	sd	s1,24(sp)
    8001657e:	1800                	addi	s0,sp,48
    80016580:	87aa                	mv	a5,a0
    80016582:	fcb43823          	sd	a1,-48(s0)
    80016586:	8732                	mv	a4,a2
    80016588:	fcf42e23          	sw	a5,-36(s0)
    8001658c:	87ba                	mv	a5,a4
    8001658e:	fcf41d23          	sh	a5,-38(s0)
    // SuperBlock sb = minix3_get_superblock();
    block_device_read_bytes(start_block * minix3_get_block_size(), data, minix3_get_block_size() * count);
    80016592:	e2dff0ef          	jal	ra,800163be <minix3_get_block_size>
    80016596:	87aa                	mv	a5,a0
    80016598:	2781                	sext.w	a5,a5
    8001659a:	fdc42703          	lw	a4,-36(s0)
    8001659e:	02f707bb          	mulw	a5,a4,a5
    800165a2:	2781                	sext.w	a5,a5
    800165a4:	02079493          	slli	s1,a5,0x20
    800165a8:	9081                	srli	s1,s1,0x20
    800165aa:	e15ff0ef          	jal	ra,800163be <minix3_get_block_size>
    800165ae:	87aa                	mv	a5,a0
    800165b0:	0007871b          	sext.w	a4,a5
    800165b4:	fda45783          	lhu	a5,-38(s0)
    800165b8:	2781                	sext.w	a5,a5
    800165ba:	02f707bb          	mulw	a5,a4,a5
    800165be:	2781                	sext.w	a5,a5
    800165c0:	863e                	mv	a2,a5
    800165c2:	fd043583          	ld	a1,-48(s0)
    800165c6:	8526                	mv	a0,s1
    800165c8:	74a050ef          	jal	ra,8001bd12 <block_device_read_bytes>
}
    800165cc:	0001                	nop
    800165ce:	70a2                	ld	ra,40(sp)
    800165d0:	7402                	ld	s0,32(sp)
    800165d2:	64e2                	ld	s1,24(sp)
    800165d4:	6145                	addi	sp,sp,48
    800165d6:	8082                	ret

00000000800165d8 <minix3_put_blocks>:
void minix3_put_blocks(uint32_t start_block, uint8_t *data, uint16_t count) {
    800165d8:	7179                	addi	sp,sp,-48
    800165da:	f406                	sd	ra,40(sp)
    800165dc:	f022                	sd	s0,32(sp)
    800165de:	ec26                	sd	s1,24(sp)
    800165e0:	1800                	addi	s0,sp,48
    800165e2:	87aa                	mv	a5,a0
    800165e4:	fcb43823          	sd	a1,-48(s0)
    800165e8:	8732                	mv	a4,a2
    800165ea:	fcf42e23          	sw	a5,-36(s0)
    800165ee:	87ba                	mv	a5,a4
    800165f0:	fcf41d23          	sh	a5,-38(s0)
    // SuperBlock sb = minix3_get_superblock();
    block_device_write_bytes(start_block * minix3_get_block_size(), data, minix3_get_block_size() * count);
    800165f4:	dcbff0ef          	jal	ra,800163be <minix3_get_block_size>
    800165f8:	87aa                	mv	a5,a0
    800165fa:	2781                	sext.w	a5,a5
    800165fc:	fdc42703          	lw	a4,-36(s0)
    80016600:	02f707bb          	mulw	a5,a4,a5
    80016604:	2781                	sext.w	a5,a5
    80016606:	02079493          	slli	s1,a5,0x20
    8001660a:	9081                	srli	s1,s1,0x20
    8001660c:	db3ff0ef          	jal	ra,800163be <minix3_get_block_size>
    80016610:	87aa                	mv	a5,a0
    80016612:	0007871b          	sext.w	a4,a5
    80016616:	fda45783          	lhu	a5,-38(s0)
    8001661a:	2781                	sext.w	a5,a5
    8001661c:	02f707bb          	mulw	a5,a4,a5
    80016620:	2781                	sext.w	a5,a5
    80016622:	863e                	mv	a2,a5
    80016624:	fd043583          	ld	a1,-48(s0)
    80016628:	8526                	mv	a0,s1
    8001662a:	7e0050ef          	jal	ra,8001be0a <block_device_write_bytes>
}
    8001662e:	0001                	nop
    80016630:	70a2                	ld	ra,40(sp)
    80016632:	7402                	ld	s0,32(sp)
    80016634:	64e2                	ld	s1,24(sp)
    80016636:	6145                	addi	sp,sp,48
    80016638:	8082                	ret

000000008001663a <minix3_get_block>:

void minix3_get_block(uint32_t block, uint8_t *data) {
    8001663a:	1101                	addi	sp,sp,-32
    8001663c:	ec06                	sd	ra,24(sp)
    8001663e:	e822                	sd	s0,16(sp)
    80016640:	1000                	addi	s0,sp,32
    80016642:	87aa                	mv	a5,a0
    80016644:	feb43023          	sd	a1,-32(s0)
    80016648:	fef42623          	sw	a5,-20(s0)
    minix3_get_blocks(block, data, 1);
    8001664c:	fec42783          	lw	a5,-20(s0)
    80016650:	4605                	li	a2,1
    80016652:	fe043583          	ld	a1,-32(s0)
    80016656:	853e                	mv	a0,a5
    80016658:	f1fff0ef          	jal	ra,80016576 <minix3_get_blocks>
}
    8001665c:	0001                	nop
    8001665e:	60e2                	ld	ra,24(sp)
    80016660:	6442                	ld	s0,16(sp)
    80016662:	6105                	addi	sp,sp,32
    80016664:	8082                	ret

0000000080016666 <minix3_put_block>:

void minix3_put_block(uint32_t block, uint8_t *data) {
    80016666:	1101                	addi	sp,sp,-32
    80016668:	ec06                	sd	ra,24(sp)
    8001666a:	e822                	sd	s0,16(sp)
    8001666c:	1000                	addi	s0,sp,32
    8001666e:	87aa                	mv	a5,a0
    80016670:	feb43023          	sd	a1,-32(s0)
    80016674:	fef42623          	sw	a5,-20(s0)
    minix3_put_blocks(block, data, 1);
    80016678:	fec42783          	lw	a5,-20(s0)
    8001667c:	4605                	li	a2,1
    8001667e:	fe043583          	ld	a1,-32(s0)
    80016682:	853e                	mv	a0,a5
    80016684:	f55ff0ef          	jal	ra,800165d8 <minix3_put_blocks>
}
    80016688:	0001                	nop
    8001668a:	60e2                	ld	ra,24(sp)
    8001668c:	6442                	ld	s0,16(sp)
    8001668e:	6105                	addi	sp,sp,32
    80016690:	8082                	ret

0000000080016692 <minix3_has_inode>:

bool minix3_has_inode(uint32_t inode) {
    80016692:	1101                	addi	sp,sp,-32
    80016694:	ec22                	sd	s0,24(sp)
    80016696:	1000                	addi	s0,sp,32
    80016698:	87aa                	mv	a5,a0
    8001669a:	fef42623          	sw	a5,-20(s0)
    if (inode == INVALID_INODE) {
    8001669e:	fec42783          	lw	a5,-20(s0)
    800166a2:	2781                	sext.w	a5,a5
    800166a4:	e399                	bnez	a5,800166aa <minix3_has_inode+0x18>
        debugf("minix3_has_inode: Invalid inode %u\n", inode);
        return false;
    800166a6:	4781                	li	a5,0
    800166a8:	a081                	j	800166e8 <minix3_has_inode+0x56>
    }
    return inode_bitmap[inode / 8] & (1 << inode % 8);
    800166aa:	0000a797          	auipc	a5,0xa
    800166ae:	a3678793          	addi	a5,a5,-1482 # 800200e0 <inode_bitmap>
    800166b2:	6398                	ld	a4,0(a5)
    800166b4:	fec42783          	lw	a5,-20(s0)
    800166b8:	0037d79b          	srliw	a5,a5,0x3
    800166bc:	2781                	sext.w	a5,a5
    800166be:	1782                	slli	a5,a5,0x20
    800166c0:	9381                	srli	a5,a5,0x20
    800166c2:	97ba                	add	a5,a5,a4
    800166c4:	0007c783          	lbu	a5,0(a5)
    800166c8:	0007871b          	sext.w	a4,a5
    800166cc:	fec42783          	lw	a5,-20(s0)
    800166d0:	8b9d                	andi	a5,a5,7
    800166d2:	2781                	sext.w	a5,a5
    800166d4:	4685                	li	a3,1
    800166d6:	00f697bb          	sllw	a5,a3,a5
    800166da:	2781                	sext.w	a5,a5
    800166dc:	8ff9                	and	a5,a5,a4
    800166de:	2781                	sext.w	a5,a5
    800166e0:	00f037b3          	snez	a5,a5
    800166e4:	0ff7f793          	andi	a5,a5,255
}
    800166e8:	853e                	mv	a0,a5
    800166ea:	6462                	ld	s0,24(sp)
    800166ec:	6105                	addi	sp,sp,32
    800166ee:	8082                	ret

00000000800166f0 <minix3_take_inode>:

// Mark the inode taken in the inode map.
bool minix3_take_inode(uint32_t inode) {
    800166f0:	1101                	addi	sp,sp,-32
    800166f2:	ec22                	sd	s0,24(sp)
    800166f4:	1000                	addi	s0,sp,32
    800166f6:	87aa                	mv	a5,a0
    800166f8:	fef42623          	sw	a5,-20(s0)
    if (inode == INVALID_INODE) {
    800166fc:	fec42783          	lw	a5,-20(s0)
    80016700:	2781                	sext.w	a5,a5
    80016702:	e399                	bnez	a5,80016708 <minix3_take_inode+0x18>
        debugf("minix3_has_inode: Invalid inode %u\n", inode);
        return false;
    80016704:	4781                	li	a5,0
    80016706:	a0ad                	j	80016770 <minix3_take_inode+0x80>
    }
    inode_bitmap[inode / 8] |= (1 << inode % 8);
    80016708:	0000a797          	auipc	a5,0xa
    8001670c:	9d878793          	addi	a5,a5,-1576 # 800200e0 <inode_bitmap>
    80016710:	6398                	ld	a4,0(a5)
    80016712:	fec42783          	lw	a5,-20(s0)
    80016716:	0037d79b          	srliw	a5,a5,0x3
    8001671a:	0007861b          	sext.w	a2,a5
    8001671e:	02061793          	slli	a5,a2,0x20
    80016722:	9381                	srli	a5,a5,0x20
    80016724:	97ba                	add	a5,a5,a4
    80016726:	0007c783          	lbu	a5,0(a5)
    8001672a:	0187971b          	slliw	a4,a5,0x18
    8001672e:	4187571b          	sraiw	a4,a4,0x18
    80016732:	fec42783          	lw	a5,-20(s0)
    80016736:	8b9d                	andi	a5,a5,7
    80016738:	2781                	sext.w	a5,a5
    8001673a:	4685                	li	a3,1
    8001673c:	00f697bb          	sllw	a5,a3,a5
    80016740:	2781                	sext.w	a5,a5
    80016742:	0187979b          	slliw	a5,a5,0x18
    80016746:	4187d79b          	sraiw	a5,a5,0x18
    8001674a:	8fd9                	or	a5,a5,a4
    8001674c:	0187969b          	slliw	a3,a5,0x18
    80016750:	4186d69b          	sraiw	a3,a3,0x18
    80016754:	0000a797          	auipc	a5,0xa
    80016758:	98c78793          	addi	a5,a5,-1652 # 800200e0 <inode_bitmap>
    8001675c:	6398                	ld	a4,0(a5)
    8001675e:	02061793          	slli	a5,a2,0x20
    80016762:	9381                	srli	a5,a5,0x20
    80016764:	97ba                	add	a5,a5,a4
    80016766:	0ff6f713          	andi	a4,a3,255
    8001676a:	00e78023          	sb	a4,0(a5)
    return true;
    8001676e:	4785                	li	a5,1
}
    80016770:	853e                	mv	a0,a5
    80016772:	6462                	ld	s0,24(sp)
    80016774:	6105                	addi	sp,sp,32
    80016776:	8082                	ret

0000000080016778 <minix3_get_next_free_inode>:

uint32_t minix3_get_next_free_inode() {
    80016778:	7179                	addi	sp,sp,-48
    8001677a:	f406                	sd	ra,40(sp)
    8001677c:	f022                	sd	s0,32(sp)
    8001677e:	1800                	addi	s0,sp,48
    size_t inode_bitmap_size = minix3_get_inode_bitmap_size();
    80016780:	cb3ff0ef          	jal	ra,80016432 <minix3_get_inode_bitmap_size>
    80016784:	fea43023          	sd	a0,-32(s0)

    for (int i = 0; i < inode_bitmap_size; i++) {
    80016788:	fe042623          	sw	zero,-20(s0)
    8001678c:	a8ad                	j	80016806 <minix3_get_next_free_inode+0x8e>
        if (inode_bitmap[i] != 0xFF) {
    8001678e:	0000a797          	auipc	a5,0xa
    80016792:	95278793          	addi	a5,a5,-1710 # 800200e0 <inode_bitmap>
    80016796:	6398                	ld	a4,0(a5)
    80016798:	fec42783          	lw	a5,-20(s0)
    8001679c:	97ba                	add	a5,a5,a4
    8001679e:	0007c783          	lbu	a5,0(a5)
    800167a2:	873e                	mv	a4,a5
    800167a4:	0ff00793          	li	a5,255
    800167a8:	04f70a63          	beq	a4,a5,800167fc <minix3_get_next_free_inode+0x84>
            for (int j = 0; j < 8; j++) {
    800167ac:	fe042423          	sw	zero,-24(s0)
    800167b0:	a83d                	j	800167ee <minix3_get_next_free_inode+0x76>
                uint32_t inode = 8 * i + j;
    800167b2:	fec42783          	lw	a5,-20(s0)
    800167b6:	0037979b          	slliw	a5,a5,0x3
    800167ba:	2781                	sext.w	a5,a5
    800167bc:	fe842703          	lw	a4,-24(s0)
    800167c0:	9fb9                	addw	a5,a5,a4
    800167c2:	2781                	sext.w	a5,a5
    800167c4:	fcf42e23          	sw	a5,-36(s0)
                if (!minix3_has_inode(inode)) {
    800167c8:	fdc42783          	lw	a5,-36(s0)
    800167cc:	853e                	mv	a0,a5
    800167ce:	ec5ff0ef          	jal	ra,80016692 <minix3_has_inode>
    800167d2:	87aa                	mv	a5,a0
    800167d4:	0017c793          	xori	a5,a5,1
    800167d8:	0ff7f793          	andi	a5,a5,255
    800167dc:	c781                	beqz	a5,800167e4 <minix3_get_next_free_inode+0x6c>
                    return inode;
    800167de:	fdc42783          	lw	a5,-36(s0)
    800167e2:	a83d                	j	80016820 <minix3_get_next_free_inode+0xa8>
            for (int j = 0; j < 8; j++) {
    800167e4:	fe842783          	lw	a5,-24(s0)
    800167e8:	2785                	addiw	a5,a5,1
    800167ea:	fef42423          	sw	a5,-24(s0)
    800167ee:	fe842783          	lw	a5,-24(s0)
    800167f2:	0007871b          	sext.w	a4,a5
    800167f6:	479d                	li	a5,7
    800167f8:	fae7dde3          	bge	a5,a4,800167b2 <minix3_get_next_free_inode+0x3a>
    for (int i = 0; i < inode_bitmap_size; i++) {
    800167fc:	fec42783          	lw	a5,-20(s0)
    80016800:	2785                	addiw	a5,a5,1
    80016802:	fef42623          	sw	a5,-20(s0)
    80016806:	fec42783          	lw	a5,-20(s0)
    8001680a:	fe043703          	ld	a4,-32(s0)
    8001680e:	f8e7e0e3          	bltu	a5,a4,8001678e <minix3_get_next_free_inode+0x16>
                }
            }
        }
    }

    warnf("minix3_get_next_free_inode: Couldn't find free inode\n");
    80016812:	0000c517          	auipc	a0,0xc
    80016816:	9ee50513          	addi	a0,a0,-1554 # 80022200 <pow10.0+0xfd0>
    8001681a:	241020ef          	jal	ra,8001925a <warnf>
    return 0;
    8001681e:	4781                	li	a5,0
}
    80016820:	853e                	mv	a0,a5
    80016822:	70a2                	ld	ra,40(sp)
    80016824:	7402                	ld	s0,32(sp)
    80016826:	6145                	addi	sp,sp,48
    80016828:	8082                	ret

000000008001682a <minix3_get_inode>:

static uint32_t last_inode = 0; // Last inode number we looked up
static Inode last_inode_data; // Data of the last inode

Inode minix3_get_inode(uint32_t inode) {
    8001682a:	7151                	addi	sp,sp,-240
    8001682c:	f586                	sd	ra,232(sp)
    8001682e:	f1a2                	sd	s0,224(sp)
    80016830:	1980                	addi	s0,sp,240
    80016832:	f2a43c23          	sd	a0,-200(s0)
    80016836:	87ae                	mv	a5,a1
    80016838:	f2f42a23          	sw	a5,-204(s0)
    if (inode == INVALID_INODE) {
    8001683c:	f3442783          	lw	a5,-204(s0)
    80016840:	2781                	sext.w	a5,a5
    80016842:	e78d                	bnez	a5,8001686c <minix3_get_inode+0x42>
        warnf("minix3_get_inode: Invalid inode %u\n", inode);
    80016844:	f3442783          	lw	a5,-204(s0)
    80016848:	85be                	mv	a1,a5
    8001684a:	0000c517          	auipc	a0,0xc
    8001684e:	9ee50513          	addi	a0,a0,-1554 # 80022238 <pow10.0+0x1008>
    80016852:	209020ef          	jal	ra,8001925a <warnf>
        return (Inode){0};
    80016856:	f3843783          	ld	a5,-200(s0)
    8001685a:	873e                	mv	a4,a5
    8001685c:	04000793          	li	a5,64
    80016860:	863e                	mv	a2,a5
    80016862:	4581                	li	a1,0
    80016864:	853a                	mv	a0,a4
    80016866:	2c5060ef          	jal	ra,8001d32a <memset>
    // block_device_read_bytes(offset, (uint8_t*)&data, sizeof(Inode));
    block_device_read_bytes(offset, (uint8_t*)&data, sizeof(Inode));
    last_inode_data = data;
    last_inode = inode;
    return data;
}
    8001686a:	a0e5                	j	80016952 <minix3_get_inode+0x128>
    else if (inode == last_inode) {
    8001686c:	0000a797          	auipc	a5,0xa
    80016870:	88478793          	addi	a5,a5,-1916 # 800200f0 <last_inode>
    80016874:	4398                	lw	a4,0(a5)
    80016876:	f3442783          	lw	a5,-204(s0)
    8001687a:	2781                	sext.w	a5,a5
    8001687c:	02e79163          	bne	a5,a4,8001689e <minix3_get_inode+0x74>
        return last_inode_data;
    80016880:	f3843703          	ld	a4,-200(s0)
    80016884:	0000a797          	auipc	a5,0xa
    80016888:	87478793          	addi	a5,a5,-1932 # 800200f8 <last_inode_data>
    8001688c:	86be                	mv	a3,a5
    8001688e:	04000793          	li	a5,64
    80016892:	863e                	mv	a2,a5
    80016894:	85b6                	mv	a1,a3
    80016896:	853a                	mv	a0,a4
    80016898:	395060ef          	jal	ra,8001d42c <memcpy>
    8001689c:	a85d                	j	80016952 <minix3_get_inode+0x128>
    SuperBlock sb = minix3_get_superblock();
    8001689e:	fc840793          	addi	a5,s0,-56
    800168a2:	853e                	mv	a0,a5
    800168a4:	a7bff0ef          	jal	ra,8001631e <minix3_get_superblock>
    uint64_t offset = minix3_get_inode_byte_offset(sb, inode);
    800168a8:	fc843603          	ld	a2,-56(s0)
    800168ac:	fd043683          	ld	a3,-48(s0)
    800168b0:	fd843703          	ld	a4,-40(s0)
    800168b4:	fe043783          	ld	a5,-32(s0)
    800168b8:	f0c43823          	sd	a2,-240(s0)
    800168bc:	f0d43c23          	sd	a3,-232(s0)
    800168c0:	f2e43023          	sd	a4,-224(s0)
    800168c4:	f2f43423          	sd	a5,-216(s0)
    800168c8:	f3442703          	lw	a4,-204(s0)
    800168cc:	f1040793          	addi	a5,s0,-240
    800168d0:	85ba                	mv	a1,a4
    800168d2:	853e                	mv	a0,a5
    800168d4:	ac2ff0ef          	jal	ra,80015b96 <minix3_get_inode_byte_offset>
    800168d8:	fea43423          	sd	a0,-24(s0)
    block_device_read_bytes(offset, (uint8_t*)&data, sizeof(Inode));
    800168dc:	f8840793          	addi	a5,s0,-120
    800168e0:	04000613          	li	a2,64
    800168e4:	85be                	mv	a1,a5
    800168e6:	fe843503          	ld	a0,-24(s0)
    800168ea:	428050ef          	jal	ra,8001bd12 <block_device_read_bytes>
    last_inode_data = data;
    800168ee:	0000a797          	auipc	a5,0xa
    800168f2:	80a78793          	addi	a5,a5,-2038 # 800200f8 <last_inode_data>
    800168f6:	f8843303          	ld	t1,-120(s0)
    800168fa:	f9043883          	ld	a7,-112(s0)
    800168fe:	f9843803          	ld	a6,-104(s0)
    80016902:	fa043503          	ld	a0,-96(s0)
    80016906:	fa843583          	ld	a1,-88(s0)
    8001690a:	fb043603          	ld	a2,-80(s0)
    8001690e:	fb843683          	ld	a3,-72(s0)
    80016912:	fc043703          	ld	a4,-64(s0)
    80016916:	0067b023          	sd	t1,0(a5)
    8001691a:	0117b423          	sd	a7,8(a5)
    8001691e:	0107b823          	sd	a6,16(a5)
    80016922:	ef88                	sd	a0,24(a5)
    80016924:	f38c                	sd	a1,32(a5)
    80016926:	f790                	sd	a2,40(a5)
    80016928:	fb94                	sd	a3,48(a5)
    8001692a:	ff98                	sd	a4,56(a5)
    last_inode = inode;
    8001692c:	00009797          	auipc	a5,0x9
    80016930:	7c478793          	addi	a5,a5,1988 # 800200f0 <last_inode>
    80016934:	f3442703          	lw	a4,-204(s0)
    80016938:	c398                	sw	a4,0(a5)
    return data;
    8001693a:	f3843783          	ld	a5,-200(s0)
    8001693e:	86be                	mv	a3,a5
    80016940:	f8840793          	addi	a5,s0,-120
    80016944:	04000713          	li	a4,64
    80016948:	863a                	mv	a2,a4
    8001694a:	85be                	mv	a1,a5
    8001694c:	8536                	mv	a0,a3
    8001694e:	2df060ef          	jal	ra,8001d42c <memcpy>
}
    80016952:	f3843503          	ld	a0,-200(s0)
    80016956:	70ae                	ld	ra,232(sp)
    80016958:	740e                	ld	s0,224(sp)
    8001695a:	616d                	addi	sp,sp,240
    8001695c:	8082                	ret

000000008001695e <minix3_put_inode>:

void minix3_put_inode(uint32_t inode, Inode data) {
    8001695e:	7119                	addi	sp,sp,-128
    80016960:	fc86                	sd	ra,120(sp)
    80016962:	f8a2                	sd	s0,112(sp)
    80016964:	f4a6                	sd	s1,104(sp)
    80016966:	0100                	addi	s0,sp,128
    80016968:	87aa                	mv	a5,a0
    8001696a:	84ae                	mv	s1,a1
    8001696c:	faf42623          	sw	a5,-84(s0)
    if (inode == INVALID_INODE) {
    80016970:	fac42783          	lw	a5,-84(s0)
    80016974:	2781                	sext.w	a5,a5
    80016976:	eb99                	bnez	a5,8001698c <minix3_put_inode+0x2e>
        warnf("minix3_put_inode: Invalid inode %u\n", inode);
    80016978:	fac42783          	lw	a5,-84(s0)
    8001697c:	85be                	mv	a1,a5
    8001697e:	0000c517          	auipc	a0,0xc
    80016982:	8e250513          	addi	a0,a0,-1822 # 80022260 <pow10.0+0x1030>
    80016986:	0d5020ef          	jal	ra,8001925a <warnf>
    8001698a:	a0b9                	j	800169d8 <minix3_put_inode+0x7a>
        return;
    }
    SuperBlock sb = minix3_get_superblock();
    8001698c:	fb840793          	addi	a5,s0,-72
    80016990:	853e                	mv	a0,a5
    80016992:	98dff0ef          	jal	ra,8001631e <minix3_get_superblock>
    uint64_t offset = minix3_get_inode_byte_offset(sb, inode);
    80016996:	fb843603          	ld	a2,-72(s0)
    8001699a:	fc043683          	ld	a3,-64(s0)
    8001699e:	fc843703          	ld	a4,-56(s0)
    800169a2:	fd043783          	ld	a5,-48(s0)
    800169a6:	f8c43023          	sd	a2,-128(s0)
    800169aa:	f8d43423          	sd	a3,-120(s0)
    800169ae:	f8e43823          	sd	a4,-112(s0)
    800169b2:	f8f43c23          	sd	a5,-104(s0)
    800169b6:	fac42703          	lw	a4,-84(s0)
    800169ba:	f8040793          	addi	a5,s0,-128
    800169be:	85ba                	mv	a1,a4
    800169c0:	853e                	mv	a0,a5
    800169c2:	9d4ff0ef          	jal	ra,80015b96 <minix3_get_inode_byte_offset>
    800169c6:	fca43c23          	sd	a0,-40(s0)

    // debugf("Putting inode %u at offset %u (%x)...\n", inode, offset, offset);
    block_device_write_bytes(offset, (uint8_t*)&data, sizeof(Inode));
    800169ca:	04000613          	li	a2,64
    800169ce:	85a6                	mv	a1,s1
    800169d0:	fd843503          	ld	a0,-40(s0)
    800169d4:	436050ef          	jal	ra,8001be0a <block_device_write_bytes>
}
    800169d8:	70e6                	ld	ra,120(sp)
    800169da:	7446                	ld	s0,112(sp)
    800169dc:	74a6                	ld	s1,104(sp)
    800169de:	6109                	addi	sp,sp,128
    800169e0:	8082                	ret

00000000800169e2 <minix3_alloc_inode>:

// Allocate a free inode.
// Return the allocated zero'd inode. 
Inode *minix3_alloc_inode() {
    800169e2:	7135                	addi	sp,sp,-160
    800169e4:	ed06                	sd	ra,152(sp)
    800169e6:	e922                	sd	s0,144(sp)
    800169e8:	1100                	addi	s0,sp,160
    uint32_t free_inode = minix3_get_next_free_inode();
    800169ea:	d8fff0ef          	jal	ra,80016778 <minix3_get_next_free_inode>
    800169ee:	87aa                	mv	a5,a0
    800169f0:	fef42623          	sw	a5,-20(s0)
    if (!free_inode) {
    800169f4:	fec42783          	lw	a5,-20(s0)
    800169f8:	2781                	sext.w	a5,a5
    800169fa:	eb89                	bnez	a5,80016a0c <minix3_alloc_inode+0x2a>
        warnf("minix3_alloc_inode: Couldn't find free inode\n");
    800169fc:	0000c517          	auipc	a0,0xc
    80016a00:	88c50513          	addi	a0,a0,-1908 # 80022288 <pow10.0+0x1058>
    80016a04:	057020ef          	jal	ra,8001925a <warnf>
        return 0;
    80016a08:	4781                	li	a5,0
    80016a0a:	a879                	j	80016aa8 <minix3_alloc_inode+0xc6>
    }
    minix3_take_inode(free_inode);
    80016a0c:	fec42783          	lw	a5,-20(s0)
    80016a10:	853e                	mv	a0,a5
    80016a12:	cdfff0ef          	jal	ra,800166f0 <minix3_take_inode>
    Inode data;
    memset(&data, 0, sizeof(data));
    80016a16:	fa840793          	addi	a5,s0,-88
    80016a1a:	04000613          	li	a2,64
    80016a1e:	4581                	li	a1,0
    80016a20:	853e                	mv	a0,a5
    80016a22:	109060ef          	jal	ra,8001d32a <memset>
    minix3_put_inode(free_inode, data);
    80016a26:	fa843883          	ld	a7,-88(s0)
    80016a2a:	fb043803          	ld	a6,-80(s0)
    80016a2e:	fb843503          	ld	a0,-72(s0)
    80016a32:	fc043583          	ld	a1,-64(s0)
    80016a36:	fc843603          	ld	a2,-56(s0)
    80016a3a:	fd043683          	ld	a3,-48(s0)
    80016a3e:	fd843703          	ld	a4,-40(s0)
    80016a42:	fe043783          	ld	a5,-32(s0)
    80016a46:	f7143023          	sd	a7,-160(s0)
    80016a4a:	f7043423          	sd	a6,-152(s0)
    80016a4e:	f6a43823          	sd	a0,-144(s0)
    80016a52:	f6b43c23          	sd	a1,-136(s0)
    80016a56:	f8c43023          	sd	a2,-128(s0)
    80016a5a:	f8d43423          	sd	a3,-120(s0)
    80016a5e:	f8e43823          	sd	a4,-112(s0)
    80016a62:	f8f43c23          	sd	a5,-104(s0)
    80016a66:	f6040713          	addi	a4,s0,-160
    80016a6a:	fec42783          	lw	a5,-20(s0)
    80016a6e:	85ba                	mv	a1,a4
    80016a70:	853e                	mv	a0,a5
    80016a72:	eedff0ef          	jal	ra,8001695e <minix3_put_inode>
    // infof("minix3_alloc_inode %p\n", minix3_get_inode_byte_offset(sb, free_inode)); // TODO: REMOVE
    return (Inode *)minix3_get_inode_byte_offset(sb, free_inode);
    80016a76:	00009797          	auipc	a5,0x9
    80016a7a:	63a78793          	addi	a5,a5,1594 # 800200b0 <sb>
    80016a7e:	6390                	ld	a2,0(a5)
    80016a80:	6794                	ld	a3,8(a5)
    80016a82:	6b98                	ld	a4,16(a5)
    80016a84:	6f9c                	ld	a5,24(a5)
    80016a86:	f6c43023          	sd	a2,-160(s0)
    80016a8a:	f6d43423          	sd	a3,-152(s0)
    80016a8e:	f6e43823          	sd	a4,-144(s0)
    80016a92:	f6f43c23          	sd	a5,-136(s0)
    80016a96:	fec42703          	lw	a4,-20(s0)
    80016a9a:	f6040793          	addi	a5,s0,-160
    80016a9e:	85ba                	mv	a1,a4
    80016aa0:	853e                	mv	a0,a5
    80016aa2:	8f4ff0ef          	jal	ra,80015b96 <minix3_get_inode_byte_offset>
    80016aa6:	87aa                	mv	a5,a0
}
    80016aa8:	853e                	mv	a0,a5
    80016aaa:	60ea                	ld	ra,152(sp)
    80016aac:	644a                	ld	s0,144(sp)
    80016aae:	610d                	addi	sp,sp,160
    80016ab0:	8082                	ret

0000000080016ab2 <minix3_is_dir>:

bool minix3_is_dir(uint32_t inode) {
    80016ab2:	711d                	addi	sp,sp,-96
    80016ab4:	ec86                	sd	ra,88(sp)
    80016ab6:	e8a2                	sd	s0,80(sp)
    80016ab8:	1080                	addi	s0,sp,96
    80016aba:	87aa                	mv	a5,a0
    80016abc:	faf42623          	sw	a5,-84(s0)
    Inode inode_data = minix3_get_inode(inode);
    80016ac0:	fb040793          	addi	a5,s0,-80
    80016ac4:	fac42703          	lw	a4,-84(s0)
    80016ac8:	85ba                	mv	a1,a4
    80016aca:	853e                	mv	a0,a5
    80016acc:	d5fff0ef          	jal	ra,8001682a <minix3_get_inode>
    if (inode_data.num_links == 0) {
    80016ad0:	fb245783          	lhu	a5,-78(s0)
    80016ad4:	eb91                	bnez	a5,80016ae8 <minix3_is_dir+0x36>
        warnf("minix3_is_dir: Inode %u has no links\n", inode);
    80016ad6:	fac42783          	lw	a5,-84(s0)
    80016ada:	85be                	mv	a1,a5
    80016adc:	0000b517          	auipc	a0,0xb
    80016ae0:	7dc50513          	addi	a0,a0,2012 # 800222b8 <pow10.0+0x1088>
    80016ae4:	776020ef          	jal	ra,8001925a <warnf>
    }
    return S_ISDIR(inode_data.mode) && inode_data.num_links > 0;
    80016ae8:	fb045783          	lhu	a5,-80(s0)
    80016aec:	0007871b          	sext.w	a4,a5
    80016af0:	67bd                	lui	a5,0xf
    80016af2:	8ff9                	and	a5,a5,a4
    80016af4:	2781                	sext.w	a5,a5
    80016af6:	873e                	mv	a4,a5
    80016af8:	6791                	lui	a5,0x4
    80016afa:	00f71763          	bne	a4,a5,80016b08 <minix3_is_dir+0x56>
    80016afe:	fb245783          	lhu	a5,-78(s0)
    80016b02:	c399                	beqz	a5,80016b08 <minix3_is_dir+0x56>
    80016b04:	4785                	li	a5,1
    80016b06:	a011                	j	80016b0a <minix3_is_dir+0x58>
    80016b08:	4781                	li	a5,0
    80016b0a:	8b85                	andi	a5,a5,1
    80016b0c:	0ff7f793          	andi	a5,a5,255
}
    80016b10:	853e                	mv	a0,a5
    80016b12:	60e6                	ld	ra,88(sp)
    80016b14:	6446                	ld	s0,80(sp)
    80016b16:	6125                	addi	sp,sp,96
    80016b18:	8082                	ret

0000000080016b1a <minix3_is_file>:

bool minix3_is_file(uint32_t inode) {
    80016b1a:	711d                	addi	sp,sp,-96
    80016b1c:	ec86                	sd	ra,88(sp)
    80016b1e:	e8a2                	sd	s0,80(sp)
    80016b20:	1080                	addi	s0,sp,96
    80016b22:	87aa                	mv	a5,a0
    80016b24:	faf42623          	sw	a5,-84(s0)
    Inode inode_data = minix3_get_inode(inode);
    80016b28:	fb040793          	addi	a5,s0,-80
    80016b2c:	fac42703          	lw	a4,-84(s0)
    80016b30:	85ba                	mv	a1,a4
    80016b32:	853e                	mv	a0,a5
    80016b34:	cf7ff0ef          	jal	ra,8001682a <minix3_get_inode>
    if (inode_data.num_links == 0) {
    80016b38:	fb245783          	lhu	a5,-78(s0)
    80016b3c:	eb91                	bnez	a5,80016b50 <minix3_is_file+0x36>
        warnf("minix3_is_file: Inode %u has no links\n", inode);
    80016b3e:	fac42783          	lw	a5,-84(s0)
    80016b42:	85be                	mv	a1,a5
    80016b44:	0000b517          	auipc	a0,0xb
    80016b48:	79c50513          	addi	a0,a0,1948 # 800222e0 <pow10.0+0x10b0>
    80016b4c:	70e020ef          	jal	ra,8001925a <warnf>
    }
    return S_ISREG(inode_data.mode) && inode_data.num_links > 0;
    80016b50:	fb045783          	lhu	a5,-80(s0)
    80016b54:	0007871b          	sext.w	a4,a5
    80016b58:	67bd                	lui	a5,0xf
    80016b5a:	8ff9                	and	a5,a5,a4
    80016b5c:	2781                	sext.w	a5,a5
    80016b5e:	873e                	mv	a4,a5
    80016b60:	67a1                	lui	a5,0x8
    80016b62:	00f71763          	bne	a4,a5,80016b70 <minix3_is_file+0x56>
    80016b66:	fb245783          	lhu	a5,-78(s0)
    80016b6a:	c399                	beqz	a5,80016b70 <minix3_is_file+0x56>
    80016b6c:	4785                	li	a5,1
    80016b6e:	a011                	j	80016b72 <minix3_is_file+0x58>
    80016b70:	4781                	li	a5,0
    80016b72:	8b85                	andi	a5,a5,1
    80016b74:	0ff7f793          	andi	a5,a5,255
}
    80016b78:	853e                	mv	a0,a5
    80016b7a:	60e6                	ld	ra,88(sp)
    80016b7c:	6446                	ld	s0,80(sp)
    80016b7e:	6125                	addi	sp,sp,96
    80016b80:	8082                	ret

0000000080016b82 <minix3_read_file>:

void minix3_read_file(uint32_t inode, uint8_t *data, uint32_t count) {
    80016b82:	1101                	addi	sp,sp,-32
    80016b84:	ec06                	sd	ra,24(sp)
    80016b86:	e822                	sd	s0,16(sp)
    80016b88:	1000                	addi	s0,sp,32
    80016b8a:	87aa                	mv	a5,a0
    80016b8c:	feb43023          	sd	a1,-32(s0)
    80016b90:	8732                	mv	a4,a2
    80016b92:	fef42623          	sw	a5,-20(s0)
    80016b96:	87ba                	mv	a5,a4
    80016b98:	fef42423          	sw	a5,-24(s0)
    minix3_get_data(inode, data, 0, count);
    80016b9c:	fe842703          	lw	a4,-24(s0)
    80016ba0:	fec42783          	lw	a5,-20(s0)
    80016ba4:	86ba                	mv	a3,a4
    80016ba6:	4601                	li	a2,0
    80016ba8:	fe043583          	ld	a1,-32(s0)
    80016bac:	853e                	mv	a0,a5
    80016bae:	00e000ef          	jal	ra,80016bbc <minix3_get_data>
}
    80016bb2:	0001                	nop
    80016bb4:	60e2                	ld	ra,24(sp)
    80016bb6:	6442                	ld	s0,16(sp)
    80016bb8:	6105                	addi	sp,sp,32
    80016bba:	8082                	ret

0000000080016bbc <minix3_get_data>:

void minix3_get_data(uint32_t inode, uint8_t *data, uint32_t offset, uint32_t count) {
    80016bbc:	ce010113          	addi	sp,sp,-800
    80016bc0:	30113c23          	sd	ra,792(sp)
    80016bc4:	30813823          	sd	s0,784(sp)
    80016bc8:	30913423          	sd	s1,776(sp)
    80016bcc:	31213023          	sd	s2,768(sp)
    80016bd0:	2f313c23          	sd	s3,760(sp)
    80016bd4:	2f413823          	sd	s4,752(sp)
    80016bd8:	2f513423          	sd	s5,744(sp)
    80016bdc:	2f613023          	sd	s6,736(sp)
    80016be0:	2d713c23          	sd	s7,728(sp)
    80016be4:	2d813823          	sd	s8,720(sp)
    80016be8:	2d913423          	sd	s9,712(sp)
    80016bec:	2da13023          	sd	s10,704(sp)
    80016bf0:	2bb13c23          	sd	s11,696(sp)
    80016bf4:	1600                	addi	s0,sp,800
    80016bf6:	87aa                	mv	a5,a0
    80016bf8:	e6b43023          	sd	a1,-416(s0)
    80016bfc:	8736                	mv	a4,a3
    80016bfe:	e6f42623          	sw	a5,-404(s0)
    80016c02:	87b2                	mv	a5,a2
    80016c04:	e6f42423          	sw	a5,-408(s0)
    80016c08:	87ba                	mv	a5,a4
    80016c0a:	e4f42e23          	sw	a5,-420(s0)
    80016c0e:	878a                	mv	a5,sp
    80016c10:	e4f43823          	sd	a5,-432(s0)
    // First, get the inode
    Inode inode_data = minix3_get_inode(inode);
    80016c14:	e7840793          	addi	a5,s0,-392
    80016c18:	e6c42703          	lw	a4,-404(s0)
    80016c1c:	85ba                	mv	a1,a4
    80016c1e:	853e                	mv	a0,a5
    80016c20:	c0bff0ef          	jal	ra,8001682a <minix3_get_inode>
    

    uint8_t zone_data[minix3_get_zone_size()];
    80016c24:	fcaff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016c28:	87aa                	mv	a5,a0
    80016c2a:	873e                	mv	a4,a5
    80016c2c:	87ba                	mv	a5,a4
    80016c2e:	17fd                	addi	a5,a5,-1
    80016c30:	f6f43c23          	sd	a5,-136(s0)
    80016c34:	e4e43023          	sd	a4,-448(s0)
    80016c38:	e4043423          	sd	zero,-440(s0)
    80016c3c:	e4043783          	ld	a5,-448(s0)
    80016c40:	93f5                	srli	a5,a5,0x3d
    80016c42:	e4843683          	ld	a3,-440(s0)
    80016c46:	068e                	slli	a3,a3,0x3
    80016c48:	d6d43423          	sd	a3,-664(s0)
    80016c4c:	d6843683          	ld	a3,-664(s0)
    80016c50:	8fd5                	or	a5,a5,a3
    80016c52:	d6f43423          	sd	a5,-664(s0)
    80016c56:	e4043783          	ld	a5,-448(s0)
    80016c5a:	078e                	slli	a5,a5,0x3
    80016c5c:	d6f43023          	sd	a5,-672(s0)
    80016c60:	e2e43823          	sd	a4,-464(s0)
    80016c64:	e2043c23          	sd	zero,-456(s0)
    80016c68:	e3043783          	ld	a5,-464(s0)
    80016c6c:	93f5                	srli	a5,a5,0x3d
    80016c6e:	e3843683          	ld	a3,-456(s0)
    80016c72:	00369993          	slli	s3,a3,0x3
    80016c76:	0137e9b3          	or	s3,a5,s3
    80016c7a:	e3043783          	ld	a5,-464(s0)
    80016c7e:	00379913          	slli	s2,a5,0x3
    80016c82:	87ba                	mv	a5,a4
    80016c84:	07bd                	addi	a5,a5,15
    80016c86:	8391                	srli	a5,a5,0x4
    80016c88:	0792                	slli	a5,a5,0x4
    80016c8a:	40f10133          	sub	sp,sp,a5
    80016c8e:	878a                	mv	a5,sp
    80016c90:	00078793          	mv	a5,a5
    80016c94:	f6f43823          	sd	a5,-144(s0)

    // The cursor is the current position in the data buffer
    uint32_t buffer_cursor = 0;
    80016c98:	f8042223          	sw	zero,-124(s0)
    uint32_t file_cursor = 0;
    80016c9c:	f8042423          	sw	zero,-120(s0)

    // Now, get the data
    // The first 7 zones are direct zones
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80016ca0:	f80406a3          	sb	zero,-115(s0)
    80016ca4:	aa55                	j	80016e58 <minix3_get_data+0x29c>
        uint32_t zone = inode_data.zones[direct_zone];
    80016ca6:	f8d44783          	lbu	a5,-115(s0)
    80016caa:	2781                	sext.w	a5,a5
    80016cac:	0791                	addi	a5,a5,4
    80016cae:	078a                	slli	a5,a5,0x2
    80016cb0:	f9040713          	addi	a4,s0,-112
    80016cb4:	97ba                	add	a5,a5,a4
    80016cb6:	ef07a783          	lw	a5,-272(a5) # 7ef0 <i+0x7ed0>
    80016cba:	ecf42223          	sw	a5,-316(s0)
        if (zone == 0) {
    80016cbe:	ec442783          	lw	a5,-316(s0)
    80016cc2:	2781                	sext.w	a5,a5
    80016cc4:	18078463          	beqz	a5,80016e4c <minix3_get_data+0x290>
            debugf("No direct zone %d\n", zone);
            continue;
        }
        memset(zone_data, 0, minix3_get_zone_size());
    80016cc8:	f26ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016ccc:	87aa                	mv	a5,a0
    80016cce:	2781                	sext.w	a5,a5
    80016cd0:	863e                	mv	a2,a5
    80016cd2:	4581                	li	a1,0
    80016cd4:	f7043503          	ld	a0,-144(s0)
    80016cd8:	652060ef          	jal	ra,8001d32a <memset>

        if (file_cursor + minix3_get_zone_size() < offset) {
    80016cdc:	f12ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016ce0:	87aa                	mv	a5,a0
    80016ce2:	2781                	sext.w	a5,a5
    80016ce4:	f8842703          	lw	a4,-120(s0)
    80016ce8:	9fb9                	addw	a5,a5,a4
    80016cea:	0007871b          	sext.w	a4,a5
    80016cee:	e6842783          	lw	a5,-408(s0)
    80016cf2:	2781                	sext.w	a5,a5
    80016cf4:	00f77c63          	bgeu	a4,a5,80016d0c <minix3_get_data+0x150>
            // We're not at the offset yet
            file_cursor += minix3_get_zone_size();
    80016cf8:	ef6ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016cfc:	87aa                	mv	a5,a0
    80016cfe:	2781                	sext.w	a5,a5
    80016d00:	f8842703          	lw	a4,-120(s0)
    80016d04:	9fb9                	addw	a5,a5,a4
    80016d06:	f8f42423          	sw	a5,-120(s0)
            continue;
    80016d0a:	a291                	j	80016e4e <minix3_get_data+0x292>
        } else if (file_cursor < offset) {
    80016d0c:	f8842703          	lw	a4,-120(s0)
    80016d10:	e6842783          	lw	a5,-408(s0)
    80016d14:	2701                	sext.w	a4,a4
    80016d16:	2781                	sext.w	a5,a5
    80016d18:	0af77563          	bgeu	a4,a5,80016dc2 <minix3_get_data+0x206>
            // We're in the middle of the offset
            // Read the zone into the buffer
            debugf("Reading first direct zone %d\n", zone);
            minix3_get_zone(zone, zone_data);
    80016d1c:	ec442783          	lw	a5,-316(s0)
    80016d20:	f7043583          	ld	a1,-144(s0)
    80016d24:	853e                	mv	a0,a5
    80016d26:	958ff0ef          	jal	ra,80015e7e <minix3_get_zone>
            // Copy the remaining data into the buffer
            size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    80016d2a:	ec4ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016d2e:	87aa                	mv	a5,a0
    80016d30:	0007871b          	sext.w	a4,a5
    80016d34:	f8842683          	lw	a3,-120(s0)
    80016d38:	e6842783          	lw	a5,-408(s0)
    80016d3c:	40f687bb          	subw	a5,a3,a5
    80016d40:	2781                	sext.w	a5,a5
    80016d42:	9fb9                	addw	a5,a5,a4
    80016d44:	0007871b          	sext.w	a4,a5
    80016d48:	e5c42783          	lw	a5,-420(s0)
    80016d4c:	2781                	sext.w	a5,a5
    80016d4e:	02e7e363          	bltu	a5,a4,80016d74 <minix3_get_data+0x1b8>
    80016d52:	e9cff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016d56:	87aa                	mv	a5,a0
    80016d58:	0007871b          	sext.w	a4,a5
    80016d5c:	f8842683          	lw	a3,-120(s0)
    80016d60:	e6842783          	lw	a5,-408(s0)
    80016d64:	40f687bb          	subw	a5,a3,a5
    80016d68:	2781                	sext.w	a5,a5
    80016d6a:	9fb9                	addw	a5,a5,a4
    80016d6c:	2781                	sext.w	a5,a5
    80016d6e:	1782                	slli	a5,a5,0x20
    80016d70:	9381                	srli	a5,a5,0x20
    80016d72:	a019                	j	80016d78 <minix3_get_data+0x1bc>
    80016d74:	e5c46783          	lwu	a5,-420(s0)
    80016d78:	eaf43c23          	sd	a5,-328(s0)
            memcpy(data, zone_data + offset - file_cursor, remaining);
    80016d7c:	e6846703          	lwu	a4,-408(s0)
    80016d80:	f8846783          	lwu	a5,-120(s0)
    80016d84:	40f707b3          	sub	a5,a4,a5
    80016d88:	f7043703          	ld	a4,-144(s0)
    80016d8c:	97ba                	add	a5,a5,a4
    80016d8e:	eb843703          	ld	a4,-328(s0)
    80016d92:	2701                	sext.w	a4,a4
    80016d94:	863a                	mv	a2,a4
    80016d96:	85be                	mv	a1,a5
    80016d98:	e6043503          	ld	a0,-416(s0)
    80016d9c:	690060ef          	jal	ra,8001d42c <memcpy>
            buffer_cursor += remaining;
    80016da0:	eb843783          	ld	a5,-328(s0)
    80016da4:	2781                	sext.w	a5,a5
    80016da6:	f8442703          	lw	a4,-124(s0)
    80016daa:	9fb9                	addw	a5,a5,a4
    80016dac:	f8f42223          	sw	a5,-124(s0)
            file_cursor = offset + remaining;
    80016db0:	eb843783          	ld	a5,-328(s0)
    80016db4:	2781                	sext.w	a5,a5
    80016db6:	e6842703          	lw	a4,-408(s0)
    80016dba:	9fb9                	addw	a5,a5,a4
    80016dbc:	f8f42423          	sw	a5,-120(s0)
            continue;
    80016dc0:	a079                	j	80016e4e <minix3_get_data+0x292>
        }

        // Read the zone into the buffer
        minix3_get_zone(zone, zone_data);
    80016dc2:	ec442783          	lw	a5,-316(s0)
    80016dc6:	f7043583          	ld	a1,-144(s0)
    80016dca:	853e                	mv	a0,a5
    80016dcc:	8b2ff0ef          	jal	ra,80015e7e <minix3_get_zone>

        // If the cursor is past the amount of data we want, we're done
        if (buffer_cursor + minix3_get_zone_size() > count) {
    80016dd0:	e1eff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016dd4:	87aa                	mv	a5,a0
    80016dd6:	2781                	sext.w	a5,a5
    80016dd8:	f8442703          	lw	a4,-124(s0)
    80016ddc:	9fb9                	addw	a5,a5,a4
    80016dde:	0007871b          	sext.w	a4,a5
    80016de2:	e5c42783          	lw	a5,-420(s0)
    80016de6:	2781                	sext.w	a5,a5
    80016de8:	02e7f863          	bgeu	a5,a4,80016e18 <minix3_get_data+0x25c>
            debugf("Reading last direct zone %d\n", zone);
            // Copy the remaining data into the buffer
            memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    80016dec:	f8446783          	lwu	a5,-124(s0)
    80016df0:	e6043703          	ld	a4,-416(s0)
    80016df4:	00f706b3          	add	a3,a4,a5
    80016df8:	e5c42703          	lw	a4,-420(s0)
    80016dfc:	f8442783          	lw	a5,-124(s0)
    80016e00:	40f707bb          	subw	a5,a4,a5
    80016e04:	2781                	sext.w	a5,a5
    80016e06:	2781                	sext.w	a5,a5
    80016e08:	863e                	mv	a2,a5
    80016e0a:	f7043583          	ld	a1,-144(s0)
    80016e0e:	8536                	mv	a0,a3
    80016e10:	61c060ef          	jal	ra,8001d42c <memcpy>
            // We're done
            return;
    80016e14:	2670006f          	j	8001787a <minix3_get_data+0xcbe>
        } else {
            debugf("Reading direct zone %d\n", zone);
            // Copy the entire zone into the buffer
            memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size());
    80016e18:	f8446783          	lwu	a5,-124(s0)
    80016e1c:	e6043703          	ld	a4,-416(s0)
    80016e20:	00f704b3          	add	s1,a4,a5
    80016e24:	dcaff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016e28:	87aa                	mv	a5,a0
    80016e2a:	2781                	sext.w	a5,a5
    80016e2c:	863e                	mv	a2,a5
    80016e2e:	f7043583          	ld	a1,-144(s0)
    80016e32:	8526                	mv	a0,s1
    80016e34:	5f8060ef          	jal	ra,8001d42c <memcpy>
        }
        buffer_cursor += minix3_get_zone_size();
    80016e38:	db6ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016e3c:	87aa                	mv	a5,a0
    80016e3e:	2781                	sext.w	a5,a5
    80016e40:	f8442703          	lw	a4,-124(s0)
    80016e44:	9fb9                	addw	a5,a5,a4
    80016e46:	f8f42223          	sw	a5,-124(s0)
    80016e4a:	a011                	j	80016e4e <minix3_get_data+0x292>
            continue;
    80016e4c:	0001                	nop
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80016e4e:	f8d44783          	lbu	a5,-115(s0)
    80016e52:	2785                	addiw	a5,a5,1
    80016e54:	f8f406a3          	sb	a5,-115(s0)
    80016e58:	f8d44783          	lbu	a5,-115(s0)
    80016e5c:	0ff7f713          	andi	a4,a5,255
    80016e60:	4799                	li	a5,6
    80016e62:	e4e7f2e3          	bgeu	a5,a4,80016ca6 <minix3_get_data+0xea>
    }

    debugf("Done with direct zones\n");
    // The next zone is an indirect zone
    if (inode_data.zones[7] != 0) {
    80016e66:	eac42783          	lw	a5,-340(s0)
    80016e6a:	26078b63          	beqz	a5,800170e0 <minix3_get_data+0x524>
    80016e6e:	878a                	mv	a5,sp
    80016e70:	893e                	mv	s2,a5
        debugf("Reading indirect zone %d\n", inode_data.zones[7]);
        uint32_t indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    80016e72:	d7cff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016e76:	87aa                	mv	a5,a0
    80016e78:	0027d79b          	srliw	a5,a5,0x2
    80016e7c:	17c2                	slli	a5,a5,0x30
    80016e7e:	93c1                	srli	a5,a5,0x30
    80016e80:	873e                	mv	a4,a5
    80016e82:	177d                	addi	a4,a4,-1
    80016e84:	f6e43423          	sd	a4,-152(s0)
    80016e88:	e2f43023          	sd	a5,-480(s0)
    80016e8c:	e2043423          	sd	zero,-472(s0)
    80016e90:	e2043703          	ld	a4,-480(s0)
    80016e94:	936d                	srli	a4,a4,0x3b
    80016e96:	e2843683          	ld	a3,-472(s0)
    80016e9a:	0696                	slli	a3,a3,0x5
    80016e9c:	d4d43c23          	sd	a3,-680(s0)
    80016ea0:	d5843683          	ld	a3,-680(s0)
    80016ea4:	8f55                	or	a4,a4,a3
    80016ea6:	d4e43c23          	sd	a4,-680(s0)
    80016eaa:	e2043703          	ld	a4,-480(s0)
    80016eae:	0716                	slli	a4,a4,0x5
    80016eb0:	d4e43823          	sd	a4,-688(s0)
    80016eb4:	e0f43823          	sd	a5,-496(s0)
    80016eb8:	e0043c23          	sd	zero,-488(s0)
    80016ebc:	e1043703          	ld	a4,-496(s0)
    80016ec0:	936d                	srli	a4,a4,0x3b
    80016ec2:	e1843683          	ld	a3,-488(s0)
    80016ec6:	0696                	slli	a3,a3,0x5
    80016ec8:	d4d43423          	sd	a3,-696(s0)
    80016ecc:	d4843683          	ld	a3,-696(s0)
    80016ed0:	8f55                	or	a4,a4,a3
    80016ed2:	d4e43423          	sd	a4,-696(s0)
    80016ed6:	e1043703          	ld	a4,-496(s0)
    80016eda:	0716                	slli	a4,a4,0x5
    80016edc:	d4e43023          	sd	a4,-704(s0)
    80016ee0:	078a                	slli	a5,a5,0x2
    80016ee2:	07bd                	addi	a5,a5,15
    80016ee4:	8391                	srli	a5,a5,0x4
    80016ee6:	0792                	slli	a5,a5,0x4
    80016ee8:	40f10133          	sub	sp,sp,a5
    80016eec:	878a                	mv	a5,sp
    80016eee:	078d                	addi	a5,a5,3
    80016ef0:	8389                	srli	a5,a5,0x2
    80016ef2:	078a                	slli	a5,a5,0x2
    80016ef4:	f6f43023          	sd	a5,-160(s0)
        minix3_get_zone(inode_data.zones[7], (uint8_t*)indirect_zones);
    80016ef8:	eac42783          	lw	a5,-340(s0)
    80016efc:	f6043583          	ld	a1,-160(s0)
    80016f00:	853e                	mv	a0,a5
    80016f02:	f7dfe0ef          	jal	ra,80015e7e <minix3_get_zone>
        

        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    80016f06:	f8040723          	sb	zero,-114(s0)
    80016f0a:	aa4d                	j	800170bc <minix3_get_data+0x500>
            uint32_t zone = indirect_zones[indirect_zone];
    80016f0c:	f8e44783          	lbu	a5,-114(s0)
    80016f10:	2781                	sext.w	a5,a5
    80016f12:	f6043703          	ld	a4,-160(s0)
    80016f16:	078a                	slli	a5,a5,0x2
    80016f18:	97ba                	add	a5,a5,a4
    80016f1a:	439c                	lw	a5,0(a5)
    80016f1c:	f4f42e23          	sw	a5,-164(s0)
            debugf("Reading indirect zone %d\n", zone);
            if (zone == 0) continue;
    80016f20:	f5c42783          	lw	a5,-164(s0)
    80016f24:	2781                	sext.w	a5,a5
    80016f26:	18078563          	beqz	a5,800170b0 <minix3_get_data+0x4f4>
            

            if (file_cursor + minix3_get_zone_size() < offset) {
    80016f2a:	cc4ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016f2e:	87aa                	mv	a5,a0
    80016f30:	2781                	sext.w	a5,a5
    80016f32:	f8842703          	lw	a4,-120(s0)
    80016f36:	9fb9                	addw	a5,a5,a4
    80016f38:	0007871b          	sext.w	a4,a5
    80016f3c:	e6842783          	lw	a5,-408(s0)
    80016f40:	2781                	sext.w	a5,a5
    80016f42:	00f77c63          	bgeu	a4,a5,80016f5a <minix3_get_data+0x39e>
                // We're not at the offset yet
                file_cursor += minix3_get_zone_size();
    80016f46:	ca8ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016f4a:	87aa                	mv	a5,a0
    80016f4c:	2781                	sext.w	a5,a5
    80016f4e:	f8842703          	lw	a4,-120(s0)
    80016f52:	9fb9                	addw	a5,a5,a4
    80016f54:	f8f42423          	sw	a5,-120(s0)
                continue;
    80016f58:	aaa9                	j	800170b2 <minix3_get_data+0x4f6>
            } else if (file_cursor < offset) {
    80016f5a:	f8842703          	lw	a4,-120(s0)
    80016f5e:	e6842783          	lw	a5,-408(s0)
    80016f62:	2701                	sext.w	a4,a4
    80016f64:	2781                	sext.w	a5,a5
    80016f66:	0af77563          	bgeu	a4,a5,80017010 <minix3_get_data+0x454>
                // We're in the middle of the offset
                // Read the zone into the buffer
                minix3_get_zone(zone, zone_data);
    80016f6a:	f5c42783          	lw	a5,-164(s0)
    80016f6e:	f7043583          	ld	a1,-144(s0)
    80016f72:	853e                	mv	a0,a5
    80016f74:	f0bfe0ef          	jal	ra,80015e7e <minix3_get_zone>
                // Copy the remaining data into the buffer
                size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    80016f78:	c76ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016f7c:	87aa                	mv	a5,a0
    80016f7e:	0007871b          	sext.w	a4,a5
    80016f82:	f8842683          	lw	a3,-120(s0)
    80016f86:	e6842783          	lw	a5,-408(s0)
    80016f8a:	40f687bb          	subw	a5,a3,a5
    80016f8e:	2781                	sext.w	a5,a5
    80016f90:	9fb9                	addw	a5,a5,a4
    80016f92:	0007871b          	sext.w	a4,a5
    80016f96:	e5c42783          	lw	a5,-420(s0)
    80016f9a:	2781                	sext.w	a5,a5
    80016f9c:	02e7e363          	bltu	a5,a4,80016fc2 <minix3_get_data+0x406>
    80016fa0:	c4eff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80016fa4:	87aa                	mv	a5,a0
    80016fa6:	0007871b          	sext.w	a4,a5
    80016faa:	f8842683          	lw	a3,-120(s0)
    80016fae:	e6842783          	lw	a5,-408(s0)
    80016fb2:	40f687bb          	subw	a5,a3,a5
    80016fb6:	2781                	sext.w	a5,a5
    80016fb8:	9fb9                	addw	a5,a5,a4
    80016fba:	2781                	sext.w	a5,a5
    80016fbc:	1782                	slli	a5,a5,0x20
    80016fbe:	9381                	srli	a5,a5,0x20
    80016fc0:	a019                	j	80016fc6 <minix3_get_data+0x40a>
    80016fc2:	e5c46783          	lwu	a5,-420(s0)
    80016fc6:	f4f43823          	sd	a5,-176(s0)
                memcpy(data, zone_data + offset - file_cursor, remaining);
    80016fca:	e6846703          	lwu	a4,-408(s0)
    80016fce:	f8846783          	lwu	a5,-120(s0)
    80016fd2:	40f707b3          	sub	a5,a4,a5
    80016fd6:	f7043703          	ld	a4,-144(s0)
    80016fda:	97ba                	add	a5,a5,a4
    80016fdc:	f5043703          	ld	a4,-176(s0)
    80016fe0:	2701                	sext.w	a4,a4
    80016fe2:	863a                	mv	a2,a4
    80016fe4:	85be                	mv	a1,a5
    80016fe6:	e6043503          	ld	a0,-416(s0)
    80016fea:	442060ef          	jal	ra,8001d42c <memcpy>
                buffer_cursor += remaining;
    80016fee:	f5043783          	ld	a5,-176(s0)
    80016ff2:	2781                	sext.w	a5,a5
    80016ff4:	f8442703          	lw	a4,-124(s0)
    80016ff8:	9fb9                	addw	a5,a5,a4
    80016ffa:	f8f42223          	sw	a5,-124(s0)
                file_cursor = offset + remaining;
    80016ffe:	f5043783          	ld	a5,-176(s0)
    80017002:	2781                	sext.w	a5,a5
    80017004:	e6842703          	lw	a4,-408(s0)
    80017008:	9fb9                	addw	a5,a5,a4
    8001700a:	f8f42423          	sw	a5,-120(s0)
                continue;
    8001700e:	a055                	j	800170b2 <minix3_get_data+0x4f6>
            }
            
            memset(zone_data, 0, minix3_get_zone_size());
    80017010:	bdeff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017014:	87aa                	mv	a5,a0
    80017016:	2781                	sext.w	a5,a5
    80017018:	863e                	mv	a2,a5
    8001701a:	4581                	li	a1,0
    8001701c:	f7043503          	ld	a0,-144(s0)
    80017020:	30a060ef          	jal	ra,8001d32a <memset>

            // Read the zone into the buffer
            minix3_get_zone(zone, zone_data);
    80017024:	f5c42783          	lw	a5,-164(s0)
    80017028:	f7043583          	ld	a1,-144(s0)
    8001702c:	853e                	mv	a0,a5
    8001702e:	e51fe0ef          	jal	ra,80015e7e <minix3_get_zone>
            // If the cursor is past the amount of data we want, we're done
            if (buffer_cursor + minix3_get_zone_size() > count) {
    80017032:	bbcff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017036:	87aa                	mv	a5,a0
    80017038:	2781                	sext.w	a5,a5
    8001703a:	f8442703          	lw	a4,-124(s0)
    8001703e:	9fb9                	addw	a5,a5,a4
    80017040:	0007871b          	sext.w	a4,a5
    80017044:	e5c42783          	lw	a5,-420(s0)
    80017048:	2781                	sext.w	a5,a5
    8001704a:	02e7f963          	bgeu	a5,a4,8001707c <minix3_get_data+0x4c0>
                // Copy the remaining data into the buffer
                memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    8001704e:	f8446783          	lwu	a5,-124(s0)
    80017052:	e6043703          	ld	a4,-416(s0)
    80017056:	00f706b3          	add	a3,a4,a5
    8001705a:	e5c42703          	lw	a4,-420(s0)
    8001705e:	f8442783          	lw	a5,-124(s0)
    80017062:	40f707bb          	subw	a5,a4,a5
    80017066:	2781                	sext.w	a5,a5
    80017068:	2781                	sext.w	a5,a5
    8001706a:	863e                	mv	a2,a5
    8001706c:	f7043583          	ld	a1,-144(s0)
    80017070:	8536                	mv	a0,a3
    80017072:	3ba060ef          	jal	ra,8001d42c <memcpy>
    80017076:	814a                	mv	sp,s2
    80017078:	0030006f          	j	8001787a <minix3_get_data+0xcbe>
                // We're done
                return;
            } else {
                // Copy the entire zone into the buffer
                memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size());
    8001707c:	f8446783          	lwu	a5,-124(s0)
    80017080:	e6043703          	ld	a4,-416(s0)
    80017084:	00f704b3          	add	s1,a4,a5
    80017088:	b66ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001708c:	87aa                	mv	a5,a0
    8001708e:	2781                	sext.w	a5,a5
    80017090:	863e                	mv	a2,a5
    80017092:	f7043583          	ld	a1,-144(s0)
    80017096:	8526                	mv	a0,s1
    80017098:	394060ef          	jal	ra,8001d42c <memcpy>
            }
            buffer_cursor += minix3_get_zone_size();
    8001709c:	b52ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800170a0:	87aa                	mv	a5,a0
    800170a2:	2781                	sext.w	a5,a5
    800170a4:	f8442703          	lw	a4,-124(s0)
    800170a8:	9fb9                	addw	a5,a5,a4
    800170aa:	f8f42223          	sw	a5,-124(s0)
    800170ae:	a011                	j	800170b2 <minix3_get_data+0x4f6>
            if (zone == 0) continue;
    800170b0:	0001                	nop
        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    800170b2:	f8e44783          	lbu	a5,-114(s0)
    800170b6:	2785                	addiw	a5,a5,1
    800170b8:	f8f40723          	sb	a5,-114(s0)
    800170bc:	f8e44783          	lbu	a5,-114(s0)
    800170c0:	03079493          	slli	s1,a5,0x30
    800170c4:	90c1                	srli	s1,s1,0x30
    800170c6:	b28ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800170ca:	87aa                	mv	a5,a0
    800170cc:	0027d79b          	srliw	a5,a5,0x2
    800170d0:	17c2                	slli	a5,a5,0x30
    800170d2:	93c1                	srli	a5,a5,0x30
    800170d4:	0004871b          	sext.w	a4,s1
    800170d8:	2781                	sext.w	a5,a5
    800170da:	e2f769e3          	bltu	a4,a5,80016f0c <minix3_get_data+0x350>
    800170de:	814a                	mv	sp,s2
    } else {
        debugf("No indirect zone\n");
    }

    // The next zone is a double indirect zone
    if (inode_data.zones[8] != 0) {
    800170e0:	eb042783          	lw	a5,-336(s0)
    800170e4:	34078d63          	beqz	a5,8001743e <minix3_get_data+0x882>
    800170e8:	878a                	mv	a5,sp
    800170ea:	89be                	mv	s3,a5
        uint32_t double_indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    800170ec:	b02ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800170f0:	87aa                	mv	a5,a0
    800170f2:	0027d79b          	srliw	a5,a5,0x2
    800170f6:	17c2                	slli	a5,a5,0x30
    800170f8:	93c1                	srli	a5,a5,0x30
    800170fa:	873e                	mv	a4,a5
    800170fc:	177d                	addi	a4,a4,-1
    800170fe:	f4e43423          	sd	a4,-184(s0)
    80017102:	e0f43023          	sd	a5,-512(s0)
    80017106:	e0043423          	sd	zero,-504(s0)
    8001710a:	e0043703          	ld	a4,-512(s0)
    8001710e:	936d                	srli	a4,a4,0x3b
    80017110:	e0843683          	ld	a3,-504(s0)
    80017114:	0696                	slli	a3,a3,0x5
    80017116:	d2d43c23          	sd	a3,-712(s0)
    8001711a:	d3843683          	ld	a3,-712(s0)
    8001711e:	8f55                	or	a4,a4,a3
    80017120:	d2e43c23          	sd	a4,-712(s0)
    80017124:	e0043703          	ld	a4,-512(s0)
    80017128:	0716                	slli	a4,a4,0x5
    8001712a:	d2e43823          	sd	a4,-720(s0)
    8001712e:	def43823          	sd	a5,-528(s0)
    80017132:	de043c23          	sd	zero,-520(s0)
    80017136:	df043703          	ld	a4,-528(s0)
    8001713a:	936d                	srli	a4,a4,0x3b
    8001713c:	df843683          	ld	a3,-520(s0)
    80017140:	0696                	slli	a3,a3,0x5
    80017142:	d2d43423          	sd	a3,-728(s0)
    80017146:	d2843683          	ld	a3,-728(s0)
    8001714a:	8f55                	or	a4,a4,a3
    8001714c:	d2e43423          	sd	a4,-728(s0)
    80017150:	df043703          	ld	a4,-528(s0)
    80017154:	0716                	slli	a4,a4,0x5
    80017156:	d2e43023          	sd	a4,-736(s0)
    8001715a:	078a                	slli	a5,a5,0x2
    8001715c:	07bd                	addi	a5,a5,15
    8001715e:	8391                	srli	a5,a5,0x4
    80017160:	0792                	slli	a5,a5,0x4
    80017162:	40f10133          	sub	sp,sp,a5
    80017166:	878a                	mv	a5,sp
    80017168:	078d                	addi	a5,a5,3
    8001716a:	8389                	srli	a5,a5,0x2
    8001716c:	078a                	slli	a5,a5,0x2
    8001716e:	f4f43023          	sd	a5,-192(s0)
        // We're done
        minix3_get_zone(inode_data.zones[8], (uint8_t*)double_indirect_zones);
    80017172:	eb042783          	lw	a5,-336(s0)
    80017176:	f4043583          	ld	a1,-192(s0)
    8001717a:	853e                	mv	a0,a5
    8001717c:	d03fe0ef          	jal	ra,80015e7e <minix3_get_zone>

        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    80017180:	f80407a3          	sb	zero,-113(s0)
    80017184:	ac59                	j	8001741a <minix3_get_data+0x85e>
    80017186:	878a                	mv	a5,sp
    80017188:	84be                	mv	s1,a5
            uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    8001718a:	f8f44783          	lbu	a5,-113(s0)
    8001718e:	2781                	sext.w	a5,a5
    80017190:	f4043703          	ld	a4,-192(s0)
    80017194:	078a                	slli	a5,a5,0x2
    80017196:	97ba                	add	a5,a5,a4
    80017198:	439c                	lw	a5,0(a5)
    8001719a:	f2f42e23          	sw	a5,-196(s0)
            if (indirect_zone == 0) continue;
    8001719e:	f3c42783          	lw	a5,-196(s0)
    800171a2:	2781                	sext.w	a5,a5
    800171a4:	e399                	bnez	a5,800171aa <minix3_get_data+0x5ee>
    800171a6:	8126                	mv	sp,s1
    800171a8:	a4a5                	j	80017410 <minix3_get_data+0x854>

            uint32_t indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    800171aa:	a44ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800171ae:	87aa                	mv	a5,a0
    800171b0:	0027d79b          	srliw	a5,a5,0x2
    800171b4:	17c2                	slli	a5,a5,0x30
    800171b6:	93c1                	srli	a5,a5,0x30
    800171b8:	873e                	mv	a4,a5
    800171ba:	177d                	addi	a4,a4,-1
    800171bc:	f2e43823          	sd	a4,-208(s0)
    800171c0:	def43023          	sd	a5,-544(s0)
    800171c4:	de043423          	sd	zero,-536(s0)
    800171c8:	de043703          	ld	a4,-544(s0)
    800171cc:	936d                	srli	a4,a4,0x3b
    800171ce:	de843683          	ld	a3,-536(s0)
    800171d2:	00569a93          	slli	s5,a3,0x5
    800171d6:	01576ab3          	or	s5,a4,s5
    800171da:	de043703          	ld	a4,-544(s0)
    800171de:	00571a13          	slli	s4,a4,0x5
    800171e2:	dcf43823          	sd	a5,-560(s0)
    800171e6:	dc043c23          	sd	zero,-552(s0)
    800171ea:	dd043703          	ld	a4,-560(s0)
    800171ee:	936d                	srli	a4,a4,0x3b
    800171f0:	dd843683          	ld	a3,-552(s0)
    800171f4:	0696                	slli	a3,a3,0x5
    800171f6:	d0d43c23          	sd	a3,-744(s0)
    800171fa:	d1843683          	ld	a3,-744(s0)
    800171fe:	8f55                	or	a4,a4,a3
    80017200:	d0e43c23          	sd	a4,-744(s0)
    80017204:	dd043703          	ld	a4,-560(s0)
    80017208:	0716                	slli	a4,a4,0x5
    8001720a:	d0e43823          	sd	a4,-752(s0)
    8001720e:	078a                	slli	a5,a5,0x2
    80017210:	07bd                	addi	a5,a5,15
    80017212:	8391                	srli	a5,a5,0x4
    80017214:	0792                	slli	a5,a5,0x4
    80017216:	40f10133          	sub	sp,sp,a5
    8001721a:	878a                	mv	a5,sp
    8001721c:	078d                	addi	a5,a5,3
    8001721e:	8389                	srli	a5,a5,0x2
    80017220:	078a                	slli	a5,a5,0x2
    80017222:	f2f43423          	sd	a5,-216(s0)
            minix3_get_zone(indirect_zone, (uint8_t*)indirect_zones);
    80017226:	f3c42783          	lw	a5,-196(s0)
    8001722a:	f2843583          	ld	a1,-216(s0)
    8001722e:	853e                	mv	a0,a5
    80017230:	c4ffe0ef          	jal	ra,80015e7e <minix3_get_zone>

            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    80017234:	f80401a3          	sb	zero,-125(s0)
    80017238:	aa4d                	j	800173ea <minix3_get_data+0x82e>
                uint32_t zone = indirect_zones[indirect_zone];
    8001723a:	f8344783          	lbu	a5,-125(s0)
    8001723e:	2781                	sext.w	a5,a5
    80017240:	f2843703          	ld	a4,-216(s0)
    80017244:	078a                	slli	a5,a5,0x2
    80017246:	97ba                	add	a5,a5,a4
    80017248:	439c                	lw	a5,0(a5)
    8001724a:	f2f42223          	sw	a5,-220(s0)
                if (zone == 0) continue;
    8001724e:	f2442783          	lw	a5,-220(s0)
    80017252:	2781                	sext.w	a5,a5
    80017254:	18078563          	beqz	a5,800173de <minix3_get_data+0x822>
                debugf("Reading double indirect zone %d\n", zone);

                if (file_cursor + minix3_get_zone_size() < offset) {
    80017258:	996ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001725c:	87aa                	mv	a5,a0
    8001725e:	2781                	sext.w	a5,a5
    80017260:	f8842703          	lw	a4,-120(s0)
    80017264:	9fb9                	addw	a5,a5,a4
    80017266:	0007871b          	sext.w	a4,a5
    8001726a:	e6842783          	lw	a5,-408(s0)
    8001726e:	2781                	sext.w	a5,a5
    80017270:	00f77c63          	bgeu	a4,a5,80017288 <minix3_get_data+0x6cc>
                    // We're not at the offset yet
                    file_cursor += minix3_get_zone_size();
    80017274:	97aff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017278:	87aa                	mv	a5,a0
    8001727a:	2781                	sext.w	a5,a5
    8001727c:	f8842703          	lw	a4,-120(s0)
    80017280:	9fb9                	addw	a5,a5,a4
    80017282:	f8f42423          	sw	a5,-120(s0)
                    continue;
    80017286:	aaa9                	j	800173e0 <minix3_get_data+0x824>
                } else if (file_cursor < offset) {
    80017288:	f8842703          	lw	a4,-120(s0)
    8001728c:	e6842783          	lw	a5,-408(s0)
    80017290:	2701                	sext.w	a4,a4
    80017292:	2781                	sext.w	a5,a5
    80017294:	0af77563          	bgeu	a4,a5,8001733e <minix3_get_data+0x782>
                    // We're in the middle of the offset
                    // Read the zone into the buffer
                    minix3_get_zone(zone, zone_data);
    80017298:	f2442783          	lw	a5,-220(s0)
    8001729c:	f7043583          	ld	a1,-144(s0)
    800172a0:	853e                	mv	a0,a5
    800172a2:	bddfe0ef          	jal	ra,80015e7e <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    800172a6:	948ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800172aa:	87aa                	mv	a5,a0
    800172ac:	0007871b          	sext.w	a4,a5
    800172b0:	f8842683          	lw	a3,-120(s0)
    800172b4:	e6842783          	lw	a5,-408(s0)
    800172b8:	40f687bb          	subw	a5,a3,a5
    800172bc:	2781                	sext.w	a5,a5
    800172be:	9fb9                	addw	a5,a5,a4
    800172c0:	0007871b          	sext.w	a4,a5
    800172c4:	e5c42783          	lw	a5,-420(s0)
    800172c8:	2781                	sext.w	a5,a5
    800172ca:	02e7e363          	bltu	a5,a4,800172f0 <minix3_get_data+0x734>
    800172ce:	920ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800172d2:	87aa                	mv	a5,a0
    800172d4:	0007871b          	sext.w	a4,a5
    800172d8:	f8842683          	lw	a3,-120(s0)
    800172dc:	e6842783          	lw	a5,-408(s0)
    800172e0:	40f687bb          	subw	a5,a3,a5
    800172e4:	2781                	sext.w	a5,a5
    800172e6:	9fb9                	addw	a5,a5,a4
    800172e8:	2781                	sext.w	a5,a5
    800172ea:	1782                	slli	a5,a5,0x20
    800172ec:	9381                	srli	a5,a5,0x20
    800172ee:	a019                	j	800172f4 <minix3_get_data+0x738>
    800172f0:	e5c46783          	lwu	a5,-420(s0)
    800172f4:	f0f43c23          	sd	a5,-232(s0)
                    memcpy(data, zone_data + offset - file_cursor, remaining);
    800172f8:	e6846703          	lwu	a4,-408(s0)
    800172fc:	f8846783          	lwu	a5,-120(s0)
    80017300:	40f707b3          	sub	a5,a4,a5
    80017304:	f7043703          	ld	a4,-144(s0)
    80017308:	97ba                	add	a5,a5,a4
    8001730a:	f1843703          	ld	a4,-232(s0)
    8001730e:	2701                	sext.w	a4,a4
    80017310:	863a                	mv	a2,a4
    80017312:	85be                	mv	a1,a5
    80017314:	e6043503          	ld	a0,-416(s0)
    80017318:	114060ef          	jal	ra,8001d42c <memcpy>
                    buffer_cursor += remaining;
    8001731c:	f1843783          	ld	a5,-232(s0)
    80017320:	2781                	sext.w	a5,a5
    80017322:	f8442703          	lw	a4,-124(s0)
    80017326:	9fb9                	addw	a5,a5,a4
    80017328:	f8f42223          	sw	a5,-124(s0)
                    file_cursor = offset + remaining;
    8001732c:	f1843783          	ld	a5,-232(s0)
    80017330:	2781                	sext.w	a5,a5
    80017332:	e6842703          	lw	a4,-408(s0)
    80017336:	9fb9                	addw	a5,a5,a4
    80017338:	f8f42423          	sw	a5,-120(s0)
                    continue;
    8001733c:	a055                	j	800173e0 <minix3_get_data+0x824>
                }
                
                // Read the zone into the buffer
                memset(zone_data, 0, minix3_get_zone_size());
    8001733e:	8b0ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017342:	87aa                	mv	a5,a0
    80017344:	2781                	sext.w	a5,a5
    80017346:	863e                	mv	a2,a5
    80017348:	4581                	li	a1,0
    8001734a:	f7043503          	ld	a0,-144(s0)
    8001734e:	7dd050ef          	jal	ra,8001d32a <memset>
                minix3_get_zone(zone, zone_data);
    80017352:	f2442783          	lw	a5,-220(s0)
    80017356:	f7043583          	ld	a1,-144(s0)
    8001735a:	853e                	mv	a0,a5
    8001735c:	b23fe0ef          	jal	ra,80015e7e <minix3_get_zone>

                // If the cursor is past the amount of data we want, we're done
                if (buffer_cursor + minix3_get_zone_size() > count) {
    80017360:	88eff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017364:	87aa                	mv	a5,a0
    80017366:	2781                	sext.w	a5,a5
    80017368:	f8442703          	lw	a4,-124(s0)
    8001736c:	9fb9                	addw	a5,a5,a4
    8001736e:	0007871b          	sext.w	a4,a5
    80017372:	e5c42783          	lw	a5,-420(s0)
    80017376:	2781                	sext.w	a5,a5
    80017378:	02e7f963          	bgeu	a5,a4,800173aa <minix3_get_data+0x7ee>
                    // Copy the remaining data into the buffer
                    memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    8001737c:	f8446783          	lwu	a5,-124(s0)
    80017380:	e6043703          	ld	a4,-416(s0)
    80017384:	00f706b3          	add	a3,a4,a5
    80017388:	e5c42703          	lw	a4,-420(s0)
    8001738c:	f8442783          	lw	a5,-124(s0)
    80017390:	40f707bb          	subw	a5,a4,a5
    80017394:	2781                	sext.w	a5,a5
    80017396:	2781                	sext.w	a5,a5
    80017398:	863e                	mv	a2,a5
    8001739a:	f7043583          	ld	a1,-144(s0)
    8001739e:	8536                	mv	a0,a3
    800173a0:	08c060ef          	jal	ra,8001d42c <memcpy>
    800173a4:	8126                	mv	sp,s1
    800173a6:	814e                	mv	sp,s3
    800173a8:	a9c9                	j	8001787a <minix3_get_data+0xcbe>
                    // We're done
                    return;
                } else {
                    // Copy the entire zone into the buffer
                    memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size());
    800173aa:	f8446783          	lwu	a5,-124(s0)
    800173ae:	e6043703          	ld	a4,-416(s0)
    800173b2:	00f70933          	add	s2,a4,a5
    800173b6:	838ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800173ba:	87aa                	mv	a5,a0
    800173bc:	2781                	sext.w	a5,a5
    800173be:	863e                	mv	a2,a5
    800173c0:	f7043583          	ld	a1,-144(s0)
    800173c4:	854a                	mv	a0,s2
    800173c6:	066060ef          	jal	ra,8001d42c <memcpy>
                }
                buffer_cursor += minix3_get_zone_size();
    800173ca:	824ff0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800173ce:	87aa                	mv	a5,a0
    800173d0:	2781                	sext.w	a5,a5
    800173d2:	f8442703          	lw	a4,-124(s0)
    800173d6:	9fb9                	addw	a5,a5,a4
    800173d8:	f8f42223          	sw	a5,-124(s0)
    800173dc:	a011                	j	800173e0 <minix3_get_data+0x824>
                if (zone == 0) continue;
    800173de:	0001                	nop
            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    800173e0:	f8344783          	lbu	a5,-125(s0)
    800173e4:	2785                	addiw	a5,a5,1
    800173e6:	f8f401a3          	sb	a5,-125(s0)
    800173ea:	f8344783          	lbu	a5,-125(s0)
    800173ee:	03079913          	slli	s2,a5,0x30
    800173f2:	03095913          	srli	s2,s2,0x30
    800173f6:	ff9fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800173fa:	87aa                	mv	a5,a0
    800173fc:	0027d79b          	srliw	a5,a5,0x2
    80017400:	17c2                	slli	a5,a5,0x30
    80017402:	93c1                	srli	a5,a5,0x30
    80017404:	0009071b          	sext.w	a4,s2
    80017408:	2781                	sext.w	a5,a5
    8001740a:	e2f768e3          	bltu	a4,a5,8001723a <minix3_get_data+0x67e>
    8001740e:	8126                	mv	sp,s1
        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    80017410:	f8f44783          	lbu	a5,-113(s0)
    80017414:	2785                	addiw	a5,a5,1
    80017416:	f8f407a3          	sb	a5,-113(s0)
    8001741a:	f8f44783          	lbu	a5,-113(s0)
    8001741e:	03079493          	slli	s1,a5,0x30
    80017422:	90c1                	srli	s1,s1,0x30
    80017424:	fcbfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017428:	87aa                	mv	a5,a0
    8001742a:	0027d79b          	srliw	a5,a5,0x2
    8001742e:	17c2                	slli	a5,a5,0x30
    80017430:	93c1                	srli	a5,a5,0x30
    80017432:	0004871b          	sext.w	a4,s1
    80017436:	2781                	sext.w	a5,a5
    80017438:	d4f767e3          	bltu	a4,a5,80017186 <minix3_get_data+0x5ca>
    8001743c:	814e                	mv	sp,s3
    } else {
        debugf("No double indirect zone\n");
    }

    // The next zone is a triple indirect zone
    if (inode_data.zones[9] != 0) {
    8001743e:	eb442783          	lw	a5,-332(s0)
    80017442:	42078b63          	beqz	a5,80017878 <minix3_get_data+0xcbc>
    80017446:	878a                	mv	a5,sp
    80017448:	8a3e                	mv	s4,a5
        uint32_t triple_indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    8001744a:	fa5fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001744e:	87aa                	mv	a5,a0
    80017450:	0027d79b          	srliw	a5,a5,0x2
    80017454:	17c2                	slli	a5,a5,0x30
    80017456:	93c1                	srli	a5,a5,0x30
    80017458:	873e                	mv	a4,a5
    8001745a:	177d                	addi	a4,a4,-1
    8001745c:	f0e43823          	sd	a4,-240(s0)
    80017460:	dcf43023          	sd	a5,-576(s0)
    80017464:	dc043423          	sd	zero,-568(s0)
    80017468:	dc043703          	ld	a4,-576(s0)
    8001746c:	936d                	srli	a4,a4,0x3b
    8001746e:	dc843683          	ld	a3,-568(s0)
    80017472:	0696                	slli	a3,a3,0x5
    80017474:	d0d43423          	sd	a3,-760(s0)
    80017478:	d0843683          	ld	a3,-760(s0)
    8001747c:	8f55                	or	a4,a4,a3
    8001747e:	d0e43423          	sd	a4,-760(s0)
    80017482:	dc043703          	ld	a4,-576(s0)
    80017486:	0716                	slli	a4,a4,0x5
    80017488:	d0e43023          	sd	a4,-768(s0)
    8001748c:	daf43823          	sd	a5,-592(s0)
    80017490:	da043c23          	sd	zero,-584(s0)
    80017494:	db043703          	ld	a4,-592(s0)
    80017498:	936d                	srli	a4,a4,0x3b
    8001749a:	db843683          	ld	a3,-584(s0)
    8001749e:	0696                	slli	a3,a3,0x5
    800174a0:	ced43c23          	sd	a3,-776(s0)
    800174a4:	cf843683          	ld	a3,-776(s0)
    800174a8:	8f55                	or	a4,a4,a3
    800174aa:	cee43c23          	sd	a4,-776(s0)
    800174ae:	db043703          	ld	a4,-592(s0)
    800174b2:	0716                	slli	a4,a4,0x5
    800174b4:	cee43823          	sd	a4,-784(s0)
    800174b8:	078a                	slli	a5,a5,0x2
    800174ba:	07bd                	addi	a5,a5,15
    800174bc:	8391                	srli	a5,a5,0x4
    800174be:	0792                	slli	a5,a5,0x4
    800174c0:	40f10133          	sub	sp,sp,a5
    800174c4:	878a                	mv	a5,sp
    800174c6:	078d                	addi	a5,a5,3
    800174c8:	8389                	srli	a5,a5,0x2
    800174ca:	078a                	slli	a5,a5,0x2
    800174cc:	f0f43423          	sd	a5,-248(s0)
        minix3_get_zone(inode_data.zones[9], (uint8_t*)triple_indirect_zones);
    800174d0:	eb442783          	lw	a5,-332(s0)
    800174d4:	f0843583          	ld	a1,-248(s0)
    800174d8:	853e                	mv	a0,a5
    800174da:	9a5fe0ef          	jal	ra,80015e7e <minix3_get_zone>

        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); triple_indirect_zone++) {
    800174de:	f8040123          	sb	zero,-126(s0)
    800174e2:	ae8d                	j	80017854 <minix3_get_data+0xc98>
    800174e4:	878a                	mv	a5,sp
    800174e6:	84be                	mv	s1,a5
            uint32_t double_indirect_zone = triple_indirect_zones[triple_indirect_zone];
    800174e8:	f8244783          	lbu	a5,-126(s0)
    800174ec:	2781                	sext.w	a5,a5
    800174ee:	f0843703          	ld	a4,-248(s0)
    800174f2:	078a                	slli	a5,a5,0x2
    800174f4:	97ba                	add	a5,a5,a4
    800174f6:	439c                	lw	a5,0(a5)
    800174f8:	f0f42223          	sw	a5,-252(s0)
            if (double_indirect_zone == 0) continue;
    800174fc:	f0442783          	lw	a5,-252(s0)
    80017500:	2781                	sext.w	a5,a5
    80017502:	e399                	bnez	a5,80017508 <minix3_get_data+0x94c>
    80017504:	8126                	mv	sp,s1
    80017506:	a691                	j	8001784a <minix3_get_data+0xc8e>
            uint32_t double_indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    80017508:	ee7fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001750c:	87aa                	mv	a5,a0
    8001750e:	0027d79b          	srliw	a5,a5,0x2
    80017512:	17c2                	slli	a5,a5,0x30
    80017514:	93c1                	srli	a5,a5,0x30
    80017516:	873e                	mv	a4,a5
    80017518:	177d                	addi	a4,a4,-1
    8001751a:	eee43c23          	sd	a4,-264(s0)
    8001751e:	daf43023          	sd	a5,-608(s0)
    80017522:	da043423          	sd	zero,-600(s0)
    80017526:	da043703          	ld	a4,-608(s0)
    8001752a:	936d                	srli	a4,a4,0x3b
    8001752c:	da843683          	ld	a3,-600(s0)
    80017530:	00569b93          	slli	s7,a3,0x5
    80017534:	01776bb3          	or	s7,a4,s7
    80017538:	da043703          	ld	a4,-608(s0)
    8001753c:	00571b13          	slli	s6,a4,0x5
    80017540:	d8f43823          	sd	a5,-624(s0)
    80017544:	d8043c23          	sd	zero,-616(s0)
    80017548:	d9043703          	ld	a4,-624(s0)
    8001754c:	936d                	srli	a4,a4,0x3b
    8001754e:	d9843683          	ld	a3,-616(s0)
    80017552:	00569c93          	slli	s9,a3,0x5
    80017556:	01976cb3          	or	s9,a4,s9
    8001755a:	d9043703          	ld	a4,-624(s0)
    8001755e:	00571c13          	slli	s8,a4,0x5
    80017562:	078a                	slli	a5,a5,0x2
    80017564:	07bd                	addi	a5,a5,15
    80017566:	8391                	srli	a5,a5,0x4
    80017568:	0792                	slli	a5,a5,0x4
    8001756a:	40f10133          	sub	sp,sp,a5
    8001756e:	878a                	mv	a5,sp
    80017570:	078d                	addi	a5,a5,3
    80017572:	8389                	srli	a5,a5,0x2
    80017574:	078a                	slli	a5,a5,0x2
    80017576:	eef43823          	sd	a5,-272(s0)
            minix3_get_zone(double_indirect_zone, (uint8_t*)double_indirect_zones);
    8001757a:	f0442783          	lw	a5,-252(s0)
    8001757e:	ef043583          	ld	a1,-272(s0)
    80017582:	853e                	mv	a0,a5
    80017584:	8fbfe0ef          	jal	ra,80015e7e <minix3_get_zone>

            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    80017588:	f80400a3          	sb	zero,-127(s0)
    8001758c:	ac61                	j	80017824 <minix3_get_data+0xc68>
    8001758e:	878a                	mv	a5,sp
    80017590:	893e                	mv	s2,a5
                uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80017592:	f8144783          	lbu	a5,-127(s0)
    80017596:	2781                	sext.w	a5,a5
    80017598:	ef043703          	ld	a4,-272(s0)
    8001759c:	078a                	slli	a5,a5,0x2
    8001759e:	97ba                	add	a5,a5,a4
    800175a0:	439c                	lw	a5,0(a5)
    800175a2:	eef42623          	sw	a5,-276(s0)
                if (indirect_zone == 0) continue;
    800175a6:	eec42783          	lw	a5,-276(s0)
    800175aa:	2781                	sext.w	a5,a5
    800175ac:	e399                	bnez	a5,800175b2 <minix3_get_data+0x9f6>
    800175ae:	814a                	mv	sp,s2
    800175b0:	a4ad                	j	8001781a <minix3_get_data+0xc5e>
                uint32_t indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    800175b2:	e3dfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800175b6:	87aa                	mv	a5,a0
    800175b8:	0027d79b          	srliw	a5,a5,0x2
    800175bc:	17c2                	slli	a5,a5,0x30
    800175be:	93c1                	srli	a5,a5,0x30
    800175c0:	873e                	mv	a4,a5
    800175c2:	177d                	addi	a4,a4,-1
    800175c4:	eee43023          	sd	a4,-288(s0)
    800175c8:	d8f43023          	sd	a5,-640(s0)
    800175cc:	d8043423          	sd	zero,-632(s0)
    800175d0:	d8043703          	ld	a4,-640(s0)
    800175d4:	936d                	srli	a4,a4,0x3b
    800175d6:	d8843683          	ld	a3,-632(s0)
    800175da:	00569d93          	slli	s11,a3,0x5
    800175de:	01b76db3          	or	s11,a4,s11
    800175e2:	d8043703          	ld	a4,-640(s0)
    800175e6:	00571d13          	slli	s10,a4,0x5
    800175ea:	d6f43823          	sd	a5,-656(s0)
    800175ee:	d6043c23          	sd	zero,-648(s0)
    800175f2:	d7043703          	ld	a4,-656(s0)
    800175f6:	936d                	srli	a4,a4,0x3b
    800175f8:	d7843683          	ld	a3,-648(s0)
    800175fc:	0696                	slli	a3,a3,0x5
    800175fe:	ced43423          	sd	a3,-792(s0)
    80017602:	ce843683          	ld	a3,-792(s0)
    80017606:	8f55                	or	a4,a4,a3
    80017608:	cee43423          	sd	a4,-792(s0)
    8001760c:	d7043703          	ld	a4,-656(s0)
    80017610:	0716                	slli	a4,a4,0x5
    80017612:	cee43023          	sd	a4,-800(s0)
    80017616:	078a                	slli	a5,a5,0x2
    80017618:	07bd                	addi	a5,a5,15
    8001761a:	8391                	srli	a5,a5,0x4
    8001761c:	0792                	slli	a5,a5,0x4
    8001761e:	40f10133          	sub	sp,sp,a5
    80017622:	878a                	mv	a5,sp
    80017624:	078d                	addi	a5,a5,3
    80017626:	8389                	srli	a5,a5,0x2
    80017628:	078a                	slli	a5,a5,0x2
    8001762a:	ecf43c23          	sd	a5,-296(s0)
                minix3_get_zone(indirect_zone, (uint8_t*)indirect_zones);
    8001762e:	eec42783          	lw	a5,-276(s0)
    80017632:	ed843583          	ld	a1,-296(s0)
    80017636:	853e                	mv	a0,a5
    80017638:	847fe0ef          	jal	ra,80015e7e <minix3_get_zone>

                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    8001763c:	f8040023          	sb	zero,-128(s0)
    80017640:	aa55                	j	800177f4 <minix3_get_data+0xc38>
                    uint32_t zone = indirect_zones[indirect_zone];
    80017642:	f8044783          	lbu	a5,-128(s0)
    80017646:	2781                	sext.w	a5,a5
    80017648:	ed843703          	ld	a4,-296(s0)
    8001764c:	078a                	slli	a5,a5,0x2
    8001764e:	97ba                	add	a5,a5,a4
    80017650:	439c                	lw	a5,0(a5)
    80017652:	ecf42a23          	sw	a5,-300(s0)
                    if (zone == 0) continue;
    80017656:	ed442783          	lw	a5,-300(s0)
    8001765a:	2781                	sext.w	a5,a5
    8001765c:	18078663          	beqz	a5,800177e8 <minix3_get_data+0xc2c>
                    debugf("Reading triple indirect zone %d\n", zone);
                    
                    if (file_cursor + minix3_get_zone_size() < offset) {
    80017660:	d8ffe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017664:	87aa                	mv	a5,a0
    80017666:	2781                	sext.w	a5,a5
    80017668:	f8842703          	lw	a4,-120(s0)
    8001766c:	9fb9                	addw	a5,a5,a4
    8001766e:	0007871b          	sext.w	a4,a5
    80017672:	e6842783          	lw	a5,-408(s0)
    80017676:	2781                	sext.w	a5,a5
    80017678:	00f77c63          	bgeu	a4,a5,80017690 <minix3_get_data+0xad4>
                        // We're not at the offset yet
                        file_cursor += minix3_get_zone_size();
    8001767c:	d73fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017680:	87aa                	mv	a5,a0
    80017682:	2781                	sext.w	a5,a5
    80017684:	f8842703          	lw	a4,-120(s0)
    80017688:	9fb9                	addw	a5,a5,a4
    8001768a:	f8f42423          	sw	a5,-120(s0)
                        continue;
    8001768e:	aab1                	j	800177ea <minix3_get_data+0xc2e>
                    } else if (file_cursor < offset) {
    80017690:	f8842703          	lw	a4,-120(s0)
    80017694:	e6842783          	lw	a5,-408(s0)
    80017698:	2701                	sext.w	a4,a4
    8001769a:	2781                	sext.w	a5,a5
    8001769c:	0af77563          	bgeu	a4,a5,80017746 <minix3_get_data+0xb8a>
                        // We're in the middle of the offset
                        // Read the zone into the buffer
                        minix3_get_zone(zone, zone_data);
    800176a0:	ed442783          	lw	a5,-300(s0)
    800176a4:	f7043583          	ld	a1,-144(s0)
    800176a8:	853e                	mv	a0,a5
    800176aa:	fd4fe0ef          	jal	ra,80015e7e <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    800176ae:	d41fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800176b2:	87aa                	mv	a5,a0
    800176b4:	0007871b          	sext.w	a4,a5
    800176b8:	f8842683          	lw	a3,-120(s0)
    800176bc:	e6842783          	lw	a5,-408(s0)
    800176c0:	40f687bb          	subw	a5,a3,a5
    800176c4:	2781                	sext.w	a5,a5
    800176c6:	9fb9                	addw	a5,a5,a4
    800176c8:	0007871b          	sext.w	a4,a5
    800176cc:	e5c42783          	lw	a5,-420(s0)
    800176d0:	2781                	sext.w	a5,a5
    800176d2:	02e7e363          	bltu	a5,a4,800176f8 <minix3_get_data+0xb3c>
    800176d6:	d19fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800176da:	87aa                	mv	a5,a0
    800176dc:	0007871b          	sext.w	a4,a5
    800176e0:	f8842683          	lw	a3,-120(s0)
    800176e4:	e6842783          	lw	a5,-408(s0)
    800176e8:	40f687bb          	subw	a5,a3,a5
    800176ec:	2781                	sext.w	a5,a5
    800176ee:	9fb9                	addw	a5,a5,a4
    800176f0:	2781                	sext.w	a5,a5
    800176f2:	1782                	slli	a5,a5,0x20
    800176f4:	9381                	srli	a5,a5,0x20
    800176f6:	a019                	j	800176fc <minix3_get_data+0xb40>
    800176f8:	e5c46783          	lwu	a5,-420(s0)
    800176fc:	ecf43423          	sd	a5,-312(s0)
                        memcpy(data, zone_data + offset - file_cursor, remaining);
    80017700:	e6846703          	lwu	a4,-408(s0)
    80017704:	f8846783          	lwu	a5,-120(s0)
    80017708:	40f707b3          	sub	a5,a4,a5
    8001770c:	f7043703          	ld	a4,-144(s0)
    80017710:	97ba                	add	a5,a5,a4
    80017712:	ec843703          	ld	a4,-312(s0)
    80017716:	2701                	sext.w	a4,a4
    80017718:	863a                	mv	a2,a4
    8001771a:	85be                	mv	a1,a5
    8001771c:	e6043503          	ld	a0,-416(s0)
    80017720:	50d050ef          	jal	ra,8001d42c <memcpy>
                        buffer_cursor += remaining;
    80017724:	ec843783          	ld	a5,-312(s0)
    80017728:	2781                	sext.w	a5,a5
    8001772a:	f8442703          	lw	a4,-124(s0)
    8001772e:	9fb9                	addw	a5,a5,a4
    80017730:	f8f42223          	sw	a5,-124(s0)
                        file_cursor = offset + remaining;
    80017734:	ec843783          	ld	a5,-312(s0)
    80017738:	2781                	sext.w	a5,a5
    8001773a:	e6842703          	lw	a4,-408(s0)
    8001773e:	9fb9                	addw	a5,a5,a4
    80017740:	f8f42423          	sw	a5,-120(s0)
                        continue;
    80017744:	a05d                	j	800177ea <minix3_get_data+0xc2e>
                    }
                
                    
                    // Read the zone into the buffer
                    memset(zone_data, 0, minix3_get_zone_size());
    80017746:	ca9fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001774a:	87aa                	mv	a5,a0
    8001774c:	2781                	sext.w	a5,a5
    8001774e:	863e                	mv	a2,a5
    80017750:	4581                	li	a1,0
    80017752:	f7043503          	ld	a0,-144(s0)
    80017756:	3d5050ef          	jal	ra,8001d32a <memset>
                    minix3_get_zone(zone, zone_data);
    8001775a:	ed442783          	lw	a5,-300(s0)
    8001775e:	f7043583          	ld	a1,-144(s0)
    80017762:	853e                	mv	a0,a5
    80017764:	f1afe0ef          	jal	ra,80015e7e <minix3_get_zone>

                    // If the cursor is past the amount of data we want, we're done
                    if (buffer_cursor + minix3_get_zone_size() > count) {
    80017768:	c87fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001776c:	87aa                	mv	a5,a0
    8001776e:	2781                	sext.w	a5,a5
    80017770:	f8442703          	lw	a4,-124(s0)
    80017774:	9fb9                	addw	a5,a5,a4
    80017776:	0007871b          	sext.w	a4,a5
    8001777a:	e5c42783          	lw	a5,-420(s0)
    8001777e:	2781                	sext.w	a5,a5
    80017780:	02e7fa63          	bgeu	a5,a4,800177b4 <minix3_get_data+0xbf8>
                        // Copy the remaining data into the buffer
                        memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    80017784:	f8446783          	lwu	a5,-124(s0)
    80017788:	e6043703          	ld	a4,-416(s0)
    8001778c:	00f706b3          	add	a3,a4,a5
    80017790:	e5c42703          	lw	a4,-420(s0)
    80017794:	f8442783          	lw	a5,-124(s0)
    80017798:	40f707bb          	subw	a5,a4,a5
    8001779c:	2781                	sext.w	a5,a5
    8001779e:	2781                	sext.w	a5,a5
    800177a0:	863e                	mv	a2,a5
    800177a2:	f7043583          	ld	a1,-144(s0)
    800177a6:	8536                	mv	a0,a3
    800177a8:	485050ef          	jal	ra,8001d42c <memcpy>
    800177ac:	814a                	mv	sp,s2
    800177ae:	8126                	mv	sp,s1
    800177b0:	8152                	mv	sp,s4
    800177b2:	a0e1                	j	8001787a <minix3_get_data+0xcbe>
                        // We're done
                        return;
                    } else {
                        // Copy the entire zone into the buffer
                        memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size());
    800177b4:	f8446783          	lwu	a5,-124(s0)
    800177b8:	e6043703          	ld	a4,-416(s0)
    800177bc:	00f709b3          	add	s3,a4,a5
    800177c0:	c2ffe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800177c4:	87aa                	mv	a5,a0
    800177c6:	2781                	sext.w	a5,a5
    800177c8:	863e                	mv	a2,a5
    800177ca:	f7043583          	ld	a1,-144(s0)
    800177ce:	854e                	mv	a0,s3
    800177d0:	45d050ef          	jal	ra,8001d42c <memcpy>
                    }
                    buffer_cursor += minix3_get_zone_size();
    800177d4:	c1bfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800177d8:	87aa                	mv	a5,a0
    800177da:	2781                	sext.w	a5,a5
    800177dc:	f8442703          	lw	a4,-124(s0)
    800177e0:	9fb9                	addw	a5,a5,a4
    800177e2:	f8f42223          	sw	a5,-124(s0)
    800177e6:	a011                	j	800177ea <minix3_get_data+0xc2e>
                    if (zone == 0) continue;
    800177e8:	0001                	nop
                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    800177ea:	f8044783          	lbu	a5,-128(s0)
    800177ee:	2785                	addiw	a5,a5,1
    800177f0:	f8f40023          	sb	a5,-128(s0)
    800177f4:	f8044783          	lbu	a5,-128(s0)
    800177f8:	03079993          	slli	s3,a5,0x30
    800177fc:	0309d993          	srli	s3,s3,0x30
    80017800:	beffe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017804:	87aa                	mv	a5,a0
    80017806:	0027d79b          	srliw	a5,a5,0x2
    8001780a:	17c2                	slli	a5,a5,0x30
    8001780c:	93c1                	srli	a5,a5,0x30
    8001780e:	0009871b          	sext.w	a4,s3
    80017812:	2781                	sext.w	a5,a5
    80017814:	e2f767e3          	bltu	a4,a5,80017642 <minix3_get_data+0xa86>
    80017818:	814a                	mv	sp,s2
            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    8001781a:	f8144783          	lbu	a5,-127(s0)
    8001781e:	2785                	addiw	a5,a5,1
    80017820:	f8f400a3          	sb	a5,-127(s0)
    80017824:	f8144783          	lbu	a5,-127(s0)
    80017828:	03079913          	slli	s2,a5,0x30
    8001782c:	03095913          	srli	s2,s2,0x30
    80017830:	bbffe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017834:	87aa                	mv	a5,a0
    80017836:	0027d79b          	srliw	a5,a5,0x2
    8001783a:	17c2                	slli	a5,a5,0x30
    8001783c:	93c1                	srli	a5,a5,0x30
    8001783e:	0009071b          	sext.w	a4,s2
    80017842:	2781                	sext.w	a5,a5
    80017844:	d4f765e3          	bltu	a4,a5,8001758e <minix3_get_data+0x9d2>
    80017848:	8126                	mv	sp,s1
        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); triple_indirect_zone++) {
    8001784a:	f8244783          	lbu	a5,-126(s0)
    8001784e:	2785                	addiw	a5,a5,1
    80017850:	f8f40123          	sb	a5,-126(s0)
    80017854:	f8244783          	lbu	a5,-126(s0)
    80017858:	03079493          	slli	s1,a5,0x30
    8001785c:	90c1                	srli	s1,s1,0x30
    8001785e:	b91fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017862:	87aa                	mv	a5,a0
    80017864:	0027d79b          	srliw	a5,a5,0x2
    80017868:	17c2                	slli	a5,a5,0x30
    8001786a:	93c1                	srli	a5,a5,0x30
    8001786c:	0004871b          	sext.w	a4,s1
    80017870:	2781                	sext.w	a5,a5
    80017872:	c6f769e3          	bltu	a4,a5,800174e4 <minix3_get_data+0x928>
    80017876:	8152                	mv	sp,s4
    } else {
        debugf("No triple indirect zone\n");
    }

    // If we get here, we've read all the data we can
    return;
    80017878:	0001                	nop
    8001787a:	e5043103          	ld	sp,-432(s0)
}
    8001787e:	ce040113          	addi	sp,s0,-800
    80017882:	31813083          	ld	ra,792(sp)
    80017886:	31013403          	ld	s0,784(sp)
    8001788a:	30813483          	ld	s1,776(sp)
    8001788e:	30013903          	ld	s2,768(sp)
    80017892:	2f813983          	ld	s3,760(sp)
    80017896:	2f013a03          	ld	s4,752(sp)
    8001789a:	2e813a83          	ld	s5,744(sp)
    8001789e:	2e013b03          	ld	s6,736(sp)
    800178a2:	2d813b83          	ld	s7,728(sp)
    800178a6:	2d013c03          	ld	s8,720(sp)
    800178aa:	2c813c83          	ld	s9,712(sp)
    800178ae:	2c013d03          	ld	s10,704(sp)
    800178b2:	2b813d83          	ld	s11,696(sp)
    800178b6:	32010113          	addi	sp,sp,800
    800178ba:	8082                	ret

00000000800178bc <minix3_put_data>:
void minix3_put_data(uint32_t inode, uint8_t *data, uint32_t offset, uint32_t count) {
    800178bc:	ce010113          	addi	sp,sp,-800
    800178c0:	30113c23          	sd	ra,792(sp)
    800178c4:	30813823          	sd	s0,784(sp)
    800178c8:	30913423          	sd	s1,776(sp)
    800178cc:	31213023          	sd	s2,768(sp)
    800178d0:	2f313c23          	sd	s3,760(sp)
    800178d4:	2f413823          	sd	s4,752(sp)
    800178d8:	2f513423          	sd	s5,744(sp)
    800178dc:	2f613023          	sd	s6,736(sp)
    800178e0:	2d713c23          	sd	s7,728(sp)
    800178e4:	2d813823          	sd	s8,720(sp)
    800178e8:	2d913423          	sd	s9,712(sp)
    800178ec:	2da13023          	sd	s10,704(sp)
    800178f0:	2bb13c23          	sd	s11,696(sp)
    800178f4:	1600                	addi	s0,sp,800
    800178f6:	87aa                	mv	a5,a0
    800178f8:	e6b43023          	sd	a1,-416(s0)
    800178fc:	8736                	mv	a4,a3
    800178fe:	e6f42623          	sw	a5,-404(s0)
    80017902:	87b2                	mv	a5,a2
    80017904:	e6f42423          	sw	a5,-408(s0)
    80017908:	87ba                	mv	a5,a4
    8001790a:	e4f42e23          	sw	a5,-420(s0)
    8001790e:	878a                	mv	a5,sp
    80017910:	e4f43823          	sd	a5,-432(s0)
    // First, get the inode
    Inode inode_data = minix3_get_inode(inode);
    80017914:	e7840793          	addi	a5,s0,-392
    80017918:	e6c42703          	lw	a4,-404(s0)
    8001791c:	85ba                	mv	a1,a4
    8001791e:	853e                	mv	a0,a5
    80017920:	f0bfe0ef          	jal	ra,8001682a <minix3_get_inode>

    uint8_t zone_data[minix3_get_zone_size()];
    80017924:	acbfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017928:	87aa                	mv	a5,a0
    8001792a:	873e                	mv	a4,a5
    8001792c:	87ba                	mv	a5,a4
    8001792e:	17fd                	addi	a5,a5,-1
    80017930:	f6f43c23          	sd	a5,-136(s0)
    80017934:	e4e43023          	sd	a4,-448(s0)
    80017938:	e4043423          	sd	zero,-440(s0)
    8001793c:	e4043783          	ld	a5,-448(s0)
    80017940:	93f5                	srli	a5,a5,0x3d
    80017942:	e4843683          	ld	a3,-440(s0)
    80017946:	068e                	slli	a3,a3,0x3
    80017948:	d6d43423          	sd	a3,-664(s0)
    8001794c:	d6843683          	ld	a3,-664(s0)
    80017950:	8fd5                	or	a5,a5,a3
    80017952:	d6f43423          	sd	a5,-664(s0)
    80017956:	e4043783          	ld	a5,-448(s0)
    8001795a:	078e                	slli	a5,a5,0x3
    8001795c:	d6f43023          	sd	a5,-672(s0)
    80017960:	e2e43823          	sd	a4,-464(s0)
    80017964:	e2043c23          	sd	zero,-456(s0)
    80017968:	e3043783          	ld	a5,-464(s0)
    8001796c:	93f5                	srli	a5,a5,0x3d
    8001796e:	e3843683          	ld	a3,-456(s0)
    80017972:	00369993          	slli	s3,a3,0x3
    80017976:	0137e9b3          	or	s3,a5,s3
    8001797a:	e3043783          	ld	a5,-464(s0)
    8001797e:	00379913          	slli	s2,a5,0x3
    80017982:	87ba                	mv	a5,a4
    80017984:	07bd                	addi	a5,a5,15
    80017986:	8391                	srli	a5,a5,0x4
    80017988:	0792                	slli	a5,a5,0x4
    8001798a:	40f10133          	sub	sp,sp,a5
    8001798e:	878a                	mv	a5,sp
    80017990:	00078793          	mv	a5,a5
    80017994:	f6f43823          	sd	a5,-144(s0)

    // The cursor is the current position in the data buffer
    uint32_t buffer_cursor = 0;
    80017998:	f8042223          	sw	zero,-124(s0)
    // The file cursor is the current position in the file
    uint32_t file_cursor = 0;
    8001799c:	f8042423          	sw	zero,-120(s0)

    // Now, get the data
    // The first 7 zones are direct zones
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    800179a0:	f80406a3          	sb	zero,-115(s0)
    800179a4:	aad5                	j	80017b98 <minix3_put_data+0x2dc>
        uint32_t zone = inode_data.zones[direct_zone];
    800179a6:	f8d44783          	lbu	a5,-115(s0)
    800179aa:	2781                	sext.w	a5,a5
    800179ac:	0791                	addi	a5,a5,4
    800179ae:	078a                	slli	a5,a5,0x2
    800179b0:	f9040713          	addi	a4,s0,-112
    800179b4:	97ba                	add	a5,a5,a4
    800179b6:	ef07a783          	lw	a5,-272(a5)
    800179ba:	ecf42223          	sw	a5,-316(s0)
        if (zone == 0) {
    800179be:	ec442783          	lw	a5,-316(s0)
    800179c2:	2781                	sext.w	a5,a5
    800179c4:	1c078263          	beqz	a5,80017b88 <minix3_put_data+0x2cc>
            debugf("No direct zone %d\n", zone);
            continue;
        }
        if (file_cursor + minix3_get_zone_size() < offset) {
    800179c8:	a27fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800179cc:	87aa                	mv	a5,a0
    800179ce:	2781                	sext.w	a5,a5
    800179d0:	f8842703          	lw	a4,-120(s0)
    800179d4:	9fb9                	addw	a5,a5,a4
    800179d6:	0007871b          	sext.w	a4,a5
    800179da:	e6842783          	lw	a5,-408(s0)
    800179de:	2781                	sext.w	a5,a5
    800179e0:	00f77c63          	bgeu	a4,a5,800179f8 <minix3_put_data+0x13c>
            // We're not at the offset yet
            file_cursor += minix3_get_zone_size();
    800179e4:	a0bfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800179e8:	87aa                	mv	a5,a0
    800179ea:	2781                	sext.w	a5,a5
    800179ec:	f8842703          	lw	a4,-120(s0)
    800179f0:	9fb9                	addw	a5,a5,a4
    800179f2:	f8f42423          	sw	a5,-120(s0)
            continue;
    800179f6:	aa61                	j	80017b8e <minix3_put_data+0x2d2>
        } else if (file_cursor < offset) {
    800179f8:	f8842703          	lw	a4,-120(s0)
    800179fc:	e6842783          	lw	a5,-408(s0)
    80017a00:	2701                	sext.w	a4,a4
    80017a02:	2781                	sext.w	a5,a5
    80017a04:	0cf77563          	bgeu	a4,a5,80017ace <minix3_put_data+0x212>
            // We're in the middle of the offset
            // Read the zone into the buffer
            debugf("Writing first direct zone %d\n", zone);
            minix3_get_zone(zone, zone_data);
    80017a08:	ec442783          	lw	a5,-316(s0)
    80017a0c:	f7043583          	ld	a1,-144(s0)
    80017a10:	853e                	mv	a0,a5
    80017a12:	c6cfe0ef          	jal	ra,80015e7e <minix3_get_zone>

            // Copy the remaining data into the buffer
            size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    80017a16:	9d9fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017a1a:	87aa                	mv	a5,a0
    80017a1c:	0007871b          	sext.w	a4,a5
    80017a20:	f8842683          	lw	a3,-120(s0)
    80017a24:	e6842783          	lw	a5,-408(s0)
    80017a28:	40f687bb          	subw	a5,a3,a5
    80017a2c:	2781                	sext.w	a5,a5
    80017a2e:	9fb9                	addw	a5,a5,a4
    80017a30:	0007871b          	sext.w	a4,a5
    80017a34:	e5c42783          	lw	a5,-420(s0)
    80017a38:	2781                	sext.w	a5,a5
    80017a3a:	02e7e363          	bltu	a5,a4,80017a60 <minix3_put_data+0x1a4>
    80017a3e:	9b1fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017a42:	87aa                	mv	a5,a0
    80017a44:	0007871b          	sext.w	a4,a5
    80017a48:	f8842683          	lw	a3,-120(s0)
    80017a4c:	e6842783          	lw	a5,-408(s0)
    80017a50:	40f687bb          	subw	a5,a3,a5
    80017a54:	2781                	sext.w	a5,a5
    80017a56:	9fb9                	addw	a5,a5,a4
    80017a58:	2781                	sext.w	a5,a5
    80017a5a:	1782                	slli	a5,a5,0x20
    80017a5c:	9381                	srli	a5,a5,0x20
    80017a5e:	a019                	j	80017a64 <minix3_put_data+0x1a8>
    80017a60:	e5c46783          	lwu	a5,-420(s0)
    80017a64:	eaf43c23          	sd	a5,-328(s0)
            memcpy(zone_data + offset - file_cursor, data, remaining);
    80017a68:	e6846703          	lwu	a4,-408(s0)
    80017a6c:	f8846783          	lwu	a5,-120(s0)
    80017a70:	40f707b3          	sub	a5,a4,a5
    80017a74:	f7043703          	ld	a4,-144(s0)
    80017a78:	97ba                	add	a5,a5,a4
    80017a7a:	eb843703          	ld	a4,-328(s0)
    80017a7e:	2701                	sext.w	a4,a4
    80017a80:	863a                	mv	a2,a4
    80017a82:	e6043583          	ld	a1,-416(s0)
    80017a86:	853e                	mv	a0,a5
    80017a88:	1a5050ef          	jal	ra,8001d42c <memcpy>
            minix3_put_zone(zone, zone_data);
    80017a8c:	ec442783          	lw	a5,-316(s0)
    80017a90:	f7043583          	ld	a1,-144(s0)
    80017a94:	853e                	mv	a0,a5
    80017a96:	c88fe0ef          	jal	ra,80015f1e <minix3_put_zone>

            buffer_cursor += remaining;
    80017a9a:	eb843783          	ld	a5,-328(s0)
    80017a9e:	2781                	sext.w	a5,a5
    80017aa0:	f8442703          	lw	a4,-124(s0)
    80017aa4:	9fb9                	addw	a5,a5,a4
    80017aa6:	f8f42223          	sw	a5,-124(s0)
            file_cursor = offset + remaining;
    80017aaa:	eb843783          	ld	a5,-328(s0)
    80017aae:	2781                	sext.w	a5,a5
    80017ab0:	e6842703          	lw	a4,-408(s0)
    80017ab4:	9fb9                	addw	a5,a5,a4
    80017ab6:	f8f42423          	sw	a5,-120(s0)
            if (buffer_cursor >= count) {
    80017aba:	f8442703          	lw	a4,-124(s0)
    80017abe:	e5c42783          	lw	a5,-420(s0)
    80017ac2:	2701                	sext.w	a4,a4
    80017ac4:	2781                	sext.w	a5,a5
    80017ac6:	0cf76363          	bltu	a4,a5,80017b8c <minix3_put_data+0x2d0>
                // We're done
                return;
    80017aca:	3b70006f          	j	80018680 <minix3_put_data+0xdc4>
            }

            continue;
        }

        memset(zone_data, 0, minix3_get_zone_size());
    80017ace:	921fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017ad2:	87aa                	mv	a5,a0
    80017ad4:	2781                	sext.w	a5,a5
    80017ad6:	863e                	mv	a2,a5
    80017ad8:	4581                	li	a1,0
    80017ada:	f7043503          	ld	a0,-144(s0)
    80017ade:	04d050ef          	jal	ra,8001d32a <memset>

        // Write the buffer into the zone
        if (buffer_cursor + minix3_get_zone_size() > count) {
    80017ae2:	90dfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017ae6:	87aa                	mv	a5,a0
    80017ae8:	2781                	sext.w	a5,a5
    80017aea:	f8442703          	lw	a4,-124(s0)
    80017aee:	9fb9                	addw	a5,a5,a4
    80017af0:	0007871b          	sext.w	a4,a5
    80017af4:	e5c42783          	lw	a5,-420(s0)
    80017af8:	2781                	sext.w	a5,a5
    80017afa:	04e7f663          	bgeu	a5,a4,80017b46 <minix3_put_data+0x28a>
            minix3_get_zone(zone, zone_data);
    80017afe:	ec442783          	lw	a5,-316(s0)
    80017b02:	f7043583          	ld	a1,-144(s0)
    80017b06:	853e                	mv	a0,a5
    80017b08:	b76fe0ef          	jal	ra,80015e7e <minix3_get_zone>
            debugf("Writing last direct zone %d\n", zone);
            // Copy the remaining data into the buffer
            memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    80017b0c:	f8446783          	lwu	a5,-124(s0)
    80017b10:	e6043703          	ld	a4,-416(s0)
    80017b14:	00f706b3          	add	a3,a4,a5
    80017b18:	e5c42703          	lw	a4,-420(s0)
    80017b1c:	f8442783          	lw	a5,-124(s0)
    80017b20:	40f707bb          	subw	a5,a4,a5
    80017b24:	2781                	sext.w	a5,a5
    80017b26:	2781                	sext.w	a5,a5
    80017b28:	863e                	mv	a2,a5
    80017b2a:	85b6                	mv	a1,a3
    80017b2c:	f7043503          	ld	a0,-144(s0)
    80017b30:	0fd050ef          	jal	ra,8001d42c <memcpy>
            // We're done
            minix3_put_zone(zone, zone_data);
    80017b34:	ec442783          	lw	a5,-316(s0)
    80017b38:	f7043583          	ld	a1,-144(s0)
    80017b3c:	853e                	mv	a0,a5
    80017b3e:	be0fe0ef          	jal	ra,80015f1e <minix3_put_zone>
            return;
    80017b42:	33f0006f          	j	80018680 <minix3_put_data+0xdc4>
        } else {
            debugf("Writing direct zone %d\n", zone);
            // Copy the entire zone into the buffer
            memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size());
    80017b46:	f8446783          	lwu	a5,-124(s0)
    80017b4a:	e6043703          	ld	a4,-416(s0)
    80017b4e:	00f704b3          	add	s1,a4,a5
    80017b52:	89dfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017b56:	87aa                	mv	a5,a0
    80017b58:	2781                	sext.w	a5,a5
    80017b5a:	863e                	mv	a2,a5
    80017b5c:	85a6                	mv	a1,s1
    80017b5e:	f7043503          	ld	a0,-144(s0)
    80017b62:	0cb050ef          	jal	ra,8001d42c <memcpy>
            minix3_put_zone(zone, zone_data);
    80017b66:	ec442783          	lw	a5,-316(s0)
    80017b6a:	f7043583          	ld	a1,-144(s0)
    80017b6e:	853e                	mv	a0,a5
    80017b70:	baefe0ef          	jal	ra,80015f1e <minix3_put_zone>
        }
        buffer_cursor += minix3_get_zone_size();
    80017b74:	87bfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017b78:	87aa                	mv	a5,a0
    80017b7a:	2781                	sext.w	a5,a5
    80017b7c:	f8442703          	lw	a4,-124(s0)
    80017b80:	9fb9                	addw	a5,a5,a4
    80017b82:	f8f42223          	sw	a5,-124(s0)
    80017b86:	a021                	j	80017b8e <minix3_put_data+0x2d2>
            continue;
    80017b88:	0001                	nop
    80017b8a:	a011                	j	80017b8e <minix3_put_data+0x2d2>
            continue;
    80017b8c:	0001                	nop
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80017b8e:	f8d44783          	lbu	a5,-115(s0)
    80017b92:	2785                	addiw	a5,a5,1
    80017b94:	f8f406a3          	sb	a5,-115(s0)
    80017b98:	f8d44783          	lbu	a5,-115(s0)
    80017b9c:	0ff7f713          	andi	a4,a5,255
    80017ba0:	4799                	li	a5,6
    80017ba2:	e0e7f2e3          	bgeu	a5,a4,800179a6 <minix3_put_data+0xea>
    }

    debugf("Done with direct zones\n");
    // The next zone is an indirect zone
    if (inode_data.zones[7] != 0) {
    80017ba6:	eac42783          	lw	a5,-340(s0)
    80017baa:	2a078c63          	beqz	a5,80017e62 <minix3_put_data+0x5a6>
    80017bae:	878a                	mv	a5,sp
    80017bb0:	893e                	mv	s2,a5
        uint32_t indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    80017bb2:	83dfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017bb6:	87aa                	mv	a5,a0
    80017bb8:	0027d79b          	srliw	a5,a5,0x2
    80017bbc:	17c2                	slli	a5,a5,0x30
    80017bbe:	93c1                	srli	a5,a5,0x30
    80017bc0:	873e                	mv	a4,a5
    80017bc2:	177d                	addi	a4,a4,-1
    80017bc4:	f6e43423          	sd	a4,-152(s0)
    80017bc8:	e2f43023          	sd	a5,-480(s0)
    80017bcc:	e2043423          	sd	zero,-472(s0)
    80017bd0:	e2043703          	ld	a4,-480(s0)
    80017bd4:	936d                	srli	a4,a4,0x3b
    80017bd6:	e2843683          	ld	a3,-472(s0)
    80017bda:	0696                	slli	a3,a3,0x5
    80017bdc:	d4d43c23          	sd	a3,-680(s0)
    80017be0:	d5843683          	ld	a3,-680(s0)
    80017be4:	8f55                	or	a4,a4,a3
    80017be6:	d4e43c23          	sd	a4,-680(s0)
    80017bea:	e2043703          	ld	a4,-480(s0)
    80017bee:	0716                	slli	a4,a4,0x5
    80017bf0:	d4e43823          	sd	a4,-688(s0)
    80017bf4:	e0f43823          	sd	a5,-496(s0)
    80017bf8:	e0043c23          	sd	zero,-488(s0)
    80017bfc:	e1043703          	ld	a4,-496(s0)
    80017c00:	936d                	srli	a4,a4,0x3b
    80017c02:	e1843683          	ld	a3,-488(s0)
    80017c06:	0696                	slli	a3,a3,0x5
    80017c08:	d4d43423          	sd	a3,-696(s0)
    80017c0c:	d4843683          	ld	a3,-696(s0)
    80017c10:	8f55                	or	a4,a4,a3
    80017c12:	d4e43423          	sd	a4,-696(s0)
    80017c16:	e1043703          	ld	a4,-496(s0)
    80017c1a:	0716                	slli	a4,a4,0x5
    80017c1c:	d4e43023          	sd	a4,-704(s0)
    80017c20:	078a                	slli	a5,a5,0x2
    80017c22:	07bd                	addi	a5,a5,15
    80017c24:	8391                	srli	a5,a5,0x4
    80017c26:	0792                	slli	a5,a5,0x4
    80017c28:	40f10133          	sub	sp,sp,a5
    80017c2c:	878a                	mv	a5,sp
    80017c2e:	078d                	addi	a5,a5,3
    80017c30:	8389                	srli	a5,a5,0x2
    80017c32:	078a                	slli	a5,a5,0x2
    80017c34:	f6f43023          	sd	a5,-160(s0)
        minix3_get_zone(inode_data.zones[7], (uint8_t*)indirect_zones);
    80017c38:	eac42783          	lw	a5,-340(s0)
    80017c3c:	f6043583          	ld	a1,-160(s0)
    80017c40:	853e                	mv	a0,a5
    80017c42:	a3cfe0ef          	jal	ra,80015e7e <minix3_get_zone>

        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    80017c46:	f8040723          	sb	zero,-114(s0)
    80017c4a:	a2f5                	j	80017e36 <minix3_put_data+0x57a>
            uint32_t zone = indirect_zones[indirect_zone];
    80017c4c:	f8e44783          	lbu	a5,-114(s0)
    80017c50:	2781                	sext.w	a5,a5
    80017c52:	f6043703          	ld	a4,-160(s0)
    80017c56:	078a                	slli	a5,a5,0x2
    80017c58:	97ba                	add	a5,a5,a4
    80017c5a:	439c                	lw	a5,0(a5)
    80017c5c:	f4f42e23          	sw	a5,-164(s0)
            if (zone == 0) continue;
    80017c60:	f5c42783          	lw	a5,-164(s0)
    80017c64:	2781                	sext.w	a5,a5
    80017c66:	1c078063          	beqz	a5,80017e26 <minix3_put_data+0x56a>
            debugf("Writing indirect zone %d\n", zone);

            if (file_cursor + minix3_get_zone_size() < offset) {
    80017c6a:	f84fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017c6e:	87aa                	mv	a5,a0
    80017c70:	2781                	sext.w	a5,a5
    80017c72:	f8842703          	lw	a4,-120(s0)
    80017c76:	9fb9                	addw	a5,a5,a4
    80017c78:	0007871b          	sext.w	a4,a5
    80017c7c:	e6842783          	lw	a5,-408(s0)
    80017c80:	2781                	sext.w	a5,a5
    80017c82:	00f77c63          	bgeu	a4,a5,80017c9a <minix3_put_data+0x3de>
                // We're not at the offset yet
                file_cursor += minix3_get_zone_size();
    80017c86:	f68fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017c8a:	87aa                	mv	a5,a0
    80017c8c:	2781                	sext.w	a5,a5
    80017c8e:	f8842703          	lw	a4,-120(s0)
    80017c92:	9fb9                	addw	a5,a5,a4
    80017c94:	f8f42423          	sw	a5,-120(s0)
                continue;
    80017c98:	aa51                	j	80017e2c <minix3_put_data+0x570>
            } else if (file_cursor < offset) {
    80017c9a:	f8842703          	lw	a4,-120(s0)
    80017c9e:	e6842783          	lw	a5,-408(s0)
    80017ca2:	2701                	sext.w	a4,a4
    80017ca4:	2781                	sext.w	a5,a5
    80017ca6:	0cf77463          	bgeu	a4,a5,80017d6e <minix3_put_data+0x4b2>
                // We're in the middle of the offset
                // Read the zone into the buffer
                minix3_get_zone(zone, zone_data);
    80017caa:	f5c42783          	lw	a5,-164(s0)
    80017cae:	f7043583          	ld	a1,-144(s0)
    80017cb2:	853e                	mv	a0,a5
    80017cb4:	9cafe0ef          	jal	ra,80015e7e <minix3_get_zone>
                // Copy the remaining data into the buffer
                size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    80017cb8:	f36fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017cbc:	87aa                	mv	a5,a0
    80017cbe:	0007871b          	sext.w	a4,a5
    80017cc2:	f8842683          	lw	a3,-120(s0)
    80017cc6:	e6842783          	lw	a5,-408(s0)
    80017cca:	40f687bb          	subw	a5,a3,a5
    80017cce:	2781                	sext.w	a5,a5
    80017cd0:	9fb9                	addw	a5,a5,a4
    80017cd2:	0007871b          	sext.w	a4,a5
    80017cd6:	e5c42783          	lw	a5,-420(s0)
    80017cda:	2781                	sext.w	a5,a5
    80017cdc:	02e7e363          	bltu	a5,a4,80017d02 <minix3_put_data+0x446>
    80017ce0:	f0efe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017ce4:	87aa                	mv	a5,a0
    80017ce6:	0007871b          	sext.w	a4,a5
    80017cea:	f8842683          	lw	a3,-120(s0)
    80017cee:	e6842783          	lw	a5,-408(s0)
    80017cf2:	40f687bb          	subw	a5,a3,a5
    80017cf6:	2781                	sext.w	a5,a5
    80017cf8:	9fb9                	addw	a5,a5,a4
    80017cfa:	2781                	sext.w	a5,a5
    80017cfc:	1782                	slli	a5,a5,0x20
    80017cfe:	9381                	srli	a5,a5,0x20
    80017d00:	a019                	j	80017d06 <minix3_put_data+0x44a>
    80017d02:	e5c46783          	lwu	a5,-420(s0)
    80017d06:	f4f43823          	sd	a5,-176(s0)
                memcpy(zone_data + offset - file_cursor, data, remaining);
    80017d0a:	e6846703          	lwu	a4,-408(s0)
    80017d0e:	f8846783          	lwu	a5,-120(s0)
    80017d12:	40f707b3          	sub	a5,a4,a5
    80017d16:	f7043703          	ld	a4,-144(s0)
    80017d1a:	97ba                	add	a5,a5,a4
    80017d1c:	f5043703          	ld	a4,-176(s0)
    80017d20:	2701                	sext.w	a4,a4
    80017d22:	863a                	mv	a2,a4
    80017d24:	e6043583          	ld	a1,-416(s0)
    80017d28:	853e                	mv	a0,a5
    80017d2a:	702050ef          	jal	ra,8001d42c <memcpy>
                minix3_put_zone(zone, zone_data);
    80017d2e:	f5c42783          	lw	a5,-164(s0)
    80017d32:	f7043583          	ld	a1,-144(s0)
    80017d36:	853e                	mv	a0,a5
    80017d38:	9e6fe0ef          	jal	ra,80015f1e <minix3_put_zone>

                buffer_cursor += remaining;
    80017d3c:	f5043783          	ld	a5,-176(s0)
    80017d40:	2781                	sext.w	a5,a5
    80017d42:	f8442703          	lw	a4,-124(s0)
    80017d46:	9fb9                	addw	a5,a5,a4
    80017d48:	f8f42223          	sw	a5,-124(s0)
                file_cursor = offset + remaining;
    80017d4c:	f5043783          	ld	a5,-176(s0)
    80017d50:	2781                	sext.w	a5,a5
    80017d52:	e6842703          	lw	a4,-408(s0)
    80017d56:	9fb9                	addw	a5,a5,a4
    80017d58:	f8f42423          	sw	a5,-120(s0)
                if (buffer_cursor >= count) {
    80017d5c:	f8442703          	lw	a4,-124(s0)
    80017d60:	e5c42783          	lw	a5,-420(s0)
    80017d64:	2701                	sext.w	a4,a4
    80017d66:	2781                	sext.w	a5,a5
    80017d68:	0cf76163          	bltu	a4,a5,80017e2a <minix3_put_data+0x56e>
                    // We're done
                    return;
    80017d6c:	a8c5                	j	80017e5c <minix3_put_data+0x5a0>
                }
                continue;
            }

            memset(zone_data, 0, minix3_get_zone_size());
    80017d6e:	e80fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017d72:	87aa                	mv	a5,a0
    80017d74:	2781                	sext.w	a5,a5
    80017d76:	863e                	mv	a2,a5
    80017d78:	4581                	li	a1,0
    80017d7a:	f7043503          	ld	a0,-144(s0)
    80017d7e:	5ac050ef          	jal	ra,8001d32a <memset>

            if (buffer_cursor + minix3_get_zone_size() > count) {
    80017d82:	e6cfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017d86:	87aa                	mv	a5,a0
    80017d88:	2781                	sext.w	a5,a5
    80017d8a:	f8442703          	lw	a4,-124(s0)
    80017d8e:	9fb9                	addw	a5,a5,a4
    80017d90:	0007871b          	sext.w	a4,a5
    80017d94:	e5c42783          	lw	a5,-420(s0)
    80017d98:	2781                	sext.w	a5,a5
    80017d9a:	04e7f563          	bgeu	a5,a4,80017de4 <minix3_put_data+0x528>
                minix3_get_zone(zone, zone_data);
    80017d9e:	f5c42783          	lw	a5,-164(s0)
    80017da2:	f7043583          	ld	a1,-144(s0)
    80017da6:	853e                	mv	a0,a5
    80017da8:	8d6fe0ef          	jal	ra,80015e7e <minix3_get_zone>
                // Copy the remaining data into the buffer
                memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    80017dac:	f8446783          	lwu	a5,-124(s0)
    80017db0:	e6043703          	ld	a4,-416(s0)
    80017db4:	00f706b3          	add	a3,a4,a5
    80017db8:	e5c42703          	lw	a4,-420(s0)
    80017dbc:	f8442783          	lw	a5,-124(s0)
    80017dc0:	40f707bb          	subw	a5,a4,a5
    80017dc4:	2781                	sext.w	a5,a5
    80017dc6:	2781                	sext.w	a5,a5
    80017dc8:	863e                	mv	a2,a5
    80017dca:	85b6                	mv	a1,a3
    80017dcc:	f7043503          	ld	a0,-144(s0)
    80017dd0:	65c050ef          	jal	ra,8001d42c <memcpy>
                // We're done
                minix3_put_zone(zone, zone_data);
    80017dd4:	f5c42783          	lw	a5,-164(s0)
    80017dd8:	f7043583          	ld	a1,-144(s0)
    80017ddc:	853e                	mv	a0,a5
    80017dde:	940fe0ef          	jal	ra,80015f1e <minix3_put_zone>
                return;
    80017de2:	a8ad                	j	80017e5c <minix3_put_data+0x5a0>
            } else {
                // Copy the entire zone into the buffer
                memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size());
    80017de4:	f8446783          	lwu	a5,-124(s0)
    80017de8:	e6043703          	ld	a4,-416(s0)
    80017dec:	00f704b3          	add	s1,a4,a5
    80017df0:	dfefe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017df4:	87aa                	mv	a5,a0
    80017df6:	2781                	sext.w	a5,a5
    80017df8:	863e                	mv	a2,a5
    80017dfa:	85a6                	mv	a1,s1
    80017dfc:	f7043503          	ld	a0,-144(s0)
    80017e00:	62c050ef          	jal	ra,8001d42c <memcpy>
                minix3_put_zone(zone, zone_data);
    80017e04:	f5c42783          	lw	a5,-164(s0)
    80017e08:	f7043583          	ld	a1,-144(s0)
    80017e0c:	853e                	mv	a0,a5
    80017e0e:	910fe0ef          	jal	ra,80015f1e <minix3_put_zone>
            }
            buffer_cursor += minix3_get_zone_size();
    80017e12:	ddcfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017e16:	87aa                	mv	a5,a0
    80017e18:	2781                	sext.w	a5,a5
    80017e1a:	f8442703          	lw	a4,-124(s0)
    80017e1e:	9fb9                	addw	a5,a5,a4
    80017e20:	f8f42223          	sw	a5,-124(s0)
    80017e24:	a021                	j	80017e2c <minix3_put_data+0x570>
            if (zone == 0) continue;
    80017e26:	0001                	nop
    80017e28:	a011                	j	80017e2c <minix3_put_data+0x570>
                continue;
    80017e2a:	0001                	nop
        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    80017e2c:	f8e44783          	lbu	a5,-114(s0)
    80017e30:	2785                	addiw	a5,a5,1
    80017e32:	f8f40723          	sb	a5,-114(s0)
    80017e36:	f8e44783          	lbu	a5,-114(s0)
    80017e3a:	03079493          	slli	s1,a5,0x30
    80017e3e:	90c1                	srli	s1,s1,0x30
    80017e40:	daefe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017e44:	87aa                	mv	a5,a0
    80017e46:	0027d79b          	srliw	a5,a5,0x2
    80017e4a:	17c2                	slli	a5,a5,0x30
    80017e4c:	93c1                	srli	a5,a5,0x30
    80017e4e:	0004871b          	sext.w	a4,s1
    80017e52:	2781                	sext.w	a5,a5
    80017e54:	def76ce3          	bltu	a4,a5,80017c4c <minix3_put_data+0x390>
    80017e58:	814a                	mv	sp,s2
    80017e5a:	a021                	j	80017e62 <minix3_put_data+0x5a6>
    80017e5c:	814a                	mv	sp,s2
    80017e5e:	0230006f          	j	80018680 <minix3_put_data+0xdc4>
        debugf("No indirect zone\n");
    }

    // The next zone is a double indirect zone
    // The next zone is a double indirect zone
    if (inode_data.zones[8] != 0) {
    80017e62:	eb042783          	lw	a5,-336(s0)
    80017e66:	38078e63          	beqz	a5,80018202 <minix3_put_data+0x946>
    80017e6a:	878a                	mv	a5,sp
    80017e6c:	89be                	mv	s3,a5
        uint32_t double_indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    80017e6e:	d80fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017e72:	87aa                	mv	a5,a0
    80017e74:	0027d79b          	srliw	a5,a5,0x2
    80017e78:	17c2                	slli	a5,a5,0x30
    80017e7a:	93c1                	srli	a5,a5,0x30
    80017e7c:	873e                	mv	a4,a5
    80017e7e:	177d                	addi	a4,a4,-1
    80017e80:	f4e43423          	sd	a4,-184(s0)
    80017e84:	e0f43023          	sd	a5,-512(s0)
    80017e88:	e0043423          	sd	zero,-504(s0)
    80017e8c:	e0043703          	ld	a4,-512(s0)
    80017e90:	936d                	srli	a4,a4,0x3b
    80017e92:	e0843683          	ld	a3,-504(s0)
    80017e96:	0696                	slli	a3,a3,0x5
    80017e98:	d2d43c23          	sd	a3,-712(s0)
    80017e9c:	d3843683          	ld	a3,-712(s0)
    80017ea0:	8f55                	or	a4,a4,a3
    80017ea2:	d2e43c23          	sd	a4,-712(s0)
    80017ea6:	e0043703          	ld	a4,-512(s0)
    80017eaa:	0716                	slli	a4,a4,0x5
    80017eac:	d2e43823          	sd	a4,-720(s0)
    80017eb0:	def43823          	sd	a5,-528(s0)
    80017eb4:	de043c23          	sd	zero,-520(s0)
    80017eb8:	df043703          	ld	a4,-528(s0)
    80017ebc:	936d                	srli	a4,a4,0x3b
    80017ebe:	df843683          	ld	a3,-520(s0)
    80017ec2:	0696                	slli	a3,a3,0x5
    80017ec4:	d2d43423          	sd	a3,-728(s0)
    80017ec8:	d2843683          	ld	a3,-728(s0)
    80017ecc:	8f55                	or	a4,a4,a3
    80017ece:	d2e43423          	sd	a4,-728(s0)
    80017ed2:	df043703          	ld	a4,-528(s0)
    80017ed6:	0716                	slli	a4,a4,0x5
    80017ed8:	d2e43023          	sd	a4,-736(s0)
    80017edc:	078a                	slli	a5,a5,0x2
    80017ede:	07bd                	addi	a5,a5,15
    80017ee0:	8391                	srli	a5,a5,0x4
    80017ee2:	0792                	slli	a5,a5,0x4
    80017ee4:	40f10133          	sub	sp,sp,a5
    80017ee8:	878a                	mv	a5,sp
    80017eea:	078d                	addi	a5,a5,3
    80017eec:	8389                	srli	a5,a5,0x2
    80017eee:	078a                	slli	a5,a5,0x2
    80017ef0:	f4f43023          	sd	a5,-192(s0)
        // We're done
        minix3_get_zone(inode_data.zones[8], (uint8_t*)double_indirect_zones);
    80017ef4:	eb042783          	lw	a5,-336(s0)
    80017ef8:	f4043583          	ld	a1,-192(s0)
    80017efc:	853e                	mv	a0,a5
    80017efe:	f81fd0ef          	jal	ra,80015e7e <minix3_get_zone>

        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    80017f02:	f80407a3          	sb	zero,-113(s0)
    80017f06:	ace1                	j	800181de <minix3_put_data+0x922>
    80017f08:	878a                	mv	a5,sp
    80017f0a:	84be                	mv	s1,a5
            uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80017f0c:	f8f44783          	lbu	a5,-113(s0)
    80017f10:	2781                	sext.w	a5,a5
    80017f12:	f4043703          	ld	a4,-192(s0)
    80017f16:	078a                	slli	a5,a5,0x2
    80017f18:	97ba                	add	a5,a5,a4
    80017f1a:	439c                	lw	a5,0(a5)
    80017f1c:	f2f42e23          	sw	a5,-196(s0)
            if (indirect_zone == 0) continue;
    80017f20:	f3c42783          	lw	a5,-196(s0)
    80017f24:	2781                	sext.w	a5,a5
    80017f26:	e399                	bnez	a5,80017f2c <minix3_put_data+0x670>
    80017f28:	8126                	mv	sp,s1
    80017f2a:	a46d                	j	800181d4 <minix3_put_data+0x918>

            uint32_t indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    80017f2c:	cc2fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017f30:	87aa                	mv	a5,a0
    80017f32:	0027d79b          	srliw	a5,a5,0x2
    80017f36:	17c2                	slli	a5,a5,0x30
    80017f38:	93c1                	srli	a5,a5,0x30
    80017f3a:	873e                	mv	a4,a5
    80017f3c:	177d                	addi	a4,a4,-1
    80017f3e:	f2e43823          	sd	a4,-208(s0)
    80017f42:	def43023          	sd	a5,-544(s0)
    80017f46:	de043423          	sd	zero,-536(s0)
    80017f4a:	de043703          	ld	a4,-544(s0)
    80017f4e:	936d                	srli	a4,a4,0x3b
    80017f50:	de843683          	ld	a3,-536(s0)
    80017f54:	00569a93          	slli	s5,a3,0x5
    80017f58:	01576ab3          	or	s5,a4,s5
    80017f5c:	de043703          	ld	a4,-544(s0)
    80017f60:	00571a13          	slli	s4,a4,0x5
    80017f64:	dcf43823          	sd	a5,-560(s0)
    80017f68:	dc043c23          	sd	zero,-552(s0)
    80017f6c:	dd043703          	ld	a4,-560(s0)
    80017f70:	936d                	srli	a4,a4,0x3b
    80017f72:	dd843683          	ld	a3,-552(s0)
    80017f76:	0696                	slli	a3,a3,0x5
    80017f78:	d0d43c23          	sd	a3,-744(s0)
    80017f7c:	d1843683          	ld	a3,-744(s0)
    80017f80:	8f55                	or	a4,a4,a3
    80017f82:	d0e43c23          	sd	a4,-744(s0)
    80017f86:	dd043703          	ld	a4,-560(s0)
    80017f8a:	0716                	slli	a4,a4,0x5
    80017f8c:	d0e43823          	sd	a4,-752(s0)
    80017f90:	078a                	slli	a5,a5,0x2
    80017f92:	07bd                	addi	a5,a5,15
    80017f94:	8391                	srli	a5,a5,0x4
    80017f96:	0792                	slli	a5,a5,0x4
    80017f98:	40f10133          	sub	sp,sp,a5
    80017f9c:	878a                	mv	a5,sp
    80017f9e:	078d                	addi	a5,a5,3
    80017fa0:	8389                	srli	a5,a5,0x2
    80017fa2:	078a                	slli	a5,a5,0x2
    80017fa4:	f2f43423          	sd	a5,-216(s0)
            minix3_get_zone(indirect_zone, (uint8_t*)indirect_zones);
    80017fa8:	f3c42783          	lw	a5,-196(s0)
    80017fac:	f2843583          	ld	a1,-216(s0)
    80017fb0:	853e                	mv	a0,a5
    80017fb2:	ecdfd0ef          	jal	ra,80015e7e <minix3_get_zone>

            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    80017fb6:	f80401a3          	sb	zero,-125(s0)
    80017fba:	a2f5                	j	800181a6 <minix3_put_data+0x8ea>
                uint32_t zone = indirect_zones[indirect_zone];
    80017fbc:	f8344783          	lbu	a5,-125(s0)
    80017fc0:	2781                	sext.w	a5,a5
    80017fc2:	f2843703          	ld	a4,-216(s0)
    80017fc6:	078a                	slli	a5,a5,0x2
    80017fc8:	97ba                	add	a5,a5,a4
    80017fca:	439c                	lw	a5,0(a5)
    80017fcc:	f2f42223          	sw	a5,-220(s0)
                if (zone == 0) continue;
    80017fd0:	f2442783          	lw	a5,-220(s0)
    80017fd4:	2781                	sext.w	a5,a5
    80017fd6:	1c078063          	beqz	a5,80018196 <minix3_put_data+0x8da>
                debugf("Writing double indirect zone %d\n", zone);

                if (file_cursor + minix3_get_zone_size() < offset) {
    80017fda:	c14fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017fde:	87aa                	mv	a5,a0
    80017fe0:	2781                	sext.w	a5,a5
    80017fe2:	f8842703          	lw	a4,-120(s0)
    80017fe6:	9fb9                	addw	a5,a5,a4
    80017fe8:	0007871b          	sext.w	a4,a5
    80017fec:	e6842783          	lw	a5,-408(s0)
    80017ff0:	2781                	sext.w	a5,a5
    80017ff2:	00f77c63          	bgeu	a4,a5,8001800a <minix3_put_data+0x74e>
                    // We're not at the offset yet
                    file_cursor += minix3_get_zone_size();
    80017ff6:	bf8fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80017ffa:	87aa                	mv	a5,a0
    80017ffc:	2781                	sext.w	a5,a5
    80017ffe:	f8842703          	lw	a4,-120(s0)
    80018002:	9fb9                	addw	a5,a5,a4
    80018004:	f8f42423          	sw	a5,-120(s0)
                    continue;
    80018008:	aa51                	j	8001819c <minix3_put_data+0x8e0>
                } else if (file_cursor < offset) {
    8001800a:	f8842703          	lw	a4,-120(s0)
    8001800e:	e6842783          	lw	a5,-408(s0)
    80018012:	2701                	sext.w	a4,a4
    80018014:	2781                	sext.w	a5,a5
    80018016:	0cf77463          	bgeu	a4,a5,800180de <minix3_put_data+0x822>
                    // We're in the middle of the offset
                    // Read the zone into the buffer
                    minix3_get_zone(zone, zone_data);
    8001801a:	f2442783          	lw	a5,-220(s0)
    8001801e:	f7043583          	ld	a1,-144(s0)
    80018022:	853e                	mv	a0,a5
    80018024:	e5bfd0ef          	jal	ra,80015e7e <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    80018028:	bc6fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001802c:	87aa                	mv	a5,a0
    8001802e:	0007871b          	sext.w	a4,a5
    80018032:	f8842683          	lw	a3,-120(s0)
    80018036:	e6842783          	lw	a5,-408(s0)
    8001803a:	40f687bb          	subw	a5,a3,a5
    8001803e:	2781                	sext.w	a5,a5
    80018040:	9fb9                	addw	a5,a5,a4
    80018042:	0007871b          	sext.w	a4,a5
    80018046:	e5c42783          	lw	a5,-420(s0)
    8001804a:	2781                	sext.w	a5,a5
    8001804c:	02e7e363          	bltu	a5,a4,80018072 <minix3_put_data+0x7b6>
    80018050:	b9efe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018054:	87aa                	mv	a5,a0
    80018056:	0007871b          	sext.w	a4,a5
    8001805a:	f8842683          	lw	a3,-120(s0)
    8001805e:	e6842783          	lw	a5,-408(s0)
    80018062:	40f687bb          	subw	a5,a3,a5
    80018066:	2781                	sext.w	a5,a5
    80018068:	9fb9                	addw	a5,a5,a4
    8001806a:	2781                	sext.w	a5,a5
    8001806c:	1782                	slli	a5,a5,0x20
    8001806e:	9381                	srli	a5,a5,0x20
    80018070:	a019                	j	80018076 <minix3_put_data+0x7ba>
    80018072:	e5c46783          	lwu	a5,-420(s0)
    80018076:	f0f43c23          	sd	a5,-232(s0)
                    memcpy(zone_data + offset - file_cursor, data, remaining);
    8001807a:	e6846703          	lwu	a4,-408(s0)
    8001807e:	f8846783          	lwu	a5,-120(s0)
    80018082:	40f707b3          	sub	a5,a4,a5
    80018086:	f7043703          	ld	a4,-144(s0)
    8001808a:	97ba                	add	a5,a5,a4
    8001808c:	f1843703          	ld	a4,-232(s0)
    80018090:	2701                	sext.w	a4,a4
    80018092:	863a                	mv	a2,a4
    80018094:	e6043583          	ld	a1,-416(s0)
    80018098:	853e                	mv	a0,a5
    8001809a:	392050ef          	jal	ra,8001d42c <memcpy>
                    minix3_put_zone(zone, zone_data);
    8001809e:	f2442783          	lw	a5,-220(s0)
    800180a2:	f7043583          	ld	a1,-144(s0)
    800180a6:	853e                	mv	a0,a5
    800180a8:	e77fd0ef          	jal	ra,80015f1e <minix3_put_zone>

                    buffer_cursor += remaining;
    800180ac:	f1843783          	ld	a5,-232(s0)
    800180b0:	2781                	sext.w	a5,a5
    800180b2:	f8442703          	lw	a4,-124(s0)
    800180b6:	9fb9                	addw	a5,a5,a4
    800180b8:	f8f42223          	sw	a5,-124(s0)
                    file_cursor = offset + remaining;
    800180bc:	f1843783          	ld	a5,-232(s0)
    800180c0:	2781                	sext.w	a5,a5
    800180c2:	e6842703          	lw	a4,-408(s0)
    800180c6:	9fb9                	addw	a5,a5,a4
    800180c8:	f8f42423          	sw	a5,-120(s0)
                    if (buffer_cursor >= count) {
    800180cc:	f8442703          	lw	a4,-124(s0)
    800180d0:	e5c42783          	lw	a5,-420(s0)
    800180d4:	2701                	sext.w	a4,a4
    800180d6:	2781                	sext.w	a5,a5
    800180d8:	0cf76163          	bltu	a4,a5,8001819a <minix3_put_data+0x8de>
                        // We're done
                        return;
    800180dc:	a8cd                	j	800181ce <minix3_put_data+0x912>
                    }
                    continue;
                }

                memset(zone_data, 0, minix3_get_zone_size());
    800180de:	b10fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800180e2:	87aa                	mv	a5,a0
    800180e4:	2781                	sext.w	a5,a5
    800180e6:	863e                	mv	a2,a5
    800180e8:	4581                	li	a1,0
    800180ea:	f7043503          	ld	a0,-144(s0)
    800180ee:	23c050ef          	jal	ra,8001d32a <memset>
                if (buffer_cursor + minix3_get_zone_size() > count) {
    800180f2:	afcfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800180f6:	87aa                	mv	a5,a0
    800180f8:	2781                	sext.w	a5,a5
    800180fa:	f8442703          	lw	a4,-124(s0)
    800180fe:	9fb9                	addw	a5,a5,a4
    80018100:	0007871b          	sext.w	a4,a5
    80018104:	e5c42783          	lw	a5,-420(s0)
    80018108:	2781                	sext.w	a5,a5
    8001810a:	04e7f563          	bgeu	a5,a4,80018154 <minix3_put_data+0x898>
                    minix3_get_zone(zone, zone_data);
    8001810e:	f2442783          	lw	a5,-220(s0)
    80018112:	f7043583          	ld	a1,-144(s0)
    80018116:	853e                	mv	a0,a5
    80018118:	d67fd0ef          	jal	ra,80015e7e <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    8001811c:	f8446783          	lwu	a5,-124(s0)
    80018120:	e6043703          	ld	a4,-416(s0)
    80018124:	00f706b3          	add	a3,a4,a5
    80018128:	e5c42703          	lw	a4,-420(s0)
    8001812c:	f8442783          	lw	a5,-124(s0)
    80018130:	40f707bb          	subw	a5,a4,a5
    80018134:	2781                	sext.w	a5,a5
    80018136:	2781                	sext.w	a5,a5
    80018138:	863e                	mv	a2,a5
    8001813a:	85b6                	mv	a1,a3
    8001813c:	f7043503          	ld	a0,-144(s0)
    80018140:	2ec050ef          	jal	ra,8001d42c <memcpy>
                    // We're done
                    minix3_put_zone(zone, zone_data);
    80018144:	f2442783          	lw	a5,-220(s0)
    80018148:	f7043583          	ld	a1,-144(s0)
    8001814c:	853e                	mv	a0,a5
    8001814e:	dd1fd0ef          	jal	ra,80015f1e <minix3_put_zone>
                    return;
    80018152:	a8b5                	j	800181ce <minix3_put_data+0x912>
                } else {
                    // Copy the entire zone into the buffer
                    memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size());
    80018154:	f8446783          	lwu	a5,-124(s0)
    80018158:	e6043703          	ld	a4,-416(s0)
    8001815c:	00f70933          	add	s2,a4,a5
    80018160:	a8efe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018164:	87aa                	mv	a5,a0
    80018166:	2781                	sext.w	a5,a5
    80018168:	863e                	mv	a2,a5
    8001816a:	85ca                	mv	a1,s2
    8001816c:	f7043503          	ld	a0,-144(s0)
    80018170:	2bc050ef          	jal	ra,8001d42c <memcpy>
                    minix3_put_zone(zone, zone_data);
    80018174:	f2442783          	lw	a5,-220(s0)
    80018178:	f7043583          	ld	a1,-144(s0)
    8001817c:	853e                	mv	a0,a5
    8001817e:	da1fd0ef          	jal	ra,80015f1e <minix3_put_zone>
                }

                buffer_cursor += minix3_get_zone_size();
    80018182:	a6cfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018186:	87aa                	mv	a5,a0
    80018188:	2781                	sext.w	a5,a5
    8001818a:	f8442703          	lw	a4,-124(s0)
    8001818e:	9fb9                	addw	a5,a5,a4
    80018190:	f8f42223          	sw	a5,-124(s0)
    80018194:	a021                	j	8001819c <minix3_put_data+0x8e0>
                if (zone == 0) continue;
    80018196:	0001                	nop
    80018198:	a011                	j	8001819c <minix3_put_data+0x8e0>
                    continue;
    8001819a:	0001                	nop
            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    8001819c:	f8344783          	lbu	a5,-125(s0)
    800181a0:	2785                	addiw	a5,a5,1
    800181a2:	f8f401a3          	sb	a5,-125(s0)
    800181a6:	f8344783          	lbu	a5,-125(s0)
    800181aa:	03079913          	slli	s2,a5,0x30
    800181ae:	03095913          	srli	s2,s2,0x30
    800181b2:	a3cfe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800181b6:	87aa                	mv	a5,a0
    800181b8:	0027d79b          	srliw	a5,a5,0x2
    800181bc:	17c2                	slli	a5,a5,0x30
    800181be:	93c1                	srli	a5,a5,0x30
    800181c0:	0009071b          	sext.w	a4,s2
    800181c4:	2781                	sext.w	a5,a5
    800181c6:	def76be3          	bltu	a4,a5,80017fbc <minix3_put_data+0x700>
    800181ca:	8126                	mv	sp,s1
    800181cc:	a021                	j	800181d4 <minix3_put_data+0x918>
    800181ce:	8126                	mv	sp,s1
    800181d0:	814e                	mv	sp,s3
    800181d2:	a17d                	j	80018680 <minix3_put_data+0xdc4>
        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    800181d4:	f8f44783          	lbu	a5,-113(s0)
    800181d8:	2785                	addiw	a5,a5,1
    800181da:	f8f407a3          	sb	a5,-113(s0)
    800181de:	f8f44783          	lbu	a5,-113(s0)
    800181e2:	03079493          	slli	s1,a5,0x30
    800181e6:	90c1                	srli	s1,s1,0x30
    800181e8:	a06fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800181ec:	87aa                	mv	a5,a0
    800181ee:	0027d79b          	srliw	a5,a5,0x2
    800181f2:	17c2                	slli	a5,a5,0x30
    800181f4:	93c1                	srli	a5,a5,0x30
    800181f6:	0004871b          	sext.w	a4,s1
    800181fa:	2781                	sext.w	a5,a5
    800181fc:	d0f766e3          	bltu	a4,a5,80017f08 <minix3_put_data+0x64c>
    80018200:	814e                	mv	sp,s3
    } else {
        debugf("No double indirect zone\n");
    }

    // The next zone is a triple indirect zone
    if (inode_data.zones[9] != 0) {
    80018202:	eb442783          	lw	a5,-332(s0)
    80018206:	46078c63          	beqz	a5,8001867e <minix3_put_data+0xdc2>
    8001820a:	878a                	mv	a5,sp
    8001820c:	8a3e                	mv	s4,a5
        uint32_t triple_indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    8001820e:	9e0fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018212:	87aa                	mv	a5,a0
    80018214:	0027d79b          	srliw	a5,a5,0x2
    80018218:	17c2                	slli	a5,a5,0x30
    8001821a:	93c1                	srli	a5,a5,0x30
    8001821c:	873e                	mv	a4,a5
    8001821e:	177d                	addi	a4,a4,-1
    80018220:	f0e43823          	sd	a4,-240(s0)
    80018224:	dcf43023          	sd	a5,-576(s0)
    80018228:	dc043423          	sd	zero,-568(s0)
    8001822c:	dc043703          	ld	a4,-576(s0)
    80018230:	936d                	srli	a4,a4,0x3b
    80018232:	dc843683          	ld	a3,-568(s0)
    80018236:	0696                	slli	a3,a3,0x5
    80018238:	d0d43423          	sd	a3,-760(s0)
    8001823c:	d0843683          	ld	a3,-760(s0)
    80018240:	8f55                	or	a4,a4,a3
    80018242:	d0e43423          	sd	a4,-760(s0)
    80018246:	dc043703          	ld	a4,-576(s0)
    8001824a:	0716                	slli	a4,a4,0x5
    8001824c:	d0e43023          	sd	a4,-768(s0)
    80018250:	daf43823          	sd	a5,-592(s0)
    80018254:	da043c23          	sd	zero,-584(s0)
    80018258:	db043703          	ld	a4,-592(s0)
    8001825c:	936d                	srli	a4,a4,0x3b
    8001825e:	db843683          	ld	a3,-584(s0)
    80018262:	0696                	slli	a3,a3,0x5
    80018264:	ced43c23          	sd	a3,-776(s0)
    80018268:	cf843683          	ld	a3,-776(s0)
    8001826c:	8f55                	or	a4,a4,a3
    8001826e:	cee43c23          	sd	a4,-776(s0)
    80018272:	db043703          	ld	a4,-592(s0)
    80018276:	0716                	slli	a4,a4,0x5
    80018278:	cee43823          	sd	a4,-784(s0)
    8001827c:	078a                	slli	a5,a5,0x2
    8001827e:	07bd                	addi	a5,a5,15
    80018280:	8391                	srli	a5,a5,0x4
    80018282:	0792                	slli	a5,a5,0x4
    80018284:	40f10133          	sub	sp,sp,a5
    80018288:	878a                	mv	a5,sp
    8001828a:	078d                	addi	a5,a5,3
    8001828c:	8389                	srli	a5,a5,0x2
    8001828e:	078a                	slli	a5,a5,0x2
    80018290:	f0f43423          	sd	a5,-248(s0)
        minix3_get_zone(inode_data.zones[9], (uint8_t*)triple_indirect_zones);
    80018294:	eb442783          	lw	a5,-332(s0)
    80018298:	f0843583          	ld	a1,-248(s0)
    8001829c:	853e                	mv	a0,a5
    8001829e:	be1fd0ef          	jal	ra,80015e7e <minix3_get_zone>

        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); triple_indirect_zone++) {
    800182a2:	f8040123          	sb	zero,-126(s0)
    800182a6:	ae55                	j	8001865a <minix3_put_data+0xd9e>
    800182a8:	878a                	mv	a5,sp
    800182aa:	84be                	mv	s1,a5
            uint32_t double_indirect_zone = triple_indirect_zones[triple_indirect_zone];
    800182ac:	f8244783          	lbu	a5,-126(s0)
    800182b0:	2781                	sext.w	a5,a5
    800182b2:	f0843703          	ld	a4,-248(s0)
    800182b6:	078a                	slli	a5,a5,0x2
    800182b8:	97ba                	add	a5,a5,a4
    800182ba:	439c                	lw	a5,0(a5)
    800182bc:	f0f42223          	sw	a5,-252(s0)
            if (double_indirect_zone == 0) continue;
    800182c0:	f0442783          	lw	a5,-252(s0)
    800182c4:	2781                	sext.w	a5,a5
    800182c6:	e399                	bnez	a5,800182cc <minix3_put_data+0xa10>
    800182c8:	8126                	mv	sp,s1
    800182ca:	a659                	j	80018650 <minix3_put_data+0xd94>
            uint32_t double_indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    800182cc:	922fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800182d0:	87aa                	mv	a5,a0
    800182d2:	0027d79b          	srliw	a5,a5,0x2
    800182d6:	17c2                	slli	a5,a5,0x30
    800182d8:	93c1                	srli	a5,a5,0x30
    800182da:	873e                	mv	a4,a5
    800182dc:	177d                	addi	a4,a4,-1
    800182de:	eee43c23          	sd	a4,-264(s0)
    800182e2:	daf43023          	sd	a5,-608(s0)
    800182e6:	da043423          	sd	zero,-600(s0)
    800182ea:	da043703          	ld	a4,-608(s0)
    800182ee:	936d                	srli	a4,a4,0x3b
    800182f0:	da843683          	ld	a3,-600(s0)
    800182f4:	00569b93          	slli	s7,a3,0x5
    800182f8:	01776bb3          	or	s7,a4,s7
    800182fc:	da043703          	ld	a4,-608(s0)
    80018300:	00571b13          	slli	s6,a4,0x5
    80018304:	d8f43823          	sd	a5,-624(s0)
    80018308:	d8043c23          	sd	zero,-616(s0)
    8001830c:	d9043703          	ld	a4,-624(s0)
    80018310:	936d                	srli	a4,a4,0x3b
    80018312:	d9843683          	ld	a3,-616(s0)
    80018316:	00569c93          	slli	s9,a3,0x5
    8001831a:	01976cb3          	or	s9,a4,s9
    8001831e:	d9043703          	ld	a4,-624(s0)
    80018322:	00571c13          	slli	s8,a4,0x5
    80018326:	078a                	slli	a5,a5,0x2
    80018328:	07bd                	addi	a5,a5,15
    8001832a:	8391                	srli	a5,a5,0x4
    8001832c:	0792                	slli	a5,a5,0x4
    8001832e:	40f10133          	sub	sp,sp,a5
    80018332:	878a                	mv	a5,sp
    80018334:	078d                	addi	a5,a5,3
    80018336:	8389                	srli	a5,a5,0x2
    80018338:	078a                	slli	a5,a5,0x2
    8001833a:	eef43823          	sd	a5,-272(s0)
            minix3_get_zone(double_indirect_zone, (uint8_t*)double_indirect_zones);
    8001833e:	f0442783          	lw	a5,-252(s0)
    80018342:	ef043583          	ld	a1,-272(s0)
    80018346:	853e                	mv	a0,a5
    80018348:	b37fd0ef          	jal	ra,80015e7e <minix3_get_zone>

            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    8001834c:	f80400a3          	sb	zero,-127(s0)
    80018350:	ace9                	j	8001862a <minix3_put_data+0xd6e>
    80018352:	878a                	mv	a5,sp
    80018354:	893e                	mv	s2,a5
                uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80018356:	f8144783          	lbu	a5,-127(s0)
    8001835a:	2781                	sext.w	a5,a5
    8001835c:	ef043703          	ld	a4,-272(s0)
    80018360:	078a                	slli	a5,a5,0x2
    80018362:	97ba                	add	a5,a5,a4
    80018364:	439c                	lw	a5,0(a5)
    80018366:	eef42623          	sw	a5,-276(s0)
                if (indirect_zone == 0) continue;
    8001836a:	eec42783          	lw	a5,-276(s0)
    8001836e:	2781                	sext.w	a5,a5
    80018370:	e399                	bnez	a5,80018376 <minix3_put_data+0xaba>
    80018372:	814a                	mv	sp,s2
    80018374:	a475                	j	80018620 <minix3_put_data+0xd64>
                uint32_t indirect_zones[minix3_get_zone_size() / sizeof(uint32_t)];
    80018376:	878fe0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001837a:	87aa                	mv	a5,a0
    8001837c:	0027d79b          	srliw	a5,a5,0x2
    80018380:	17c2                	slli	a5,a5,0x30
    80018382:	93c1                	srli	a5,a5,0x30
    80018384:	873e                	mv	a4,a5
    80018386:	177d                	addi	a4,a4,-1
    80018388:	eee43023          	sd	a4,-288(s0)
    8001838c:	d8f43023          	sd	a5,-640(s0)
    80018390:	d8043423          	sd	zero,-632(s0)
    80018394:	d8043703          	ld	a4,-640(s0)
    80018398:	936d                	srli	a4,a4,0x3b
    8001839a:	d8843683          	ld	a3,-632(s0)
    8001839e:	00569d93          	slli	s11,a3,0x5
    800183a2:	01b76db3          	or	s11,a4,s11
    800183a6:	d8043703          	ld	a4,-640(s0)
    800183aa:	00571d13          	slli	s10,a4,0x5
    800183ae:	d6f43823          	sd	a5,-656(s0)
    800183b2:	d6043c23          	sd	zero,-648(s0)
    800183b6:	d7043703          	ld	a4,-656(s0)
    800183ba:	936d                	srli	a4,a4,0x3b
    800183bc:	d7843683          	ld	a3,-648(s0)
    800183c0:	0696                	slli	a3,a3,0x5
    800183c2:	ced43423          	sd	a3,-792(s0)
    800183c6:	ce843683          	ld	a3,-792(s0)
    800183ca:	8f55                	or	a4,a4,a3
    800183cc:	cee43423          	sd	a4,-792(s0)
    800183d0:	d7043703          	ld	a4,-656(s0)
    800183d4:	0716                	slli	a4,a4,0x5
    800183d6:	cee43023          	sd	a4,-800(s0)
    800183da:	078a                	slli	a5,a5,0x2
    800183dc:	07bd                	addi	a5,a5,15
    800183de:	8391                	srli	a5,a5,0x4
    800183e0:	0792                	slli	a5,a5,0x4
    800183e2:	40f10133          	sub	sp,sp,a5
    800183e6:	878a                	mv	a5,sp
    800183e8:	078d                	addi	a5,a5,3
    800183ea:	8389                	srli	a5,a5,0x2
    800183ec:	078a                	slli	a5,a5,0x2
    800183ee:	ecf43c23          	sd	a5,-296(s0)
                minix3_get_zone(indirect_zone, (uint8_t*)indirect_zones);
    800183f2:	eec42783          	lw	a5,-276(s0)
    800183f6:	ed843583          	ld	a1,-296(s0)
    800183fa:	853e                	mv	a0,a5
    800183fc:	a83fd0ef          	jal	ra,80015e7e <minix3_get_zone>

                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    80018400:	f8040023          	sb	zero,-128(s0)
    80018404:	a2f5                	j	800185f0 <minix3_put_data+0xd34>
                    uint32_t zone = indirect_zones[indirect_zone];
    80018406:	f8044783          	lbu	a5,-128(s0)
    8001840a:	2781                	sext.w	a5,a5
    8001840c:	ed843703          	ld	a4,-296(s0)
    80018410:	078a                	slli	a5,a5,0x2
    80018412:	97ba                	add	a5,a5,a4
    80018414:	439c                	lw	a5,0(a5)
    80018416:	ecf42a23          	sw	a5,-300(s0)
                    if (zone == 0) continue;
    8001841a:	ed442783          	lw	a5,-300(s0)
    8001841e:	2781                	sext.w	a5,a5
    80018420:	1c078063          	beqz	a5,800185e0 <minix3_put_data+0xd24>
                    debugf("Writing triple indirect zone %d\n", zone);

                    if (file_cursor + minix3_get_zone_size() < offset) {
    80018424:	fcbfd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018428:	87aa                	mv	a5,a0
    8001842a:	2781                	sext.w	a5,a5
    8001842c:	f8842703          	lw	a4,-120(s0)
    80018430:	9fb9                	addw	a5,a5,a4
    80018432:	0007871b          	sext.w	a4,a5
    80018436:	e6842783          	lw	a5,-408(s0)
    8001843a:	2781                	sext.w	a5,a5
    8001843c:	00f77c63          	bgeu	a4,a5,80018454 <minix3_put_data+0xb98>
                        // We're not at the offset yet
                        file_cursor += minix3_get_zone_size();
    80018440:	faffd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018444:	87aa                	mv	a5,a0
    80018446:	2781                	sext.w	a5,a5
    80018448:	f8842703          	lw	a4,-120(s0)
    8001844c:	9fb9                	addw	a5,a5,a4
    8001844e:	f8f42423          	sw	a5,-120(s0)
                        continue;
    80018452:	aa51                	j	800185e6 <minix3_put_data+0xd2a>
                    } else if (file_cursor < offset) {
    80018454:	f8842703          	lw	a4,-120(s0)
    80018458:	e6842783          	lw	a5,-408(s0)
    8001845c:	2701                	sext.w	a4,a4
    8001845e:	2781                	sext.w	a5,a5
    80018460:	0cf77463          	bgeu	a4,a5,80018528 <minix3_put_data+0xc6c>
                        // We're in the middle of the offset
                        // Read the zone into the buffer
                        minix3_get_zone(zone, zone_data);
    80018464:	ed442783          	lw	a5,-300(s0)
    80018468:	f7043583          	ld	a1,-144(s0)
    8001846c:	853e                	mv	a0,a5
    8001846e:	a11fd0ef          	jal	ra,80015e7e <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        size_t remaining = min(count, minix3_get_zone_size() - (offset - file_cursor));
    80018472:	f7dfd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018476:	87aa                	mv	a5,a0
    80018478:	0007871b          	sext.w	a4,a5
    8001847c:	f8842683          	lw	a3,-120(s0)
    80018480:	e6842783          	lw	a5,-408(s0)
    80018484:	40f687bb          	subw	a5,a3,a5
    80018488:	2781                	sext.w	a5,a5
    8001848a:	9fb9                	addw	a5,a5,a4
    8001848c:	0007871b          	sext.w	a4,a5
    80018490:	e5c42783          	lw	a5,-420(s0)
    80018494:	2781                	sext.w	a5,a5
    80018496:	02e7e363          	bltu	a5,a4,800184bc <minix3_put_data+0xc00>
    8001849a:	f55fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001849e:	87aa                	mv	a5,a0
    800184a0:	0007871b          	sext.w	a4,a5
    800184a4:	f8842683          	lw	a3,-120(s0)
    800184a8:	e6842783          	lw	a5,-408(s0)
    800184ac:	40f687bb          	subw	a5,a3,a5
    800184b0:	2781                	sext.w	a5,a5
    800184b2:	9fb9                	addw	a5,a5,a4
    800184b4:	2781                	sext.w	a5,a5
    800184b6:	1782                	slli	a5,a5,0x20
    800184b8:	9381                	srli	a5,a5,0x20
    800184ba:	a019                	j	800184c0 <minix3_put_data+0xc04>
    800184bc:	e5c46783          	lwu	a5,-420(s0)
    800184c0:	ecf43423          	sd	a5,-312(s0)
                        memcpy(zone_data + offset - file_cursor, data, remaining);
    800184c4:	e6846703          	lwu	a4,-408(s0)
    800184c8:	f8846783          	lwu	a5,-120(s0)
    800184cc:	40f707b3          	sub	a5,a4,a5
    800184d0:	f7043703          	ld	a4,-144(s0)
    800184d4:	97ba                	add	a5,a5,a4
    800184d6:	ec843703          	ld	a4,-312(s0)
    800184da:	2701                	sext.w	a4,a4
    800184dc:	863a                	mv	a2,a4
    800184de:	e6043583          	ld	a1,-416(s0)
    800184e2:	853e                	mv	a0,a5
    800184e4:	749040ef          	jal	ra,8001d42c <memcpy>
                        minix3_put_zone(zone, zone_data);
    800184e8:	ed442783          	lw	a5,-300(s0)
    800184ec:	f7043583          	ld	a1,-144(s0)
    800184f0:	853e                	mv	a0,a5
    800184f2:	a2dfd0ef          	jal	ra,80015f1e <minix3_put_zone>

                        buffer_cursor += remaining;
    800184f6:	ec843783          	ld	a5,-312(s0)
    800184fa:	2781                	sext.w	a5,a5
    800184fc:	f8442703          	lw	a4,-124(s0)
    80018500:	9fb9                	addw	a5,a5,a4
    80018502:	f8f42223          	sw	a5,-124(s0)
                        file_cursor = offset + remaining;
    80018506:	ec843783          	ld	a5,-312(s0)
    8001850a:	2781                	sext.w	a5,a5
    8001850c:	e6842703          	lw	a4,-408(s0)
    80018510:	9fb9                	addw	a5,a5,a4
    80018512:	f8f42423          	sw	a5,-120(s0)
                        if (buffer_cursor >= count) {
    80018516:	f8442703          	lw	a4,-124(s0)
    8001851a:	e5c42783          	lw	a5,-420(s0)
    8001851e:	2701                	sext.w	a4,a4
    80018520:	2781                	sext.w	a5,a5
    80018522:	0cf76163          	bltu	a4,a5,800185e4 <minix3_put_data+0xd28>
                            // We're done
                            return;
    80018526:	a8cd                	j	80018618 <minix3_put_data+0xd5c>
                        }
                        continue;
                    }

                    memset(zone_data, 0, minix3_get_zone_size());
    80018528:	ec7fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001852c:	87aa                	mv	a5,a0
    8001852e:	2781                	sext.w	a5,a5
    80018530:	863e                	mv	a2,a5
    80018532:	4581                	li	a1,0
    80018534:	f7043503          	ld	a0,-144(s0)
    80018538:	5f3040ef          	jal	ra,8001d32a <memset>

                    if (buffer_cursor + minix3_get_zone_size() > count) {
    8001853c:	eb3fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018540:	87aa                	mv	a5,a0
    80018542:	2781                	sext.w	a5,a5
    80018544:	f8442703          	lw	a4,-124(s0)
    80018548:	9fb9                	addw	a5,a5,a4
    8001854a:	0007871b          	sext.w	a4,a5
    8001854e:	e5c42783          	lw	a5,-420(s0)
    80018552:	2781                	sext.w	a5,a5
    80018554:	04e7f563          	bgeu	a5,a4,8001859e <minix3_put_data+0xce2>
                        minix3_get_zone(zone, zone_data);
    80018558:	ed442783          	lw	a5,-300(s0)
    8001855c:	f7043583          	ld	a1,-144(s0)
    80018560:	853e                	mv	a0,a5
    80018562:	91dfd0ef          	jal	ra,80015e7e <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    80018566:	f8446783          	lwu	a5,-124(s0)
    8001856a:	e6043703          	ld	a4,-416(s0)
    8001856e:	00f706b3          	add	a3,a4,a5
    80018572:	e5c42703          	lw	a4,-420(s0)
    80018576:	f8442783          	lw	a5,-124(s0)
    8001857a:	40f707bb          	subw	a5,a4,a5
    8001857e:	2781                	sext.w	a5,a5
    80018580:	2781                	sext.w	a5,a5
    80018582:	863e                	mv	a2,a5
    80018584:	85b6                	mv	a1,a3
    80018586:	f7043503          	ld	a0,-144(s0)
    8001858a:	6a3040ef          	jal	ra,8001d42c <memcpy>
                        // We're done
                        minix3_put_zone(zone, zone_data);
    8001858e:	ed442783          	lw	a5,-300(s0)
    80018592:	f7043583          	ld	a1,-144(s0)
    80018596:	853e                	mv	a0,a5
    80018598:	987fd0ef          	jal	ra,80015f1e <minix3_put_zone>
                        return;
    8001859c:	a8b5                	j	80018618 <minix3_put_data+0xd5c>
                    } else {
                        // Copy the entire zone into the buffer
                        memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size());
    8001859e:	f8446783          	lwu	a5,-124(s0)
    800185a2:	e6043703          	ld	a4,-416(s0)
    800185a6:	00f709b3          	add	s3,a4,a5
    800185aa:	e45fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800185ae:	87aa                	mv	a5,a0
    800185b0:	2781                	sext.w	a5,a5
    800185b2:	863e                	mv	a2,a5
    800185b4:	85ce                	mv	a1,s3
    800185b6:	f7043503          	ld	a0,-144(s0)
    800185ba:	673040ef          	jal	ra,8001d42c <memcpy>
                        minix3_put_zone(zone, zone_data);
    800185be:	ed442783          	lw	a5,-300(s0)
    800185c2:	f7043583          	ld	a1,-144(s0)
    800185c6:	853e                	mv	a0,a5
    800185c8:	957fd0ef          	jal	ra,80015f1e <minix3_put_zone>
                    }
                    buffer_cursor += minix3_get_zone_size();
    800185cc:	e23fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    800185d0:	87aa                	mv	a5,a0
    800185d2:	2781                	sext.w	a5,a5
    800185d4:	f8442703          	lw	a4,-124(s0)
    800185d8:	9fb9                	addw	a5,a5,a4
    800185da:	f8f42223          	sw	a5,-124(s0)
    800185de:	a021                	j	800185e6 <minix3_put_data+0xd2a>
                    if (zone == 0) continue;
    800185e0:	0001                	nop
    800185e2:	a011                	j	800185e6 <minix3_put_data+0xd2a>
                        continue;
    800185e4:	0001                	nop
                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); indirect_zone++) {
    800185e6:	f8044783          	lbu	a5,-128(s0)
    800185ea:	2785                	addiw	a5,a5,1
    800185ec:	f8f40023          	sb	a5,-128(s0)
    800185f0:	f8044783          	lbu	a5,-128(s0)
    800185f4:	03079993          	slli	s3,a5,0x30
    800185f8:	0309d993          	srli	s3,s3,0x30
    800185fc:	df3fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018600:	87aa                	mv	a5,a0
    80018602:	0027d79b          	srliw	a5,a5,0x2
    80018606:	17c2                	slli	a5,a5,0x30
    80018608:	93c1                	srli	a5,a5,0x30
    8001860a:	0009871b          	sext.w	a4,s3
    8001860e:	2781                	sext.w	a5,a5
    80018610:	def76be3          	bltu	a4,a5,80018406 <minix3_put_data+0xb4a>
    80018614:	814a                	mv	sp,s2
    80018616:	a029                	j	80018620 <minix3_put_data+0xd64>
    80018618:	814a                	mv	sp,s2
    8001861a:	8126                	mv	sp,s1
    8001861c:	8152                	mv	sp,s4
    8001861e:	a08d                	j	80018680 <minix3_put_data+0xdc4>
            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); double_indirect_zone++) {
    80018620:	f8144783          	lbu	a5,-127(s0)
    80018624:	2785                	addiw	a5,a5,1
    80018626:	f8f400a3          	sb	a5,-127(s0)
    8001862a:	f8144783          	lbu	a5,-127(s0)
    8001862e:	03079913          	slli	s2,a5,0x30
    80018632:	03095913          	srli	s2,s2,0x30
    80018636:	db9fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    8001863a:	87aa                	mv	a5,a0
    8001863c:	0027d79b          	srliw	a5,a5,0x2
    80018640:	17c2                	slli	a5,a5,0x30
    80018642:	93c1                	srli	a5,a5,0x30
    80018644:	0009071b          	sext.w	a4,s2
    80018648:	2781                	sext.w	a5,a5
    8001864a:	d0f764e3          	bltu	a4,a5,80018352 <minix3_put_data+0xa96>
    8001864e:	8126                	mv	sp,s1
        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size() / sizeof(uint32_t); triple_indirect_zone++) {
    80018650:	f8244783          	lbu	a5,-126(s0)
    80018654:	2785                	addiw	a5,a5,1
    80018656:	f8f40123          	sb	a5,-126(s0)
    8001865a:	f8244783          	lbu	a5,-126(s0)
    8001865e:	03079493          	slli	s1,a5,0x30
    80018662:	90c1                	srli	s1,s1,0x30
    80018664:	d8bfd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018668:	87aa                	mv	a5,a0
    8001866a:	0027d79b          	srliw	a5,a5,0x2
    8001866e:	17c2                	slli	a5,a5,0x30
    80018670:	93c1                	srli	a5,a5,0x30
    80018672:	0004871b          	sext.w	a4,s1
    80018676:	2781                	sext.w	a5,a5
    80018678:	c2f768e3          	bltu	a4,a5,800182a8 <minix3_put_data+0x9ec>
    8001867c:	8152                	mv	sp,s4
        debugf("No triple indirect zone\n");
    }


    // If we get here, we've read all the data we can
    return;
    8001867e:	0001                	nop
    80018680:	e5043103          	ld	sp,-432(s0)
}
    80018684:	ce040113          	addi	sp,s0,-800
    80018688:	31813083          	ld	ra,792(sp)
    8001868c:	31013403          	ld	s0,784(sp)
    80018690:	30813483          	ld	s1,776(sp)
    80018694:	30013903          	ld	s2,768(sp)
    80018698:	2f813983          	ld	s3,760(sp)
    8001869c:	2f013a03          	ld	s4,752(sp)
    800186a0:	2e813a83          	ld	s5,744(sp)
    800186a4:	2e013b03          	ld	s6,736(sp)
    800186a8:	2d813b83          	ld	s7,728(sp)
    800186ac:	2d013c03          	ld	s8,720(sp)
    800186b0:	2c813c83          	ld	s9,712(sp)
    800186b4:	2c013d03          	ld	s10,704(sp)
    800186b8:	2b813d83          	ld	s11,696(sp)
    800186bc:	32010113          	addi	sp,sp,800
    800186c0:	8082                	ret

00000000800186c2 <minix3_get_dir_entry>:


bool minix3_get_dir_entry(uint32_t inode, uint32_t entry, DirEntry *data) {
    800186c2:	7135                	addi	sp,sp,-160
    800186c4:	ed06                	sd	ra,152(sp)
    800186c6:	e922                	sd	s0,144(sp)
    800186c8:	1100                	addi	s0,sp,160
    800186ca:	87aa                	mv	a5,a0
    800186cc:	872e                	mv	a4,a1
    800186ce:	f6c43023          	sd	a2,-160(s0)
    800186d2:	f6f42623          	sw	a5,-148(s0)
    800186d6:	87ba                	mv	a5,a4
    800186d8:	f6f42423          	sw	a5,-152(s0)
    if (!minix3_is_dir(inode)) {
    800186dc:	f6c42783          	lw	a5,-148(s0)
    800186e0:	853e                	mv	a0,a5
    800186e2:	bd0fe0ef          	jal	ra,80016ab2 <minix3_is_dir>
    800186e6:	87aa                	mv	a5,a0
    800186e8:	0017c793          	xori	a5,a5,1
    800186ec:	0ff7f793          	andi	a5,a5,255
    800186f0:	cf99                	beqz	a5,8001870e <minix3_get_dir_entry+0x4c>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    800186f2:	f6c42703          	lw	a4,-148(s0)
    800186f6:	f6c42783          	lw	a5,-148(s0)
    800186fa:	863a                	mv	a2,a4
    800186fc:	85be                	mv	a1,a5
    800186fe:	0000a517          	auipc	a0,0xa
    80018702:	c0a50513          	addi	a0,a0,-1014 # 80022308 <pow10.0+0x10d8>
    80018706:	355000ef          	jal	ra,8001925a <warnf>
        return false;
    8001870a:	4781                	li	a5,0
    8001870c:	a881                	j	8001875c <minix3_get_dir_entry+0x9a>
    }
    Inode inode_data = minix3_get_inode(inode);
    8001870e:	fb040793          	addi	a5,s0,-80
    80018712:	f6c42703          	lw	a4,-148(s0)
    80018716:	85ba                	mv	a1,a4
    80018718:	853e                	mv	a0,a5
    8001871a:	910fe0ef          	jal	ra,8001682a <minix3_get_inode>
    debugf("Getting entry %u from inode %u\n", entry, inode);
    DirEntry tmp;
    minix3_get_data(inode, &tmp, entry * sizeof(DirEntry), sizeof(DirEntry));
    8001871e:	f6842783          	lw	a5,-152(s0)
    80018722:	0067979b          	slliw	a5,a5,0x6
    80018726:	0007861b          	sext.w	a2,a5
    8001872a:	f7040713          	addi	a4,s0,-144
    8001872e:	f6c42783          	lw	a5,-148(s0)
    80018732:	04000693          	li	a3,64
    80018736:	85ba                	mv	a1,a4
    80018738:	853e                	mv	a0,a5
    8001873a:	c82fe0ef          	jal	ra,80016bbc <minix3_get_data>
    debugf("Got entry %s at inode %u\n", tmp.name, tmp.inode);
    if (tmp.inode == 0) {
    8001873e:	f7042783          	lw	a5,-144(s0)
    80018742:	e399                	bnez	a5,80018748 <minix3_get_dir_entry+0x86>
        return false;
    80018744:	4781                	li	a5,0
    80018746:	a819                	j	8001875c <minix3_get_dir_entry+0x9a>
    }

    memcpy(data, &tmp, sizeof(DirEntry));
    80018748:	f7040793          	addi	a5,s0,-144
    8001874c:	04000613          	li	a2,64
    80018750:	85be                	mv	a1,a5
    80018752:	f6043503          	ld	a0,-160(s0)
    80018756:	4d7040ef          	jal	ra,8001d42c <memcpy>
    return true;
    8001875a:	4785                	li	a5,1
}
    8001875c:	853e                	mv	a0,a5
    8001875e:	60ea                	ld	ra,152(sp)
    80018760:	644a                	ld	s0,144(sp)
    80018762:	610d                	addi	sp,sp,160
    80018764:	8082                	ret

0000000080018766 <minix3_put_dir_entry>:

void minix3_put_dir_entry(uint32_t inode, uint32_t entry, DirEntry *data) {
    80018766:	711d                	addi	sp,sp,-96
    80018768:	ec86                	sd	ra,88(sp)
    8001876a:	e8a2                	sd	s0,80(sp)
    8001876c:	1080                	addi	s0,sp,96
    8001876e:	87aa                	mv	a5,a0
    80018770:	872e                	mv	a4,a1
    80018772:	fac43023          	sd	a2,-96(s0)
    80018776:	faf42623          	sw	a5,-84(s0)
    8001877a:	87ba                	mv	a5,a4
    8001877c:	faf42423          	sw	a5,-88(s0)
    if (!minix3_is_dir(inode)) {
    80018780:	fac42783          	lw	a5,-84(s0)
    80018784:	853e                	mv	a0,a5
    80018786:	b2cfe0ef          	jal	ra,80016ab2 <minix3_is_dir>
    8001878a:	87aa                	mv	a5,a0
    8001878c:	0017c793          	xori	a5,a5,1
    80018790:	0ff7f793          	andi	a5,a5,255
    80018794:	cf91                	beqz	a5,800187b0 <minix3_put_dir_entry+0x4a>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    80018796:	fac42703          	lw	a4,-84(s0)
    8001879a:	fac42783          	lw	a5,-84(s0)
    8001879e:	863a                	mv	a2,a4
    800187a0:	85be                	mv	a1,a5
    800187a2:	0000a517          	auipc	a0,0xa
    800187a6:	b6650513          	addi	a0,a0,-1178 # 80022308 <pow10.0+0x10d8>
    800187aa:	2b1000ef          	jal	ra,8001925a <warnf>
    800187ae:	a80d                	j	800187e0 <minix3_put_dir_entry+0x7a>
        return;
    }
    Inode inode_data = minix3_get_inode(inode);
    800187b0:	fb040793          	addi	a5,s0,-80
    800187b4:	fac42703          	lw	a4,-84(s0)
    800187b8:	85ba                	mv	a1,a4
    800187ba:	853e                	mv	a0,a5
    800187bc:	86efe0ef          	jal	ra,8001682a <minix3_get_inode>
    minix3_put_data(inode, data, entry * sizeof(DirEntry), sizeof(DirEntry));
    800187c0:	fa842783          	lw	a5,-88(s0)
    800187c4:	0067979b          	slliw	a5,a5,0x6
    800187c8:	0007871b          	sext.w	a4,a5
    800187cc:	fac42783          	lw	a5,-84(s0)
    800187d0:	04000693          	li	a3,64
    800187d4:	863a                	mv	a2,a4
    800187d6:	fa043583          	ld	a1,-96(s0)
    800187da:	853e                	mv	a0,a5
    800187dc:	8e0ff0ef          	jal	ra,800178bc <minix3_put_data>
}
    800187e0:	60e6                	ld	ra,88(sp)
    800187e2:	6446                	ld	s0,80(sp)
    800187e4:	6125                	addi	sp,sp,96
    800187e6:	8082                	ret

00000000800187e8 <minix3_list_dir>:


// List all of the entries in the given directory to the given buffer.
uint32_t minix3_list_dir(uint32_t inode, DirEntry *entries, uint32_t max_entries) {
    800187e8:	7171                	addi	sp,sp,-176
    800187ea:	f506                	sd	ra,168(sp)
    800187ec:	f122                	sd	s0,160(sp)
    800187ee:	1900                	addi	s0,sp,176
    800187f0:	87aa                	mv	a5,a0
    800187f2:	f4b43823          	sd	a1,-176(s0)
    800187f6:	8732                	mv	a4,a2
    800187f8:	f4f42e23          	sw	a5,-164(s0)
    800187fc:	87ba                	mv	a5,a4
    800187fe:	f4f42c23          	sw	a5,-168(s0)
    if (!minix3_is_dir(inode)) {
    80018802:	f5c42783          	lw	a5,-164(s0)
    80018806:	853e                	mv	a0,a5
    80018808:	aaafe0ef          	jal	ra,80016ab2 <minix3_is_dir>
    8001880c:	87aa                	mv	a5,a0
    8001880e:	0017c793          	xori	a5,a5,1
    80018812:	0ff7f793          	andi	a5,a5,255
    80018816:	cf99                	beqz	a5,80018834 <minix3_list_dir+0x4c>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    80018818:	f5c42703          	lw	a4,-164(s0)
    8001881c:	f5c42783          	lw	a5,-164(s0)
    80018820:	863a                	mv	a2,a4
    80018822:	85be                	mv	a1,a5
    80018824:	0000a517          	auipc	a0,0xa
    80018828:	ae450513          	addi	a0,a0,-1308 # 80022308 <pow10.0+0x10d8>
    8001882c:	22f000ef          	jal	ra,8001925a <warnf>
        return 0;
    80018830:	4781                	li	a5,0
    80018832:	a041                	j	800188b2 <minix3_list_dir+0xca>
    }
    Inode inode_data = minix3_get_inode(inode);
    80018834:	fa840793          	addi	a5,s0,-88
    80018838:	f5c42703          	lw	a4,-164(s0)
    8001883c:	85ba                	mv	a1,a4
    8001883e:	853e                	mv	a0,a5
    80018840:	febfd0ef          	jal	ra,8001682a <minix3_get_inode>
    debugf("Listing directory %u\n", inode);
    uint32_t entry = 0;
    80018844:	fe042623          	sw	zero,-20(s0)
    DirEntry tmp;
    while (minix3_get_dir_entry(inode, entry, &tmp)) {
    80018848:	a0b1                	j	80018894 <minix3_list_dir+0xac>
        debugf("Found entry %s at inode %u\n", tmp.name, tmp.inode);
        memcpy(entries + entry, &tmp, sizeof(DirEntry));
    8001884a:	fec46783          	lwu	a5,-20(s0)
    8001884e:	079a                	slli	a5,a5,0x6
    80018850:	f5043703          	ld	a4,-176(s0)
    80018854:	97ba                	add	a5,a5,a4
    80018856:	f6840713          	addi	a4,s0,-152
    8001885a:	04000613          	li	a2,64
    8001885e:	85ba                	mv	a1,a4
    80018860:	853e                	mv	a0,a5
    80018862:	3cb040ef          	jal	ra,8001d42c <memcpy>
        entry++;
    80018866:	fec42783          	lw	a5,-20(s0)
    8001886a:	2785                	addiw	a5,a5,1
    8001886c:	fef42623          	sw	a5,-20(s0)
        if (entry >= max_entries) {
    80018870:	fec42703          	lw	a4,-20(s0)
    80018874:	f5842783          	lw	a5,-168(s0)
    80018878:	2701                	sext.w	a4,a4
    8001887a:	2781                	sext.w	a5,a5
    8001887c:	00f76c63          	bltu	a4,a5,80018894 <minix3_list_dir+0xac>
            warnf("Too many entries in directory %u\n", inode);
    80018880:	f5c42783          	lw	a5,-164(s0)
    80018884:	85be                	mv	a1,a5
    80018886:	0000a517          	auipc	a0,0xa
    8001888a:	aaa50513          	addi	a0,a0,-1366 # 80022330 <pow10.0+0x1100>
    8001888e:	1cd000ef          	jal	ra,8001925a <warnf>
            break;
    80018892:	a831                	j	800188ae <minix3_list_dir+0xc6>
    while (minix3_get_dir_entry(inode, entry, &tmp)) {
    80018894:	f6840693          	addi	a3,s0,-152
    80018898:	fec42703          	lw	a4,-20(s0)
    8001889c:	f5c42783          	lw	a5,-164(s0)
    800188a0:	8636                	mv	a2,a3
    800188a2:	85ba                	mv	a1,a4
    800188a4:	853e                	mv	a0,a5
    800188a6:	e1dff0ef          	jal	ra,800186c2 <minix3_get_dir_entry>
    800188aa:	87aa                	mv	a5,a0
    800188ac:	ffd9                	bnez	a5,8001884a <minix3_list_dir+0x62>
        }
    }
    return entry;
    800188ae:	fec42783          	lw	a5,-20(s0)
}
    800188b2:	853e                	mv	a0,a5
    800188b4:	70aa                	ld	ra,168(sp)
    800188b6:	740a                	ld	s0,160(sp)
    800188b8:	614d                	addi	sp,sp,176
    800188ba:	8082                	ret

00000000800188bc <minix3_find_dir_entry>:
// Returns the inode number of the file with the given name in the given directory.
// If the file does not exist, return INVALID_INODE.
uint32_t minix3_find_dir_entry(uint32_t inode, char *name) {
    800188bc:	7179                	addi	sp,sp,-48
    800188be:	f406                	sd	ra,40(sp)
    800188c0:	f022                	sd	s0,32(sp)
    800188c2:	1800                	addi	s0,sp,48
    800188c4:	7379                	lui	t1,0xffffe
    800188c6:	911a                	add	sp,sp,t1
    800188c8:	872a                	mv	a4,a0
    800188ca:	77f9                	lui	a5,0xffffe
    800188cc:	ff040693          	addi	a3,s0,-16
    800188d0:	97b6                	add	a5,a5,a3
    800188d2:	feb7b023          	sd	a1,-32(a5) # ffffffffffffdfe0 <_heap_end+0xffffffff77fedfe0>
    800188d6:	77f9                	lui	a5,0xffffe
    800188d8:	ff040693          	addi	a3,s0,-16
    800188dc:	97b6                	add	a5,a5,a3
    800188de:	fee7a623          	sw	a4,-20(a5) # ffffffffffffdfec <_heap_end+0xffffffff77fedfec>
    DirEntry entries[128];
    uint32_t num_entries = minix3_list_dir(inode, entries, 128);
    800188e2:	77f9                	lui	a5,0xffffe
    800188e4:	17e1                	addi	a5,a5,-8
    800188e6:	ff040713          	addi	a4,s0,-16
    800188ea:	973e                	add	a4,a4,a5
    800188ec:	77f9                	lui	a5,0xffffe
    800188ee:	ff040693          	addi	a3,s0,-16
    800188f2:	97b6                	add	a5,a5,a3
    800188f4:	fec7a783          	lw	a5,-20(a5) # ffffffffffffdfec <_heap_end+0xffffffff77fedfec>
    800188f8:	08000613          	li	a2,128
    800188fc:	85ba                	mv	a1,a4
    800188fe:	853e                	mv	a0,a5
    80018900:	ee9ff0ef          	jal	ra,800187e8 <minix3_list_dir>
    80018904:	87aa                	mv	a5,a0
    80018906:	fef42423          	sw	a5,-24(s0)

    for (uint32_t i=0; i<num_entries; i++) {
    8001890a:	fe042623          	sw	zero,-20(s0)
    8001890e:	a0b9                	j	8001895c <minix3_find_dir_entry+0xa0>
        if (strcmp(entries[i].name, name) == 0) {
    80018910:	77f9                	lui	a5,0xffffe
    80018912:	17e1                	addi	a5,a5,-8
    80018914:	ff040713          	addi	a4,s0,-16
    80018918:	973e                	add	a4,a4,a5
    8001891a:	fec46783          	lwu	a5,-20(s0)
    8001891e:	079a                	slli	a5,a5,0x6
    80018920:	97ba                	add	a5,a5,a4
    80018922:	00478713          	addi	a4,a5,4 # ffffffffffffe004 <_heap_end+0xffffffff77fee004>
    80018926:	77f9                	lui	a5,0xffffe
    80018928:	ff040693          	addi	a3,s0,-16
    8001892c:	97b6                	add	a5,a5,a3
    8001892e:	fe07b583          	ld	a1,-32(a5) # ffffffffffffdfe0 <_heap_end+0xffffffff77fedfe0>
    80018932:	853a                	mv	a0,a4
    80018934:	687040ef          	jal	ra,8001d7ba <strcmp>
    80018938:	87aa                	mv	a5,a0
    8001893a:	ef81                	bnez	a5,80018952 <minix3_find_dir_entry+0x96>
            debugf("Found entry %s at inode %u\n", name, entries[i].inode);
            return entries[i].inode;
    8001893c:	77f9                	lui	a5,0xffffe
    8001893e:	ff040713          	addi	a4,s0,-16
    80018942:	973e                	add	a4,a4,a5
    80018944:	fec46783          	lwu	a5,-20(s0)
    80018948:	079a                	slli	a5,a5,0x6
    8001894a:	97ba                	add	a5,a5,a4
    8001894c:	ff87a783          	lw	a5,-8(a5) # ffffffffffffdff8 <_heap_end+0xffffffff77fedff8>
    80018950:	a091                	j	80018994 <minix3_find_dir_entry+0xd8>
    for (uint32_t i=0; i<num_entries; i++) {
    80018952:	fec42783          	lw	a5,-20(s0)
    80018956:	2785                	addiw	a5,a5,1
    80018958:	fef42623          	sw	a5,-20(s0)
    8001895c:	fec42703          	lw	a4,-20(s0)
    80018960:	fe842783          	lw	a5,-24(s0)
    80018964:	2701                	sext.w	a4,a4
    80018966:	2781                	sext.w	a5,a5
    80018968:	faf764e3          	bltu	a4,a5,80018910 <minix3_find_dir_entry+0x54>
        }
    }
    warnf("Could not find entry %s in inode %u\n", name, inode);
    8001896c:	77f9                	lui	a5,0xffffe
    8001896e:	ff040713          	addi	a4,s0,-16
    80018972:	97ba                	add	a5,a5,a4
    80018974:	fec7a703          	lw	a4,-20(a5) # ffffffffffffdfec <_heap_end+0xffffffff77fedfec>
    80018978:	77f9                	lui	a5,0xffffe
    8001897a:	ff040693          	addi	a3,s0,-16
    8001897e:	97b6                	add	a5,a5,a3
    80018980:	863a                	mv	a2,a4
    80018982:	fe07b583          	ld	a1,-32(a5) # ffffffffffffdfe0 <_heap_end+0xffffffff77fedfe0>
    80018986:	0000a517          	auipc	a0,0xa
    8001898a:	9d250513          	addi	a0,a0,-1582 # 80022358 <pow10.0+0x1128>
    8001898e:	0cd000ef          	jal	ra,8001925a <warnf>
    return INVALID_INODE;
    80018992:	4781                	li	a5,0
}
    80018994:	853e                	mv	a0,a5
    80018996:	6309                	lui	t1,0x2
    80018998:	911a                	add	sp,sp,t1
    8001899a:	70a2                	ld	ra,40(sp)
    8001899c:	7402                	ld	s0,32(sp)
    8001899e:	6145                	addi	sp,sp,48
    800189a0:	8082                	ret

00000000800189a2 <strcat>:

void strcat(char *dest, char *src) {
    800189a2:	7179                	addi	sp,sp,-48
    800189a4:	f422                	sd	s0,40(sp)
    800189a6:	1800                	addi	s0,sp,48
    800189a8:	fca43c23          	sd	a0,-40(s0)
    800189ac:	fcb43823          	sd	a1,-48(s0)
    uint32_t i, j;
    for (i=0; dest[i] != 0; i++) {
    800189b0:	fe042623          	sw	zero,-20(s0)
    800189b4:	a031                	j	800189c0 <strcat+0x1e>
    800189b6:	fec42783          	lw	a5,-20(s0)
    800189ba:	2785                	addiw	a5,a5,1
    800189bc:	fef42623          	sw	a5,-20(s0)
    800189c0:	fec46783          	lwu	a5,-20(s0)
    800189c4:	fd843703          	ld	a4,-40(s0)
    800189c8:	97ba                	add	a5,a5,a4
    800189ca:	0007c783          	lbu	a5,0(a5)
    800189ce:	f7e5                	bnez	a5,800189b6 <strcat+0x14>
    }
    for (j=0; src[j] != 0; j++) {
    800189d0:	fe042423          	sw	zero,-24(s0)
    800189d4:	a815                	j	80018a08 <strcat+0x66>
        dest[i + j] = src[j];
    800189d6:	fe846783          	lwu	a5,-24(s0)
    800189da:	fd043703          	ld	a4,-48(s0)
    800189de:	973e                	add	a4,a4,a5
    800189e0:	fec42683          	lw	a3,-20(s0)
    800189e4:	fe842783          	lw	a5,-24(s0)
    800189e8:	9fb5                	addw	a5,a5,a3
    800189ea:	2781                	sext.w	a5,a5
    800189ec:	1782                	slli	a5,a5,0x20
    800189ee:	9381                	srli	a5,a5,0x20
    800189f0:	fd843683          	ld	a3,-40(s0)
    800189f4:	97b6                	add	a5,a5,a3
    800189f6:	00074703          	lbu	a4,0(a4)
    800189fa:	00e78023          	sb	a4,0(a5)
    for (j=0; src[j] != 0; j++) {
    800189fe:	fe842783          	lw	a5,-24(s0)
    80018a02:	2785                	addiw	a5,a5,1
    80018a04:	fef42423          	sw	a5,-24(s0)
    80018a08:	fe846783          	lwu	a5,-24(s0)
    80018a0c:	fd043703          	ld	a4,-48(s0)
    80018a10:	97ba                	add	a5,a5,a4
    80018a12:	0007c783          	lbu	a5,0(a5)
    80018a16:	f3e1                	bnez	a5,800189d6 <strcat+0x34>
    }
    dest[i + j] = 0;
    80018a18:	fec42703          	lw	a4,-20(s0)
    80018a1c:	fe842783          	lw	a5,-24(s0)
    80018a20:	9fb9                	addw	a5,a5,a4
    80018a22:	2781                	sext.w	a5,a5
    80018a24:	1782                	slli	a5,a5,0x20
    80018a26:	9381                	srli	a5,a5,0x20
    80018a28:	fd843703          	ld	a4,-40(s0)
    80018a2c:	97ba                	add	a5,a5,a4
    80018a2e:	00078023          	sb	zero,0(a5)
}
    80018a32:	0001                	nop
    80018a34:	7422                	ld	s0,40(sp)
    80018a36:	6145                	addi	sp,sp,48
    80018a38:	8082                	ret

0000000080018a3a <minix3_traverse>:

void minix3_traverse(uint32_t inode, char *root_path, void *data, uint32_t current_depth, uint32_t max_depth, void (*callback)(uint32_t inode, const char *path, char *name, void *data, uint32_t depth)) {
    80018a3a:	7109                	addi	sp,sp,-384
    80018a3c:	fe86                	sd	ra,376(sp)
    80018a3e:	faa2                	sd	s0,368(sp)
    80018a40:	f6a6                	sd	s1,360(sp)
    80018a42:	f2ca                	sd	s2,352(sp)
    80018a44:	eece                	sd	s3,344(sp)
    80018a46:	ead2                	sd	s4,336(sp)
    80018a48:	e6d6                	sd	s5,328(sp)
    80018a4a:	e2da                	sd	s6,320(sp)
    80018a4c:	fe5e                	sd	s7,312(sp)
    80018a4e:	fa62                	sd	s8,304(sp)
    80018a50:	f666                	sd	s9,296(sp)
    80018a52:	0300                	addi	s0,sp,384
    80018a54:	eab43023          	sd	a1,-352(s0)
    80018a58:	e8c43c23          	sd	a2,-360(s0)
    80018a5c:	e8f43423          	sd	a5,-376(s0)
    80018a60:	87aa                	mv	a5,a0
    80018a62:	eaf42623          	sw	a5,-340(s0)
    80018a66:	87b6                	mv	a5,a3
    80018a68:	eaf42423          	sw	a5,-344(s0)
    80018a6c:	87ba                	mv	a5,a4
    80018a6e:	e8f42a23          	sw	a5,-364(s0)
    80018a72:	878a                	mv	a5,sp
    80018a74:	84be                	mv	s1,a5
    debugf("Traversing %s: inode %u at depth %d\n", root_path, inode, current_depth);
    if (current_depth > max_depth) {
    80018a76:	ea842703          	lw	a4,-344(s0)
    80018a7a:	e9442783          	lw	a5,-364(s0)
    80018a7e:	2701                	sext.w	a4,a4
    80018a80:	2781                	sext.w	a5,a5
    80018a82:	24e7e163          	bltu	a5,a4,80018cc4 <minix3_traverse+0x28a>
        return;
    }
    if (!minix3_has_inode(inode)) {
    80018a86:	eac42783          	lw	a5,-340(s0)
    80018a8a:	853e                	mv	a0,a5
    80018a8c:	c07fd0ef          	jal	ra,80016692 <minix3_has_inode>
    80018a90:	87aa                	mv	a5,a0
    80018a92:	0017c793          	xori	a5,a5,1
    80018a96:	0ff7f793          	andi	a5,a5,255
    80018a9a:	cb99                	beqz	a5,80018ab0 <minix3_traverse+0x76>
        warnf("Inode %u does not exist\n", inode);
    80018a9c:	eac42783          	lw	a5,-340(s0)
    80018aa0:	85be                	mv	a1,a5
    80018aa2:	0000a517          	auipc	a0,0xa
    80018aa6:	8de50513          	addi	a0,a0,-1826 # 80022380 <pow10.0+0x1150>
    80018aaa:	7b0000ef          	jal	ra,8001925a <warnf>
        return;
    80018aae:	ac21                	j	80018cc6 <minix3_traverse+0x28c>
    }
    debugf("Traversing inode %u at depth %d\n", inode, current_depth);
    char name[128];
    strncpy(name, path_file_name(root_path), sizeof(name));
    80018ab0:	ea043503          	ld	a0,-352(s0)
    80018ab4:	6d4040ef          	jal	ra,8001d188 <path_file_name>
    80018ab8:	872a                	mv	a4,a0
    80018aba:	ef840793          	addi	a5,s0,-264
    80018abe:	08000613          	li	a2,128
    80018ac2:	85ba                	mv	a1,a4
    80018ac4:	853e                	mv	a0,a5
    80018ac6:	086050ef          	jal	ra,8001db4c <strncpy>
    if (!minix3_is_dir(inode)) {
    80018aca:	eac42783          	lw	a5,-340(s0)
    80018ace:	853e                	mv	a0,a5
    80018ad0:	fe3fd0ef          	jal	ra,80016ab2 <minix3_is_dir>
    80018ad4:	87aa                	mv	a5,a0
    80018ad6:	0017c793          	xori	a5,a5,1
    80018ada:	0ff7f793          	andi	a5,a5,255
    80018ade:	c385                	beqz	a5,80018afe <minix3_traverse+0xc4>
        debugf("Not a directory\n");
        callback(inode, root_path, name, data, current_depth);
    80018ae0:	ea842703          	lw	a4,-344(s0)
    80018ae4:	ef840613          	addi	a2,s0,-264
    80018ae8:	eac42783          	lw	a5,-340(s0)
    80018aec:	e8843803          	ld	a6,-376(s0)
    80018af0:	e9843683          	ld	a3,-360(s0)
    80018af4:	ea043583          	ld	a1,-352(s0)
    80018af8:	853e                	mv	a0,a5
    80018afa:	9802                	jalr	a6
        return;
    80018afc:	a2e9                	j	80018cc6 <minix3_traverse+0x28c>
    } else {
        debugf("Is a directory\n");
    }

    Inode inode_data = minix3_get_inode(inode);
    80018afe:	eb840793          	addi	a5,s0,-328
    80018b02:	eac42703          	lw	a4,-340(s0)
    80018b06:	85ba                	mv	a1,a4
    80018b08:	853e                	mv	a0,a5
    80018b0a:	d21fd0ef          	jal	ra,8001682a <minix3_get_inode>
    debug_inode(inode);
    80018b0e:	eac42783          	lw	a5,-340(s0)
    80018b12:	853e                	mv	a0,a5
    80018b14:	d22fd0ef          	jal	ra,80016036 <debug_inode>
    uint32_t max_entries = minix3_get_zone_size() / sizeof(DirEntry);
    80018b18:	8d7fd0ef          	jal	ra,800163ee <minix3_get_zone_size>
    80018b1c:	87aa                	mv	a5,a0
    80018b1e:	0067d79b          	srliw	a5,a5,0x6
    80018b22:	17c2                	slli	a5,a5,0x30
    80018b24:	93c1                	srli	a5,a5,0x30
    80018b26:	f8f42c23          	sw	a5,-104(s0)
    debugf("Max entries: %u\n", max_entries);
    DirEntry entries[max_entries];
    80018b2a:	f9842783          	lw	a5,-104(s0)
    80018b2e:	02079713          	slli	a4,a5,0x20
    80018b32:	9301                	srli	a4,a4,0x20
    80018b34:	177d                	addi	a4,a4,-1
    80018b36:	f8e43823          	sd	a4,-112(s0)
    80018b3a:	02079713          	slli	a4,a5,0x20
    80018b3e:	9301                	srli	a4,a4,0x20
    80018b40:	8c3a                	mv	s8,a4
    80018b42:	4c81                	li	s9,0
    80018b44:	037c5713          	srli	a4,s8,0x37
    80018b48:	009c9a93          	slli	s5,s9,0x9
    80018b4c:	01576ab3          	or	s5,a4,s5
    80018b50:	009c1a13          	slli	s4,s8,0x9
    80018b54:	02079713          	slli	a4,a5,0x20
    80018b58:	9301                	srli	a4,a4,0x20
    80018b5a:	8b3a                	mv	s6,a4
    80018b5c:	4b81                	li	s7,0
    80018b5e:	037b5713          	srli	a4,s6,0x37
    80018b62:	009b9993          	slli	s3,s7,0x9
    80018b66:	013769b3          	or	s3,a4,s3
    80018b6a:	009b1913          	slli	s2,s6,0x9
    80018b6e:	1782                	slli	a5,a5,0x20
    80018b70:	9381                	srli	a5,a5,0x20
    80018b72:	079a                	slli	a5,a5,0x6
    80018b74:	07bd                	addi	a5,a5,15
    80018b76:	8391                	srli	a5,a5,0x4
    80018b78:	0792                	slli	a5,a5,0x4
    80018b7a:	40f10133          	sub	sp,sp,a5
    80018b7e:	878a                	mv	a5,sp
    80018b80:	078d                	addi	a5,a5,3
    80018b82:	8389                	srli	a5,a5,0x2
    80018b84:	078a                	slli	a5,a5,0x2
    80018b86:	f8f43423          	sd	a5,-120(s0)
    debugf("Allocated entries\n");
    uint32_t num_entries = minix3_list_dir(inode, entries, max_entries);
    80018b8a:	f9842703          	lw	a4,-104(s0)
    80018b8e:	eac42783          	lw	a5,-340(s0)
    80018b92:	863a                	mv	a2,a4
    80018b94:	f8843583          	ld	a1,-120(s0)
    80018b98:	853e                	mv	a0,a5
    80018b9a:	c4fff0ef          	jal	ra,800187e8 <minix3_list_dir>
    80018b9e:	87aa                	mv	a5,a0
    80018ba0:	f8f42223          	sw	a5,-124(s0)
    debugf("Found %u entries\n", num_entries);

    char *path = kmalloc(1024);
    80018ba4:	40000513          	li	a0,1024
    80018ba8:	8eefb0ef          	jal	ra,80013c96 <kmalloc>
    80018bac:	f6a43c23          	sd	a0,-136(s0)
    callback(inode, root_path, name, data, current_depth);
    80018bb0:	ea842703          	lw	a4,-344(s0)
    80018bb4:	ef840613          	addi	a2,s0,-264
    80018bb8:	eac42783          	lw	a5,-340(s0)
    80018bbc:	e8843803          	ld	a6,-376(s0)
    80018bc0:	e9843683          	ld	a3,-360(s0)
    80018bc4:	ea043583          	ld	a1,-352(s0)
    80018bc8:	853e                	mv	a0,a5
    80018bca:	9802                	jalr	a6
    for (uint32_t i=0; i<num_entries; i++) {
    80018bcc:	f8042e23          	sw	zero,-100(s0)
    80018bd0:	a8e9                	j	80018caa <minix3_traverse+0x270>
        if (entries[i].inode == INVALID_INODE) {
    80018bd2:	f8843703          	ld	a4,-120(s0)
    80018bd6:	f9c46783          	lwu	a5,-100(s0)
    80018bda:	079a                	slli	a5,a5,0x6
    80018bdc:	97ba                	add	a5,a5,a4
    80018bde:	439c                	lw	a5,0(a5)
    80018be0:	cfcd                	beqz	a5,80018c9a <minix3_traverse+0x260>
            continue;
        }
        strncpy(name, entries[i].name, sizeof(name));
    80018be2:	f9c46783          	lwu	a5,-100(s0)
    80018be6:	079a                	slli	a5,a5,0x6
    80018be8:	f8843703          	ld	a4,-120(s0)
    80018bec:	97ba                	add	a5,a5,a4
    80018bee:	00478713          	addi	a4,a5,4
    80018bf2:	ef840793          	addi	a5,s0,-264
    80018bf6:	08000613          	li	a2,128
    80018bfa:	85ba                	mv	a1,a4
    80018bfc:	853e                	mv	a0,a5
    80018bfe:	74f040ef          	jal	ra,8001db4c <strncpy>
        //         name[j] = 0;
        //         break;
        //     }
        //     name[j] = entries[i].name[j];
        // }
        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) {
    80018c02:	ef840793          	addi	a5,s0,-264
    80018c06:	00009597          	auipc	a1,0x9
    80018c0a:	79a58593          	addi	a1,a1,1946 # 800223a0 <pow10.0+0x1170>
    80018c0e:	853e                	mv	a0,a5
    80018c10:	3ab040ef          	jal	ra,8001d7ba <strcmp>
    80018c14:	87aa                	mv	a5,a0
    80018c16:	c7c1                	beqz	a5,80018c9e <minix3_traverse+0x264>
    80018c18:	ef840793          	addi	a5,s0,-264
    80018c1c:	00009597          	auipc	a1,0x9
    80018c20:	78c58593          	addi	a1,a1,1932 # 800223a8 <pow10.0+0x1178>
    80018c24:	853e                	mv	a0,a5
    80018c26:	395040ef          	jal	ra,8001d7ba <strcmp>
    80018c2a:	87aa                	mv	a5,a0
    80018c2c:	cbad                	beqz	a5,80018c9e <minix3_traverse+0x264>
            continue;
        }

        strcpy(path, root_path);
    80018c2e:	ea043583          	ld	a1,-352(s0)
    80018c32:	f7843503          	ld	a0,-136(s0)
    80018c36:	6c1040ef          	jal	ra,8001daf6 <strcpy>
        if (strcmp(path, "/") != 0) {
    80018c3a:	00009597          	auipc	a1,0x9
    80018c3e:	37658593          	addi	a1,a1,886 # 80021fb0 <pow10.0+0xd80>
    80018c42:	f7843503          	ld	a0,-136(s0)
    80018c46:	375040ef          	jal	ra,8001d7ba <strcmp>
    80018c4a:	87aa                	mv	a5,a0
    80018c4c:	cb89                	beqz	a5,80018c5e <minix3_traverse+0x224>
            strcat(path, "/");
    80018c4e:	00009597          	auipc	a1,0x9
    80018c52:	36258593          	addi	a1,a1,866 # 80021fb0 <pow10.0+0xd80>
    80018c56:	f7843503          	ld	a0,-136(s0)
    80018c5a:	d49ff0ef          	jal	ra,800189a2 <strcat>
        }
        strcat(path, name);
    80018c5e:	ef840793          	addi	a5,s0,-264
    80018c62:	85be                	mv	a1,a5
    80018c64:	f7843503          	ld	a0,-136(s0)
    80018c68:	d3bff0ef          	jal	ra,800189a2 <strcat>

        minix3_traverse(entries[i].inode, path, data, current_depth + 1, max_depth, callback);
    80018c6c:	f8843703          	ld	a4,-120(s0)
    80018c70:	f9c46783          	lwu	a5,-100(s0)
    80018c74:	079a                	slli	a5,a5,0x6
    80018c76:	97ba                	add	a5,a5,a4
    80018c78:	4388                	lw	a0,0(a5)
    80018c7a:	ea842783          	lw	a5,-344(s0)
    80018c7e:	2785                	addiw	a5,a5,1
    80018c80:	0007869b          	sext.w	a3,a5
    80018c84:	e9442703          	lw	a4,-364(s0)
    80018c88:	e8843783          	ld	a5,-376(s0)
    80018c8c:	e9843603          	ld	a2,-360(s0)
    80018c90:	f7843583          	ld	a1,-136(s0)
    80018c94:	da7ff0ef          	jal	ra,80018a3a <minix3_traverse>
    80018c98:	a021                	j	80018ca0 <minix3_traverse+0x266>
            continue;
    80018c9a:	0001                	nop
    80018c9c:	a011                	j	80018ca0 <minix3_traverse+0x266>
            continue;
    80018c9e:	0001                	nop
    for (uint32_t i=0; i<num_entries; i++) {
    80018ca0:	f9c42783          	lw	a5,-100(s0)
    80018ca4:	2785                	addiw	a5,a5,1
    80018ca6:	f8f42e23          	sw	a5,-100(s0)
    80018caa:	f9c42703          	lw	a4,-100(s0)
    80018cae:	f8442783          	lw	a5,-124(s0)
    80018cb2:	2701                	sext.w	a4,a4
    80018cb4:	2781                	sext.w	a5,a5
    80018cb6:	f0f76ee3          	bltu	a4,a5,80018bd2 <minix3_traverse+0x198>
    }

    kfree(path);
    80018cba:	f7843503          	ld	a0,-136(s0)
    80018cbe:	820fb0ef          	jal	ra,80013cde <kfree>
    return;
    80018cc2:	a011                	j	80018cc6 <minix3_traverse+0x28c>
        return;
    80018cc4:	0001                	nop
    80018cc6:	8126                	mv	sp,s1
}
    80018cc8:	e8040113          	addi	sp,s0,-384
    80018ccc:	70f6                	ld	ra,376(sp)
    80018cce:	7456                	ld	s0,368(sp)
    80018cd0:	74b6                	ld	s1,360(sp)
    80018cd2:	7916                	ld	s2,352(sp)
    80018cd4:	69f6                	ld	s3,344(sp)
    80018cd6:	6a56                	ld	s4,336(sp)
    80018cd8:	6ab6                	ld	s5,328(sp)
    80018cda:	6b16                	ld	s6,320(sp)
    80018cdc:	7bf2                	ld	s7,312(sp)
    80018cde:	7c52                	ld	s8,304(sp)
    80018ce0:	7cb2                	ld	s9,296(sp)
    80018ce2:	6119                	addi	sp,sp,384
    80018ce4:	8082                	ret

0000000080018ce6 <process_new>:
#define STACK_PAGES 2
#define STACK_SIZE  (STACK_PAGES * PAGE_SIZE)
#define STACK_TOP   0xfffffffc0ffee000UL

struct process *process_new(process_mode mode)
{
    80018ce6:	715d                	addi	sp,sp,-80
    80018ce8:	e486                	sd	ra,72(sp)
    80018cea:	e0a2                	sd	s0,64(sp)
    80018cec:	0880                	addi	s0,sp,80
    80018cee:	87aa                	mv	a5,a0
    80018cf0:	faf42e23          	sw	a5,-68(s0)
    struct process *p       = (struct process *)kzalloc(sizeof(*p));
    80018cf4:	29000593          	li	a1,656
    80018cf8:	4505                	li	a0,1
    80018cfa:	fbdfa0ef          	jal	ra,80013cb6 <kcalloc>
    80018cfe:	fea43023          	sd	a0,-32(s0)

    p->hart                 = -1U;
    80018d02:	fe043783          	ld	a5,-32(s0)
    80018d06:	577d                	li	a4,-1
    80018d08:	c3d8                	sw	a4,4(a5)
    p->ptable               = mmu_table_create();
    80018d0a:	8dcfb0ef          	jal	ra,80013de6 <mmu_table_create>
    80018d0e:	872a                	mv	a4,a0
    80018d10:	fe043783          	ld	a5,-32(s0)
    80018d14:	26e7bc23          	sd	a4,632(a5)
    p->state                = PS_WAITING;
    80018d18:	fe043783          	ld	a5,-32(s0)
    80018d1c:	4705                	li	a4,1
    80018d1e:	c7d8                	sw	a4,12(a5)
    // p->pid               = fill_in_with_unique_pid

    // Set the trap frame and create all necessary structures.
    // p->frame.sepc = filled_in_by_ELF_loader
    p->frame.sstatus        = SSTATUS_SPP_BOOL(mode) | SSTATUS_FS_INITIAL | SSTATUS_SPIE;
    80018d20:	fbc42783          	lw	a5,-68(s0)
    80018d24:	2781                	sext.w	a5,a5
    80018d26:	c789                	beqz	a5,80018d30 <process_new+0x4a>
    80018d28:	6789                	lui	a5,0x2
    80018d2a:	12078793          	addi	a5,a5,288 # 2120 <i+0x2100>
    80018d2e:	a021                	j	80018d36 <process_new+0x50>
    80018d30:	6789                	lui	a5,0x2
    80018d32:	02078793          	addi	a5,a5,32 # 2020 <i+0x2000>
    80018d36:	fe043703          	ld	a4,-32(s0)
    80018d3a:	24f73023          	sd	a5,576(a4)
    p->frame.sie            = SIE_SEIE | SIE_SSIE | SIE_STIE;
    80018d3e:	fe043783          	ld	a5,-32(s0)
    80018d42:	22200713          	li	a4,546
    80018d46:	24e7b423          	sd	a4,584(a5)
    p->frame.satp           = SATP(p->ptable, p->pid);
    80018d4a:	fe043783          	ld	a5,-32(s0)
    80018d4e:	2787b783          	ld	a5,632(a5)
    80018d52:	00c7d713          	srli	a4,a5,0xc
    80018d56:	57fd                	li	a5,-1
    80018d58:	83d1                	srli	a5,a5,0x14
    80018d5a:	8f7d                	and	a4,a4,a5
    80018d5c:	fe043783          	ld	a5,-32(s0)
    80018d60:	0007d783          	lhu	a5,0(a5)
    80018d64:	17b2                	slli	a5,a5,0x2c
    80018d66:	8f5d                	or	a4,a4,a5
    80018d68:	57fd                	li	a5,-1
    80018d6a:	17fe                	slli	a5,a5,0x3f
    80018d6c:	8f5d                	or	a4,a4,a5
    80018d6e:	fe043783          	ld	a5,-32(s0)
    80018d72:	24e7b823          	sd	a4,592(a5)
    p->frame.sscratch       = (unsigned long)&p->frame;
    80018d76:	fe043783          	ld	a5,-32(s0)
    80018d7a:	03878793          	addi	a5,a5,56
    80018d7e:	873e                	mv	a4,a5
    80018d80:	fe043783          	ld	a5,-32(s0)
    80018d84:	24e7bc23          	sd	a4,600(a5)
    p->frame.stvec          = trampoline_trap_start;
    80018d88:	0000a797          	auipc	a5,0xa
    80018d8c:	61c78793          	addi	a5,a5,1564 # 800233a4 <trampoline_trap_start>
    80018d90:	6398                	ld	a4,0(a5)
    80018d92:	fe043783          	ld	a5,-32(s0)
    80018d96:	26e7b023          	sd	a4,608(a5)
    p->frame.trap_satp      = SATP_KERNEL;
    80018d9a:	00007797          	auipc	a5,0x7
    80018d9e:	26678793          	addi	a5,a5,614 # 80020000 <kernel_mmu_table>
    80018da2:	639c                	ld	a5,0(a5)
    80018da4:	00c7d713          	srli	a4,a5,0xc
    80018da8:	57fd                	li	a5,-1
    80018daa:	83d1                	srli	a5,a5,0x14
    80018dac:	8f7d                	and	a4,a4,a5
    80018dae:	8ffff7b7          	lui	a5,0x8ffff
    80018db2:	1782                	slli	a5,a5,0x20
    80018db4:	8f5d                	or	a4,a4,a5
    80018db6:	fe043783          	ld	a5,-32(s0)
    80018dba:	26e7b423          	sd	a4,616(a5) # ffffffff8ffff268 <_heap_end+0xffffffff07fef268>
    // p->frame.trap_stack = filled_in_by_SCHEDULER

    p->fds = vector_new_with_capacity(5);
    80018dbe:	4515                	li	a0,5
    80018dc0:	02e050ef          	jal	ra,8001ddee <vector_new_with_capacity>
    80018dc4:	872a                	mv	a4,a0
    80018dc6:	fe043783          	ld	a5,-32(s0)
    80018dca:	28e7b423          	sd	a4,648(a5)
    p->pages = list_new();
    80018dce:	2e8030ef          	jal	ra,8001c0b6 <list_new>
    80018dd2:	872a                	mv	a4,a0
    80018dd4:	fe043783          	ld	a5,-32(s0)
    80018dd8:	28e7b023          	sd	a4,640(a5)

    // We need to keep track of the stack itself in the kernel, so we can free it
    // later, but the user process will interact with the stack via the SP register.
    p->frame.xregs[XREG_SP] = STACK_TOP + STACK_SIZE;
    80018ddc:	fe043783          	ld	a5,-32(s0)
    80018de0:	c0fff737          	lui	a4,0xc0fff
    80018de4:	0712                	slli	a4,a4,0x4
    80018de6:	e7b8                	sd	a4,72(a5)
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    80018de8:	fe043423          	sd	zero,-24(s0)
    80018dec:	a085                	j	80018e4c <process_new+0x166>
        void *stack = page_zalloc();
    80018dee:	4505                	li	a0,1
    80018df0:	55a020ef          	jal	ra,8001b34a <page_znalloc>
    80018df4:	fca43423          	sd	a0,-56(s0)
        list_add_ptr(p->pages, stack);
    80018df8:	fe043783          	ld	a5,-32(s0)
    80018dfc:	2807b783          	ld	a5,640(a5)
    80018e00:	fc843703          	ld	a4,-56(s0)
    80018e04:	85ba                	mv	a1,a4
    80018e06:	853e                	mv	a0,a5
    80018e08:	2de030ef          	jal	ra,8001c0e6 <list_add>
        mmu_map(p->ptable, STACK_TOP + PAGE_SIZE * i, (unsigned long)stack,
    80018e0c:	fe043783          	ld	a5,-32(s0)
    80018e10:	2787b503          	ld	a0,632(a5)
    80018e14:	fe843783          	ld	a5,-24(s0)
    80018e18:	00c79713          	slli	a4,a5,0xc
    80018e1c:	ffe087b7          	lui	a5,0xffe08
    80018e20:	17dd                	addi	a5,a5,-9
    80018e22:	07b6                	slli	a5,a5,0xd
    80018e24:	00f705b3          	add	a1,a4,a5
    80018e28:	fc843603          	ld	a2,-56(s0)
    80018e2c:	fbc42783          	lw	a5,-68(s0)
    80018e30:	2781                	sext.w	a5,a5
    80018e32:	e399                	bnez	a5,80018e38 <process_new+0x152>
    80018e34:	47c1                	li	a5,16
    80018e36:	a011                	j	80018e3a <process_new+0x154>
    80018e38:	4799                	li	a5,6
    80018e3a:	873e                	mv	a4,a5
    80018e3c:	4681                	li	a3,0
    80018e3e:	802fb0ef          	jal	ra,80013e40 <mmu_map>
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    80018e42:	fe843783          	ld	a5,-24(s0)
    80018e46:	0785                	addi	a5,a5,1
    80018e48:	fef43423          	sd	a5,-24(s0)
    80018e4c:	fe843703          	ld	a4,-24(s0)
    80018e50:	4785                	li	a5,1
    80018e52:	f8e7fee3          	bgeu	a5,a4,80018dee <process_new+0x108>
    }

    // We need to map certain kernel portions into the user's page table. Notice
    // that the PB_USER is NOT set, but it needs to be there because we need to execute
    // the trap/start instructions while using the user's page table until we change SATP.
    unsigned long trans_trampoline_start = mmu_translate(kernel_mmu_table, trampoline_thread_start);
    80018e56:	00007797          	auipc	a5,0x7
    80018e5a:	1aa78793          	addi	a5,a5,426 # 80020000 <kernel_mmu_table>
    80018e5e:	6398                	ld	a4,0(a5)
    80018e60:	0000a797          	auipc	a5,0xa
    80018e64:	52c78793          	addi	a5,a5,1324 # 8002338c <trampoline_thread_start>
    80018e68:	639c                	ld	a5,0(a5)
    80018e6a:	85be                	mv	a1,a5
    80018e6c:	853a                	mv	a0,a4
    80018e6e:	9fcfb0ef          	jal	ra,8001406a <mmu_translate>
    80018e72:	fca43c23          	sd	a0,-40(s0)
    unsigned long trans_trampoline_trap  = mmu_translate(kernel_mmu_table, trampoline_trap_start);
    80018e76:	00007797          	auipc	a5,0x7
    80018e7a:	18a78793          	addi	a5,a5,394 # 80020000 <kernel_mmu_table>
    80018e7e:	6398                	ld	a4,0(a5)
    80018e80:	0000a797          	auipc	a5,0xa
    80018e84:	52478793          	addi	a5,a5,1316 # 800233a4 <trampoline_trap_start>
    80018e88:	639c                	ld	a5,0(a5)
    80018e8a:	85be                	mv	a1,a5
    80018e8c:	853a                	mv	a0,a4
    80018e8e:	9dcfb0ef          	jal	ra,8001406a <mmu_translate>
    80018e92:	fca43823          	sd	a0,-48(s0)
    mmu_map(p->ptable, trampoline_thread_start, trans_trampoline_start, MMU_LEVEL_4K,
    80018e96:	fe043783          	ld	a5,-32(s0)
    80018e9a:	2787b503          	ld	a0,632(a5)
    80018e9e:	0000a797          	auipc	a5,0xa
    80018ea2:	4ee78793          	addi	a5,a5,1262 # 8002338c <trampoline_thread_start>
    80018ea6:	639c                	ld	a5,0(a5)
    80018ea8:	4729                	li	a4,10
    80018eaa:	4681                	li	a3,0
    80018eac:	fd843603          	ld	a2,-40(s0)
    80018eb0:	85be                	mv	a1,a5
    80018eb2:	f8ffa0ef          	jal	ra,80013e40 <mmu_map>
            PB_READ | PB_EXECUTE);
    mmu_map(p->ptable, trampoline_trap_start, trans_trampoline_trap, MMU_LEVEL_4K,
    80018eb6:	fe043783          	ld	a5,-32(s0)
    80018eba:	2787b503          	ld	a0,632(a5)
    80018ebe:	0000a797          	auipc	a5,0xa
    80018ec2:	4e678793          	addi	a5,a5,1254 # 800233a4 <trampoline_trap_start>
    80018ec6:	639c                	ld	a5,0(a5)
    80018ec8:	4729                	li	a4,10
    80018eca:	4681                	li	a3,0
    80018ecc:	fd043603          	ld	a2,-48(s0)
    80018ed0:	85be                	mv	a1,a5
    80018ed2:	f6ffa0ef          	jal	ra,80013e40 <mmu_map>
            PB_READ | PB_EXECUTE);

    SFENCE_ASID(p->pid);
    80018ed6:	fe043783          	ld	a5,-32(s0)
    80018eda:	0007d783          	lhu	a5,0(a5)
    80018ede:	12f00073          	sfence.vma	zero,a5

    return p;
    80018ee2:	fe043783          	ld	a5,-32(s0)
}
    80018ee6:	853e                	mv	a0,a5
    80018ee8:	60a6                	ld	ra,72(sp)
    80018eea:	6406                	ld	s0,64(sp)
    80018eec:	6161                	addi	sp,sp,80
    80018eee:	8082                	ret

0000000080018ef0 <process_free>:

int process_free(struct process *p)
{
    80018ef0:	7179                	addi	sp,sp,-48
    80018ef2:	f406                	sd	ra,40(sp)
    80018ef4:	f022                	sd	s0,32(sp)
    80018ef6:	1800                	addi	s0,sp,48
    80018ef8:	fca43c23          	sd	a0,-40(s0)
    struct ListElem *e;
    unsigned int i;

    if (!p || !ON_HART_NONE(p)) {
    80018efc:	fd843783          	ld	a5,-40(s0)
    80018f00:	cb81                	beqz	a5,80018f10 <process_free+0x20>
    80018f02:	fd843783          	ld	a5,-40(s0)
    80018f06:	43dc                	lw	a5,4(a5)
    80018f08:	873e                	mv	a4,a5
    80018f0a:	57fd                	li	a5,-1
    80018f0c:	00f70463          	beq	a4,a5,80018f14 <process_free+0x24>
        // Process is invalid or running somewhere, or this is stale.
        return -1;
    80018f10:	57fd                	li	a5,-1
    80018f12:	a8d1                	j	80018fe6 <process_free+0xf6>
    }

    // Free all resources allocated to the process.

    if (p->ptable) {
    80018f14:	fd843783          	ld	a5,-40(s0)
    80018f18:	2787b783          	ld	a5,632(a5)
    80018f1c:	cf91                	beqz	a5,80018f38 <process_free+0x48>
        mmu_free(p->ptable);
    80018f1e:	fd843783          	ld	a5,-40(s0)
    80018f22:	2787b783          	ld	a5,632(a5)
    80018f26:	853e                	mv	a0,a5
    80018f28:	8bcfb0ef          	jal	ra,80013fe4 <mmu_free>
        SFENCE_ASID(p->pid);
    80018f2c:	fd843783          	ld	a5,-40(s0)
    80018f30:	0007d783          	lhu	a5,0(a5)
    80018f34:	12f00073          	sfence.vma	zero,a5
    }

    if (p->pages) {
    80018f38:	fd843783          	ld	a5,-40(s0)
    80018f3c:	2807b783          	ld	a5,640(a5)
    80018f40:	cbb9                	beqz	a5,80018f96 <process_free+0xa6>
        list_for_each(p->pages, e) {
    80018f42:	fd843783          	ld	a5,-40(s0)
    80018f46:	2807b783          	ld	a5,640(a5)
    80018f4a:	853e                	mv	a0,a5
    80018f4c:	5ba030ef          	jal	ra,8001c506 <list_elem_start_ascending>
    80018f50:	fea43423          	sd	a0,-24(s0)
    80018f54:	a839                	j	80018f72 <process_free+0x82>
            page_free(list_elem_value_ptr(e));
    80018f56:	fe843503          	ld	a0,-24(s0)
    80018f5a:	60c030ef          	jal	ra,8001c566 <list_elem_value>
    80018f5e:	87aa                	mv	a5,a0
    80018f60:	853e                	mv	a0,a5
    80018f62:	484020ef          	jal	ra,8001b3e6 <page_free>
        list_for_each(p->pages, e) {
    80018f66:	fe843503          	ld	a0,-24(s0)
    80018f6a:	5e4030ef          	jal	ra,8001c54e <list_elem_prev>
    80018f6e:	fea43423          	sd	a0,-24(s0)
    80018f72:	fd843783          	ld	a5,-40(s0)
    80018f76:	2807b783          	ld	a5,640(a5)
    80018f7a:	fe843583          	ld	a1,-24(s0)
    80018f7e:	853e                	mv	a0,a5
    80018f80:	4f8030ef          	jal	ra,8001c478 <list_elem_valid>
    80018f84:	87aa                	mv	a5,a0
    80018f86:	fbe1                	bnez	a5,80018f56 <process_free+0x66>
        }
        list_free(p->pages);
    80018f88:	fd843783          	ld	a5,-40(s0)
    80018f8c:	2807b783          	ld	a5,640(a5)
    80018f90:	853e                	mv	a0,a5
    80018f92:	48e030ef          	jal	ra,8001c420 <list_free>
    }

    if (p->fds) {
    80018f96:	fd843783          	ld	a5,-40(s0)
    80018f9a:	2887b783          	ld	a5,648(a5)
    80018f9e:	cf9d                	beqz	a5,80018fdc <process_free+0xec>
        for (i = 0;i < vector_size(p->fds);i += 1) {
    80018fa0:	fe042223          	sw	zero,-28(s0)
    80018fa4:	a031                	j	80018fb0 <process_free+0xc0>
    80018fa6:	fe442783          	lw	a5,-28(s0)
    80018faa:	2785                	addiw	a5,a5,1
    80018fac:	fef42223          	sw	a5,-28(s0)
    80018fb0:	fd843783          	ld	a5,-40(s0)
    80018fb4:	2887b783          	ld	a5,648(a5)
    80018fb8:	853e                	mv	a0,a5
    80018fba:	722050ef          	jal	ra,8001e6dc <vector_size>
    80018fbe:	87aa                	mv	a5,a0
    80018fc0:	0007871b          	sext.w	a4,a5
    80018fc4:	fe442783          	lw	a5,-28(s0)
    80018fc8:	2781                	sext.w	a5,a5
    80018fca:	fce7eee3          	bltu	a5,a4,80018fa6 <process_free+0xb6>
            // Clean up any file descriptor stuff here.
        }
        vector_free(p->fds);
    80018fce:	fd843783          	ld	a5,-40(s0)
    80018fd2:	2887b783          	ld	a5,648(a5)
    80018fd6:	853e                	mv	a0,a5
    80018fd8:	734050ef          	jal	ra,8001e70c <vector_free>
    }
    

    kfree(p);
    80018fdc:	fd843503          	ld	a0,-40(s0)
    80018fe0:	cfffa0ef          	jal	ra,80013cde <kfree>

    return 0;
    80018fe4:	4781                	li	a5,0
}
    80018fe6:	853e                	mv	a0,a5
    80018fe8:	70a2                	ld	ra,40(sp)
    80018fea:	7402                	ld	s0,32(sp)
    80018fec:	6145                	addi	sp,sp,48
    80018fee:	8082                	ret

0000000080018ff0 <process_run>:

bool process_run(struct process *p, unsigned int hart)
{
    80018ff0:	7179                	addi	sp,sp,-48
    80018ff2:	f406                	sd	ra,40(sp)
    80018ff4:	f022                	sd	s0,32(sp)
    80018ff6:	1800                	addi	s0,sp,48
    80018ff8:	fca43c23          	sd	a0,-40(s0)
    80018ffc:	87ae                	mv	a5,a1
    80018ffe:	fcf42a23          	sw	a5,-44(s0)
    void process_asm_run(void *frame_addr);
    unsigned int me = sbi_whoami();
    80019002:	5b4000ef          	jal	ra,800195b6 <sbi_whoami>
    80019006:	87aa                	mv	a5,a0
    80019008:	fef42623          	sw	a5,-20(s0)

    if (me == hart) {
    8001900c:	fec42703          	lw	a4,-20(s0)
    80019010:	fd442783          	lw	a5,-44(s0)
    80019014:	2701                	sext.w	a4,a4
    80019016:	2781                	sext.w	a5,a5
    80019018:	00f71b63          	bne	a4,a5,8001902e <process_run+0x3e>
        process_asm_run(&p->frame);
    8001901c:	fd843783          	ld	a5,-40(s0)
    80019020:	03878793          	addi	a5,a5,56
    80019024:	853e                	mv	a0,a5
    80019026:	74f020ef          	jal	ra,8001bf74 <process_asm_run>
        // process_asm_run should not return, but if it does
        // something went wrong.
        return false;
    8001902a:	4781                	li	a5,0
    8001902c:	a815                	j	80019060 <process_run+0x70>
    }

    return sbi_hart_start(hart, trampoline_thread_start, (unsigned long)&p->frame, p->frame.satp);
    8001902e:	0000a797          	auipc	a5,0xa
    80019032:	35e78793          	addi	a5,a5,862 # 8002338c <trampoline_thread_start>
    80019036:	6398                	ld	a4,0(a5)
    80019038:	fd843783          	ld	a5,-40(s0)
    8001903c:	03878793          	addi	a5,a5,56
    80019040:	863e                	mv	a2,a5
    80019042:	fd843783          	ld	a5,-40(s0)
    80019046:	2507b683          	ld	a3,592(a5)
    8001904a:	fd442783          	lw	a5,-44(s0)
    8001904e:	85ba                	mv	a1,a4
    80019050:	853e                	mv	a0,a5
    80019052:	43c000ef          	jal	ra,8001948e <sbi_hart_start>
    80019056:	87aa                	mv	a5,a0
    80019058:	00f037b3          	snez	a5,a5
    8001905c:	0ff7f793          	andi	a5,a5,255
}
    80019060:	853e                	mv	a0,a5
    80019062:	70a2                	ld	ra,40(sp)
    80019064:	7402                	ld	s0,32(sp)
    80019066:	6145                	addi	sp,sp,48
    80019068:	8082                	ret

000000008001906a <lgprefix>:

static bool last_was_newline = true;

static int k_log_level = 0xFFF;

static const char *lgprefix(log_type lt) {
    8001906a:	1101                	addi	sp,sp,-32
    8001906c:	ec22                	sd	s0,24(sp)
    8001906e:	1000                	addi	s0,sp,32
    80019070:	87aa                	mv	a5,a0
    80019072:	fef42623          	sw	a5,-20(s0)
    80019076:	fec42783          	lw	a5,-20(s0)
    8001907a:	0007871b          	sext.w	a4,a5
    8001907e:	47c1                	li	a5,16
    80019080:	04e7ed63          	bltu	a5,a4,800190da <lgprefix+0x70>
    80019084:	fec46783          	lwu	a5,-20(s0)
    80019088:	00279713          	slli	a4,a5,0x2
    8001908c:	00009797          	auipc	a5,0x9
    80019090:	37878793          	addi	a5,a5,888 # 80022404 <pow10.0+0x11d4>
    80019094:	97ba                	add	a5,a5,a4
    80019096:	439c                	lw	a5,0(a5)
    80019098:	0007871b          	sext.w	a4,a5
    8001909c:	00009797          	auipc	a5,0x9
    800190a0:	36878793          	addi	a5,a5,872 # 80022404 <pow10.0+0x11d4>
    800190a4:	97ba                	add	a5,a5,a4
    800190a6:	8782                	jr	a5
    switch (lt) {
        case LOG_DEBUG:
            return "[DEBUG]: ";
    800190a8:	00009797          	auipc	a5,0x9
    800190ac:	30878793          	addi	a5,a5,776 # 800223b0 <pow10.0+0x1180>
    800190b0:	a80d                	j	800190e2 <lgprefix+0x78>
        case LOG_INFO:
            return "[INFO]: ";
    800190b2:	00009797          	auipc	a5,0x9
    800190b6:	30e78793          	addi	a5,a5,782 # 800223c0 <pow10.0+0x1190>
    800190ba:	a025                	j	800190e2 <lgprefix+0x78>
        case LOG_WARN:
            return "[WARN]: ";
    800190bc:	00009797          	auipc	a5,0x9
    800190c0:	31478793          	addi	a5,a5,788 # 800223d0 <pow10.0+0x11a0>
    800190c4:	a839                	j	800190e2 <lgprefix+0x78>
        case LOG_ERROR:
            return "[ERROR]: ";
    800190c6:	00009797          	auipc	a5,0x9
    800190ca:	31a78793          	addi	a5,a5,794 # 800223e0 <pow10.0+0x11b0>
    800190ce:	a811                	j	800190e2 <lgprefix+0x78>
        case LOG_FATAL:
            return "[FATAL]: ";
    800190d0:	00009797          	auipc	a5,0x9
    800190d4:	32078793          	addi	a5,a5,800 # 800223f0 <pow10.0+0x11c0>
    800190d8:	a029                	j	800190e2 <lgprefix+0x78>
        default:
            return "";
    800190da:	00009797          	auipc	a5,0x9
    800190de:	32678793          	addi	a5,a5,806 # 80022400 <pow10.0+0x11d0>
    }
}
    800190e2:	853e                	mv	a0,a5
    800190e4:	6462                	ld	s0,24(sp)
    800190e6:	6105                	addi	sp,sp,32
    800190e8:	8082                	ret

00000000800190ea <vlogf>:

static int vlogf(log_type lt, const char *fmt, va_list args)
{
    800190ea:	7139                	addi	sp,sp,-64
    800190ec:	fc06                	sd	ra,56(sp)
    800190ee:	f822                	sd	s0,48(sp)
    800190f0:	0080                	addi	s0,sp,64
    800190f2:	87aa                	mv	a5,a0
    800190f4:	fcb43823          	sd	a1,-48(s0)
    800190f8:	fcc43423          	sd	a2,-56(s0)
    800190fc:	fcf42e23          	sw	a5,-36(s0)
    if (!(lt & k_log_level)) {
    80019100:	0000b797          	auipc	a5,0xb
    80019104:	f0878793          	addi	a5,a5,-248 # 80024008 <k_log_level>
    80019108:	439c                	lw	a5,0(a5)
    8001910a:	0007871b          	sext.w	a4,a5
    8001910e:	fdc42783          	lw	a5,-36(s0)
    80019112:	8ff9                	and	a5,a5,a4
    80019114:	2781                	sext.w	a5,a5
    80019116:	e399                	bnez	a5,8001911c <vlogf+0x32>
        return 0;
    80019118:	4781                	li	a5,0
    8001911a:	a049                	j	8001919c <vlogf+0xb2>
    }
    int printf(const char *fmt, ...);
    if (last_was_newline) {
    8001911c:	0000b797          	auipc	a5,0xb
    80019120:	ee878793          	addi	a5,a5,-280 # 80024004 <last_was_newline>
    80019124:	0007c783          	lbu	a5,0(a5)
    80019128:	cf91                	beqz	a5,80019144 <vlogf+0x5a>
        printf("%s", lgprefix(lt));
    8001912a:	fdc42783          	lw	a5,-36(s0)
    8001912e:	853e                	mv	a0,a5
    80019130:	f3bff0ef          	jal	ra,8001906a <lgprefix>
    80019134:	87aa                	mv	a5,a0
    80019136:	85be                	mv	a1,a5
    80019138:	00009517          	auipc	a0,0x9
    8001913c:	31050513          	addi	a0,a0,784 # 80022448 <pow10.0+0x1218>
    80019140:	906f90ef          	jal	ra,80012246 <printf>
    }
    for (const char *p = fmt; *p != '\0'; p++) {
    80019144:	fd043783          	ld	a5,-48(s0)
    80019148:	fef43423          	sd	a5,-24(s0)
    8001914c:	a825                	j	80019184 <vlogf+0x9a>
        if (*p == '\n') {
    8001914e:	fe843783          	ld	a5,-24(s0)
    80019152:	0007c783          	lbu	a5,0(a5)
    80019156:	873e                	mv	a4,a5
    80019158:	47a9                	li	a5,10
    8001915a:	00f71a63          	bne	a4,a5,8001916e <vlogf+0x84>
            last_was_newline = true;
    8001915e:	0000b797          	auipc	a5,0xb
    80019162:	ea678793          	addi	a5,a5,-346 # 80024004 <last_was_newline>
    80019166:	4705                	li	a4,1
    80019168:	00e78023          	sb	a4,0(a5)
    8001916c:	a039                	j	8001917a <vlogf+0x90>
        } else {
            last_was_newline = false;
    8001916e:	0000b797          	auipc	a5,0xb
    80019172:	e9678793          	addi	a5,a5,-362 # 80024004 <last_was_newline>
    80019176:	00078023          	sb	zero,0(a5)
    for (const char *p = fmt; *p != '\0'; p++) {
    8001917a:	fe843783          	ld	a5,-24(s0)
    8001917e:	0785                	addi	a5,a5,1
    80019180:	fef43423          	sd	a5,-24(s0)
    80019184:	fe843783          	ld	a5,-24(s0)
    80019188:	0007c783          	lbu	a5,0(a5)
    8001918c:	f3e9                	bnez	a5,8001914e <vlogf+0x64>
        }
    }
    int vprintf_(const char *format, va_list va);
    return vprintf_(fmt, args);
    8001918e:	fc843583          	ld	a1,-56(s0)
    80019192:	fd043503          	ld	a0,-48(s0)
    80019196:	9def90ef          	jal	ra,80012374 <vprintf_>
    8001919a:	87aa                	mv	a5,a0
}
    8001919c:	853e                	mv	a0,a5
    8001919e:	70e2                	ld	ra,56(sp)
    800191a0:	7442                	ld	s0,48(sp)
    800191a2:	6121                	addi	sp,sp,64
    800191a4:	8082                	ret

00000000800191a6 <logf>:

int logf(log_type lt, const char *fmt, ...)
{
    800191a6:	7159                	addi	sp,sp,-112
    800191a8:	fc06                	sd	ra,56(sp)
    800191aa:	f822                	sd	s0,48(sp)
    800191ac:	0080                	addi	s0,sp,64
    800191ae:	fcb43823          	sd	a1,-48(s0)
    800191b2:	e010                	sd	a2,0(s0)
    800191b4:	e414                	sd	a3,8(s0)
    800191b6:	e818                	sd	a4,16(s0)
    800191b8:	ec1c                	sd	a5,24(s0)
    800191ba:	03043023          	sd	a6,32(s0)
    800191be:	03143423          	sd	a7,40(s0)
    800191c2:	87aa                	mv	a5,a0
    800191c4:	fcf42e23          	sw	a5,-36(s0)
    va_list va;
    va_start(va, fmt);
    800191c8:	03040793          	addi	a5,s0,48
    800191cc:	fcf43423          	sd	a5,-56(s0)
    800191d0:	fc843783          	ld	a5,-56(s0)
    800191d4:	fd078793          	addi	a5,a5,-48
    800191d8:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(lt, fmt, va);
    800191dc:	fe043703          	ld	a4,-32(s0)
    800191e0:	fdc42783          	lw	a5,-36(s0)
    800191e4:	863a                	mv	a2,a4
    800191e6:	fd043583          	ld	a1,-48(s0)
    800191ea:	853e                	mv	a0,a5
    800191ec:	effff0ef          	jal	ra,800190ea <vlogf>
    800191f0:	87aa                	mv	a5,a0
    800191f2:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    800191f6:	fec42783          	lw	a5,-20(s0)
}
    800191fa:	853e                	mv	a0,a5
    800191fc:	70e2                	ld	ra,56(sp)
    800191fe:	7442                	ld	s0,48(sp)
    80019200:	6165                	addi	sp,sp,112
    80019202:	8082                	ret

0000000080019204 <debugf>:

int debugf(const char *fmt, ...)
{
    80019204:	7159                	addi	sp,sp,-112
    80019206:	f406                	sd	ra,40(sp)
    80019208:	f022                	sd	s0,32(sp)
    8001920a:	1800                	addi	s0,sp,48
    8001920c:	fca43c23          	sd	a0,-40(s0)
    80019210:	e40c                	sd	a1,8(s0)
    80019212:	e810                	sd	a2,16(s0)
    80019214:	ec14                	sd	a3,24(s0)
    80019216:	f018                	sd	a4,32(s0)
    80019218:	f41c                	sd	a5,40(s0)
    8001921a:	03043823          	sd	a6,48(s0)
    8001921e:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    80019222:	04040793          	addi	a5,s0,64
    80019226:	fcf43823          	sd	a5,-48(s0)
    8001922a:	fd043783          	ld	a5,-48(s0)
    8001922e:	fc878793          	addi	a5,a5,-56
    80019232:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_DEBUG, fmt, va);
    80019236:	fe043783          	ld	a5,-32(s0)
    8001923a:	863e                	mv	a2,a5
    8001923c:	fd843583          	ld	a1,-40(s0)
    80019240:	4509                	li	a0,2
    80019242:	ea9ff0ef          	jal	ra,800190ea <vlogf>
    80019246:	87aa                	mv	a5,a0
    80019248:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001924c:	fec42783          	lw	a5,-20(s0)
}
    80019250:	853e                	mv	a0,a5
    80019252:	70a2                	ld	ra,40(sp)
    80019254:	7402                	ld	s0,32(sp)
    80019256:	6165                	addi	sp,sp,112
    80019258:	8082                	ret

000000008001925a <warnf>:

int warnf(const char *fmt, ...)
{
    8001925a:	7159                	addi	sp,sp,-112
    8001925c:	f406                	sd	ra,40(sp)
    8001925e:	f022                	sd	s0,32(sp)
    80019260:	1800                	addi	s0,sp,48
    80019262:	fca43c23          	sd	a0,-40(s0)
    80019266:	e40c                	sd	a1,8(s0)
    80019268:	e810                	sd	a2,16(s0)
    8001926a:	ec14                	sd	a3,24(s0)
    8001926c:	f018                	sd	a4,32(s0)
    8001926e:	f41c                	sd	a5,40(s0)
    80019270:	03043823          	sd	a6,48(s0)
    80019274:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    80019278:	04040793          	addi	a5,s0,64
    8001927c:	fcf43823          	sd	a5,-48(s0)
    80019280:	fd043783          	ld	a5,-48(s0)
    80019284:	fc878793          	addi	a5,a5,-56
    80019288:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_WARN, fmt, va);
    8001928c:	fe043783          	ld	a5,-32(s0)
    80019290:	863e                	mv	a2,a5
    80019292:	fd843583          	ld	a1,-40(s0)
    80019296:	4541                	li	a0,16
    80019298:	e53ff0ef          	jal	ra,800190ea <vlogf>
    8001929c:	87aa                	mv	a5,a0
    8001929e:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    800192a2:	fec42783          	lw	a5,-20(s0)
}
    800192a6:	853e                	mv	a0,a5
    800192a8:	70a2                	ld	ra,40(sp)
    800192aa:	7402                	ld	s0,32(sp)
    800192ac:	6165                	addi	sp,sp,112
    800192ae:	8082                	ret

00000000800192b0 <textf>:

int textf(const char *fmt, ...)
{
    800192b0:	7159                	addi	sp,sp,-112
    800192b2:	f406                	sd	ra,40(sp)
    800192b4:	f022                	sd	s0,32(sp)
    800192b6:	1800                	addi	s0,sp,48
    800192b8:	fca43c23          	sd	a0,-40(s0)
    800192bc:	e40c                	sd	a1,8(s0)
    800192be:	e810                	sd	a2,16(s0)
    800192c0:	ec14                	sd	a3,24(s0)
    800192c2:	f018                	sd	a4,32(s0)
    800192c4:	f41c                	sd	a5,40(s0)
    800192c6:	03043823          	sd	a6,48(s0)
    800192ca:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    800192ce:	04040793          	addi	a5,s0,64
    800192d2:	fcf43823          	sd	a5,-48(s0)
    800192d6:	fd043783          	ld	a5,-48(s0)
    800192da:	fc878793          	addi	a5,a5,-56
    800192de:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_TEXT, fmt, va);
    800192e2:	fe043783          	ld	a5,-32(s0)
    800192e6:	863e                	mv	a2,a5
    800192e8:	fd843583          	ld	a1,-40(s0)
    800192ec:	02000513          	li	a0,32
    800192f0:	dfbff0ef          	jal	ra,800190ea <vlogf>
    800192f4:	87aa                	mv	a5,a0
    800192f6:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    800192fa:	fec42783          	lw	a5,-20(s0)
}
    800192fe:	853e                	mv	a0,a5
    80019300:	70a2                	ld	ra,40(sp)
    80019302:	7402                	ld	s0,32(sp)
    80019304:	6165                	addi	sp,sp,112
    80019306:	8082                	ret

0000000080019308 <infof>:

int infof(const char *fmt, ...)
{
    80019308:	7159                	addi	sp,sp,-112
    8001930a:	f406                	sd	ra,40(sp)
    8001930c:	f022                	sd	s0,32(sp)
    8001930e:	1800                	addi	s0,sp,48
    80019310:	fca43c23          	sd	a0,-40(s0)
    80019314:	e40c                	sd	a1,8(s0)
    80019316:	e810                	sd	a2,16(s0)
    80019318:	ec14                	sd	a3,24(s0)
    8001931a:	f018                	sd	a4,32(s0)
    8001931c:	f41c                	sd	a5,40(s0)
    8001931e:	03043823          	sd	a6,48(s0)
    80019322:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    80019326:	04040793          	addi	a5,s0,64
    8001932a:	fcf43823          	sd	a5,-48(s0)
    8001932e:	fd043783          	ld	a5,-48(s0)
    80019332:	fc878793          	addi	a5,a5,-56
    80019336:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_INFO, fmt, va);
    8001933a:	fe043783          	ld	a5,-32(s0)
    8001933e:	863e                	mv	a2,a5
    80019340:	fd843583          	ld	a1,-40(s0)
    80019344:	4511                	li	a0,4
    80019346:	da5ff0ef          	jal	ra,800190ea <vlogf>
    8001934a:	87aa                	mv	a5,a0
    8001934c:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    80019350:	fec42783          	lw	a5,-20(s0)
}
    80019354:	853e                	mv	a0,a5
    80019356:	70a2                	ld	ra,40(sp)
    80019358:	7402                	ld	s0,32(sp)
    8001935a:	6165                	addi	sp,sp,112
    8001935c:	8082                	ret

000000008001935e <fatalf>:

ATTR_NORET void fatalf(const char *fmt, ...)
{
    8001935e:	7159                	addi	sp,sp,-112
    80019360:	f406                	sd	ra,40(sp)
    80019362:	f022                	sd	s0,32(sp)
    80019364:	1800                	addi	s0,sp,48
    80019366:	fca43c23          	sd	a0,-40(s0)
    8001936a:	e40c                	sd	a1,8(s0)
    8001936c:	e810                	sd	a2,16(s0)
    8001936e:	ec14                	sd	a3,24(s0)
    80019370:	f018                	sd	a4,32(s0)
    80019372:	f41c                	sd	a5,40(s0)
    80019374:	03043823          	sd	a6,48(s0)
    80019378:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001937c:	04040793          	addi	a5,s0,64
    80019380:	fcf43823          	sd	a5,-48(s0)
    80019384:	fd043783          	ld	a5,-48(s0)
    80019388:	fc878793          	addi	a5,a5,-56
    8001938c:	fef43423          	sd	a5,-24(s0)
    vlogf(LOG_FATAL, fmt, va);
    80019390:	fe843783          	ld	a5,-24(s0)
    80019394:	863e                	mv	a2,a5
    80019396:	fd843583          	ld	a1,-40(s0)
    8001939a:	4521                	li	a0,8
    8001939c:	d4fff0ef          	jal	ra,800190ea <vlogf>
    va_end(va);

    CSR_CLEAR("sstatus");
    800193a0:	10001073          	csrw	sstatus,zero
    WFI_LOOP();
    800193a4:	10500073          	wfi
    800193a8:	bff5                	j	800193a4 <fatalf+0x46>

00000000800193aa <klogset>:
}

void klogset(log_type lt)
{
    800193aa:	1101                	addi	sp,sp,-32
    800193ac:	ec22                	sd	s0,24(sp)
    800193ae:	1000                	addi	s0,sp,32
    800193b0:	87aa                	mv	a5,a0
    800193b2:	fef42623          	sw	a5,-20(s0)
    k_log_level |= lt;
    800193b6:	0000b797          	auipc	a5,0xb
    800193ba:	c5278793          	addi	a5,a5,-942 # 80024008 <k_log_level>
    800193be:	439c                	lw	a5,0(a5)
    800193c0:	0007871b          	sext.w	a4,a5
    800193c4:	fec42783          	lw	a5,-20(s0)
    800193c8:	8fd9                	or	a5,a5,a4
    800193ca:	2781                	sext.w	a5,a5
    800193cc:	0007871b          	sext.w	a4,a5
    800193d0:	0000b797          	auipc	a5,0xb
    800193d4:	c3878793          	addi	a5,a5,-968 # 80024008 <k_log_level>
    800193d8:	c398                	sw	a4,0(a5)
}
    800193da:	0001                	nop
    800193dc:	6462                	ld	s0,24(sp)
    800193de:	6105                	addi	sp,sp,32
    800193e0:	8082                	ret

00000000800193e2 <klogclear>:

void klogclear(log_type lt)
{
    800193e2:	1101                	addi	sp,sp,-32
    800193e4:	ec22                	sd	s0,24(sp)
    800193e6:	1000                	addi	s0,sp,32
    800193e8:	87aa                	mv	a5,a0
    800193ea:	fef42623          	sw	a5,-20(s0)
    k_log_level &= ~lt;
    800193ee:	fec42783          	lw	a5,-20(s0)
    800193f2:	fff7c793          	not	a5,a5
    800193f6:	0007871b          	sext.w	a4,a5
    800193fa:	0000b797          	auipc	a5,0xb
    800193fe:	c0e78793          	addi	a5,a5,-1010 # 80024008 <k_log_level>
    80019402:	439c                	lw	a5,0(a5)
    80019404:	2781                	sext.w	a5,a5
    80019406:	8ff9                	and	a5,a5,a4
    80019408:	2781                	sext.w	a5,a5
    8001940a:	0007871b          	sext.w	a4,a5
    8001940e:	0000b797          	auipc	a5,0xb
    80019412:	bfa78793          	addi	a5,a5,-1030 # 80024008 <k_log_level>
    80019416:	c398                	sw	a4,0(a5)
    80019418:	0001                	nop
    8001941a:	6462                	ld	s0,24(sp)
    8001941c:	6105                	addi	sp,sp,32
    8001941e:	8082                	ret

0000000080019420 <sbi_putchar>:
#include <compiler.h>
#include <config.h>
#include <sbi.h>

void sbi_putchar(char c)
{
    80019420:	1101                	addi	sp,sp,-32
    80019422:	ec22                	sd	s0,24(sp)
    80019424:	1000                	addi	s0,sp,32
    80019426:	87aa                	mv	a5,a0
    80019428:	fef407a3          	sb	a5,-17(s0)
    asm volatile("mv a7, %0\nmv a0, %1\necall" ::"r"(SBI_SVCALL_PUTCHAR), "r"(c) : "a7", "a0");
    8001942c:	47a5                	li	a5,9
    8001942e:	fef44703          	lbu	a4,-17(s0)
    80019432:	88be                	mv	a7,a5
    80019434:	853a                	mv	a0,a4
    80019436:	00000073          	ecall
}
    8001943a:	0001                	nop
    8001943c:	6462                	ld	s0,24(sp)
    8001943e:	6105                	addi	sp,sp,32
    80019440:	8082                	ret

0000000080019442 <sbi_getchar>:

char sbi_getchar(void)
{
    80019442:	1101                	addi	sp,sp,-32
    80019444:	ec22                	sd	s0,24(sp)
    80019446:	1000                	addi	s0,sp,32
    char c;
    asm volatile("mv a7, %1\necall\nmv %0, a0\n" : "=r"(c) : "r"(SBI_SVCALL_GETCHAR) : "a7", "a0");
    80019448:	47a9                	li	a5,10
    8001944a:	88be                	mv	a7,a5
    8001944c:	00000073          	ecall
    80019450:	87aa                	mv	a5,a0
    80019452:	fef407a3          	sb	a5,-17(s0)
    return c;
    80019456:	fef44783          	lbu	a5,-17(s0)
}
    8001945a:	853e                	mv	a0,a5
    8001945c:	6462                	ld	s0,24(sp)
    8001945e:	6105                	addi	sp,sp,32
    80019460:	8082                	ret

0000000080019462 <sbi_hart_get_status>:

int sbi_hart_get_status(unsigned int hart)
{
    80019462:	7179                	addi	sp,sp,-48
    80019464:	f422                	sd	s0,40(sp)
    80019466:	1800                	addi	s0,sp,48
    80019468:	87aa                	mv	a5,a0
    8001946a:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\necall\nmv %0, a0\n"
    8001946e:	4785                	li	a5,1
    80019470:	fdc42703          	lw	a4,-36(s0)
    80019474:	88be                	mv	a7,a5
    80019476:	853a                	mv	a0,a4
    80019478:	00000073          	ecall
    8001947c:	87aa                	mv	a5,a0
    8001947e:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_STATUS), "r"(hart)
                 : "a0", "a7");
    return stat;
    80019482:	fec42783          	lw	a5,-20(s0)
}
    80019486:	853e                	mv	a0,a5
    80019488:	7422                	ld	s0,40(sp)
    8001948a:	6145                	addi	sp,sp,48
    8001948c:	8082                	ret

000000008001948e <sbi_hart_start>:

int sbi_hart_start(unsigned int hart, unsigned long target, unsigned long scratch, unsigned long satp)
{
    8001948e:	7139                	addi	sp,sp,-64
    80019490:	fc22                	sd	s0,56(sp)
    80019492:	0080                	addi	s0,sp,64
    80019494:	87aa                	mv	a5,a0
    80019496:	fcb43823          	sd	a1,-48(s0)
    8001949a:	fcc43423          	sd	a2,-56(s0)
    8001949e:	fcd43023          	sd	a3,-64(s0)
    800194a2:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\nmv a1, %3\nmv a2, %4\nmv a3, %5\necall\nmv %0, a0\n"
    800194a6:	4789                	li	a5,2
    800194a8:	fdc42703          	lw	a4,-36(s0)
    800194ac:	fd043683          	ld	a3,-48(s0)
    800194b0:	fc843803          	ld	a6,-56(s0)
    800194b4:	fc043303          	ld	t1,-64(s0)
    800194b8:	88be                	mv	a7,a5
    800194ba:	853a                	mv	a0,a4
    800194bc:	85b6                	mv	a1,a3
    800194be:	8642                	mv	a2,a6
    800194c0:	869a                	mv	a3,t1
    800194c2:	00000073          	ecall
    800194c6:	87aa                	mv	a5,a0
    800194c8:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_START), "r"(hart), "r"(target), "r"(scratch), "r"(satp)
                 : "a0", "a1", "a2", "a7");
    return stat;
    800194cc:	fec42783          	lw	a5,-20(s0)
}
    800194d0:	853e                	mv	a0,a5
    800194d2:	7462                	ld	s0,56(sp)
    800194d4:	6121                	addi	sp,sp,64
    800194d6:	8082                	ret

00000000800194d8 <sbi_hart_stop>:

void sbi_hart_stop(void)
{
    800194d8:	1141                	addi	sp,sp,-16
    800194da:	e422                	sd	s0,8(sp)
    800194dc:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall\nwfi" : : "r"(SBI_SVCALL_HART_STOP) : "a0", "a7");
    800194de:	478d                	li	a5,3
    800194e0:	88be                	mv	a7,a5
    800194e2:	00000073          	ecall
    800194e6:	10500073          	wfi
}
    800194ea:	0001                	nop
    800194ec:	6422                	ld	s0,8(sp)
    800194ee:	0141                	addi	sp,sp,16
    800194f0:	8082                	ret

00000000800194f2 <sbi_poweroff>:

void sbi_poweroff(void)
{
    800194f2:	1141                	addi	sp,sp,-16
    800194f4:	e422                	sd	s0,8(sp)
    800194f6:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" : : "r"(SBI_SVCALL_POWEROFF) : "a0", "a7");
    800194f8:	47b1                	li	a5,12
    800194fa:	88be                	mv	a7,a5
    800194fc:	00000073          	ecall
}
    80019500:	0001                	nop
    80019502:	6422                	ld	s0,8(sp)
    80019504:	0141                	addi	sp,sp,16
    80019506:	8082                	ret

0000000080019508 <sbi_get_time>:

unsigned long sbi_get_time(void)
{
    80019508:	1101                	addi	sp,sp,-32
    8001950a:	ec22                	sd	s0,24(sp)
    8001950c:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_GET_TIME) : "a0", "a7");
    8001950e:	4791                	li	a5,4
    80019510:	88be                	mv	a7,a5
    80019512:	00000073          	ecall
    80019516:	87aa                	mv	a5,a0
    80019518:	fef43423          	sd	a5,-24(s0)
    return ret;
    8001951c:	fe843783          	ld	a5,-24(s0)
}
    80019520:	853e                	mv	a0,a5
    80019522:	6462                	ld	s0,24(sp)
    80019524:	6105                	addi	sp,sp,32
    80019526:	8082                	ret

0000000080019528 <sbi_set_timer>:

void sbi_set_timer(unsigned int hart, unsigned long val)
{
    80019528:	1101                	addi	sp,sp,-32
    8001952a:	ec22                	sd	s0,24(sp)
    8001952c:	1000                	addi	s0,sp,32
    8001952e:	87aa                	mv	a5,a0
    80019530:	feb43023          	sd	a1,-32(s0)
    80019534:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_SET_TIMECMP), "r"(hart),
    80019538:	4795                	li	a5,5
    8001953a:	fec42703          	lw	a4,-20(s0)
    8001953e:	fe043683          	ld	a3,-32(s0)
    80019542:	88be                	mv	a7,a5
    80019544:	853a                	mv	a0,a4
    80019546:	85b6                	mv	a1,a3
    80019548:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    8001954c:	0001                	nop
    8001954e:	6462                	ld	s0,24(sp)
    80019550:	6105                	addi	sp,sp,32
    80019552:	8082                	ret

0000000080019554 <sbi_add_timer>:

void sbi_add_timer(unsigned int hart, unsigned long val)
{
    80019554:	1101                	addi	sp,sp,-32
    80019556:	ec22                	sd	s0,24(sp)
    80019558:	1000                	addi	s0,sp,32
    8001955a:	87aa                	mv	a5,a0
    8001955c:	feb43023          	sd	a1,-32(s0)
    80019560:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_ADD_TIMECMP), "r"(hart),
    80019564:	4799                	li	a5,6
    80019566:	fec42703          	lw	a4,-20(s0)
    8001956a:	fe043683          	ld	a3,-32(s0)
    8001956e:	88be                	mv	a7,a5
    80019570:	853a                	mv	a0,a4
    80019572:	85b6                	mv	a1,a3
    80019574:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    80019578:	0001                	nop
    8001957a:	6462                	ld	s0,24(sp)
    8001957c:	6105                	addi	sp,sp,32
    8001957e:	8082                	ret

0000000080019580 <sbi_ack_timer>:

void sbi_ack_timer(void)
{
    80019580:	1141                	addi	sp,sp,-16
    80019582:	e422                	sd	s0,8(sp)
    80019584:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" ::"r"(SBI_SVCALL_ACK_TIMER) : "a7");
    80019586:	479d                	li	a5,7
    80019588:	88be                	mv	a7,a5
    8001958a:	00000073          	ecall
}
    8001958e:	0001                	nop
    80019590:	6422                	ld	s0,8(sp)
    80019592:	0141                	addi	sp,sp,16
    80019594:	8082                	ret

0000000080019596 <sbi_rtc_get_time>:

unsigned long sbi_rtc_get_time(void)
{
    80019596:	1101                	addi	sp,sp,-32
    80019598:	ec22                	sd	s0,24(sp)
    8001959a:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0"
    8001959c:	47a1                	li	a5,8
    8001959e:	88be                	mv	a7,a5
    800195a0:	00000073          	ecall
    800195a4:	87aa                	mv	a5,a0
    800195a6:	fef43423          	sd	a5,-24(s0)
                 : "=r"(ret)
                 : "r"(SBI_SVCALL_RTC_GET_TIME)
                 : "a0", "a7");
    return ret;
    800195aa:	fe843783          	ld	a5,-24(s0)
}
    800195ae:	853e                	mv	a0,a5
    800195b0:	6462                	ld	s0,24(sp)
    800195b2:	6105                	addi	sp,sp,32
    800195b4:	8082                	ret

00000000800195b6 <sbi_whoami>:

int sbi_whoami(void)
{
    800195b6:	1101                	addi	sp,sp,-32
    800195b8:	ec22                	sd	s0,24(sp)
    800195ba:	1000                	addi	s0,sp,32
    int ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_WHOAMI) : "a0", "a7");
    800195bc:	47ad                	li	a5,11
    800195be:	88be                	mv	a7,a5
    800195c0:	00000073          	ecall
    800195c4:	87aa                	mv	a5,a0
    800195c6:	fef42623          	sw	a5,-20(s0)
    return ret;
    800195ca:	fec42783          	lw	a5,-20(s0)
}
    800195ce:	853e                	mv	a0,a5
    800195d0:	6462                	ld	s0,24(sp)
    800195d2:	6105                	addi	sp,sp,32
    800195d4:	8082                	ret

00000000800195d6 <sbi_num_harts>:

int sbi_num_harts(void)
{
    800195d6:	1101                	addi	sp,sp,-32
    800195d8:	ec06                	sd	ra,24(sp)
    800195da:	e822                	sd	s0,16(sp)
    800195dc:	1000                	addi	s0,sp,32
    unsigned int i;
    int num_harts = 0;
    800195de:	fe042423          	sw	zero,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800195e2:	fe042623          	sw	zero,-20(s0)
    800195e6:	a015                	j	8001960a <sbi_num_harts+0x34>
        if (sbi_hart_get_status(i) != 0) {
    800195e8:	fec42783          	lw	a5,-20(s0)
    800195ec:	853e                	mv	a0,a5
    800195ee:	e75ff0ef          	jal	ra,80019462 <sbi_hart_get_status>
    800195f2:	87aa                	mv	a5,a0
    800195f4:	c791                	beqz	a5,80019600 <sbi_num_harts+0x2a>
            num_harts += 1;
    800195f6:	fe842783          	lw	a5,-24(s0)
    800195fa:	2785                	addiw	a5,a5,1
    800195fc:	fef42423          	sw	a5,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80019600:	fec42783          	lw	a5,-20(s0)
    80019604:	2785                	addiw	a5,a5,1
    80019606:	fef42623          	sw	a5,-20(s0)
    8001960a:	fec42783          	lw	a5,-20(s0)
    8001960e:	0007871b          	sext.w	a4,a5
    80019612:	478d                	li	a5,3
    80019614:	fce7fae3          	bgeu	a5,a4,800195e8 <sbi_num_harts+0x12>
        }
    }
    return num_harts;
    80019618:	fe842783          	lw	a5,-24(s0)
}
    8001961c:	853e                	mv	a0,a5
    8001961e:	60e2                	ld	ra,24(sp)
    80019620:	6442                	ld	s0,16(sp)
    80019622:	6105                	addi	sp,sp,32
    80019624:	8082                	ret

0000000080019626 <plic_set_priority>:
#define PLIC_PCI_INTB 33
#define PLIC_PCI_INTC 34
#define PLIC_PCI_INTD 35

void plic_set_priority(int interrupt_id, char priority)
{
    80019626:	7179                	addi	sp,sp,-48
    80019628:	f422                	sd	s0,40(sp)
    8001962a:	1800                	addi	s0,sp,48
    8001962c:	87aa                	mv	a5,a0
    8001962e:	872e                	mv	a4,a1
    80019630:	fcf42e23          	sw	a5,-36(s0)
    80019634:	87ba                	mv	a5,a4
    80019636:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_PRIORITY(interrupt_id);
    8001963a:	fdc42783          	lw	a5,-36(s0)
    8001963e:	0027979b          	slliw	a5,a5,0x2
    80019642:	2781                	sext.w	a5,a5
    80019644:	873e                	mv	a4,a5
    80019646:	0c0007b7          	lui	a5,0xc000
    8001964a:	97ba                	add	a5,a5,a4
    8001964c:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    80019650:	fdb44783          	lbu	a5,-37(s0)
    80019654:	2781                	sext.w	a5,a5
    80019656:	8b9d                	andi	a5,a5,7
    80019658:	0007871b          	sext.w	a4,a5
    8001965c:	fe843783          	ld	a5,-24(s0)
    80019660:	c398                	sw	a4,0(a5)
}
    80019662:	0001                	nop
    80019664:	7422                	ld	s0,40(sp)
    80019666:	6145                	addi	sp,sp,48
    80019668:	8082                	ret

000000008001966a <plic_set_threshold>:
void plic_set_threshold(int hart, char priority)
{
    8001966a:	7179                	addi	sp,sp,-48
    8001966c:	f422                	sd	s0,40(sp)
    8001966e:	1800                	addi	s0,sp,48
    80019670:	87aa                	mv	a5,a0
    80019672:	872e                	mv	a4,a1
    80019674:	fcf42e23          	sw	a5,-36(s0)
    80019678:	87ba                	mv	a5,a4
    8001967a:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_THRESHOLD(hart, PLIC_MODE_SUPERVISOR);
    8001967e:	fdc42783          	lw	a5,-36(s0)
    80019682:	0017979b          	slliw	a5,a5,0x1
    80019686:	2781                	sext.w	a5,a5
    80019688:	2785                	addiw	a5,a5,1
    8001968a:	2781                	sext.w	a5,a5
    8001968c:	00c7979b          	slliw	a5,a5,0xc
    80019690:	2781                	sext.w	a5,a5
    80019692:	873e                	mv	a4,a5
    80019694:	0c2007b7          	lui	a5,0xc200
    80019698:	97ba                	add	a5,a5,a4
    8001969a:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    8001969e:	fdb44783          	lbu	a5,-37(s0)
    800196a2:	2781                	sext.w	a5,a5
    800196a4:	8b9d                	andi	a5,a5,7
    800196a6:	0007871b          	sext.w	a4,a5
    800196aa:	fe843783          	ld	a5,-24(s0)
    800196ae:	c398                	sw	a4,0(a5)
}
    800196b0:	0001                	nop
    800196b2:	7422                	ld	s0,40(sp)
    800196b4:	6145                	addi	sp,sp,48
    800196b6:	8082                	ret

00000000800196b8 <plic_enable>:
void plic_enable(int hart, int interrupt_id)
{
    800196b8:	7179                	addi	sp,sp,-48
    800196ba:	f422                	sd	s0,40(sp)
    800196bc:	1800                	addi	s0,sp,48
    800196be:	87aa                	mv	a5,a0
    800196c0:	872e                	mv	a4,a1
    800196c2:	fcf42e23          	sw	a5,-36(s0)
    800196c6:	87ba                	mv	a5,a4
    800196c8:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    800196cc:	fdc42783          	lw	a5,-36(s0)
    800196d0:	0017979b          	slliw	a5,a5,0x1
    800196d4:	2781                	sext.w	a5,a5
    800196d6:	2785                	addiw	a5,a5,1
    800196d8:	2781                	sext.w	a5,a5
    800196da:	0077979b          	slliw	a5,a5,0x7
    800196de:	2781                	sext.w	a5,a5
    800196e0:	873e                	mv	a4,a5
    800196e2:	0c0027b7          	lui	a5,0xc002
    800196e6:	97ba                	add	a5,a5,a4
    800196e8:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] |= 1UL << (interrupt_id % 32);
    800196ec:	fd842783          	lw	a5,-40(s0)
    800196f0:	41f7d71b          	sraiw	a4,a5,0x1f
    800196f4:	01b7571b          	srliw	a4,a4,0x1b
    800196f8:	9fb9                	addw	a5,a5,a4
    800196fa:	4057d79b          	sraiw	a5,a5,0x5
    800196fe:	0007869b          	sext.w	a3,a5
    80019702:	87b6                	mv	a5,a3
    80019704:	078a                	slli	a5,a5,0x2
    80019706:	fe843703          	ld	a4,-24(s0)
    8001970a:	97ba                	add	a5,a5,a4
    8001970c:	438c                	lw	a1,0(a5)
    8001970e:	fd842703          	lw	a4,-40(s0)
    80019712:	41f7579b          	sraiw	a5,a4,0x1f
    80019716:	01b7d79b          	srliw	a5,a5,0x1b
    8001971a:	9f3d                	addw	a4,a4,a5
    8001971c:	8b7d                	andi	a4,a4,31
    8001971e:	40f707bb          	subw	a5,a4,a5
    80019722:	2781                	sext.w	a5,a5
    80019724:	873e                	mv	a4,a5
    80019726:	4785                	li	a5,1
    80019728:	00e797b3          	sll	a5,a5,a4
    8001972c:	0007861b          	sext.w	a2,a5
    80019730:	87b6                	mv	a5,a3
    80019732:	078a                	slli	a5,a5,0x2
    80019734:	fe843703          	ld	a4,-24(s0)
    80019738:	97ba                	add	a5,a5,a4
    8001973a:	86ae                	mv	a3,a1
    8001973c:	8732                	mv	a4,a2
    8001973e:	8f55                	or	a4,a4,a3
    80019740:	2701                	sext.w	a4,a4
    80019742:	c398                	sw	a4,0(a5)
}
    80019744:	0001                	nop
    80019746:	7422                	ld	s0,40(sp)
    80019748:	6145                	addi	sp,sp,48
    8001974a:	8082                	ret

000000008001974c <plic_disable>:
void plic_disable(int hart, int interrupt_id)
{
    8001974c:	7179                	addi	sp,sp,-48
    8001974e:	f422                	sd	s0,40(sp)
    80019750:	1800                	addi	s0,sp,48
    80019752:	87aa                	mv	a5,a0
    80019754:	872e                	mv	a4,a1
    80019756:	fcf42e23          	sw	a5,-36(s0)
    8001975a:	87ba                	mv	a5,a4
    8001975c:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    80019760:	fdc42783          	lw	a5,-36(s0)
    80019764:	0017979b          	slliw	a5,a5,0x1
    80019768:	2781                	sext.w	a5,a5
    8001976a:	2785                	addiw	a5,a5,1
    8001976c:	2781                	sext.w	a5,a5
    8001976e:	0077979b          	slliw	a5,a5,0x7
    80019772:	2781                	sext.w	a5,a5
    80019774:	873e                	mv	a4,a5
    80019776:	0c0027b7          	lui	a5,0xc002
    8001977a:	97ba                	add	a5,a5,a4
    8001977c:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] &= ~(1UL << (interrupt_id % 32));
    80019780:	fd842783          	lw	a5,-40(s0)
    80019784:	41f7d71b          	sraiw	a4,a5,0x1f
    80019788:	01b7571b          	srliw	a4,a4,0x1b
    8001978c:	9fb9                	addw	a5,a5,a4
    8001978e:	4057d79b          	sraiw	a5,a5,0x5
    80019792:	0007869b          	sext.w	a3,a5
    80019796:	87b6                	mv	a5,a3
    80019798:	078a                	slli	a5,a5,0x2
    8001979a:	fe843703          	ld	a4,-24(s0)
    8001979e:	97ba                	add	a5,a5,a4
    800197a0:	438c                	lw	a1,0(a5)
    800197a2:	fd842703          	lw	a4,-40(s0)
    800197a6:	41f7579b          	sraiw	a5,a4,0x1f
    800197aa:	01b7d79b          	srliw	a5,a5,0x1b
    800197ae:	9f3d                	addw	a4,a4,a5
    800197b0:	8b7d                	andi	a4,a4,31
    800197b2:	40f707bb          	subw	a5,a4,a5
    800197b6:	2781                	sext.w	a5,a5
    800197b8:	873e                	mv	a4,a5
    800197ba:	4785                	li	a5,1
    800197bc:	00e797b3          	sll	a5,a5,a4
    800197c0:	2781                	sext.w	a5,a5
    800197c2:	fff7c793          	not	a5,a5
    800197c6:	0007861b          	sext.w	a2,a5
    800197ca:	87b6                	mv	a5,a3
    800197cc:	078a                	slli	a5,a5,0x2
    800197ce:	fe843703          	ld	a4,-24(s0)
    800197d2:	97ba                	add	a5,a5,a4
    800197d4:	86ae                	mv	a3,a1
    800197d6:	8732                	mv	a4,a2
    800197d8:	8f75                	and	a4,a4,a3
    800197da:	2701                	sext.w	a4,a4
    800197dc:	c398                	sw	a4,0(a5)
}
    800197de:	0001                	nop
    800197e0:	7422                	ld	s0,40(sp)
    800197e2:	6145                	addi	sp,sp,48
    800197e4:	8082                	ret

00000000800197e6 <plic_claim>:
uint32_t plic_claim(int hart)
{
    800197e6:	7179                	addi	sp,sp,-48
    800197e8:	f422                	sd	s0,40(sp)
    800197ea:	1800                	addi	s0,sp,48
    800197ec:	87aa                	mv	a5,a0
    800197ee:	fcf42e23          	sw	a5,-36(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    800197f2:	fdc42783          	lw	a5,-36(s0)
    800197f6:	0017979b          	slliw	a5,a5,0x1
    800197fa:	2781                	sext.w	a5,a5
    800197fc:	2785                	addiw	a5,a5,1
    800197fe:	2781                	sext.w	a5,a5
    80019800:	00c7979b          	slliw	a5,a5,0xc
    80019804:	2781                	sext.w	a5,a5
    80019806:	873e                	mv	a4,a5
    80019808:	0c2007b7          	lui	a5,0xc200
    8001980c:	0791                	addi	a5,a5,4
    8001980e:	97ba                	add	a5,a5,a4
    80019810:	fef43423          	sd	a5,-24(s0)
    return *base;
    80019814:	fe843783          	ld	a5,-24(s0)
    80019818:	439c                	lw	a5,0(a5)
}
    8001981a:	853e                	mv	a0,a5
    8001981c:	7422                	ld	s0,40(sp)
    8001981e:	6145                	addi	sp,sp,48
    80019820:	8082                	ret

0000000080019822 <plic_complete>:
void plic_complete(int hart, int id)
{
    80019822:	7179                	addi	sp,sp,-48
    80019824:	f422                	sd	s0,40(sp)
    80019826:	1800                	addi	s0,sp,48
    80019828:	87aa                	mv	a5,a0
    8001982a:	872e                	mv	a4,a1
    8001982c:	fcf42e23          	sw	a5,-36(s0)
    80019830:	87ba                	mv	a5,a4
    80019832:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    80019836:	fdc42783          	lw	a5,-36(s0)
    8001983a:	0017979b          	slliw	a5,a5,0x1
    8001983e:	2781                	sext.w	a5,a5
    80019840:	2785                	addiw	a5,a5,1
    80019842:	2781                	sext.w	a5,a5
    80019844:	00c7979b          	slliw	a5,a5,0xc
    80019848:	2781                	sext.w	a5,a5
    8001984a:	873e                	mv	a4,a5
    8001984c:	0c2007b7          	lui	a5,0xc200
    80019850:	0791                	addi	a5,a5,4
    80019852:	97ba                	add	a5,a5,a4
    80019854:	fef43423          	sd	a5,-24(s0)
    *base          = id;
    80019858:	fd842703          	lw	a4,-40(s0)
    8001985c:	fe843783          	ld	a5,-24(s0)
    80019860:	c398                	sw	a4,0(a5)
}
    80019862:	0001                	nop
    80019864:	7422                	ld	s0,40(sp)
    80019866:	6145                	addi	sp,sp,48
    80019868:	8082                	ret

000000008001986a <plic_handle_irq>:

void plic_handle_irq(int hart)
{
    8001986a:	7179                	addi	sp,sp,-48
    8001986c:	f406                	sd	ra,40(sp)
    8001986e:	f022                	sd	s0,32(sp)
    80019870:	1800                	addi	s0,sp,48
    80019872:	87aa                	mv	a5,a0
    80019874:	fcf42e23          	sw	a5,-36(s0)
    int irq = plic_claim(hart);
    80019878:	fdc42783          	lw	a5,-36(s0)
    8001987c:	853e                	mv	a0,a5
    8001987e:	f69ff0ef          	jal	ra,800197e6 <plic_claim>
    80019882:	87aa                	mv	a5,a0
    80019884:	2781                	sext.w	a5,a5
    80019886:	fef42623          	sw	a5,-20(s0)
    8001988a:	fec42783          	lw	a5,-20(s0)
    8001988e:	3781                	addiw	a5,a5,-32
    80019890:	2781                	sext.w	a5,a5

    switch (irq) {
    80019892:	873e                	mv	a4,a5
    80019894:	478d                	li	a5,3
    80019896:	00e7e863          	bltu	a5,a4,800198a6 <plic_handle_irq+0x3c>
        // PCI devices 32-35
        case PLIC_PCI_INTA: [[fallthrough]]
        case PLIC_PCI_INTB: [[fallthrough]]
        case PLIC_PCI_INTC: [[fallthrough]]
        case PLIC_PCI_INTD:
            pci_dispatch_irq(irq);
    8001989a:	fec42783          	lw	a5,-20(s0)
    8001989e:	853e                	mv	a0,a5
    800198a0:	b1ff90ef          	jal	ra,800133be <pci_dispatch_irq>
            break;
    800198a4:	0001                	nop
    }
    plic_complete(hart, irq);
    800198a6:	fec42703          	lw	a4,-20(s0)
    800198aa:	fdc42783          	lw	a5,-36(s0)
    800198ae:	85ba                	mv	a1,a4
    800198b0:	853e                	mv	a0,a5
    800198b2:	f71ff0ef          	jal	ra,80019822 <plic_complete>
}
    800198b6:	0001                	nop
    800198b8:	70a2                	ld	ra,40(sp)
    800198ba:	7402                	ld	s0,32(sp)
    800198bc:	6145                	addi	sp,sp,48
    800198be:	8082                	ret

00000000800198c0 <plic_init>:

void plic_init(void)
{
    800198c0:	1141                	addi	sp,sp,-16
    800198c2:	e406                	sd	ra,8(sp)
    800198c4:	e022                	sd	s0,0(sp)
    800198c6:	0800                	addi	s0,sp,16
    plic_enable(0, PLIC_PCI_INTA);
    800198c8:	02000593          	li	a1,32
    800198cc:	4501                	li	a0,0
    800198ce:	debff0ef          	jal	ra,800196b8 <plic_enable>
    plic_enable(0, PLIC_PCI_INTB);
    800198d2:	02100593          	li	a1,33
    800198d6:	4501                	li	a0,0
    800198d8:	de1ff0ef          	jal	ra,800196b8 <plic_enable>
    plic_enable(0, PLIC_PCI_INTC);
    800198dc:	02200593          	li	a1,34
    800198e0:	4501                	li	a0,0
    800198e2:	dd7ff0ef          	jal	ra,800196b8 <plic_enable>
    plic_enable(0, PLIC_PCI_INTD);
    800198e6:	02300593          	li	a1,35
    800198ea:	4501                	li	a0,0
    800198ec:	dcdff0ef          	jal	ra,800196b8 <plic_enable>

    plic_set_threshold(0, 0);
    800198f0:	4581                	li	a1,0
    800198f2:	4501                	li	a0,0
    800198f4:	d77ff0ef          	jal	ra,8001966a <plic_set_threshold>

    plic_set_priority(PLIC_PCI_INTA, 7);
    800198f8:	459d                	li	a1,7
    800198fa:	02000513          	li	a0,32
    800198fe:	d29ff0ef          	jal	ra,80019626 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTB, 7);
    80019902:	459d                	li	a1,7
    80019904:	02100513          	li	a0,33
    80019908:	d1fff0ef          	jal	ra,80019626 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTC, 7);
    8001990c:	459d                	li	a1,7
    8001990e:	02200513          	li	a0,34
    80019912:	d15ff0ef          	jal	ra,80019626 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTD, 7);
    80019916:	459d                	li	a1,7
    80019918:	02300513          	li	a0,35
    8001991c:	d0bff0ef          	jal	ra,80019626 <plic_set_priority>
}
    80019920:	0001                	nop
    80019922:	60a2                	ld	ra,8(sp)
    80019924:	6402                	ld	s0,0(sp)
    80019926:	0141                	addi	sp,sp,16
    80019928:	8082                	ret

000000008001992a <virtio_create_job>:



static Vector *virtio_devices = NULL;

void virtio_create_job(VirtioDevice *dev, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job)) {
    8001992a:	7179                	addi	sp,sp,-48
    8001992c:	f406                	sd	ra,40(sp)
    8001992e:	f022                	sd	s0,32(sp)
    80019930:	1800                	addi	s0,sp,48
    80019932:	fea43423          	sd	a0,-24(s0)
    80019936:	feb43023          	sd	a1,-32(s0)
    8001993a:	fcc43c23          	sd	a2,-40(s0)
    virtio_create_job_with_data(dev, pid_id, callback, NULL);
    8001993e:	4681                	li	a3,0
    80019940:	fd843603          	ld	a2,-40(s0)
    80019944:	fe043583          	ld	a1,-32(s0)
    80019948:	fe843503          	ld	a0,-24(s0)
    8001994c:	00e000ef          	jal	ra,8001995a <virtio_create_job_with_data>
}
    80019950:	0001                	nop
    80019952:	70a2                	ld	ra,40(sp)
    80019954:	7402                	ld	s0,32(sp)
    80019956:	6145                	addi	sp,sp,48
    80019958:	8082                	ret

000000008001995a <virtio_create_job_with_data>:

void virtio_create_job_with_data(VirtioDevice *dev, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job), void *data) {
    8001995a:	7171                	addi	sp,sp,-176
    8001995c:	f506                	sd	ra,168(sp)
    8001995e:	f122                	sd	s0,160(sp)
    80019960:	1900                	addi	s0,sp,176
    80019962:	faa43423          	sd	a0,-88(s0)
    80019966:	fab43023          	sd	a1,-96(s0)
    8001996a:	f8c43c23          	sd	a2,-104(s0)
    8001996e:	f8d43823          	sd	a3,-112(s0)
    Job job = job_create(virtio_get_next_job_id(dev), pid_id, callback);
    80019972:	fa843503          	ld	a0,-88(s0)
    80019976:	46c000ef          	jal	ra,80019de2 <virtio_get_next_job_id>
    8001997a:	872a                	mv	a4,a0
    8001997c:	fb840793          	addi	a5,s0,-72
    80019980:	f9843683          	ld	a3,-104(s0)
    80019984:	fa043603          	ld	a2,-96(s0)
    80019988:	85ba                	mv	a1,a4
    8001998a:	853e                	mv	a0,a5
    8001998c:	0d6000ef          	jal	ra,80019a62 <job_create>
    job.data = data;
    80019990:	f9043783          	ld	a5,-112(s0)
    80019994:	fef43423          	sd	a5,-24(s0)
    virtio_add_job(dev, job);
    80019998:	fb843803          	ld	a6,-72(s0)
    8001999c:	fc043503          	ld	a0,-64(s0)
    800199a0:	fc843583          	ld	a1,-56(s0)
    800199a4:	fd043603          	ld	a2,-48(s0)
    800199a8:	fd843683          	ld	a3,-40(s0)
    800199ac:	fe043703          	ld	a4,-32(s0)
    800199b0:	fe843783          	ld	a5,-24(s0)
    800199b4:	f5043823          	sd	a6,-176(s0)
    800199b8:	f4a43c23          	sd	a0,-168(s0)
    800199bc:	f6b43023          	sd	a1,-160(s0)
    800199c0:	f6c43423          	sd	a2,-152(s0)
    800199c4:	f6d43823          	sd	a3,-144(s0)
    800199c8:	f6e43c23          	sd	a4,-136(s0)
    800199cc:	f8f43023          	sd	a5,-128(s0)
    800199d0:	f5040793          	addi	a5,s0,-176
    800199d4:	85be                	mv	a1,a5
    800199d6:	fa843503          	ld	a0,-88(s0)
    800199da:	29c000ef          	jal	ra,80019c76 <virtio_add_job>
}
    800199de:	0001                	nop
    800199e0:	70aa                	ld	ra,168(sp)
    800199e2:	740a                	ld	s0,160(sp)
    800199e4:	614d                	addi	sp,sp,176
    800199e6:	8082                	ret

00000000800199e8 <virtio_get_job>:

Job *virtio_get_job(VirtioDevice *dev, uint64_t job_id) {
    800199e8:	7179                	addi	sp,sp,-48
    800199ea:	f406                	sd	ra,40(sp)
    800199ec:	f022                	sd	s0,32(sp)
    800199ee:	1800                	addi	s0,sp,48
    800199f0:	fca43c23          	sd	a0,-40(s0)
    800199f4:	fcb43823          	sd	a1,-48(s0)
    for (uint64_t i=0; i<vector_size(dev->jobs); i++) {
    800199f8:	fe043423          	sd	zero,-24(s0)
    800199fc:	a83d                	j	80019a3a <virtio_get_job+0x52>
        Job *job = NULL;
    800199fe:	fe043023          	sd	zero,-32(s0)
        vector_get_ptr(dev->jobs, i, &job);
    80019a02:	fd843783          	ld	a5,-40(s0)
    80019a06:	63dc                	ld	a5,128(a5)
    80019a08:	fe843703          	ld	a4,-24(s0)
    80019a0c:	2701                	sext.w	a4,a4
    80019a0e:	fe040693          	addi	a3,s0,-32
    80019a12:	8636                	mv	a2,a3
    80019a14:	85ba                	mv	a1,a4
    80019a16:	853e                	mv	a0,a5
    80019a18:	564040ef          	jal	ra,8001df7c <vector_get>
        if (job->job_id == job_id) {
    80019a1c:	fe043783          	ld	a5,-32(s0)
    80019a20:	639c                	ld	a5,0(a5)
    80019a22:	fd043703          	ld	a4,-48(s0)
    80019a26:	00f71563          	bne	a4,a5,80019a30 <virtio_get_job+0x48>
            return job;
    80019a2a:	fe043783          	ld	a5,-32(s0)
    80019a2e:	a02d                	j	80019a58 <virtio_get_job+0x70>
    for (uint64_t i=0; i<vector_size(dev->jobs); i++) {
    80019a30:	fe843783          	ld	a5,-24(s0)
    80019a34:	0785                	addi	a5,a5,1
    80019a36:	fef43423          	sd	a5,-24(s0)
    80019a3a:	fd843783          	ld	a5,-40(s0)
    80019a3e:	63dc                	ld	a5,128(a5)
    80019a40:	853e                	mv	a0,a5
    80019a42:	49b040ef          	jal	ra,8001e6dc <vector_size>
    80019a46:	87aa                	mv	a5,a0
    80019a48:	2781                	sext.w	a5,a5
    80019a4a:	1782                	slli	a5,a5,0x20
    80019a4c:	9381                	srli	a5,a5,0x20
    80019a4e:	fe843703          	ld	a4,-24(s0)
    80019a52:	faf766e3          	bltu	a4,a5,800199fe <virtio_get_job+0x16>
        }
    }
    debugf("No job found with ID %d\n", job_id);
    return NULL;
    80019a56:	4781                	li	a5,0
}
    80019a58:	853e                	mv	a0,a5
    80019a5a:	70a2                	ld	ra,40(sp)
    80019a5c:	7402                	ld	s0,32(sp)
    80019a5e:	6145                	addi	sp,sp,48
    80019a60:	8082                	ret

0000000080019a62 <job_create>:

Job job_create(uint64_t job_id, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job)) {
    80019a62:	7179                	addi	sp,sp,-48
    80019a64:	f406                	sd	ra,40(sp)
    80019a66:	f022                	sd	s0,32(sp)
    80019a68:	1800                	addi	s0,sp,48
    80019a6a:	fea43423          	sd	a0,-24(s0)
    80019a6e:	feb43023          	sd	a1,-32(s0)
    80019a72:	fcc43c23          	sd	a2,-40(s0)
    80019a76:	fcd43823          	sd	a3,-48(s0)
    return job_create_with_data(job_id, pid_id, callback, NULL);
    80019a7a:	fe843783          	ld	a5,-24(s0)
    80019a7e:	4701                	li	a4,0
    80019a80:	fd043683          	ld	a3,-48(s0)
    80019a84:	fd843603          	ld	a2,-40(s0)
    80019a88:	fe043583          	ld	a1,-32(s0)
    80019a8c:	853e                	mv	a0,a5
    80019a8e:	010000ef          	jal	ra,80019a9e <job_create_with_data>
}
    80019a92:	fe843503          	ld	a0,-24(s0)
    80019a96:	70a2                	ld	ra,40(sp)
    80019a98:	7402                	ld	s0,32(sp)
    80019a9a:	6145                	addi	sp,sp,48
    80019a9c:	8082                	ret

0000000080019a9e <job_create_with_data>:

Job job_create_with_data(uint64_t job_id, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job), void *data) {
    80019a9e:	7119                	addi	sp,sp,-128
    80019aa0:	fca2                	sd	s0,120(sp)
    80019aa2:	0100                	addi	s0,sp,128
    80019aa4:	faa43423          	sd	a0,-88(s0)
    80019aa8:	fab43023          	sd	a1,-96(s0)
    80019aac:	f8c43c23          	sd	a2,-104(s0)
    80019ab0:	f8d43823          	sd	a3,-112(s0)
    80019ab4:	f8e43423          	sd	a4,-120(s0)
    Job job;
    job.job_id = job_id;
    80019ab8:	fa043783          	ld	a5,-96(s0)
    80019abc:	faf43c23          	sd	a5,-72(s0)
    job.pid_id = pid_id;
    80019ac0:	f9843783          	ld	a5,-104(s0)
    80019ac4:	fcf43023          	sd	a5,-64(s0)
    job.callback = callback;
    80019ac8:	f9043783          	ld	a5,-112(s0)
    80019acc:	fef43023          	sd	a5,-32(s0)
    job.done = false;
    80019ad0:	fc040423          	sb	zero,-56(s0)
    job.data = data;
    80019ad4:	f8843783          	ld	a5,-120(s0)
    80019ad8:	fef43423          	sd	a5,-24(s0)
    return job;
    80019adc:	fa843783          	ld	a5,-88(s0)
    80019ae0:	fb843883          	ld	a7,-72(s0)
    80019ae4:	fc043803          	ld	a6,-64(s0)
    80019ae8:	fc843503          	ld	a0,-56(s0)
    80019aec:	fd043583          	ld	a1,-48(s0)
    80019af0:	fd843603          	ld	a2,-40(s0)
    80019af4:	fe043683          	ld	a3,-32(s0)
    80019af8:	fe843703          	ld	a4,-24(s0)
    80019afc:	0117b023          	sd	a7,0(a5) # c200000 <i+0xc1fffe0>
    80019b00:	0107b423          	sd	a6,8(a5)
    80019b04:	eb88                	sd	a0,16(a5)
    80019b06:	ef8c                	sd	a1,24(a5)
    80019b08:	f390                	sd	a2,32(a5)
    80019b0a:	f794                	sd	a3,40(a5)
    80019b0c:	fb98                	sd	a4,48(a5)
}
    80019b0e:	fa843503          	ld	a0,-88(s0)
    80019b12:	7466                	ld	s0,120(sp)
    80019b14:	6109                	addi	sp,sp,128
    80019b16:	8082                	ret

0000000080019b18 <job_set_context>:

void job_set_context(Job *job, VirtioDescriptor *desc, uint16_t num_descriptors) {
    80019b18:	7179                	addi	sp,sp,-48
    80019b1a:	f422                	sd	s0,40(sp)
    80019b1c:	1800                	addi	s0,sp,48
    80019b1e:	fea43423          	sd	a0,-24(s0)
    80019b22:	feb43023          	sd	a1,-32(s0)
    80019b26:	87b2                	mv	a5,a2
    80019b28:	fcf41f23          	sh	a5,-34(s0)
    if (job == NULL) {
    80019b2c:	fe843783          	ld	a5,-24(s0)
    80019b30:	cf89                	beqz	a5,80019b4a <job_set_context+0x32>
        debugf("No job\n");
        return;
    }
    job->context.desc = desc;
    80019b32:	fe843783          	ld	a5,-24(s0)
    80019b36:	fe043703          	ld	a4,-32(s0)
    80019b3a:	ef98                	sd	a4,24(a5)
    job->context.num_descriptors = num_descriptors;
    80019b3c:	fe843783          	ld	a5,-24(s0)
    80019b40:	fde45703          	lhu	a4,-34(s0)
    80019b44:	02e79023          	sh	a4,32(a5)
    80019b48:	a011                	j	80019b4c <job_set_context+0x34>
        return;
    80019b4a:	0001                	nop
}
    80019b4c:	7422                	ld	s0,40(sp)
    80019b4e:	6145                	addi	sp,sp,48
    80019b50:	8082                	ret

0000000080019b52 <job_destroy>:

void job_destroy(Job *job) {
    80019b52:	1101                	addi	sp,sp,-32
    80019b54:	ec06                	sd	ra,24(sp)
    80019b56:	e822                	sd	s0,16(sp)
    80019b58:	1000                	addi	s0,sp,32
    80019b5a:	fea43423          	sd	a0,-24(s0)
    if (job->data != NULL) {
    80019b5e:	fe843783          	ld	a5,-24(s0)
    80019b62:	7b9c                	ld	a5,48(a5)
    80019b64:	c799                	beqz	a5,80019b72 <job_destroy+0x20>
        debugf("About to free non-nulled Job data\n");
        kfree(job->data);
    80019b66:	fe843783          	ld	a5,-24(s0)
    80019b6a:	7b9c                	ld	a5,48(a5)
    80019b6c:	853e                	mv	a0,a5
    80019b6e:	970fa0ef          	jal	ra,80013cde <kfree>
    }

    if (job != NULL) {
    80019b72:	fe843783          	ld	a5,-24(s0)
    80019b76:	c789                	beqz	a5,80019b80 <job_destroy+0x2e>
        kfree(job);
    80019b78:	fe843503          	ld	a0,-24(s0)
    80019b7c:	962fa0ef          	jal	ra,80013cde <kfree>
    }
}
    80019b80:	0001                	nop
    80019b82:	60e2                	ld	ra,24(sp)
    80019b84:	6442                	ld	s0,16(sp)
    80019b86:	6105                	addi	sp,sp,32
    80019b88:	8082                	ret

0000000080019b8a <virtio_callback_and_free_job>:

void virtio_callback_and_free_job(VirtioDevice *dev, uint64_t job_id) {
    80019b8a:	7179                	addi	sp,sp,-48
    80019b8c:	f406                	sd	ra,40(sp)
    80019b8e:	f022                	sd	s0,32(sp)
    80019b90:	1800                	addi	s0,sp,48
    80019b92:	fca43c23          	sd	a0,-40(s0)
    80019b96:	fcb43823          	sd	a1,-48(s0)
    Job *job = virtio_get_job(dev, job_id);
    80019b9a:	fd043583          	ld	a1,-48(s0)
    80019b9e:	fd843503          	ld	a0,-40(s0)
    80019ba2:	e47ff0ef          	jal	ra,800199e8 <virtio_get_job>
    80019ba6:	fea43423          	sd	a0,-24(s0)
    if (job == NULL) {
    80019baa:	fe843783          	ld	a5,-24(s0)
    80019bae:	c79d                	beqz	a5,80019bdc <virtio_callback_and_free_job+0x52>
        debugf("No job\n");
        return;
    }
    job->done = true;
    80019bb0:	fe843783          	ld	a5,-24(s0)
    80019bb4:	4705                	li	a4,1
    80019bb6:	00e78823          	sb	a4,16(a5)
    if (job->callback != NULL) {
    80019bba:	fe843783          	ld	a5,-24(s0)
    80019bbe:	779c                	ld	a5,40(a5)
    80019bc0:	cb89                	beqz	a5,80019bd2 <virtio_callback_and_free_job+0x48>
        job->callback(dev, job);
    80019bc2:	fe843783          	ld	a5,-24(s0)
    80019bc6:	779c                	ld	a5,40(a5)
    80019bc8:	fe843583          	ld	a1,-24(s0)
    80019bcc:	fd843503          	ld	a0,-40(s0)
    80019bd0:	9782                	jalr	a5
    } else {
        debugf("No callback for job\n");
    }

    job_destroy(job);
    80019bd2:	fe843503          	ld	a0,-24(s0)
    80019bd6:	f7dff0ef          	jal	ra,80019b52 <job_destroy>
    80019bda:	a011                	j	80019bde <virtio_callback_and_free_job+0x54>
        return;
    80019bdc:	0001                	nop
}
    80019bde:	70a2                	ld	ra,40(sp)
    80019be0:	7402                	ld	s0,32(sp)
    80019be2:	6145                	addi	sp,sp,48
    80019be4:	8082                	ret

0000000080019be6 <virtio_is_device_available>:

bool virtio_is_device_available(VirtioDevice *dev) {
    80019be6:	1101                	addi	sp,sp,-32
    80019be8:	ec22                	sd	s0,24(sp)
    80019bea:	1000                	addi	s0,sp,32
    80019bec:	fea43423          	sd	a0,-24(s0)
    return dev->lock == MUTEX_UNLOCKED;
    80019bf0:	fe843783          	ld	a5,-24(s0)
    80019bf4:	0907a783          	lw	a5,144(a5)
    80019bf8:	0017b793          	seqz	a5,a5
    80019bfc:	0ff7f793          	andi	a5,a5,255
}
    80019c00:	853e                	mv	a0,a5
    80019c02:	6462                	ld	s0,24(sp)
    80019c04:	6105                	addi	sp,sp,32
    80019c06:	8082                	ret

0000000080019c08 <virtio_acquire_device>:

void virtio_acquire_device(VirtioDevice *dev) {
    80019c08:	7179                	addi	sp,sp,-48
    80019c0a:	f406                	sd	ra,40(sp)
    80019c0c:	f022                	sd	s0,32(sp)
    80019c0e:	1800                	addi	s0,sp,48
    80019c10:	fca43c23          	sd	a0,-40(s0)
    IRQ_OFF();
    80019c14:	100027f3          	csrr	a5,sstatus
    80019c18:	fef43423          	sd	a5,-24(s0)
    80019c1c:	fe843783          	ld	a5,-24(s0)
    80019c20:	9bf5                	andi	a5,a5,-3
    80019c22:	10079073          	csrw	sstatus,a5
    debugf("Acquiring device %p\n", dev);
    mutex_spinlock(&dev->lock);
    80019c26:	fd843783          	ld	a5,-40(s0)
    80019c2a:	09078793          	addi	a5,a5,144
    80019c2e:	853e                	mv	a0,a5
    80019c30:	96efa0ef          	jal	ra,80013d9e <mutex_spinlock>
}
    80019c34:	0001                	nop
    80019c36:	70a2                	ld	ra,40(sp)
    80019c38:	7402                	ld	s0,32(sp)
    80019c3a:	6145                	addi	sp,sp,48
    80019c3c:	8082                	ret

0000000080019c3e <virtio_release_device>:

void virtio_release_device(VirtioDevice *dev) {
    80019c3e:	7179                	addi	sp,sp,-48
    80019c40:	f406                	sd	ra,40(sp)
    80019c42:	f022                	sd	s0,32(sp)
    80019c44:	1800                	addi	s0,sp,48
    80019c46:	fca43c23          	sd	a0,-40(s0)
    mutex_unlock(&dev->lock);
    80019c4a:	fd843783          	ld	a5,-40(s0)
    80019c4e:	09078793          	addi	a5,a5,144
    80019c52:	853e                	mv	a0,a5
    80019c54:	978fa0ef          	jal	ra,80013dcc <mutex_unlock>
    debugf("Releasing device %p\n", dev);
    IRQ_ON();
    80019c58:	100027f3          	csrr	a5,sstatus
    80019c5c:	fef43423          	sd	a5,-24(s0)
    80019c60:	fe843783          	ld	a5,-24(s0)
    80019c64:	0027e793          	ori	a5,a5,2
    80019c68:	10079073          	csrw	sstatus,a5
}
    80019c6c:	0001                	nop
    80019c6e:	70a2                	ld	ra,40(sp)
    80019c70:	7402                	ld	s0,32(sp)
    80019c72:	6145                	addi	sp,sp,48
    80019c74:	8082                	ret

0000000080019c76 <virtio_add_job>:

void virtio_add_job(VirtioDevice *dev, Job job) {
    80019c76:	7139                	addi	sp,sp,-64
    80019c78:	fc06                	sd	ra,56(sp)
    80019c7a:	f822                	sd	s0,48(sp)
    80019c7c:	f426                	sd	s1,40(sp)
    80019c7e:	0080                	addi	s0,sp,64
    80019c80:	fca43423          	sd	a0,-56(s0)
    80019c84:	84ae                	mv	s1,a1
    Job *mem = (Job *)kzalloc(sizeof(Job));
    80019c86:	03800593          	li	a1,56
    80019c8a:	4505                	li	a0,1
    80019c8c:	82afa0ef          	jal	ra,80013cb6 <kcalloc>
    80019c90:	fca43c23          	sd	a0,-40(s0)
    memcpy(mem, &job, sizeof(Job));
    80019c94:	03800613          	li	a2,56
    80019c98:	85a6                	mv	a1,s1
    80019c9a:	fd843503          	ld	a0,-40(s0)
    80019c9e:	78e030ef          	jal	ra,8001d42c <memcpy>
    vector_push_ptr(dev->jobs, mem);
    80019ca2:	fc843783          	ld	a5,-56(s0)
    80019ca6:	63dc                	ld	a5,128(a5)
    80019ca8:	fd843703          	ld	a4,-40(s0)
    80019cac:	85ba                	mv	a1,a4
    80019cae:	853e                	mv	a0,a5
    80019cb0:	16c040ef          	jal	ra,8001de1c <vector_push>
}
    80019cb4:	0001                	nop
    80019cb6:	70e2                	ld	ra,56(sp)
    80019cb8:	7442                	ld	s0,48(sp)
    80019cba:	74a2                	ld	s1,40(sp)
    80019cbc:	6121                	addi	sp,sp,64
    80019cbe:	8082                	ret

0000000080019cc0 <virtio_debug_job>:
//         }
//     }
//     return NULL;
// }

void virtio_debug_job(VirtioDevice *dev, Job *job) {
    80019cc0:	7179                	addi	sp,sp,-48
    80019cc2:	f422                	sd	s0,40(sp)
    80019cc4:	1800                	addi	s0,sp,48
    80019cc6:	fca43c23          	sd	a0,-40(s0)
    80019cca:	fcb43823          	sd	a1,-48(s0)
    debugf("Done %d\n", job->done);
    debugf("Data %p\n", job->data);
    debugf("Context\n");
    debugf("  Num descriptors %d\n", job->context.num_descriptors);
    debugf("  Descriptors\n");
    for (uint16_t i=0; i<job->context.num_descriptors; i++) {
    80019cce:	fe041723          	sh	zero,-18(s0)
    80019cd2:	a031                	j	80019cde <virtio_debug_job+0x1e>
    80019cd4:	fee45783          	lhu	a5,-18(s0)
    80019cd8:	2785                	addiw	a5,a5,1
    80019cda:	fef41723          	sh	a5,-18(s0)
    80019cde:	fd043783          	ld	a5,-48(s0)
    80019ce2:	0207d783          	lhu	a5,32(a5)
    80019ce6:	fee45703          	lhu	a4,-18(s0)
    80019cea:	2701                	sext.w	a4,a4
    80019cec:	2781                	sext.w	a5,a5
    80019cee:	fef763e3          	bltu	a4,a5,80019cd4 <virtio_debug_job+0x14>
        debugf("      addr: %p\n", job->context.desc[i].addr);
        debugf("      len: %d\n", job->context.desc[i].len);
        debugf("      flags: %d\n", job->context.desc[i].flags);
        debugf("      next: %d\n", job->context.desc[i].next);
    }
}
    80019cf2:	0001                	nop
    80019cf4:	0001                	nop
    80019cf6:	7422                	ld	s0,40(sp)
    80019cf8:	6145                	addi	sp,sp,48
    80019cfa:	8082                	ret

0000000080019cfc <virtio_handle_interrupt>:

void virtio_handle_interrupt(VirtioDevice *dev, VirtioDescriptor desc[], uint16_t num_descriptors) {
    80019cfc:	7139                	addi	sp,sp,-64
    80019cfe:	fc06                	sd	ra,56(sp)
    80019d00:	f822                	sd	s0,48(sp)
    80019d02:	0080                	addi	s0,sp,64
    80019d04:	fca43c23          	sd	a0,-40(s0)
    80019d08:	fcb43823          	sd	a1,-48(s0)
    80019d0c:	87b2                	mv	a5,a2
    80019d0e:	fcf41723          	sh	a5,-50(s0)
    uint64_t job_id = virtio_which_job_from_interrupt(dev);
    80019d12:	fd843503          	ld	a0,-40(s0)
    80019d16:	052000ef          	jal	ra,80019d68 <virtio_which_job_from_interrupt>
    80019d1a:	fea43423          	sd	a0,-24(s0)
    if (job_id == -1ULL) {
    80019d1e:	fe843703          	ld	a4,-24(s0)
    80019d22:	57fd                	li	a5,-1
    80019d24:	00f71963          	bne	a4,a5,80019d36 <virtio_handle_interrupt+0x3a>
        warnf("No job found matching interrupt\n");
    80019d28:	00008517          	auipc	a0,0x8
    80019d2c:	72850513          	addi	a0,a0,1832 # 80022450 <pow10.0+0x1220>
    80019d30:	d2aff0ef          	jal	ra,8001925a <warnf>
        return;
    80019d34:	a035                	j	80019d60 <virtio_handle_interrupt+0x64>
    }

    job_set_context(virtio_get_job(dev, job_id), desc, num_descriptors);
    80019d36:	fe843583          	ld	a1,-24(s0)
    80019d3a:	fd843503          	ld	a0,-40(s0)
    80019d3e:	cabff0ef          	jal	ra,800199e8 <virtio_get_job>
    80019d42:	872a                	mv	a4,a0
    80019d44:	fce45783          	lhu	a5,-50(s0)
    80019d48:	863e                	mv	a2,a5
    80019d4a:	fd043583          	ld	a1,-48(s0)
    80019d4e:	853a                	mv	a0,a4
    80019d50:	dc9ff0ef          	jal	ra,80019b18 <job_set_context>

    virtio_complete_job(dev, job_id);
    80019d54:	fe843583          	ld	a1,-24(s0)
    80019d58:	fd843503          	ld	a0,-40(s0)
    80019d5c:	0a0000ef          	jal	ra,80019dfc <virtio_complete_job>
}
    80019d60:	70e2                	ld	ra,56(sp)
    80019d62:	7442                	ld	s0,48(sp)
    80019d64:	6121                	addi	sp,sp,64
    80019d66:	8082                	ret

0000000080019d68 <virtio_which_job_from_interrupt>:

uint64_t virtio_which_job_from_interrupt(VirtioDevice *dev) {
    80019d68:	1101                	addi	sp,sp,-32
    80019d6a:	ec22                	sd	s0,24(sp)
    80019d6c:	1000                	addi	s0,sp,32
    80019d6e:	fea43423          	sd	a0,-24(s0)
    // Get the ID of the job from the descriptor
    return (uint64_t)dev->device_idx - 1;
    80019d72:	fe843783          	ld	a5,-24(s0)
    80019d76:	08c7d783          	lhu	a5,140(a5)
    80019d7a:	17fd                	addi	a5,a5,-1
}
    80019d7c:	853e                	mv	a0,a5
    80019d7e:	6462                	ld	s0,24(sp)
    80019d80:	6105                	addi	sp,sp,32
    80019d82:	8082                	ret

0000000080019d84 <virtio_get_job_id_by_index>:

uint64_t virtio_get_job_id_by_index(VirtioDevice *dev, uint64_t index) {
    80019d84:	7179                	addi	sp,sp,-48
    80019d86:	f406                	sd	ra,40(sp)
    80019d88:	f022                	sd	s0,32(sp)
    80019d8a:	1800                	addi	s0,sp,48
    80019d8c:	fca43c23          	sd	a0,-40(s0)
    80019d90:	fcb43823          	sd	a1,-48(s0)
    Job *job = NULL;
    80019d94:	fe043423          	sd	zero,-24(s0)
    if (index >= vector_size(dev->jobs)) {
    80019d98:	fd843783          	ld	a5,-40(s0)
    80019d9c:	63dc                	ld	a5,128(a5)
    80019d9e:	853e                	mv	a0,a5
    80019da0:	13d040ef          	jal	ra,8001e6dc <vector_size>
    80019da4:	87aa                	mv	a5,a0
    80019da6:	2781                	sext.w	a5,a5
    80019da8:	1782                	slli	a5,a5,0x20
    80019daa:	9381                	srli	a5,a5,0x20
    80019dac:	fd043703          	ld	a4,-48(s0)
    80019db0:	00f76463          	bltu	a4,a5,80019db8 <virtio_get_job_id_by_index+0x34>
        return -1ULL;
    80019db4:	57fd                	li	a5,-1
    80019db6:	a00d                	j	80019dd8 <virtio_get_job_id_by_index+0x54>
    }

    vector_get_ptr(dev->jobs, index, &job);
    80019db8:	fd843783          	ld	a5,-40(s0)
    80019dbc:	63dc                	ld	a5,128(a5)
    80019dbe:	fd043703          	ld	a4,-48(s0)
    80019dc2:	2701                	sext.w	a4,a4
    80019dc4:	fe840693          	addi	a3,s0,-24
    80019dc8:	8636                	mv	a2,a3
    80019dca:	85ba                	mv	a1,a4
    80019dcc:	853e                	mv	a0,a5
    80019dce:	1ae040ef          	jal	ra,8001df7c <vector_get>
    return job->job_id;
    80019dd2:	fe843783          	ld	a5,-24(s0)
    80019dd6:	639c                	ld	a5,0(a5)
}
    80019dd8:	853e                	mv	a0,a5
    80019dda:	70a2                	ld	ra,40(sp)
    80019ddc:	7402                	ld	s0,32(sp)
    80019dde:	6145                	addi	sp,sp,48
    80019de0:	8082                	ret

0000000080019de2 <virtio_get_next_job_id>:

uint64_t virtio_get_next_job_id(VirtioDevice *dev) {
    80019de2:	1101                	addi	sp,sp,-32
    80019de4:	ec22                	sd	s0,24(sp)
    80019de6:	1000                	addi	s0,sp,32
    80019de8:	fea43423          	sd	a0,-24(s0)
    return (uint64_t)dev->device_idx;
    80019dec:	fe843783          	ld	a5,-24(s0)
    80019df0:	08c7d783          	lhu	a5,140(a5)
}
    80019df4:	853e                	mv	a0,a5
    80019df6:	6462                	ld	s0,24(sp)
    80019df8:	6105                	addi	sp,sp,32
    80019dfa:	8082                	ret

0000000080019dfc <virtio_complete_job>:

void virtio_complete_job(VirtioDevice *dev, uint64_t job_id) {
    80019dfc:	7179                	addi	sp,sp,-48
    80019dfe:	f406                	sd	ra,40(sp)
    80019e00:	f022                	sd	s0,32(sp)
    80019e02:	1800                	addi	s0,sp,48
    80019e04:	fca43c23          	sd	a0,-40(s0)
    80019e08:	fcb43823          	sd	a1,-48(s0)
    virtio_acquire_device(dev);
    80019e0c:	fd843503          	ld	a0,-40(s0)
    80019e10:	df9ff0ef          	jal	ra,80019c08 <virtio_acquire_device>
    Job *job = virtio_get_job(dev, job_id);
    80019e14:	fd043583          	ld	a1,-48(s0)
    80019e18:	fd843503          	ld	a0,-40(s0)
    80019e1c:	bcdff0ef          	jal	ra,800199e8 <virtio_get_job>
    80019e20:	fea43423          	sd	a0,-24(s0)
    if (job == NULL) {
    80019e24:	fe843783          	ld	a5,-24(s0)
    80019e28:	ef91                	bnez	a5,80019e44 <virtio_complete_job+0x48>
        warnf("No job found with ID %d\n", job_id);
    80019e2a:	fd043583          	ld	a1,-48(s0)
    80019e2e:	00008517          	auipc	a0,0x8
    80019e32:	64a50513          	addi	a0,a0,1610 # 80022478 <pow10.0+0x1248>
    80019e36:	c24ff0ef          	jal	ra,8001925a <warnf>
        virtio_release_device(dev);
    80019e3a:	fd843503          	ld	a0,-40(s0)
    80019e3e:	e01ff0ef          	jal	ra,80019c3e <virtio_release_device>
        return;
    80019e42:	a899                	j	80019e98 <virtio_complete_job+0x9c>
    }

    if (job->done) {
    80019e44:	fe843783          	ld	a5,-24(s0)
    80019e48:	0107c783          	lbu	a5,16(a5)
    80019e4c:	cf91                	beqz	a5,80019e68 <virtio_complete_job+0x6c>
        warnf("Job %d already done\n", job_id);
    80019e4e:	fd043583          	ld	a1,-48(s0)
    80019e52:	00008517          	auipc	a0,0x8
    80019e56:	64650513          	addi	a0,a0,1606 # 80022498 <pow10.0+0x1268>
    80019e5a:	c00ff0ef          	jal	ra,8001925a <warnf>
        virtio_release_device(dev);
    80019e5e:	fd843503          	ld	a0,-40(s0)
    80019e62:	dddff0ef          	jal	ra,80019c3e <virtio_release_device>
        return;
    80019e66:	a80d                	j	80019e98 <virtio_complete_job+0x9c>
    }
    virtio_callback_and_free_job(dev, job_id);
    80019e68:	fd043583          	ld	a1,-48(s0)
    80019e6c:	fd843503          	ld	a0,-40(s0)
    80019e70:	d1bff0ef          	jal	ra,80019b8a <virtio_callback_and_free_job>
    if (job->done) {
    80019e74:	fe843783          	ld	a5,-24(s0)
    80019e78:	0107c783          	lbu	a5,16(a5)
    80019e7c:	cb91                	beqz	a5,80019e90 <virtio_complete_job+0x94>
        debugf("Job %d done\n", job_id);
        vector_remove_val_ptr(dev->jobs, job);
    80019e7e:	fd843783          	ld	a5,-40(s0)
    80019e82:	63dc                	ld	a5,128(a5)
    80019e84:	fe843703          	ld	a4,-24(s0)
    80019e88:	85ba                	mv	a1,a4
    80019e8a:	853e                	mv	a0,a5
    80019e8c:	45c040ef          	jal	ra,8001e2e8 <vector_remove_value>
    } else {
        debugf("Job %d not done\n", job_id);
    }

    virtio_release_device(dev);
    80019e90:	fd843503          	ld	a0,-40(s0)
    80019e94:	dabff0ef          	jal	ra,80019c3e <virtio_release_device>
}
    80019e98:	70a2                	ld	ra,40(sp)
    80019e9a:	7402                	ld	s0,32(sp)
    80019e9c:	6145                	addi	sp,sp,48
    80019e9e:	8082                	ret

0000000080019ea0 <virtio_get_block_config>:

volatile struct VirtioBlockConfig *virtio_get_block_config(VirtioDevice *device) {
    80019ea0:	1101                	addi	sp,sp,-32
    80019ea2:	ec06                	sd	ra,24(sp)
    80019ea4:	e822                	sd	s0,16(sp)
    80019ea6:	1000                	addi	s0,sp,32
    80019ea8:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioBlockConfig *)pci_get_device_specific_config(device->pcidev);
    80019eac:	fe843783          	ld	a5,-24(s0)
    80019eb0:	63bc                	ld	a5,64(a5)
    80019eb2:	853e                	mv	a0,a5
    80019eb4:	d53f80ef          	jal	ra,80012c06 <pci_get_device_specific_config>
    80019eb8:	87aa                	mv	a5,a0
}
    80019eba:	853e                	mv	a0,a5
    80019ebc:	60e2                	ld	ra,24(sp)
    80019ebe:	6442                	ld	s0,16(sp)
    80019ec0:	6105                	addi	sp,sp,32
    80019ec2:	8082                	ret

0000000080019ec4 <virtio_get_input_config>:

volatile struct VirtioInputConfig *virtio_get_input_config(VirtioDevice *device) {
    80019ec4:	1101                	addi	sp,sp,-32
    80019ec6:	ec06                	sd	ra,24(sp)
    80019ec8:	e822                	sd	s0,16(sp)
    80019eca:	1000                	addi	s0,sp,32
    80019ecc:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioInputConfig *)pci_get_device_specific_config(device->pcidev);
    80019ed0:	fe843783          	ld	a5,-24(s0)
    80019ed4:	63bc                	ld	a5,64(a5)
    80019ed6:	853e                	mv	a0,a5
    80019ed8:	d2ff80ef          	jal	ra,80012c06 <pci_get_device_specific_config>
    80019edc:	87aa                	mv	a5,a0
}
    80019ede:	853e                	mv	a0,a5
    80019ee0:	60e2                	ld	ra,24(sp)
    80019ee2:	6442                	ld	s0,16(sp)
    80019ee4:	6105                	addi	sp,sp,32
    80019ee6:	8082                	ret

0000000080019ee8 <virtio_get_gpu_config>:

volatile struct VirtioGpuConfig *virtio_get_gpu_config(VirtioDevice *device) {
    80019ee8:	1101                	addi	sp,sp,-32
    80019eea:	ec06                	sd	ra,24(sp)
    80019eec:	e822                	sd	s0,16(sp)
    80019eee:	1000                	addi	s0,sp,32
    80019ef0:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioGpuConfig *)pci_get_device_specific_config(device->pcidev);
    80019ef4:	fe843783          	ld	a5,-24(s0)
    80019ef8:	63bc                	ld	a5,64(a5)
    80019efa:	853e                	mv	a0,a5
    80019efc:	d0bf80ef          	jal	ra,80012c06 <pci_get_device_specific_config>
    80019f00:	87aa                	mv	a5,a0
}
    80019f02:	853e                	mv	a0,a5
    80019f04:	60e2                	ld	ra,24(sp)
    80019f06:	6442                	ld	s0,16(sp)
    80019f08:	6105                	addi	sp,sp,32
    80019f0a:	8082                	ret

0000000080019f0c <virtio_get_device_id>:

uint16_t virtio_get_device_id(VirtioDevice *dev) {
    80019f0c:	1101                	addi	sp,sp,-32
    80019f0e:	ec22                	sd	s0,24(sp)
    80019f10:	1000                	addi	s0,sp,32
    80019f12:	fea43423          	sd	a0,-24(s0)
    return dev->pcidev->ecam_header->device_id;
    80019f16:	fe843783          	ld	a5,-24(s0)
    80019f1a:	63bc                	ld	a5,64(a5)
    80019f1c:	639c                	ld	a5,0(a5)
    80019f1e:	0027d783          	lhu	a5,2(a5)
    80019f22:	17c2                	slli	a5,a5,0x30
    80019f24:	93c1                	srli	a5,a5,0x30
}
    80019f26:	853e                	mv	a0,a5
    80019f28:	6462                	ld	s0,24(sp)
    80019f2a:	6105                	addi	sp,sp,32
    80019f2c:	8082                	ret

0000000080019f2e <virtio_is_rng_device>:

bool virtio_is_rng_device(VirtioDevice *dev) {
    80019f2e:	1101                	addi	sp,sp,-32
    80019f30:	ec06                	sd	ra,24(sp)
    80019f32:	e822                	sd	s0,16(sp)
    80019f34:	1000                	addi	s0,sp,32
    80019f36:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_ENTROPY);
    80019f3a:	fe843503          	ld	a0,-24(s0)
    80019f3e:	fcfff0ef          	jal	ra,80019f0c <virtio_get_device_id>
    80019f42:	87aa                	mv	a5,a0
    80019f44:	0007871b          	sext.w	a4,a5
    80019f48:	6785                	lui	a5,0x1
    80019f4a:	04478793          	addi	a5,a5,68 # 1044 <i+0x1024>
    80019f4e:	40f707b3          	sub	a5,a4,a5
    80019f52:	0017b793          	seqz	a5,a5
    80019f56:	0ff7f793          	andi	a5,a5,255
}
    80019f5a:	853e                	mv	a0,a5
    80019f5c:	60e2                	ld	ra,24(sp)
    80019f5e:	6442                	ld	s0,16(sp)
    80019f60:	6105                	addi	sp,sp,32
    80019f62:	8082                	ret

0000000080019f64 <virtio_is_block_device>:

bool virtio_is_block_device(VirtioDevice *dev) {
    80019f64:	1101                	addi	sp,sp,-32
    80019f66:	ec06                	sd	ra,24(sp)
    80019f68:	e822                	sd	s0,16(sp)
    80019f6a:	1000                	addi	s0,sp,32
    80019f6c:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_BLOCK);
    80019f70:	fe843503          	ld	a0,-24(s0)
    80019f74:	f99ff0ef          	jal	ra,80019f0c <virtio_get_device_id>
    80019f78:	87aa                	mv	a5,a0
    80019f7a:	0007871b          	sext.w	a4,a5
    80019f7e:	6785                	lui	a5,0x1
    80019f80:	04278793          	addi	a5,a5,66 # 1042 <i+0x1022>
    80019f84:	40f707b3          	sub	a5,a4,a5
    80019f88:	0017b793          	seqz	a5,a5
    80019f8c:	0ff7f793          	andi	a5,a5,255
}
    80019f90:	853e                	mv	a0,a5
    80019f92:	60e2                	ld	ra,24(sp)
    80019f94:	6442                	ld	s0,16(sp)
    80019f96:	6105                	addi	sp,sp,32
    80019f98:	8082                	ret

0000000080019f9a <virtio_is_input_device>:

bool virtio_is_input_device(VirtioDevice *dev) {
    80019f9a:	1101                	addi	sp,sp,-32
    80019f9c:	ec06                	sd	ra,24(sp)
    80019f9e:	e822                	sd	s0,16(sp)
    80019fa0:	1000                	addi	s0,sp,32
    80019fa2:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_INPUT);
    80019fa6:	fe843503          	ld	a0,-24(s0)
    80019faa:	f63ff0ef          	jal	ra,80019f0c <virtio_get_device_id>
    80019fae:	87aa                	mv	a5,a0
    80019fb0:	0007871b          	sext.w	a4,a5
    80019fb4:	6785                	lui	a5,0x1
    80019fb6:	05278793          	addi	a5,a5,82 # 1052 <i+0x1032>
    80019fba:	40f707b3          	sub	a5,a4,a5
    80019fbe:	0017b793          	seqz	a5,a5
    80019fc2:	0ff7f793          	andi	a5,a5,255
}
    80019fc6:	853e                	mv	a0,a5
    80019fc8:	60e2                	ld	ra,24(sp)
    80019fca:	6442                	ld	s0,16(sp)
    80019fcc:	6105                	addi	sp,sp,32
    80019fce:	8082                	ret

0000000080019fd0 <virtio_is_gpu_device>:

bool virtio_is_gpu_device(VirtioDevice *dev) {
    80019fd0:	1101                	addi	sp,sp,-32
    80019fd2:	ec06                	sd	ra,24(sp)
    80019fd4:	e822                	sd	s0,16(sp)
    80019fd6:	1000                	addi	s0,sp,32
    80019fd8:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_GPU);
    80019fdc:	fe843503          	ld	a0,-24(s0)
    80019fe0:	f2dff0ef          	jal	ra,80019f0c <virtio_get_device_id>
    80019fe4:	87aa                	mv	a5,a0
    80019fe6:	0007871b          	sext.w	a4,a5
    80019fea:	6785                	lui	a5,0x1
    80019fec:	05078793          	addi	a5,a5,80 # 1050 <i+0x1030>
    80019ff0:	40f707b3          	sub	a5,a4,a5
    80019ff4:	0017b793          	seqz	a5,a5
    80019ff8:	0ff7f793          	andi	a5,a5,255
}
    80019ffc:	853e                	mv	a0,a5
    80019ffe:	60e2                	ld	ra,24(sp)
    8001a000:	6442                	ld	s0,16(sp)
    8001a002:	6105                	addi	sp,sp,32
    8001a004:	8082                	ret

000000008001a006 <virtio_get_queue_size>:

uint16_t virtio_get_queue_size(VirtioDevice *dev) {
    8001a006:	1101                	addi	sp,sp,-32
    8001a008:	ec22                	sd	s0,24(sp)
    8001a00a:	1000                	addi	s0,sp,32
    8001a00c:	fea43423          	sd	a0,-24(s0)
    return dev->common_cfg->queue_size;
    8001a010:	fe843783          	ld	a5,-24(s0)
    8001a014:	67bc                	ld	a5,72(a5)
    8001a016:	0187d783          	lhu	a5,24(a5)
    8001a01a:	17c2                	slli	a5,a5,0x30
    8001a01c:	93c1                	srli	a5,a5,0x30
}
    8001a01e:	853e                	mv	a0,a5
    8001a020:	6462                	ld	s0,24(sp)
    8001a022:	6105                	addi	sp,sp,32
    8001a024:	8082                	ret

000000008001a026 <virtio_get_device>:

VirtioDevice *virtio_get_device(uint16_t device_type) {
    8001a026:	7139                	addi	sp,sp,-64
    8001a028:	fc06                	sd	ra,56(sp)
    8001a02a:	f822                	sd	s0,48(sp)
    8001a02c:	f426                	sd	s1,40(sp)
    8001a02e:	0080                	addi	s0,sp,64
    8001a030:	87aa                	mv	a5,a0
    8001a032:	fcf41723          	sh	a5,-50(s0)
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a036:	fc041f23          	sh	zero,-34(s0)
    8001a03a:	a099                	j	8001a080 <virtio_get_device+0x5a>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001a03c:	fde45783          	lhu	a5,-34(s0)
    8001a040:	853e                	mv	a0,a5
    8001a042:	0ce000ef          	jal	ra,8001a110 <virtio_get_nth_saved_device>
    8001a046:	fca43823          	sd	a0,-48(s0)
        if (virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(device_type)) {
    8001a04a:	fd043503          	ld	a0,-48(s0)
    8001a04e:	ebfff0ef          	jal	ra,80019f0c <virtio_get_device_id>
    8001a052:	87aa                	mv	a5,a0
    8001a054:	0007869b          	sext.w	a3,a5
    8001a058:	fce45783          	lhu	a5,-50(s0)
    8001a05c:	0007871b          	sext.w	a4,a5
    8001a060:	6785                	lui	a5,0x1
    8001a062:	0407879b          	addiw	a5,a5,64
    8001a066:	9fb9                	addw	a5,a5,a4
    8001a068:	2781                	sext.w	a5,a5
    8001a06a:	8736                	mv	a4,a3
    8001a06c:	00f71563          	bne	a4,a5,8001a076 <virtio_get_device+0x50>
            return dev;
    8001a070:	fd043783          	ld	a5,-48(s0)
    8001a074:	a025                	j	8001a09c <virtio_get_device+0x76>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a076:	fde45783          	lhu	a5,-34(s0)
    8001a07a:	2785                	addiw	a5,a5,1
    8001a07c:	fcf41f23          	sh	a5,-34(s0)
    8001a080:	fde45483          	lhu	s1,-34(s0)
    8001a084:	18c000ef          	jal	ra,8001a210 <virtio_count_saved_devices>
    8001a088:	87aa                	mv	a5,a0
    8001a08a:	faf4e9e3          	bltu	s1,a5,8001a03c <virtio_get_device+0x16>
        }
    }

    warnf("No device could be found");
    8001a08e:	00008517          	auipc	a0,0x8
    8001a092:	42250513          	addi	a0,a0,1058 # 800224b0 <pow10.0+0x1280>
    8001a096:	9c4ff0ef          	jal	ra,8001925a <warnf>
    return NULL;
    8001a09a:	4781                	li	a5,0
}
    8001a09c:	853e                	mv	a0,a5
    8001a09e:	70e2                	ld	ra,56(sp)
    8001a0a0:	7442                	ld	s0,48(sp)
    8001a0a2:	74a2                	ld	s1,40(sp)
    8001a0a4:	6121                	addi	sp,sp,64
    8001a0a6:	8082                	ret

000000008001a0a8 <virtio_get_rng_device>:

VirtioDevice *virtio_get_rng_device(void) {
    8001a0a8:	1141                	addi	sp,sp,-16
    8001a0aa:	e406                	sd	ra,8(sp)
    8001a0ac:	e022                	sd	s0,0(sp)
    8001a0ae:	0800                	addi	s0,sp,16
    return virtio_get_device(VIRTIO_PCI_DEVICE_ENTROPY);
    8001a0b0:	4511                	li	a0,4
    8001a0b2:	f75ff0ef          	jal	ra,8001a026 <virtio_get_device>
    8001a0b6:	87aa                	mv	a5,a0
}
    8001a0b8:	853e                	mv	a0,a5
    8001a0ba:	60a2                	ld	ra,8(sp)
    8001a0bc:	6402                	ld	s0,0(sp)
    8001a0be:	0141                	addi	sp,sp,16
    8001a0c0:	8082                	ret

000000008001a0c2 <virtio_get_block_device>:

VirtioDevice *virtio_get_block_device(void) {
    8001a0c2:	1141                	addi	sp,sp,-16
    8001a0c4:	e406                	sd	ra,8(sp)
    8001a0c6:	e022                	sd	s0,0(sp)
    8001a0c8:	0800                	addi	s0,sp,16
    return virtio_get_device(VIRTIO_PCI_DEVICE_BLOCK);
    8001a0ca:	4509                	li	a0,2
    8001a0cc:	f5bff0ef          	jal	ra,8001a026 <virtio_get_device>
    8001a0d0:	87aa                	mv	a5,a0
}
    8001a0d2:	853e                	mv	a0,a5
    8001a0d4:	60a2                	ld	ra,8(sp)
    8001a0d6:	6402                	ld	s0,0(sp)
    8001a0d8:	0141                	addi	sp,sp,16
    8001a0da:	8082                	ret

000000008001a0dc <virtio_get_input_device>:

VirtioDevice *virtio_get_input_device(void) {
    8001a0dc:	1141                	addi	sp,sp,-16
    8001a0de:	e406                	sd	ra,8(sp)
    8001a0e0:	e022                	sd	s0,0(sp)
    8001a0e2:	0800                	addi	s0,sp,16
    return virtio_get_device(VIRTIO_PCI_DEVICE_INPUT);
    8001a0e4:	4549                	li	a0,18
    8001a0e6:	f41ff0ef          	jal	ra,8001a026 <virtio_get_device>
    8001a0ea:	87aa                	mv	a5,a0
}
    8001a0ec:	853e                	mv	a0,a5
    8001a0ee:	60a2                	ld	ra,8(sp)
    8001a0f0:	6402                	ld	s0,0(sp)
    8001a0f2:	0141                	addi	sp,sp,16
    8001a0f4:	8082                	ret

000000008001a0f6 <virtio_get_gpu_device>:

VirtioDevice *virtio_get_gpu_device(void) {
    8001a0f6:	1141                	addi	sp,sp,-16
    8001a0f8:	e406                	sd	ra,8(sp)
    8001a0fa:	e022                	sd	s0,0(sp)
    8001a0fc:	0800                	addi	s0,sp,16
    return virtio_get_device(VIRTIO_PCI_DEVICE_GPU);
    8001a0fe:	4541                	li	a0,16
    8001a100:	f27ff0ef          	jal	ra,8001a026 <virtio_get_device>
    8001a104:	87aa                	mv	a5,a0
}
    8001a106:	853e                	mv	a0,a5
    8001a108:	60a2                	ld	ra,8(sp)
    8001a10a:	6402                	ld	s0,0(sp)
    8001a10c:	0141                	addi	sp,sp,16
    8001a10e:	8082                	ret

000000008001a110 <virtio_get_nth_saved_device>:

VirtioDevice *virtio_get_nth_saved_device(uint16_t n) {
    8001a110:	7179                	addi	sp,sp,-48
    8001a112:	f406                	sd	ra,40(sp)
    8001a114:	f022                	sd	s0,32(sp)
    8001a116:	1800                	addi	s0,sp,48
    8001a118:	87aa                	mv	a5,a0
    8001a11a:	fcf41f23          	sh	a5,-34(s0)
    VirtioDevice *result;
    vector_get_ptr(virtio_devices, n, &result);
    8001a11e:	00006797          	auipc	a5,0x6
    8001a122:	01a78793          	addi	a5,a5,26 # 80020138 <virtio_devices>
    8001a126:	639c                	ld	a5,0(a5)
    8001a128:	fde45703          	lhu	a4,-34(s0)
    8001a12c:	2701                	sext.w	a4,a4
    8001a12e:	fe840693          	addi	a3,s0,-24
    8001a132:	8636                	mv	a2,a3
    8001a134:	85ba                	mv	a1,a4
    8001a136:	853e                	mv	a0,a5
    8001a138:	645030ef          	jal	ra,8001df7c <vector_get>
    return result;
    8001a13c:	fe843783          	ld	a5,-24(s0)
}
    8001a140:	853e                	mv	a0,a5
    8001a142:	70a2                	ld	ra,40(sp)
    8001a144:	7402                	ld	s0,32(sp)
    8001a146:	6145                	addi	sp,sp,48
    8001a148:	8082                	ret

000000008001a14a <virtio_save_device>:

void virtio_save_device(VirtioDevice device) {
    8001a14a:	7179                	addi	sp,sp,-48
    8001a14c:	f406                	sd	ra,40(sp)
    8001a14e:	f022                	sd	s0,32(sp)
    8001a150:	ec26                	sd	s1,24(sp)
    8001a152:	1800                	addi	s0,sp,48
    8001a154:	84aa                	mv	s1,a0
    VirtioDevice *mem = (VirtioDevice *)kzalloc(sizeof(VirtioDevice));
    8001a156:	09800593          	li	a1,152
    8001a15a:	4505                	li	a0,1
    8001a15c:	b5bf90ef          	jal	ra,80013cb6 <kcalloc>
    8001a160:	fca43c23          	sd	a0,-40(s0)
    memcpy(mem, &device, sizeof(VirtioDevice));
    8001a164:	09800613          	li	a2,152
    8001a168:	85a6                	mv	a1,s1
    8001a16a:	fd843503          	ld	a0,-40(s0)
    8001a16e:	2be030ef          	jal	ra,8001d42c <memcpy>
    vector_push_ptr(virtio_devices, mem);
    8001a172:	00006797          	auipc	a5,0x6
    8001a176:	fc678793          	addi	a5,a5,-58 # 80020138 <virtio_devices>
    8001a17a:	639c                	ld	a5,0(a5)
    8001a17c:	fd843703          	ld	a4,-40(s0)
    8001a180:	85ba                	mv	a1,a4
    8001a182:	853e                	mv	a0,a5
    8001a184:	499030ef          	jal	ra,8001de1c <vector_push>
}
    8001a188:	0001                	nop
    8001a18a:	70a2                	ld	ra,40(sp)
    8001a18c:	7402                	ld	s0,32(sp)
    8001a18e:	64e2                	ld	s1,24(sp)
    8001a190:	6145                	addi	sp,sp,48
    8001a192:	8082                	ret

000000008001a194 <virtio_from_pci_device>:

VirtioDevice *virtio_from_pci_device(PCIDevice *pcidevice) {
    8001a194:	7179                	addi	sp,sp,-48
    8001a196:	f406                	sd	ra,40(sp)
    8001a198:	f022                	sd	s0,32(sp)
    8001a19a:	1800                	addi	s0,sp,48
    8001a19c:	fca43c23          	sd	a0,-40(s0)
    for(uint32_t i = 0; i < vector_size(virtio_devices);i++){
    8001a1a0:	fe042623          	sw	zero,-20(s0)
    8001a1a4:	a081                	j	8001a1e4 <virtio_from_pci_device+0x50>
        VirtioDevice *curr_virt_device = NULL;
    8001a1a6:	fe043023          	sd	zero,-32(s0)
        vector_get_ptr(virtio_devices, i, &curr_virt_device);
    8001a1aa:	00006797          	auipc	a5,0x6
    8001a1ae:	f8e78793          	addi	a5,a5,-114 # 80020138 <virtio_devices>
    8001a1b2:	639c                	ld	a5,0(a5)
    8001a1b4:	fe040693          	addi	a3,s0,-32
    8001a1b8:	fec42703          	lw	a4,-20(s0)
    8001a1bc:	8636                	mv	a2,a3
    8001a1be:	85ba                	mv	a1,a4
    8001a1c0:	853e                	mv	a0,a5
    8001a1c2:	5bb030ef          	jal	ra,8001df7c <vector_get>
        if(curr_virt_device->pcidev == pcidevice) {
    8001a1c6:	fe043783          	ld	a5,-32(s0)
    8001a1ca:	63bc                	ld	a5,64(a5)
    8001a1cc:	fd843703          	ld	a4,-40(s0)
    8001a1d0:	00f71563          	bne	a4,a5,8001a1da <virtio_from_pci_device+0x46>
            return curr_virt_device;
    8001a1d4:	fe043783          	ld	a5,-32(s0)
    8001a1d8:	a03d                	j	8001a206 <virtio_from_pci_device+0x72>
    for(uint32_t i = 0; i < vector_size(virtio_devices);i++){
    8001a1da:	fec42783          	lw	a5,-20(s0)
    8001a1de:	2785                	addiw	a5,a5,1
    8001a1e0:	fef42623          	sw	a5,-20(s0)
    8001a1e4:	00006797          	auipc	a5,0x6
    8001a1e8:	f5478793          	addi	a5,a5,-172 # 80020138 <virtio_devices>
    8001a1ec:	639c                	ld	a5,0(a5)
    8001a1ee:	853e                	mv	a0,a5
    8001a1f0:	4ec040ef          	jal	ra,8001e6dc <vector_size>
    8001a1f4:	87aa                	mv	a5,a0
    8001a1f6:	0007871b          	sext.w	a4,a5
    8001a1fa:	fec42783          	lw	a5,-20(s0)
    8001a1fe:	2781                	sext.w	a5,a5
    8001a200:	fae7e3e3          	bltu	a5,a4,8001a1a6 <virtio_from_pci_device+0x12>
        }
    }
    return NULL;
    8001a204:	4781                	li	a5,0
}
    8001a206:	853e                	mv	a0,a5
    8001a208:	70a2                	ld	ra,40(sp)
    8001a20a:	7402                	ld	s0,32(sp)
    8001a20c:	6145                	addi	sp,sp,48
    8001a20e:	8082                	ret

000000008001a210 <virtio_count_saved_devices>:

// Get the number of saved Virtio devices.
uint64_t virtio_count_saved_devices(void) {
    8001a210:	1141                	addi	sp,sp,-16
    8001a212:	e406                	sd	ra,8(sp)
    8001a214:	e022                	sd	s0,0(sp)
    8001a216:	0800                	addi	s0,sp,16
    return vector_size(virtio_devices);
    8001a218:	00006797          	auipc	a5,0x6
    8001a21c:	f2078793          	addi	a5,a5,-224 # 80020138 <virtio_devices>
    8001a220:	639c                	ld	a5,0(a5)
    8001a222:	853e                	mv	a0,a5
    8001a224:	4b8040ef          	jal	ra,8001e6dc <vector_size>
    8001a228:	87aa                	mv	a5,a0
    8001a22a:	2781                	sext.w	a5,a5
    8001a22c:	1782                	slli	a5,a5,0x20
    8001a22e:	9381                	srli	a5,a5,0x20
}
    8001a230:	853e                	mv	a0,a5
    8001a232:	60a2                	ld	ra,8(sp)
    8001a234:	6402                	ld	s0,0(sp)
    8001a236:	0141                	addi	sp,sp,16
    8001a238:	8082                	ret

000000008001a23a <virtio_get_capability>:

// Get a virtio capability for a given device by the virtio capability's type.
// If this is zero, it will get the common configuration capability. If this is
// one, it will get the notify capability. If this is two, it will get the ISR
// capability. Etc.
volatile struct VirtioCapability *virtio_get_capability(VirtioDevice *dev, uint8_t type) {
    8001a23a:	1101                	addi	sp,sp,-32
    8001a23c:	ec06                	sd	ra,24(sp)
    8001a23e:	e822                	sd	s0,16(sp)
    8001a240:	1000                	addi	s0,sp,32
    8001a242:	fea43423          	sd	a0,-24(s0)
    8001a246:	87ae                	mv	a5,a1
    8001a248:	fef403a3          	sb	a5,-25(s0)
    return pci_get_virtio_capability(dev->pcidev, type);
    8001a24c:	fe843783          	ld	a5,-24(s0)
    8001a250:	63bc                	ld	a5,64(a5)
    8001a252:	fe744703          	lbu	a4,-25(s0)
    8001a256:	85ba                	mv	a1,a4
    8001a258:	853e                	mv	a0,a5
    8001a25a:	e90f80ef          	jal	ra,800128ea <pci_get_virtio_capability>
    8001a25e:	87aa                	mv	a5,a0
}
    8001a260:	853e                	mv	a0,a5
    8001a262:	60e2                	ld	ra,24(sp)
    8001a264:	6442                	ld	s0,16(sp)
    8001a266:	6105                	addi	sp,sp,32
    8001a268:	8082                	ret

000000008001a26a <virtio_init>:
/**
 * @brief Initialize the virtio system
 */


void virtio_init(void) {
    8001a26a:	7161                	addi	sp,sp,-432
    8001a26c:	f706                	sd	ra,424(sp)
    8001a26e:	f322                	sd	s0,416(sp)
    8001a270:	ef26                	sd	s1,408(sp)
    8001a272:	1b00                	addi	s0,sp,432
    debugf("virtio_init: Initializing virtio system...\n");
    // Initialize the vector of virtio devices
    virtio_devices = vector_new();
    8001a274:	309030ef          	jal	ra,8001dd7c <vector_new>
    8001a278:	872a                	mv	a4,a0
    8001a27a:	00006797          	auipc	a5,0x6
    8001a27e:	ebe78793          	addi	a5,a5,-322 # 80020138 <virtio_devices>
    8001a282:	e398                	sd	a4,0(a5)

    // Get the number of PCI devices saved
    // This will allow us to iterate through all of them and find the virtio devices
    uint64_t num_pci_devices = pci_count_saved_devices();
    8001a284:	ee2f80ef          	jal	ra,80012966 <pci_count_saved_devices>
    8001a288:	fca43423          	sd	a0,-56(s0)
    
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    8001a28c:	fc043c23          	sd	zero,-40(s0)
    8001a290:	acc1                	j	8001a560 <virtio_init+0x2f6>
        // Get the PCI device
        PCIDevice *pcidevice = pci_get_nth_saved_device(i);
    8001a292:	fd843783          	ld	a5,-40(s0)
    8001a296:	17c2                	slli	a5,a5,0x30
    8001a298:	93c1                	srli	a5,a5,0x30
    8001a29a:	853e                	mv	a0,a5
    8001a29c:	821f80ef          	jal	ra,80012abc <pci_get_nth_saved_device>
    8001a2a0:	faa43823          	sd	a0,-80(s0)
        
        // Is this a virtio device?
        if (pci_is_virtio_device(pcidevice)) { // Access through ecam_header
    8001a2a4:	fb043503          	ld	a0,-80(s0)
    8001a2a8:	c8af80ef          	jal	ra,80012732 <pci_is_virtio_device>
    8001a2ac:	87aa                	mv	a5,a0
    8001a2ae:	2a078463          	beqz	a5,8001a556 <virtio_init+0x2ec>

            // Create a new bookkeeping structure for the virtio device
            VirtioDevice viodev;

            // Add the PCI device to the bookkeeping structure
            viodev.pcidev = pcidevice;
    8001a2b2:	fb043783          	ld	a5,-80(s0)
    8001a2b6:	f2f43c23          	sd	a5,-200(s0)
            // Add the common configuration, notify capability, and ISR to the bookkeeping structure
            viodev.common_cfg = pci_get_virtio_common_config(pcidevice);
    8001a2ba:	fb043503          	ld	a0,-80(s0)
    8001a2be:	9a1f80ef          	jal	ra,80012c5e <pci_get_virtio_common_config>
    8001a2c2:	87aa                	mv	a5,a0
    8001a2c4:	f4f43023          	sd	a5,-192(s0)
            viodev.notify_cap = pci_get_virtio_notify_capability(pcidevice);
    8001a2c8:	fb043503          	ld	a0,-80(s0)
    8001a2cc:	9ebf80ef          	jal	ra,80012cb6 <pci_get_virtio_notify_capability>
    8001a2d0:	87aa                	mv	a5,a0
    8001a2d2:	f4f43423          	sd	a5,-184(s0)
            viodev.isr = pci_get_virtio_isr_status(pcidevice);
    8001a2d6:	fb043503          	ld	a0,-80(s0)
    8001a2da:	a41f80ef          	jal	ra,80012d1a <pci_get_virtio_isr_status>
    8001a2de:	87aa                	mv	a5,a0
    8001a2e0:	f4f43823          	sd	a5,-176(s0)
            if (virtio_is_rng_device(&viodev)) {
    8001a2e4:	ef840793          	addi	a5,s0,-264
    8001a2e8:	853e                	mv	a0,a5
    8001a2ea:	c45ff0ef          	jal	ra,80019f2e <virtio_is_rng_device>
    8001a2ee:	87aa                	mv	a5,a0
    8001a2f0:	ef89                	bnez	a5,8001a30a <virtio_init+0xa0>
                debugf("Setting up RNG device\n");
            } else if (virtio_is_block_device(&viodev)) {
    8001a2f2:	ef840793          	addi	a5,s0,-264
    8001a2f6:	853e                	mv	a0,a5
    8001a2f8:	c6dff0ef          	jal	ra,80019f64 <virtio_is_block_device>
    8001a2fc:	87aa                	mv	a5,a0
    8001a2fe:	e791                	bnez	a5,8001a30a <virtio_init+0xa0>
                debugf("Setting up block device\n");
            } else if (virtio_is_input_device(&viodev)) {
    8001a300:	ef840793          	addi	a5,s0,-264
    8001a304:	853e                	mv	a0,a5
    8001a306:	c95ff0ef          	jal	ra,80019f9a <virtio_is_input_device>
            debugf("Common config at 0x%08x\n", viodev.common_cfg);
            debugf("Notify config at 0x%08x\n", viodev.notify_cap);
            debugf("ISR config at 0x%08x\n", viodev.isr);

            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status = VIRTIO_F_RESET;
    8001a30a:	f4043783          	ld	a5,-192(s0)
    8001a30e:	00078a23          	sb	zero,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status = VIRTIO_F_ACKNOWLEDGE;
    8001a312:	f4043783          	ld	a5,-192(s0)
    8001a316:	4705                	li	a4,1
    8001a318:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER;
    8001a31c:	f4043783          	ld	a5,-192(s0)
    8001a320:	0147c783          	lbu	a5,20(a5)
    8001a324:	0ff7f713          	andi	a4,a5,255
    8001a328:	f4043783          	ld	a5,-192(s0)
    8001a32c:	00276713          	ori	a4,a4,2
    8001a330:	0ff77713          	andi	a4,a4,255
    8001a334:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            if (viodev.common_cfg->device_feature & VIRTIO_F_IN_ORDER) {
    8001a338:	f4043783          	ld	a5,-192(s0)
    8001a33c:	43dc                	lw	a5,4(a5)
    8001a33e:	2781                	sext.w	a5,a5
    8001a340:	0237f793          	andi	a5,a5,35
    8001a344:	2781                	sext.w	a5,a5
    8001a346:	cf81                	beqz	a5,8001a35e <virtio_init+0xf4>
                debugf("Device supports in-order\n");
                viodev.common_cfg->driver_feature |= VIRTIO_F_IN_ORDER;
    8001a348:	f4043783          	ld	a5,-192(s0)
    8001a34c:	47dc                	lw	a5,12(a5)
    8001a34e:	0007871b          	sext.w	a4,a5
    8001a352:	f4043783          	ld	a5,-192(s0)
    8001a356:	02376713          	ori	a4,a4,35
    8001a35a:	2701                	sext.w	a4,a4
    8001a35c:	c7d8                	sw	a4,12(a5)
            } else {
                debugf("Device does not support in-order\n");
            }
            viodev.common_cfg->device_status |= VIRTIO_F_FEATURES_OK;
    8001a35e:	f4043783          	ld	a5,-192(s0)
    8001a362:	0147c783          	lbu	a5,20(a5)
    8001a366:	0ff7f713          	andi	a4,a5,255
    8001a36a:	f4043783          	ld	a5,-192(s0)
    8001a36e:	00876713          	ori	a4,a4,8
    8001a372:	0ff77713          	andi	a4,a4,255
    8001a376:	00e78a23          	sb	a4,20(a5)
            if (!(viodev.common_cfg->device_status & VIRTIO_F_FEATURES_OK)) {
    8001a37a:	f4043783          	ld	a5,-192(s0)
    8001a37e:	0147c783          	lbu	a5,20(a5)
    8001a382:	0ff7f793          	andi	a5,a5,255
    8001a386:	2781                	sext.w	a5,a5
    8001a388:	8ba1                	andi	a5,a5,8
    8001a38a:	2781                	sext.w	a5,a5
    8001a38c:	e799                	bnez	a5,8001a39a <virtio_init+0x130>
                warnf("Device does not accept features\n");
    8001a38e:	00008517          	auipc	a0,0x8
    8001a392:	14250513          	addi	a0,a0,322 # 800224d0 <pow10.0+0x12a0>
    8001a396:	ec5fe0ef          	jal	ra,8001925a <warnf>
            }
            
            // Fix qsize below
            viodev.common_cfg->queue_select = 0;
    8001a39a:	f4043783          	ld	a5,-192(s0)
    8001a39e:	00079b23          	sh	zero,22(a5)
            uint16_t qsize = viodev.common_cfg->queue_size;
    8001a3a2:	f4043783          	ld	a5,-192(s0)
    8001a3a6:	0187d783          	lhu	a5,24(a5)
    8001a3aa:	faf41723          	sh	a5,-82(s0)
            debugf("Virtio device has queue size %d\n", qsize);

            // Allocate contiguous physical memory for descriptor table, driver ring, and device ring
            // These are virtual memory pointers that we will use in the OS side.
            viodev.desc = (VirtioDescriptor *)kzalloc(VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
    8001a3ae:	fae45783          	lhu	a5,-82(s0)
    8001a3b2:	2781                	sext.w	a5,a5
    8001a3b4:	0047979b          	slliw	a5,a5,0x4
    8001a3b8:	2781                	sext.w	a5,a5
    8001a3ba:	85be                	mv	a1,a5
    8001a3bc:	4505                	li	a0,1
    8001a3be:	8f9f90ef          	jal	ra,80013cb6 <kcalloc>
    8001a3c2:	87aa                	mv	a5,a0
    8001a3c4:	f4f43c23          	sd	a5,-168(s0)
            viodev.driver = (VirtioDriverRing *)kzalloc(VIRTIO_DRIVER_TABLE_BYTES(qsize));
    8001a3c8:	fae45783          	lhu	a5,-82(s0)
    8001a3cc:	2781                	sext.w	a5,a5
    8001a3ce:	278d                	addiw	a5,a5,3
    8001a3d0:	2781                	sext.w	a5,a5
    8001a3d2:	0017979b          	slliw	a5,a5,0x1
    8001a3d6:	2781                	sext.w	a5,a5
    8001a3d8:	85be                	mv	a1,a5
    8001a3da:	4505                	li	a0,1
    8001a3dc:	8dbf90ef          	jal	ra,80013cb6 <kcalloc>
    8001a3e0:	87aa                	mv	a5,a0
    8001a3e2:	f6f43023          	sd	a5,-160(s0)
            viodev.device = (VirtioDeviceRing *)kzalloc(VIRTIO_DEVICE_TABLE_BYTES(qsize));
    8001a3e6:	fae45783          	lhu	a5,-82(s0)
    8001a3ea:	2781                	sext.w	a5,a5
    8001a3ec:	0037979b          	slliw	a5,a5,0x3
    8001a3f0:	2781                	sext.w	a5,a5
    8001a3f2:	2799                	addiw	a5,a5,6
    8001a3f4:	2781                	sext.w	a5,a5
    8001a3f6:	85be                	mv	a1,a5
    8001a3f8:	4505                	li	a0,1
    8001a3fa:	8bdf90ef          	jal	ra,80013cb6 <kcalloc>
    8001a3fe:	87aa                	mv	a5,a0
    8001a400:	f6f43423          	sd	a5,-152(s0)
            debugf("Descriptor ring size: %d\n", VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
            debugf("Driver ring size: %d\n", VIRTIO_DRIVER_TABLE_BYTES(qsize));
            debugf("Device ring size: %d\n", VIRTIO_DEVICE_TABLE_BYTES(qsize));

            // Initialize the indices
            viodev.desc_idx = 0;
    8001a404:	f8041023          	sh	zero,-128(s0)
            viodev.driver_idx = 0;
    8001a408:	f8041123          	sh	zero,-126(s0)
            viodev.device_idx = 0;
    8001a40c:	f8041223          	sh	zero,-124(s0)

            // Add the physical addresses for the descriptor table, driver ring, and device ring to the common configuration
            // We translate the virtual addresses so the devices can actuall access the memory.
            uint64_t phys_desc = kernel_mmu_translate((uint64_t)viodev.desc),
    8001a410:	f5843783          	ld	a5,-168(s0)
    8001a414:	853e                	mv	a0,a5
    8001a416:	dd3f90ef          	jal	ra,800141e8 <kernel_mmu_translate>
    8001a41a:	faa43023          	sd	a0,-96(s0)
                phys_driver = kernel_mmu_translate((uint64_t)viodev.driver),
    8001a41e:	f6043783          	ld	a5,-160(s0)
    8001a422:	853e                	mv	a0,a5
    8001a424:	dc5f90ef          	jal	ra,800141e8 <kernel_mmu_translate>
    8001a428:	f8a43c23          	sd	a0,-104(s0)
                phys_device = kernel_mmu_translate((uint64_t)viodev.device);
    8001a42c:	f6843783          	ld	a5,-152(s0)
    8001a430:	853e                	mv	a0,a5
    8001a432:	db7f90ef          	jal	ra,800141e8 <kernel_mmu_translate>
    8001a436:	f8a43823          	sd	a0,-112(s0)
            viodev.common_cfg->queue_desc = phys_desc;
    8001a43a:	f4043783          	ld	a5,-192(s0)
    8001a43e:	fa043703          	ld	a4,-96(s0)
    8001a442:	f398                	sd	a4,32(a5)
            viodev.common_cfg->queue_driver = phys_driver;
    8001a444:	f4043783          	ld	a5,-192(s0)
    8001a448:	f9843703          	ld	a4,-104(s0)
    8001a44c:	f798                	sd	a4,40(a5)
            viodev.common_cfg->queue_device = phys_device;
    8001a44e:	f4043783          	ld	a5,-192(s0)
    8001a452:	f9043703          	ld	a4,-112(s0)
    8001a456:	fb98                	sd	a4,48(a5)
            debugf("virtio_init: queue_desc = 0x%08lx physical (0x%08lx virtual)\n", phys_desc, viodev.desc);
            debugf("virtio_init: queue_driver = 0x%08lx physical (0x%08lx virtual)\n", phys_driver, viodev.driver);
            debugf("virtio_init: queue_device = 0x%08lx physical (0x%08lx virtual)\n", phys_device, viodev.device);
            if (viodev.common_cfg->queue_desc != phys_desc) {
    8001a458:	f4043783          	ld	a5,-192(s0)
    8001a45c:	739c                	ld	a5,32(a5)
    8001a45e:	fa043703          	ld	a4,-96(s0)
    8001a462:	02f70363          	beq	a4,a5,8001a488 <virtio_init+0x21e>
                warnf("Device does not reflect physical desc ring  @0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_desc, phys_desc, viodev.common_cfg->queue_desc);
    8001a466:	f4043783          	ld	a5,-192(s0)
    8001a46a:	02078713          	addi	a4,a5,32
    8001a46e:	f4043783          	ld	a5,-192(s0)
    8001a472:	739c                	ld	a5,32(a5)
    8001a474:	86be                	mv	a3,a5
    8001a476:	fa043603          	ld	a2,-96(s0)
    8001a47a:	85ba                	mv	a1,a4
    8001a47c:	00008517          	auipc	a0,0x8
    8001a480:	07c50513          	addi	a0,a0,124 # 800224f8 <pow10.0+0x12c8>
    8001a484:	dd7fe0ef          	jal	ra,8001925a <warnf>
            }
            if (viodev.common_cfg->queue_driver != phys_driver) {
    8001a488:	f4043783          	ld	a5,-192(s0)
    8001a48c:	779c                	ld	a5,40(a5)
    8001a48e:	f9843703          	ld	a4,-104(s0)
    8001a492:	02f70363          	beq	a4,a5,8001a4b8 <virtio_init+0x24e>
                warnf("Device does not reflect physical driver ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_driver, phys_driver, viodev.common_cfg->queue_driver);
    8001a496:	f4043783          	ld	a5,-192(s0)
    8001a49a:	02878713          	addi	a4,a5,40
    8001a49e:	f4043783          	ld	a5,-192(s0)
    8001a4a2:	779c                	ld	a5,40(a5)
    8001a4a4:	86be                	mv	a3,a5
    8001a4a6:	f9843603          	ld	a2,-104(s0)
    8001a4aa:	85ba                	mv	a1,a4
    8001a4ac:	00008517          	auipc	a0,0x8
    8001a4b0:	09c50513          	addi	a0,a0,156 # 80022548 <pow10.0+0x1318>
    8001a4b4:	da7fe0ef          	jal	ra,8001925a <warnf>
            }
            if (viodev.common_cfg->queue_device != phys_device){
    8001a4b8:	f4043783          	ld	a5,-192(s0)
    8001a4bc:	7b9c                	ld	a5,48(a5)
    8001a4be:	f9043703          	ld	a4,-112(s0)
    8001a4c2:	02f70363          	beq	a4,a5,8001a4e8 <virtio_init+0x27e>
                warnf("Device does not reflect physical device ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_device, phys_device, viodev.common_cfg->queue_device);
    8001a4c6:	f4043783          	ld	a5,-192(s0)
    8001a4ca:	03078713          	addi	a4,a5,48
    8001a4ce:	f4043783          	ld	a5,-192(s0)
    8001a4d2:	7b9c                	ld	a5,48(a5)
    8001a4d4:	86be                	mv	a3,a5
    8001a4d6:	f9043603          	ld	a2,-112(s0)
    8001a4da:	85ba                	mv	a1,a4
    8001a4dc:	00008517          	auipc	a0,0x8
    8001a4e0:	0bc50513          	addi	a0,a0,188 # 80022598 <pow10.0+0x1368>
    8001a4e4:	d77fe0ef          	jal	ra,8001925a <warnf>
            }
            debugf("Set up tables for virtio device\n");
            viodev.common_cfg->queue_enable = 1;
    8001a4e8:	f4043783          	ld	a5,-192(s0)
    8001a4ec:	4705                	li	a4,1
    8001a4ee:	00e79e23          	sh	a4,28(a5)
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER_OK;
    8001a4f2:	f4043783          	ld	a5,-192(s0)
    8001a4f6:	0147c783          	lbu	a5,20(a5)
    8001a4fa:	0ff7f713          	andi	a4,a5,255
    8001a4fe:	f4043783          	ld	a5,-192(s0)
    8001a502:	00476713          	ori	a4,a4,4
    8001a506:	0ff77713          	andi	a4,a4,255
    8001a50a:	00e78a23          	sb	a4,20(a5)
            viodev.device->flags = 0;
    8001a50e:	f6843783          	ld	a5,-152(s0)
    8001a512:	00079023          	sh	zero,0(a5)
            viodev.lock = MUTEX_UNLOCKED;
    8001a516:	f8042423          	sw	zero,-120(s0)
            viodev.jobs = vector_new();
    8001a51a:	063030ef          	jal	ra,8001dd7c <vector_new>
    8001a51e:	87aa                	mv	a5,a0
    8001a520:	f6f43c23          	sd	a5,-136(s0)
            virtio_set_device_name(&viodev, "Unknown Virtio Device");
    8001a524:	ef840793          	addi	a5,s0,-264
    8001a528:	00008597          	auipc	a1,0x8
    8001a52c:	0c058593          	addi	a1,a1,192 # 800225e8 <pow10.0+0x13b8>
    8001a530:	853e                	mv	a0,a5
    8001a532:	0ee000ef          	jal	ra,8001a620 <virtio_set_device_name>
            // Add to vector using vector_push
            virtio_save_device(viodev);
    8001a536:	e5040793          	addi	a5,s0,-432
    8001a53a:	ef840713          	addi	a4,s0,-264
    8001a53e:	09800693          	li	a3,152
    8001a542:	8636                	mv	a2,a3
    8001a544:	85ba                	mv	a1,a4
    8001a546:	853e                	mv	a0,a5
    8001a548:	6e5020ef          	jal	ra,8001d42c <memcpy>
    8001a54c:	e5040793          	addi	a5,s0,-432
    8001a550:	853e                	mv	a0,a5
    8001a552:	bf9ff0ef          	jal	ra,8001a14a <virtio_save_device>
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    8001a556:	fd843783          	ld	a5,-40(s0)
    8001a55a:	0785                	addi	a5,a5,1
    8001a55c:	fcf43c23          	sd	a5,-40(s0)
    8001a560:	fd843703          	ld	a4,-40(s0)
    8001a564:	fc843783          	ld	a5,-56(s0)
    8001a568:	d2f765e3          	bltu	a4,a5,8001a292 <virtio_init+0x28>
        }
    }
    rng_device_init();
    8001a56c:	870f80ef          	jal	ra,800125dc <rng_device_init>
    block_device_init();
    8001a570:	3e0010ef          	jal	ra,8001b950 <block_device_init>
    gpu_device_init();
    8001a574:	fb9f90ef          	jal	ra,8001452c <gpu_device_init>
    /*
    loop over every virtio device and initialize based on type
    */

    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a578:	fc041b23          	sh	zero,-42(s0)
    8001a57c:	a82d                	j	8001a5b6 <virtio_init+0x34c>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001a57e:	fd645783          	lhu	a5,-42(s0)
    8001a582:	853e                	mv	a0,a5
    8001a584:	b8dff0ef          	jal	ra,8001a110 <virtio_get_nth_saved_device>
    8001a588:	faa43c23          	sd	a0,-72(s0)
        if(virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_INPUT)){
    8001a58c:	fb843503          	ld	a0,-72(s0)
    8001a590:	97dff0ef          	jal	ra,80019f0c <virtio_get_device_id>
    8001a594:	87aa                	mv	a5,a0
    8001a596:	0007871b          	sext.w	a4,a5
    8001a59a:	6785                	lui	a5,0x1
    8001a59c:	05278793          	addi	a5,a5,82 # 1052 <i+0x1032>
    8001a5a0:	00f71663          	bne	a4,a5,8001a5ac <virtio_init+0x342>
            input_device_init(dev);
    8001a5a4:	fb843503          	ld	a0,-72(s0)
    8001a5a8:	7c1000ef          	jal	ra,8001b568 <input_device_init>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a5ac:	fd645783          	lhu	a5,-42(s0)
    8001a5b0:	2785                	addiw	a5,a5,1
    8001a5b2:	fcf41b23          	sh	a5,-42(s0)
    8001a5b6:	fd645483          	lhu	s1,-42(s0)
    8001a5ba:	c57ff0ef          	jal	ra,8001a210 <virtio_count_saved_devices>
    8001a5be:	87aa                	mv	a5,a0
    8001a5c0:	faf4efe3          	bltu	s1,a5,8001a57e <virtio_init+0x314>
        }
    }
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a5c4:	fc041a23          	sh	zero,-44(s0)
    8001a5c8:	a835                	j	8001a604 <virtio_init+0x39a>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001a5ca:	fd445783          	lhu	a5,-44(s0)
    8001a5ce:	853e                	mv	a0,a5
    8001a5d0:	b41ff0ef          	jal	ra,8001a110 <virtio_get_nth_saved_device>
    8001a5d4:	fca43023          	sd	a0,-64(s0)
        infof("Found device #%u: \"%s\"\n", i, virtio_get_device_name(dev));
    8001a5d8:	fd445783          	lhu	a5,-44(s0)
    8001a5dc:	0007849b          	sext.w	s1,a5
    8001a5e0:	fc043503          	ld	a0,-64(s0)
    8001a5e4:	068000ef          	jal	ra,8001a64c <virtio_get_device_name>
    8001a5e8:	87aa                	mv	a5,a0
    8001a5ea:	863e                	mv	a2,a5
    8001a5ec:	85a6                	mv	a1,s1
    8001a5ee:	00008517          	auipc	a0,0x8
    8001a5f2:	01250513          	addi	a0,a0,18 # 80022600 <pow10.0+0x13d0>
    8001a5f6:	d13fe0ef          	jal	ra,80019308 <infof>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a5fa:	fd445783          	lhu	a5,-44(s0)
    8001a5fe:	2785                	addiw	a5,a5,1
    8001a600:	fcf41a23          	sh	a5,-44(s0)
    8001a604:	fd445483          	lhu	s1,-44(s0)
    8001a608:	c09ff0ef          	jal	ra,8001a210 <virtio_count_saved_devices>
    8001a60c:	87aa                	mv	a5,a0
    8001a60e:	faf4eee3          	bltu	s1,a5,8001a5ca <virtio_init+0x360>
    }
    debugf("virtio_init: Done initializing virtio system\n");
}
    8001a612:	0001                	nop
    8001a614:	0001                	nop
    8001a616:	70ba                	ld	ra,424(sp)
    8001a618:	741a                	ld	s0,416(sp)
    8001a61a:	64fa                	ld	s1,408(sp)
    8001a61c:	615d                	addi	sp,sp,432
    8001a61e:	8082                	ret

000000008001a620 <virtio_set_device_name>:

void virtio_set_device_name(VirtioDevice *dev, const char *name) {
    8001a620:	1101                	addi	sp,sp,-32
    8001a622:	ec06                	sd	ra,24(sp)
    8001a624:	e822                	sd	s0,16(sp)
    8001a626:	1000                	addi	s0,sp,32
    8001a628:	fea43423          	sd	a0,-24(s0)
    8001a62c:	feb43023          	sd	a1,-32(s0)
    strncpy(dev->name, name, sizeof(dev->name));
    8001a630:	fe843783          	ld	a5,-24(s0)
    8001a634:	04000613          	li	a2,64
    8001a638:	fe043583          	ld	a1,-32(s0)
    8001a63c:	853e                	mv	a0,a5
    8001a63e:	50e030ef          	jal	ra,8001db4c <strncpy>
}
    8001a642:	0001                	nop
    8001a644:	60e2                	ld	ra,24(sp)
    8001a646:	6442                	ld	s0,16(sp)
    8001a648:	6105                	addi	sp,sp,32
    8001a64a:	8082                	ret

000000008001a64c <virtio_get_device_name>:

const char *virtio_get_device_name(VirtioDevice *dev) {
    8001a64c:	1101                	addi	sp,sp,-32
    8001a64e:	ec22                	sd	s0,24(sp)
    8001a650:	1000                	addi	s0,sp,32
    8001a652:	fea43423          	sd	a0,-24(s0)
    return dev->name;
    8001a656:	fe843783          	ld	a5,-24(s0)
}
    8001a65a:	853e                	mv	a0,a5
    8001a65c:	6462                	ld	s0,24(sp)
    8001a65e:	6105                	addi	sp,sp,32
    8001a660:	8082                	ret

000000008001a662 <virtio_notify_register>:

// Get the notify capability for the given virtio device.
volatile uint16_t *virtio_notify_register(VirtioDevice *device) {
    8001a662:	715d                	addi	sp,sp,-80
    8001a664:	e486                	sd	ra,72(sp)
    8001a666:	e0a2                	sd	s0,64(sp)
    8001a668:	0880                	addi	s0,sp,80
    8001a66a:	faa43c23          	sd	a0,-72(s0)
    // struct VirtioCapability *vio_cap = pci_get_virtio_capability(device->pcidev, VIRTIO_PCI_CAP_NOTIFY_CFG);
    // volatile VirtioPciNotifyCfg *notify_cap = pci_get_virtio_notify_capability(device->pcidev);
    uint8_t bar_num = device->notify_cap->cap.bar;
    8001a66e:	fb843783          	ld	a5,-72(s0)
    8001a672:	6bbc                	ld	a5,80(a5)
    8001a674:	0047c783          	lbu	a5,4(a5)
    8001a678:	fef407a3          	sb	a5,-17(s0)
    uint64_t offset = device->notify_cap->cap.offset;
    8001a67c:	fb843783          	ld	a5,-72(s0)
    8001a680:	6bbc                	ld	a5,80(a5)
    8001a682:	479c                	lw	a5,8(a5)
    8001a684:	2781                	sext.w	a5,a5
    8001a686:	1782                	slli	a5,a5,0x20
    8001a688:	9381                	srli	a5,a5,0x20
    8001a68a:	fef43023          	sd	a5,-32(s0)
    uint16_t queue_notify_off = device->common_cfg->queue_notify_off;
    8001a68e:	fb843783          	ld	a5,-72(s0)
    8001a692:	67bc                	ld	a5,72(a5)
    8001a694:	01e7d783          	lhu	a5,30(a5)
    8001a698:	fcf41f23          	sh	a5,-34(s0)
    uint32_t notify_off_multiplier = device->notify_cap->notify_off_multiplier;
    8001a69c:	fb843783          	ld	a5,-72(s0)
    8001a6a0:	6bbc                	ld	a5,80(a5)
    8001a6a2:	4b9c                	lw	a5,16(a5)
    8001a6a4:	fcf42c23          	sw	a5,-40(s0)
    uint64_t bar = (uint64_t)pci_get_device_bar(device->pcidev, bar_num);
    8001a6a8:	fb843783          	ld	a5,-72(s0)
    8001a6ac:	63bc                	ld	a5,64(a5)
    8001a6ae:	fef44703          	lbu	a4,-17(s0)
    8001a6b2:	85ba                	mv	a1,a4
    8001a6b4:	853e                	mv	a0,a5
    8001a6b6:	e28f80ef          	jal	ra,80012cde <pci_get_device_bar>
    8001a6ba:	87aa                	mv	a5,a0
    8001a6bc:	fcf43823          	sd	a5,-48(s0)
    // debugf("Notify cap bar=%d offset=%x, (len=%d)\n", bar_num, offset, device->notify_cap->cap.length);
    // debugf("BAR at %x, offset=%x, queue_notify_off=%x, notify_off_mult=%x\n", bar, offset, queue_notify_off, notify_off_multiplier);

    uint16_t *notify = (uint16_t*)(bar + BAR_NOTIFY_CAP(offset, queue_notify_off, notify_off_multiplier));
    8001a6c0:	fde45783          	lhu	a5,-34(s0)
    8001a6c4:	2781                	sext.w	a5,a5
    8001a6c6:	fd842703          	lw	a4,-40(s0)
    8001a6ca:	02f707bb          	mulw	a5,a4,a5
    8001a6ce:	2781                	sext.w	a5,a5
    8001a6d0:	02079713          	slli	a4,a5,0x20
    8001a6d4:	9301                	srli	a4,a4,0x20
    8001a6d6:	fe043783          	ld	a5,-32(s0)
    8001a6da:	973e                	add	a4,a4,a5
    8001a6dc:	fd043783          	ld	a5,-48(s0)
    8001a6e0:	97ba                	add	a5,a5,a4
    8001a6e2:	fcf43423          	sd	a5,-56(s0)
    return notify;
    8001a6e6:	fc843783          	ld	a5,-56(s0)
}
    8001a6ea:	853e                	mv	a0,a5
    8001a6ec:	60a6                	ld	ra,72(sp)
    8001a6ee:	6406                	ld	s0,64(sp)
    8001a6f0:	6161                	addi	sp,sp,80
    8001a6f2:	8082                	ret

000000008001a6f4 <virtio_notify>:
 * @brief Virtio notification
 * @param viodev - virtio device to notify for
 * @param which_queue - queue number to notify
 */
void virtio_notify(VirtioDevice *viodev, uint16_t which_queue)
{
    8001a6f4:	7179                	addi	sp,sp,-48
    8001a6f6:	f406                	sd	ra,40(sp)
    8001a6f8:	f022                	sd	s0,32(sp)
    8001a6fa:	1800                	addi	s0,sp,48
    8001a6fc:	fca43c23          	sd	a0,-40(s0)
    8001a700:	87ae                	mv	a5,a1
    8001a702:	fcf41b23          	sh	a5,-42(s0)
    uint16_t num_queues = viodev->common_cfg->num_queues;
    8001a706:	fd843783          	ld	a5,-40(s0)
    8001a70a:	67bc                	ld	a5,72(a5)
    8001a70c:	0127d783          	lhu	a5,18(a5)
    8001a710:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    8001a714:	fd645703          	lhu	a4,-42(s0)
    8001a718:	fee45783          	lhu	a5,-18(s0)
    8001a71c:	2701                	sext.w	a4,a4
    8001a71e:	2781                	sext.w	a5,a5
    8001a720:	02f76363          	bltu	a4,a5,8001a746 <virtio_notify+0x52>
        warnf("virtio_notify: Provided queue number %d is too big (num_queues=%d) for device %s\n", which_queue, num_queues, viodev->name);
    8001a724:	fd645783          	lhu	a5,-42(s0)
    8001a728:	2781                	sext.w	a5,a5
    8001a72a:	fee45703          	lhu	a4,-18(s0)
    8001a72e:	2701                	sext.w	a4,a4
    8001a730:	fd843683          	ld	a3,-40(s0)
    8001a734:	863a                	mv	a2,a4
    8001a736:	85be                	mv	a1,a5
    8001a738:	00008517          	auipc	a0,0x8
    8001a73c:	ee050513          	addi	a0,a0,-288 # 80022618 <pow10.0+0x13e8>
    8001a740:	b1bfe0ef          	jal	ra,8001925a <warnf>
        return;
    8001a744:	a025                	j	8001a76c <virtio_notify+0x78>
    }

    // Select the queue we are looking at
    viodev->common_cfg->queue_select = which_queue;
    8001a746:	fd843783          	ld	a5,-40(s0)
    8001a74a:	67bc                	ld	a5,72(a5)
    8001a74c:	fd645703          	lhu	a4,-42(s0)
    8001a750:	00e79b23          	sh	a4,22(a5)

    volatile uint16_t *notify_register = virtio_notify_register(viodev);
    8001a754:	fd843503          	ld	a0,-40(s0)
    8001a758:	f0bff0ef          	jal	ra,8001a662 <virtio_notify_register>
    8001a75c:	fea43023          	sd	a0,-32(s0)
    // debugf("Notifying at 0x%p on instruction...\n", notify_register);
    *notify_register = which_queue;
    8001a760:	fe043783          	ld	a5,-32(s0)
    8001a764:	fd645703          	lhu	a4,-42(s0)
    8001a768:	00e79023          	sh	a4,0(a5)
    // debugf("Notified device\n\n");
}
    8001a76c:	70a2                	ld	ra,40(sp)
    8001a76e:	7402                	ld	s0,32(sp)
    8001a770:	6145                	addi	sp,sp,48
    8001a772:	8082                	ret

000000008001a774 <virtio_set_queue_and_get_size>:

// Select the queue and get its size
uint64_t virtio_set_queue_and_get_size(VirtioDevice *device, uint16_t which_queue) {
    8001a774:	7179                	addi	sp,sp,-48
    8001a776:	f406                	sd	ra,40(sp)
    8001a778:	f022                	sd	s0,32(sp)
    8001a77a:	1800                	addi	s0,sp,48
    8001a77c:	fca43c23          	sd	a0,-40(s0)
    8001a780:	87ae                	mv	a5,a1
    8001a782:	fcf41b23          	sh	a5,-42(s0)
    if (device->common_cfg->queue_select != which_queue) {
    8001a786:	fd843783          	ld	a5,-40(s0)
    8001a78a:	67bc                	ld	a5,72(a5)
    8001a78c:	0167d783          	lhu	a5,22(a5)
    8001a790:	17c2                	slli	a5,a5,0x30
    8001a792:	93c1                	srli	a5,a5,0x30
    8001a794:	fd645703          	lhu	a4,-42(s0)
    8001a798:	2701                	sext.w	a4,a4
    8001a79a:	2781                	sext.w	a5,a5
    8001a79c:	00f70963          	beq	a4,a5,8001a7ae <virtio_set_queue_and_get_size+0x3a>
        device->common_cfg->queue_select = which_queue;
    8001a7a0:	fd843783          	ld	a5,-40(s0)
    8001a7a4:	67bc                	ld	a5,72(a5)
    8001a7a6:	fd645703          	lhu	a4,-42(s0)
    8001a7aa:	00e79b23          	sh	a4,22(a5)
    }
    uint16_t num_queues = device->common_cfg->num_queues;
    8001a7ae:	fd843783          	ld	a5,-40(s0)
    8001a7b2:	67bc                	ld	a5,72(a5)
    8001a7b4:	0127d783          	lhu	a5,18(a5)
    8001a7b8:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    8001a7bc:	fd645703          	lhu	a4,-42(s0)
    8001a7c0:	fee45783          	lhu	a5,-18(s0)
    8001a7c4:	2701                	sext.w	a4,a4
    8001a7c6:	2781                	sext.w	a5,a5
    8001a7c8:	02f76263          	bltu	a4,a5,8001a7ec <virtio_set_queue_and_get_size+0x78>
        warnf("virtio_notify: Provided queue number %d is too big (num_queues=%d)...\n", which_queue, num_queues);
    8001a7cc:	fd645783          	lhu	a5,-42(s0)
    8001a7d0:	2781                	sext.w	a5,a5
    8001a7d2:	fee45703          	lhu	a4,-18(s0)
    8001a7d6:	2701                	sext.w	a4,a4
    8001a7d8:	863a                	mv	a2,a4
    8001a7da:	85be                	mv	a1,a5
    8001a7dc:	00008517          	auipc	a0,0x8
    8001a7e0:	e9450513          	addi	a0,a0,-364 # 80022670 <pow10.0+0x1440>
    8001a7e4:	a77fe0ef          	jal	ra,8001925a <warnf>
        return -1ULL;
    8001a7e8:	57fd                	li	a5,-1
    8001a7ea:	a801                	j	8001a7fa <virtio_set_queue_and_get_size+0x86>
    }

    return device->common_cfg->queue_size;
    8001a7ec:	fd843783          	ld	a5,-40(s0)
    8001a7f0:	67bc                	ld	a5,72(a5)
    8001a7f2:	0187d783          	lhu	a5,24(a5)
    8001a7f6:	17c2                	slli	a5,a5,0x30
    8001a7f8:	93c1                	srli	a5,a5,0x30
}
    8001a7fa:	853e                	mv	a0,a5
    8001a7fc:	70a2                	ld	ra,40(sp)
    8001a7fe:	7402                	ld	s0,32(sp)
    8001a800:	6145                	addi	sp,sp,48
    8001a802:	8082                	ret

000000008001a804 <virtio_send_one_descriptor>:

void virtio_send_one_descriptor(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor descriptor, bool notify_device_when_done) {
    8001a804:	7179                	addi	sp,sp,-48
    8001a806:	f406                	sd	ra,40(sp)
    8001a808:	f022                	sd	s0,32(sp)
    8001a80a:	1800                	addi	s0,sp,48
    8001a80c:	fea43423          	sd	a0,-24(s0)
    8001a810:	87ae                	mv	a5,a1
    8001a812:	fcc43823          	sd	a2,-48(s0)
    8001a816:	fcd43c23          	sd	a3,-40(s0)
    8001a81a:	fef41323          	sh	a5,-26(s0)
    8001a81e:	87ba                	mv	a5,a4
    8001a820:	fef402a3          	sb	a5,-27(s0)
    virtio_send_descriptor_chain(device, which_queue, &descriptor, 1, notify_device_when_done);
    8001a824:	fe544703          	lbu	a4,-27(s0)
    8001a828:	fd040613          	addi	a2,s0,-48
    8001a82c:	fe645783          	lhu	a5,-26(s0)
    8001a830:	4685                	li	a3,1
    8001a832:	85be                	mv	a1,a5
    8001a834:	fe843503          	ld	a0,-24(s0)
    8001a838:	00e000ef          	jal	ra,8001a846 <virtio_send_descriptor_chain>
}
    8001a83c:	0001                	nop
    8001a83e:	70a2                	ld	ra,40(sp)
    8001a840:	7402                	ld	s0,32(sp)
    8001a842:	6145                	addi	sp,sp,48
    8001a844:	8082                	ret

000000008001a846 <virtio_send_descriptor_chain>:


void virtio_send_descriptor_chain(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor *descriptors, uint16_t num_descriptors, bool notify_device_when_done) {
    8001a846:	711d                	addi	sp,sp,-96
    8001a848:	ec86                	sd	ra,88(sp)
    8001a84a:	e8a2                	sd	s0,80(sp)
    8001a84c:	1080                	addi	s0,sp,96
    8001a84e:	faa43c23          	sd	a0,-72(s0)
    8001a852:	87ae                	mv	a5,a1
    8001a854:	fac43423          	sd	a2,-88(s0)
    8001a858:	faf41b23          	sh	a5,-74(s0)
    8001a85c:	87b6                	mv	a5,a3
    8001a85e:	faf41a23          	sh	a5,-76(s0)
    8001a862:	87ba                	mv	a5,a4
    8001a864:	faf409a3          	sb	a5,-77(s0)
    // Confirm the device is ready
    if (!device->ready) {
    8001a868:	fb843783          	ld	a5,-72(s0)
    8001a86c:	08e7c783          	lbu	a5,142(a5)
    8001a870:	0017c793          	xori	a5,a5,1
    8001a874:	0ff7f793          	andi	a5,a5,255
    8001a878:	cb81                	beqz	a5,8001a888 <virtio_send_descriptor_chain+0x42>
        fatalf("device is not ready\n");
    8001a87a:	00008517          	auipc	a0,0x8
    8001a87e:	e3e50513          	addi	a0,a0,-450 # 800226b8 <pow10.0+0x1488>
    8001a882:	addfe0ef          	jal	ra,8001935e <fatalf>
        return;
    8001a886:	aae9                	j	8001aa60 <virtio_send_descriptor_chain+0x21a>
    }

    virtio_acquire_device(device);
    8001a888:	fb843503          	ld	a0,-72(s0)
    8001a88c:	b7cff0ef          	jal	ra,80019c08 <virtio_acquire_device>

    // Select the queue we're using
    if (which_queue >= device->common_cfg->num_queues) {
    8001a890:	fb843783          	ld	a5,-72(s0)
    8001a894:	67bc                	ld	a5,72(a5)
    8001a896:	0127d783          	lhu	a5,18(a5)
    8001a89a:	17c2                	slli	a5,a5,0x30
    8001a89c:	93c1                	srli	a5,a5,0x30
    8001a89e:	fb645703          	lhu	a4,-74(s0)
    8001a8a2:	2701                	sext.w	a4,a4
    8001a8a4:	2781                	sext.w	a5,a5
    8001a8a6:	02f76763          	bltu	a4,a5,8001a8d4 <virtio_send_descriptor_chain+0x8e>
        fatalf("queue number %d is too big (num_queues=%d)\n", which_queue, device->common_cfg->num_queues);
    8001a8aa:	fb645783          	lhu	a5,-74(s0)
    8001a8ae:	0007871b          	sext.w	a4,a5
    8001a8b2:	fb843783          	ld	a5,-72(s0)
    8001a8b6:	67bc                	ld	a5,72(a5)
    8001a8b8:	0127d783          	lhu	a5,18(a5)
    8001a8bc:	17c2                	slli	a5,a5,0x30
    8001a8be:	93c1                	srli	a5,a5,0x30
    8001a8c0:	2781                	sext.w	a5,a5
    8001a8c2:	863e                	mv	a2,a5
    8001a8c4:	85ba                	mv	a1,a4
    8001a8c6:	00008517          	auipc	a0,0x8
    8001a8ca:	e0a50513          	addi	a0,a0,-502 # 800226d0 <pow10.0+0x14a0>
    8001a8ce:	a91fe0ef          	jal	ra,8001935e <fatalf>
        return;
    8001a8d2:	a279                	j	8001aa60 <virtio_send_descriptor_chain+0x21a>
    }

    // The size of the queue we're using
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    8001a8d4:	fb645783          	lhu	a5,-74(s0)
    8001a8d8:	85be                	mv	a1,a5
    8001a8da:	fb843503          	ld	a0,-72(s0)
    8001a8de:	e97ff0ef          	jal	ra,8001a774 <virtio_set_queue_and_get_size>
    8001a8e2:	fea43023          	sd	a0,-32(s0)
#define VIRTQ_DESC_F_NEXT 1
#define VIRTQ_DESC_F_WRITE 2
#define VIRTQ_DESC_F_INDIRECT 4
    uint16_t    flags;
    uint16_t    next;*/
    device->driver_idx = device->driver->idx;
    8001a8e6:	fb843783          	ld	a5,-72(s0)
    8001a8ea:	77bc                	ld	a5,104(a5)
    8001a8ec:	0027d783          	lhu	a5,2(a5)
    8001a8f0:	03079713          	slli	a4,a5,0x30
    8001a8f4:	9341                	srli	a4,a4,0x30
    8001a8f6:	fb843783          	ld	a5,-72(s0)
    8001a8fa:	08e79523          	sh	a4,138(a5)
    uint64_t head_descriptor_index = device->desc_idx;
    8001a8fe:	fb843783          	ld	a5,-72(s0)
    8001a902:	0887d783          	lhu	a5,136(a5)
    8001a906:	fcf43c23          	sd	a5,-40(s0)
    for (int i=0; i<num_descriptors; i++) {
    8001a90a:	fe042623          	sw	zero,-20(s0)
    8001a90e:	a075                	j	8001a9ba <virtio_send_descriptor_chain+0x174>
        uint64_t descriptor_index = (device->desc_idx + i) % queue_size;
    8001a910:	fb843783          	ld	a5,-72(s0)
    8001a914:	0887d783          	lhu	a5,136(a5)
    8001a918:	2781                	sext.w	a5,a5
    8001a91a:	fec42703          	lw	a4,-20(s0)
    8001a91e:	9fb9                	addw	a5,a5,a4
    8001a920:	2781                	sext.w	a5,a5
    8001a922:	873e                	mv	a4,a5
    8001a924:	fe043783          	ld	a5,-32(s0)
    8001a928:	02f777b3          	remu	a5,a4,a5
    8001a92c:	fcf43823          	sd	a5,-48(s0)
        // debugf("Writing descriptor %d to queue %d\n", descriptor_index, which_queue);
        VirtioDescriptor descriptor = descriptors[i];
    8001a930:	fec42783          	lw	a5,-20(s0)
    8001a934:	0792                	slli	a5,a5,0x4
    8001a936:	fa843703          	ld	a4,-88(s0)
    8001a93a:	97ba                	add	a5,a5,a4
    8001a93c:	6398                	ld	a4,0(a5)
    8001a93e:	fce43023          	sd	a4,-64(s0)
    8001a942:	679c                	ld	a5,8(a5)
    8001a944:	fcf43423          	sd	a5,-56(s0)
        descriptor.next = (descriptor_index + 1) % queue_size;
    8001a948:	fd043783          	ld	a5,-48(s0)
    8001a94c:	00178713          	addi	a4,a5,1
    8001a950:	fe043783          	ld	a5,-32(s0)
    8001a954:	02f777b3          	remu	a5,a4,a5
    8001a958:	17c2                	slli	a5,a5,0x30
    8001a95a:	93c1                	srli	a5,a5,0x30
    8001a95c:	fcf41723          	sh	a5,-50(s0)
        if (i < num_descriptors - 1) {
    8001a960:	fb445783          	lhu	a5,-76(s0)
    8001a964:	2781                	sext.w	a5,a5
    8001a966:	37fd                	addiw	a5,a5,-1
    8001a968:	0007871b          	sext.w	a4,a5
    8001a96c:	fec42783          	lw	a5,-20(s0)
    8001a970:	2781                	sext.w	a5,a5
    8001a972:	00e7db63          	bge	a5,a4,8001a988 <virtio_send_descriptor_chain+0x142>
            descriptor.flags |= VIRTQ_DESC_F_NEXT;
    8001a976:	fcc45783          	lhu	a5,-52(s0)
    8001a97a:	0017e793          	ori	a5,a5,1
    8001a97e:	17c2                	slli	a5,a5,0x30
    8001a980:	93c1                	srli	a5,a5,0x30
    8001a982:	fcf41623          	sh	a5,-52(s0)
    8001a986:	a801                	j	8001a996 <virtio_send_descriptor_chain+0x150>
        } else {
            descriptor.flags &= ~VIRTQ_DESC_F_NEXT;
    8001a988:	fcc45783          	lhu	a5,-52(s0)
    8001a98c:	9bf9                	andi	a5,a5,-2
    8001a98e:	17c2                	slli	a5,a5,0x30
    8001a990:	93c1                	srli	a5,a5,0x30
    8001a992:	fcf41623          	sh	a5,-52(s0)
        // debugf("Descriptor addr: %p\n", descriptor.addr);
        // debugf("Descriptor len: 0x%x = %d\n", descriptor.len, descriptor.len);
        // debugf("Descriptor flags: 0x%x = %d\n", descriptor.flags, descriptor.flags);
        // debugf("Descriptor next: 0x%x = %d\n", descriptor.next, descriptor.next);
        // Put the descriptor in the descriptor table
        device->desc[descriptor_index] = descriptor;
    8001a996:	fb843783          	ld	a5,-72(s0)
    8001a99a:	73b8                	ld	a4,96(a5)
    8001a99c:	fd043783          	ld	a5,-48(s0)
    8001a9a0:	0792                	slli	a5,a5,0x4
    8001a9a2:	97ba                	add	a5,a5,a4
    8001a9a4:	fc043703          	ld	a4,-64(s0)
    8001a9a8:	e398                	sd	a4,0(a5)
    8001a9aa:	fc843703          	ld	a4,-56(s0)
    8001a9ae:	e798                	sd	a4,8(a5)
    for (int i=0; i<num_descriptors; i++) {
    8001a9b0:	fec42783          	lw	a5,-20(s0)
    8001a9b4:	2785                	addiw	a5,a5,1
    8001a9b6:	fef42623          	sw	a5,-20(s0)
    8001a9ba:	fb445783          	lhu	a5,-76(s0)
    8001a9be:	0007871b          	sext.w	a4,a5
    8001a9c2:	fec42783          	lw	a5,-20(s0)
    8001a9c6:	2781                	sext.w	a5,a5
    8001a9c8:	f4e7c4e3          	blt	a5,a4,8001a910 <virtio_send_descriptor_chain+0xca>
    }
    // Put the descriptor into the driver ring
    device->driver->ring[device->driver->idx % queue_size] = head_descriptor_index;
    8001a9cc:	fb843783          	ld	a5,-72(s0)
    8001a9d0:	77b4                	ld	a3,104(a5)
    8001a9d2:	fb843783          	ld	a5,-72(s0)
    8001a9d6:	77bc                	ld	a5,104(a5)
    8001a9d8:	0027d783          	lhu	a5,2(a5)
    8001a9dc:	17c2                	slli	a5,a5,0x30
    8001a9de:	93c1                	srli	a5,a5,0x30
    8001a9e0:	873e                	mv	a4,a5
    8001a9e2:	fe043783          	ld	a5,-32(s0)
    8001a9e6:	02f777b3          	remu	a5,a4,a5
    8001a9ea:	fd843703          	ld	a4,-40(s0)
    8001a9ee:	1742                	slli	a4,a4,0x30
    8001a9f0:	9341                	srli	a4,a4,0x30
    8001a9f2:	0786                	slli	a5,a5,0x1
    8001a9f4:	97b6                	add	a5,a5,a3
    8001a9f6:	00e79223          	sh	a4,4(a5)
    // Increment the index to make it "visible" to the device
    device->driver->idx++;
    8001a9fa:	fb843783          	ld	a5,-72(s0)
    8001a9fe:	77bc                	ld	a5,104(a5)
    8001aa00:	0027d703          	lhu	a4,2(a5)
    8001aa04:	1742                	slli	a4,a4,0x30
    8001aa06:	9341                	srli	a4,a4,0x30
    8001aa08:	2705                	addiw	a4,a4,1
    8001aa0a:	1742                	slli	a4,a4,0x30
    8001aa0c:	9341                	srli	a4,a4,0x30
    8001aa0e:	00e79123          	sh	a4,2(a5)
    // Update the descriptor index for our bookkeeping
    device->desc_idx = (device->desc_idx + num_descriptors) % queue_size;
    8001aa12:	fb843783          	ld	a5,-72(s0)
    8001aa16:	0887d783          	lhu	a5,136(a5)
    8001aa1a:	0007871b          	sext.w	a4,a5
    8001aa1e:	fb445783          	lhu	a5,-76(s0)
    8001aa22:	2781                	sext.w	a5,a5
    8001aa24:	9fb9                	addw	a5,a5,a4
    8001aa26:	2781                	sext.w	a5,a5
    8001aa28:	873e                	mv	a4,a5
    8001aa2a:	fe043783          	ld	a5,-32(s0)
    8001aa2e:	02f777b3          	remu	a5,a4,a5
    8001aa32:	03079713          	slli	a4,a5,0x30
    8001aa36:	9341                	srli	a4,a4,0x30
    8001aa38:	fb843783          	ld	a5,-72(s0)
    8001aa3c:	08e79423          	sh	a4,136(a5)

    // debugf("Driver index: %d\n", device->driver->idx);
    // debugf("Descriptor index: %d\n", device->desc_idx);
    
    virtio_release_device(device);
    8001aa40:	fb843503          	ld	a0,-72(s0)
    8001aa44:	9faff0ef          	jal	ra,80019c3e <virtio_release_device>

    // Notify the device if we're ready to do so
    if (notify_device_when_done) {
    8001aa48:	fb344783          	lbu	a5,-77(s0)
    8001aa4c:	0ff7f793          	andi	a5,a5,255
    8001aa50:	cb81                	beqz	a5,8001aa60 <virtio_send_descriptor_chain+0x21a>
        virtio_notify(device, which_queue);
    8001aa52:	fb645783          	lhu	a5,-74(s0)
    8001aa56:	85be                	mv	a1,a5
    8001aa58:	fb843503          	ld	a0,-72(s0)
    8001aa5c:	c99ff0ef          	jal	ra,8001a6f4 <virtio_notify>
    }
}
    8001aa60:	60e6                	ld	ra,88(sp)
    8001aa62:	6446                	ld	s0,80(sp)
    8001aa64:	6125                	addi	sp,sp,96
    8001aa66:	8082                	ret

000000008001aa68 <virtio_receive_descriptor_chain>:


uint16_t virtio_receive_descriptor_chain(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor *received, uint16_t max_descriptors, bool wait_for_descriptor) {
    8001aa68:	715d                	addi	sp,sp,-80
    8001aa6a:	e486                	sd	ra,72(sp)
    8001aa6c:	e0a2                	sd	s0,64(sp)
    8001aa6e:	0880                	addi	s0,sp,80
    8001aa70:	fca43423          	sd	a0,-56(s0)
    8001aa74:	87ae                	mv	a5,a1
    8001aa76:	fac43c23          	sd	a2,-72(s0)
    8001aa7a:	fcf41323          	sh	a5,-58(s0)
    8001aa7e:	87b6                	mv	a5,a3
    8001aa80:	fcf41223          	sh	a5,-60(s0)
    8001aa84:	87ba                	mv	a5,a4
    8001aa86:	fcf401a3          	sb	a5,-61(s0)
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    8001aa8a:	fc645783          	lhu	a5,-58(s0)
    8001aa8e:	85be                	mv	a1,a5
    8001aa90:	fc843503          	ld	a0,-56(s0)
    8001aa94:	ce1ff0ef          	jal	ra,8001a774 <virtio_set_queue_and_get_size>
    8001aa98:	fca43c23          	sd	a0,-40(s0)
    if (wait_for_descriptor) {
    8001aa9c:	fc344783          	lbu	a5,-61(s0)
    8001aaa0:	0ff7f793          	andi	a5,a5,255
    8001aaa4:	cb81                	beqz	a5,8001aab4 <virtio_receive_descriptor_chain+0x4c>
        virtio_wait_for_descriptor(device, which_queue);
    8001aaa6:	fc645783          	lhu	a5,-58(s0)
    8001aaaa:	85be                	mv	a1,a5
    8001aaac:	fc843503          	ld	a0,-56(s0)
    8001aab0:	1fc000ef          	jal	ra,8001acac <virtio_wait_for_descriptor>
    }

    if (!virtio_has_received_descriptor(device, which_queue)) {
    8001aab4:	fc645783          	lhu	a5,-58(s0)
    8001aab8:	85be                	mv	a1,a5
    8001aaba:	fc843503          	ld	a0,-56(s0)
    8001aabe:	1a0000ef          	jal	ra,8001ac5e <virtio_has_received_descriptor>
    8001aac2:	87aa                	mv	a5,a0
    8001aac4:	0017c793          	xori	a5,a5,1
    8001aac8:	0ff7f793          	andi	a5,a5,255
    8001aacc:	cb89                	beqz	a5,8001aade <virtio_receive_descriptor_chain+0x76>
        warnf("No descriptor received\n");
    8001aace:	00008517          	auipc	a0,0x8
    8001aad2:	c3250513          	addi	a0,a0,-974 # 80022700 <pow10.0+0x14d0>
    8001aad6:	f84fe0ef          	jal	ra,8001925a <warnf>
        return 0;
    8001aada:	4781                	li	a5,0
    8001aadc:	a209                	j	8001abde <virtio_receive_descriptor_chain+0x176>
    }
    

    // Get the descriptor index from the device ring
    uint64_t descriptor_index = device->device->ring[device->device_idx % queue_size].id;
    8001aade:	fc843783          	ld	a5,-56(s0)
    8001aae2:	7bb8                	ld	a4,112(a5)
    8001aae4:	fc843783          	ld	a5,-56(s0)
    8001aae8:	08c7d783          	lhu	a5,140(a5)
    8001aaec:	86be                	mv	a3,a5
    8001aaee:	fd843783          	ld	a5,-40(s0)
    8001aaf2:	02f6f7b3          	remu	a5,a3,a5
    8001aaf6:	078e                	slli	a5,a5,0x3
    8001aaf8:	97ba                	add	a5,a5,a4
    8001aafa:	43dc                	lw	a5,4(a5)
    8001aafc:	2781                	sext.w	a5,a5
    8001aafe:	1782                	slli	a5,a5,0x20
    8001ab00:	9381                	srli	a5,a5,0x20
    8001ab02:	fcf43823          	sd	a5,-48(s0)
    // Get the length of the descriptor
    volatile VirtioDescriptor *descriptor = (volatile VirtioDescriptor*)&device->desc[descriptor_index];
    8001ab06:	fc843783          	ld	a5,-56(s0)
    8001ab0a:	73b8                	ld	a4,96(a5)
    8001ab0c:	fd043783          	ld	a5,-48(s0)
    8001ab10:	0792                	slli	a5,a5,0x4
    8001ab12:	97ba                	add	a5,a5,a4
    8001ab14:	fef43423          	sd	a5,-24(s0)

    uint16_t i = 0;
    8001ab18:	fe041323          	sh	zero,-26(s0)
    while (descriptor->flags & VIRTQ_DESC_F_NEXT) {
    8001ab1c:	a091                	j	8001ab60 <virtio_receive_descriptor_chain+0xf8>
        received[i++] = *descriptor;
    8001ab1e:	fe645783          	lhu	a5,-26(s0)
    8001ab22:	0017871b          	addiw	a4,a5,1
    8001ab26:	fee41323          	sh	a4,-26(s0)
    8001ab2a:	0792                	slli	a5,a5,0x4
    8001ab2c:	fb843703          	ld	a4,-72(s0)
    8001ab30:	97ba                	add	a5,a5,a4
    8001ab32:	fe843703          	ld	a4,-24(s0)
    8001ab36:	6314                	ld	a3,0(a4)
    8001ab38:	e394                	sd	a3,0(a5)
    8001ab3a:	6718                	ld	a4,8(a4)
    8001ab3c:	e798                	sd	a4,8(a5)
        // debugf("Reading descriptor %d from queue %d\n", descriptor_index, which_queue);
        // debugf("Descriptor addr: %p\n", descriptor->addr);
        // debugf("Descriptor len: 0x%x = %d\n", descriptor->len, descriptor->len);
        // debugf("Descriptor flags: 0x%x = %d\n", descriptor->flags, descriptor->flags);
        // debugf("Descriptor next: 0x%x = %d\n", descriptor->next, descriptor->next);
        descriptor_index = descriptor->next;
    8001ab3e:	fe843783          	ld	a5,-24(s0)
    8001ab42:	00e7d783          	lhu	a5,14(a5)
    8001ab46:	17c2                	slli	a5,a5,0x30
    8001ab48:	93c1                	srli	a5,a5,0x30
    8001ab4a:	fcf43823          	sd	a5,-48(s0)
        descriptor = (volatile VirtioDescriptor*)&device->desc[descriptor_index];
    8001ab4e:	fc843783          	ld	a5,-56(s0)
    8001ab52:	73b8                	ld	a4,96(a5)
    8001ab54:	fd043783          	ld	a5,-48(s0)
    8001ab58:	0792                	slli	a5,a5,0x4
    8001ab5a:	97ba                	add	a5,a5,a4
    8001ab5c:	fef43423          	sd	a5,-24(s0)
    while (descriptor->flags & VIRTQ_DESC_F_NEXT) {
    8001ab60:	fe843783          	ld	a5,-24(s0)
    8001ab64:	00c7d783          	lhu	a5,12(a5)
    8001ab68:	17c2                	slli	a5,a5,0x30
    8001ab6a:	93c1                	srli	a5,a5,0x30
    8001ab6c:	2781                	sext.w	a5,a5
    8001ab6e:	8b85                	andi	a5,a5,1
    8001ab70:	2781                	sext.w	a5,a5
    8001ab72:	f7d5                	bnez	a5,8001ab1e <virtio_receive_descriptor_chain+0xb6>
    }

    received[i] = *descriptor;
    8001ab74:	fe645783          	lhu	a5,-26(s0)
    8001ab78:	0792                	slli	a5,a5,0x4
    8001ab7a:	fb843703          	ld	a4,-72(s0)
    8001ab7e:	97ba                	add	a5,a5,a4
    8001ab80:	fe843703          	ld	a4,-24(s0)
    8001ab84:	6314                	ld	a3,0(a4)
    8001ab86:	e394                	sd	a3,0(a5)
    8001ab88:	6718                	ld	a4,8(a4)
    8001ab8a:	e798                	sd	a4,8(a5)
    // debugf("Reading descriptor %d from queue %d\n", i, which_queue);
    // debugf("Descriptor addr: %p\n", descriptor->addr);
    // debugf("Descriptor len: 0x%x = %d\n", descriptor->len, descriptor->len);
    // debugf("Descriptor flags: 0x%x = %d\n", descriptor->flags, descriptor->flags);
    // debugf("Descriptor next: 0x%x = %d\n", descriptor->next, descriptor->next);
    i++;
    8001ab8c:	fe645783          	lhu	a5,-26(s0)
    8001ab90:	2785                	addiw	a5,a5,1
    8001ab92:	fef41323          	sh	a5,-26(s0)
    device->device_idx = device->device->idx;
    8001ab96:	fc843783          	ld	a5,-56(s0)
    8001ab9a:	7bbc                	ld	a5,112(a5)
    8001ab9c:	0027d783          	lhu	a5,2(a5)
    8001aba0:	03079713          	slli	a4,a5,0x30
    8001aba4:	9341                	srli	a4,a4,0x30
    8001aba6:	fc843783          	ld	a5,-56(s0)
    8001abaa:	08e79623          	sh	a4,140(a5)
    if (i > max_descriptors) {
    8001abae:	fe645703          	lhu	a4,-26(s0)
    8001abb2:	fc445783          	lhu	a5,-60(s0)
    8001abb6:	2701                	sext.w	a4,a4
    8001abb8:	2781                	sext.w	a5,a5
    8001abba:	02e7f063          	bgeu	a5,a4,8001abda <virtio_receive_descriptor_chain+0x172>
        warnf("Received %d descriptors, but expected %d or fewer\n", i, max_descriptors);
    8001abbe:	fe645783          	lhu	a5,-26(s0)
    8001abc2:	2781                	sext.w	a5,a5
    8001abc4:	fc445703          	lhu	a4,-60(s0)
    8001abc8:	2701                	sext.w	a4,a4
    8001abca:	863a                	mv	a2,a4
    8001abcc:	85be                	mv	a1,a5
    8001abce:	00008517          	auipc	a0,0x8
    8001abd2:	b4a50513          	addi	a0,a0,-1206 # 80022718 <pow10.0+0x14e8>
    8001abd6:	e84fe0ef          	jal	ra,8001925a <warnf>
    }
    return i;
    8001abda:	fe645783          	lhu	a5,-26(s0)
}
    8001abde:	853e                	mv	a0,a5
    8001abe0:	60a6                	ld	ra,72(sp)
    8001abe2:	6406                	ld	s0,64(sp)
    8001abe4:	6161                	addi	sp,sp,80
    8001abe6:	8082                	ret

000000008001abe8 <virtio_receive_one_descriptor>:

VirtioDescriptor virtio_receive_one_descriptor(VirtioDevice *device, uint16_t which_queue, bool wait_for_descriptor) {
    8001abe8:	715d                	addi	sp,sp,-80
    8001abea:	e486                	sd	ra,72(sp)
    8001abec:	e0a2                	sd	s0,64(sp)
    8001abee:	fc4a                	sd	s2,56(sp)
    8001abf0:	f84e                	sd	s3,48(sp)
    8001abf2:	0880                	addi	s0,sp,80
    8001abf4:	faa43c23          	sd	a0,-72(s0)
    8001abf8:	87ae                	mv	a5,a1
    8001abfa:	8732                	mv	a4,a2
    8001abfc:	faf41b23          	sh	a5,-74(s0)
    8001ac00:	87ba                	mv	a5,a4
    8001ac02:	faf40aa3          	sb	a5,-75(s0)
    VirtioDescriptor received;
    received.addr = 0;
    8001ac06:	fc043023          	sd	zero,-64(s0)
    received.flags = 0;
    8001ac0a:	fc041623          	sh	zero,-52(s0)
    received.len = 0;
    8001ac0e:	fc042423          	sw	zero,-56(s0)
    received.next = 0;
    8001ac12:	fc041723          	sh	zero,-50(s0)
    virtio_receive_descriptor_chain(device, which_queue, &received, 1, wait_for_descriptor);
    8001ac16:	fb544703          	lbu	a4,-75(s0)
    8001ac1a:	fc040613          	addi	a2,s0,-64
    8001ac1e:	fb645783          	lhu	a5,-74(s0)
    8001ac22:	4685                	li	a3,1
    8001ac24:	85be                	mv	a1,a5
    8001ac26:	fb843503          	ld	a0,-72(s0)
    8001ac2a:	e3fff0ef          	jal	ra,8001aa68 <virtio_receive_descriptor_chain>
    return received;
    8001ac2e:	fc043783          	ld	a5,-64(s0)
    8001ac32:	fcf43823          	sd	a5,-48(s0)
    8001ac36:	fc843783          	ld	a5,-56(s0)
    8001ac3a:	fcf43c23          	sd	a5,-40(s0)
    8001ac3e:	fd043703          	ld	a4,-48(s0)
    8001ac42:	fd843783          	ld	a5,-40(s0)
    8001ac46:	893a                	mv	s2,a4
    8001ac48:	89be                	mv	s3,a5
    8001ac4a:	874a                	mv	a4,s2
    8001ac4c:	87ce                	mv	a5,s3
}
    8001ac4e:	853a                	mv	a0,a4
    8001ac50:	85be                	mv	a1,a5
    8001ac52:	60a6                	ld	ra,72(sp)
    8001ac54:	6406                	ld	s0,64(sp)
    8001ac56:	7962                	ld	s2,56(sp)
    8001ac58:	79c2                	ld	s3,48(sp)
    8001ac5a:	6161                	addi	sp,sp,80
    8001ac5c:	8082                	ret

000000008001ac5e <virtio_has_received_descriptor>:

bool virtio_has_received_descriptor(VirtioDevice *device, uint16_t which_queue) {
    8001ac5e:	1101                	addi	sp,sp,-32
    8001ac60:	ec06                	sd	ra,24(sp)
    8001ac62:	e822                	sd	s0,16(sp)
    8001ac64:	1000                	addi	s0,sp,32
    8001ac66:	fea43423          	sd	a0,-24(s0)
    8001ac6a:	87ae                	mv	a5,a1
    8001ac6c:	fef41323          	sh	a5,-26(s0)
    virtio_set_queue_and_get_size(device, which_queue);
    8001ac70:	fe645783          	lhu	a5,-26(s0)
    8001ac74:	85be                	mv	a1,a5
    8001ac76:	fe843503          	ld	a0,-24(s0)
    8001ac7a:	afbff0ef          	jal	ra,8001a774 <virtio_set_queue_and_get_size>
    if (device->device_idx == device->device->idx) {
    8001ac7e:	fe843783          	ld	a5,-24(s0)
    8001ac82:	08c7d703          	lhu	a4,140(a5)
    8001ac86:	fe843783          	ld	a5,-24(s0)
    8001ac8a:	7bbc                	ld	a5,112(a5)
    8001ac8c:	0027d783          	lhu	a5,2(a5)
    8001ac90:	17c2                	slli	a5,a5,0x30
    8001ac92:	93c1                	srli	a5,a5,0x30
    8001ac94:	2701                	sext.w	a4,a4
    8001ac96:	2781                	sext.w	a5,a5
    8001ac98:	00f71463          	bne	a4,a5,8001aca0 <virtio_has_received_descriptor+0x42>
        return false;
    8001ac9c:	4781                	li	a5,0
    8001ac9e:	a011                	j	8001aca2 <virtio_has_received_descriptor+0x44>
    }
    return true;
    8001aca0:	4785                	li	a5,1
}
    8001aca2:	853e                	mv	a0,a5
    8001aca4:	60e2                	ld	ra,24(sp)
    8001aca6:	6442                	ld	s0,16(sp)
    8001aca8:	6105                	addi	sp,sp,32
    8001acaa:	8082                	ret

000000008001acac <virtio_wait_for_descriptor>:

void virtio_wait_for_descriptor(VirtioDevice *device, uint16_t which_queue) {
    8001acac:	1101                	addi	sp,sp,-32
    8001acae:	ec06                	sd	ra,24(sp)
    8001acb0:	e822                	sd	s0,16(sp)
    8001acb2:	1000                	addi	s0,sp,32
    8001acb4:	fea43423          	sd	a0,-24(s0)
    8001acb8:	87ae                	mv	a5,a1
    8001acba:	fef41323          	sh	a5,-26(s0)
    while (!virtio_has_received_descriptor(device, which_queue)) {
    8001acbe:	0001                	nop
    8001acc0:	fe645783          	lhu	a5,-26(s0)
    8001acc4:	85be                	mv	a1,a5
    8001acc6:	fe843503          	ld	a0,-24(s0)
    8001acca:	f95ff0ef          	jal	ra,8001ac5e <virtio_has_received_descriptor>
    8001acce:	87aa                	mv	a5,a0
    8001acd0:	0017c793          	xori	a5,a5,1
    8001acd4:	0ff7f793          	andi	a5,a5,255
    8001acd8:	f7e5                	bnez	a5,8001acc0 <virtio_wait_for_descriptor+0x14>
        debugf("Blocking on descriptor\n");
        // Do nothing
    }
}
    8001acda:	0001                	nop
    8001acdc:	0001                	nop
    8001acde:	60e2                	ld	ra,24(sp)
    8001ace0:	6442                	ld	s0,16(sp)
    8001ace2:	6105                	addi	sp,sp,32
    8001ace4:	8082                	ret

000000008001ace6 <set_taken>:

static uint8_t *bookkeeping;  // Pointer to the bookkeeping area

// For some reason, the macros didn't work for me, so I used the static functions like Marz said and it works.
static void set_taken(uint64_t index)
{
    8001ace6:	1101                	addi	sp,sp,-32
    8001ace8:	ec22                	sd	s0,24(sp)
    8001acea:	1000                	addi	s0,sp,32
    8001acec:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2));
    8001acf0:	00005797          	auipc	a5,0x5
    8001acf4:	45078793          	addi	a5,a5,1104 # 80020140 <bookkeeping>
    8001acf8:	6398                	ld	a4,0(a5)
    8001acfa:	fe843783          	ld	a5,-24(s0)
    8001acfe:	8389                	srli	a5,a5,0x2
    8001ad00:	973e                	add	a4,a4,a5
    8001ad02:	00074703          	lbu	a4,0(a4) # ffffffffc0fff000 <_heap_end+0xffffffff38fef000>
    8001ad06:	0187169b          	slliw	a3,a4,0x18
    8001ad0a:	4186d69b          	sraiw	a3,a3,0x18
    8001ad0e:	fe843703          	ld	a4,-24(s0)
    8001ad12:	2701                	sext.w	a4,a4
    8001ad14:	8b0d                	andi	a4,a4,3
    8001ad16:	2701                	sext.w	a4,a4
    8001ad18:	0017171b          	slliw	a4,a4,0x1
    8001ad1c:	2701                	sext.w	a4,a4
    8001ad1e:	4605                	li	a2,1
    8001ad20:	00e6173b          	sllw	a4,a2,a4
    8001ad24:	2701                	sext.w	a4,a4
    8001ad26:	0187171b          	slliw	a4,a4,0x18
    8001ad2a:	4187571b          	sraiw	a4,a4,0x18
    8001ad2e:	8f55                	or	a4,a4,a3
    8001ad30:	0187169b          	slliw	a3,a4,0x18
    8001ad34:	4186d69b          	sraiw	a3,a3,0x18
    8001ad38:	00005717          	auipc	a4,0x5
    8001ad3c:	40870713          	addi	a4,a4,1032 # 80020140 <bookkeeping>
    8001ad40:	6318                	ld	a4,0(a4)
    8001ad42:	97ba                	add	a5,a5,a4
    8001ad44:	0ff6f713          	andi	a4,a3,255
    8001ad48:	00e78023          	sb	a4,0(a5)
}
    8001ad4c:	0001                	nop
    8001ad4e:	6462                	ld	s0,24(sp)
    8001ad50:	6105                	addi	sp,sp,32
    8001ad52:	8082                	ret

000000008001ad54 <clear_taken>:

static void clear_taken(uint64_t index)
{
    8001ad54:	1101                	addi	sp,sp,-32
    8001ad56:	ec22                	sd	s0,24(sp)
    8001ad58:	1000                	addi	s0,sp,32
    8001ad5a:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2));
    8001ad5e:	00005797          	auipc	a5,0x5
    8001ad62:	3e278793          	addi	a5,a5,994 # 80020140 <bookkeeping>
    8001ad66:	6398                	ld	a4,0(a5)
    8001ad68:	fe843783          	ld	a5,-24(s0)
    8001ad6c:	8389                	srli	a5,a5,0x2
    8001ad6e:	973e                	add	a4,a4,a5
    8001ad70:	00074703          	lbu	a4,0(a4)
    8001ad74:	0187169b          	slliw	a3,a4,0x18
    8001ad78:	4186d69b          	sraiw	a3,a3,0x18
    8001ad7c:	fe843703          	ld	a4,-24(s0)
    8001ad80:	2701                	sext.w	a4,a4
    8001ad82:	8b0d                	andi	a4,a4,3
    8001ad84:	2701                	sext.w	a4,a4
    8001ad86:	0017171b          	slliw	a4,a4,0x1
    8001ad8a:	2701                	sext.w	a4,a4
    8001ad8c:	4605                	li	a2,1
    8001ad8e:	00e6173b          	sllw	a4,a2,a4
    8001ad92:	2701                	sext.w	a4,a4
    8001ad94:	0187171b          	slliw	a4,a4,0x18
    8001ad98:	4187571b          	sraiw	a4,a4,0x18
    8001ad9c:	fff74713          	not	a4,a4
    8001ada0:	0187171b          	slliw	a4,a4,0x18
    8001ada4:	4187571b          	sraiw	a4,a4,0x18
    8001ada8:	8f75                	and	a4,a4,a3
    8001adaa:	0187169b          	slliw	a3,a4,0x18
    8001adae:	4186d69b          	sraiw	a3,a3,0x18
    8001adb2:	00005717          	auipc	a4,0x5
    8001adb6:	38e70713          	addi	a4,a4,910 # 80020140 <bookkeeping>
    8001adba:	6318                	ld	a4,0(a4)
    8001adbc:	97ba                	add	a5,a5,a4
    8001adbe:	0ff6f713          	andi	a4,a3,255
    8001adc2:	00e78023          	sb	a4,0(a5)
}
    8001adc6:	0001                	nop
    8001adc8:	6462                	ld	s0,24(sp)
    8001adca:	6105                	addi	sp,sp,32
    8001adcc:	8082                	ret

000000008001adce <is_taken>:

static int is_taken(uint64_t index)
{
    8001adce:	1101                	addi	sp,sp,-32
    8001add0:	ec22                	sd	s0,24(sp)
    8001add2:	1000                	addi	s0,sp,32
    8001add4:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2));
    8001add8:	00005797          	auipc	a5,0x5
    8001addc:	36878793          	addi	a5,a5,872 # 80020140 <bookkeeping>
    8001ade0:	6398                	ld	a4,0(a5)
    8001ade2:	fe843783          	ld	a5,-24(s0)
    8001ade6:	8389                	srli	a5,a5,0x2
    8001ade8:	97ba                	add	a5,a5,a4
    8001adea:	0007c783          	lbu	a5,0(a5)
    8001adee:	0007871b          	sext.w	a4,a5
    8001adf2:	fe843783          	ld	a5,-24(s0)
    8001adf6:	2781                	sext.w	a5,a5
    8001adf8:	8b8d                	andi	a5,a5,3
    8001adfa:	2781                	sext.w	a5,a5
    8001adfc:	0017979b          	slliw	a5,a5,0x1
    8001ae00:	2781                	sext.w	a5,a5
    8001ae02:	4685                	li	a3,1
    8001ae04:	00f697bb          	sllw	a5,a3,a5
    8001ae08:	2781                	sext.w	a5,a5
    8001ae0a:	8ff9                	and	a5,a5,a4
    8001ae0c:	2781                	sext.w	a5,a5
}
    8001ae0e:	853e                	mv	a0,a5
    8001ae10:	6462                	ld	s0,24(sp)
    8001ae12:	6105                	addi	sp,sp,32
    8001ae14:	8082                	ret

000000008001ae16 <set_last>:

static void set_last(uint64_t index)
{
    8001ae16:	1101                	addi	sp,sp,-32
    8001ae18:	ec22                	sd	s0,24(sp)
    8001ae1a:	1000                	addi	s0,sp,32
    8001ae1c:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2 + 1));
    8001ae20:	00005797          	auipc	a5,0x5
    8001ae24:	32078793          	addi	a5,a5,800 # 80020140 <bookkeeping>
    8001ae28:	6398                	ld	a4,0(a5)
    8001ae2a:	fe843783          	ld	a5,-24(s0)
    8001ae2e:	8389                	srli	a5,a5,0x2
    8001ae30:	973e                	add	a4,a4,a5
    8001ae32:	00074703          	lbu	a4,0(a4)
    8001ae36:	0187169b          	slliw	a3,a4,0x18
    8001ae3a:	4186d69b          	sraiw	a3,a3,0x18
    8001ae3e:	fe843703          	ld	a4,-24(s0)
    8001ae42:	2701                	sext.w	a4,a4
    8001ae44:	8b0d                	andi	a4,a4,3
    8001ae46:	2701                	sext.w	a4,a4
    8001ae48:	0017171b          	slliw	a4,a4,0x1
    8001ae4c:	2701                	sext.w	a4,a4
    8001ae4e:	2705                	addiw	a4,a4,1
    8001ae50:	2701                	sext.w	a4,a4
    8001ae52:	4605                	li	a2,1
    8001ae54:	00e6173b          	sllw	a4,a2,a4
    8001ae58:	2701                	sext.w	a4,a4
    8001ae5a:	0187171b          	slliw	a4,a4,0x18
    8001ae5e:	4187571b          	sraiw	a4,a4,0x18
    8001ae62:	8f55                	or	a4,a4,a3
    8001ae64:	0187169b          	slliw	a3,a4,0x18
    8001ae68:	4186d69b          	sraiw	a3,a3,0x18
    8001ae6c:	00005717          	auipc	a4,0x5
    8001ae70:	2d470713          	addi	a4,a4,724 # 80020140 <bookkeeping>
    8001ae74:	6318                	ld	a4,0(a4)
    8001ae76:	97ba                	add	a5,a5,a4
    8001ae78:	0ff6f713          	andi	a4,a3,255
    8001ae7c:	00e78023          	sb	a4,0(a5)
}
    8001ae80:	0001                	nop
    8001ae82:	6462                	ld	s0,24(sp)
    8001ae84:	6105                	addi	sp,sp,32
    8001ae86:	8082                	ret

000000008001ae88 <clear_last>:

static void clear_last(uint64_t index)
{
    8001ae88:	1101                	addi	sp,sp,-32
    8001ae8a:	ec22                	sd	s0,24(sp)
    8001ae8c:	1000                	addi	s0,sp,32
    8001ae8e:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2 + 1));
    8001ae92:	00005797          	auipc	a5,0x5
    8001ae96:	2ae78793          	addi	a5,a5,686 # 80020140 <bookkeeping>
    8001ae9a:	6398                	ld	a4,0(a5)
    8001ae9c:	fe843783          	ld	a5,-24(s0)
    8001aea0:	8389                	srli	a5,a5,0x2
    8001aea2:	973e                	add	a4,a4,a5
    8001aea4:	00074703          	lbu	a4,0(a4)
    8001aea8:	0187169b          	slliw	a3,a4,0x18
    8001aeac:	4186d69b          	sraiw	a3,a3,0x18
    8001aeb0:	fe843703          	ld	a4,-24(s0)
    8001aeb4:	2701                	sext.w	a4,a4
    8001aeb6:	8b0d                	andi	a4,a4,3
    8001aeb8:	2701                	sext.w	a4,a4
    8001aeba:	0017171b          	slliw	a4,a4,0x1
    8001aebe:	2701                	sext.w	a4,a4
    8001aec0:	2705                	addiw	a4,a4,1
    8001aec2:	2701                	sext.w	a4,a4
    8001aec4:	4605                	li	a2,1
    8001aec6:	00e6173b          	sllw	a4,a2,a4
    8001aeca:	2701                	sext.w	a4,a4
    8001aecc:	0187171b          	slliw	a4,a4,0x18
    8001aed0:	4187571b          	sraiw	a4,a4,0x18
    8001aed4:	fff74713          	not	a4,a4
    8001aed8:	0187171b          	slliw	a4,a4,0x18
    8001aedc:	4187571b          	sraiw	a4,a4,0x18
    8001aee0:	8f75                	and	a4,a4,a3
    8001aee2:	0187169b          	slliw	a3,a4,0x18
    8001aee6:	4186d69b          	sraiw	a3,a3,0x18
    8001aeea:	00005717          	auipc	a4,0x5
    8001aeee:	25670713          	addi	a4,a4,598 # 80020140 <bookkeeping>
    8001aef2:	6318                	ld	a4,0(a4)
    8001aef4:	97ba                	add	a5,a5,a4
    8001aef6:	0ff6f713          	andi	a4,a3,255
    8001aefa:	00e78023          	sb	a4,0(a5)
}
    8001aefe:	0001                	nop
    8001af00:	6462                	ld	s0,24(sp)
    8001af02:	6105                	addi	sp,sp,32
    8001af04:	8082                	ret

000000008001af06 <is_last>:

static int is_last(uint64_t index)
{
    8001af06:	1101                	addi	sp,sp,-32
    8001af08:	ec22                	sd	s0,24(sp)
    8001af0a:	1000                	addi	s0,sp,32
    8001af0c:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2 + 1));
    8001af10:	00005797          	auipc	a5,0x5
    8001af14:	23078793          	addi	a5,a5,560 # 80020140 <bookkeeping>
    8001af18:	6398                	ld	a4,0(a5)
    8001af1a:	fe843783          	ld	a5,-24(s0)
    8001af1e:	8389                	srli	a5,a5,0x2
    8001af20:	97ba                	add	a5,a5,a4
    8001af22:	0007c783          	lbu	a5,0(a5)
    8001af26:	0007871b          	sext.w	a4,a5
    8001af2a:	fe843783          	ld	a5,-24(s0)
    8001af2e:	2781                	sext.w	a5,a5
    8001af30:	8b8d                	andi	a5,a5,3
    8001af32:	2781                	sext.w	a5,a5
    8001af34:	0017979b          	slliw	a5,a5,0x1
    8001af38:	2781                	sext.w	a5,a5
    8001af3a:	2785                	addiw	a5,a5,1
    8001af3c:	2781                	sext.w	a5,a5
    8001af3e:	4685                	li	a3,1
    8001af40:	00f697bb          	sllw	a5,a3,a5
    8001af44:	2781                	sext.w	a5,a5
    8001af46:	8ff9                	and	a5,a5,a4
    8001af48:	2781                	sext.w	a5,a5
}
    8001af4a:	853e                	mv	a0,a5
    8001af4c:	6462                	ld	s0,24(sp)
    8001af4e:	6105                	addi	sp,sp,32
    8001af50:	8082                	ret

000000008001af52 <page_init>:

void page_init(void)
{
    8001af52:	1101                	addi	sp,sp,-32
    8001af54:	ec06                	sd	ra,24(sp)
    8001af56:	e822                	sd	s0,16(sp)
    8001af58:	1000                	addi	s0,sp,32
    /* Initialize the page system. */
    bookkeeping = (uint8_t*)sym_start(heap);
    8001af5a:	00005797          	auipc	a5,0x5
    8001af5e:	1e678793          	addi	a5,a5,486 # 80020140 <bookkeeping>
    8001af62:	00012717          	auipc	a4,0x12
    8001af66:	09e70713          	addi	a4,a4,158 # 8002d000 <_heap_start>
    8001af6a:	e398                	sd	a4,0(a5)
    
    // Print bookkeeping area
    mutex_spinlock(&page_lock);
    8001af6c:	00005517          	auipc	a0,0x5
    8001af70:	09c50513          	addi	a0,a0,156 # 80020008 <page_lock>
    8001af74:	e2bf80ef          	jal	ra,80013d9e <mutex_spinlock>

    // Initialize the bookkeeping area
    memset(bookkeeping, 0, BK_SIZE_IN_BYTES);
    8001af78:	00005797          	auipc	a5,0x5
    8001af7c:	1c878793          	addi	a5,a5,456 # 80020140 <bookkeeping>
    8001af80:	6394                	ld	a3,0(a5)
    8001af82:	07ff5717          	auipc	a4,0x7ff5
    8001af86:	07e70713          	addi	a4,a4,126 # 88010000 <_heap_end>
    8001af8a:	00012797          	auipc	a5,0x12
    8001af8e:	07678793          	addi	a5,a5,118 # 8002d000 <_heap_start>
    8001af92:	40f707b3          	sub	a5,a4,a5
    8001af96:	83b9                	srli	a5,a5,0xe
    8001af98:	0007871b          	sext.w	a4,a5
    8001af9c:	6785                	lui	a5,0x1
    8001af9e:	37fd                	addiw	a5,a5,-1
    8001afa0:	9fb9                	addw	a5,a5,a4
    8001afa2:	2781                	sext.w	a5,a5
    8001afa4:	0007871b          	sext.w	a4,a5
    8001afa8:	77fd                	lui	a5,0xfffff
    8001afaa:	8ff9                	and	a5,a5,a4
    8001afac:	2781                	sext.w	a5,a5
    8001afae:	863e                	mv	a2,a5
    8001afb0:	4581                	li	a1,0
    8001afb2:	8536                	mv	a0,a3
    8001afb4:	376020ef          	jal	ra,8001d32a <memset>
    // Mark the bookkeeping pages as taken
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    8001afb8:	fe043423          	sd	zero,-24(s0)
    8001afbc:	a811                	j	8001afd0 <page_init+0x7e>
        set_taken(i);
    8001afbe:	fe843503          	ld	a0,-24(s0)
    8001afc2:	d25ff0ef          	jal	ra,8001ace6 <set_taken>
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    8001afc6:	fe843783          	ld	a5,-24(s0)
    8001afca:	0785                	addi	a5,a5,1
    8001afcc:	fef43423          	sd	a5,-24(s0)
    8001afd0:	07ff5717          	auipc	a4,0x7ff5
    8001afd4:	03070713          	addi	a4,a4,48 # 88010000 <_heap_end>
    8001afd8:	00012797          	auipc	a5,0x12
    8001afdc:	02878793          	addi	a5,a5,40 # 8002d000 <_heap_start>
    8001afe0:	40f707b3          	sub	a5,a4,a5
    8001afe4:	00e7d713          	srli	a4,a5,0xe
    8001afe8:	6785                	lui	a5,0x1
    8001afea:	17fd                	addi	a5,a5,-1
    8001afec:	97ba                	add	a5,a5,a4
    8001afee:	83b1                	srli	a5,a5,0xc
    8001aff0:	fe843703          	ld	a4,-24(s0)
    8001aff4:	fcf765e3          	bltu	a4,a5,8001afbe <page_init+0x6c>
    }
    set_last(BK_SIZE_IN_PAGES-1);
    8001aff8:	07ff5717          	auipc	a4,0x7ff5
    8001affc:	00870713          	addi	a4,a4,8 # 88010000 <_heap_end>
    8001b000:	00012797          	auipc	a5,0x12
    8001b004:	00078793          	mv	a5,a5
    8001b008:	40f707b3          	sub	a5,a4,a5
    8001b00c:	00e7d713          	srli	a4,a5,0xe
    8001b010:	6785                	lui	a5,0x1
    8001b012:	17fd                	addi	a5,a5,-1
    8001b014:	97ba                	add	a5,a5,a4
    8001b016:	83b1                	srli	a5,a5,0xc
    8001b018:	17fd                	addi	a5,a5,-1
    8001b01a:	853e                	mv	a0,a5
    8001b01c:	dfbff0ef          	jal	ra,8001ae16 <set_last>

    debugf("page_init: bookkeeping area initialized\n");
    8001b020:	00007517          	auipc	a0,0x7
    8001b024:	73050513          	addi	a0,a0,1840 # 80022750 <pow10.0+0x1520>
    8001b028:	9dcfe0ef          	jal	ra,80019204 <debugf>
    debugf("page_init: bookkeeping area starts at 0x%08lx\n", bookkeeping);
    8001b02c:	00005797          	auipc	a5,0x5
    8001b030:	11478793          	addi	a5,a5,276 # 80020140 <bookkeeping>
    8001b034:	639c                	ld	a5,0(a5)
    8001b036:	85be                	mv	a1,a5
    8001b038:	00007517          	auipc	a0,0x7
    8001b03c:	74850513          	addi	a0,a0,1864 # 80022780 <pow10.0+0x1550>
    8001b040:	9c4fe0ef          	jal	ra,80019204 <debugf>
    debugf("page_init: bookkeeping area ends at 0x%08lx\n", bookkeeping + BK_SIZE_IN_BYTES);
    8001b044:	00005797          	auipc	a5,0x5
    8001b048:	0fc78793          	addi	a5,a5,252 # 80020140 <bookkeeping>
    8001b04c:	6398                	ld	a4,0(a5)
    8001b04e:	07ff5697          	auipc	a3,0x7ff5
    8001b052:	fb268693          	addi	a3,a3,-78 # 88010000 <_heap_end>
    8001b056:	00012797          	auipc	a5,0x12
    8001b05a:	faa78793          	addi	a5,a5,-86 # 8002d000 <_heap_start>
    8001b05e:	40f687b3          	sub	a5,a3,a5
    8001b062:	00e7d693          	srli	a3,a5,0xe
    8001b066:	6785                	lui	a5,0x1
    8001b068:	17fd                	addi	a5,a5,-1
    8001b06a:	96be                	add	a3,a3,a5
    8001b06c:	77fd                	lui	a5,0xfffff
    8001b06e:	8ff5                	and	a5,a5,a3
    8001b070:	97ba                	add	a5,a5,a4
    8001b072:	85be                	mv	a1,a5
    8001b074:	00007517          	auipc	a0,0x7
    8001b078:	73c50513          	addi	a0,a0,1852 # 800227b0 <pow10.0+0x1580>
    8001b07c:	988fe0ef          	jal	ra,80019204 <debugf>
    mutex_unlock(&page_lock);
    8001b080:	00005517          	auipc	a0,0x5
    8001b084:	f8850513          	addi	a0,a0,-120 # 80020008 <page_lock>
    8001b088:	d45f80ef          	jal	ra,80013dcc <mutex_unlock>

    // Print out the bookkeeping area's contents
    logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    8001b08c:	00005797          	auipc	a5,0x5
    8001b090:	0b478793          	addi	a5,a5,180 # 80020140 <bookkeeping>
    8001b094:	6390                	ld	a2,0(a5)
    8001b096:	00005797          	auipc	a5,0x5
    8001b09a:	0aa78793          	addi	a5,a5,170 # 80020140 <bookkeeping>
    8001b09e:	6398                	ld	a4,0(a5)
    8001b0a0:	07ff5697          	auipc	a3,0x7ff5
    8001b0a4:	f6068693          	addi	a3,a3,-160 # 88010000 <_heap_end>
    8001b0a8:	00012797          	auipc	a5,0x12
    8001b0ac:	f5878793          	addi	a5,a5,-168 # 8002d000 <_heap_start>
    8001b0b0:	40f687b3          	sub	a5,a3,a5
    8001b0b4:	00e7d693          	srli	a3,a5,0xe
    8001b0b8:	6785                	lui	a5,0x1
    8001b0ba:	17fd                	addi	a5,a5,-1
    8001b0bc:	96be                	add	a3,a3,a5
    8001b0be:	77fd                	lui	a5,0xfffff
    8001b0c0:	8ff5                	and	a5,a5,a3
    8001b0c2:	97ba                	add	a5,a5,a4
    8001b0c4:	86be                	mv	a3,a5
    8001b0c6:	00007597          	auipc	a1,0x7
    8001b0ca:	71a58593          	addi	a1,a1,1818 # 800227e0 <pow10.0+0x15b0>
    8001b0ce:	4511                	li	a0,4
    8001b0d0:	8d6fe0ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  Heap: 0x%08lx -> 0x%08lx", bookkeeping + BK_SIZE_IN_BYTES, bookkeeping + HEAP_SIZE_IN_BYTES);
    8001b0d4:	00005797          	auipc	a5,0x5
    8001b0d8:	06c78793          	addi	a5,a5,108 # 80020140 <bookkeeping>
    8001b0dc:	6398                	ld	a4,0(a5)
    8001b0de:	07ff5697          	auipc	a3,0x7ff5
    8001b0e2:	f2268693          	addi	a3,a3,-222 # 88010000 <_heap_end>
    8001b0e6:	00012797          	auipc	a5,0x12
    8001b0ea:	f1a78793          	addi	a5,a5,-230 # 8002d000 <_heap_start>
    8001b0ee:	40f687b3          	sub	a5,a3,a5
    8001b0f2:	00e7d693          	srli	a3,a5,0xe
    8001b0f6:	6785                	lui	a5,0x1
    8001b0f8:	17fd                	addi	a5,a5,-1
    8001b0fa:	96be                	add	a3,a3,a5
    8001b0fc:	77fd                	lui	a5,0xfffff
    8001b0fe:	8ff5                	and	a5,a5,a3
    8001b100:	00f70633          	add	a2,a4,a5
    8001b104:	00005797          	auipc	a5,0x5
    8001b108:	03c78793          	addi	a5,a5,60 # 80020140 <bookkeeping>
    8001b10c:	6398                	ld	a4,0(a5)
    8001b10e:	07ff5697          	auipc	a3,0x7ff5
    8001b112:	ef268693          	addi	a3,a3,-270 # 88010000 <_heap_end>
    8001b116:	00012797          	auipc	a5,0x12
    8001b11a:	eea78793          	addi	a5,a5,-278 # 8002d000 <_heap_start>
    8001b11e:	40f687b3          	sub	a5,a3,a5
    8001b122:	97ba                	add	a5,a5,a4
    8001b124:	86be                	mv	a3,a5
    8001b126:	00007597          	auipc	a1,0x7
    8001b12a:	6da58593          	addi	a1,a1,1754 # 80022800 <pow10.0+0x15d0>
    8001b12e:	4511                	li	a0,4
    8001b130:	876fe0ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    8001b134:	07ff5717          	auipc	a4,0x7ff5
    8001b138:	ecc70713          	addi	a4,a4,-308 # 88010000 <_heap_end>
    8001b13c:	00012797          	auipc	a5,0x12
    8001b140:	ec478793          	addi	a5,a5,-316 # 8002d000 <_heap_start>
    8001b144:	40f70633          	sub	a2,a4,a5
    8001b148:	07ff5717          	auipc	a4,0x7ff5
    8001b14c:	eb870713          	addi	a4,a4,-328 # 88010000 <_heap_end>
    8001b150:	00012797          	auipc	a5,0x12
    8001b154:	eb078793          	addi	a5,a5,-336 # 8002d000 <_heap_start>
    8001b158:	40f707b3          	sub	a5,a4,a5
    8001b15c:	83b1                	srli	a5,a5,0xc
    8001b15e:	86be                	mv	a3,a5
    8001b160:	00007597          	auipc	a1,0x7
    8001b164:	6c058593          	addi	a1,a1,1728 # 80022820 <pow10.0+0x15f0>
    8001b168:	4511                	li	a0,4
    8001b16a:	83cfe0ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    8001b16e:	07ff5717          	auipc	a4,0x7ff5
    8001b172:	e9270713          	addi	a4,a4,-366 # 88010000 <_heap_end>
    8001b176:	00012797          	auipc	a5,0x12
    8001b17a:	e8a78793          	addi	a5,a5,-374 # 8002d000 <_heap_start>
    8001b17e:	40f707b3          	sub	a5,a4,a5
    8001b182:	00e7d713          	srli	a4,a5,0xe
    8001b186:	6785                	lui	a5,0x1
    8001b188:	17fd                	addi	a5,a5,-1
    8001b18a:	973e                	add	a4,a4,a5
    8001b18c:	77fd                	lui	a5,0xfffff
    8001b18e:	00f77633          	and	a2,a4,a5
    8001b192:	07ff5717          	auipc	a4,0x7ff5
    8001b196:	e6e70713          	addi	a4,a4,-402 # 88010000 <_heap_end>
    8001b19a:	00012797          	auipc	a5,0x12
    8001b19e:	e6678793          	addi	a5,a5,-410 # 8002d000 <_heap_start>
    8001b1a2:	40f707b3          	sub	a5,a4,a5
    8001b1a6:	00e7d713          	srli	a4,a5,0xe
    8001b1aa:	6785                	lui	a5,0x1
    8001b1ac:	17fd                	addi	a5,a5,-1
    8001b1ae:	97ba                	add	a5,a5,a4
    8001b1b0:	83b1                	srli	a5,a5,0xc
    8001b1b2:	86be                	mv	a3,a5
    8001b1b4:	00007597          	auipc	a1,0x7
    8001b1b8:	69458593          	addi	a1,a1,1684 # 80022848 <pow10.0+0x1618>
    8001b1bc:	4511                	li	a0,4
    8001b1be:	fe9fd0ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    8001b1c2:	330000ef          	jal	ra,8001b4f2 <page_count_taken>
    8001b1c6:	87aa                	mv	a5,a0
    8001b1c8:	863e                	mv	a2,a5
    8001b1ca:	00007597          	auipc	a1,0x7
    8001b1ce:	6ae58593          	addi	a1,a1,1710 # 80022878 <pow10.0+0x1648>
    8001b1d2:	4511                	li	a0,4
    8001b1d4:	fd3fd0ef          	jal	ra,800191a6 <logf>
    logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
    8001b1d8:	2a4000ef          	jal	ra,8001b47c <page_count_free>
    8001b1dc:	87aa                	mv	a5,a0
    8001b1de:	863e                	mv	a2,a5
    8001b1e0:	00007597          	auipc	a1,0x7
    8001b1e4:	6b058593          	addi	a1,a1,1712 # 80022890 <pow10.0+0x1660>
    8001b1e8:	4511                	li	a0,4
    8001b1ea:	fbdfd0ef          	jal	ra,800191a6 <logf>
    // logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    // logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    // logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
}
    8001b1ee:	0001                	nop
    8001b1f0:	60e2                	ld	ra,24(sp)
    8001b1f2:	6442                	ld	s0,16(sp)
    8001b1f4:	6105                	addi	sp,sp,32
    8001b1f6:	8082                	ret

000000008001b1f8 <page_nalloc>:

void *page_nalloc(int n)
{
    8001b1f8:	7139                	addi	sp,sp,-64
    8001b1fa:	fc06                	sd	ra,56(sp)
    8001b1fc:	f822                	sd	s0,48(sp)
    8001b1fe:	0080                	addi	s0,sp,64
    8001b200:	87aa                	mv	a5,a0
    8001b202:	fcf42623          	sw	a5,-52(s0)
    if (n <= 0) {
    8001b206:	fcc42783          	lw	a5,-52(s0)
    8001b20a:	2781                	sext.w	a5,a5
    8001b20c:	00f04463          	bgtz	a5,8001b214 <page_nalloc+0x1c>
        return NULL;
    8001b210:	4781                	li	a5,0
    8001b212:	a23d                	j	8001b340 <page_nalloc+0x148>
    }

    mutex_spinlock(&page_lock);
    8001b214:	00005517          	auipc	a0,0x5
    8001b218:	df450513          	addi	a0,a0,-524 # 80020008 <page_lock>
    8001b21c:	b83f80ef          	jal	ra,80013d9e <mutex_spinlock>

    int start = 0;
    8001b220:	fe042623          	sw	zero,-20(s0)
    int consecutive = 0;
    8001b224:	fe042423          	sw	zero,-24(s0)

    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001b228:	fe043023          	sd	zero,-32(s0)
    8001b22c:	a0e5                	j	8001b314 <page_nalloc+0x11c>
        if (!is_taken(i) && !is_last(i)) {
    8001b22e:	fe043503          	ld	a0,-32(s0)
    8001b232:	b9dff0ef          	jal	ra,8001adce <is_taken>
    8001b236:	87aa                	mv	a5,a0
    8001b238:	e7f9                	bnez	a5,8001b306 <page_nalloc+0x10e>
    8001b23a:	fe043503          	ld	a0,-32(s0)
    8001b23e:	cc9ff0ef          	jal	ra,8001af06 <is_last>
    8001b242:	87aa                	mv	a5,a0
    8001b244:	e3e9                	bnez	a5,8001b306 <page_nalloc+0x10e>
            if (consecutive == 0) {
    8001b246:	fe842783          	lw	a5,-24(s0)
    8001b24a:	2781                	sext.w	a5,a5
    8001b24c:	e789                	bnez	a5,8001b256 <page_nalloc+0x5e>
                start = i;
    8001b24e:	fe043783          	ld	a5,-32(s0)
    8001b252:	fef42623          	sw	a5,-20(s0)
            }

            consecutive++;
    8001b256:	fe842783          	lw	a5,-24(s0)
    8001b25a:	2785                	addiw	a5,a5,1
    8001b25c:	fef42423          	sw	a5,-24(s0)

            if (consecutive >= n) {
    8001b260:	fe842703          	lw	a4,-24(s0)
    8001b264:	fcc42783          	lw	a5,-52(s0)
    8001b268:	2701                	sext.w	a4,a4
    8001b26a:	2781                	sext.w	a5,a5
    8001b26c:	08f74f63          	blt	a4,a5,8001b30a <page_nalloc+0x112>
                // debugf("page_nalloc: found %d consecutive pages starting at 0x%08lx\n", n, start);
                for (int j = 0; j < n; j++) {
    8001b270:	fc042e23          	sw	zero,-36(s0)
    8001b274:	a091                	j	8001b2b8 <page_nalloc+0xc0>
                    // debugf("page_nalloc: marking page 0x%08lx as taken\n", start + j);
                    set_taken(start + j);
    8001b276:	fec42703          	lw	a4,-20(s0)
    8001b27a:	fdc42783          	lw	a5,-36(s0)
    8001b27e:	9fb9                	addw	a5,a5,a4
    8001b280:	2781                	sext.w	a5,a5
    8001b282:	853e                	mv	a0,a5
    8001b284:	a63ff0ef          	jal	ra,8001ace6 <set_taken>
                    if (j == n - 1) {
    8001b288:	fcc42783          	lw	a5,-52(s0)
    8001b28c:	37fd                	addiw	a5,a5,-1
    8001b28e:	0007871b          	sext.w	a4,a5
    8001b292:	fdc42783          	lw	a5,-36(s0)
    8001b296:	2781                	sext.w	a5,a5
    8001b298:	00e79b63          	bne	a5,a4,8001b2ae <page_nalloc+0xb6>
                        set_last(start + j);
    8001b29c:	fec42703          	lw	a4,-20(s0)
    8001b2a0:	fdc42783          	lw	a5,-36(s0)
    8001b2a4:	9fb9                	addw	a5,a5,a4
    8001b2a6:	2781                	sext.w	a5,a5
    8001b2a8:	853e                	mv	a0,a5
    8001b2aa:	b6dff0ef          	jal	ra,8001ae16 <set_last>
                for (int j = 0; j < n; j++) {
    8001b2ae:	fdc42783          	lw	a5,-36(s0)
    8001b2b2:	2785                	addiw	a5,a5,1
    8001b2b4:	fcf42e23          	sw	a5,-36(s0)
    8001b2b8:	fdc42703          	lw	a4,-36(s0)
    8001b2bc:	fcc42783          	lw	a5,-52(s0)
    8001b2c0:	2701                	sext.w	a4,a4
    8001b2c2:	2781                	sext.w	a5,a5
    8001b2c4:	faf749e3          	blt	a4,a5,8001b276 <page_nalloc+0x7e>
                    }
                }
                // debugf("page_nalloc: marking page 0x%08lx as last\n", start + n - 1);

                mutex_unlock(&page_lock);
    8001b2c8:	00005517          	auipc	a0,0x5
    8001b2cc:	d4050513          	addi	a0,a0,-704 # 80020008 <page_lock>
    8001b2d0:	afdf80ef          	jal	ra,80013dcc <mutex_unlock>
                // debugf("Found free %d pages at #%d, %d\n", n, start, i);
                void *result = (void*)((uint64_t)bookkeeping + ((uint64_t)start * PAGE_SIZE));
    8001b2d4:	fec42783          	lw	a5,-20(s0)
    8001b2d8:	07b2                	slli	a5,a5,0xc
    8001b2da:	00005717          	auipc	a4,0x5
    8001b2de:	e6670713          	addi	a4,a4,-410 # 80020140 <bookkeeping>
    8001b2e2:	6318                	ld	a4,0(a4)
    8001b2e4:	97ba                	add	a5,a5,a4
    8001b2e6:	fcf43823          	sd	a5,-48(s0)

                debugf("Found %d free pages at %p\n", n, result);
    8001b2ea:	fcc42783          	lw	a5,-52(s0)
    8001b2ee:	fd043603          	ld	a2,-48(s0)
    8001b2f2:	85be                	mv	a1,a5
    8001b2f4:	00007517          	auipc	a0,0x7
    8001b2f8:	5b450513          	addi	a0,a0,1460 # 800228a8 <pow10.0+0x1678>
    8001b2fc:	f09fd0ef          	jal	ra,80019204 <debugf>
                return result;
    8001b300:	fd043783          	ld	a5,-48(s0)
    8001b304:	a835                	j	8001b340 <page_nalloc+0x148>
            }
        } else {
            // debugf("page_nalloc: page 0x%08lx is taken\n", i);
            consecutive = 0;
    8001b306:	fe042423          	sw	zero,-24(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001b30a:	fe043783          	ld	a5,-32(s0)
    8001b30e:	0785                	addi	a5,a5,1
    8001b310:	fef43023          	sd	a5,-32(s0)
    8001b314:	07ff5717          	auipc	a4,0x7ff5
    8001b318:	cec70713          	addi	a4,a4,-788 # 88010000 <_heap_end>
    8001b31c:	00012797          	auipc	a5,0x12
    8001b320:	ce478793          	addi	a5,a5,-796 # 8002d000 <_heap_start>
    8001b324:	40f707b3          	sub	a5,a4,a5
    8001b328:	83b1                	srli	a5,a5,0xc
    8001b32a:	fe043703          	ld	a4,-32(s0)
    8001b32e:	f0f760e3          	bltu	a4,a5,8001b22e <page_nalloc+0x36>
        }
    }

    mutex_unlock(&page_lock);
    8001b332:	00005517          	auipc	a0,0x5
    8001b336:	cd650513          	addi	a0,a0,-810 # 80020008 <page_lock>
    8001b33a:	a93f80ef          	jal	ra,80013dcc <mutex_unlock>
    return NULL;
    8001b33e:	4781                	li	a5,0
}
    8001b340:	853e                	mv	a0,a5
    8001b342:	70e2                	ld	ra,56(sp)
    8001b344:	7442                	ld	s0,48(sp)
    8001b346:	6121                	addi	sp,sp,64
    8001b348:	8082                	ret

000000008001b34a <page_znalloc>:

void *page_znalloc(int n)
{
    8001b34a:	7179                	addi	sp,sp,-48
    8001b34c:	f406                	sd	ra,40(sp)
    8001b34e:	f022                	sd	s0,32(sp)
    8001b350:	1800                	addi	s0,sp,48
    8001b352:	87aa                	mv	a5,a0
    8001b354:	fcf42e23          	sw	a5,-36(s0)
    if (n <= 0) {
    8001b358:	fdc42783          	lw	a5,-36(s0)
    8001b35c:	2781                	sext.w	a5,a5
    8001b35e:	00f04463          	bgtz	a5,8001b366 <page_znalloc+0x1c>
        return NULL;
    8001b362:	4781                	li	a5,0
    8001b364:	a805                	j	8001b394 <page_znalloc+0x4a>
    }
    
    void *mem = page_nalloc(n);
    8001b366:	fdc42783          	lw	a5,-36(s0)
    8001b36a:	853e                	mv	a0,a5
    8001b36c:	e8dff0ef          	jal	ra,8001b1f8 <page_nalloc>
    8001b370:	fea43423          	sd	a0,-24(s0)
    if (mem) {
    8001b374:	fe843783          	ld	a5,-24(s0)
    8001b378:	cf81                	beqz	a5,8001b390 <page_znalloc+0x46>
        // debugf("page_znalloc: zeroing out %d pages starting at 0x%08lx\n", n, mem);
        memset(mem, 0, n * PAGE_SIZE);
    8001b37a:	fdc42783          	lw	a5,-36(s0)
    8001b37e:	00c7979b          	slliw	a5,a5,0xc
    8001b382:	2781                	sext.w	a5,a5
    8001b384:	863e                	mv	a2,a5
    8001b386:	4581                	li	a1,0
    8001b388:	fe843503          	ld	a0,-24(s0)
    8001b38c:	79f010ef          	jal	ra,8001d32a <memset>
    }
    return mem;
    8001b390:	fe843783          	ld	a5,-24(s0)
}
    8001b394:	853e                	mv	a0,a5
    8001b396:	70a2                	ld	ra,40(sp)
    8001b398:	7402                	ld	s0,32(sp)
    8001b39a:	6145                	addi	sp,sp,48
    8001b39c:	8082                	ret

000000008001b39e <page_to_index>:

uint64_t page_to_index(void *page) {
    8001b39e:	1101                	addi	sp,sp,-32
    8001b3a0:	ec22                	sd	s0,24(sp)
    8001b3a2:	1000                	addi	s0,sp,32
    8001b3a4:	fea43423          	sd	a0,-24(s0)
    return ((uint64_t)page - (uint64_t)bookkeeping) / PAGE_SIZE;
    8001b3a8:	fe843783          	ld	a5,-24(s0)
    8001b3ac:	00005717          	auipc	a4,0x5
    8001b3b0:	d9470713          	addi	a4,a4,-620 # 80020140 <bookkeeping>
    8001b3b4:	6318                	ld	a4,0(a4)
    8001b3b6:	8f99                	sub	a5,a5,a4
    8001b3b8:	83b1                	srli	a5,a5,0xc
}
    8001b3ba:	853e                	mv	a0,a5
    8001b3bc:	6462                	ld	s0,24(sp)
    8001b3be:	6105                	addi	sp,sp,32
    8001b3c0:	8082                	ret

000000008001b3c2 <index_to_page>:

void *index_to_page(uint64_t idx) {
    8001b3c2:	1101                	addi	sp,sp,-32
    8001b3c4:	ec22                	sd	s0,24(sp)
    8001b3c6:	1000                	addi	s0,sp,32
    8001b3c8:	fea43423          	sd	a0,-24(s0)
    return (void*)(idx * PAGE_SIZE + (uint64_t)bookkeeping);
    8001b3cc:	fe843783          	ld	a5,-24(s0)
    8001b3d0:	07b2                	slli	a5,a5,0xc
    8001b3d2:	00005717          	auipc	a4,0x5
    8001b3d6:	d6e70713          	addi	a4,a4,-658 # 80020140 <bookkeeping>
    8001b3da:	6318                	ld	a4,0(a4)
    8001b3dc:	97ba                	add	a5,a5,a4
}
    8001b3de:	853e                	mv	a0,a5
    8001b3e0:	6462                	ld	s0,24(sp)
    8001b3e2:	6105                	addi	sp,sp,32
    8001b3e4:	8082                	ret

000000008001b3e6 <page_free>:

void page_free(void *p)
{
    8001b3e6:	7179                	addi	sp,sp,-48
    8001b3e8:	f406                	sd	ra,40(sp)
    8001b3ea:	f022                	sd	s0,32(sp)
    8001b3ec:	1800                	addi	s0,sp,48
    8001b3ee:	fca43c23          	sd	a0,-40(s0)
    if (p == NULL) {
    8001b3f2:	fd843783          	ld	a5,-40(s0)
    8001b3f6:	cfb5                	beqz	a5,8001b472 <page_free+0x8c>
        return;
    }
    /* Free the page */
    // uint64_t x = ((uint64_t)p - (uint64_t)bookkeeping) / PAGE_SIZE;
    uint64_t x = page_to_index(p);
    8001b3f8:	fd843503          	ld	a0,-40(s0)
    8001b3fc:	fa3ff0ef          	jal	ra,8001b39e <page_to_index>
    8001b400:	fea43423          	sd	a0,-24(s0)
    // debugf("page_free: freeing page %lu at address 0x%p\n", x, p);

    mutex_spinlock(&page_lock);
    8001b404:	00005517          	auipc	a0,0x5
    8001b408:	c0450513          	addi	a0,a0,-1020 # 80020008 <page_lock>
    8001b40c:	993f80ef          	jal	ra,80013d9e <mutex_spinlock>


    if (!is_taken(x)) {
    8001b410:	fe843503          	ld	a0,-24(s0)
    8001b414:	9bbff0ef          	jal	ra,8001adce <is_taken>
    8001b418:	87aa                	mv	a5,a0
    8001b41a:	e38d                	bnez	a5,8001b43c <page_free+0x56>
        // logf(LOG_ERROR, "page_free: page 0x%08lx is already free!\n", x);
        mutex_unlock(&page_lock);
    8001b41c:	00005517          	auipc	a0,0x5
    8001b420:	bec50513          	addi	a0,a0,-1044 # 80020008 <page_lock>
    8001b424:	9a9f80ef          	jal	ra,80013dcc <mutex_unlock>
        return;
    8001b428:	a0b1                	j	8001b474 <page_free+0x8e>
    }

    // Clear all the pages starting at the index until the last page
    while (is_taken(x) && !is_last(x)) {
        clear_taken(x);
    8001b42a:	fe843503          	ld	a0,-24(s0)
    8001b42e:	927ff0ef          	jal	ra,8001ad54 <clear_taken>
        x++;
    8001b432:	fe843783          	ld	a5,-24(s0)
    8001b436:	0785                	addi	a5,a5,1
    8001b438:	fef43423          	sd	a5,-24(s0)
    while (is_taken(x) && !is_last(x)) {
    8001b43c:	fe843503          	ld	a0,-24(s0)
    8001b440:	98fff0ef          	jal	ra,8001adce <is_taken>
    8001b444:	87aa                	mv	a5,a0
    8001b446:	c799                	beqz	a5,8001b454 <page_free+0x6e>
    8001b448:	fe843503          	ld	a0,-24(s0)
    8001b44c:	abbff0ef          	jal	ra,8001af06 <is_last>
    8001b450:	87aa                	mv	a5,a0
    8001b452:	dfe1                	beqz	a5,8001b42a <page_free+0x44>
    }
    clear_taken(x);
    8001b454:	fe843503          	ld	a0,-24(s0)
    8001b458:	8fdff0ef          	jal	ra,8001ad54 <clear_taken>
    clear_last(x);
    8001b45c:	fe843503          	ld	a0,-24(s0)
    8001b460:	a29ff0ef          	jal	ra,8001ae88 <clear_last>


    mutex_unlock(&page_lock);
    8001b464:	00005517          	auipc	a0,0x5
    8001b468:	ba450513          	addi	a0,a0,-1116 # 80020008 <page_lock>
    8001b46c:	961f80ef          	jal	ra,80013dcc <mutex_unlock>
    8001b470:	a011                	j	8001b474 <page_free+0x8e>
        return;
    8001b472:	0001                	nop
}
    8001b474:	70a2                	ld	ra,40(sp)
    8001b476:	7402                	ld	s0,32(sp)
    8001b478:	6145                	addi	sp,sp,48
    8001b47a:	8082                	ret

000000008001b47c <page_count_free>:

int page_count_free(void)
{
    8001b47c:	1101                	addi	sp,sp,-32
    8001b47e:	ec06                	sd	ra,24(sp)
    8001b480:	e822                	sd	s0,16(sp)
    8001b482:	1000                	addi	s0,sp,32
    int ret = 0;
    8001b484:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract taken. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract taken pages from it.
    */

    mutex_spinlock(&page_lock);
    8001b488:	00005517          	auipc	a0,0x5
    8001b48c:	b8050513          	addi	a0,a0,-1152 # 80020008 <page_lock>
    8001b490:	90ff80ef          	jal	ra,80013d9e <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001b494:	fe043023          	sd	zero,-32(s0)
    8001b498:	a00d                	j	8001b4ba <page_count_free+0x3e>
       if (!is_taken(i)) {
    8001b49a:	fe043503          	ld	a0,-32(s0)
    8001b49e:	931ff0ef          	jal	ra,8001adce <is_taken>
    8001b4a2:	87aa                	mv	a5,a0
    8001b4a4:	e791                	bnez	a5,8001b4b0 <page_count_free+0x34>
           ret++;
    8001b4a6:	fec42783          	lw	a5,-20(s0)
    8001b4aa:	2785                	addiw	a5,a5,1
    8001b4ac:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001b4b0:	fe043783          	ld	a5,-32(s0)
    8001b4b4:	0785                	addi	a5,a5,1
    8001b4b6:	fef43023          	sd	a5,-32(s0)
    8001b4ba:	07ff5717          	auipc	a4,0x7ff5
    8001b4be:	b4670713          	addi	a4,a4,-1210 # 88010000 <_heap_end>
    8001b4c2:	00012797          	auipc	a5,0x12
    8001b4c6:	b3e78793          	addi	a5,a5,-1218 # 8002d000 <_heap_start>
    8001b4ca:	40f707b3          	sub	a5,a4,a5
    8001b4ce:	83b1                	srli	a5,a5,0xc
    8001b4d0:	fe043703          	ld	a4,-32(s0)
    8001b4d4:	fcf763e3          	bltu	a4,a5,8001b49a <page_count_free+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    8001b4d8:	00005517          	auipc	a0,0x5
    8001b4dc:	b3050513          	addi	a0,a0,-1232 # 80020008 <page_lock>
    8001b4e0:	8edf80ef          	jal	ra,80013dcc <mutex_unlock>

    return ret;
    8001b4e4:	fec42783          	lw	a5,-20(s0)
}
    8001b4e8:	853e                	mv	a0,a5
    8001b4ea:	60e2                	ld	ra,24(sp)
    8001b4ec:	6442                	ld	s0,16(sp)
    8001b4ee:	6105                	addi	sp,sp,32
    8001b4f0:	8082                	ret

000000008001b4f2 <page_count_taken>:

int page_count_taken(void)
{
    8001b4f2:	1101                	addi	sp,sp,-32
    8001b4f4:	ec06                	sd	ra,24(sp)
    8001b4f6:	e822                	sd	s0,16(sp)
    8001b4f8:	1000                	addi	s0,sp,32
    int ret = 0;
    8001b4fa:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract free. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract free pages from it.
    */

    mutex_spinlock(&page_lock);
    8001b4fe:	00005517          	auipc	a0,0x5
    8001b502:	b0a50513          	addi	a0,a0,-1270 # 80020008 <page_lock>
    8001b506:	899f80ef          	jal	ra,80013d9e <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001b50a:	fe043023          	sd	zero,-32(s0)
    8001b50e:	a00d                	j	8001b530 <page_count_taken+0x3e>
       if (is_taken(i)) {
    8001b510:	fe043503          	ld	a0,-32(s0)
    8001b514:	8bbff0ef          	jal	ra,8001adce <is_taken>
    8001b518:	87aa                	mv	a5,a0
    8001b51a:	c791                	beqz	a5,8001b526 <page_count_taken+0x34>
           ret++;
    8001b51c:	fec42783          	lw	a5,-20(s0)
    8001b520:	2785                	addiw	a5,a5,1
    8001b522:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001b526:	fe043783          	ld	a5,-32(s0)
    8001b52a:	0785                	addi	a5,a5,1
    8001b52c:	fef43023          	sd	a5,-32(s0)
    8001b530:	07ff5717          	auipc	a4,0x7ff5
    8001b534:	ad070713          	addi	a4,a4,-1328 # 88010000 <_heap_end>
    8001b538:	00012797          	auipc	a5,0x12
    8001b53c:	ac878793          	addi	a5,a5,-1336 # 8002d000 <_heap_start>
    8001b540:	40f707b3          	sub	a5,a4,a5
    8001b544:	83b1                	srli	a5,a5,0xc
    8001b546:	fe043703          	ld	a4,-32(s0)
    8001b54a:	fcf763e3          	bltu	a4,a5,8001b510 <page_count_taken+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    8001b54e:	00005517          	auipc	a0,0x5
    8001b552:	aba50513          	addi	a0,a0,-1350 # 80020008 <page_lock>
    8001b556:	877f80ef          	jal	ra,80013dcc <mutex_unlock>

    return ret;
    8001b55a:	fec42783          	lw	a5,-20(s0)
}
    8001b55e:	853e                	mv	a0,a5
    8001b560:	60e2                	ld	ra,24(sp)
    8001b562:	6442                	ld	s0,16(sp)
    8001b564:	6105                	addi	sp,sp,32
    8001b566:	8082                	ret

000000008001b568 <input_device_init>:
// static VirtioDevice *tablet_device;
// static List *input_devices;  //we need to store multiple input devices
// static Ring *input_events;  //TODO: use the ring to buffer input events and also limit the number of events
// const int event_limit = 1000;   //limits number of events so we don't run out of memory

void input_device_init(VirtioDevice *device) {
    8001b568:	7179                	addi	sp,sp,-48
    8001b56a:	f406                	sd	ra,40(sp)
    8001b56c:	f022                	sd	s0,32(sp)
    8001b56e:	1800                	addi	s0,sp,48
    8001b570:	fca43c23          	sd	a0,-40(s0)
    // init_counter++;
    // input_events = ring_new(event_limit);
    device_active_jobs = vector_new();
    8001b574:	009020ef          	jal	ra,8001dd7c <vector_new>
    8001b578:	872a                	mv	a4,a0
    8001b57a:	00005797          	auipc	a5,0x5
    8001b57e:	bce78793          	addi	a5,a5,-1074 # 80020148 <device_active_jobs>
    8001b582:	e398                	sd	a4,0(a5)
    // list_add(input_devices, device);
    debugf("Input device init done for device at %p\n", device->pcidev->ecam_header);
    8001b584:	fd843783          	ld	a5,-40(s0)
    8001b588:	63bc                	ld	a5,64(a5)
    8001b58a:	639c                	ld	a5,0(a5)
    8001b58c:	85be                	mv	a1,a5
    8001b58e:	00007517          	auipc	a0,0x7
    8001b592:	33a50513          	addi	a0,a0,826 # 800228c8 <pow10.0+0x1698>
    8001b596:	c6ffd0ef          	jal	ra,80019204 <debugf>
    device->ready = true;
    8001b59a:	fd843783          	ld	a5,-40(s0)
    8001b59e:	4705                	li	a4,1
    8001b5a0:	08e78723          	sb	a4,142(a5)
    volatile VirtioInputConfig *config = virtio_get_input_config(device);
    8001b5a4:	fd843503          	ld	a0,-40(s0)
    8001b5a8:	91dfe0ef          	jal	ra,80019ec4 <virtio_get_input_config>
    8001b5ac:	fea43423          	sd	a0,-24(s0)
    debugf("Input device initialized\n");
    8001b5b0:	00007517          	auipc	a0,0x7
    8001b5b4:	34850513          	addi	a0,a0,840 # 800228f8 <pow10.0+0x16c8>
    8001b5b8:	c4dfd0ef          	jal	ra,80019204 <debugf>

    //extra stuff just to see if we can see the input type
    debugf("Reading input config\n");
    8001b5bc:	00007517          	auipc	a0,0x7
    8001b5c0:	35c50513          	addi	a0,a0,860 # 80022918 <pow10.0+0x16e8>
    8001b5c4:	c41fd0ef          	jal	ra,80019204 <debugf>
    get_input_device_config(device,VIRTIO_INPUT_CFG_ID_NAME,0,8);
    8001b5c8:	46a1                	li	a3,8
    8001b5ca:	4601                	li	a2,0
    8001b5cc:	4585                	li	a1,1
    8001b5ce:	fd843503          	ld	a0,-40(s0)
    8001b5d2:	0b4000ef          	jal	ra,8001b686 <get_input_device_config>
    debugf("%.128s", config->string);
    8001b5d6:	fe843783          	ld	a5,-24(s0)
    8001b5da:	07a1                	addi	a5,a5,8
    8001b5dc:	85be                	mv	a1,a5
    8001b5de:	00007517          	auipc	a0,0x7
    8001b5e2:	35250513          	addi	a0,a0,850 # 80022930 <pow10.0+0x1700>
    8001b5e6:	c1ffd0ef          	jal	ra,80019204 <debugf>
    get_input_device_config(device,VIRTIO_INPUT_CFG_ID_NAME,0,8);
    8001b5ea:	46a1                	li	a3,8
    8001b5ec:	4601                	li	a2,0
    8001b5ee:	4585                	li	a1,1
    8001b5f0:	fd843503          	ld	a0,-40(s0)
    8001b5f4:	092000ef          	jal	ra,8001b686 <get_input_device_config>
    if (config->ids.product == EV_KEY) {
    8001b5f8:	fe843783          	ld	a5,-24(s0)
    8001b5fc:	00c7d783          	lhu	a5,12(a5)
    8001b600:	17c2                	slli	a5,a5,0x30
    8001b602:	93c1                	srli	a5,a5,0x30
    8001b604:	0007871b          	sext.w	a4,a5
    8001b608:	4785                	li	a5,1
    8001b60a:	02f71163          	bne	a4,a5,8001b62c <input_device_init+0xc4>
        debugf("Found keyboard input device.\n");
    8001b60e:	00007517          	auipc	a0,0x7
    8001b612:	32a50513          	addi	a0,a0,810 # 80022938 <pow10.0+0x1708>
    8001b616:	beffd0ef          	jal	ra,80019204 <debugf>
        virtio_set_device_name(device, "Keyboard");
    8001b61a:	00007597          	auipc	a1,0x7
    8001b61e:	33e58593          	addi	a1,a1,830 # 80022958 <pow10.0+0x1728>
    8001b622:	fd843503          	ld	a0,-40(s0)
    8001b626:	ffbfe0ef          	jal	ra,8001a620 <virtio_set_device_name>
        virtio_set_device_name(device, "Tablet");
    }
    else {
        debugf("Found an input device product id %d\n", config->ids.product);
    }
}
    8001b62a:	a889                	j	8001b67c <input_device_init+0x114>
    else if (config->ids.product == EV_ABS) {
    8001b62c:	fe843783          	ld	a5,-24(s0)
    8001b630:	00c7d783          	lhu	a5,12(a5)
    8001b634:	17c2                	slli	a5,a5,0x30
    8001b636:	93c1                	srli	a5,a5,0x30
    8001b638:	0007871b          	sext.w	a4,a5
    8001b63c:	478d                	li	a5,3
    8001b63e:	02f71163          	bne	a4,a5,8001b660 <input_device_init+0xf8>
        debugf("Found tablet input device.\n");
    8001b642:	00007517          	auipc	a0,0x7
    8001b646:	32650513          	addi	a0,a0,806 # 80022968 <pow10.0+0x1738>
    8001b64a:	bbbfd0ef          	jal	ra,80019204 <debugf>
        virtio_set_device_name(device, "Tablet");
    8001b64e:	00007597          	auipc	a1,0x7
    8001b652:	33a58593          	addi	a1,a1,826 # 80022988 <pow10.0+0x1758>
    8001b656:	fd843503          	ld	a0,-40(s0)
    8001b65a:	fc7fe0ef          	jal	ra,8001a620 <virtio_set_device_name>
}
    8001b65e:	a839                	j	8001b67c <input_device_init+0x114>
        debugf("Found an input device product id %d\n", config->ids.product);
    8001b660:	fe843783          	ld	a5,-24(s0)
    8001b664:	00c7d783          	lhu	a5,12(a5)
    8001b668:	17c2                	slli	a5,a5,0x30
    8001b66a:	93c1                	srli	a5,a5,0x30
    8001b66c:	2781                	sext.w	a5,a5
    8001b66e:	85be                	mv	a1,a5
    8001b670:	00007517          	auipc	a0,0x7
    8001b674:	32050513          	addi	a0,a0,800 # 80022990 <pow10.0+0x1760>
    8001b678:	b8dfd0ef          	jal	ra,80019204 <debugf>
}
    8001b67c:	0001                	nop
    8001b67e:	70a2                	ld	ra,40(sp)
    8001b680:	7402                	ld	s0,32(sp)
    8001b682:	6145                	addi	sp,sp,48
    8001b684:	8082                	ret

000000008001b686 <get_input_device_config>:

void get_input_device_config(VirtioDevice *device, uint8_t select, uint8_t subsel, uint8_t size) {
    8001b686:	7179                	addi	sp,sp,-48
    8001b688:	f406                	sd	ra,40(sp)
    8001b68a:	f022                	sd	s0,32(sp)
    8001b68c:	1800                	addi	s0,sp,48
    8001b68e:	fca43c23          	sd	a0,-40(s0)
    8001b692:	87ae                	mv	a5,a1
    8001b694:	8736                	mv	a4,a3
    8001b696:	fcf40ba3          	sb	a5,-41(s0)
    8001b69a:	87b2                	mv	a5,a2
    8001b69c:	fcf40b23          	sb	a5,-42(s0)
    8001b6a0:	87ba                	mv	a5,a4
    8001b6a2:	fcf40aa3          	sb	a5,-43(s0)
    volatile VirtioInputConfig *config = virtio_get_input_config(device);
    8001b6a6:	fd843503          	ld	a0,-40(s0)
    8001b6aa:	81bfe0ef          	jal	ra,80019ec4 <virtio_get_input_config>
    8001b6ae:	fea43423          	sd	a0,-24(s0)
    config->select = select;
    8001b6b2:	fe843783          	ld	a5,-24(s0)
    8001b6b6:	fd744703          	lbu	a4,-41(s0)
    8001b6ba:	00e78023          	sb	a4,0(a5)
    debugf("set_input_device_config: select = 0x%x\n", config->select);
    8001b6be:	fe843783          	ld	a5,-24(s0)
    8001b6c2:	0007c783          	lbu	a5,0(a5)
    8001b6c6:	0ff7f793          	andi	a5,a5,255
    8001b6ca:	2781                	sext.w	a5,a5
    8001b6cc:	85be                	mv	a1,a5
    8001b6ce:	00007517          	auipc	a0,0x7
    8001b6d2:	2ea50513          	addi	a0,a0,746 # 800229b8 <pow10.0+0x1788>
    8001b6d6:	b2ffd0ef          	jal	ra,80019204 <debugf>
    config->subsel = subsel;
    8001b6da:	fe843783          	ld	a5,-24(s0)
    8001b6de:	fd644703          	lbu	a4,-42(s0)
    8001b6e2:	00e780a3          	sb	a4,1(a5)
    debugf("set_input_device_config: subsel = 0x%x\n", config->subsel);
    8001b6e6:	fe843783          	ld	a5,-24(s0)
    8001b6ea:	0017c783          	lbu	a5,1(a5)
    8001b6ee:	0ff7f793          	andi	a5,a5,255
    8001b6f2:	2781                	sext.w	a5,a5
    8001b6f4:	85be                	mv	a1,a5
    8001b6f6:	00007517          	auipc	a0,0x7
    8001b6fa:	2ea50513          	addi	a0,a0,746 # 800229e0 <pow10.0+0x17b0>
    8001b6fe:	b07fd0ef          	jal	ra,80019204 <debugf>
    // config->size = size;
    // debugf("set_input_device_config: size = 0x%x\n", config->size);
    debugf("%.128s\n", config->string);
    8001b702:	fe843783          	ld	a5,-24(s0)
    8001b706:	07a1                	addi	a5,a5,8
    8001b708:	85be                	mv	a1,a5
    8001b70a:	00007517          	auipc	a0,0x7
    8001b70e:	2fe50513          	addi	a0,a0,766 # 80022a08 <pow10.0+0x17d8>
    8001b712:	af3fd0ef          	jal	ra,80019204 <debugf>
}
    8001b716:	0001                	nop
    8001b718:	70a2                	ld	ra,40(sp)
    8001b71a:	7402                	ld	s0,32(sp)
    8001b71c:	6145                	addi	sp,sp,48
    8001b71e:	8082                	ret

000000008001b720 <input_device_interrupt_handler>:

void input_device_interrupt_handler(VirtioDevice* dev) {
    8001b720:	7151                	addi	sp,sp,-240
    8001b722:	f586                	sd	ra,232(sp)
    8001b724:	f1a2                	sd	s0,224(sp)
    8001b726:	1980                	addi	s0,sp,240
    8001b728:	f0a43c23          	sd	a0,-232(s0)
    InputDevice *input_dev = NULL;
    8001b72c:	fe043023          	sd	zero,-32(s0)
    if(init_counter != 0){//ignore first interrupts
    8001b730:	00009797          	auipc	a5,0x9
    8001b734:	8dc78793          	addi	a5,a5,-1828 # 8002400c <init_counter>
    8001b738:	439c                	lw	a5,0(a5)
    8001b73a:	c78d                	beqz	a5,8001b764 <input_device_interrupt_handler+0x44>
        debugf("[INPUT HANDLER]ignore first interrupts!\n");
    8001b73c:	00007517          	auipc	a0,0x7
    8001b740:	2d450513          	addi	a0,a0,724 # 80022a10 <pow10.0+0x17e0>
    8001b744:	ac1fd0ef          	jal	ra,80019204 <debugf>
        init_counter--;
    8001b748:	00009797          	auipc	a5,0x9
    8001b74c:	8c478793          	addi	a5,a5,-1852 # 8002400c <init_counter>
    8001b750:	439c                	lw	a5,0(a5)
    8001b752:	37fd                	addiw	a5,a5,-1
    8001b754:	0007871b          	sext.w	a4,a5
    8001b758:	00009797          	auipc	a5,0x9
    8001b75c:	8b478793          	addi	a5,a5,-1868 # 8002400c <init_counter>
    8001b760:	c398                	sw	a4,0(a5)
        return;
    8001b762:	a2dd                	j	8001b948 <input_device_interrupt_handler+0x228>
    }
    if (dev == NULL) {
    8001b764:	f1843783          	ld	a5,-232(s0)
    8001b768:	eb81                	bnez	a5,8001b778 <input_device_interrupt_handler+0x58>
        debugf("Input device not initialized\n");
    8001b76a:	00007517          	auipc	a0,0x7
    8001b76e:	2d650513          	addi	a0,a0,726 # 80022a40 <pow10.0+0x1810>
    8001b772:	a93fd0ef          	jal	ra,80019204 <debugf>
        return;
    8001b776:	aac9                	j	8001b948 <input_device_interrupt_handler+0x228>
    }
    if(!dev->ready){
    8001b778:	f1843783          	ld	a5,-232(s0)
    8001b77c:	08e7c783          	lbu	a5,142(a5)
    8001b780:	0017c793          	xori	a5,a5,1
    8001b784:	0ff7f793          	andi	a5,a5,255
    8001b788:	c799                	beqz	a5,8001b796 <input_device_interrupt_handler+0x76>
        debugf("[INPUT HANDLER]Device not ready!\n");
    8001b78a:	00007517          	auipc	a0,0x7
    8001b78e:	2d650513          	addi	a0,a0,726 # 80022a60 <pow10.0+0x1830>
    8001b792:	a73fd0ef          	jal	ra,80019204 <debugf>
    }
    if(virtio_get_device_id(dev) != VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_INPUT)){
    8001b796:	f1843503          	ld	a0,-232(s0)
    8001b79a:	f72fe0ef          	jal	ra,80019f0c <virtio_get_device_id>
    8001b79e:	87aa                	mv	a5,a0
    8001b7a0:	0007871b          	sext.w	a4,a5
    8001b7a4:	6785                	lui	a5,0x1
    8001b7a6:	05278793          	addi	a5,a5,82 # 1052 <i+0x1032>
    8001b7aa:	00f70963          	beq	a4,a5,8001b7bc <input_device_interrupt_handler+0x9c>
        debugf("[INPUT HANDLER] Not an input device\n");
    8001b7ae:	00007517          	auipc	a0,0x7
    8001b7b2:	2da50513          	addi	a0,a0,730 # 80022a88 <pow10.0+0x1858>
    8001b7b6:	a4ffd0ef          	jal	ra,80019204 <debugf>
        return;
    8001b7ba:	a279                	j	8001b948 <input_device_interrupt_handler+0x228>
    }
    else{
        input_dev = (InputDevice *)dev;
    8001b7bc:	f1843783          	ld	a5,-232(s0)
    8001b7c0:	fef43023          	sd	a5,-32(s0)
    }

    VirtioDescriptor received_descriptors[MAX_DESCRIPTORS];
    uint16_t num_received = virtio_receive_descriptor_chain(input_dev, 0, received_descriptors, MAX_DESCRIPTORS, true);
    8001b7c4:	f2840793          	addi	a5,s0,-216
    8001b7c8:	4705                	li	a4,1
    8001b7ca:	46a9                	li	a3,10
    8001b7cc:	863e                	mv	a2,a5
    8001b7ce:	4581                	li	a1,0
    8001b7d0:	fe043503          	ld	a0,-32(s0)
    8001b7d4:	a94ff0ef          	jal	ra,8001aa68 <virtio_receive_descriptor_chain>
    8001b7d8:	87aa                	mv	a5,a0
    8001b7da:	fcf41f23          	sh	a5,-34(s0)
    for (uint16_t i = 0; i < num_received; ++i) {
    8001b7de:	fe041723          	sh	zero,-18(s0)
    8001b7e2:	aa99                	j	8001b938 <input_device_interrupt_handler+0x218>
        volatile struct virtio_input_event *event_ptr = (volatile struct virtio_input_event *)received_descriptors[i].addr;
    8001b7e4:	fee45783          	lhu	a5,-18(s0)
    8001b7e8:	2781                	sext.w	a5,a5
    8001b7ea:	0792                	slli	a5,a5,0x4
    8001b7ec:	ff040713          	addi	a4,s0,-16
    8001b7f0:	97ba                	add	a5,a5,a4
    8001b7f2:	f387b783          	ld	a5,-200(a5)
    8001b7f6:	fcf43823          	sd	a5,-48(s0)
        uint32_t len = received_descriptors[i].len;
    8001b7fa:	fee45783          	lhu	a5,-18(s0)
    8001b7fe:	2781                	sext.w	a5,a5
    8001b800:	0792                	slli	a5,a5,0x4
    8001b802:	ff040713          	addi	a4,s0,-16
    8001b806:	97ba                	add	a5,a5,a4
    8001b808:	f407a783          	lw	a5,-192(a5)
    8001b80c:	fcf42623          	sw	a5,-52(s0)

        if (len != sizeof(struct virtio_input_event)) {
    8001b810:	fcc42783          	lw	a5,-52(s0)
    8001b814:	0007871b          	sext.w	a4,a5
    8001b818:	47a1                	li	a5,8
    8001b81a:	02f70d63          	beq	a4,a5,8001b854 <input_device_interrupt_handler+0x134>
            debugf("Received invalid input event size: %d\n", len);
    8001b81e:	fcc42783          	lw	a5,-52(s0)
    8001b822:	85be                	mv	a1,a5
    8001b824:	00007517          	auipc	a0,0x7
    8001b828:	28c50513          	addi	a0,a0,652 # 80022ab0 <pow10.0+0x1880>
    8001b82c:	9d9fd0ef          	jal	ra,80019204 <debugf>
            virtio_send_one_descriptor(dev, 0, received_descriptors[i], true);
    8001b830:	fee45783          	lhu	a5,-18(s0)
    8001b834:	2781                	sext.w	a5,a5
    8001b836:	0792                	slli	a5,a5,0x4
    8001b838:	ff040713          	addi	a4,s0,-16
    8001b83c:	97ba                	add	a5,a5,a4
    8001b83e:	4705                	li	a4,1
    8001b840:	f387b603          	ld	a2,-200(a5)
    8001b844:	f407b683          	ld	a3,-192(a5)
    8001b848:	4581                	li	a1,0
    8001b84a:	f1843503          	ld	a0,-232(s0)
    8001b84e:	fb7fe0ef          	jal	ra,8001a804 <virtio_send_one_descriptor>
            continue;
    8001b852:	a8f1                	j	8001b92e <input_device_interrupt_handler+0x20e>
        }

        // Copy event to local buffer
        if (input_dev->size < INPUT_EVENT_BUFFER_SIZE) {
    8001b854:	fe043783          	ld	a5,-32(s0)
    8001b858:	2187a783          	lw	a5,536(a5)
    8001b85c:	873e                	mv	a4,a5
    8001b85e:	03f00793          	li	a5,63
    8001b862:	08e7cf63          	blt	a5,a4,8001b900 <input_device_interrupt_handler+0x1e0>
            memcpy(&input_dev->event_buffer[input_dev->tail], event_ptr, sizeof(struct virtio_input_event));
    8001b866:	fe043783          	ld	a5,-32(s0)
    8001b86a:	2147a783          	lw	a5,532(a5)
    8001b86e:	0789                	addi	a5,a5,2
    8001b870:	078e                	slli	a5,a5,0x3
    8001b872:	fe043703          	ld	a4,-32(s0)
    8001b876:	97ba                	add	a5,a5,a4
    8001b878:	4621                	li	a2,8
    8001b87a:	fd043583          	ld	a1,-48(s0)
    8001b87e:	853e                	mv	a0,a5
    8001b880:	3ad010ef          	jal	ra,8001d42c <memcpy>
            input_dev->tail = (input_dev->tail + 1) % INPUT_EVENT_BUFFER_SIZE;
    8001b884:	fe043783          	ld	a5,-32(s0)
    8001b888:	2147a783          	lw	a5,532(a5)
    8001b88c:	2785                	addiw	a5,a5,1
    8001b88e:	2781                	sext.w	a5,a5
    8001b890:	873e                	mv	a4,a5
    8001b892:	41f7579b          	sraiw	a5,a4,0x1f
    8001b896:	01a7d79b          	srliw	a5,a5,0x1a
    8001b89a:	9f3d                	addw	a4,a4,a5
    8001b89c:	03f77713          	andi	a4,a4,63
    8001b8a0:	40f707bb          	subw	a5,a4,a5
    8001b8a4:	0007871b          	sext.w	a4,a5
    8001b8a8:	fe043783          	ld	a5,-32(s0)
    8001b8ac:	20e7aa23          	sw	a4,532(a5)
            input_dev->size++;
    8001b8b0:	fe043783          	ld	a5,-32(s0)
    8001b8b4:	2187a783          	lw	a5,536(a5)
    8001b8b8:	2785                	addiw	a5,a5,1
    8001b8ba:	0007871b          	sext.w	a4,a5
    8001b8be:	fe043783          	ld	a5,-32(s0)
    8001b8c2:	20e7ac23          	sw	a4,536(a5)
            debugf("Input event received: type=%d, code=%d, value=%d\n", event_ptr->type, event_ptr->code, event_ptr->value);
    8001b8c6:	fd043783          	ld	a5,-48(s0)
    8001b8ca:	0007d783          	lhu	a5,0(a5)
    8001b8ce:	17c2                	slli	a5,a5,0x30
    8001b8d0:	93c1                	srli	a5,a5,0x30
    8001b8d2:	0007871b          	sext.w	a4,a5
    8001b8d6:	fd043783          	ld	a5,-48(s0)
    8001b8da:	0027d783          	lhu	a5,2(a5)
    8001b8de:	17c2                	slli	a5,a5,0x30
    8001b8e0:	93c1                	srli	a5,a5,0x30
    8001b8e2:	0007861b          	sext.w	a2,a5
    8001b8e6:	fd043783          	ld	a5,-48(s0)
    8001b8ea:	43dc                	lw	a5,4(a5)
    8001b8ec:	2781                	sext.w	a5,a5
    8001b8ee:	86be                	mv	a3,a5
    8001b8f0:	85ba                	mv	a1,a4
    8001b8f2:	00007517          	auipc	a0,0x7
    8001b8f6:	1e650513          	addi	a0,a0,486 # 80022ad8 <pow10.0+0x18a8>
    8001b8fa:	90bfd0ef          	jal	ra,80019204 <debugf>
    8001b8fe:	a039                	j	8001b90c <input_device_interrupt_handler+0x1ec>
        } else {
            debugf("Input event buffer full, event dropped\n");
    8001b900:	00007517          	auipc	a0,0x7
    8001b904:	21050513          	addi	a0,a0,528 # 80022b10 <pow10.0+0x18e0>
    8001b908:	8fdfd0ef          	jal	ra,80019204 <debugf>
        }

        // Send the descriptor back to the device
        virtio_send_one_descriptor(dev, 0, received_descriptors[i], true);
    8001b90c:	fee45783          	lhu	a5,-18(s0)
    8001b910:	2781                	sext.w	a5,a5
    8001b912:	0792                	slli	a5,a5,0x4
    8001b914:	ff040713          	addi	a4,s0,-16
    8001b918:	97ba                	add	a5,a5,a4
    8001b91a:	4705                	li	a4,1
    8001b91c:	f387b603          	ld	a2,-200(a5)
    8001b920:	f407b683          	ld	a3,-192(a5)
    8001b924:	4581                	li	a1,0
    8001b926:	f1843503          	ld	a0,-232(s0)
    8001b92a:	edbfe0ef          	jal	ra,8001a804 <virtio_send_one_descriptor>
    for (uint16_t i = 0; i < num_received; ++i) {
    8001b92e:	fee45783          	lhu	a5,-18(s0)
    8001b932:	2785                	addiw	a5,a5,1
    8001b934:	fef41723          	sh	a5,-18(s0)
    8001b938:	fee45703          	lhu	a4,-18(s0)
    8001b93c:	fde45783          	lhu	a5,-34(s0)
    8001b940:	2701                	sext.w	a4,a4
    8001b942:	2781                	sext.w	a5,a5
    8001b944:	eaf760e3          	bltu	a4,a5,8001b7e4 <input_device_interrupt_handler+0xc4>
    }
}
    8001b948:	70ae                	ld	ra,232(sp)
    8001b94a:	740e                	ld	s0,224(sp)
    8001b94c:	616d                	addi	sp,sp,240
    8001b94e:	8082                	ret

000000008001b950 <block_device_init>:
static uint64_t request_count = 0;
static Vector *device_active_jobs;
static VirtioDevice *block_device;
static Mutex block_device_mutex;

void block_device_init() {
    8001b950:	1101                	addi	sp,sp,-32
    8001b952:	ec06                	sd	ra,24(sp)
    8001b954:	e822                	sd	s0,16(sp)
    8001b956:	1000                	addi	s0,sp,32
    device_active_jobs = vector_new();
    8001b958:	424020ef          	jal	ra,8001dd7c <vector_new>
    8001b95c:	872a                	mv	a4,a0
    8001b95e:	00004797          	auipc	a5,0x4
    8001b962:	7fa78793          	addi	a5,a5,2042 # 80020158 <device_active_jobs>
    8001b966:	e398                	sd	a4,0(a5)
    block_device = virtio_get_block_device();
    8001b968:	f5afe0ef          	jal	ra,8001a0c2 <virtio_get_block_device>
    8001b96c:	872a                	mv	a4,a0
    8001b96e:	00004797          	auipc	a5,0x4
    8001b972:	7f278793          	addi	a5,a5,2034 # 80020160 <block_device>
    8001b976:	e398                	sd	a4,0(a5)
    block_device_mutex = MUTEX_UNLOCKED;
    8001b978:	00004797          	auipc	a5,0x4
    8001b97c:	7f078793          	addi	a5,a5,2032 # 80020168 <block_device_mutex>
    8001b980:	0007a023          	sw	zero,0(a5)
    debugf("Block device init done for device at %p\n", block_device->pcidev->ecam_header);
    virtio_set_device_name(block_device, "Block Device #1");
    8001b984:	00004797          	auipc	a5,0x4
    8001b988:	7dc78793          	addi	a5,a5,2012 # 80020160 <block_device>
    8001b98c:	639c                	ld	a5,0(a5)
    8001b98e:	00007597          	auipc	a1,0x7
    8001b992:	1aa58593          	addi	a1,a1,426 # 80022b38 <pow10.0+0x1908>
    8001b996:	853e                	mv	a0,a5
    8001b998:	c89fe0ef          	jal	ra,8001a620 <virtio_set_device_name>
    block_device->ready = true;
    8001b99c:	00004797          	auipc	a5,0x4
    8001b9a0:	7c478793          	addi	a5,a5,1988 # 80020160 <block_device>
    8001b9a4:	639c                	ld	a5,0(a5)
    8001b9a6:	4705                	li	a4,1
    8001b9a8:	08e78723          	sb	a4,142(a5)

    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001b9ac:	00004797          	auipc	a5,0x4
    8001b9b0:	7b478793          	addi	a5,a5,1972 # 80020160 <block_device>
    8001b9b4:	639c                	ld	a5,0(a5)
    8001b9b6:	853e                	mv	a0,a5
    8001b9b8:	ce8fe0ef          	jal	ra,80019ea0 <virtio_get_block_config>
    8001b9bc:	fea43423          	sd	a0,-24(s0)
    debugf("Block device has %d max size\n", config->size_max);
    debugf("Block device has block size of %d\n", config->blk_size);
    debugf("Block device has %d capacity\n", config->capacity);
    debugf("Block device has %d cylinders\n", config->geometry.cylinders);
    debugf("Block device has %d heads\n", config->geometry.heads);
}
    8001b9c0:	0001                	nop
    8001b9c2:	60e2                	ld	ra,24(sp)
    8001b9c4:	6442                	ld	s0,16(sp)
    8001b9c6:	6105                	addi	sp,sp,32
    8001b9c8:	8082                	ret

000000008001b9ca <block_device_get_sector_size>:

uint64_t block_device_get_sector_size(void) {
    8001b9ca:	1101                	addi	sp,sp,-32
    8001b9cc:	ec06                	sd	ra,24(sp)
    8001b9ce:	e822                	sd	s0,16(sp)
    8001b9d0:	1000                	addi	s0,sp,32
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001b9d2:	00004797          	auipc	a5,0x4
    8001b9d6:	78e78793          	addi	a5,a5,1934 # 80020160 <block_device>
    8001b9da:	639c                	ld	a5,0(a5)
    8001b9dc:	853e                	mv	a0,a5
    8001b9de:	cc2fe0ef          	jal	ra,80019ea0 <virtio_get_block_config>
    8001b9e2:	fea43423          	sd	a0,-24(s0)
    return config->blk_size;
    8001b9e6:	fe843783          	ld	a5,-24(s0)
    8001b9ea:	4bdc                	lw	a5,20(a5)
    8001b9ec:	2781                	sext.w	a5,a5
    8001b9ee:	1782                	slli	a5,a5,0x20
    8001b9f0:	9381                	srli	a5,a5,0x20
}
    8001b9f2:	853e                	mv	a0,a5
    8001b9f4:	60e2                	ld	ra,24(sp)
    8001b9f6:	6442                	ld	s0,16(sp)
    8001b9f8:	6105                	addi	sp,sp,32
    8001b9fa:	8082                	ret

000000008001b9fc <block_device_get_sector_count>:

uint64_t block_device_get_sector_count(void) {
    8001b9fc:	1101                	addi	sp,sp,-32
    8001b9fe:	ec06                	sd	ra,24(sp)
    8001ba00:	e822                	sd	s0,16(sp)
    8001ba02:	1000                	addi	s0,sp,32
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001ba04:	00004797          	auipc	a5,0x4
    8001ba08:	75c78793          	addi	a5,a5,1884 # 80020160 <block_device>
    8001ba0c:	639c                	ld	a5,0(a5)
    8001ba0e:	853e                	mv	a0,a5
    8001ba10:	c90fe0ef          	jal	ra,80019ea0 <virtio_get_block_config>
    8001ba14:	fea43423          	sd	a0,-24(s0)
    return config->capacity;
    8001ba18:	fe843783          	ld	a5,-24(s0)
    8001ba1c:	639c                	ld	a5,0(a5)
}
    8001ba1e:	853e                	mv	a0,a5
    8001ba20:	60e2                	ld	ra,24(sp)
    8001ba22:	6442                	ld	s0,16(sp)
    8001ba24:	6105                	addi	sp,sp,32
    8001ba26:	8082                	ret

000000008001ba28 <block_device_get_bytes>:

uint64_t block_device_get_bytes(void) {
    8001ba28:	1101                	addi	sp,sp,-32
    8001ba2a:	ec06                	sd	ra,24(sp)
    8001ba2c:	e822                	sd	s0,16(sp)
    8001ba2e:	1000                	addi	s0,sp,32
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001ba30:	00004797          	auipc	a5,0x4
    8001ba34:	73078793          	addi	a5,a5,1840 # 80020160 <block_device>
    8001ba38:	639c                	ld	a5,0(a5)
    8001ba3a:	853e                	mv	a0,a5
    8001ba3c:	c64fe0ef          	jal	ra,80019ea0 <virtio_get_block_config>
    8001ba40:	fea43423          	sd	a0,-24(s0)
    return config->capacity * config->blk_size;
    8001ba44:	fe843783          	ld	a5,-24(s0)
    8001ba48:	6398                	ld	a4,0(a5)
    8001ba4a:	fe843783          	ld	a5,-24(s0)
    8001ba4e:	4bdc                	lw	a5,20(a5)
    8001ba50:	2781                	sext.w	a5,a5
    8001ba52:	1782                	slli	a5,a5,0x20
    8001ba54:	9381                	srli	a5,a5,0x20
    8001ba56:	02f707b3          	mul	a5,a4,a5
}
    8001ba5a:	853e                	mv	a0,a5
    8001ba5c:	60e2                	ld	ra,24(sp)
    8001ba5e:	6442                	ld	s0,16(sp)
    8001ba60:	6105                	addi	sp,sp,32
    8001ba62:	8082                	ret

000000008001ba64 <block_device_handle_job>:

void block_device_handle_job(VirtioDevice *block_device, Job *job) {
    8001ba64:	7179                	addi	sp,sp,-48
    8001ba66:	f422                	sd	s0,40(sp)
    8001ba68:	1800                	addi	s0,sp,48
    8001ba6a:	fca43c23          	sd	a0,-40(s0)
    8001ba6e:	fcb43823          	sd	a1,-48(s0)
    debugf("Handling block device job %u\n", job->job_id);
    BlockRequestPacket *packet = (BlockRequestPacket *)job->data;
    8001ba72:	fd043783          	ld	a5,-48(s0)
    8001ba76:	7b9c                	ld	a5,48(a5)
    8001ba78:	fef43423          	sd	a5,-24(s0)
    debugf("Packet status in handle: %x\n", packet->status);
    
    job->data = NULL;
    8001ba7c:	fd043783          	ld	a5,-48(s0)
    8001ba80:	0207b823          	sd	zero,48(a5)
}
    8001ba84:	0001                	nop
    8001ba86:	7422                	ld	s0,40(sp)
    8001ba88:	6145                	addi	sp,sp,48
    8001ba8a:	8082                	ret

000000008001ba8c <block_device_send_request>:

void block_device_send_request(BlockRequestPacket *packet) {
    8001ba8c:	7119                	addi	sp,sp,-128
    8001ba8e:	fc86                	sd	ra,120(sp)
    8001ba90:	f8a2                	sd	s0,112(sp)
    8001ba92:	0100                	addi	s0,sp,128
    8001ba94:	f8a43423          	sd	a0,-120(s0)
    mutex_spinlock(&block_device_mutex);
    8001ba98:	00004517          	auipc	a0,0x4
    8001ba9c:	6d050513          	addi	a0,a0,1744 # 80020168 <block_device_mutex>
    8001baa0:	afef80ef          	jal	ra,80013d9e <mutex_spinlock>
    request_count++;
    8001baa4:	00004797          	auipc	a5,0x4
    8001baa8:	6ac78793          	addi	a5,a5,1708 # 80020150 <request_count>
    8001baac:	639c                	ld	a5,0(a5)
    8001baae:	00178713          	addi	a4,a5,1
    8001bab2:	00004797          	auipc	a5,0x4
    8001bab6:	69e78793          	addi	a5,a5,1694 # 80020150 <request_count>
    8001baba:	e398                	sd	a4,0(a5)

    debugf("Sending block request #%u\n", request_count);
    // First descriptor is the header
    packet->status = 0xf;
    8001babc:	f8843783          	ld	a5,-120(s0)
    8001bac0:	473d                	li	a4,15
    8001bac2:	00e78ca3          	sb	a4,25(a5)

    VirtioDescriptor header;
    header.addr = kernel_mmu_translate((uint64_t)packet);
    8001bac6:	f8843783          	ld	a5,-120(s0)
    8001baca:	853e                	mv	a0,a5
    8001bacc:	f1cf80ef          	jal	ra,800141e8 <kernel_mmu_translate>
    8001bad0:	87aa                	mv	a5,a0
    8001bad2:	fef43023          	sd	a5,-32(s0)
    header.flags = VIRTQ_DESC_F_NEXT;
    8001bad6:	4785                	li	a5,1
    8001bad8:	fef41623          	sh	a5,-20(s0)
    header.len = sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t);
    8001badc:	47c1                	li	a5,16
    8001bade:	fef42423          	sw	a5,-24(s0)

    // Second descriptor is the data
    VirtioDescriptor data;
    data.addr = kernel_mmu_translate((uint64_t)packet->data);
    8001bae2:	f8843783          	ld	a5,-120(s0)
    8001bae6:	6b9c                	ld	a5,16(a5)
    8001bae8:	853e                	mv	a0,a5
    8001baea:	efef80ef          	jal	ra,800141e8 <kernel_mmu_translate>
    8001baee:	87aa                	mv	a5,a0
    8001baf0:	fcf43823          	sd	a5,-48(s0)
    if (packet->type == VIRTIO_BLK_T_IN)
    8001baf4:	f8843783          	ld	a5,-120(s0)
    8001baf8:	439c                	lw	a5,0(a5)
    8001bafa:	e781                	bnez	a5,8001bb02 <block_device_send_request+0x76>
        data.flags = VIRTQ_DESC_F_WRITE;
    8001bafc:	4789                	li	a5,2
    8001bafe:	fcf41e23          	sh	a5,-36(s0)
    data.flags |= VIRTQ_DESC_F_NEXT;
    8001bb02:	fdc45783          	lhu	a5,-36(s0)
    8001bb06:	0017e793          	ori	a5,a5,1
    8001bb0a:	17c2                	slli	a5,a5,0x30
    8001bb0c:	93c1                	srli	a5,a5,0x30
    8001bb0e:	fcf41e23          	sh	a5,-36(s0)
    data.len = packet->sector_count * 512;
    8001bb12:	f8843783          	ld	a5,-120(s0)
    8001bb16:	0187c783          	lbu	a5,24(a5)
    8001bb1a:	2781                	sext.w	a5,a5
    8001bb1c:	0097979b          	slliw	a5,a5,0x9
    8001bb20:	2781                	sext.w	a5,a5
    8001bb22:	2781                	sext.w	a5,a5
    8001bb24:	fcf42c23          	sw	a5,-40(s0)

    // The third descriptor is the status
    VirtioDescriptor status;
    status.addr = kernel_mmu_translate((uint64_t)&packet->status);
    8001bb28:	f8843783          	ld	a5,-120(s0)
    8001bb2c:	07e5                	addi	a5,a5,25
    8001bb2e:	853e                	mv	a0,a5
    8001bb30:	eb8f80ef          	jal	ra,800141e8 <kernel_mmu_translate>
    8001bb34:	87aa                	mv	a5,a0
    8001bb36:	fcf43023          	sd	a5,-64(s0)
    status.flags = VIRTQ_DESC_F_WRITE;
    8001bb3a:	4789                	li	a5,2
    8001bb3c:	fcf41623          	sh	a5,-52(s0)
    status.len = sizeof(packet->status);
    8001bb40:	4785                	li	a5,1
    8001bb42:	fcf42423          	sw	a5,-56(s0)

    VirtioDescriptor chain[3];
    chain[0] = header;
    8001bb46:	fe043783          	ld	a5,-32(s0)
    8001bb4a:	f8f43823          	sd	a5,-112(s0)
    8001bb4e:	fe843783          	ld	a5,-24(s0)
    8001bb52:	f8f43c23          	sd	a5,-104(s0)
    chain[1] = data;
    8001bb56:	fd043783          	ld	a5,-48(s0)
    8001bb5a:	faf43023          	sd	a5,-96(s0)
    8001bb5e:	fd843783          	ld	a5,-40(s0)
    8001bb62:	faf43423          	sd	a5,-88(s0)
    chain[2] = status;
    8001bb66:	fc043783          	ld	a5,-64(s0)
    8001bb6a:	faf43823          	sd	a5,-80(s0)
    8001bb6e:	fc843783          	ld	a5,-56(s0)
    8001bb72:	faf43c23          	sd	a5,-72(s0)

    virtio_create_job_with_data(block_device, 1, block_device_handle_job, packet);
    8001bb76:	00004797          	auipc	a5,0x4
    8001bb7a:	5ea78793          	addi	a5,a5,1514 # 80020160 <block_device>
    8001bb7e:	639c                	ld	a5,0(a5)
    8001bb80:	f8843683          	ld	a3,-120(s0)
    8001bb84:	00000617          	auipc	a2,0x0
    8001bb88:	ee060613          	addi	a2,a2,-288 # 8001ba64 <block_device_handle_job>
    8001bb8c:	4585                	li	a1,1
    8001bb8e:	853e                	mv	a0,a5
    8001bb90:	dcbfd0ef          	jal	ra,8001995a <virtio_create_job_with_data>
    virtio_send_descriptor_chain(block_device, 0, chain, 3, true);
    8001bb94:	00004797          	auipc	a5,0x4
    8001bb98:	5cc78793          	addi	a5,a5,1484 # 80020160 <block_device>
    8001bb9c:	639c                	ld	a5,0(a5)
    8001bb9e:	f9040613          	addi	a2,s0,-112
    8001bba2:	4705                	li	a4,1
    8001bba4:	468d                	li	a3,3
    8001bba6:	4581                	li	a1,0
    8001bba8:	853e                	mv	a0,a5
    8001bbaa:	c9dfe0ef          	jal	ra,8001a846 <virtio_send_descriptor_chain>
    WFI();
    8001bbae:	10500073          	wfi

    debugf("Packet status after sending request #%u: %x\n", request_count, packet->status);
    if (packet->status != 0) {
    8001bbb2:	f8843783          	ld	a5,-120(s0)
    8001bbb6:	0197c783          	lbu	a5,25(a5)
    8001bbba:	cf89                	beqz	a5,8001bbd4 <block_device_send_request+0x148>
        warnf("Block device request failed with status %x\n", packet->status);
    8001bbbc:	f8843783          	ld	a5,-120(s0)
    8001bbc0:	0197c783          	lbu	a5,25(a5)
    8001bbc4:	2781                	sext.w	a5,a5
    8001bbc6:	85be                	mv	a1,a5
    8001bbc8:	00007517          	auipc	a0,0x7
    8001bbcc:	f8050513          	addi	a0,a0,-128 # 80022b48 <pow10.0+0x1918>
    8001bbd0:	e8afd0ef          	jal	ra,8001925a <warnf>
    }
    
    mutex_unlock(&block_device_mutex);
    8001bbd4:	00004517          	auipc	a0,0x4
    8001bbd8:	59450513          	addi	a0,a0,1428 # 80020168 <block_device_mutex>
    8001bbdc:	9f0f80ef          	jal	ra,80013dcc <mutex_unlock>
}
    8001bbe0:	0001                	nop
    8001bbe2:	70e6                	ld	ra,120(sp)
    8001bbe4:	7446                	ld	s0,112(sp)
    8001bbe6:	6109                	addi	sp,sp,128
    8001bbe8:	8082                	ret

000000008001bbea <block_device_read_sector>:

void block_device_read_sector(uint64_t sector, uint8_t *data) {
    8001bbea:	7139                	addi	sp,sp,-64
    8001bbec:	fc06                	sd	ra,56(sp)
    8001bbee:	f822                	sd	s0,48(sp)
    8001bbf0:	0080                	addi	s0,sp,64
    8001bbf2:	fca43423          	sd	a0,-56(s0)
    8001bbf6:	fcb43023          	sd	a1,-64(s0)
    debugf("Reading sector %d\n", sector);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_IN;
    8001bbfa:	fc042823          	sw	zero,-48(s0)
    packet.sector = sector;
    8001bbfe:	fc843783          	ld	a5,-56(s0)
    8001bc02:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001bc06:	fc043783          	ld	a5,-64(s0)
    8001bc0a:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    8001bc0e:	4785                	li	a5,1
    8001bc10:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001bc14:	47bd                	li	a5,15
    8001bc16:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(&packet);
    8001bc1a:	fd040793          	addi	a5,s0,-48
    8001bc1e:	853e                	mv	a0,a5
    8001bc20:	e6dff0ef          	jal	ra,8001ba8c <block_device_send_request>
}
    8001bc24:	0001                	nop
    8001bc26:	70e2                	ld	ra,56(sp)
    8001bc28:	7442                	ld	s0,48(sp)
    8001bc2a:	6121                	addi	sp,sp,64
    8001bc2c:	8082                	ret

000000008001bc2e <block_device_write_sector>:

void block_device_write_sector(uint64_t sector, uint8_t *data) {
    8001bc2e:	7139                	addi	sp,sp,-64
    8001bc30:	fc06                	sd	ra,56(sp)
    8001bc32:	f822                	sd	s0,48(sp)
    8001bc34:	0080                	addi	s0,sp,64
    8001bc36:	fca43423          	sd	a0,-56(s0)
    8001bc3a:	fcb43023          	sd	a1,-64(s0)
    debugf("Writing sector %d\n", sector);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_OUT;
    8001bc3e:	4785                	li	a5,1
    8001bc40:	fcf42823          	sw	a5,-48(s0)
    packet.sector = sector;
    8001bc44:	fc843783          	ld	a5,-56(s0)
    8001bc48:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001bc4c:	fc043783          	ld	a5,-64(s0)
    8001bc50:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    8001bc54:	4785                	li	a5,1
    8001bc56:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001bc5a:	47bd                	li	a5,15
    8001bc5c:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(&packet);
    8001bc60:	fd040793          	addi	a5,s0,-48
    8001bc64:	853e                	mv	a0,a5
    8001bc66:	e27ff0ef          	jal	ra,8001ba8c <block_device_send_request>
}
    8001bc6a:	0001                	nop
    8001bc6c:	70e2                	ld	ra,56(sp)
    8001bc6e:	7442                	ld	s0,48(sp)
    8001bc70:	6121                	addi	sp,sp,64
    8001bc72:	8082                	ret

000000008001bc74 <block_device_read_sectors>:

void block_device_read_sectors(uint64_t sector, uint8_t *data, uint64_t count) {
    8001bc74:	715d                	addi	sp,sp,-80
    8001bc76:	e486                	sd	ra,72(sp)
    8001bc78:	e0a2                	sd	s0,64(sp)
    8001bc7a:	0880                	addi	s0,sp,80
    8001bc7c:	fca43423          	sd	a0,-56(s0)
    8001bc80:	fcb43023          	sd	a1,-64(s0)
    8001bc84:	fac43c23          	sd	a2,-72(s0)
    debugf("Read sectors %d-%d\n", sector, sector + count);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_IN;
    8001bc88:	fc042823          	sw	zero,-48(s0)
    packet.sector = sector;
    8001bc8c:	fc843783          	ld	a5,-56(s0)
    8001bc90:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001bc94:	fc043783          	ld	a5,-64(s0)
    8001bc98:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = count;
    8001bc9c:	fb843783          	ld	a5,-72(s0)
    8001bca0:	0ff7f793          	andi	a5,a5,255
    8001bca4:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001bca8:	47bd                	li	a5,15
    8001bcaa:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(&packet);
    8001bcae:	fd040793          	addi	a5,s0,-48
    8001bcb2:	853e                	mv	a0,a5
    8001bcb4:	dd9ff0ef          	jal	ra,8001ba8c <block_device_send_request>
}
    8001bcb8:	0001                	nop
    8001bcba:	60a6                	ld	ra,72(sp)
    8001bcbc:	6406                	ld	s0,64(sp)
    8001bcbe:	6161                	addi	sp,sp,80
    8001bcc0:	8082                	ret

000000008001bcc2 <block_device_write_sectors>:

void block_device_write_sectors(uint64_t sector, uint8_t *data, uint64_t count) {
    8001bcc2:	715d                	addi	sp,sp,-80
    8001bcc4:	e486                	sd	ra,72(sp)
    8001bcc6:	e0a2                	sd	s0,64(sp)
    8001bcc8:	0880                	addi	s0,sp,80
    8001bcca:	fca43423          	sd	a0,-56(s0)
    8001bcce:	fcb43023          	sd	a1,-64(s0)
    8001bcd2:	fac43c23          	sd	a2,-72(s0)
    debugf("Writing sectors %d-%d\n", sector, sector + count);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_OUT;
    8001bcd6:	4785                	li	a5,1
    8001bcd8:	fcf42823          	sw	a5,-48(s0)
    packet.sector = sector;
    8001bcdc:	fc843783          	ld	a5,-56(s0)
    8001bce0:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001bce4:	fc043783          	ld	a5,-64(s0)
    8001bce8:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = count;
    8001bcec:	fb843783          	ld	a5,-72(s0)
    8001bcf0:	0ff7f793          	andi	a5,a5,255
    8001bcf4:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001bcf8:	47bd                	li	a5,15
    8001bcfa:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(&packet);
    8001bcfe:	fd040793          	addi	a5,s0,-48
    8001bd02:	853e                	mv	a0,a5
    8001bd04:	d89ff0ef          	jal	ra,8001ba8c <block_device_send_request>
}
    8001bd08:	0001                	nop
    8001bd0a:	60a6                	ld	ra,72(sp)
    8001bd0c:	6406                	ld	s0,64(sp)
    8001bd0e:	6161                	addi	sp,sp,80
    8001bd10:	8082                	ret

000000008001bd12 <block_device_read_bytes>:


void block_device_read_bytes(uint64_t byte, uint8_t *data, uint64_t bytes) {
    8001bd12:	7159                	addi	sp,sp,-112
    8001bd14:	f486                	sd	ra,104(sp)
    8001bd16:	f0a2                	sd	s0,96(sp)
    8001bd18:	eca6                	sd	s1,88(sp)
    8001bd1a:	1880                	addi	s0,sp,112
    8001bd1c:	faa43423          	sd	a0,-88(s0)
    8001bd20:	fab43023          	sd	a1,-96(s0)
    8001bd24:	f8c43c23          	sd	a2,-104(s0)
    8001bd28:	868a                	mv	a3,sp
    8001bd2a:	84b6                	mv	s1,a3
    debugf("block_device_read_bytes(%d, %p, %d)\n", byte, data, bytes);
    uint64_t sectors = ALIGN_UP_POT(bytes, 512) / 512;
    8001bd2c:	f9843683          	ld	a3,-104(s0)
    8001bd30:	1ff68693          	addi	a3,a3,511
    8001bd34:	82a5                	srli	a3,a3,0x9
    8001bd36:	fcd43823          	sd	a3,-48(s0)
    uint64_t sector = byte / 512;
    8001bd3a:	fa843683          	ld	a3,-88(s0)
    8001bd3e:	82a5                	srli	a3,a3,0x9
    8001bd40:	fcd43423          	sd	a3,-56(s0)
    uint8_t buffer[sectors][512];
    8001bd44:	fd043683          	ld	a3,-48(s0)
    8001bd48:	8636                	mv	a2,a3
    8001bd4a:	167d                	addi	a2,a2,-1
    8001bd4c:	fcc43023          	sd	a2,-64(s0)
    8001bd50:	8e36                	mv	t3,a3
    8001bd52:	4e81                	li	t4,0
    8001bd54:	034e5613          	srli	a2,t3,0x34
    8001bd58:	00ce9893          	slli	a7,t4,0xc
    8001bd5c:	011668b3          	or	a7,a2,a7
    8001bd60:	00ce1813          	slli	a6,t3,0xc
    8001bd64:	8336                	mv	t1,a3
    8001bd66:	4381                	li	t2,0
    8001bd68:	03435613          	srli	a2,t1,0x34
    8001bd6c:	00c39793          	slli	a5,t2,0xc
    8001bd70:	8fd1                	or	a5,a5,a2
    8001bd72:	00c31713          	slli	a4,t1,0xc
    8001bd76:	00969793          	slli	a5,a3,0x9
    8001bd7a:	07bd                	addi	a5,a5,15
    8001bd7c:	8391                	srli	a5,a5,0x4
    8001bd7e:	0792                	slli	a5,a5,0x4
    8001bd80:	40f10133          	sub	sp,sp,a5
    8001bd84:	878a                	mv	a5,sp
    8001bd86:	00078793          	mv	a5,a5
    8001bd8a:	faf43c23          	sd	a5,-72(s0)
    
    block_device_read_sectors(sector, (uint8_t *)buffer, sectors);
    8001bd8e:	fd043603          	ld	a2,-48(s0)
    8001bd92:	fb843583          	ld	a1,-72(s0)
    8001bd96:	fc843503          	ld	a0,-56(s0)
    8001bd9a:	edbff0ef          	jal	ra,8001bc74 <block_device_read_sectors>

    uint64_t alignment_offset = byte % 512;
    8001bd9e:	fa843783          	ld	a5,-88(s0)
    8001bda2:	1ff7f793          	andi	a5,a5,511
    8001bda6:	faf43823          	sd	a5,-80(s0)

    // Copy the data with the correct offset
    for (uint64_t i = 0; i < bytes; i++) {
    8001bdaa:	fc043c23          	sd	zero,-40(s0)
    8001bdae:	a83d                	j	8001bdec <block_device_read_bytes+0xda>
        data[i] = buffer[i / 512][(alignment_offset + i) % 512];
    8001bdb0:	fd843783          	ld	a5,-40(s0)
    8001bdb4:	0097d693          	srli	a3,a5,0x9
    8001bdb8:	fb043703          	ld	a4,-80(s0)
    8001bdbc:	fd843783          	ld	a5,-40(s0)
    8001bdc0:	97ba                	add	a5,a5,a4
    8001bdc2:	1ff7f713          	andi	a4,a5,511
    8001bdc6:	fa043603          	ld	a2,-96(s0)
    8001bdca:	fd843783          	ld	a5,-40(s0)
    8001bdce:	97b2                	add	a5,a5,a2
    8001bdd0:	fb843603          	ld	a2,-72(s0)
    8001bdd4:	06a6                	slli	a3,a3,0x9
    8001bdd6:	96b2                	add	a3,a3,a2
    8001bdd8:	9736                	add	a4,a4,a3
    8001bdda:	00074703          	lbu	a4,0(a4)
    8001bdde:	00e78023          	sb	a4,0(a5)
    for (uint64_t i = 0; i < bytes; i++) {
    8001bde2:	fd843783          	ld	a5,-40(s0)
    8001bde6:	0785                	addi	a5,a5,1
    8001bde8:	fcf43c23          	sd	a5,-40(s0)
    8001bdec:	fd843703          	ld	a4,-40(s0)
    8001bdf0:	f9843783          	ld	a5,-104(s0)
    8001bdf4:	faf76ee3          	bltu	a4,a5,8001bdb0 <block_device_read_bytes+0x9e>
    8001bdf8:	8126                	mv	sp,s1
    }
}
    8001bdfa:	0001                	nop
    8001bdfc:	f9040113          	addi	sp,s0,-112
    8001be00:	70a6                	ld	ra,104(sp)
    8001be02:	7406                	ld	s0,96(sp)
    8001be04:	64e6                	ld	s1,88(sp)
    8001be06:	6165                	addi	sp,sp,112
    8001be08:	8082                	ret

000000008001be0a <block_device_write_bytes>:


void block_device_write_bytes(uint64_t byte, uint8_t *data, uint64_t bytes) {
    8001be0a:	7159                	addi	sp,sp,-112
    8001be0c:	f486                	sd	ra,104(sp)
    8001be0e:	f0a2                	sd	s0,96(sp)
    8001be10:	eca6                	sd	s1,88(sp)
    8001be12:	1880                	addi	s0,sp,112
    8001be14:	faa43423          	sd	a0,-88(s0)
    8001be18:	fab43023          	sd	a1,-96(s0)
    8001be1c:	f8c43c23          	sd	a2,-104(s0)
    8001be20:	868a                	mv	a3,sp
    8001be22:	84b6                	mv	s1,a3
    debugf("block_device_write_bytes(%d, %p, %d)\n", byte, data, bytes);
    uint64_t sectors = ALIGN_UP_POT(bytes, 512) / 512;
    8001be24:	f9843683          	ld	a3,-104(s0)
    8001be28:	1ff68693          	addi	a3,a3,511
    8001be2c:	82a5                	srli	a3,a3,0x9
    8001be2e:	fcd43823          	sd	a3,-48(s0)
    uint64_t sector = byte / 512;
    8001be32:	fa843683          	ld	a3,-88(s0)
    8001be36:	82a5                	srli	a3,a3,0x9
    8001be38:	fcd43423          	sd	a3,-56(s0)
    uint8_t buffer[sectors][512];
    8001be3c:	fd043683          	ld	a3,-48(s0)
    8001be40:	8636                	mv	a2,a3
    8001be42:	167d                	addi	a2,a2,-1
    8001be44:	fcc43023          	sd	a2,-64(s0)
    8001be48:	8e36                	mv	t3,a3
    8001be4a:	4e81                	li	t4,0
    8001be4c:	034e5613          	srli	a2,t3,0x34
    8001be50:	00ce9893          	slli	a7,t4,0xc
    8001be54:	011668b3          	or	a7,a2,a7
    8001be58:	00ce1813          	slli	a6,t3,0xc
    8001be5c:	8336                	mv	t1,a3
    8001be5e:	4381                	li	t2,0
    8001be60:	03435613          	srli	a2,t1,0x34
    8001be64:	00c39793          	slli	a5,t2,0xc
    8001be68:	8fd1                	or	a5,a5,a2
    8001be6a:	00c31713          	slli	a4,t1,0xc
    8001be6e:	00969793          	slli	a5,a3,0x9
    8001be72:	07bd                	addi	a5,a5,15
    8001be74:	8391                	srli	a5,a5,0x4
    8001be76:	0792                	slli	a5,a5,0x4
    8001be78:	40f10133          	sub	sp,sp,a5
    8001be7c:	878a                	mv	a5,sp
    8001be7e:	00078793          	mv	a5,a5
    8001be82:	faf43c23          	sd	a5,-72(s0)

    uint64_t alignment_offset = byte % 512;
    8001be86:	fa843783          	ld	a5,-88(s0)
    8001be8a:	1ff7f793          	andi	a5,a5,511
    8001be8e:	faf43823          	sd	a5,-80(s0)
    block_device_read_sectors(sector, (uint8_t *)buffer, sectors);
    8001be92:	fd043603          	ld	a2,-48(s0)
    8001be96:	fb843583          	ld	a1,-72(s0)
    8001be9a:	fc843503          	ld	a0,-56(s0)
    8001be9e:	dd7ff0ef          	jal	ra,8001bc74 <block_device_read_sectors>
    // Copy the data with the correct offset
    for (uint64_t i = 0; i < bytes; i++) {
    8001bea2:	fc043c23          	sd	zero,-40(s0)
    8001bea6:	a83d                	j	8001bee4 <block_device_write_bytes+0xda>
        buffer[i / 512][(alignment_offset + i) % 512] = data[i];
    8001bea8:	fa043703          	ld	a4,-96(s0)
    8001beac:	fd843783          	ld	a5,-40(s0)
    8001beb0:	973e                	add	a4,a4,a5
    8001beb2:	fd843783          	ld	a5,-40(s0)
    8001beb6:	0097d693          	srli	a3,a5,0x9
    8001beba:	fb043603          	ld	a2,-80(s0)
    8001bebe:	fd843783          	ld	a5,-40(s0)
    8001bec2:	97b2                	add	a5,a5,a2
    8001bec4:	1ff7f793          	andi	a5,a5,511
    8001bec8:	00074703          	lbu	a4,0(a4)
    8001becc:	fb843603          	ld	a2,-72(s0)
    8001bed0:	06a6                	slli	a3,a3,0x9
    8001bed2:	96b2                	add	a3,a3,a2
    8001bed4:	97b6                	add	a5,a5,a3
    8001bed6:	00e78023          	sb	a4,0(a5)
    for (uint64_t i = 0; i < bytes; i++) {
    8001beda:	fd843783          	ld	a5,-40(s0)
    8001bede:	0785                	addi	a5,a5,1
    8001bee0:	fcf43c23          	sd	a5,-40(s0)
    8001bee4:	fd843703          	ld	a4,-40(s0)
    8001bee8:	f9843783          	ld	a5,-104(s0)
    8001beec:	faf76ee3          	bltu	a4,a5,8001bea8 <block_device_write_bytes+0x9e>
    }

    block_device_write_sectors(sector, (uint8_t *)buffer, sectors);
    8001bef0:	fd043603          	ld	a2,-48(s0)
    8001bef4:	fb843583          	ld	a1,-72(s0)
    8001bef8:	fc843503          	ld	a0,-56(s0)
    8001befc:	dc7ff0ef          	jal	ra,8001bcc2 <block_device_write_sectors>
    8001bf00:	8126                	mv	sp,s1
}
    8001bf02:	0001                	nop
    8001bf04:	f9040113          	addi	sp,s0,-112
    8001bf08:	70a6                	ld	ra,104(sp)
    8001bf0a:	7406                	ld	s0,96(sp)
    8001bf0c:	64e6                	ld	s1,88(sp)
    8001bf0e:	6165                	addi	sp,sp,112
    8001bf10:	8082                	ret
	...

000000008001bf20 <_start>:
.section .text
.global _start
_start:
.option push
.option norelax
	la		sp, _stack_end
    8001bf20:	00011117          	auipc	sp,0x11
    8001bf24:	0e010113          	addi	sp,sp,224 # 8002d000 <_heap_start>
	la		gp, __global_pointer$
    8001bf28:	00004197          	auipc	gp,0x4
    8001bf2c:	0d818193          	addi	gp,gp,216 # 80020000 <kernel_mmu_table>
    # Unlike the SBI, we will be trap returning so that
    # we know the registers sstatus, sip, stvec, and sepc are
    # in a place where we expect them to be. We can just jump
    # into main (tail main) like the SBI, but this ensures the CSRs
    # are what we say they are instead of just assuming from the SBI.
	la		t0, main
    8001bf30:	ffff9297          	auipc	t0,0xffff9
    8001bf34:	53628293          	addi	t0,t0,1334 # 80015466 <main>
	csrw	sepc, t0
    8001bf38:	14129073          	csrw	sepc,t0
	li		t0, 1 << 9
    8001bf3c:	20000293          	li	t0,512
	csrw	sie, t0
    8001bf40:	10429073          	csrw	sie,t0
    # 1 << 13 - FS:  in the "initial" position
    # 1 << 8  - SPP: into Supervisor Mode
    # 1 << 5  - SPIE: enable interrupts
	li		t0, (1 << 13) | (1 << 8) | (1 << 5)
    8001bf44:	6289                	lui	t0,0x2
    8001bf46:	1202829b          	addiw	t0,t0,288
	csrw	sstatus, t0
    8001bf4a:	10029073          	csrw	sstatus,t0
    # Load the return address (RA) to the park. When main
    # returns, it will park the HART.
	la		ra, park
    8001bf4e:	00000097          	auipc	ra,0x0
    8001bf52:	01208093          	addi	ra,ra,18 # 8001bf60 <park>
	csrr	a0, sscratch
    8001bf56:	14002573          	csrr	a0,sscratch
	sret
    8001bf5a:	10200073          	sret
    8001bf5e:	0001                	nop

000000008001bf60 <park>:

.section .text
.global park
.align 4
park:
	wfi
    8001bf60:	10500073          	wfi
	j	park
    8001bf64:	bff5                	j	8001bf60 <park>

000000008001bf66 <park_end>:
	...

000000008001bf74 <process_asm_run>:

.section .text
.global process_asm_run
process_asm_run:
    # a0 - Trap frame
    csrw    sscratch, a0
    8001bf74:	14051073          	csrw	sscratch,a0
    tail    _spawn_kthread
    8001bf78:	0880306f          	j	8001f000 <_spawn_kthread>

000000008001bf7c <g_kmalloc>:
void *(*__global_kmalloc)(uint64_t size);
void *(*__global_kcalloc)(uint64_t num, uint64_t size);
void (*__global_kfree)(void *ptr);

void *g_kmalloc(uint64_t size)
{
    8001bf7c:	1101                	addi	sp,sp,-32
    8001bf7e:	ec06                	sd	ra,24(sp)
    8001bf80:	e822                	sd	s0,16(sp)
    8001bf82:	1000                	addi	s0,sp,32
    8001bf84:	fea43423          	sd	a0,-24(s0)
    if (__global_kmalloc == NULL) {
    8001bf88:	00004797          	auipc	a5,0x4
    8001bf8c:	08878793          	addi	a5,a5,136 # 80020010 <__global_kmalloc>
    8001bf90:	639c                	ld	a5,0(a5)
    8001bf92:	e399                	bnez	a5,8001bf98 <g_kmalloc+0x1c>
        return NULL;
    8001bf94:	4781                	li	a5,0
    8001bf96:	a811                	j	8001bfaa <g_kmalloc+0x2e>
    }
    return __global_kmalloc(size);
    8001bf98:	00004797          	auipc	a5,0x4
    8001bf9c:	07878793          	addi	a5,a5,120 # 80020010 <__global_kmalloc>
    8001bfa0:	639c                	ld	a5,0(a5)
    8001bfa2:	fe843503          	ld	a0,-24(s0)
    8001bfa6:	9782                	jalr	a5
    8001bfa8:	87aa                	mv	a5,a0
}
    8001bfaa:	853e                	mv	a0,a5
    8001bfac:	60e2                	ld	ra,24(sp)
    8001bfae:	6442                	ld	s0,16(sp)
    8001bfb0:	6105                	addi	sp,sp,32
    8001bfb2:	8082                	ret

000000008001bfb4 <g_kcalloc>:
void *g_kcalloc(uint64_t num, uint64_t size)
{
    8001bfb4:	1101                	addi	sp,sp,-32
    8001bfb6:	ec06                	sd	ra,24(sp)
    8001bfb8:	e822                	sd	s0,16(sp)
    8001bfba:	1000                	addi	s0,sp,32
    8001bfbc:	fea43423          	sd	a0,-24(s0)
    8001bfc0:	feb43023          	sd	a1,-32(s0)
    if (__global_kcalloc == NULL) {
    8001bfc4:	00004797          	auipc	a5,0x4
    8001bfc8:	05478793          	addi	a5,a5,84 # 80020018 <__global_kcalloc>
    8001bfcc:	639c                	ld	a5,0(a5)
    8001bfce:	e399                	bnez	a5,8001bfd4 <g_kcalloc+0x20>
        return NULL;
    8001bfd0:	4781                	li	a5,0
    8001bfd2:	a821                	j	8001bfea <g_kcalloc+0x36>
    }
    return __global_kcalloc(num, size);
    8001bfd4:	00004797          	auipc	a5,0x4
    8001bfd8:	04478793          	addi	a5,a5,68 # 80020018 <__global_kcalloc>
    8001bfdc:	639c                	ld	a5,0(a5)
    8001bfde:	fe043583          	ld	a1,-32(s0)
    8001bfe2:	fe843503          	ld	a0,-24(s0)
    8001bfe6:	9782                	jalr	a5
    8001bfe8:	87aa                	mv	a5,a0
}
    8001bfea:	853e                	mv	a0,a5
    8001bfec:	60e2                	ld	ra,24(sp)
    8001bfee:	6442                	ld	s0,16(sp)
    8001bff0:	6105                	addi	sp,sp,32
    8001bff2:	8082                	ret

000000008001bff4 <g_kzalloc>:
void *g_kzalloc(uint64_t size)
{
    8001bff4:	1101                	addi	sp,sp,-32
    8001bff6:	ec06                	sd	ra,24(sp)
    8001bff8:	e822                	sd	s0,16(sp)
    8001bffa:	1000                	addi	s0,sp,32
    8001bffc:	fea43423          	sd	a0,-24(s0)
    return g_kcalloc(1, size);
    8001c000:	fe843583          	ld	a1,-24(s0)
    8001c004:	4505                	li	a0,1
    8001c006:	fafff0ef          	jal	ra,8001bfb4 <g_kcalloc>
    8001c00a:	87aa                	mv	a5,a0
}
    8001c00c:	853e                	mv	a0,a5
    8001c00e:	60e2                	ld	ra,24(sp)
    8001c010:	6442                	ld	s0,16(sp)
    8001c012:	6105                	addi	sp,sp,32
    8001c014:	8082                	ret

000000008001c016 <g_kfree>:
void g_kfree(void *ptr)
{
    8001c016:	1101                	addi	sp,sp,-32
    8001c018:	ec06                	sd	ra,24(sp)
    8001c01a:	e822                	sd	s0,16(sp)
    8001c01c:	1000                	addi	s0,sp,32
    8001c01e:	fea43423          	sd	a0,-24(s0)
    if (__global_kfree != NULL) {
    8001c022:	00004797          	auipc	a5,0x4
    8001c026:	ffe78793          	addi	a5,a5,-2 # 80020020 <__global_kfree>
    8001c02a:	639c                	ld	a5,0(a5)
    8001c02c:	cb89                	beqz	a5,8001c03e <g_kfree+0x28>
        __global_kfree(ptr);
    8001c02e:	00004797          	auipc	a5,0x4
    8001c032:	ff278793          	addi	a5,a5,-14 # 80020020 <__global_kfree>
    8001c036:	639c                	ld	a5,0(a5)
    8001c038:	fe843503          	ld	a0,-24(s0)
    8001c03c:	9782                	jalr	a5
    }
}
    8001c03e:	0001                	nop
    8001c040:	60e2                	ld	ra,24(sp)
    8001c042:	6442                	ld	s0,16(sp)
    8001c044:	6105                	addi	sp,sp,32
    8001c046:	8082                	ret

000000008001c048 <util_connect_galloc>:

void util_connect_galloc(void *(*malloc)(uint64_t size),
                         void *(*calloc)(uint64_t elem, uint64_t size), void (*free)(void *ptr))
{
    8001c048:	7179                	addi	sp,sp,-48
    8001c04a:	f422                	sd	s0,40(sp)
    8001c04c:	1800                	addi	s0,sp,48
    8001c04e:	fea43423          	sd	a0,-24(s0)
    8001c052:	feb43023          	sd	a1,-32(s0)
    8001c056:	fcc43c23          	sd	a2,-40(s0)
    __global_kmalloc = malloc;
    8001c05a:	00004797          	auipc	a5,0x4
    8001c05e:	fb678793          	addi	a5,a5,-74 # 80020010 <__global_kmalloc>
    8001c062:	fe843703          	ld	a4,-24(s0)
    8001c066:	e398                	sd	a4,0(a5)
    __global_kcalloc = calloc;
    8001c068:	00004797          	auipc	a5,0x4
    8001c06c:	fb078793          	addi	a5,a5,-80 # 80020018 <__global_kcalloc>
    8001c070:	fe043703          	ld	a4,-32(s0)
    8001c074:	e398                	sd	a4,0(a5)
    __global_kfree   = free;
    8001c076:	00004797          	auipc	a5,0x4
    8001c07a:	faa78793          	addi	a5,a5,-86 # 80020020 <__global_kfree>
    8001c07e:	fd843703          	ld	a4,-40(s0)
    8001c082:	e398                	sd	a4,0(a5)
}
    8001c084:	0001                	nop
    8001c086:	7422                	ld	s0,40(sp)
    8001c088:	6145                	addi	sp,sp,48
    8001c08a:	8082                	ret

000000008001c08c <list_init>:
typedef struct List {
    ListElem head;
} List;

static List *list_init(List *lst)
{
    8001c08c:	1101                	addi	sp,sp,-32
    8001c08e:	ec22                	sd	s0,24(sp)
    8001c090:	1000                	addi	s0,sp,32
    8001c092:	fea43423          	sd	a0,-24(s0)
    lst->head.next = &lst->head;
    8001c096:	fe843703          	ld	a4,-24(s0)
    8001c09a:	fe843783          	ld	a5,-24(s0)
    8001c09e:	e798                	sd	a4,8(a5)
    lst->head.prev = &lst->head;
    8001c0a0:	fe843703          	ld	a4,-24(s0)
    8001c0a4:	fe843783          	ld	a5,-24(s0)
    8001c0a8:	eb98                	sd	a4,16(a5)

    return lst;
    8001c0aa:	fe843783          	ld	a5,-24(s0)
}
    8001c0ae:	853e                	mv	a0,a5
    8001c0b0:	6462                	ld	s0,24(sp)
    8001c0b2:	6105                	addi	sp,sp,32
    8001c0b4:	8082                	ret

000000008001c0b6 <list_new>:

List *list_new(void)
{
    8001c0b6:	1101                	addi	sp,sp,-32
    8001c0b8:	ec06                	sd	ra,24(sp)
    8001c0ba:	e822                	sd	s0,16(sp)
    8001c0bc:	1000                	addi	s0,sp,32
    List *m = (List *)g_kmalloc(sizeof(List));
    8001c0be:	4561                	li	a0,24
    8001c0c0:	ebdff0ef          	jal	ra,8001bf7c <g_kmalloc>
    8001c0c4:	fea43423          	sd	a0,-24(s0)
    if (m == NULL) {
    8001c0c8:	fe843783          	ld	a5,-24(s0)
    8001c0cc:	e399                	bnez	a5,8001c0d2 <list_new+0x1c>
        return NULL;
    8001c0ce:	4781                	li	a5,0
    8001c0d0:	a031                	j	8001c0dc <list_new+0x26>
    }
    return list_init(m);
    8001c0d2:	fe843503          	ld	a0,-24(s0)
    8001c0d6:	fb7ff0ef          	jal	ra,8001c08c <list_init>
    8001c0da:	87aa                	mv	a5,a0
}
    8001c0dc:	853e                	mv	a0,a5
    8001c0de:	60e2                	ld	ra,24(sp)
    8001c0e0:	6442                	ld	s0,16(sp)
    8001c0e2:	6105                	addi	sp,sp,32
    8001c0e4:	8082                	ret

000000008001c0e6 <list_add>:

void list_add(List *lst, uint64_t value)
{
    8001c0e6:	7179                	addi	sp,sp,-48
    8001c0e8:	f406                	sd	ra,40(sp)
    8001c0ea:	f022                	sd	s0,32(sp)
    8001c0ec:	1800                	addi	s0,sp,48
    8001c0ee:	fca43c23          	sd	a0,-40(s0)
    8001c0f2:	fcb43823          	sd	a1,-48(s0)
    ListElem *l;
    l             = (ListElem *)g_kzalloc(sizeof(ListElem));
    8001c0f6:	4561                	li	a0,24
    8001c0f8:	efdff0ef          	jal	ra,8001bff4 <g_kzalloc>
    8001c0fc:	fea43423          	sd	a0,-24(s0)
    l->next       = lst->head.next;
    8001c100:	fd843783          	ld	a5,-40(s0)
    8001c104:	6798                	ld	a4,8(a5)
    8001c106:	fe843783          	ld	a5,-24(s0)
    8001c10a:	e798                	sd	a4,8(a5)
    l->prev       = &lst->head;
    8001c10c:	fd843703          	ld	a4,-40(s0)
    8001c110:	fe843783          	ld	a5,-24(s0)
    8001c114:	eb98                	sd	a4,16(a5)
    l->next->prev = l;
    8001c116:	fe843783          	ld	a5,-24(s0)
    8001c11a:	679c                	ld	a5,8(a5)
    8001c11c:	fe843703          	ld	a4,-24(s0)
    8001c120:	eb98                	sd	a4,16(a5)
    l->prev->next = l;
    8001c122:	fe843783          	ld	a5,-24(s0)
    8001c126:	6b9c                	ld	a5,16(a5)
    8001c128:	fe843703          	ld	a4,-24(s0)
    8001c12c:	e798                	sd	a4,8(a5)
    l->value      = value;
    8001c12e:	fe843783          	ld	a5,-24(s0)
    8001c132:	fd043703          	ld	a4,-48(s0)
    8001c136:	e398                	sd	a4,0(a5)
}
    8001c138:	0001                	nop
    8001c13a:	70a2                	ld	ra,40(sp)
    8001c13c:	7402                	ld	s0,32(sp)
    8001c13e:	6145                	addi	sp,sp,48
    8001c140:	8082                	ret

000000008001c142 <list_clear>:

void list_clear(List *lst)
{
    8001c142:	7179                	addi	sp,sp,-48
    8001c144:	f406                	sd	ra,40(sp)
    8001c146:	f022                	sd	s0,32(sp)
    8001c148:	1800                	addi	s0,sp,48
    8001c14a:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001c14e:	fd843783          	ld	a5,-40(s0)
    8001c152:	679c                	ld	a5,8(a5)
    8001c154:	fef43423          	sd	a5,-24(s0)
    8001c158:	a831                	j	8001c174 <list_clear+0x32>
        n = e->next;
    8001c15a:	fe843783          	ld	a5,-24(s0)
    8001c15e:	679c                	ld	a5,8(a5)
    8001c160:	fef43023          	sd	a5,-32(s0)
        list_remove_elem(e);
    8001c164:	fe843503          	ld	a0,-24(s0)
    8001c168:	120000ef          	jal	ra,8001c288 <list_remove_elem>
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001c16c:	fe043783          	ld	a5,-32(s0)
    8001c170:	fef43423          	sd	a5,-24(s0)
    8001c174:	fd843783          	ld	a5,-40(s0)
    8001c178:	fe843703          	ld	a4,-24(s0)
    8001c17c:	fcf71fe3          	bne	a4,a5,8001c15a <list_clear+0x18>
    }
}
    8001c180:	0001                	nop
    8001c182:	0001                	nop
    8001c184:	70a2                	ld	ra,40(sp)
    8001c186:	7402                	ld	s0,32(sp)
    8001c188:	6145                	addi	sp,sp,48
    8001c18a:	8082                	ret

000000008001c18c <list_sort>:

void list_sort(List *lst, LIST_COMPARATOR_PARAM(comp))
{
    8001c18c:	7139                	addi	sp,sp,-64
    8001c18e:	fc06                	sd	ra,56(sp)
    8001c190:	f822                	sd	s0,48(sp)
    8001c192:	0080                	addi	s0,sp,64
    8001c194:	fca43423          	sd	a0,-56(s0)
    8001c198:	fcb43023          	sd	a1,-64(s0)
    ListElem *e;
    bool swapped;
    uint64_t tmp;

    do {
        swapped = false;
    8001c19c:	fe0403a3          	sb	zero,-25(s0)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    8001c1a0:	fc843783          	ld	a5,-56(s0)
    8001c1a4:	6b9c                	ld	a5,16(a5)
    8001c1a6:	fef43423          	sd	a5,-24(s0)
    8001c1aa:	a8a9                	j	8001c204 <list_sort+0x78>
            if (!comp(e->value, e->prev->value)) {
    8001c1ac:	fe843783          	ld	a5,-24(s0)
    8001c1b0:	6398                	ld	a4,0(a5)
    8001c1b2:	fe843783          	ld	a5,-24(s0)
    8001c1b6:	6b9c                	ld	a5,16(a5)
    8001c1b8:	639c                	ld	a5,0(a5)
    8001c1ba:	fc043683          	ld	a3,-64(s0)
    8001c1be:	85be                	mv	a1,a5
    8001c1c0:	853a                	mv	a0,a4
    8001c1c2:	9682                	jalr	a3
    8001c1c4:	87aa                	mv	a5,a0
    8001c1c6:	0017c793          	xori	a5,a5,1
    8001c1ca:	0ff7f793          	andi	a5,a5,255
    8001c1ce:	c795                	beqz	a5,8001c1fa <list_sort+0x6e>
                swapped        = true;
    8001c1d0:	4785                	li	a5,1
    8001c1d2:	fef403a3          	sb	a5,-25(s0)
                tmp            = e->value;
    8001c1d6:	fe843783          	ld	a5,-24(s0)
    8001c1da:	639c                	ld	a5,0(a5)
    8001c1dc:	fcf43c23          	sd	a5,-40(s0)
                e->value       = e->prev->value;
    8001c1e0:	fe843783          	ld	a5,-24(s0)
    8001c1e4:	6b9c                	ld	a5,16(a5)
    8001c1e6:	6398                	ld	a4,0(a5)
    8001c1e8:	fe843783          	ld	a5,-24(s0)
    8001c1ec:	e398                	sd	a4,0(a5)
                e->prev->value = tmp;
    8001c1ee:	fe843783          	ld	a5,-24(s0)
    8001c1f2:	6b9c                	ld	a5,16(a5)
    8001c1f4:	fd843703          	ld	a4,-40(s0)
    8001c1f8:	e398                	sd	a4,0(a5)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    8001c1fa:	fe843783          	ld	a5,-24(s0)
    8001c1fe:	6b9c                	ld	a5,16(a5)
    8001c200:	fef43423          	sd	a5,-24(s0)
    8001c204:	fe843783          	ld	a5,-24(s0)
    8001c208:	6b98                	ld	a4,16(a5)
    8001c20a:	fc843783          	ld	a5,-56(s0)
    8001c20e:	f8f71fe3          	bne	a4,a5,8001c1ac <list_sort+0x20>
            }
        }
    } while (swapped);
    8001c212:	fe744783          	lbu	a5,-25(s0)
    8001c216:	0ff7f793          	andi	a5,a5,255
    8001c21a:	f3c9                	bnez	a5,8001c19c <list_sort+0x10>
}
    8001c21c:	0001                	nop
    8001c21e:	0001                	nop
    8001c220:	70e2                	ld	ra,56(sp)
    8001c222:	7442                	ld	s0,48(sp)
    8001c224:	6121                	addi	sp,sp,64
    8001c226:	8082                	ret

000000008001c228 <list_remove>:

bool list_remove(List *lst, uint64_t value)
{
    8001c228:	7179                	addi	sp,sp,-48
    8001c22a:	f406                	sd	ra,40(sp)
    8001c22c:	f022                	sd	s0,32(sp)
    8001c22e:	1800                	addi	s0,sp,48
    8001c230:	fca43c23          	sd	a0,-40(s0)
    8001c234:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(lst, e)
    8001c238:	fd843503          	ld	a0,-40(s0)
    8001c23c:	2ca000ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001c240:	fea43423          	sd	a0,-24(s0)
    8001c244:	a025                	j	8001c26c <list_remove+0x44>
    {
        if (e->value == value) {
    8001c246:	fe843783          	ld	a5,-24(s0)
    8001c24a:	639c                	ld	a5,0(a5)
    8001c24c:	fd043703          	ld	a4,-48(s0)
    8001c250:	00f71863          	bne	a4,a5,8001c260 <list_remove+0x38>
            list_remove_elem(e);
    8001c254:	fe843503          	ld	a0,-24(s0)
    8001c258:	030000ef          	jal	ra,8001c288 <list_remove_elem>
            return true;
    8001c25c:	4785                	li	a5,1
    8001c25e:	a005                	j	8001c27e <list_remove+0x56>
    list_for_each(lst, e)
    8001c260:	fe843503          	ld	a0,-24(s0)
    8001c264:	2ea000ef          	jal	ra,8001c54e <list_elem_prev>
    8001c268:	fea43423          	sd	a0,-24(s0)
    8001c26c:	fe843583          	ld	a1,-24(s0)
    8001c270:	fd843503          	ld	a0,-40(s0)
    8001c274:	204000ef          	jal	ra,8001c478 <list_elem_valid>
    8001c278:	87aa                	mv	a5,a0
    8001c27a:	f7f1                	bnez	a5,8001c246 <list_remove+0x1e>
        }
    }
    return false;
    8001c27c:	4781                	li	a5,0
}
    8001c27e:	853e                	mv	a0,a5
    8001c280:	70a2                	ld	ra,40(sp)
    8001c282:	7402                	ld	s0,32(sp)
    8001c284:	6145                	addi	sp,sp,48
    8001c286:	8082                	ret

000000008001c288 <list_remove_elem>:

void list_remove_elem(ListElem *e)
{
    8001c288:	1101                	addi	sp,sp,-32
    8001c28a:	ec06                	sd	ra,24(sp)
    8001c28c:	e822                	sd	s0,16(sp)
    8001c28e:	1000                	addi	s0,sp,32
    8001c290:	fea43423          	sd	a0,-24(s0)
    e->next->prev = e->prev;
    8001c294:	fe843783          	ld	a5,-24(s0)
    8001c298:	679c                	ld	a5,8(a5)
    8001c29a:	fe843703          	ld	a4,-24(s0)
    8001c29e:	6b18                	ld	a4,16(a4)
    8001c2a0:	eb98                	sd	a4,16(a5)
    e->prev->next = e->next;
    8001c2a2:	fe843783          	ld	a5,-24(s0)
    8001c2a6:	6b9c                	ld	a5,16(a5)
    8001c2a8:	fe843703          	ld	a4,-24(s0)
    8001c2ac:	6718                	ld	a4,8(a4)
    8001c2ae:	e798                	sd	a4,8(a5)
    g_kfree(e);
    8001c2b0:	fe843503          	ld	a0,-24(s0)
    8001c2b4:	d63ff0ef          	jal	ra,8001c016 <g_kfree>
}
    8001c2b8:	0001                	nop
    8001c2ba:	60e2                	ld	ra,24(sp)
    8001c2bc:	6442                	ld	s0,16(sp)
    8001c2be:	6105                	addi	sp,sp,32
    8001c2c0:	8082                	ret

000000008001c2c2 <list_find_elem>:

ListElem *list_find_elem(List *l, uint64_t value)
{
    8001c2c2:	7179                	addi	sp,sp,-48
    8001c2c4:	f406                	sd	ra,40(sp)
    8001c2c6:	f022                	sd	s0,32(sp)
    8001c2c8:	1800                	addi	s0,sp,48
    8001c2ca:	fca43c23          	sd	a0,-40(s0)
    8001c2ce:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(l, e)
    8001c2d2:	fd843503          	ld	a0,-40(s0)
    8001c2d6:	230000ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001c2da:	fea43423          	sd	a0,-24(s0)
    8001c2de:	a00d                	j	8001c300 <list_find_elem+0x3e>
    {
        if (e->value == value) {
    8001c2e0:	fe843783          	ld	a5,-24(s0)
    8001c2e4:	639c                	ld	a5,0(a5)
    8001c2e6:	fd043703          	ld	a4,-48(s0)
    8001c2ea:	00f71563          	bne	a4,a5,8001c2f4 <list_find_elem+0x32>
            return e;
    8001c2ee:	fe843783          	ld	a5,-24(s0)
    8001c2f2:	a005                	j	8001c312 <list_find_elem+0x50>
    list_for_each(l, e)
    8001c2f4:	fe843503          	ld	a0,-24(s0)
    8001c2f8:	256000ef          	jal	ra,8001c54e <list_elem_prev>
    8001c2fc:	fea43423          	sd	a0,-24(s0)
    8001c300:	fe843583          	ld	a1,-24(s0)
    8001c304:	fd843503          	ld	a0,-40(s0)
    8001c308:	170000ef          	jal	ra,8001c478 <list_elem_valid>
    8001c30c:	87aa                	mv	a5,a0
    8001c30e:	fbe9                	bnez	a5,8001c2e0 <list_find_elem+0x1e>
        }
    }
    return NULL;
    8001c310:	4781                	li	a5,0
}
    8001c312:	853e                	mv	a0,a5
    8001c314:	70a2                	ld	ra,40(sp)
    8001c316:	7402                	ld	s0,32(sp)
    8001c318:	6145                	addi	sp,sp,48
    8001c31a:	8082                	ret

000000008001c31c <list_contains>:

bool list_contains(const List *lst, uint64_t value)
{
    8001c31c:	7179                	addi	sp,sp,-48
    8001c31e:	f406                	sd	ra,40(sp)
    8001c320:	f022                	sd	s0,32(sp)
    8001c322:	1800                	addi	s0,sp,48
    8001c324:	fca43c23          	sd	a0,-40(s0)
    8001c328:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e = list_find_celem(lst, value);
    8001c32c:	fd043583          	ld	a1,-48(s0)
    8001c330:	fd843503          	ld	a0,-40(s0)
    8001c334:	178000ef          	jal	ra,8001c4ac <list_find_celem>
    8001c338:	fea43423          	sd	a0,-24(s0)

    return e == NULL ? false : true;
    8001c33c:	fe843783          	ld	a5,-24(s0)
    8001c340:	00f037b3          	snez	a5,a5
    8001c344:	0ff7f793          	andi	a5,a5,255
}
    8001c348:	853e                	mv	a0,a5
    8001c34a:	70a2                	ld	ra,40(sp)
    8001c34c:	7402                	ld	s0,32(sp)
    8001c34e:	6145                	addi	sp,sp,48
    8001c350:	8082                	ret

000000008001c352 <list_pop_back>:

ListElem *list_pop_back(List *l)
{
    8001c352:	7179                	addi	sp,sp,-48
    8001c354:	f406                	sd	ra,40(sp)
    8001c356:	f022                	sd	s0,32(sp)
    8001c358:	1800                	addi	s0,sp,48
    8001c35a:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.next) {
    8001c35e:	fd843703          	ld	a4,-40(s0)
    8001c362:	fd843783          	ld	a5,-40(s0)
    8001c366:	679c                	ld	a5,8(a5)
    8001c368:	00f71463          	bne	a4,a5,8001c370 <list_pop_back+0x1e>
        return NULL;
    8001c36c:	4781                	li	a5,0
    8001c36e:	a821                	j	8001c386 <list_pop_back+0x34>
    }
    ListElem *e = l->head.next;
    8001c370:	fd843783          	ld	a5,-40(s0)
    8001c374:	679c                	ld	a5,8(a5)
    8001c376:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    8001c37a:	fe843503          	ld	a0,-24(s0)
    8001c37e:	f0bff0ef          	jal	ra,8001c288 <list_remove_elem>
    return e;
    8001c382:	fe843783          	ld	a5,-24(s0)
}
    8001c386:	853e                	mv	a0,a5
    8001c388:	70a2                	ld	ra,40(sp)
    8001c38a:	7402                	ld	s0,32(sp)
    8001c38c:	6145                	addi	sp,sp,48
    8001c38e:	8082                	ret

000000008001c390 <list_pop>:

ListElem *list_pop(List *l)
{
    8001c390:	7179                	addi	sp,sp,-48
    8001c392:	f406                	sd	ra,40(sp)
    8001c394:	f022                	sd	s0,32(sp)
    8001c396:	1800                	addi	s0,sp,48
    8001c398:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.prev) {
    8001c39c:	fd843703          	ld	a4,-40(s0)
    8001c3a0:	fd843783          	ld	a5,-40(s0)
    8001c3a4:	6b9c                	ld	a5,16(a5)
    8001c3a6:	00f71463          	bne	a4,a5,8001c3ae <list_pop+0x1e>
        return NULL;
    8001c3aa:	4781                	li	a5,0
    8001c3ac:	a821                	j	8001c3c4 <list_pop+0x34>
    }
    ListElem *e = l->head.prev;
    8001c3ae:	fd843783          	ld	a5,-40(s0)
    8001c3b2:	6b9c                	ld	a5,16(a5)
    8001c3b4:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    8001c3b8:	fe843503          	ld	a0,-24(s0)
    8001c3bc:	ecdff0ef          	jal	ra,8001c288 <list_remove_elem>
    return e;
    8001c3c0:	fe843783          	ld	a5,-24(s0)
}
    8001c3c4:	853e                	mv	a0,a5
    8001c3c6:	70a2                	ld	ra,40(sp)
    8001c3c8:	7402                	ld	s0,32(sp)
    8001c3ca:	6145                	addi	sp,sp,48
    8001c3cc:	8082                	ret

000000008001c3ce <list_size>:

uint64_t list_size(const List *lst)
{
    8001c3ce:	7179                	addi	sp,sp,-48
    8001c3d0:	f406                	sd	ra,40(sp)
    8001c3d2:	f022                	sd	s0,32(sp)
    8001c3d4:	1800                	addi	s0,sp,48
    8001c3d6:	fca43c23          	sd	a0,-40(s0)
    uint64_t s = 0;
    8001c3da:	fe043423          	sd	zero,-24(s0)
    const ListElem *e;
    list_for_ceach(lst, e)
    8001c3de:	fd843503          	ld	a0,-40(s0)
    8001c3e2:	19c000ef          	jal	ra,8001c57e <list_celem_start_ascending>
    8001c3e6:	fea43023          	sd	a0,-32(s0)
    8001c3ea:	a821                	j	8001c402 <list_size+0x34>
    {
        s += 1;
    8001c3ec:	fe843783          	ld	a5,-24(s0)
    8001c3f0:	0785                	addi	a5,a5,1
    8001c3f2:	fef43423          	sd	a5,-24(s0)
    list_for_ceach(lst, e)
    8001c3f6:	fe043503          	ld	a0,-32(s0)
    8001c3fa:	1cc000ef          	jal	ra,8001c5c6 <list_celem_prev>
    8001c3fe:	fea43023          	sd	a0,-32(s0)
    8001c402:	fe043583          	ld	a1,-32(s0)
    8001c406:	fd843503          	ld	a0,-40(s0)
    8001c40a:	06e000ef          	jal	ra,8001c478 <list_elem_valid>
    8001c40e:	87aa                	mv	a5,a0
    8001c410:	fff1                	bnez	a5,8001c3ec <list_size+0x1e>
    }
    return s;
    8001c412:	fe843783          	ld	a5,-24(s0)
}
    8001c416:	853e                	mv	a0,a5
    8001c418:	70a2                	ld	ra,40(sp)
    8001c41a:	7402                	ld	s0,32(sp)
    8001c41c:	6145                	addi	sp,sp,48
    8001c41e:	8082                	ret

000000008001c420 <list_free>:

void list_free(List *lst)
{
    8001c420:	7179                	addi	sp,sp,-48
    8001c422:	f406                	sd	ra,40(sp)
    8001c424:	f022                	sd	s0,32(sp)
    8001c426:	1800                	addi	s0,sp,48
    8001c428:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    if (lst == NULL) {
    8001c42c:	fd843783          	ld	a5,-40(s0)
    8001c430:	cf9d                	beqz	a5,8001c46e <list_free+0x4e>
        return;
    }
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001c432:	fd843783          	ld	a5,-40(s0)
    8001c436:	679c                	ld	a5,8(a5)
    8001c438:	fef43423          	sd	a5,-24(s0)
    8001c43c:	a831                	j	8001c458 <list_free+0x38>
        n = e->next;
    8001c43e:	fe843783          	ld	a5,-24(s0)
    8001c442:	679c                	ld	a5,8(a5)
    8001c444:	fef43023          	sd	a5,-32(s0)
        g_kfree(e);
    8001c448:	fe843503          	ld	a0,-24(s0)
    8001c44c:	bcbff0ef          	jal	ra,8001c016 <g_kfree>
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001c450:	fe043783          	ld	a5,-32(s0)
    8001c454:	fef43423          	sd	a5,-24(s0)
    8001c458:	fd843783          	ld	a5,-40(s0)
    8001c45c:	fe843703          	ld	a4,-24(s0)
    8001c460:	fcf71fe3          	bne	a4,a5,8001c43e <list_free+0x1e>
    }
    g_kfree(lst);
    8001c464:	fd843503          	ld	a0,-40(s0)
    8001c468:	bafff0ef          	jal	ra,8001c016 <g_kfree>
    8001c46c:	a011                	j	8001c470 <list_free+0x50>
        return;
    8001c46e:	0001                	nop
}
    8001c470:	70a2                	ld	ra,40(sp)
    8001c472:	7402                	ld	s0,32(sp)
    8001c474:	6145                	addi	sp,sp,48
    8001c476:	8082                	ret

000000008001c478 <list_elem_valid>:

bool list_elem_valid(const List *l, const ListElem *e)
{
    8001c478:	1101                	addi	sp,sp,-32
    8001c47a:	ec22                	sd	s0,24(sp)
    8001c47c:	1000                	addi	s0,sp,32
    8001c47e:	fea43423          	sd	a0,-24(s0)
    8001c482:	feb43023          	sd	a1,-32(s0)
    return e != NULL && e != &l->head;
    8001c486:	fe043783          	ld	a5,-32(s0)
    8001c48a:	cb89                	beqz	a5,8001c49c <list_elem_valid+0x24>
    8001c48c:	fe843783          	ld	a5,-24(s0)
    8001c490:	fe043703          	ld	a4,-32(s0)
    8001c494:	00f70463          	beq	a4,a5,8001c49c <list_elem_valid+0x24>
    8001c498:	4785                	li	a5,1
    8001c49a:	a011                	j	8001c49e <list_elem_valid+0x26>
    8001c49c:	4781                	li	a5,0
    8001c49e:	8b85                	andi	a5,a5,1
    8001c4a0:	0ff7f793          	andi	a5,a5,255
}
    8001c4a4:	853e                	mv	a0,a5
    8001c4a6:	6462                	ld	s0,24(sp)
    8001c4a8:	6105                	addi	sp,sp,32
    8001c4aa:	8082                	ret

000000008001c4ac <list_find_celem>:

const ListElem *list_find_celem(const List *l, uint64_t value) 
{
    8001c4ac:	7179                	addi	sp,sp,-48
    8001c4ae:	f406                	sd	ra,40(sp)
    8001c4b0:	f022                	sd	s0,32(sp)
    8001c4b2:	1800                	addi	s0,sp,48
    8001c4b4:	fca43c23          	sd	a0,-40(s0)
    8001c4b8:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e;
    list_for_ceach(l, e) 
    8001c4bc:	fd843503          	ld	a0,-40(s0)
    8001c4c0:	0be000ef          	jal	ra,8001c57e <list_celem_start_ascending>
    8001c4c4:	fea43423          	sd	a0,-24(s0)
    8001c4c8:	a00d                	j	8001c4ea <list_find_celem+0x3e>
    {
        if (e->value == value) {
    8001c4ca:	fe843783          	ld	a5,-24(s0)
    8001c4ce:	639c                	ld	a5,0(a5)
    8001c4d0:	fd043703          	ld	a4,-48(s0)
    8001c4d4:	00f71563          	bne	a4,a5,8001c4de <list_find_celem+0x32>
            return e;
    8001c4d8:	fe843783          	ld	a5,-24(s0)
    8001c4dc:	a005                	j	8001c4fc <list_find_celem+0x50>
    list_for_ceach(l, e) 
    8001c4de:	fe843503          	ld	a0,-24(s0)
    8001c4e2:	0e4000ef          	jal	ra,8001c5c6 <list_celem_prev>
    8001c4e6:	fea43423          	sd	a0,-24(s0)
    8001c4ea:	fe843583          	ld	a1,-24(s0)
    8001c4ee:	fd843503          	ld	a0,-40(s0)
    8001c4f2:	f87ff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001c4f6:	87aa                	mv	a5,a0
    8001c4f8:	fbe9                	bnez	a5,8001c4ca <list_find_celem+0x1e>
        }
    }
    return NULL;
    8001c4fa:	4781                	li	a5,0
}
    8001c4fc:	853e                	mv	a0,a5
    8001c4fe:	70a2                	ld	ra,40(sp)
    8001c500:	7402                	ld	s0,32(sp)
    8001c502:	6145                	addi	sp,sp,48
    8001c504:	8082                	ret

000000008001c506 <list_elem_start_ascending>:

ListElem *list_elem_start_ascending(List *l)
{
    8001c506:	1101                	addi	sp,sp,-32
    8001c508:	ec22                	sd	s0,24(sp)
    8001c50a:	1000                	addi	s0,sp,32
    8001c50c:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    8001c510:	fe843783          	ld	a5,-24(s0)
    8001c514:	6b9c                	ld	a5,16(a5)
}
    8001c516:	853e                	mv	a0,a5
    8001c518:	6462                	ld	s0,24(sp)
    8001c51a:	6105                	addi	sp,sp,32
    8001c51c:	8082                	ret

000000008001c51e <list_elem_start_descending>:

ListElem *list_elem_start_descending(List *l)
{
    8001c51e:	1101                	addi	sp,sp,-32
    8001c520:	ec22                	sd	s0,24(sp)
    8001c522:	1000                	addi	s0,sp,32
    8001c524:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    8001c528:	fe843783          	ld	a5,-24(s0)
    8001c52c:	679c                	ld	a5,8(a5)
}
    8001c52e:	853e                	mv	a0,a5
    8001c530:	6462                	ld	s0,24(sp)
    8001c532:	6105                	addi	sp,sp,32
    8001c534:	8082                	ret

000000008001c536 <list_elem_next>:

ListElem *list_elem_next(ListElem *e)
{
    8001c536:	1101                	addi	sp,sp,-32
    8001c538:	ec22                	sd	s0,24(sp)
    8001c53a:	1000                	addi	s0,sp,32
    8001c53c:	fea43423          	sd	a0,-24(s0)
    return e->next;
    8001c540:	fe843783          	ld	a5,-24(s0)
    8001c544:	679c                	ld	a5,8(a5)
}
    8001c546:	853e                	mv	a0,a5
    8001c548:	6462                	ld	s0,24(sp)
    8001c54a:	6105                	addi	sp,sp,32
    8001c54c:	8082                	ret

000000008001c54e <list_elem_prev>:

ListElem *list_elem_prev(ListElem *e)
{
    8001c54e:	1101                	addi	sp,sp,-32
    8001c550:	ec22                	sd	s0,24(sp)
    8001c552:	1000                	addi	s0,sp,32
    8001c554:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    8001c558:	fe843783          	ld	a5,-24(s0)
    8001c55c:	6b9c                	ld	a5,16(a5)
}
    8001c55e:	853e                	mv	a0,a5
    8001c560:	6462                	ld	s0,24(sp)
    8001c562:	6105                	addi	sp,sp,32
    8001c564:	8082                	ret

000000008001c566 <list_elem_value>:

uint64_t list_elem_value(const ListElem *e)
{
    8001c566:	1101                	addi	sp,sp,-32
    8001c568:	ec22                	sd	s0,24(sp)
    8001c56a:	1000                	addi	s0,sp,32
    8001c56c:	fea43423          	sd	a0,-24(s0)
    return e->value;
    8001c570:	fe843783          	ld	a5,-24(s0)
    8001c574:	639c                	ld	a5,0(a5)
}
    8001c576:	853e                	mv	a0,a5
    8001c578:	6462                	ld	s0,24(sp)
    8001c57a:	6105                	addi	sp,sp,32
    8001c57c:	8082                	ret

000000008001c57e <list_celem_start_ascending>:

const ListElem *list_celem_start_ascending(const List *l) {
    8001c57e:	1101                	addi	sp,sp,-32
    8001c580:	ec22                	sd	s0,24(sp)
    8001c582:	1000                	addi	s0,sp,32
    8001c584:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    8001c588:	fe843783          	ld	a5,-24(s0)
    8001c58c:	6b9c                	ld	a5,16(a5)
}
    8001c58e:	853e                	mv	a0,a5
    8001c590:	6462                	ld	s0,24(sp)
    8001c592:	6105                	addi	sp,sp,32
    8001c594:	8082                	ret

000000008001c596 <list_celem_start_descending>:
const ListElem *list_celem_start_descending(const List *l) {
    8001c596:	1101                	addi	sp,sp,-32
    8001c598:	ec22                	sd	s0,24(sp)
    8001c59a:	1000                	addi	s0,sp,32
    8001c59c:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    8001c5a0:	fe843783          	ld	a5,-24(s0)
    8001c5a4:	679c                	ld	a5,8(a5)
}
    8001c5a6:	853e                	mv	a0,a5
    8001c5a8:	6462                	ld	s0,24(sp)
    8001c5aa:	6105                	addi	sp,sp,32
    8001c5ac:	8082                	ret

000000008001c5ae <list_celem_next>:
const ListElem *list_celem_next(const ListElem *e) {
    8001c5ae:	1101                	addi	sp,sp,-32
    8001c5b0:	ec22                	sd	s0,24(sp)
    8001c5b2:	1000                	addi	s0,sp,32
    8001c5b4:	fea43423          	sd	a0,-24(s0)
    return e->next;
    8001c5b8:	fe843783          	ld	a5,-24(s0)
    8001c5bc:	679c                	ld	a5,8(a5)
}
    8001c5be:	853e                	mv	a0,a5
    8001c5c0:	6462                	ld	s0,24(sp)
    8001c5c2:	6105                	addi	sp,sp,32
    8001c5c4:	8082                	ret

000000008001c5c6 <list_celem_prev>:
const ListElem *list_celem_prev(const ListElem *e) {
    8001c5c6:	1101                	addi	sp,sp,-32
    8001c5c8:	ec22                	sd	s0,24(sp)
    8001c5ca:	1000                	addi	s0,sp,32
    8001c5cc:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    8001c5d0:	fe843783          	ld	a5,-24(s0)
    8001c5d4:	6b9c                	ld	a5,16(a5)
}
    8001c5d6:	853e                	mv	a0,a5
    8001c5d8:	6462                	ld	s0,24(sp)
    8001c5da:	6105                	addi	sp,sp,32
    8001c5dc:	8082                	ret

000000008001c5de <list_sort_signed_long_comparator_ascending>:

// Default list comparators
LIST_COMPARATOR(list_sort_signed_long_comparator_ascending)
{
    8001c5de:	1101                	addi	sp,sp,-32
    8001c5e0:	ec22                	sd	s0,24(sp)
    8001c5e2:	1000                	addi	s0,sp,32
    8001c5e4:	fea43423          	sd	a0,-24(s0)
    8001c5e8:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    8001c5ec:	fe843703          	ld	a4,-24(s0)
    8001c5f0:	fe043783          	ld	a5,-32(s0)
    8001c5f4:	00e7a7b3          	slt	a5,a5,a4
    8001c5f8:	0017c793          	xori	a5,a5,1
    8001c5fc:	0ff7f793          	andi	a5,a5,255
}
    8001c600:	853e                	mv	a0,a5
    8001c602:	6462                	ld	s0,24(sp)
    8001c604:	6105                	addi	sp,sp,32
    8001c606:	8082                	ret

000000008001c608 <list_sort_signed_long_comparator_descending>:
LIST_COMPARATOR(list_sort_signed_long_comparator_descending)
{
    8001c608:	1101                	addi	sp,sp,-32
    8001c60a:	ec22                	sd	s0,24(sp)
    8001c60c:	1000                	addi	s0,sp,32
    8001c60e:	fea43423          	sd	a0,-24(s0)
    8001c612:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    8001c616:	fe843703          	ld	a4,-24(s0)
    8001c61a:	fe043783          	ld	a5,-32(s0)
    8001c61e:	00f727b3          	slt	a5,a4,a5
    8001c622:	0017c793          	xori	a5,a5,1
    8001c626:	0ff7f793          	andi	a5,a5,255
}
    8001c62a:	853e                	mv	a0,a5
    8001c62c:	6462                	ld	s0,24(sp)
    8001c62e:	6105                	addi	sp,sp,32
    8001c630:	8082                	ret

000000008001c632 <list_sort_unsigned_long_comparator_ascending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_ascending)
{
    8001c632:	1101                	addi	sp,sp,-32
    8001c634:	ec22                	sd	s0,24(sp)
    8001c636:	1000                	addi	s0,sp,32
    8001c638:	fea43423          	sd	a0,-24(s0)
    8001c63c:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    8001c640:	fe843703          	ld	a4,-24(s0)
    8001c644:	fe043783          	ld	a5,-32(s0)
    8001c648:	00e7b7b3          	sltu	a5,a5,a4
    8001c64c:	0017c793          	xori	a5,a5,1
    8001c650:	0ff7f793          	andi	a5,a5,255
}
    8001c654:	853e                	mv	a0,a5
    8001c656:	6462                	ld	s0,24(sp)
    8001c658:	6105                	addi	sp,sp,32
    8001c65a:	8082                	ret

000000008001c65c <list_sort_unsigned_long_comparator_descending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_descending)
{
    8001c65c:	1101                	addi	sp,sp,-32
    8001c65e:	ec22                	sd	s0,24(sp)
    8001c660:	1000                	addi	s0,sp,32
    8001c662:	fea43423          	sd	a0,-24(s0)
    8001c666:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    8001c66a:	fe843703          	ld	a4,-24(s0)
    8001c66e:	fe043783          	ld	a5,-32(s0)
    8001c672:	00f737b3          	sltu	a5,a4,a5
    8001c676:	0017c793          	xori	a5,a5,1
    8001c67a:	0ff7f793          	andi	a5,a5,255
}
    8001c67e:	853e                	mv	a0,a5
    8001c680:	6462                	ld	s0,24(sp)
    8001c682:	6105                	addi	sp,sp,32
    8001c684:	8082                	ret

000000008001c686 <list_sort_string_comparator_ascending>:
LIST_COMPARATOR(list_sort_string_comparator_ascending)
{
    8001c686:	1101                	addi	sp,sp,-32
    8001c688:	ec06                	sd	ra,24(sp)
    8001c68a:	e822                	sd	s0,16(sp)
    8001c68c:	1000                	addi	s0,sp,32
    8001c68e:	fea43423          	sd	a0,-24(s0)
    8001c692:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    8001c696:	fe843783          	ld	a5,-24(s0)
    8001c69a:	fe043703          	ld	a4,-32(s0)
    8001c69e:	85ba                	mv	a1,a4
    8001c6a0:	853e                	mv	a0,a5
    8001c6a2:	118010ef          	jal	ra,8001d7ba <strcmp>
    8001c6a6:	87aa                	mv	a5,a0
    8001c6a8:	0017a793          	slti	a5,a5,1
    8001c6ac:	0ff7f793          	andi	a5,a5,255
}
    8001c6b0:	853e                	mv	a0,a5
    8001c6b2:	60e2                	ld	ra,24(sp)
    8001c6b4:	6442                	ld	s0,16(sp)
    8001c6b6:	6105                	addi	sp,sp,32
    8001c6b8:	8082                	ret

000000008001c6ba <list_sort_string_comparator_descending>:
LIST_COMPARATOR(list_sort_string_comparator_descending)
{
    8001c6ba:	1101                	addi	sp,sp,-32
    8001c6bc:	ec06                	sd	ra,24(sp)
    8001c6be:	e822                	sd	s0,16(sp)
    8001c6c0:	1000                	addi	s0,sp,32
    8001c6c2:	fea43423          	sd	a0,-24(s0)
    8001c6c6:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    8001c6ca:	fe843783          	ld	a5,-24(s0)
    8001c6ce:	fe043703          	ld	a4,-32(s0)
    8001c6d2:	85ba                	mv	a1,a4
    8001c6d4:	853e                	mv	a0,a5
    8001c6d6:	0e4010ef          	jal	ra,8001d7ba <strcmp>
    8001c6da:	87aa                	mv	a5,a0
    8001c6dc:	fff7c793          	not	a5,a5
    8001c6e0:	01f7d79b          	srliw	a5,a5,0x1f
    8001c6e4:	0ff7f793          	andi	a5,a5,255
}
    8001c6e8:	853e                	mv	a0,a5
    8001c6ea:	60e2                	ld	ra,24(sp)
    8001c6ec:	6442                	ld	s0,16(sp)
    8001c6ee:	6105                	addi	sp,sp,32
    8001c6f0:	8082                	ret

000000008001c6f2 <fnv1a_digest_64>:
#define FNV1_64_OFFSET  14695981039346656037UL
#define FNV1_64_PRIME   1099511628211UL

// FNV-1a hashing
static uint64_t fnv1a_digest_64(const char *key)
{
    8001c6f2:	7179                	addi	sp,sp,-48
    8001c6f4:	f422                	sd	s0,40(sp)
    8001c6f6:	1800                	addi	s0,sp,48
    8001c6f8:	fca43c23          	sd	a0,-40(s0)
    uint64_t digest = FNV1_64_OFFSET;
    8001c6fc:	00007797          	auipc	a5,0x7
    8001c700:	cc478793          	addi	a5,a5,-828 # 800233c0 <trampoline_trap_size+0xc>
    8001c704:	639c                	ld	a5,0(a5)
    8001c706:	fef43423          	sd	a5,-24(s0)
    const unsigned char *k;

    for (k = (unsigned char *)key; *k; k += 1) {
    8001c70a:	fd843783          	ld	a5,-40(s0)
    8001c70e:	fef43023          	sd	a5,-32(s0)
    8001c712:	a035                	j	8001c73e <fnv1a_digest_64+0x4c>
        digest = (digest ^ *k) * FNV1_64_PRIME;
    8001c714:	fe043783          	ld	a5,-32(s0)
    8001c718:	0007c783          	lbu	a5,0(a5)
    8001c71c:	873e                	mv	a4,a5
    8001c71e:	fe843783          	ld	a5,-24(s0)
    8001c722:	8f3d                	xor	a4,a4,a5
    8001c724:	4785                	li	a5,1
    8001c726:	17a2                	slli	a5,a5,0x28
    8001c728:	1b378793          	addi	a5,a5,435
    8001c72c:	02f707b3          	mul	a5,a4,a5
    8001c730:	fef43423          	sd	a5,-24(s0)
    for (k = (unsigned char *)key; *k; k += 1) {
    8001c734:	fe043783          	ld	a5,-32(s0)
    8001c738:	0785                	addi	a5,a5,1
    8001c73a:	fef43023          	sd	a5,-32(s0)
    8001c73e:	fe043783          	ld	a5,-32(s0)
    8001c742:	0007c783          	lbu	a5,0(a5)
    8001c746:	f7f9                	bnez	a5,8001c714 <fnv1a_digest_64+0x22>
    }
    return digest;
    8001c748:	fe843783          	ld	a5,-24(s0)
}
    8001c74c:	853e                	mv	a0,a5
    8001c74e:	7422                	ld	s0,40(sp)
    8001c750:	6145                	addi	sp,sp,48
    8001c752:	8082                	ret

000000008001c754 <map_int_to_str>:


// We need to store 20 digits, a possible negative sign, and the NULL-terminator
#define STR_KEY_SIZE 64
static char *map_int_to_str(char dst[], long n)
{
    8001c754:	7139                	addi	sp,sp,-64
    8001c756:	fc22                	sd	s0,56(sp)
    8001c758:	0080                	addi	s0,sp,64
    8001c75a:	fca43423          	sd	a0,-56(s0)
    8001c75e:	fcb43023          	sd	a1,-64(s0)
    char *const ret = dst;
    8001c762:	fc843783          	ld	a5,-56(s0)
    8001c766:	fef43023          	sd	a5,-32(s0)
    int i;
    int j;
    if (n == 0) {
    8001c76a:	fc043783          	ld	a5,-64(s0)
    8001c76e:	ef99                	bnez	a5,8001c78c <map_int_to_str+0x38>
        dst[0] = '0';
    8001c770:	fc843783          	ld	a5,-56(s0)
    8001c774:	03000713          	li	a4,48
    8001c778:	00e78023          	sb	a4,0(a5)
        dst[1] = '\0';
    8001c77c:	fc843783          	ld	a5,-56(s0)
    8001c780:	0785                	addi	a5,a5,1
    8001c782:	00078023          	sb	zero,0(a5)
        return ret;
    8001c786:	fe043783          	ld	a5,-32(s0)
    8001c78a:	aa29                	j	8001c8a4 <map_int_to_str+0x150>
    }
    if (n < 0) {
    8001c78c:	fc043783          	ld	a5,-64(s0)
    8001c790:	0207d263          	bgez	a5,8001c7b4 <map_int_to_str+0x60>
        // Advance the pointer so that when we flip,
        // we don't flip the negative sign.
        *dst++ = '-';
    8001c794:	fc843783          	ld	a5,-56(s0)
    8001c798:	00178713          	addi	a4,a5,1
    8001c79c:	fce43423          	sd	a4,-56(s0)
    8001c7a0:	02d00713          	li	a4,45
    8001c7a4:	00e78023          	sb	a4,0(a5)
        n = -n;
    8001c7a8:	fc043783          	ld	a5,-64(s0)
    8001c7ac:	40f007b3          	neg	a5,a5
    8001c7b0:	fcf43023          	sd	a5,-64(s0)
    }
    // We can get the one's place by modding by 10, but
    // this stores the number backwards.
    for (i = 0;i < (STR_KEY_SIZE - 2) && n > 0;i += 1, n /= 10) {
    8001c7b4:	fe042623          	sw	zero,-20(s0)
    8001c7b8:	a83d                	j	8001c7f6 <map_int_to_str+0xa2>
        dst[i] = (char)(n % 10) + '0';
    8001c7ba:	fc043703          	ld	a4,-64(s0)
    8001c7be:	47a9                	li	a5,10
    8001c7c0:	02f767b3          	rem	a5,a4,a5
    8001c7c4:	0ff7f713          	andi	a4,a5,255
    8001c7c8:	fec42783          	lw	a5,-20(s0)
    8001c7cc:	fc843683          	ld	a3,-56(s0)
    8001c7d0:	97b6                	add	a5,a5,a3
    8001c7d2:	0307071b          	addiw	a4,a4,48
    8001c7d6:	0ff77713          	andi	a4,a4,255
    8001c7da:	00e78023          	sb	a4,0(a5)
    for (i = 0;i < (STR_KEY_SIZE - 2) && n > 0;i += 1, n /= 10) {
    8001c7de:	fec42783          	lw	a5,-20(s0)
    8001c7e2:	2785                	addiw	a5,a5,1
    8001c7e4:	fef42623          	sw	a5,-20(s0)
    8001c7e8:	fc043703          	ld	a4,-64(s0)
    8001c7ec:	47a9                	li	a5,10
    8001c7ee:	02f747b3          	div	a5,a4,a5
    8001c7f2:	fcf43023          	sd	a5,-64(s0)
    8001c7f6:	fec42783          	lw	a5,-20(s0)
    8001c7fa:	0007871b          	sext.w	a4,a5
    8001c7fe:	03d00793          	li	a5,61
    8001c802:	00e7c663          	blt	a5,a4,8001c80e <map_int_to_str+0xba>
    8001c806:	fc043783          	ld	a5,-64(s0)
    8001c80a:	faf048e3          	bgtz	a5,8001c7ba <map_int_to_str+0x66>
    }
    // Flip the number back into order.
    for (j = 0;j < i / 2;j+=1) {
    8001c80e:	fe042423          	sw	zero,-24(s0)
    8001c812:	a095                	j	8001c876 <map_int_to_str+0x122>
        char c;
        c = dst[j];
    8001c814:	fe842783          	lw	a5,-24(s0)
    8001c818:	fc843703          	ld	a4,-56(s0)
    8001c81c:	97ba                	add	a5,a5,a4
    8001c81e:	0007c783          	lbu	a5,0(a5)
    8001c822:	fcf40fa3          	sb	a5,-33(s0)
        dst[j] = dst[i - j - 1];
    8001c826:	fec42703          	lw	a4,-20(s0)
    8001c82a:	fe842783          	lw	a5,-24(s0)
    8001c82e:	40f707bb          	subw	a5,a4,a5
    8001c832:	2781                	sext.w	a5,a5
    8001c834:	17fd                	addi	a5,a5,-1
    8001c836:	fc843703          	ld	a4,-56(s0)
    8001c83a:	973e                	add	a4,a4,a5
    8001c83c:	fe842783          	lw	a5,-24(s0)
    8001c840:	fc843683          	ld	a3,-56(s0)
    8001c844:	97b6                	add	a5,a5,a3
    8001c846:	00074703          	lbu	a4,0(a4)
    8001c84a:	00e78023          	sb	a4,0(a5)
        dst[i - j - 1] = c;
    8001c84e:	fec42703          	lw	a4,-20(s0)
    8001c852:	fe842783          	lw	a5,-24(s0)
    8001c856:	40f707bb          	subw	a5,a4,a5
    8001c85a:	2781                	sext.w	a5,a5
    8001c85c:	17fd                	addi	a5,a5,-1
    8001c85e:	fc843703          	ld	a4,-56(s0)
    8001c862:	97ba                	add	a5,a5,a4
    8001c864:	fdf44703          	lbu	a4,-33(s0)
    8001c868:	00e78023          	sb	a4,0(a5)
    for (j = 0;j < i / 2;j+=1) {
    8001c86c:	fe842783          	lw	a5,-24(s0)
    8001c870:	2785                	addiw	a5,a5,1
    8001c872:	fef42423          	sw	a5,-24(s0)
    8001c876:	fec42783          	lw	a5,-20(s0)
    8001c87a:	01f7d71b          	srliw	a4,a5,0x1f
    8001c87e:	9fb9                	addw	a5,a5,a4
    8001c880:	4017d79b          	sraiw	a5,a5,0x1
    8001c884:	0007871b          	sext.w	a4,a5
    8001c888:	fe842783          	lw	a5,-24(s0)
    8001c88c:	2781                	sext.w	a5,a5
    8001c88e:	f8e7c3e3          	blt	a5,a4,8001c814 <map_int_to_str+0xc0>
    }
    dst[i] = '\0';
    8001c892:	fec42783          	lw	a5,-20(s0)
    8001c896:	fc843703          	ld	a4,-56(s0)
    8001c89a:	97ba                	add	a5,a5,a4
    8001c89c:	00078023          	sb	zero,0(a5)
    return ret;
    8001c8a0:	fe043783          	ld	a5,-32(s0)
}
    8001c8a4:	853e                	mv	a0,a5
    8001c8a6:	7462                	ld	s0,56(sp)
    8001c8a8:	6121                	addi	sp,sp,64
    8001c8aa:	8082                	ret

000000008001c8ac <map_get_elem>:

static MapElem *map_get_elem(Map *map, const char *key)
{
    8001c8ac:	7139                	addi	sp,sp,-64
    8001c8ae:	fc06                	sd	ra,56(sp)
    8001c8b0:	f822                	sd	s0,48(sp)
    8001c8b2:	0080                	addi	s0,sp,64
    8001c8b4:	fca43423          	sd	a0,-56(s0)
    8001c8b8:	fcb43023          	sd	a1,-64(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001c8bc:	fc043503          	ld	a0,-64(s0)
    8001c8c0:	e33ff0ef          	jal	ra,8001c6f2 <fnv1a_digest_64>
    8001c8c4:	872a                	mv	a4,a0
    8001c8c6:	fc843783          	ld	a5,-56(s0)
    8001c8ca:	439c                	lw	a5,0(a5)
    8001c8cc:	1782                	slli	a5,a5,0x20
    8001c8ce:	9381                	srli	a5,a5,0x20
    8001c8d0:	02f777b3          	remu	a5,a4,a5
    8001c8d4:	fef43023          	sd	a5,-32(s0)
    ListElem *e;
    MapElem *me;

    list_for_each_ascending(map->values[idx], e)
    8001c8d8:	fc843783          	ld	a5,-56(s0)
    8001c8dc:	6798                	ld	a4,8(a5)
    8001c8de:	fe043783          	ld	a5,-32(s0)
    8001c8e2:	078e                	slli	a5,a5,0x3
    8001c8e4:	97ba                	add	a5,a5,a4
    8001c8e6:	639c                	ld	a5,0(a5)
    8001c8e8:	853e                	mv	a0,a5
    8001c8ea:	c1dff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001c8ee:	fea43423          	sd	a0,-24(s0)
    8001c8f2:	a81d                	j	8001c928 <map_get_elem+0x7c>
    {
        me = list_elem_value_ptr(e);
    8001c8f4:	fe843503          	ld	a0,-24(s0)
    8001c8f8:	c6fff0ef          	jal	ra,8001c566 <list_elem_value>
    8001c8fc:	87aa                	mv	a5,a0
    8001c8fe:	fcf43c23          	sd	a5,-40(s0)
        if (!strcmp(key, me->key)) {
    8001c902:	fd843783          	ld	a5,-40(s0)
    8001c906:	639c                	ld	a5,0(a5)
    8001c908:	85be                	mv	a1,a5
    8001c90a:	fc043503          	ld	a0,-64(s0)
    8001c90e:	6ad000ef          	jal	ra,8001d7ba <strcmp>
    8001c912:	87aa                	mv	a5,a0
    8001c914:	e781                	bnez	a5,8001c91c <map_get_elem+0x70>
            return me;
    8001c916:	fd843783          	ld	a5,-40(s0)
    8001c91a:	a03d                	j	8001c948 <map_get_elem+0x9c>
    list_for_each_ascending(map->values[idx], e)
    8001c91c:	fe843503          	ld	a0,-24(s0)
    8001c920:	c2fff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001c924:	fea43423          	sd	a0,-24(s0)
    8001c928:	fc843783          	ld	a5,-56(s0)
    8001c92c:	6798                	ld	a4,8(a5)
    8001c92e:	fe043783          	ld	a5,-32(s0)
    8001c932:	078e                	slli	a5,a5,0x3
    8001c934:	97ba                	add	a5,a5,a4
    8001c936:	639c                	ld	a5,0(a5)
    8001c938:	fe843583          	ld	a1,-24(s0)
    8001c93c:	853e                	mv	a0,a5
    8001c93e:	b3bff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001c942:	87aa                	mv	a5,a0
    8001c944:	fbc5                	bnez	a5,8001c8f4 <map_get_elem+0x48>
        }
    }

    return NULL;
    8001c946:	4781                	li	a5,0
}
    8001c948:	853e                	mv	a0,a5
    8001c94a:	70e2                	ld	ra,56(sp)
    8001c94c:	7442                	ld	s0,48(sp)
    8001c94e:	6121                	addi	sp,sp,64
    8001c950:	8082                	ret

000000008001c952 <map_get_celem>:

static const MapElem *map_get_celem(const Map *map, const char *key)
{
    8001c952:	7139                	addi	sp,sp,-64
    8001c954:	fc06                	sd	ra,56(sp)
    8001c956:	f822                	sd	s0,48(sp)
    8001c958:	0080                	addi	s0,sp,64
    8001c95a:	fca43423          	sd	a0,-56(s0)
    8001c95e:	fcb43023          	sd	a1,-64(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001c962:	fc043503          	ld	a0,-64(s0)
    8001c966:	d8dff0ef          	jal	ra,8001c6f2 <fnv1a_digest_64>
    8001c96a:	872a                	mv	a4,a0
    8001c96c:	fc843783          	ld	a5,-56(s0)
    8001c970:	439c                	lw	a5,0(a5)
    8001c972:	1782                	slli	a5,a5,0x20
    8001c974:	9381                	srli	a5,a5,0x20
    8001c976:	02f777b3          	remu	a5,a4,a5
    8001c97a:	fef43023          	sd	a5,-32(s0)
    ListElem *e;
    const MapElem *me;

    list_for_each_ascending(map->values[idx], e)
    8001c97e:	fc843783          	ld	a5,-56(s0)
    8001c982:	6798                	ld	a4,8(a5)
    8001c984:	fe043783          	ld	a5,-32(s0)
    8001c988:	078e                	slli	a5,a5,0x3
    8001c98a:	97ba                	add	a5,a5,a4
    8001c98c:	639c                	ld	a5,0(a5)
    8001c98e:	853e                	mv	a0,a5
    8001c990:	b77ff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001c994:	fea43423          	sd	a0,-24(s0)
    8001c998:	a81d                	j	8001c9ce <map_get_celem+0x7c>
    {
        me = list_celem_value_ptr(e);
    8001c99a:	fe843503          	ld	a0,-24(s0)
    8001c99e:	bc9ff0ef          	jal	ra,8001c566 <list_elem_value>
    8001c9a2:	87aa                	mv	a5,a0
    8001c9a4:	fcf43c23          	sd	a5,-40(s0)
        if (!strcmp(key, me->key)) {
    8001c9a8:	fd843783          	ld	a5,-40(s0)
    8001c9ac:	639c                	ld	a5,0(a5)
    8001c9ae:	85be                	mv	a1,a5
    8001c9b0:	fc043503          	ld	a0,-64(s0)
    8001c9b4:	607000ef          	jal	ra,8001d7ba <strcmp>
    8001c9b8:	87aa                	mv	a5,a0
    8001c9ba:	e781                	bnez	a5,8001c9c2 <map_get_celem+0x70>
            return me;
    8001c9bc:	fd843783          	ld	a5,-40(s0)
    8001c9c0:	a03d                	j	8001c9ee <map_get_celem+0x9c>
    list_for_each_ascending(map->values[idx], e)
    8001c9c2:	fe843503          	ld	a0,-24(s0)
    8001c9c6:	b89ff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001c9ca:	fea43423          	sd	a0,-24(s0)
    8001c9ce:	fc843783          	ld	a5,-56(s0)
    8001c9d2:	6798                	ld	a4,8(a5)
    8001c9d4:	fe043783          	ld	a5,-32(s0)
    8001c9d8:	078e                	slli	a5,a5,0x3
    8001c9da:	97ba                	add	a5,a5,a4
    8001c9dc:	639c                	ld	a5,0(a5)
    8001c9de:	fe843583          	ld	a1,-24(s0)
    8001c9e2:	853e                	mv	a0,a5
    8001c9e4:	a95ff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001c9e8:	87aa                	mv	a5,a0
    8001c9ea:	fbc5                	bnez	a5,8001c99a <map_get_celem+0x48>
        }
    }

    return NULL;
    8001c9ec:	4781                	li	a5,0
}
    8001c9ee:	853e                	mv	a0,a5
    8001c9f0:	70e2                	ld	ra,56(sp)
    8001c9f2:	7442                	ld	s0,48(sp)
    8001c9f4:	6121                	addi	sp,sp,64
    8001c9f6:	8082                	ret

000000008001c9f8 <mapelem_set_val>:

static void mapelem_set_val(MapElem *me, MapValue val) {
    8001c9f8:	1101                	addi	sp,sp,-32
    8001c9fa:	ec22                	sd	s0,24(sp)
    8001c9fc:	1000                	addi	s0,sp,32
    8001c9fe:	fea43423          	sd	a0,-24(s0)
    8001ca02:	feb43023          	sd	a1,-32(s0)
    me->val = val;
    8001ca06:	fe843783          	ld	a5,-24(s0)
    8001ca0a:	fe043703          	ld	a4,-32(s0)
    8001ca0e:	e798                	sd	a4,8(a5)
}
    8001ca10:	0001                	nop
    8001ca12:	6462                	ld	s0,24(sp)
    8001ca14:	6105                	addi	sp,sp,32
    8001ca16:	8082                	ret

000000008001ca18 <mapelem_new_val>:

static void mapelem_new_val(Map *map, const char *key, MapValue val) {
    8001ca18:	7139                	addi	sp,sp,-64
    8001ca1a:	fc06                	sd	ra,56(sp)
    8001ca1c:	f822                	sd	s0,48(sp)
    8001ca1e:	0080                	addi	s0,sp,64
    8001ca20:	fca43c23          	sd	a0,-40(s0)
    8001ca24:	fcb43823          	sd	a1,-48(s0)
    8001ca28:	fcc43423          	sd	a2,-56(s0)
    MapElem *me;
    // If we get here, the key isn't there.
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001ca2c:	fd043503          	ld	a0,-48(s0)
    8001ca30:	cc3ff0ef          	jal	ra,8001c6f2 <fnv1a_digest_64>
    8001ca34:	872a                	mv	a4,a0
    8001ca36:	fd843783          	ld	a5,-40(s0)
    8001ca3a:	439c                	lw	a5,0(a5)
    8001ca3c:	1782                	slli	a5,a5,0x20
    8001ca3e:	9381                	srli	a5,a5,0x20
    8001ca40:	02f777b3          	remu	a5,a4,a5
    8001ca44:	fef43423          	sd	a5,-24(s0)
    me           = (MapElem *)g_kmalloc(sizeof(MapElem));
    8001ca48:	4541                	li	a0,16
    8001ca4a:	d32ff0ef          	jal	ra,8001bf7c <g_kmalloc>
    8001ca4e:	fea43023          	sd	a0,-32(s0)
    me->key      = strdup(key);
    8001ca52:	fd043503          	ld	a0,-48(s0)
    8001ca56:	162010ef          	jal	ra,8001dbb8 <strdup>
    8001ca5a:	872a                	mv	a4,a0
    8001ca5c:	fe043783          	ld	a5,-32(s0)
    8001ca60:	e398                	sd	a4,0(a5)
    me->val      = val;
    8001ca62:	fe043783          	ld	a5,-32(s0)
    8001ca66:	fc843703          	ld	a4,-56(s0)
    8001ca6a:	e798                	sd	a4,8(a5)
    list_add_ptr(map->values[idx], me);
    8001ca6c:	fd843783          	ld	a5,-40(s0)
    8001ca70:	6798                	ld	a4,8(a5)
    8001ca72:	fe843783          	ld	a5,-24(s0)
    8001ca76:	078e                	slli	a5,a5,0x3
    8001ca78:	97ba                	add	a5,a5,a4
    8001ca7a:	639c                	ld	a5,0(a5)
    8001ca7c:	fe043703          	ld	a4,-32(s0)
    8001ca80:	85ba                	mv	a1,a4
    8001ca82:	853e                	mv	a0,a5
    8001ca84:	e62ff0ef          	jal	ra,8001c0e6 <list_add>
    map->size += 1;
    8001ca88:	fd843783          	ld	a5,-40(s0)
    8001ca8c:	43dc                	lw	a5,4(a5)
    8001ca8e:	2785                	addiw	a5,a5,1
    8001ca90:	0007871b          	sext.w	a4,a5
    8001ca94:	fd843783          	ld	a5,-40(s0)
    8001ca98:	c3d8                	sw	a4,4(a5)
}
    8001ca9a:	0001                	nop
    8001ca9c:	70e2                	ld	ra,56(sp)
    8001ca9e:	7442                	ld	s0,48(sp)
    8001caa0:	6121                	addi	sp,sp,64
    8001caa2:	8082                	ret

000000008001caa4 <map_init_values>:

static struct List **map_init_values(uint32_t slots) {
    8001caa4:	7139                	addi	sp,sp,-64
    8001caa6:	fc06                	sd	ra,56(sp)
    8001caa8:	f822                	sd	s0,48(sp)
    8001caaa:	f426                	sd	s1,40(sp)
    8001caac:	0080                	addi	s0,sp,64
    8001caae:	87aa                	mv	a5,a0
    8001cab0:	fcf42623          	sw	a5,-52(s0)
    struct List **lst = (struct List **)g_kcalloc(slots, sizeof(struct List *));
    8001cab4:	fcc46783          	lwu	a5,-52(s0)
    8001cab8:	45a1                	li	a1,8
    8001caba:	853e                	mv	a0,a5
    8001cabc:	cf8ff0ef          	jal	ra,8001bfb4 <g_kcalloc>
    8001cac0:	fca43823          	sd	a0,-48(s0)
    for (uint32_t i = 0; i < slots; i++) {
    8001cac4:	fc042e23          	sw	zero,-36(s0)
    8001cac8:	a00d                	j	8001caea <map_init_values+0x46>
        lst[i] = list_new();
    8001caca:	fdc46783          	lwu	a5,-36(s0)
    8001cace:	078e                	slli	a5,a5,0x3
    8001cad0:	fd043703          	ld	a4,-48(s0)
    8001cad4:	00f704b3          	add	s1,a4,a5
    8001cad8:	ddeff0ef          	jal	ra,8001c0b6 <list_new>
    8001cadc:	87aa                	mv	a5,a0
    8001cade:	e09c                	sd	a5,0(s1)
    for (uint32_t i = 0; i < slots; i++) {
    8001cae0:	fdc42783          	lw	a5,-36(s0)
    8001cae4:	2785                	addiw	a5,a5,1
    8001cae6:	fcf42e23          	sw	a5,-36(s0)
    8001caea:	fdc42703          	lw	a4,-36(s0)
    8001caee:	fcc42783          	lw	a5,-52(s0)
    8001caf2:	2701                	sext.w	a4,a4
    8001caf4:	2781                	sext.w	a5,a5
    8001caf6:	fcf76ae3          	bltu	a4,a5,8001caca <map_init_values+0x26>
    }
    return lst;
    8001cafa:	fd043783          	ld	a5,-48(s0)
}
    8001cafe:	853e                	mv	a0,a5
    8001cb00:	70e2                	ld	ra,56(sp)
    8001cb02:	7442                	ld	s0,48(sp)
    8001cb04:	74a2                	ld	s1,40(sp)
    8001cb06:	6121                	addi	sp,sp,64
    8001cb08:	8082                	ret

000000008001cb0a <map_elem_free>:

static void map_elem_free(MapElem *me) {
    8001cb0a:	1101                	addi	sp,sp,-32
    8001cb0c:	ec06                	sd	ra,24(sp)
    8001cb0e:	e822                	sd	s0,16(sp)
    8001cb10:	1000                	addi	s0,sp,32
    8001cb12:	fea43423          	sd	a0,-24(s0)
    g_kfree(me->key);
    8001cb16:	fe843783          	ld	a5,-24(s0)
    8001cb1a:	639c                	ld	a5,0(a5)
    8001cb1c:	853e                	mv	a0,a5
    8001cb1e:	cf8ff0ef          	jal	ra,8001c016 <g_kfree>
    g_kfree(me);
    8001cb22:	fe843503          	ld	a0,-24(s0)
    8001cb26:	cf0ff0ef          	jal	ra,8001c016 <g_kfree>
}
    8001cb2a:	0001                	nop
    8001cb2c:	60e2                	ld	ra,24(sp)
    8001cb2e:	6442                	ld	s0,16(sp)
    8001cb30:	6105                	addi	sp,sp,32
    8001cb32:	8082                	ret

000000008001cb34 <map_lst_free>:

static void map_lst_free(ListElem *e) {
    8001cb34:	1101                	addi	sp,sp,-32
    8001cb36:	ec06                	sd	ra,24(sp)
    8001cb38:	e822                	sd	s0,16(sp)
    8001cb3a:	1000                	addi	s0,sp,32
    8001cb3c:	fea43423          	sd	a0,-24(s0)
    map_elem_free(list_elem_value_ptr(e));
    8001cb40:	fe843503          	ld	a0,-24(s0)
    8001cb44:	a23ff0ef          	jal	ra,8001c566 <list_elem_value>
    8001cb48:	87aa                	mv	a5,a0
    8001cb4a:	853e                	mv	a0,a5
    8001cb4c:	fbfff0ef          	jal	ra,8001cb0a <map_elem_free>
    list_remove_elem(e);
    8001cb50:	fe843503          	ld	a0,-24(s0)
    8001cb54:	f34ff0ef          	jal	ra,8001c288 <list_remove_elem>
}
    8001cb58:	0001                	nop
    8001cb5a:	60e2                	ld	ra,24(sp)
    8001cb5c:	6442                	ld	s0,16(sp)
    8001cb5e:	6105                	addi	sp,sp,32
    8001cb60:	8082                	ret

000000008001cb62 <map_init>:

static Map *map_init(Map *map, uint32_t slots)
{
    8001cb62:	1101                	addi	sp,sp,-32
    8001cb64:	ec06                	sd	ra,24(sp)
    8001cb66:	e822                	sd	s0,16(sp)
    8001cb68:	1000                	addi	s0,sp,32
    8001cb6a:	fea43423          	sd	a0,-24(s0)
    8001cb6e:	87ae                	mv	a5,a1
    8001cb70:	fef42223          	sw	a5,-28(s0)
    if (map == NULL) {
    8001cb74:	fe843783          	ld	a5,-24(s0)
    8001cb78:	e399                	bnez	a5,8001cb7e <map_init+0x1c>
        return NULL;
    8001cb7a:	4781                	li	a5,0
    8001cb7c:	a805                	j	8001cbac <map_init+0x4a>
    }

    map->slots  = slots == 0 ? 1 : slots;
    8001cb7e:	fe442783          	lw	a5,-28(s0)
    8001cb82:	2781                	sext.w	a5,a5
    8001cb84:	c781                	beqz	a5,8001cb8c <map_init+0x2a>
    8001cb86:	fe442783          	lw	a5,-28(s0)
    8001cb8a:	a011                	j	8001cb8e <map_init+0x2c>
    8001cb8c:	4785                	li	a5,1
    8001cb8e:	fe843703          	ld	a4,-24(s0)
    8001cb92:	c31c                	sw	a5,0(a4)
    map->values = map_init_values(map->slots);
    8001cb94:	fe843783          	ld	a5,-24(s0)
    8001cb98:	439c                	lw	a5,0(a5)
    8001cb9a:	853e                	mv	a0,a5
    8001cb9c:	f09ff0ef          	jal	ra,8001caa4 <map_init_values>
    8001cba0:	872a                	mv	a4,a0
    8001cba2:	fe843783          	ld	a5,-24(s0)
    8001cba6:	e798                	sd	a4,8(a5)
    return map;
    8001cba8:	fe843783          	ld	a5,-24(s0)
}
    8001cbac:	853e                	mv	a0,a5
    8001cbae:	60e2                	ld	ra,24(sp)
    8001cbb0:	6442                	ld	s0,16(sp)
    8001cbb2:	6105                	addi	sp,sp,32
    8001cbb4:	8082                	ret

000000008001cbb6 <map_new>:

Map *map_new(void)
{
    8001cbb6:	1141                	addi	sp,sp,-16
    8001cbb8:	e406                	sd	ra,8(sp)
    8001cbba:	e022                	sd	s0,0(sp)
    8001cbbc:	0800                	addi	s0,sp,16
    return map_new_with_slots(DEFAULT_MAP_SIZE);
    8001cbbe:	04000513          	li	a0,64
    8001cbc2:	010000ef          	jal	ra,8001cbd2 <map_new_with_slots>
    8001cbc6:	87aa                	mv	a5,a0
}
    8001cbc8:	853e                	mv	a0,a5
    8001cbca:	60a2                	ld	ra,8(sp)
    8001cbcc:	6402                	ld	s0,0(sp)
    8001cbce:	0141                	addi	sp,sp,16
    8001cbd0:	8082                	ret

000000008001cbd2 <map_new_with_slots>:

Map *map_new_with_slots(uint32_t slots)
{
    8001cbd2:	1101                	addi	sp,sp,-32
    8001cbd4:	ec06                	sd	ra,24(sp)
    8001cbd6:	e822                	sd	s0,16(sp)
    8001cbd8:	1000                	addi	s0,sp,32
    8001cbda:	87aa                	mv	a5,a0
    8001cbdc:	fef42623          	sw	a5,-20(s0)
    if (slots == 0) {
    8001cbe0:	fec42783          	lw	a5,-20(s0)
    8001cbe4:	2781                	sext.w	a5,a5
    8001cbe6:	e399                	bnez	a5,8001cbec <map_new_with_slots+0x1a>
        return NULL;
    8001cbe8:	4781                	li	a5,0
    8001cbea:	a821                	j	8001cc02 <map_new_with_slots+0x30>
    }
    return map_init((Map *)g_kmalloc(sizeof(Map)), slots);
    8001cbec:	4541                	li	a0,16
    8001cbee:	b8eff0ef          	jal	ra,8001bf7c <g_kmalloc>
    8001cbf2:	872a                	mv	a4,a0
    8001cbf4:	fec42783          	lw	a5,-20(s0)
    8001cbf8:	85be                	mv	a1,a5
    8001cbfa:	853a                	mv	a0,a4
    8001cbfc:	f67ff0ef          	jal	ra,8001cb62 <map_init>
    8001cc00:	87aa                	mv	a5,a0
}
    8001cc02:	853e                	mv	a0,a5
    8001cc04:	60e2                	ld	ra,24(sp)
    8001cc06:	6442                	ld	s0,16(sp)
    8001cc08:	6105                	addi	sp,sp,32
    8001cc0a:	8082                	ret

000000008001cc0c <map_slots>:


uint32_t map_slots(const Map *map)
{
    8001cc0c:	1101                	addi	sp,sp,-32
    8001cc0e:	ec22                	sd	s0,24(sp)
    8001cc10:	1000                	addi	s0,sp,32
    8001cc12:	fea43423          	sd	a0,-24(s0)
    return map->slots;
    8001cc16:	fe843783          	ld	a5,-24(s0)
    8001cc1a:	439c                	lw	a5,0(a5)
}
    8001cc1c:	853e                	mv	a0,a5
    8001cc1e:	6462                	ld	s0,24(sp)
    8001cc20:	6105                	addi	sp,sp,32
    8001cc22:	8082                	ret

000000008001cc24 <map_size>:

uint32_t map_size(const Map *map)
{
    8001cc24:	1101                	addi	sp,sp,-32
    8001cc26:	ec22                	sd	s0,24(sp)
    8001cc28:	1000                	addi	s0,sp,32
    8001cc2a:	fea43423          	sd	a0,-24(s0)
    return map->size;
    8001cc2e:	fe843783          	ld	a5,-24(s0)
    8001cc32:	43dc                	lw	a5,4(a5)
}
    8001cc34:	853e                	mv	a0,a5
    8001cc36:	6462                	ld	s0,24(sp)
    8001cc38:	6105                	addi	sp,sp,32
    8001cc3a:	8082                	ret

000000008001cc3c <map_set>:

void map_set(Map *map, const char *key, MapValue val)
{
    8001cc3c:	7139                	addi	sp,sp,-64
    8001cc3e:	fc06                	sd	ra,56(sp)
    8001cc40:	f822                	sd	s0,48(sp)
    8001cc42:	0080                	addi	s0,sp,64
    8001cc44:	fca43c23          	sd	a0,-40(s0)
    8001cc48:	fcb43823          	sd	a1,-48(s0)
    8001cc4c:	fcc43423          	sd	a2,-56(s0)
    MapElem *me = map_get_elem(map, key);
    8001cc50:	fd043583          	ld	a1,-48(s0)
    8001cc54:	fd843503          	ld	a0,-40(s0)
    8001cc58:	c55ff0ef          	jal	ra,8001c8ac <map_get_elem>
    8001cc5c:	fea43423          	sd	a0,-24(s0)
    if (me != NULL) {
    8001cc60:	fe843783          	ld	a5,-24(s0)
    8001cc64:	cb81                	beqz	a5,8001cc74 <map_set+0x38>
        mapelem_set_val(me, val);
    8001cc66:	fc843583          	ld	a1,-56(s0)
    8001cc6a:	fe843503          	ld	a0,-24(s0)
    8001cc6e:	d8bff0ef          	jal	ra,8001c9f8 <mapelem_set_val>
    }
    else {
        mapelem_new_val(map, key, val);
    }
}
    8001cc72:	a809                	j	8001cc84 <map_set+0x48>
        mapelem_new_val(map, key, val);
    8001cc74:	fc843603          	ld	a2,-56(s0)
    8001cc78:	fd043583          	ld	a1,-48(s0)
    8001cc7c:	fd843503          	ld	a0,-40(s0)
    8001cc80:	d99ff0ef          	jal	ra,8001ca18 <mapelem_new_val>
}
    8001cc84:	0001                	nop
    8001cc86:	70e2                	ld	ra,56(sp)
    8001cc88:	7442                	ld	s0,48(sp)
    8001cc8a:	6121                	addi	sp,sp,64
    8001cc8c:	8082                	ret

000000008001cc8e <map_set_int>:

void map_set_int(Map *map, long ikey, MapValue val)
{
    8001cc8e:	7159                	addi	sp,sp,-112
    8001cc90:	f486                	sd	ra,104(sp)
    8001cc92:	f0a2                	sd	s0,96(sp)
    8001cc94:	1880                	addi	s0,sp,112
    8001cc96:	faa43423          	sd	a0,-88(s0)
    8001cc9a:	fab43023          	sd	a1,-96(s0)
    8001cc9e:	f8c43c23          	sd	a2,-104(s0)
    char key[STR_KEY_SIZE];
    map_set(map, map_int_to_str(key, ikey), val);
    8001cca2:	fb040793          	addi	a5,s0,-80
    8001cca6:	fa043583          	ld	a1,-96(s0)
    8001ccaa:	853e                	mv	a0,a5
    8001ccac:	aa9ff0ef          	jal	ra,8001c754 <map_int_to_str>
    8001ccb0:	87aa                	mv	a5,a0
    8001ccb2:	f9843603          	ld	a2,-104(s0)
    8001ccb6:	85be                	mv	a1,a5
    8001ccb8:	fa843503          	ld	a0,-88(s0)
    8001ccbc:	f81ff0ef          	jal	ra,8001cc3c <map_set>
}
    8001ccc0:	0001                	nop
    8001ccc2:	70a6                	ld	ra,104(sp)
    8001ccc4:	7406                	ld	s0,96(sp)
    8001ccc6:	6165                	addi	sp,sp,112
    8001ccc8:	8082                	ret

000000008001ccca <map_get_unchecked>:

MapValue map_get_unchecked(const Map *map, const char *key)
{
    8001ccca:	7179                	addi	sp,sp,-48
    8001cccc:	f406                	sd	ra,40(sp)
    8001ccce:	f022                	sd	s0,32(sp)
    8001ccd0:	1800                	addi	s0,sp,48
    8001ccd2:	fca43c23          	sd	a0,-40(s0)
    8001ccd6:	fcb43823          	sd	a1,-48(s0)
    MapValue ret = 0;
    8001ccda:	fe043423          	sd	zero,-24(s0)
    map_get(map, key, &ret);
    8001ccde:	fe840793          	addi	a5,s0,-24
    8001cce2:	863e                	mv	a2,a5
    8001cce4:	fd043583          	ld	a1,-48(s0)
    8001cce8:	fd843503          	ld	a0,-40(s0)
    8001ccec:	012000ef          	jal	ra,8001ccfe <map_get>
    return ret;
    8001ccf0:	fe843783          	ld	a5,-24(s0)
}
    8001ccf4:	853e                	mv	a0,a5
    8001ccf6:	70a2                	ld	ra,40(sp)
    8001ccf8:	7402                	ld	s0,32(sp)
    8001ccfa:	6145                	addi	sp,sp,48
    8001ccfc:	8082                	ret

000000008001ccfe <map_get>:

bool map_get(const Map *map, const char *key, MapValue *value)
{
    8001ccfe:	7139                	addi	sp,sp,-64
    8001cd00:	fc06                	sd	ra,56(sp)
    8001cd02:	f822                	sd	s0,48(sp)
    8001cd04:	0080                	addi	s0,sp,64
    8001cd06:	fca43c23          	sd	a0,-40(s0)
    8001cd0a:	fcb43823          	sd	a1,-48(s0)
    8001cd0e:	fcc43423          	sd	a2,-56(s0)
    const MapElem *me = map_get_celem(map, key);
    8001cd12:	fd043583          	ld	a1,-48(s0)
    8001cd16:	fd843503          	ld	a0,-40(s0)
    8001cd1a:	c39ff0ef          	jal	ra,8001c952 <map_get_celem>
    8001cd1e:	fea43423          	sd	a0,-24(s0)
    if (me == NULL) {
    8001cd22:	fe843783          	ld	a5,-24(s0)
    8001cd26:	e399                	bnez	a5,8001cd2c <map_get+0x2e>
        return false;
    8001cd28:	4781                	li	a5,0
    8001cd2a:	a819                	j	8001cd40 <map_get+0x42>
    }
    if (value != NULL) {
    8001cd2c:	fc843783          	ld	a5,-56(s0)
    8001cd30:	c799                	beqz	a5,8001cd3e <map_get+0x40>
        *value = me->val;
    8001cd32:	fe843783          	ld	a5,-24(s0)
    8001cd36:	6798                	ld	a4,8(a5)
    8001cd38:	fc843783          	ld	a5,-56(s0)
    8001cd3c:	e398                	sd	a4,0(a5)
    }
    return true;
    8001cd3e:	4785                	li	a5,1
}
    8001cd40:	853e                	mv	a0,a5
    8001cd42:	70e2                	ld	ra,56(sp)
    8001cd44:	7442                	ld	s0,48(sp)
    8001cd46:	6121                	addi	sp,sp,64
    8001cd48:	8082                	ret

000000008001cd4a <map_get_int>:

bool map_get_int(const Map *map, long ikey, MapValue *value)
{
    8001cd4a:	7159                	addi	sp,sp,-112
    8001cd4c:	f486                	sd	ra,104(sp)
    8001cd4e:	f0a2                	sd	s0,96(sp)
    8001cd50:	1880                	addi	s0,sp,112
    8001cd52:	faa43423          	sd	a0,-88(s0)
    8001cd56:	fab43023          	sd	a1,-96(s0)
    8001cd5a:	f8c43c23          	sd	a2,-104(s0)
    char key[STR_KEY_SIZE];
    return map_get(map, map_int_to_str(key, ikey), value);
    8001cd5e:	fb040793          	addi	a5,s0,-80
    8001cd62:	fa043583          	ld	a1,-96(s0)
    8001cd66:	853e                	mv	a0,a5
    8001cd68:	9edff0ef          	jal	ra,8001c754 <map_int_to_str>
    8001cd6c:	87aa                	mv	a5,a0
    8001cd6e:	f9843603          	ld	a2,-104(s0)
    8001cd72:	85be                	mv	a1,a5
    8001cd74:	fa843503          	ld	a0,-88(s0)
    8001cd78:	f87ff0ef          	jal	ra,8001ccfe <map_get>
    8001cd7c:	87aa                	mv	a5,a0
}
    8001cd7e:	853e                	mv	a0,a5
    8001cd80:	70a6                	ld	ra,104(sp)
    8001cd82:	7406                	ld	s0,96(sp)
    8001cd84:	6165                	addi	sp,sp,112
    8001cd86:	8082                	ret

000000008001cd88 <map_contains>:

bool map_contains(const Map *map, const char *key)
{
    8001cd88:	1101                	addi	sp,sp,-32
    8001cd8a:	ec06                	sd	ra,24(sp)
    8001cd8c:	e822                	sd	s0,16(sp)
    8001cd8e:	1000                	addi	s0,sp,32
    8001cd90:	fea43423          	sd	a0,-24(s0)
    8001cd94:	feb43023          	sd	a1,-32(s0)
    return map_get(map, key, NULL);
    8001cd98:	4601                	li	a2,0
    8001cd9a:	fe043583          	ld	a1,-32(s0)
    8001cd9e:	fe843503          	ld	a0,-24(s0)
    8001cda2:	f5dff0ef          	jal	ra,8001ccfe <map_get>
    8001cda6:	87aa                	mv	a5,a0
}
    8001cda8:	853e                	mv	a0,a5
    8001cdaa:	60e2                	ld	ra,24(sp)
    8001cdac:	6442                	ld	s0,16(sp)
    8001cdae:	6105                	addi	sp,sp,32
    8001cdb0:	8082                	ret

000000008001cdb2 <map_contains_int>:

bool map_contains_int(const struct Map *map, long ikey)
{
    8001cdb2:	1101                	addi	sp,sp,-32
    8001cdb4:	ec06                	sd	ra,24(sp)
    8001cdb6:	e822                	sd	s0,16(sp)
    8001cdb8:	1000                	addi	s0,sp,32
    8001cdba:	fea43423          	sd	a0,-24(s0)
    8001cdbe:	feb43023          	sd	a1,-32(s0)
    return map_get_int(map, ikey, NULL);
    8001cdc2:	4601                	li	a2,0
    8001cdc4:	fe043583          	ld	a1,-32(s0)
    8001cdc8:	fe843503          	ld	a0,-24(s0)
    8001cdcc:	f7fff0ef          	jal	ra,8001cd4a <map_get_int>
    8001cdd0:	87aa                	mv	a5,a0
}
    8001cdd2:	853e                	mv	a0,a5
    8001cdd4:	60e2                	ld	ra,24(sp)
    8001cdd6:	6442                	ld	s0,16(sp)
    8001cdd8:	6105                	addi	sp,sp,32
    8001cdda:	8082                	ret

000000008001cddc <map_remove>:

bool map_remove(Map *map, const char *key)
{
    8001cddc:	7179                	addi	sp,sp,-48
    8001cdde:	f406                	sd	ra,40(sp)
    8001cde0:	f022                	sd	s0,32(sp)
    8001cde2:	1800                	addi	s0,sp,48
    8001cde4:	fca43c23          	sd	a0,-40(s0)
    8001cde8:	fcb43823          	sd	a1,-48(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001cdec:	fd043503          	ld	a0,-48(s0)
    8001cdf0:	903ff0ef          	jal	ra,8001c6f2 <fnv1a_digest_64>
    8001cdf4:	872a                	mv	a4,a0
    8001cdf6:	fd843783          	ld	a5,-40(s0)
    8001cdfa:	439c                	lw	a5,0(a5)
    8001cdfc:	1782                	slli	a5,a5,0x20
    8001cdfe:	9381                	srli	a5,a5,0x20
    8001ce00:	02f777b3          	remu	a5,a4,a5
    8001ce04:	fef43023          	sd	a5,-32(s0)
    ListElem *e;

    list_for_each_ascending(map->values[idx], e)
    8001ce08:	fd843783          	ld	a5,-40(s0)
    8001ce0c:	6798                	ld	a4,8(a5)
    8001ce0e:	fe043783          	ld	a5,-32(s0)
    8001ce12:	078e                	slli	a5,a5,0x3
    8001ce14:	97ba                	add	a5,a5,a4
    8001ce16:	639c                	ld	a5,0(a5)
    8001ce18:	853e                	mv	a0,a5
    8001ce1a:	eecff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001ce1e:	fea43423          	sd	a0,-24(s0)
    8001ce22:	a099                	j	8001ce68 <map_remove+0x8c>
    {
        if (!strcmp(key, ((MapElem *)list_elem_value(e))->key)) {
    8001ce24:	fe843503          	ld	a0,-24(s0)
    8001ce28:	f3eff0ef          	jal	ra,8001c566 <list_elem_value>
    8001ce2c:	87aa                	mv	a5,a0
    8001ce2e:	639c                	ld	a5,0(a5)
    8001ce30:	85be                	mv	a1,a5
    8001ce32:	fd043503          	ld	a0,-48(s0)
    8001ce36:	185000ef          	jal	ra,8001d7ba <strcmp>
    8001ce3a:	87aa                	mv	a5,a0
    8001ce3c:	e385                	bnez	a5,8001ce5c <map_remove+0x80>
            map_lst_free(e);
    8001ce3e:	fe843503          	ld	a0,-24(s0)
    8001ce42:	cf3ff0ef          	jal	ra,8001cb34 <map_lst_free>
            map->size -= 1;
    8001ce46:	fd843783          	ld	a5,-40(s0)
    8001ce4a:	43dc                	lw	a5,4(a5)
    8001ce4c:	37fd                	addiw	a5,a5,-1
    8001ce4e:	0007871b          	sext.w	a4,a5
    8001ce52:	fd843783          	ld	a5,-40(s0)
    8001ce56:	c3d8                	sw	a4,4(a5)
            return true;
    8001ce58:	4785                	li	a5,1
    8001ce5a:	a03d                	j	8001ce88 <map_remove+0xac>
    list_for_each_ascending(map->values[idx], e)
    8001ce5c:	fe843503          	ld	a0,-24(s0)
    8001ce60:	eeeff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001ce64:	fea43423          	sd	a0,-24(s0)
    8001ce68:	fd843783          	ld	a5,-40(s0)
    8001ce6c:	6798                	ld	a4,8(a5)
    8001ce6e:	fe043783          	ld	a5,-32(s0)
    8001ce72:	078e                	slli	a5,a5,0x3
    8001ce74:	97ba                	add	a5,a5,a4
    8001ce76:	639c                	ld	a5,0(a5)
    8001ce78:	fe843583          	ld	a1,-24(s0)
    8001ce7c:	853e                	mv	a0,a5
    8001ce7e:	dfaff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001ce82:	87aa                	mv	a5,a0
    8001ce84:	f3c5                	bnez	a5,8001ce24 <map_remove+0x48>
        }
    }
    return false;
    8001ce86:	4781                	li	a5,0
}
    8001ce88:	853e                	mv	a0,a5
    8001ce8a:	70a2                	ld	ra,40(sp)
    8001ce8c:	7402                	ld	s0,32(sp)
    8001ce8e:	6145                	addi	sp,sp,48
    8001ce90:	8082                	ret

000000008001ce92 <map_remove_int>:

bool map_remove_int(Map *map, long ikey)
{
    8001ce92:	711d                	addi	sp,sp,-96
    8001ce94:	ec86                	sd	ra,88(sp)
    8001ce96:	e8a2                	sd	s0,80(sp)
    8001ce98:	1080                	addi	s0,sp,96
    8001ce9a:	faa43423          	sd	a0,-88(s0)
    8001ce9e:	fab43023          	sd	a1,-96(s0)
    char key[STR_KEY_SIZE];
    return map_remove(map, map_int_to_str(key, ikey));
    8001cea2:	fb040793          	addi	a5,s0,-80
    8001cea6:	fa043583          	ld	a1,-96(s0)
    8001ceaa:	853e                	mv	a0,a5
    8001ceac:	8a9ff0ef          	jal	ra,8001c754 <map_int_to_str>
    8001ceb0:	87aa                	mv	a5,a0
    8001ceb2:	85be                	mv	a1,a5
    8001ceb4:	fa843503          	ld	a0,-88(s0)
    8001ceb8:	f25ff0ef          	jal	ra,8001cddc <map_remove>
    8001cebc:	87aa                	mv	a5,a0
}
    8001cebe:	853e                	mv	a0,a5
    8001cec0:	60e6                	ld	ra,88(sp)
    8001cec2:	6446                	ld	s0,80(sp)
    8001cec4:	6125                	addi	sp,sp,96
    8001cec6:	8082                	ret

000000008001cec8 <map_clear>:

void map_clear(Map *map)
{
    8001cec8:	7179                	addi	sp,sp,-48
    8001ceca:	f406                	sd	ra,40(sp)
    8001cecc:	f022                	sd	s0,32(sp)
    8001cece:	1800                	addi	s0,sp,48
    8001ced0:	fca43c23          	sd	a0,-40(s0)
    uint32_t i;
    ListElem *e;

    for (i = 0; i < map->slots; i++) {
    8001ced4:	fe042623          	sw	zero,-20(s0)
    8001ced8:	a8a9                	j	8001cf32 <map_clear+0x6a>
        list_for_each_ascending(map->values[i], e)
    8001ceda:	fd843783          	ld	a5,-40(s0)
    8001cede:	6798                	ld	a4,8(a5)
    8001cee0:	fec46783          	lwu	a5,-20(s0)
    8001cee4:	078e                	slli	a5,a5,0x3
    8001cee6:	97ba                	add	a5,a5,a4
    8001cee8:	639c                	ld	a5,0(a5)
    8001ceea:	853e                	mv	a0,a5
    8001ceec:	e1aff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001cef0:	fea43023          	sd	a0,-32(s0)
    8001cef4:	a819                	j	8001cf0a <map_clear+0x42>
        {
            map_lst_free(e);
    8001cef6:	fe043503          	ld	a0,-32(s0)
    8001cefa:	c3bff0ef          	jal	ra,8001cb34 <map_lst_free>
        list_for_each_ascending(map->values[i], e)
    8001cefe:	fe043503          	ld	a0,-32(s0)
    8001cf02:	e4cff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001cf06:	fea43023          	sd	a0,-32(s0)
    8001cf0a:	fd843783          	ld	a5,-40(s0)
    8001cf0e:	6798                	ld	a4,8(a5)
    8001cf10:	fec46783          	lwu	a5,-20(s0)
    8001cf14:	078e                	slli	a5,a5,0x3
    8001cf16:	97ba                	add	a5,a5,a4
    8001cf18:	639c                	ld	a5,0(a5)
    8001cf1a:	fe043583          	ld	a1,-32(s0)
    8001cf1e:	853e                	mv	a0,a5
    8001cf20:	d58ff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001cf24:	87aa                	mv	a5,a0
    8001cf26:	fbe1                	bnez	a5,8001cef6 <map_clear+0x2e>
    for (i = 0; i < map->slots; i++) {
    8001cf28:	fec42783          	lw	a5,-20(s0)
    8001cf2c:	2785                	addiw	a5,a5,1
    8001cf2e:	fef42623          	sw	a5,-20(s0)
    8001cf32:	fd843783          	ld	a5,-40(s0)
    8001cf36:	4398                	lw	a4,0(a5)
    8001cf38:	fec42783          	lw	a5,-20(s0)
    8001cf3c:	2781                	sext.w	a5,a5
    8001cf3e:	f8e7eee3          	bltu	a5,a4,8001ceda <map_clear+0x12>
        }
    }
    map->size = 0;
    8001cf42:	fd843783          	ld	a5,-40(s0)
    8001cf46:	0007a223          	sw	zero,4(a5)
}
    8001cf4a:	0001                	nop
    8001cf4c:	70a2                	ld	ra,40(sp)
    8001cf4e:	7402                	ld	s0,32(sp)
    8001cf50:	6145                	addi	sp,sp,48
    8001cf52:	8082                	ret

000000008001cf54 <map_free>:

void map_free(Map *map)
{
    8001cf54:	7179                	addi	sp,sp,-48
    8001cf56:	f406                	sd	ra,40(sp)
    8001cf58:	f022                	sd	s0,32(sp)
    8001cf5a:	1800                	addi	s0,sp,48
    8001cf5c:	fca43c23          	sd	a0,-40(s0)
    uint32_t i;
    ListElem *e;

    if (map == NULL) {
    8001cf60:	fd843783          	ld	a5,-40(s0)
    8001cf64:	c3d5                	beqz	a5,8001d008 <map_free+0xb4>
        return;
    }
    for (i = 0; i < map->slots; i++) {
    8001cf66:	fe042623          	sw	zero,-20(s0)
    8001cf6a:	a885                	j	8001cfda <map_free+0x86>
        list_for_each_ascending(map->values[i], e)
    8001cf6c:	fd843783          	ld	a5,-40(s0)
    8001cf70:	6798                	ld	a4,8(a5)
    8001cf72:	fec46783          	lwu	a5,-20(s0)
    8001cf76:	078e                	slli	a5,a5,0x3
    8001cf78:	97ba                	add	a5,a5,a4
    8001cf7a:	639c                	ld	a5,0(a5)
    8001cf7c:	853e                	mv	a0,a5
    8001cf7e:	d88ff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001cf82:	fea43023          	sd	a0,-32(s0)
    8001cf86:	a819                	j	8001cf9c <map_free+0x48>
        {
            map_lst_free(e);
    8001cf88:	fe043503          	ld	a0,-32(s0)
    8001cf8c:	ba9ff0ef          	jal	ra,8001cb34 <map_lst_free>
        list_for_each_ascending(map->values[i], e)
    8001cf90:	fe043503          	ld	a0,-32(s0)
    8001cf94:	dbaff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001cf98:	fea43023          	sd	a0,-32(s0)
    8001cf9c:	fd843783          	ld	a5,-40(s0)
    8001cfa0:	6798                	ld	a4,8(a5)
    8001cfa2:	fec46783          	lwu	a5,-20(s0)
    8001cfa6:	078e                	slli	a5,a5,0x3
    8001cfa8:	97ba                	add	a5,a5,a4
    8001cfaa:	639c                	ld	a5,0(a5)
    8001cfac:	fe043583          	ld	a1,-32(s0)
    8001cfb0:	853e                	mv	a0,a5
    8001cfb2:	cc6ff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001cfb6:	87aa                	mv	a5,a0
    8001cfb8:	fbe1                	bnez	a5,8001cf88 <map_free+0x34>
        }
        list_free(map->values[i]);
    8001cfba:	fd843783          	ld	a5,-40(s0)
    8001cfbe:	6798                	ld	a4,8(a5)
    8001cfc0:	fec46783          	lwu	a5,-20(s0)
    8001cfc4:	078e                	slli	a5,a5,0x3
    8001cfc6:	97ba                	add	a5,a5,a4
    8001cfc8:	639c                	ld	a5,0(a5)
    8001cfca:	853e                	mv	a0,a5
    8001cfcc:	c54ff0ef          	jal	ra,8001c420 <list_free>
    for (i = 0; i < map->slots; i++) {
    8001cfd0:	fec42783          	lw	a5,-20(s0)
    8001cfd4:	2785                	addiw	a5,a5,1
    8001cfd6:	fef42623          	sw	a5,-20(s0)
    8001cfda:	fd843783          	ld	a5,-40(s0)
    8001cfde:	4398                	lw	a4,0(a5)
    8001cfe0:	fec42783          	lw	a5,-20(s0)
    8001cfe4:	2781                	sext.w	a5,a5
    8001cfe6:	f8e7e3e3          	bltu	a5,a4,8001cf6c <map_free+0x18>
    }
    g_kfree(map->values);
    8001cfea:	fd843783          	ld	a5,-40(s0)
    8001cfee:	679c                	ld	a5,8(a5)
    8001cff0:	853e                	mv	a0,a5
    8001cff2:	824ff0ef          	jal	ra,8001c016 <g_kfree>
    map->size = 0;
    8001cff6:	fd843783          	ld	a5,-40(s0)
    8001cffa:	0007a223          	sw	zero,4(a5)
    g_kfree(map);
    8001cffe:	fd843503          	ld	a0,-40(s0)
    8001d002:	814ff0ef          	jal	ra,8001c016 <g_kfree>
    8001d006:	a011                	j	8001d00a <map_free+0xb6>
        return;
    8001d008:	0001                	nop
}
    8001d00a:	70a2                	ld	ra,40(sp)
    8001d00c:	7402                	ld	s0,32(sp)
    8001d00e:	6145                	addi	sp,sp,48
    8001d010:	8082                	ret

000000008001d012 <map_get_keys>:

struct List *map_get_keys(const Map *map) {
    8001d012:	7139                	addi	sp,sp,-64
    8001d014:	fc06                	sd	ra,56(sp)
    8001d016:	f822                	sd	s0,48(sp)
    8001d018:	0080                	addi	s0,sp,64
    8001d01a:	fca43423          	sd	a0,-56(s0)
    uint32_t i;
    ListElem *e;
    struct List *ret = list_new();
    8001d01e:	898ff0ef          	jal	ra,8001c0b6 <list_new>
    8001d022:	fca43c23          	sd	a0,-40(s0)

    for (i = 0;i < map->slots;i++) {
    8001d026:	fe042623          	sw	zero,-20(s0)
    8001d02a:	a885                	j	8001d09a <map_get_keys+0x88>
        list_for_each_ascending(map->values[i], e) {
    8001d02c:	fc843783          	ld	a5,-56(s0)
    8001d030:	6798                	ld	a4,8(a5)
    8001d032:	fec46783          	lwu	a5,-20(s0)
    8001d036:	078e                	slli	a5,a5,0x3
    8001d038:	97ba                	add	a5,a5,a4
    8001d03a:	639c                	ld	a5,0(a5)
    8001d03c:	853e                	mv	a0,a5
    8001d03e:	cc8ff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001d042:	fea43023          	sd	a0,-32(s0)
    8001d046:	a035                	j	8001d072 <map_get_keys+0x60>
            list_add(ret, (uint64_t)strdup(((MapElem *)list_elem_value(e))->key));
    8001d048:	fe043503          	ld	a0,-32(s0)
    8001d04c:	d1aff0ef          	jal	ra,8001c566 <list_elem_value>
    8001d050:	87aa                	mv	a5,a0
    8001d052:	639c                	ld	a5,0(a5)
    8001d054:	853e                	mv	a0,a5
    8001d056:	363000ef          	jal	ra,8001dbb8 <strdup>
    8001d05a:	87aa                	mv	a5,a0
    8001d05c:	85be                	mv	a1,a5
    8001d05e:	fd843503          	ld	a0,-40(s0)
    8001d062:	884ff0ef          	jal	ra,8001c0e6 <list_add>
        list_for_each_ascending(map->values[i], e) {
    8001d066:	fe043503          	ld	a0,-32(s0)
    8001d06a:	ce4ff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001d06e:	fea43023          	sd	a0,-32(s0)
    8001d072:	fc843783          	ld	a5,-56(s0)
    8001d076:	6798                	ld	a4,8(a5)
    8001d078:	fec46783          	lwu	a5,-20(s0)
    8001d07c:	078e                	slli	a5,a5,0x3
    8001d07e:	97ba                	add	a5,a5,a4
    8001d080:	639c                	ld	a5,0(a5)
    8001d082:	fe043583          	ld	a1,-32(s0)
    8001d086:	853e                	mv	a0,a5
    8001d088:	bf0ff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001d08c:	87aa                	mv	a5,a0
    8001d08e:	ffcd                	bnez	a5,8001d048 <map_get_keys+0x36>
    for (i = 0;i < map->slots;i++) {
    8001d090:	fec42783          	lw	a5,-20(s0)
    8001d094:	2785                	addiw	a5,a5,1
    8001d096:	fef42623          	sw	a5,-20(s0)
    8001d09a:	fc843783          	ld	a5,-56(s0)
    8001d09e:	4398                	lw	a4,0(a5)
    8001d0a0:	fec42783          	lw	a5,-20(s0)
    8001d0a4:	2781                	sext.w	a5,a5
    8001d0a6:	f8e7e3e3          	bltu	a5,a4,8001d02c <map_get_keys+0x1a>
        }
    }

    return ret;
    8001d0aa:	fd843783          	ld	a5,-40(s0)
}
    8001d0ae:	853e                	mv	a0,a5
    8001d0b0:	70e2                	ld	ra,56(sp)
    8001d0b2:	7442                	ld	s0,48(sp)
    8001d0b4:	6121                	addi	sp,sp,64
    8001d0b6:	8082                	ret

000000008001d0b8 <map_free_get_keys>:

void map_free_get_keys(List *src) {
    8001d0b8:	7179                	addi	sp,sp,-48
    8001d0ba:	f406                	sd	ra,40(sp)
    8001d0bc:	f022                	sd	s0,32(sp)
    8001d0be:	1800                	addi	s0,sp,48
    8001d0c0:	fca43c23          	sd	a0,-40(s0)
    if (src != NULL) {
    8001d0c4:	fd843783          	ld	a5,-40(s0)
    8001d0c8:	c3b1                	beqz	a5,8001d10c <map_free_get_keys+0x54>
        ListElem *e;
        list_for_each_ascending(src, e) {
    8001d0ca:	fd843503          	ld	a0,-40(s0)
    8001d0ce:	c38ff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001d0d2:	fea43423          	sd	a0,-24(s0)
    8001d0d6:	a839                	j	8001d0f4 <map_free_get_keys+0x3c>
            g_kfree(list_elem_value_ptr(e));
    8001d0d8:	fe843503          	ld	a0,-24(s0)
    8001d0dc:	c8aff0ef          	jal	ra,8001c566 <list_elem_value>
    8001d0e0:	87aa                	mv	a5,a0
    8001d0e2:	853e                	mv	a0,a5
    8001d0e4:	f33fe0ef          	jal	ra,8001c016 <g_kfree>
        list_for_each_ascending(src, e) {
    8001d0e8:	fe843503          	ld	a0,-24(s0)
    8001d0ec:	c62ff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001d0f0:	fea43423          	sd	a0,-24(s0)
    8001d0f4:	fe843583          	ld	a1,-24(s0)
    8001d0f8:	fd843503          	ld	a0,-40(s0)
    8001d0fc:	b7cff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001d100:	87aa                	mv	a5,a0
    8001d102:	fbf9                	bnez	a5,8001d0d8 <map_free_get_keys+0x20>
        }
        list_free(src);
    8001d104:	fd843503          	ld	a0,-40(s0)
    8001d108:	b18ff0ef          	jal	ra,8001c420 <list_free>
    }
}
    8001d10c:	0001                	nop
    8001d10e:	70a2                	ld	ra,40(sp)
    8001d110:	7402                	ld	s0,32(sp)
    8001d112:	6145                	addi	sp,sp,48
    8001d114:	8082                	ret

000000008001d116 <path_skip_slashes>:
#include <list.h>
#include <path.h>
#include <util.h>

const char *path_skip_slashes(const char *path)
{
    8001d116:	1101                	addi	sp,sp,-32
    8001d118:	ec22                	sd	s0,24(sp)
    8001d11a:	1000                	addi	s0,sp,32
    8001d11c:	fea43423          	sd	a0,-24(s0)
    while (*path == '/') {
    8001d120:	a031                	j	8001d12c <path_skip_slashes+0x16>
        path++;
    8001d122:	fe843783          	ld	a5,-24(s0)
    8001d126:	0785                	addi	a5,a5,1
    8001d128:	fef43423          	sd	a5,-24(s0)
    while (*path == '/') {
    8001d12c:	fe843783          	ld	a5,-24(s0)
    8001d130:	0007c783          	lbu	a5,0(a5)
    8001d134:	873e                	mv	a4,a5
    8001d136:	02f00793          	li	a5,47
    8001d13a:	fef704e3          	beq	a4,a5,8001d122 <path_skip_slashes+0xc>
    }
    return path;
    8001d13e:	fe843783          	ld	a5,-24(s0)
}
    8001d142:	853e                	mv	a0,a5
    8001d144:	6462                	ld	s0,24(sp)
    8001d146:	6105                	addi	sp,sp,32
    8001d148:	8082                	ret

000000008001d14a <path_next_slash>:

const char *path_next_slash(const char *path)
{
    8001d14a:	1101                	addi	sp,sp,-32
    8001d14c:	ec22                	sd	s0,24(sp)
    8001d14e:	1000                	addi	s0,sp,32
    8001d150:	fea43423          	sd	a0,-24(s0)
    while (*path != '/' && *path != '\0') {
    8001d154:	a031                	j	8001d160 <path_next_slash+0x16>
        path++;
    8001d156:	fe843783          	ld	a5,-24(s0)
    8001d15a:	0785                	addi	a5,a5,1
    8001d15c:	fef43423          	sd	a5,-24(s0)
    while (*path != '/' && *path != '\0') {
    8001d160:	fe843783          	ld	a5,-24(s0)
    8001d164:	0007c783          	lbu	a5,0(a5)
    8001d168:	873e                	mv	a4,a5
    8001d16a:	02f00793          	li	a5,47
    8001d16e:	00f70763          	beq	a4,a5,8001d17c <path_next_slash+0x32>
    8001d172:	fe843783          	ld	a5,-24(s0)
    8001d176:	0007c783          	lbu	a5,0(a5)
    8001d17a:	fff1                	bnez	a5,8001d156 <path_next_slash+0xc>
    }
    return path;
    8001d17c:	fe843783          	ld	a5,-24(s0)
}
    8001d180:	853e                	mv	a0,a5
    8001d182:	6462                	ld	s0,24(sp)
    8001d184:	6105                	addi	sp,sp,32
    8001d186:	8082                	ret

000000008001d188 <path_file_name>:

const char *path_file_name(const char *path)
{
    8001d188:	7179                	addi	sp,sp,-48
    8001d18a:	f406                	sd	ra,40(sp)
    8001d18c:	f022                	sd	s0,32(sp)
    8001d18e:	1800                	addi	s0,sp,48
    8001d190:	fca43c23          	sd	a0,-40(s0)
    int len = strlen(path);
    8001d194:	fd843503          	ld	a0,-40(s0)
    8001d198:	121000ef          	jal	ra,8001dab8 <strlen>
    8001d19c:	87aa                	mv	a5,a0
    8001d19e:	fef42423          	sw	a5,-24(s0)
    int i;
    for (i = len - 1; path[i] != '/' && i >= 0; i -= 1)
    8001d1a2:	fe842783          	lw	a5,-24(s0)
    8001d1a6:	37fd                	addiw	a5,a5,-1
    8001d1a8:	fef42623          	sw	a5,-20(s0)
    8001d1ac:	a031                	j	8001d1b8 <path_file_name+0x30>
    8001d1ae:	fec42783          	lw	a5,-20(s0)
    8001d1b2:	37fd                	addiw	a5,a5,-1
    8001d1b4:	fef42623          	sw	a5,-20(s0)
    8001d1b8:	fec42783          	lw	a5,-20(s0)
    8001d1bc:	fd843703          	ld	a4,-40(s0)
    8001d1c0:	97ba                	add	a5,a5,a4
    8001d1c2:	0007c783          	lbu	a5,0(a5)
    8001d1c6:	873e                	mv	a4,a5
    8001d1c8:	02f00793          	li	a5,47
    8001d1cc:	00f70763          	beq	a4,a5,8001d1da <path_file_name+0x52>
    8001d1d0:	fec42783          	lw	a5,-20(s0)
    8001d1d4:	2781                	sext.w	a5,a5
    8001d1d6:	fc07dce3          	bgez	a5,8001d1ae <path_file_name+0x26>
        ;
    return path + i + 1;
    8001d1da:	fec42783          	lw	a5,-20(s0)
    8001d1de:	0785                	addi	a5,a5,1
    8001d1e0:	fd843703          	ld	a4,-40(s0)
    8001d1e4:	97ba                	add	a5,a5,a4
}
    8001d1e6:	853e                	mv	a0,a5
    8001d1e8:	70a2                	ld	ra,40(sp)
    8001d1ea:	7402                	ld	s0,32(sp)
    8001d1ec:	6145                	addi	sp,sp,48
    8001d1ee:	8082                	ret

000000008001d1f0 <path_split>:

List *path_split(const char *path)
{
    8001d1f0:	7129                	addi	sp,sp,-320
    8001d1f2:	fe06                	sd	ra,312(sp)
    8001d1f4:	fa22                	sd	s0,304(sp)
    8001d1f6:	0280                	addi	s0,sp,320
    8001d1f8:	eca43423          	sd	a0,-312(s0)
    char name[256];
    char *ptr;
    unsigned int i;
    List *v = list_new();
    8001d1fc:	ebbfe0ef          	jal	ra,8001c0b6 <list_new>
    8001d200:	fea43023          	sd	a0,-32(s0)
    while (*path != '\0') {
    8001d204:	a065                	j	8001d2ac <path_split+0xbc>
        path = path_skip_slashes(path);
    8001d206:	ec843503          	ld	a0,-312(s0)
    8001d20a:	f0dff0ef          	jal	ra,8001d116 <path_skip_slashes>
    8001d20e:	eca43423          	sd	a0,-312(s0)
        for (i = 0; i < (sizeof(name) - 1) && path[i] != '/' && path[i] != '\0'; i += 1) {
    8001d212:	fe042623          	sw	zero,-20(s0)
    8001d216:	a025                	j	8001d23e <path_split+0x4e>
            name[i] = path[i];
    8001d218:	fec46783          	lwu	a5,-20(s0)
    8001d21c:	ec843703          	ld	a4,-312(s0)
    8001d220:	97ba                	add	a5,a5,a4
    8001d222:	0007c703          	lbu	a4,0(a5)
    8001d226:	fec46783          	lwu	a5,-20(s0)
    8001d22a:	ff040693          	addi	a3,s0,-16
    8001d22e:	97b6                	add	a5,a5,a3
    8001d230:	eee78423          	sb	a4,-280(a5)
        for (i = 0; i < (sizeof(name) - 1) && path[i] != '/' && path[i] != '\0'; i += 1) {
    8001d234:	fec42783          	lw	a5,-20(s0)
    8001d238:	2785                	addiw	a5,a5,1
    8001d23a:	fef42623          	sw	a5,-20(s0)
    8001d23e:	fec42783          	lw	a5,-20(s0)
    8001d242:	0007871b          	sext.w	a4,a5
    8001d246:	0fe00793          	li	a5,254
    8001d24a:	02e7e663          	bltu	a5,a4,8001d276 <path_split+0x86>
    8001d24e:	fec46783          	lwu	a5,-20(s0)
    8001d252:	ec843703          	ld	a4,-312(s0)
    8001d256:	97ba                	add	a5,a5,a4
    8001d258:	0007c783          	lbu	a5,0(a5)
    8001d25c:	873e                	mv	a4,a5
    8001d25e:	02f00793          	li	a5,47
    8001d262:	00f70a63          	beq	a4,a5,8001d276 <path_split+0x86>
    8001d266:	fec46783          	lwu	a5,-20(s0)
    8001d26a:	ec843703          	ld	a4,-312(s0)
    8001d26e:	97ba                	add	a5,a5,a4
    8001d270:	0007c783          	lbu	a5,0(a5)
    8001d274:	f3d5                	bnez	a5,8001d218 <path_split+0x28>
        }
        name[i] = '\0';
    8001d276:	fec46783          	lwu	a5,-20(s0)
    8001d27a:	ff040713          	addi	a4,s0,-16
    8001d27e:	97ba                	add	a5,a5,a4
    8001d280:	ee078423          	sb	zero,-280(a5)
        ptr     = strdup(name);
    8001d284:	ed840793          	addi	a5,s0,-296
    8001d288:	853e                	mv	a0,a5
    8001d28a:	12f000ef          	jal	ra,8001dbb8 <strdup>
    8001d28e:	fca43c23          	sd	a0,-40(s0)
        list_add(v, (uint64_t)ptr);
    8001d292:	fd843783          	ld	a5,-40(s0)
    8001d296:	85be                	mv	a1,a5
    8001d298:	fe043503          	ld	a0,-32(s0)
    8001d29c:	e4bfe0ef          	jal	ra,8001c0e6 <list_add>
        path = path_next_slash(path);
    8001d2a0:	ec843503          	ld	a0,-312(s0)
    8001d2a4:	ea7ff0ef          	jal	ra,8001d14a <path_next_slash>
    8001d2a8:	eca43423          	sd	a0,-312(s0)
    while (*path != '\0') {
    8001d2ac:	ec843783          	ld	a5,-312(s0)
    8001d2b0:	0007c783          	lbu	a5,0(a5)
    8001d2b4:	fba9                	bnez	a5,8001d206 <path_split+0x16>
    }
    return v;
    8001d2b6:	fe043783          	ld	a5,-32(s0)
}
    8001d2ba:	853e                	mv	a0,a5
    8001d2bc:	70f2                	ld	ra,312(sp)
    8001d2be:	7452                	ld	s0,304(sp)
    8001d2c0:	6131                	addi	sp,sp,320
    8001d2c2:	8082                	ret

000000008001d2c4 <path_split_free>:

void path_split_free(struct List *l)
{
    8001d2c4:	7179                	addi	sp,sp,-48
    8001d2c6:	f406                	sd	ra,40(sp)
    8001d2c8:	f022                	sd	s0,32(sp)
    8001d2ca:	1800                	addi	s0,sp,48
    8001d2cc:	fca43c23          	sd	a0,-40(s0)
    ListElem *e;
    list_for_each(l, e)
    8001d2d0:	fd843503          	ld	a0,-40(s0)
    8001d2d4:	a32ff0ef          	jal	ra,8001c506 <list_elem_start_ascending>
    8001d2d8:	fea43423          	sd	a0,-24(s0)
    8001d2dc:	a015                	j	8001d300 <path_split_free+0x3c>
    {
        void *ptr = (void *)list_elem_value(e);
    8001d2de:	fe843503          	ld	a0,-24(s0)
    8001d2e2:	a84ff0ef          	jal	ra,8001c566 <list_elem_value>
    8001d2e6:	87aa                	mv	a5,a0
    8001d2e8:	fef43023          	sd	a5,-32(s0)
        g_kfree(ptr);
    8001d2ec:	fe043503          	ld	a0,-32(s0)
    8001d2f0:	d27fe0ef          	jal	ra,8001c016 <g_kfree>
    list_for_each(l, e)
    8001d2f4:	fe843503          	ld	a0,-24(s0)
    8001d2f8:	a56ff0ef          	jal	ra,8001c54e <list_elem_prev>
    8001d2fc:	fea43423          	sd	a0,-24(s0)
    8001d300:	fe843583          	ld	a1,-24(s0)
    8001d304:	fd843503          	ld	a0,-40(s0)
    8001d308:	970ff0ef          	jal	ra,8001c478 <list_elem_valid>
    8001d30c:	87aa                	mv	a5,a0
    8001d30e:	fbe1                	bnez	a5,8001d2de <path_split_free+0x1a>
    }
    list_free(l);
    8001d310:	fd843503          	ld	a0,-40(s0)
    8001d314:	90cff0ef          	jal	ra,8001c420 <list_free>
    g_kfree(l);
    8001d318:	fd843503          	ld	a0,-40(s0)
    8001d31c:	cfbfe0ef          	jal	ra,8001c016 <g_kfree>
}
    8001d320:	0001                	nop
    8001d322:	70a2                	ld	ra,40(sp)
    8001d324:	7402                	ld	s0,32(sp)
    8001d326:	6145                	addi	sp,sp,48
    8001d328:	8082                	ret

000000008001d32a <memset>:
#include <alloc.h>
#include <stdint.h>
#include <util.h>

void *memset(void *dst, char data, int size)
{
    8001d32a:	715d                	addi	sp,sp,-80
    8001d32c:	e4a2                	sd	s0,72(sp)
    8001d32e:	0880                	addi	s0,sp,80
    8001d330:	faa43c23          	sd	a0,-72(s0)
    8001d334:	87ae                	mv	a5,a1
    8001d336:	8732                	mv	a4,a2
    8001d338:	faf40ba3          	sb	a5,-73(s0)
    8001d33c:	87ba                	mv	a5,a4
    8001d33e:	faf42823          	sw	a5,-80(s0)
    int64_t i;
    long *ldst = (long *)dst;
    8001d342:	fb843783          	ld	a5,-72(s0)
    8001d346:	fef43023          	sd	a5,-32(s0)
    char *cdst;
    char l[]              = {data, data, data, data, data, data, data, data};
    8001d34a:	fb744783          	lbu	a5,-73(s0)
    8001d34e:	fcf40423          	sb	a5,-56(s0)
    8001d352:	fb744783          	lbu	a5,-73(s0)
    8001d356:	fcf404a3          	sb	a5,-55(s0)
    8001d35a:	fb744783          	lbu	a5,-73(s0)
    8001d35e:	fcf40523          	sb	a5,-54(s0)
    8001d362:	fb744783          	lbu	a5,-73(s0)
    8001d366:	fcf405a3          	sb	a5,-53(s0)
    8001d36a:	fb744783          	lbu	a5,-73(s0)
    8001d36e:	fcf40623          	sb	a5,-52(s0)
    8001d372:	fb744783          	lbu	a5,-73(s0)
    8001d376:	fcf406a3          	sb	a5,-51(s0)
    8001d37a:	fb744783          	lbu	a5,-73(s0)
    8001d37e:	fcf40723          	sb	a5,-50(s0)
    8001d382:	fb744783          	lbu	a5,-73(s0)
    8001d386:	fcf407a3          	sb	a5,-49(s0)

    int num_8_byte_copies = size / 8;
    8001d38a:	fb042783          	lw	a5,-80(s0)
    8001d38e:	41f7d71b          	sraiw	a4,a5,0x1f
    8001d392:	01d7571b          	srliw	a4,a4,0x1d
    8001d396:	9fb9                	addw	a5,a5,a4
    8001d398:	4037d79b          	sraiw	a5,a5,0x3
    8001d39c:	fcf42a23          	sw	a5,-44(s0)
    int num_1_byte_copies = size % 8;
    8001d3a0:	fb042703          	lw	a4,-80(s0)
    8001d3a4:	41f7579b          	sraiw	a5,a4,0x1f
    8001d3a8:	01d7d79b          	srliw	a5,a5,0x1d
    8001d3ac:	9f3d                	addw	a4,a4,a5
    8001d3ae:	8b1d                	andi	a4,a4,7
    8001d3b0:	40f707bb          	subw	a5,a4,a5
    8001d3b4:	fcf42823          	sw	a5,-48(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    8001d3b8:	fe043423          	sd	zero,-24(s0)
    8001d3bc:	a005                	j	8001d3dc <memset+0xb2>
        *ldst++ = *((long *)l);
    8001d3be:	fc840713          	addi	a4,s0,-56
    8001d3c2:	fe043783          	ld	a5,-32(s0)
    8001d3c6:	00878693          	addi	a3,a5,8
    8001d3ca:	fed43023          	sd	a3,-32(s0)
    8001d3ce:	6318                	ld	a4,0(a4)
    8001d3d0:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    8001d3d2:	fe843783          	ld	a5,-24(s0)
    8001d3d6:	0785                	addi	a5,a5,1
    8001d3d8:	fef43423          	sd	a5,-24(s0)
    8001d3dc:	fd442783          	lw	a5,-44(s0)
    8001d3e0:	fe843703          	ld	a4,-24(s0)
    8001d3e4:	fcf74de3          	blt	a4,a5,8001d3be <memset+0x94>
    }

    cdst = (char *)ldst;
    8001d3e8:	fe043783          	ld	a5,-32(s0)
    8001d3ec:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    8001d3f0:	fe043423          	sd	zero,-24(s0)
    8001d3f4:	a005                	j	8001d414 <memset+0xea>
        *cdst++ = data;
    8001d3f6:	fd843783          	ld	a5,-40(s0)
    8001d3fa:	00178713          	addi	a4,a5,1
    8001d3fe:	fce43c23          	sd	a4,-40(s0)
    8001d402:	fb744703          	lbu	a4,-73(s0)
    8001d406:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    8001d40a:	fe843783          	ld	a5,-24(s0)
    8001d40e:	0785                	addi	a5,a5,1
    8001d410:	fef43423          	sd	a5,-24(s0)
    8001d414:	fd042783          	lw	a5,-48(s0)
    8001d418:	fe843703          	ld	a4,-24(s0)
    8001d41c:	fcf74de3          	blt	a4,a5,8001d3f6 <memset+0xcc>
    }

    return dst;
    8001d420:	fb843783          	ld	a5,-72(s0)
}
    8001d424:	853e                	mv	a0,a5
    8001d426:	6426                	ld	s0,72(sp)
    8001d428:	6161                	addi	sp,sp,80
    8001d42a:	8082                	ret

000000008001d42c <memcpy>:

void *memcpy(void *dst, const void *src, int size)
{
    8001d42c:	711d                	addi	sp,sp,-96
    8001d42e:	eca2                	sd	s0,88(sp)
    8001d430:	1080                	addi	s0,sp,96
    8001d432:	faa43c23          	sd	a0,-72(s0)
    8001d436:	fab43823          	sd	a1,-80(s0)
    8001d43a:	87b2                	mv	a5,a2
    8001d43c:	faf42623          	sw	a5,-84(s0)
    int i;
    char *cdst;
    const char *csrc;
    long *ldst            = (long *)dst;
    8001d440:	fb843783          	ld	a5,-72(s0)
    8001d444:	fcf43823          	sd	a5,-48(s0)
    const long *lsrc      = (long *)src;
    8001d448:	fb043783          	ld	a5,-80(s0)
    8001d44c:	fcf43423          	sd	a5,-56(s0)

    int num_8_byte_copies = size / 8;
    8001d450:	fac42783          	lw	a5,-84(s0)
    8001d454:	41f7d71b          	sraiw	a4,a5,0x1f
    8001d458:	01d7571b          	srliw	a4,a4,0x1d
    8001d45c:	9fb9                	addw	a5,a5,a4
    8001d45e:	4037d79b          	sraiw	a5,a5,0x3
    8001d462:	fcf42223          	sw	a5,-60(s0)
    int num_1_byte_copies = size % 8;
    8001d466:	fac42703          	lw	a4,-84(s0)
    8001d46a:	41f7579b          	sraiw	a5,a4,0x1f
    8001d46e:	01d7d79b          	srliw	a5,a5,0x1d
    8001d472:	9f3d                	addw	a4,a4,a5
    8001d474:	8b1d                	andi	a4,a4,7
    8001d476:	40f707bb          	subw	a5,a4,a5
    8001d47a:	fcf42023          	sw	a5,-64(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    8001d47e:	fe042623          	sw	zero,-20(s0)
    8001d482:	a025                	j	8001d4aa <memcpy+0x7e>
        *ldst++ = *lsrc++;
    8001d484:	fc843703          	ld	a4,-56(s0)
    8001d488:	00870793          	addi	a5,a4,8
    8001d48c:	fcf43423          	sd	a5,-56(s0)
    8001d490:	fd043783          	ld	a5,-48(s0)
    8001d494:	00878693          	addi	a3,a5,8
    8001d498:	fcd43823          	sd	a3,-48(s0)
    8001d49c:	6318                	ld	a4,0(a4)
    8001d49e:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    8001d4a0:	fec42783          	lw	a5,-20(s0)
    8001d4a4:	2785                	addiw	a5,a5,1
    8001d4a6:	fef42623          	sw	a5,-20(s0)
    8001d4aa:	fec42703          	lw	a4,-20(s0)
    8001d4ae:	fc442783          	lw	a5,-60(s0)
    8001d4b2:	2701                	sext.w	a4,a4
    8001d4b4:	2781                	sext.w	a5,a5
    8001d4b6:	fcf747e3          	blt	a4,a5,8001d484 <memcpy+0x58>
    }

    cdst = (char *)ldst;
    8001d4ba:	fd043783          	ld	a5,-48(s0)
    8001d4be:	fef43023          	sd	a5,-32(s0)
    csrc = (char *)lsrc;
    8001d4c2:	fc843783          	ld	a5,-56(s0)
    8001d4c6:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    8001d4ca:	fe042623          	sw	zero,-20(s0)
    8001d4ce:	a035                	j	8001d4fa <memcpy+0xce>
        *cdst++ = *csrc++;
    8001d4d0:	fd843703          	ld	a4,-40(s0)
    8001d4d4:	00170793          	addi	a5,a4,1
    8001d4d8:	fcf43c23          	sd	a5,-40(s0)
    8001d4dc:	fe043783          	ld	a5,-32(s0)
    8001d4e0:	00178693          	addi	a3,a5,1
    8001d4e4:	fed43023          	sd	a3,-32(s0)
    8001d4e8:	00074703          	lbu	a4,0(a4)
    8001d4ec:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    8001d4f0:	fec42783          	lw	a5,-20(s0)
    8001d4f4:	2785                	addiw	a5,a5,1
    8001d4f6:	fef42623          	sw	a5,-20(s0)
    8001d4fa:	fec42703          	lw	a4,-20(s0)
    8001d4fe:	fc042783          	lw	a5,-64(s0)
    8001d502:	2701                	sext.w	a4,a4
    8001d504:	2781                	sext.w	a5,a5
    8001d506:	fcf745e3          	blt	a4,a5,8001d4d0 <memcpy+0xa4>
    }

    return dst;
    8001d50a:	fb843783          	ld	a5,-72(s0)
}
    8001d50e:	853e                	mv	a0,a5
    8001d510:	6466                	ld	s0,88(sp)
    8001d512:	6125                	addi	sp,sp,96
    8001d514:	8082                	ret

000000008001d516 <memmove>:

void *memmove(void *_dst, const void *_src, int n)
{
    8001d516:	7139                	addi	sp,sp,-64
    8001d518:	fc22                	sd	s0,56(sp)
    8001d51a:	0080                	addi	s0,sp,64
    8001d51c:	fca43c23          	sd	a0,-40(s0)
    8001d520:	fcb43823          	sd	a1,-48(s0)
    8001d524:	87b2                	mv	a5,a2
    8001d526:	fcf42623          	sw	a5,-52(s0)
    const char *src = _src;
    8001d52a:	fd043783          	ld	a5,-48(s0)
    8001d52e:	fef43423          	sd	a5,-24(s0)
    char *dst       = _dst;
    8001d532:	fd843783          	ld	a5,-40(s0)
    8001d536:	fef43023          	sd	a5,-32(s0)

    if (n == 0)
    8001d53a:	fcc42783          	lw	a5,-52(s0)
    8001d53e:	2781                	sext.w	a5,a5
    8001d540:	e781                	bnez	a5,8001d548 <memmove+0x32>
        return _dst;
    8001d542:	fd843783          	ld	a5,-40(s0)
    8001d546:	a845                	j	8001d5f6 <memmove+0xe0>

    if (src < dst && src + n > dst) {
    8001d548:	fe843703          	ld	a4,-24(s0)
    8001d54c:	fe043783          	ld	a5,-32(s0)
    8001d550:	08f77c63          	bgeu	a4,a5,8001d5e8 <memmove+0xd2>
    8001d554:	fcc42783          	lw	a5,-52(s0)
    8001d558:	fe843703          	ld	a4,-24(s0)
    8001d55c:	97ba                	add	a5,a5,a4
    8001d55e:	fe043703          	ld	a4,-32(s0)
    8001d562:	08f77363          	bgeu	a4,a5,8001d5e8 <memmove+0xd2>
        src += n;
    8001d566:	fcc42783          	lw	a5,-52(s0)
    8001d56a:	fe843703          	ld	a4,-24(s0)
    8001d56e:	97ba                	add	a5,a5,a4
    8001d570:	fef43423          	sd	a5,-24(s0)
        dst += n;
    8001d574:	fcc42783          	lw	a5,-52(s0)
    8001d578:	fe043703          	ld	a4,-32(s0)
    8001d57c:	97ba                	add	a5,a5,a4
    8001d57e:	fef43023          	sd	a5,-32(s0)
        for (; n > 0; n -= 1) {
    8001d582:	a805                	j	8001d5b2 <memmove+0x9c>
            *--dst = *--src;
    8001d584:	fe843783          	ld	a5,-24(s0)
    8001d588:	17fd                	addi	a5,a5,-1
    8001d58a:	fef43423          	sd	a5,-24(s0)
    8001d58e:	fe043783          	ld	a5,-32(s0)
    8001d592:	17fd                	addi	a5,a5,-1
    8001d594:	fef43023          	sd	a5,-32(s0)
    8001d598:	fe843783          	ld	a5,-24(s0)
    8001d59c:	0007c703          	lbu	a4,0(a5)
    8001d5a0:	fe043783          	ld	a5,-32(s0)
    8001d5a4:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    8001d5a8:	fcc42783          	lw	a5,-52(s0)
    8001d5ac:	37fd                	addiw	a5,a5,-1
    8001d5ae:	fcf42623          	sw	a5,-52(s0)
    8001d5b2:	fcc42783          	lw	a5,-52(s0)
    8001d5b6:	2781                	sext.w	a5,a5
    8001d5b8:	fcf046e3          	bgtz	a5,8001d584 <memmove+0x6e>
    if (src < dst && src + n > dst) {
    8001d5bc:	a81d                	j	8001d5f2 <memmove+0xdc>
        }
    }
    else {
        for (; n > 0; n -= 1) {
            *dst++ = *src++;
    8001d5be:	fe843703          	ld	a4,-24(s0)
    8001d5c2:	00170793          	addi	a5,a4,1
    8001d5c6:	fef43423          	sd	a5,-24(s0)
    8001d5ca:	fe043783          	ld	a5,-32(s0)
    8001d5ce:	00178693          	addi	a3,a5,1
    8001d5d2:	fed43023          	sd	a3,-32(s0)
    8001d5d6:	00074703          	lbu	a4,0(a4)
    8001d5da:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    8001d5de:	fcc42783          	lw	a5,-52(s0)
    8001d5e2:	37fd                	addiw	a5,a5,-1
    8001d5e4:	fcf42623          	sw	a5,-52(s0)
    8001d5e8:	fcc42783          	lw	a5,-52(s0)
    8001d5ec:	2781                	sext.w	a5,a5
    8001d5ee:	fcf048e3          	bgtz	a5,8001d5be <memmove+0xa8>
        }
    }

    return _dst;
    8001d5f2:	fd843783          	ld	a5,-40(s0)
}
    8001d5f6:	853e                	mv	a0,a5
    8001d5f8:	7462                	ld	s0,56(sp)
    8001d5fa:	6121                	addi	sp,sp,64
    8001d5fc:	8082                	ret

000000008001d5fe <memcmp>:

int memcmp(const void *haystack, const void *needle, int size)
{
    8001d5fe:	715d                	addi	sp,sp,-80
    8001d600:	e4a2                	sd	s0,72(sp)
    8001d602:	0880                	addi	s0,sp,80
    8001d604:	fca43423          	sd	a0,-56(s0)
    8001d608:	fcb43023          	sd	a1,-64(s0)
    8001d60c:	87b2                	mv	a5,a2
    8001d60e:	faf42e23          	sw	a5,-68(s0)
    const char *hay  = (char *)haystack;
    8001d612:	fc843783          	ld	a5,-56(s0)
    8001d616:	fef43023          	sd	a5,-32(s0)
    const char *need = (char *)needle;
    8001d61a:	fc043783          	ld	a5,-64(s0)
    8001d61e:	fcf43c23          	sd	a5,-40(s0)
    int i;

    for (i = 0; i < (size - 1); i++) {
    8001d622:	fe042623          	sw	zero,-20(s0)
    8001d626:	a8a1                	j	8001d67e <memcmp+0x80>
        if (hay[i] != need[i]) {
    8001d628:	fec42783          	lw	a5,-20(s0)
    8001d62c:	fe043703          	ld	a4,-32(s0)
    8001d630:	97ba                	add	a5,a5,a4
    8001d632:	0007c683          	lbu	a3,0(a5)
    8001d636:	fec42783          	lw	a5,-20(s0)
    8001d63a:	fd843703          	ld	a4,-40(s0)
    8001d63e:	97ba                	add	a5,a5,a4
    8001d640:	0007c783          	lbu	a5,0(a5)
    8001d644:	8736                	mv	a4,a3
    8001d646:	02f70763          	beq	a4,a5,8001d674 <memcmp+0x76>
            return hay[i] - need[i];
    8001d64a:	fec42783          	lw	a5,-20(s0)
    8001d64e:	fe043703          	ld	a4,-32(s0)
    8001d652:	97ba                	add	a5,a5,a4
    8001d654:	0007c783          	lbu	a5,0(a5)
    8001d658:	0007871b          	sext.w	a4,a5
    8001d65c:	fec42783          	lw	a5,-20(s0)
    8001d660:	fd843683          	ld	a3,-40(s0)
    8001d664:	97b6                	add	a5,a5,a3
    8001d666:	0007c783          	lbu	a5,0(a5)
    8001d66a:	2781                	sext.w	a5,a5
    8001d66c:	40f707bb          	subw	a5,a4,a5
    8001d670:	2781                	sext.w	a5,a5
    8001d672:	a0a1                	j	8001d6ba <memcmp+0xbc>
    for (i = 0; i < (size - 1); i++) {
    8001d674:	fec42783          	lw	a5,-20(s0)
    8001d678:	2785                	addiw	a5,a5,1
    8001d67a:	fef42623          	sw	a5,-20(s0)
    8001d67e:	fbc42783          	lw	a5,-68(s0)
    8001d682:	37fd                	addiw	a5,a5,-1
    8001d684:	0007871b          	sext.w	a4,a5
    8001d688:	fec42783          	lw	a5,-20(s0)
    8001d68c:	2781                	sext.w	a5,a5
    8001d68e:	f8e7cde3          	blt	a5,a4,8001d628 <memcmp+0x2a>
        }
    }

    return hay[i] - need[i];
    8001d692:	fec42783          	lw	a5,-20(s0)
    8001d696:	fe043703          	ld	a4,-32(s0)
    8001d69a:	97ba                	add	a5,a5,a4
    8001d69c:	0007c783          	lbu	a5,0(a5)
    8001d6a0:	0007871b          	sext.w	a4,a5
    8001d6a4:	fec42783          	lw	a5,-20(s0)
    8001d6a8:	fd843683          	ld	a3,-40(s0)
    8001d6ac:	97b6                	add	a5,a5,a3
    8001d6ae:	0007c783          	lbu	a5,0(a5)
    8001d6b2:	2781                	sext.w	a5,a5
    8001d6b4:	40f707bb          	subw	a5,a4,a5
    8001d6b8:	2781                	sext.w	a5,a5
}
    8001d6ba:	853e                	mv	a0,a5
    8001d6bc:	6426                	ld	s0,72(sp)
    8001d6be:	6161                	addi	sp,sp,80
    8001d6c0:	8082                	ret

000000008001d6c2 <atoi>:

int atoi(const char *st)
{
    8001d6c2:	7139                	addi	sp,sp,-64
    8001d6c4:	fc22                	sd	s0,56(sp)
    8001d6c6:	0080                	addi	s0,sp,64
    8001d6c8:	fca43423          	sd	a0,-56(s0)
    int r = 0;
    8001d6cc:	fe042623          	sw	zero,-20(s0)
    int p = 1;
    8001d6d0:	4785                	li	a5,1
    8001d6d2:	fef42423          	sw	a5,-24(s0)
    int i;
    int l = 0;
    8001d6d6:	fe042023          	sw	zero,-32(s0)
    int n = 0;
    8001d6da:	fc042e23          	sw	zero,-36(s0)

    if (st[0] == '-') {
    8001d6de:	fc843783          	ld	a5,-56(s0)
    8001d6e2:	0007c783          	lbu	a5,0(a5)
    8001d6e6:	873e                	mv	a4,a5
    8001d6e8:	02d00793          	li	a5,45
    8001d6ec:	02f71063          	bne	a4,a5,8001d70c <atoi+0x4a>
        st++;
    8001d6f0:	fc843783          	ld	a5,-56(s0)
    8001d6f4:	0785                	addi	a5,a5,1
    8001d6f6:	fcf43423          	sd	a5,-56(s0)
        n = 1;
    8001d6fa:	4785                	li	a5,1
    8001d6fc:	fcf42e23          	sw	a5,-36(s0)
    }

    while (st[l] >= '0' && st[l] <= '9')
    8001d700:	a031                	j	8001d70c <atoi+0x4a>
        l++;
    8001d702:	fe042783          	lw	a5,-32(s0)
    8001d706:	2785                	addiw	a5,a5,1
    8001d708:	fef42023          	sw	a5,-32(s0)
    while (st[l] >= '0' && st[l] <= '9')
    8001d70c:	fe042783          	lw	a5,-32(s0)
    8001d710:	fc843703          	ld	a4,-56(s0)
    8001d714:	97ba                	add	a5,a5,a4
    8001d716:	0007c783          	lbu	a5,0(a5)
    8001d71a:	873e                	mv	a4,a5
    8001d71c:	02f00793          	li	a5,47
    8001d720:	00e7fe63          	bgeu	a5,a4,8001d73c <atoi+0x7a>
    8001d724:	fe042783          	lw	a5,-32(s0)
    8001d728:	fc843703          	ld	a4,-56(s0)
    8001d72c:	97ba                	add	a5,a5,a4
    8001d72e:	0007c783          	lbu	a5,0(a5)
    8001d732:	873e                	mv	a4,a5
    8001d734:	03900793          	li	a5,57
    8001d738:	fce7f5e3          	bgeu	a5,a4,8001d702 <atoi+0x40>

    for (i = l - 1; i >= 0; i--) {
    8001d73c:	fe042783          	lw	a5,-32(s0)
    8001d740:	37fd                	addiw	a5,a5,-1
    8001d742:	fef42223          	sw	a5,-28(s0)
    8001d746:	a0a9                	j	8001d790 <atoi+0xce>
        r += p * (st[i] - '0');
    8001d748:	fe442783          	lw	a5,-28(s0)
    8001d74c:	fc843703          	ld	a4,-56(s0)
    8001d750:	97ba                	add	a5,a5,a4
    8001d752:	0007c783          	lbu	a5,0(a5)
    8001d756:	2781                	sext.w	a5,a5
    8001d758:	fd07879b          	addiw	a5,a5,-48
    8001d75c:	2781                	sext.w	a5,a5
    8001d75e:	fe842703          	lw	a4,-24(s0)
    8001d762:	02f707bb          	mulw	a5,a4,a5
    8001d766:	2781                	sext.w	a5,a5
    8001d768:	fec42703          	lw	a4,-20(s0)
    8001d76c:	9fb9                	addw	a5,a5,a4
    8001d76e:	fef42623          	sw	a5,-20(s0)
        p *= 10;
    8001d772:	fe842703          	lw	a4,-24(s0)
    8001d776:	87ba                	mv	a5,a4
    8001d778:	0027979b          	slliw	a5,a5,0x2
    8001d77c:	9fb9                	addw	a5,a5,a4
    8001d77e:	0017979b          	slliw	a5,a5,0x1
    8001d782:	fef42423          	sw	a5,-24(s0)
    for (i = l - 1; i >= 0; i--) {
    8001d786:	fe442783          	lw	a5,-28(s0)
    8001d78a:	37fd                	addiw	a5,a5,-1
    8001d78c:	fef42223          	sw	a5,-28(s0)
    8001d790:	fe442783          	lw	a5,-28(s0)
    8001d794:	2781                	sext.w	a5,a5
    8001d796:	fa07d9e3          	bgez	a5,8001d748 <atoi+0x86>
    }

    return (n ? -r : r);
    8001d79a:	fdc42783          	lw	a5,-36(s0)
    8001d79e:	2781                	sext.w	a5,a5
    8001d7a0:	c799                	beqz	a5,8001d7ae <atoi+0xec>
    8001d7a2:	fec42783          	lw	a5,-20(s0)
    8001d7a6:	40f007bb          	negw	a5,a5
    8001d7aa:	2781                	sext.w	a5,a5
    8001d7ac:	a019                	j	8001d7b2 <atoi+0xf0>
    8001d7ae:	fec42783          	lw	a5,-20(s0)
}
    8001d7b2:	853e                	mv	a0,a5
    8001d7b4:	7462                	ld	s0,56(sp)
    8001d7b6:	6121                	addi	sp,sp,64
    8001d7b8:	8082                	ret

000000008001d7ba <strcmp>:

int strcmp(const char *l, const char *r)
{
    8001d7ba:	7139                	addi	sp,sp,-64
    8001d7bc:	fc22                	sd	s0,56(sp)
    8001d7be:	0080                	addi	s0,sp,64
    8001d7c0:	fca43423          	sd	a0,-56(s0)
    8001d7c4:	fcb43023          	sd	a1,-64(s0)
    const unsigned char *s1 = (const unsigned char *)l;
    8001d7c8:	fc843783          	ld	a5,-56(s0)
    8001d7cc:	fef43423          	sd	a5,-24(s0)
    const unsigned char *s2 = (const unsigned char *)r;
    8001d7d0:	fc043783          	ld	a5,-64(s0)
    8001d7d4:	fef43023          	sd	a5,-32(s0)
    unsigned int c1, c2;

    do {
        c1 = (unsigned char)*s1++;
    8001d7d8:	fe843783          	ld	a5,-24(s0)
    8001d7dc:	00178713          	addi	a4,a5,1
    8001d7e0:	fee43423          	sd	a4,-24(s0)
    8001d7e4:	0007c783          	lbu	a5,0(a5)
    8001d7e8:	fcf42e23          	sw	a5,-36(s0)
        c2 = (unsigned char)*s2++;
    8001d7ec:	fe043783          	ld	a5,-32(s0)
    8001d7f0:	00178713          	addi	a4,a5,1
    8001d7f4:	fee43023          	sd	a4,-32(s0)
    8001d7f8:	0007c783          	lbu	a5,0(a5)
    8001d7fc:	fcf42c23          	sw	a5,-40(s0)
        if (c1 == '\0')
    8001d800:	fdc42783          	lw	a5,-36(s0)
    8001d804:	2781                	sext.w	a5,a5
    8001d806:	eb91                	bnez	a5,8001d81a <strcmp+0x60>
            return c1 - c2;
    8001d808:	fdc42703          	lw	a4,-36(s0)
    8001d80c:	fd842783          	lw	a5,-40(s0)
    8001d810:	40f707bb          	subw	a5,a4,a5
    8001d814:	2781                	sext.w	a5,a5
    8001d816:	2781                	sext.w	a5,a5
    8001d818:	a00d                	j	8001d83a <strcmp+0x80>
    } while (c1 == c2);
    8001d81a:	fdc42703          	lw	a4,-36(s0)
    8001d81e:	fd842783          	lw	a5,-40(s0)
    8001d822:	2701                	sext.w	a4,a4
    8001d824:	2781                	sext.w	a5,a5
    8001d826:	faf709e3          	beq	a4,a5,8001d7d8 <strcmp+0x1e>

    return c1 - c2;
    8001d82a:	fdc42703          	lw	a4,-36(s0)
    8001d82e:	fd842783          	lw	a5,-40(s0)
    8001d832:	40f707bb          	subw	a5,a4,a5
    8001d836:	2781                	sext.w	a5,a5
    8001d838:	2781                	sext.w	a5,a5
}
    8001d83a:	853e                	mv	a0,a5
    8001d83c:	7462                	ld	s0,56(sp)
    8001d83e:	6121                	addi	sp,sp,64
    8001d840:	8082                	ret

000000008001d842 <strncmp>:

int strncmp(const char *left, const char *right, int n)
{
    8001d842:	7139                	addi	sp,sp,-64
    8001d844:	fc22                	sd	s0,56(sp)
    8001d846:	0080                	addi	s0,sp,64
    8001d848:	fca43c23          	sd	a0,-40(s0)
    8001d84c:	fcb43823          	sd	a1,-48(s0)
    8001d850:	87b2                	mv	a5,a2
    8001d852:	fcf42623          	sw	a5,-52(s0)
    unsigned int c1 = '\0';
    8001d856:	fe042623          	sw	zero,-20(s0)
    unsigned int c2 = '\0';
    8001d85a:	fe042423          	sw	zero,-24(s0)

    if (n >= 4) {
    8001d85e:	fcc42783          	lw	a5,-52(s0)
    8001d862:	0007871b          	sext.w	a4,a5
    8001d866:	478d                	li	a5,3
    8001d868:	1ce7da63          	bge	a5,a4,8001da3c <strncmp+0x1fa>
        int n4 = n >> 2;
    8001d86c:	fcc42783          	lw	a5,-52(s0)
    8001d870:	4027d79b          	sraiw	a5,a5,0x2
    8001d874:	fef42223          	sw	a5,-28(s0)
        do {
            c1 = (unsigned char)*left++;
    8001d878:	fd843783          	ld	a5,-40(s0)
    8001d87c:	00178713          	addi	a4,a5,1
    8001d880:	fce43c23          	sd	a4,-40(s0)
    8001d884:	0007c783          	lbu	a5,0(a5)
    8001d888:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8001d88c:	fd043783          	ld	a5,-48(s0)
    8001d890:	00178713          	addi	a4,a5,1
    8001d894:	fce43823          	sd	a4,-48(s0)
    8001d898:	0007c783          	lbu	a5,0(a5)
    8001d89c:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001d8a0:	fec42783          	lw	a5,-20(s0)
    8001d8a4:	2781                	sext.w	a5,a5
    8001d8a6:	cb89                	beqz	a5,8001d8b8 <strncmp+0x76>
    8001d8a8:	fec42703          	lw	a4,-20(s0)
    8001d8ac:	fe842783          	lw	a5,-24(s0)
    8001d8b0:	2701                	sext.w	a4,a4
    8001d8b2:	2781                	sext.w	a5,a5
    8001d8b4:	00f70b63          	beq	a4,a5,8001d8ca <strncmp+0x88>
                return c1 - c2;
    8001d8b8:	fec42703          	lw	a4,-20(s0)
    8001d8bc:	fe842783          	lw	a5,-24(s0)
    8001d8c0:	40f707bb          	subw	a5,a4,a5
    8001d8c4:	2781                	sext.w	a5,a5
    8001d8c6:	2781                	sext.w	a5,a5
    8001d8c8:	a279                	j	8001da56 <strncmp+0x214>
            }

            c1 = (unsigned char)*left++;
    8001d8ca:	fd843783          	ld	a5,-40(s0)
    8001d8ce:	00178713          	addi	a4,a5,1
    8001d8d2:	fce43c23          	sd	a4,-40(s0)
    8001d8d6:	0007c783          	lbu	a5,0(a5)
    8001d8da:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8001d8de:	fd043783          	ld	a5,-48(s0)
    8001d8e2:	00178713          	addi	a4,a5,1
    8001d8e6:	fce43823          	sd	a4,-48(s0)
    8001d8ea:	0007c783          	lbu	a5,0(a5)
    8001d8ee:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001d8f2:	fec42783          	lw	a5,-20(s0)
    8001d8f6:	2781                	sext.w	a5,a5
    8001d8f8:	cb89                	beqz	a5,8001d90a <strncmp+0xc8>
    8001d8fa:	fec42703          	lw	a4,-20(s0)
    8001d8fe:	fe842783          	lw	a5,-24(s0)
    8001d902:	2701                	sext.w	a4,a4
    8001d904:	2781                	sext.w	a5,a5
    8001d906:	00f70b63          	beq	a4,a5,8001d91c <strncmp+0xda>
                return c1 - c2;
    8001d90a:	fec42703          	lw	a4,-20(s0)
    8001d90e:	fe842783          	lw	a5,-24(s0)
    8001d912:	40f707bb          	subw	a5,a4,a5
    8001d916:	2781                	sext.w	a5,a5
    8001d918:	2781                	sext.w	a5,a5
    8001d91a:	aa35                	j	8001da56 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    8001d91c:	fd843783          	ld	a5,-40(s0)
    8001d920:	00178713          	addi	a4,a5,1
    8001d924:	fce43c23          	sd	a4,-40(s0)
    8001d928:	0007c783          	lbu	a5,0(a5)
    8001d92c:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8001d930:	fd043783          	ld	a5,-48(s0)
    8001d934:	00178713          	addi	a4,a5,1
    8001d938:	fce43823          	sd	a4,-48(s0)
    8001d93c:	0007c783          	lbu	a5,0(a5)
    8001d940:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001d944:	fec42783          	lw	a5,-20(s0)
    8001d948:	2781                	sext.w	a5,a5
    8001d94a:	cb89                	beqz	a5,8001d95c <strncmp+0x11a>
    8001d94c:	fec42703          	lw	a4,-20(s0)
    8001d950:	fe842783          	lw	a5,-24(s0)
    8001d954:	2701                	sext.w	a4,a4
    8001d956:	2781                	sext.w	a5,a5
    8001d958:	00f70b63          	beq	a4,a5,8001d96e <strncmp+0x12c>
                return c1 - c2;
    8001d95c:	fec42703          	lw	a4,-20(s0)
    8001d960:	fe842783          	lw	a5,-24(s0)
    8001d964:	40f707bb          	subw	a5,a4,a5
    8001d968:	2781                	sext.w	a5,a5
    8001d96a:	2781                	sext.w	a5,a5
    8001d96c:	a0ed                	j	8001da56 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    8001d96e:	fd843783          	ld	a5,-40(s0)
    8001d972:	00178713          	addi	a4,a5,1
    8001d976:	fce43c23          	sd	a4,-40(s0)
    8001d97a:	0007c783          	lbu	a5,0(a5)
    8001d97e:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8001d982:	fd043783          	ld	a5,-48(s0)
    8001d986:	00178713          	addi	a4,a5,1
    8001d98a:	fce43823          	sd	a4,-48(s0)
    8001d98e:	0007c783          	lbu	a5,0(a5)
    8001d992:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001d996:	fec42783          	lw	a5,-20(s0)
    8001d99a:	2781                	sext.w	a5,a5
    8001d99c:	cb89                	beqz	a5,8001d9ae <strncmp+0x16c>
    8001d99e:	fec42703          	lw	a4,-20(s0)
    8001d9a2:	fe842783          	lw	a5,-24(s0)
    8001d9a6:	2701                	sext.w	a4,a4
    8001d9a8:	2781                	sext.w	a5,a5
    8001d9aa:	00f70b63          	beq	a4,a5,8001d9c0 <strncmp+0x17e>
                return c1 - c2;
    8001d9ae:	fec42703          	lw	a4,-20(s0)
    8001d9b2:	fe842783          	lw	a5,-24(s0)
    8001d9b6:	40f707bb          	subw	a5,a4,a5
    8001d9ba:	2781                	sext.w	a5,a5
    8001d9bc:	2781                	sext.w	a5,a5
    8001d9be:	a861                	j	8001da56 <strncmp+0x214>
            }
        } while (--n4 > 0);
    8001d9c0:	fe442783          	lw	a5,-28(s0)
    8001d9c4:	37fd                	addiw	a5,a5,-1
    8001d9c6:	fef42223          	sw	a5,-28(s0)
    8001d9ca:	fe442783          	lw	a5,-28(s0)
    8001d9ce:	2781                	sext.w	a5,a5
    8001d9d0:	eaf044e3          	bgtz	a5,8001d878 <strncmp+0x36>
        n &= 3;
    8001d9d4:	fcc42783          	lw	a5,-52(s0)
    8001d9d8:	8b8d                	andi	a5,a5,3
    8001d9da:	fcf42623          	sw	a5,-52(s0)
    }

    while (n > 0) {
    8001d9de:	a8b9                	j	8001da3c <strncmp+0x1fa>
        c1 = (unsigned char)*left++;
    8001d9e0:	fd843783          	ld	a5,-40(s0)
    8001d9e4:	00178713          	addi	a4,a5,1
    8001d9e8:	fce43c23          	sd	a4,-40(s0)
    8001d9ec:	0007c783          	lbu	a5,0(a5)
    8001d9f0:	fef42623          	sw	a5,-20(s0)
        c2 = (unsigned char)*right++;
    8001d9f4:	fd043783          	ld	a5,-48(s0)
    8001d9f8:	00178713          	addi	a4,a5,1
    8001d9fc:	fce43823          	sd	a4,-48(s0)
    8001da00:	0007c783          	lbu	a5,0(a5)
    8001da04:	fef42423          	sw	a5,-24(s0)
        if (c1 == '\0' || c1 != c2)
    8001da08:	fec42783          	lw	a5,-20(s0)
    8001da0c:	2781                	sext.w	a5,a5
    8001da0e:	cb89                	beqz	a5,8001da20 <strncmp+0x1de>
    8001da10:	fec42703          	lw	a4,-20(s0)
    8001da14:	fe842783          	lw	a5,-24(s0)
    8001da18:	2701                	sext.w	a4,a4
    8001da1a:	2781                	sext.w	a5,a5
    8001da1c:	00f70b63          	beq	a4,a5,8001da32 <strncmp+0x1f0>
            return c1 - c2;
    8001da20:	fec42703          	lw	a4,-20(s0)
    8001da24:	fe842783          	lw	a5,-24(s0)
    8001da28:	40f707bb          	subw	a5,a4,a5
    8001da2c:	2781                	sext.w	a5,a5
    8001da2e:	2781                	sext.w	a5,a5
    8001da30:	a01d                	j	8001da56 <strncmp+0x214>
        n--;
    8001da32:	fcc42783          	lw	a5,-52(s0)
    8001da36:	37fd                	addiw	a5,a5,-1
    8001da38:	fcf42623          	sw	a5,-52(s0)
    while (n > 0) {
    8001da3c:	fcc42783          	lw	a5,-52(s0)
    8001da40:	2781                	sext.w	a5,a5
    8001da42:	f8f04fe3          	bgtz	a5,8001d9e0 <strncmp+0x19e>
    }

    return c1 - c2;
    8001da46:	fec42703          	lw	a4,-20(s0)
    8001da4a:	fe842783          	lw	a5,-24(s0)
    8001da4e:	40f707bb          	subw	a5,a4,a5
    8001da52:	2781                	sext.w	a5,a5
    8001da54:	2781                	sext.w	a5,a5
}
    8001da56:	853e                	mv	a0,a5
    8001da58:	7462                	ld	s0,56(sp)
    8001da5a:	6121                	addi	sp,sp,64
    8001da5c:	8082                	ret

000000008001da5e <strfindchr>:

int strfindchr(const char *r, char t)
{
    8001da5e:	7179                	addi	sp,sp,-48
    8001da60:	f422                	sd	s0,40(sp)
    8001da62:	1800                	addi	s0,sp,48
    8001da64:	fca43c23          	sd	a0,-40(s0)
    8001da68:	87ae                	mv	a5,a1
    8001da6a:	fcf40ba3          	sb	a5,-41(s0)
    int i = 0;
    8001da6e:	fe042623          	sw	zero,-20(s0)
    while (r[i] != t) {
    8001da72:	a005                	j	8001da92 <strfindchr+0x34>
        if (r[i] == '\0') {
    8001da74:	fec42783          	lw	a5,-20(s0)
    8001da78:	fd843703          	ld	a4,-40(s0)
    8001da7c:	97ba                	add	a5,a5,a4
    8001da7e:	0007c783          	lbu	a5,0(a5)
    8001da82:	e399                	bnez	a5,8001da88 <strfindchr+0x2a>
            return -1;
    8001da84:	57fd                	li	a5,-1
    8001da86:	a02d                	j	8001dab0 <strfindchr+0x52>
        }
        i++;
    8001da88:	fec42783          	lw	a5,-20(s0)
    8001da8c:	2785                	addiw	a5,a5,1
    8001da8e:	fef42623          	sw	a5,-20(s0)
    while (r[i] != t) {
    8001da92:	fec42783          	lw	a5,-20(s0)
    8001da96:	fd843703          	ld	a4,-40(s0)
    8001da9a:	97ba                	add	a5,a5,a4
    8001da9c:	0007c703          	lbu	a4,0(a5)
    8001daa0:	fd744783          	lbu	a5,-41(s0)
    8001daa4:	0ff7f793          	andi	a5,a5,255
    8001daa8:	fce796e3          	bne	a5,a4,8001da74 <strfindchr+0x16>
    }
    return i;
    8001daac:	fec42783          	lw	a5,-20(s0)
}
    8001dab0:	853e                	mv	a0,a5
    8001dab2:	7422                	ld	s0,40(sp)
    8001dab4:	6145                	addi	sp,sp,48
    8001dab6:	8082                	ret

000000008001dab8 <strlen>:

int strlen(const char *s)
{
    8001dab8:	7179                	addi	sp,sp,-48
    8001daba:	f422                	sd	s0,40(sp)
    8001dabc:	1800                	addi	s0,sp,48
    8001dabe:	fca43c23          	sd	a0,-40(s0)
    int len = 0;
    8001dac2:	fe042623          	sw	zero,-20(s0)
    while (s[len] && ++len)
    8001dac6:	0001                	nop
    8001dac8:	fec42783          	lw	a5,-20(s0)
    8001dacc:	fd843703          	ld	a4,-40(s0)
    8001dad0:	97ba                	add	a5,a5,a4
    8001dad2:	0007c783          	lbu	a5,0(a5)
    8001dad6:	cb91                	beqz	a5,8001daea <strlen+0x32>
    8001dad8:	fec42783          	lw	a5,-20(s0)
    8001dadc:	2785                	addiw	a5,a5,1
    8001dade:	fef42623          	sw	a5,-20(s0)
    8001dae2:	fec42783          	lw	a5,-20(s0)
    8001dae6:	2781                	sext.w	a5,a5
    8001dae8:	f3e5                	bnez	a5,8001dac8 <strlen+0x10>
        ;
    return len;
    8001daea:	fec42783          	lw	a5,-20(s0)
}
    8001daee:	853e                	mv	a0,a5
    8001daf0:	7422                	ld	s0,40(sp)
    8001daf2:	6145                	addi	sp,sp,48
    8001daf4:	8082                	ret

000000008001daf6 <strcpy>:

char *strcpy(char *dest, const char *s)
{
    8001daf6:	7179                	addi	sp,sp,-48
    8001daf8:	f422                	sd	s0,40(sp)
    8001dafa:	1800                	addi	s0,sp,48
    8001dafc:	fca43c23          	sd	a0,-40(s0)
    8001db00:	fcb43823          	sd	a1,-48(s0)
    char *o = dest;
    8001db04:	fd843783          	ld	a5,-40(s0)
    8001db08:	fef43423          	sd	a5,-24(s0)
    while (*s) {
    8001db0c:	a00d                	j	8001db2e <strcpy+0x38>
        *dest++ = *s++;
    8001db0e:	fd043703          	ld	a4,-48(s0)
    8001db12:	00170793          	addi	a5,a4,1
    8001db16:	fcf43823          	sd	a5,-48(s0)
    8001db1a:	fd843783          	ld	a5,-40(s0)
    8001db1e:	00178693          	addi	a3,a5,1
    8001db22:	fcd43c23          	sd	a3,-40(s0)
    8001db26:	00074703          	lbu	a4,0(a4)
    8001db2a:	00e78023          	sb	a4,0(a5)
    while (*s) {
    8001db2e:	fd043783          	ld	a5,-48(s0)
    8001db32:	0007c783          	lbu	a5,0(a5)
    8001db36:	ffe1                	bnez	a5,8001db0e <strcpy+0x18>
    }
    *dest = '\0';
    8001db38:	fd843783          	ld	a5,-40(s0)
    8001db3c:	00078023          	sb	zero,0(a5)
    return o;
    8001db40:	fe843783          	ld	a5,-24(s0)
}
    8001db44:	853e                	mv	a0,a5
    8001db46:	7422                	ld	s0,40(sp)
    8001db48:	6145                	addi	sp,sp,48
    8001db4a:	8082                	ret

000000008001db4c <strncpy>:

char *strncpy(char *dest, const char *s, int n)
{
    8001db4c:	7139                	addi	sp,sp,-64
    8001db4e:	fc22                	sd	s0,56(sp)
    8001db50:	0080                	addi	s0,sp,64
    8001db52:	fca43c23          	sd	a0,-40(s0)
    8001db56:	fcb43823          	sd	a1,-48(s0)
    8001db5a:	87b2                	mv	a5,a2
    8001db5c:	fcf42623          	sw	a5,-52(s0)
    char *o = dest;
    8001db60:	fd843783          	ld	a5,-40(s0)
    8001db64:	fef43423          	sd	a5,-24(s0)
    while (*s && n-- > 0) {
    8001db68:	a00d                	j	8001db8a <strncpy+0x3e>
        *dest++ = *s++;
    8001db6a:	fd043703          	ld	a4,-48(s0)
    8001db6e:	00170793          	addi	a5,a4,1
    8001db72:	fcf43823          	sd	a5,-48(s0)
    8001db76:	fd843783          	ld	a5,-40(s0)
    8001db7a:	00178693          	addi	a3,a5,1
    8001db7e:	fcd43c23          	sd	a3,-40(s0)
    8001db82:	00074703          	lbu	a4,0(a4)
    8001db86:	00e78023          	sb	a4,0(a5)
    while (*s && n-- > 0) {
    8001db8a:	fd043783          	ld	a5,-48(s0)
    8001db8e:	0007c783          	lbu	a5,0(a5)
    8001db92:	cb89                	beqz	a5,8001dba4 <strncpy+0x58>
    8001db94:	fcc42783          	lw	a5,-52(s0)
    8001db98:	fff7871b          	addiw	a4,a5,-1
    8001db9c:	fce42623          	sw	a4,-52(s0)
    8001dba0:	fcf045e3          	bgtz	a5,8001db6a <strncpy+0x1e>
    }
    *dest = '\0';
    8001dba4:	fd843783          	ld	a5,-40(s0)
    8001dba8:	00078023          	sb	zero,0(a5)
    return o;
    8001dbac:	fe843783          	ld	a5,-24(s0)
}
    8001dbb0:	853e                	mv	a0,a5
    8001dbb2:	7462                	ld	s0,56(sp)
    8001dbb4:	6121                	addi	sp,sp,64
    8001dbb6:	8082                	ret

000000008001dbb8 <strdup>:


char *strdup(const char *src)
{
    8001dbb8:	7179                	addi	sp,sp,-48
    8001dbba:	f406                	sd	ra,40(sp)
    8001dbbc:	f022                	sd	s0,32(sp)
    8001dbbe:	1800                	addi	s0,sp,48
    8001dbc0:	fca43c23          	sd	a0,-40(s0)
    int len   = strlen(src);
    8001dbc4:	fd843503          	ld	a0,-40(s0)
    8001dbc8:	ef1ff0ef          	jal	ra,8001dab8 <strlen>
    8001dbcc:	87aa                	mv	a5,a0
    8001dbce:	fef42623          	sw	a5,-20(s0)
    char *ret = (char *)g_kmalloc(len + 1);
    8001dbd2:	fec42783          	lw	a5,-20(s0)
    8001dbd6:	2785                	addiw	a5,a5,1
    8001dbd8:	2781                	sext.w	a5,a5
    8001dbda:	853e                	mv	a0,a5
    8001dbdc:	ba0fe0ef          	jal	ra,8001bf7c <g_kmalloc>
    8001dbe0:	fea43023          	sd	a0,-32(s0)
    if (!ret) {
    8001dbe4:	fe043783          	ld	a5,-32(s0)
    8001dbe8:	e399                	bnez	a5,8001dbee <strdup+0x36>
        return NULL;
    8001dbea:	4781                	li	a5,0
    8001dbec:	a801                	j	8001dbfc <strdup+0x44>
    }
    return strcpy(ret, src);
    8001dbee:	fd843583          	ld	a1,-40(s0)
    8001dbf2:	fe043503          	ld	a0,-32(s0)
    8001dbf6:	f01ff0ef          	jal	ra,8001daf6 <strcpy>
    8001dbfa:	87aa                	mv	a5,a0
}
    8001dbfc:	853e                	mv	a0,a5
    8001dbfe:	70a2                	ld	ra,40(sp)
    8001dc00:	7402                	ld	s0,32(sp)
    8001dc02:	6145                	addi	sp,sp,48
    8001dc04:	8082                	ret

000000008001dc06 <strstartswith>:

bool strstartswith(const char *src, const char *start)
{
    8001dc06:	7179                	addi	sp,sp,-48
    8001dc08:	f406                	sd	ra,40(sp)
    8001dc0a:	f022                	sd	s0,32(sp)
    8001dc0c:	1800                	addi	s0,sp,48
    8001dc0e:	fca43c23          	sd	a0,-40(s0)
    8001dc12:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    8001dc16:	fd843503          	ld	a0,-40(s0)
    8001dc1a:	e9fff0ef          	jal	ra,8001dab8 <strlen>
    8001dc1e:	87aa                	mv	a5,a0
    8001dc20:	fef42423          	sw	a5,-24(s0)
    int start_len = strlen(start);
    8001dc24:	fd043503          	ld	a0,-48(s0)
    8001dc28:	e91ff0ef          	jal	ra,8001dab8 <strlen>
    8001dc2c:	87aa                	mv	a5,a0
    8001dc2e:	fef42223          	sw	a5,-28(s0)
    int i;
    
    if (src_len < start_len) {
    8001dc32:	fe842703          	lw	a4,-24(s0)
    8001dc36:	fe442783          	lw	a5,-28(s0)
    8001dc3a:	2701                	sext.w	a4,a4
    8001dc3c:	2781                	sext.w	a5,a5
    8001dc3e:	00f75463          	bge	a4,a5,8001dc46 <strstartswith+0x40>
        return false;
    8001dc42:	4781                	li	a5,0
    8001dc44:	a0a9                	j	8001dc8e <strstartswith+0x88>
    }

    for (i = 0;i < start_len;i++) {
    8001dc46:	fe042623          	sw	zero,-20(s0)
    8001dc4a:	a80d                	j	8001dc7c <strstartswith+0x76>
        if (src[i] != start[i]) {
    8001dc4c:	fec42783          	lw	a5,-20(s0)
    8001dc50:	fd843703          	ld	a4,-40(s0)
    8001dc54:	97ba                	add	a5,a5,a4
    8001dc56:	0007c683          	lbu	a3,0(a5)
    8001dc5a:	fec42783          	lw	a5,-20(s0)
    8001dc5e:	fd043703          	ld	a4,-48(s0)
    8001dc62:	97ba                	add	a5,a5,a4
    8001dc64:	0007c783          	lbu	a5,0(a5)
    8001dc68:	8736                	mv	a4,a3
    8001dc6a:	00f70463          	beq	a4,a5,8001dc72 <strstartswith+0x6c>
            return false;
    8001dc6e:	4781                	li	a5,0
    8001dc70:	a839                	j	8001dc8e <strstartswith+0x88>
    for (i = 0;i < start_len;i++) {
    8001dc72:	fec42783          	lw	a5,-20(s0)
    8001dc76:	2785                	addiw	a5,a5,1
    8001dc78:	fef42623          	sw	a5,-20(s0)
    8001dc7c:	fec42703          	lw	a4,-20(s0)
    8001dc80:	fe442783          	lw	a5,-28(s0)
    8001dc84:	2701                	sext.w	a4,a4
    8001dc86:	2781                	sext.w	a5,a5
    8001dc88:	fcf742e3          	blt	a4,a5,8001dc4c <strstartswith+0x46>
        }
    }

    return true;
    8001dc8c:	4785                	li	a5,1
}
    8001dc8e:	853e                	mv	a0,a5
    8001dc90:	70a2                	ld	ra,40(sp)
    8001dc92:	7402                	ld	s0,32(sp)
    8001dc94:	6145                	addi	sp,sp,48
    8001dc96:	8082                	ret

000000008001dc98 <strendswith>:

bool strendswith(const char *src, const char *end)
{
    8001dc98:	7179                	addi	sp,sp,-48
    8001dc9a:	f406                	sd	ra,40(sp)
    8001dc9c:	f022                	sd	s0,32(sp)
    8001dc9e:	1800                	addi	s0,sp,48
    8001dca0:	fca43c23          	sd	a0,-40(s0)
    8001dca4:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    8001dca8:	fd843503          	ld	a0,-40(s0)
    8001dcac:	e0dff0ef          	jal	ra,8001dab8 <strlen>
    8001dcb0:	87aa                	mv	a5,a0
    8001dcb2:	fef42423          	sw	a5,-24(s0)
    int end_len = strlen(end);
    8001dcb6:	fd043503          	ld	a0,-48(s0)
    8001dcba:	dffff0ef          	jal	ra,8001dab8 <strlen>
    8001dcbe:	87aa                	mv	a5,a0
    8001dcc0:	fef42223          	sw	a5,-28(s0)
    int cmp = src_len - end_len;
    8001dcc4:	fe842703          	lw	a4,-24(s0)
    8001dcc8:	fe442783          	lw	a5,-28(s0)
    8001dccc:	40f707bb          	subw	a5,a4,a5
    8001dcd0:	fef42023          	sw	a5,-32(s0)
    int i;
    
    if (src_len < end_len) {
    8001dcd4:	fe842703          	lw	a4,-24(s0)
    8001dcd8:	fe442783          	lw	a5,-28(s0)
    8001dcdc:	2701                	sext.w	a4,a4
    8001dcde:	2781                	sext.w	a5,a5
    8001dce0:	00f75463          	bge	a4,a5,8001dce8 <strendswith+0x50>
        return false;
    8001dce4:	4781                	li	a5,0
    8001dce6:	a891                	j	8001dd3a <strendswith+0xa2>
    }

    for (i = 0;i < end_len;i++) {
    8001dce8:	fe042623          	sw	zero,-20(s0)
    8001dcec:	a835                	j	8001dd28 <strendswith+0x90>
        if (src[i + cmp] != end[i]) {
    8001dcee:	fec42703          	lw	a4,-20(s0)
    8001dcf2:	fe042783          	lw	a5,-32(s0)
    8001dcf6:	9fb9                	addw	a5,a5,a4
    8001dcf8:	2781                	sext.w	a5,a5
    8001dcfa:	873e                	mv	a4,a5
    8001dcfc:	fd843783          	ld	a5,-40(s0)
    8001dd00:	97ba                	add	a5,a5,a4
    8001dd02:	0007c683          	lbu	a3,0(a5)
    8001dd06:	fec42783          	lw	a5,-20(s0)
    8001dd0a:	fd043703          	ld	a4,-48(s0)
    8001dd0e:	97ba                	add	a5,a5,a4
    8001dd10:	0007c783          	lbu	a5,0(a5)
    8001dd14:	8736                	mv	a4,a3
    8001dd16:	00f70463          	beq	a4,a5,8001dd1e <strendswith+0x86>
            return false;
    8001dd1a:	4781                	li	a5,0
    8001dd1c:	a839                	j	8001dd3a <strendswith+0xa2>
    for (i = 0;i < end_len;i++) {
    8001dd1e:	fec42783          	lw	a5,-20(s0)
    8001dd22:	2785                	addiw	a5,a5,1
    8001dd24:	fef42623          	sw	a5,-20(s0)
    8001dd28:	fec42703          	lw	a4,-20(s0)
    8001dd2c:	fe442783          	lw	a5,-28(s0)
    8001dd30:	2701                	sext.w	a4,a4
    8001dd32:	2781                	sext.w	a5,a5
    8001dd34:	faf74de3          	blt	a4,a5,8001dcee <strendswith+0x56>
        }
    }

    return true;    
    8001dd38:	4785                	li	a5,1
}
    8001dd3a:	853e                	mv	a0,a5
    8001dd3c:	70a2                	ld	ra,40(sp)
    8001dd3e:	7402                	ld	s0,32(sp)
    8001dd40:	6145                	addi	sp,sp,48
    8001dd42:	8082                	ret

000000008001dd44 <vector_init>:
    uint32_t size;
    uint32_t capacity;
    uint64_t *values;
} Vector;

static Vector *vector_init(Vector *vec) {
    8001dd44:	1101                	addi	sp,sp,-32
    8001dd46:	ec22                	sd	s0,24(sp)
    8001dd48:	1000                	addi	s0,sp,32
    8001dd4a:	fea43423          	sd	a0,-24(s0)
    if (vec == NULL) {
    8001dd4e:	fe843783          	ld	a5,-24(s0)
    8001dd52:	e399                	bnez	a5,8001dd58 <vector_init+0x14>
        return NULL;
    8001dd54:	4781                	li	a5,0
    8001dd56:	a839                	j	8001dd74 <vector_init+0x30>
    }
    vec->size = 0;
    8001dd58:	fe843783          	ld	a5,-24(s0)
    8001dd5c:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    8001dd60:	fe843783          	ld	a5,-24(s0)
    8001dd64:	0007a223          	sw	zero,4(a5)
    vec->values = NULL;
    8001dd68:	fe843783          	ld	a5,-24(s0)
    8001dd6c:	0007b423          	sd	zero,8(a5)
    return vec;
    8001dd70:	fe843783          	ld	a5,-24(s0)
}
    8001dd74:	853e                	mv	a0,a5
    8001dd76:	6462                	ld	s0,24(sp)
    8001dd78:	6105                	addi	sp,sp,32
    8001dd7a:	8082                	ret

000000008001dd7c <vector_new>:

Vector *vector_new(void) {
    8001dd7c:	1141                	addi	sp,sp,-16
    8001dd7e:	e406                	sd	ra,8(sp)
    8001dd80:	e022                	sd	s0,0(sp)
    8001dd82:	0800                	addi	s0,sp,16
    return vector_init((Vector *)g_kmalloc(sizeof(Vector)));
    8001dd84:	4541                	li	a0,16
    8001dd86:	9f6fe0ef          	jal	ra,8001bf7c <g_kmalloc>
    8001dd8a:	87aa                	mv	a5,a0
    8001dd8c:	853e                	mv	a0,a5
    8001dd8e:	fb7ff0ef          	jal	ra,8001dd44 <vector_init>
    8001dd92:	87aa                	mv	a5,a0
}
    8001dd94:	853e                	mv	a0,a5
    8001dd96:	60a2                	ld	ra,8(sp)
    8001dd98:	6402                	ld	s0,0(sp)
    8001dd9a:	0141                	addi	sp,sp,16
    8001dd9c:	8082                	ret

000000008001dd9e <vector_init_with_capacity>:

static Vector *vector_init_with_capacity(Vector *vec, uint32_t capacity) {
    8001dd9e:	1101                	addi	sp,sp,-32
    8001dda0:	ec06                	sd	ra,24(sp)
    8001dda2:	e822                	sd	s0,16(sp)
    8001dda4:	1000                	addi	s0,sp,32
    8001dda6:	fea43423          	sd	a0,-24(s0)
    8001ddaa:	87ae                	mv	a5,a1
    8001ddac:	fef42223          	sw	a5,-28(s0)
    if (vec == NULL) {
    8001ddb0:	fe843783          	ld	a5,-24(s0)
    8001ddb4:	e399                	bnez	a5,8001ddba <vector_init_with_capacity+0x1c>
        return NULL;
    8001ddb6:	4781                	li	a5,0
    8001ddb8:	a035                	j	8001dde4 <vector_init_with_capacity+0x46>
    }
    vec->size = 0;
    8001ddba:	fe843783          	ld	a5,-24(s0)
    8001ddbe:	0007a023          	sw	zero,0(a5)
    vec->capacity = capacity;
    8001ddc2:	fe843783          	ld	a5,-24(s0)
    8001ddc6:	fe442703          	lw	a4,-28(s0)
    8001ddca:	c3d8                	sw	a4,4(a5)
    vec->values = (uint64_t *)g_kcalloc(capacity, sizeof(uint64_t));
    8001ddcc:	fe446783          	lwu	a5,-28(s0)
    8001ddd0:	45a1                	li	a1,8
    8001ddd2:	853e                	mv	a0,a5
    8001ddd4:	9e0fe0ef          	jal	ra,8001bfb4 <g_kcalloc>
    8001ddd8:	872a                	mv	a4,a0
    8001ddda:	fe843783          	ld	a5,-24(s0)
    8001ddde:	e798                	sd	a4,8(a5)
    return vec;
    8001dde0:	fe843783          	ld	a5,-24(s0)
}
    8001dde4:	853e                	mv	a0,a5
    8001dde6:	60e2                	ld	ra,24(sp)
    8001dde8:	6442                	ld	s0,16(sp)
    8001ddea:	6105                	addi	sp,sp,32
    8001ddec:	8082                	ret

000000008001ddee <vector_new_with_capacity>:

Vector *vector_new_with_capacity(uint32_t capacity) {
    8001ddee:	1101                	addi	sp,sp,-32
    8001ddf0:	ec06                	sd	ra,24(sp)
    8001ddf2:	e822                	sd	s0,16(sp)
    8001ddf4:	1000                	addi	s0,sp,32
    8001ddf6:	87aa                	mv	a5,a0
    8001ddf8:	fef42623          	sw	a5,-20(s0)
    return vector_init_with_capacity((Vector *)g_kmalloc(sizeof(Vector)), capacity);
    8001ddfc:	4541                	li	a0,16
    8001ddfe:	97efe0ef          	jal	ra,8001bf7c <g_kmalloc>
    8001de02:	872a                	mv	a4,a0
    8001de04:	fec42783          	lw	a5,-20(s0)
    8001de08:	85be                	mv	a1,a5
    8001de0a:	853a                	mv	a0,a4
    8001de0c:	f93ff0ef          	jal	ra,8001dd9e <vector_init_with_capacity>
    8001de10:	87aa                	mv	a5,a0
}
    8001de12:	853e                	mv	a0,a5
    8001de14:	60e2                	ld	ra,24(sp)
    8001de16:	6442                	ld	s0,16(sp)
    8001de18:	6105                	addi	sp,sp,32
    8001de1a:	8082                	ret

000000008001de1c <vector_push>:

void vector_push(Vector *vec, uint64_t value) {
    8001de1c:	1101                	addi	sp,sp,-32
    8001de1e:	ec06                	sd	ra,24(sp)
    8001de20:	e822                	sd	s0,16(sp)
    8001de22:	1000                	addi	s0,sp,32
    8001de24:	fea43423          	sd	a0,-24(s0)
    8001de28:	feb43023          	sd	a1,-32(s0)
    vector_insert(vec, vec->size, value);
    8001de2c:	fe843783          	ld	a5,-24(s0)
    8001de30:	439c                	lw	a5,0(a5)
    8001de32:	fe043603          	ld	a2,-32(s0)
    8001de36:	85be                	mv	a1,a5
    8001de38:	fe843503          	ld	a0,-24(s0)
    8001de3c:	00e000ef          	jal	ra,8001de4a <vector_insert>
}
    8001de40:	0001                	nop
    8001de42:	60e2                	ld	ra,24(sp)
    8001de44:	6442                	ld	s0,16(sp)
    8001de46:	6105                	addi	sp,sp,32
    8001de48:	8082                	ret

000000008001de4a <vector_insert>:

void vector_insert(Vector *vec, uint32_t idx, uint64_t value) {
    8001de4a:	7139                	addi	sp,sp,-64
    8001de4c:	fc06                	sd	ra,56(sp)
    8001de4e:	f822                	sd	s0,48(sp)
    8001de50:	0080                	addi	s0,sp,64
    8001de52:	fca43c23          	sd	a0,-40(s0)
    8001de56:	87ae                	mv	a5,a1
    8001de58:	fcc43423          	sd	a2,-56(s0)
    8001de5c:	fcf42a23          	sw	a5,-44(s0)
    uint32_t i;
    vector_resize(vec, vec->size + 1);
    8001de60:	fd843783          	ld	a5,-40(s0)
    8001de64:	439c                	lw	a5,0(a5)
    8001de66:	2785                	addiw	a5,a5,1
    8001de68:	2781                	sext.w	a5,a5
    8001de6a:	85be                	mv	a1,a5
    8001de6c:	fd843503          	ld	a0,-40(s0)
    8001de70:	214000ef          	jal	ra,8001e084 <vector_resize>
    for (i = vec->size - 1;i > idx;i--) {
    8001de74:	fd843783          	ld	a5,-40(s0)
    8001de78:	439c                	lw	a5,0(a5)
    8001de7a:	37fd                	addiw	a5,a5,-1
    8001de7c:	fef42623          	sw	a5,-20(s0)
    8001de80:	a805                	j	8001deb0 <vector_insert+0x66>
        vector_set(vec, i, vector_get_unchecked(vec, i - 1));
    8001de82:	fec42783          	lw	a5,-20(s0)
    8001de86:	37fd                	addiw	a5,a5,-1
    8001de88:	2781                	sext.w	a5,a5
    8001de8a:	85be                	mv	a1,a5
    8001de8c:	fd843503          	ld	a0,-40(s0)
    8001de90:	13a000ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001de94:	872a                	mv	a4,a0
    8001de96:	fec42783          	lw	a5,-20(s0)
    8001de9a:	863a                	mv	a2,a4
    8001de9c:	85be                	mv	a1,a5
    8001de9e:	fd843503          	ld	a0,-40(s0)
    8001dea2:	094000ef          	jal	ra,8001df36 <vector_set>
    for (i = vec->size - 1;i > idx;i--) {
    8001dea6:	fec42783          	lw	a5,-20(s0)
    8001deaa:	37fd                	addiw	a5,a5,-1
    8001deac:	fef42623          	sw	a5,-20(s0)
    8001deb0:	fec42703          	lw	a4,-20(s0)
    8001deb4:	fd442783          	lw	a5,-44(s0)
    8001deb8:	2701                	sext.w	a4,a4
    8001deba:	2781                	sext.w	a5,a5
    8001debc:	fce7e3e3          	bltu	a5,a4,8001de82 <vector_insert+0x38>
    }
    vector_set(vec, idx, value);
    8001dec0:	fd442783          	lw	a5,-44(s0)
    8001dec4:	fc843603          	ld	a2,-56(s0)
    8001dec8:	85be                	mv	a1,a5
    8001deca:	fd843503          	ld	a0,-40(s0)
    8001dece:	068000ef          	jal	ra,8001df36 <vector_set>
}
    8001ded2:	0001                	nop
    8001ded4:	70e2                	ld	ra,56(sp)
    8001ded6:	7442                	ld	s0,48(sp)
    8001ded8:	6121                	addi	sp,sp,64
    8001deda:	8082                	ret

000000008001dedc <vector_find>:

int vector_find(Vector *vec, uint64_t val) {
    8001dedc:	7179                	addi	sp,sp,-48
    8001dede:	f422                	sd	s0,40(sp)
    8001dee0:	1800                	addi	s0,sp,48
    8001dee2:	fca43c23          	sd	a0,-40(s0)
    8001dee6:	fcb43823          	sd	a1,-48(s0)
    int i;
    for (i = 0;i < (int)vec->size;i++) {
    8001deea:	fe042623          	sw	zero,-20(s0)
    8001deee:	a02d                	j	8001df18 <vector_find+0x3c>
        if (vec->values[i] == val) {
    8001def0:	fd843783          	ld	a5,-40(s0)
    8001def4:	6798                	ld	a4,8(a5)
    8001def6:	fec42783          	lw	a5,-20(s0)
    8001defa:	078e                	slli	a5,a5,0x3
    8001defc:	97ba                	add	a5,a5,a4
    8001defe:	639c                	ld	a5,0(a5)
    8001df00:	fd043703          	ld	a4,-48(s0)
    8001df04:	00f71563          	bne	a4,a5,8001df0e <vector_find+0x32>
            return i;
    8001df08:	fec42783          	lw	a5,-20(s0)
    8001df0c:	a00d                	j	8001df2e <vector_find+0x52>
    for (i = 0;i < (int)vec->size;i++) {
    8001df0e:	fec42783          	lw	a5,-20(s0)
    8001df12:	2785                	addiw	a5,a5,1
    8001df14:	fef42623          	sw	a5,-20(s0)
    8001df18:	fd843783          	ld	a5,-40(s0)
    8001df1c:	439c                	lw	a5,0(a5)
    8001df1e:	0007871b          	sext.w	a4,a5
    8001df22:	fec42783          	lw	a5,-20(s0)
    8001df26:	2781                	sext.w	a5,a5
    8001df28:	fce7c4e3          	blt	a5,a4,8001def0 <vector_find+0x14>
        }
    }
    return -1;
    8001df2c:	57fd                	li	a5,-1
}
    8001df2e:	853e                	mv	a0,a5
    8001df30:	7422                	ld	s0,40(sp)
    8001df32:	6145                	addi	sp,sp,48
    8001df34:	8082                	ret

000000008001df36 <vector_set>:

bool vector_set(Vector *vec, uint32_t idx, uint64_t val) {
    8001df36:	7179                	addi	sp,sp,-48
    8001df38:	f422                	sd	s0,40(sp)
    8001df3a:	1800                	addi	s0,sp,48
    8001df3c:	fea43423          	sd	a0,-24(s0)
    8001df40:	87ae                	mv	a5,a1
    8001df42:	fcc43c23          	sd	a2,-40(s0)
    8001df46:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    8001df4a:	fe843783          	ld	a5,-24(s0)
    8001df4e:	4398                	lw	a4,0(a5)
    8001df50:	fe442783          	lw	a5,-28(s0)
    8001df54:	2781                	sext.w	a5,a5
    8001df56:	00e7e463          	bltu	a5,a4,8001df5e <vector_set+0x28>
        return false;
    8001df5a:	4781                	li	a5,0
    8001df5c:	a821                	j	8001df74 <vector_set+0x3e>
    }
    vec->values[idx] = val;
    8001df5e:	fe843783          	ld	a5,-24(s0)
    8001df62:	6798                	ld	a4,8(a5)
    8001df64:	fe446783          	lwu	a5,-28(s0)
    8001df68:	078e                	slli	a5,a5,0x3
    8001df6a:	97ba                	add	a5,a5,a4
    8001df6c:	fd843703          	ld	a4,-40(s0)
    8001df70:	e398                	sd	a4,0(a5)
    return true;
    8001df72:	4785                	li	a5,1
}
    8001df74:	853e                	mv	a0,a5
    8001df76:	7422                	ld	s0,40(sp)
    8001df78:	6145                	addi	sp,sp,48
    8001df7a:	8082                	ret

000000008001df7c <vector_get>:

bool vector_get(Vector *vec, uint32_t idx, uint64_t *val) {
    8001df7c:	7179                	addi	sp,sp,-48
    8001df7e:	f422                	sd	s0,40(sp)
    8001df80:	1800                	addi	s0,sp,48
    8001df82:	fea43423          	sd	a0,-24(s0)
    8001df86:	87ae                	mv	a5,a1
    8001df88:	fcc43c23          	sd	a2,-40(s0)
    8001df8c:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    8001df90:	fe843783          	ld	a5,-24(s0)
    8001df94:	4398                	lw	a4,0(a5)
    8001df96:	fe442783          	lw	a5,-28(s0)
    8001df9a:	2781                	sext.w	a5,a5
    8001df9c:	00e7e463          	bltu	a5,a4,8001dfa4 <vector_get+0x28>
        return false;
    8001dfa0:	4781                	li	a5,0
    8001dfa2:	a005                	j	8001dfc2 <vector_get+0x46>
    }
    if (val != NULL) {
    8001dfa4:	fd843783          	ld	a5,-40(s0)
    8001dfa8:	cf81                	beqz	a5,8001dfc0 <vector_get+0x44>
        *val = vec->values[idx];
    8001dfaa:	fe843783          	ld	a5,-24(s0)
    8001dfae:	6798                	ld	a4,8(a5)
    8001dfb0:	fe446783          	lwu	a5,-28(s0)
    8001dfb4:	078e                	slli	a5,a5,0x3
    8001dfb6:	97ba                	add	a5,a5,a4
    8001dfb8:	6398                	ld	a4,0(a5)
    8001dfba:	fd843783          	ld	a5,-40(s0)
    8001dfbe:	e398                	sd	a4,0(a5)
    }
    return true;
    8001dfc0:	4785                	li	a5,1
}
    8001dfc2:	853e                	mv	a0,a5
    8001dfc4:	7422                	ld	s0,40(sp)
    8001dfc6:	6145                	addi	sp,sp,48
    8001dfc8:	8082                	ret

000000008001dfca <vector_get_unchecked>:

uint64_t vector_get_unchecked(Vector *vec, uint32_t idx) {
    8001dfca:	1101                	addi	sp,sp,-32
    8001dfcc:	ec22                	sd	s0,24(sp)
    8001dfce:	1000                	addi	s0,sp,32
    8001dfd0:	fea43423          	sd	a0,-24(s0)
    8001dfd4:	87ae                	mv	a5,a1
    8001dfd6:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    8001dfda:	fe843783          	ld	a5,-24(s0)
    8001dfde:	4398                	lw	a4,0(a5)
    8001dfe0:	fe442783          	lw	a5,-28(s0)
    8001dfe4:	2781                	sext.w	a5,a5
    8001dfe6:	00e7e463          	bltu	a5,a4,8001dfee <vector_get_unchecked+0x24>
        return 0;
    8001dfea:	4781                	li	a5,0
    8001dfec:	a809                	j	8001dffe <vector_get_unchecked+0x34>
    }
    return vec->values[idx];
    8001dfee:	fe843783          	ld	a5,-24(s0)
    8001dff2:	6798                	ld	a4,8(a5)
    8001dff4:	fe446783          	lwu	a5,-28(s0)
    8001dff8:	078e                	slli	a5,a5,0x3
    8001dffa:	97ba                	add	a5,a5,a4
    8001dffc:	639c                	ld	a5,0(a5)
}
    8001dffe:	853e                	mv	a0,a5
    8001e000:	6462                	ld	s0,24(sp)
    8001e002:	6105                	addi	sp,sp,32
    8001e004:	8082                	ret

000000008001e006 <vector_resize_with_default>:


void vector_resize_with_default(Vector *vec, uint32_t new_size, uint64_t def) {
    8001e006:	7139                	addi	sp,sp,-64
    8001e008:	fc06                	sd	ra,56(sp)
    8001e00a:	f822                	sd	s0,48(sp)
    8001e00c:	0080                	addi	s0,sp,64
    8001e00e:	fca43c23          	sd	a0,-40(s0)
    8001e012:	87ae                	mv	a5,a1
    8001e014:	fcc43423          	sd	a2,-56(s0)
    8001e018:	fcf42a23          	sw	a5,-44(s0)
    uint32_t old_size = vec->size;
    8001e01c:	fd843783          	ld	a5,-40(s0)
    8001e020:	439c                	lw	a5,0(a5)
    8001e022:	fef42423          	sw	a5,-24(s0)
    vector_resize(vec, new_size);
    8001e026:	fd442783          	lw	a5,-44(s0)
    8001e02a:	85be                	mv	a1,a5
    8001e02c:	fd843503          	ld	a0,-40(s0)
    8001e030:	054000ef          	jal	ra,8001e084 <vector_resize>
    if (old_size < new_size) {
    8001e034:	fe842703          	lw	a4,-24(s0)
    8001e038:	fd442783          	lw	a5,-44(s0)
    8001e03c:	2701                	sext.w	a4,a4
    8001e03e:	2781                	sext.w	a5,a5
    8001e040:	02f77d63          	bgeu	a4,a5,8001e07a <vector_resize_with_default+0x74>
        uint32_t i;
        for (i = old_size;i < new_size;i++) {
    8001e044:	fe842783          	lw	a5,-24(s0)
    8001e048:	fef42623          	sw	a5,-20(s0)
    8001e04c:	a839                	j	8001e06a <vector_resize_with_default+0x64>
            vector_set(vec, i, def);
    8001e04e:	fec42783          	lw	a5,-20(s0)
    8001e052:	fc843603          	ld	a2,-56(s0)
    8001e056:	85be                	mv	a1,a5
    8001e058:	fd843503          	ld	a0,-40(s0)
    8001e05c:	edbff0ef          	jal	ra,8001df36 <vector_set>
        for (i = old_size;i < new_size;i++) {
    8001e060:	fec42783          	lw	a5,-20(s0)
    8001e064:	2785                	addiw	a5,a5,1
    8001e066:	fef42623          	sw	a5,-20(s0)
    8001e06a:	fec42703          	lw	a4,-20(s0)
    8001e06e:	fd442783          	lw	a5,-44(s0)
    8001e072:	2701                	sext.w	a4,a4
    8001e074:	2781                	sext.w	a5,a5
    8001e076:	fcf76ce3          	bltu	a4,a5,8001e04e <vector_resize_with_default+0x48>
        }
    }
}
    8001e07a:	0001                	nop
    8001e07c:	70e2                	ld	ra,56(sp)
    8001e07e:	7442                	ld	s0,48(sp)
    8001e080:	6121                	addi	sp,sp,64
    8001e082:	8082                	ret

000000008001e084 <vector_resize>:

void vector_resize(Vector *vec, uint32_t new_size) {
    8001e084:	7179                	addi	sp,sp,-48
    8001e086:	f406                	sd	ra,40(sp)
    8001e088:	f022                	sd	s0,32(sp)
    8001e08a:	1800                	addi	s0,sp,48
    8001e08c:	fca43c23          	sd	a0,-40(s0)
    8001e090:	87ae                	mv	a5,a1
    8001e092:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_size > vec->capacity) {
    8001e096:	fd843783          	ld	a5,-40(s0)
    8001e09a:	43d8                	lw	a4,4(a5)
    8001e09c:	fd442783          	lw	a5,-44(s0)
    8001e0a0:	2781                	sext.w	a5,a5
    8001e0a2:	06f77963          	bgeu	a4,a5,8001e114 <vector_resize+0x90>
        vals = (uint64_t *)g_kcalloc(new_size, sizeof(uint64_t));
    8001e0a6:	fd446783          	lwu	a5,-44(s0)
    8001e0aa:	45a1                	li	a1,8
    8001e0ac:	853e                	mv	a0,a5
    8001e0ae:	f07fd0ef          	jal	ra,8001bfb4 <g_kcalloc>
    8001e0b2:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    8001e0b6:	fe042623          	sw	zero,-20(s0)
    8001e0ba:	a02d                	j	8001e0e4 <vector_resize+0x60>
            vals[i] = vec->values[i];
    8001e0bc:	fd843783          	ld	a5,-40(s0)
    8001e0c0:	6798                	ld	a4,8(a5)
    8001e0c2:	fec46783          	lwu	a5,-20(s0)
    8001e0c6:	078e                	slli	a5,a5,0x3
    8001e0c8:	973e                	add	a4,a4,a5
    8001e0ca:	fec46783          	lwu	a5,-20(s0)
    8001e0ce:	078e                	slli	a5,a5,0x3
    8001e0d0:	fe043683          	ld	a3,-32(s0)
    8001e0d4:	97b6                	add	a5,a5,a3
    8001e0d6:	6318                	ld	a4,0(a4)
    8001e0d8:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    8001e0da:	fec42783          	lw	a5,-20(s0)
    8001e0de:	2785                	addiw	a5,a5,1
    8001e0e0:	fef42623          	sw	a5,-20(s0)
    8001e0e4:	fd843783          	ld	a5,-40(s0)
    8001e0e8:	4398                	lw	a4,0(a5)
    8001e0ea:	fec42783          	lw	a5,-20(s0)
    8001e0ee:	2781                	sext.w	a5,a5
    8001e0f0:	fce7e6e3          	bltu	a5,a4,8001e0bc <vector_resize+0x38>
        }
        g_kfree(vec->values);
    8001e0f4:	fd843783          	ld	a5,-40(s0)
    8001e0f8:	679c                	ld	a5,8(a5)
    8001e0fa:	853e                	mv	a0,a5
    8001e0fc:	f1bfd0ef          	jal	ra,8001c016 <g_kfree>
        vec->values = vals;
    8001e100:	fd843783          	ld	a5,-40(s0)
    8001e104:	fe043703          	ld	a4,-32(s0)
    8001e108:	e798                	sd	a4,8(a5)
        vec->capacity = new_size;
    8001e10a:	fd843783          	ld	a5,-40(s0)
    8001e10e:	fd442703          	lw	a4,-44(s0)
    8001e112:	c3d8                	sw	a4,4(a5)
    }        
    vec->size = new_size;    
    8001e114:	fd843783          	ld	a5,-40(s0)
    8001e118:	fd442703          	lw	a4,-44(s0)
    8001e11c:	c398                	sw	a4,0(a5)
}
    8001e11e:	0001                	nop
    8001e120:	70a2                	ld	ra,40(sp)
    8001e122:	7402                	ld	s0,32(sp)
    8001e124:	6145                	addi	sp,sp,48
    8001e126:	8082                	ret

000000008001e128 <vector_reserve>:

void vector_reserve(Vector *vec, uint32_t new_capacity) {
    8001e128:	7179                	addi	sp,sp,-48
    8001e12a:	f406                	sd	ra,40(sp)
    8001e12c:	f022                	sd	s0,32(sp)
    8001e12e:	1800                	addi	s0,sp,48
    8001e130:	fca43c23          	sd	a0,-40(s0)
    8001e134:	87ae                	mv	a5,a1
    8001e136:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_capacity > vec->capacity) {
    8001e13a:	fd843783          	ld	a5,-40(s0)
    8001e13e:	43d8                	lw	a4,4(a5)
    8001e140:	fd442783          	lw	a5,-44(s0)
    8001e144:	2781                	sext.w	a5,a5
    8001e146:	06f77a63          	bgeu	a4,a5,8001e1ba <vector_reserve+0x92>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    8001e14a:	fd446783          	lwu	a5,-44(s0)
    8001e14e:	45a1                	li	a1,8
    8001e150:	853e                	mv	a0,a5
    8001e152:	e63fd0ef          	jal	ra,8001bfb4 <g_kcalloc>
    8001e156:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    8001e15a:	fe042623          	sw	zero,-20(s0)
    8001e15e:	a02d                	j	8001e188 <vector_reserve+0x60>
            vals[i] = vec->values[i];
    8001e160:	fd843783          	ld	a5,-40(s0)
    8001e164:	6798                	ld	a4,8(a5)
    8001e166:	fec46783          	lwu	a5,-20(s0)
    8001e16a:	078e                	slli	a5,a5,0x3
    8001e16c:	973e                	add	a4,a4,a5
    8001e16e:	fec46783          	lwu	a5,-20(s0)
    8001e172:	078e                	slli	a5,a5,0x3
    8001e174:	fe043683          	ld	a3,-32(s0)
    8001e178:	97b6                	add	a5,a5,a3
    8001e17a:	6318                	ld	a4,0(a4)
    8001e17c:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    8001e17e:	fec42783          	lw	a5,-20(s0)
    8001e182:	2785                	addiw	a5,a5,1
    8001e184:	fef42623          	sw	a5,-20(s0)
    8001e188:	fd843783          	ld	a5,-40(s0)
    8001e18c:	4398                	lw	a4,0(a5)
    8001e18e:	fec42783          	lw	a5,-20(s0)
    8001e192:	2781                	sext.w	a5,a5
    8001e194:	fce7e6e3          	bltu	a5,a4,8001e160 <vector_reserve+0x38>
        }
        g_kfree(vec->values);
    8001e198:	fd843783          	ld	a5,-40(s0)
    8001e19c:	679c                	ld	a5,8(a5)
    8001e19e:	853e                	mv	a0,a5
    8001e1a0:	e77fd0ef          	jal	ra,8001c016 <g_kfree>
        vec->values = vals;
    8001e1a4:	fd843783          	ld	a5,-40(s0)
    8001e1a8:	fe043703          	ld	a4,-32(s0)
    8001e1ac:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    8001e1ae:	fd843783          	ld	a5,-40(s0)
    8001e1b2:	fd442703          	lw	a4,-44(s0)
    8001e1b6:	c3d8                	sw	a4,4(a5)
        }
        g_kfree(vec->values);
        vec->values = vals;
        vec->capacity = new_capacity;
    }
}
    8001e1b8:	a04d                	j	8001e25a <vector_reserve+0x132>
    else if (new_capacity > 0 && new_capacity < vec->capacity) {
    8001e1ba:	fd442783          	lw	a5,-44(s0)
    8001e1be:	2781                	sext.w	a5,a5
    8001e1c0:	cfc9                	beqz	a5,8001e25a <vector_reserve+0x132>
    8001e1c2:	fd843783          	ld	a5,-40(s0)
    8001e1c6:	43d8                	lw	a4,4(a5)
    8001e1c8:	fd442783          	lw	a5,-44(s0)
    8001e1cc:	2781                	sext.w	a5,a5
    8001e1ce:	08e7f663          	bgeu	a5,a4,8001e25a <vector_reserve+0x132>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    8001e1d2:	fd446783          	lwu	a5,-44(s0)
    8001e1d6:	45a1                	li	a1,8
    8001e1d8:	853e                	mv	a0,a5
    8001e1da:	ddbfd0ef          	jal	ra,8001bfb4 <g_kcalloc>
    8001e1de:	fea43023          	sd	a0,-32(s0)
        if (new_capacity < vec->size) {
    8001e1e2:	fd843783          	ld	a5,-40(s0)
    8001e1e6:	4398                	lw	a4,0(a5)
    8001e1e8:	fd442783          	lw	a5,-44(s0)
    8001e1ec:	2781                	sext.w	a5,a5
    8001e1ee:	00e7f763          	bgeu	a5,a4,8001e1fc <vector_reserve+0xd4>
            vec->size = new_capacity;
    8001e1f2:	fd843783          	ld	a5,-40(s0)
    8001e1f6:	fd442703          	lw	a4,-44(s0)
    8001e1fa:	c398                	sw	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    8001e1fc:	fe042623          	sw	zero,-20(s0)
    8001e200:	a02d                	j	8001e22a <vector_reserve+0x102>
            vals[i] = vec->values[i];
    8001e202:	fd843783          	ld	a5,-40(s0)
    8001e206:	6798                	ld	a4,8(a5)
    8001e208:	fec46783          	lwu	a5,-20(s0)
    8001e20c:	078e                	slli	a5,a5,0x3
    8001e20e:	973e                	add	a4,a4,a5
    8001e210:	fec46783          	lwu	a5,-20(s0)
    8001e214:	078e                	slli	a5,a5,0x3
    8001e216:	fe043683          	ld	a3,-32(s0)
    8001e21a:	97b6                	add	a5,a5,a3
    8001e21c:	6318                	ld	a4,0(a4)
    8001e21e:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    8001e220:	fec42783          	lw	a5,-20(s0)
    8001e224:	2785                	addiw	a5,a5,1
    8001e226:	fef42623          	sw	a5,-20(s0)
    8001e22a:	fd843783          	ld	a5,-40(s0)
    8001e22e:	4398                	lw	a4,0(a5)
    8001e230:	fec42783          	lw	a5,-20(s0)
    8001e234:	2781                	sext.w	a5,a5
    8001e236:	fce7e6e3          	bltu	a5,a4,8001e202 <vector_reserve+0xda>
        g_kfree(vec->values);
    8001e23a:	fd843783          	ld	a5,-40(s0)
    8001e23e:	679c                	ld	a5,8(a5)
    8001e240:	853e                	mv	a0,a5
    8001e242:	dd5fd0ef          	jal	ra,8001c016 <g_kfree>
        vec->values = vals;
    8001e246:	fd843783          	ld	a5,-40(s0)
    8001e24a:	fe043703          	ld	a4,-32(s0)
    8001e24e:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    8001e250:	fd843783          	ld	a5,-40(s0)
    8001e254:	fd442703          	lw	a4,-44(s0)
    8001e258:	c3d8                	sw	a4,4(a5)
}
    8001e25a:	0001                	nop
    8001e25c:	70a2                	ld	ra,40(sp)
    8001e25e:	7402                	ld	s0,32(sp)
    8001e260:	6145                	addi	sp,sp,48
    8001e262:	8082                	ret

000000008001e264 <vector_remove>:

bool vector_remove(Vector *vec, uint32_t idx) {
    8001e264:	1101                	addi	sp,sp,-32
    8001e266:	ec22                	sd	s0,24(sp)
    8001e268:	1000                	addi	s0,sp,32
    8001e26a:	fea43423          	sd	a0,-24(s0)
    8001e26e:	87ae                	mv	a5,a1
    8001e270:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    8001e274:	fe843783          	ld	a5,-24(s0)
    8001e278:	4398                	lw	a4,0(a5)
    8001e27a:	fe442783          	lw	a5,-28(s0)
    8001e27e:	2781                	sext.w	a5,a5
    8001e280:	00e7e463          	bltu	a5,a4,8001e288 <vector_remove+0x24>
        return false;
    8001e284:	4781                	li	a5,0
    8001e286:	a8a9                	j	8001e2e0 <vector_remove+0x7c>
    }
    vec->size -= 1;
    8001e288:	fe843783          	ld	a5,-24(s0)
    8001e28c:	439c                	lw	a5,0(a5)
    8001e28e:	37fd                	addiw	a5,a5,-1
    8001e290:	0007871b          	sext.w	a4,a5
    8001e294:	fe843783          	ld	a5,-24(s0)
    8001e298:	c398                	sw	a4,0(a5)
    for (;idx < vec->size;idx++) {
    8001e29a:	a815                	j	8001e2ce <vector_remove+0x6a>
        vec->values[idx] = vec->values[idx + 1];
    8001e29c:	fe843783          	ld	a5,-24(s0)
    8001e2a0:	6798                	ld	a4,8(a5)
    8001e2a2:	fe442783          	lw	a5,-28(s0)
    8001e2a6:	2785                	addiw	a5,a5,1
    8001e2a8:	2781                	sext.w	a5,a5
    8001e2aa:	1782                	slli	a5,a5,0x20
    8001e2ac:	9381                	srli	a5,a5,0x20
    8001e2ae:	078e                	slli	a5,a5,0x3
    8001e2b0:	973e                	add	a4,a4,a5
    8001e2b2:	fe843783          	ld	a5,-24(s0)
    8001e2b6:	6794                	ld	a3,8(a5)
    8001e2b8:	fe446783          	lwu	a5,-28(s0)
    8001e2bc:	078e                	slli	a5,a5,0x3
    8001e2be:	97b6                	add	a5,a5,a3
    8001e2c0:	6318                	ld	a4,0(a4)
    8001e2c2:	e398                	sd	a4,0(a5)
    for (;idx < vec->size;idx++) {
    8001e2c4:	fe442783          	lw	a5,-28(s0)
    8001e2c8:	2785                	addiw	a5,a5,1
    8001e2ca:	fef42223          	sw	a5,-28(s0)
    8001e2ce:	fe843783          	ld	a5,-24(s0)
    8001e2d2:	4398                	lw	a4,0(a5)
    8001e2d4:	fe442783          	lw	a5,-28(s0)
    8001e2d8:	2781                	sext.w	a5,a5
    8001e2da:	fce7e1e3          	bltu	a5,a4,8001e29c <vector_remove+0x38>
    }
    return true;
    8001e2de:	4785                	li	a5,1
}
    8001e2e0:	853e                	mv	a0,a5
    8001e2e2:	6462                	ld	s0,24(sp)
    8001e2e4:	6105                	addi	sp,sp,32
    8001e2e6:	8082                	ret

000000008001e2e8 <vector_remove_value>:

bool vector_remove_value(Vector *vec, uint64_t val) {
    8001e2e8:	7179                	addi	sp,sp,-48
    8001e2ea:	f406                	sd	ra,40(sp)
    8001e2ec:	f022                	sd	s0,32(sp)
    8001e2ee:	1800                	addi	s0,sp,48
    8001e2f0:	fca43c23          	sd	a0,-40(s0)
    8001e2f4:	fcb43823          	sd	a1,-48(s0)
    uint32_t i;
    for (i = 0;i < vec->size;i++) {
    8001e2f8:	fe042623          	sw	zero,-20(s0)
    8001e2fc:	a81d                	j	8001e332 <vector_remove_value+0x4a>
        if (vec->values[i] == val) {
    8001e2fe:	fd843783          	ld	a5,-40(s0)
    8001e302:	6798                	ld	a4,8(a5)
    8001e304:	fec46783          	lwu	a5,-20(s0)
    8001e308:	078e                	slli	a5,a5,0x3
    8001e30a:	97ba                	add	a5,a5,a4
    8001e30c:	639c                	ld	a5,0(a5)
    8001e30e:	fd043703          	ld	a4,-48(s0)
    8001e312:	00f71b63          	bne	a4,a5,8001e328 <vector_remove_value+0x40>
            vector_remove(vec, i);
    8001e316:	fec42783          	lw	a5,-20(s0)
    8001e31a:	85be                	mv	a1,a5
    8001e31c:	fd843503          	ld	a0,-40(s0)
    8001e320:	f45ff0ef          	jal	ra,8001e264 <vector_remove>
            return true;
    8001e324:	4785                	li	a5,1
    8001e326:	a839                	j	8001e344 <vector_remove_value+0x5c>
    for (i = 0;i < vec->size;i++) {
    8001e328:	fec42783          	lw	a5,-20(s0)
    8001e32c:	2785                	addiw	a5,a5,1
    8001e32e:	fef42623          	sw	a5,-20(s0)
    8001e332:	fd843783          	ld	a5,-40(s0)
    8001e336:	4398                	lw	a4,0(a5)
    8001e338:	fec42783          	lw	a5,-20(s0)
    8001e33c:	2781                	sext.w	a5,a5
    8001e33e:	fce7e0e3          	bltu	a5,a4,8001e2fe <vector_remove_value+0x16>
        }
    }
    return false;
    8001e342:	4781                	li	a5,0
}
    8001e344:	853e                	mv	a0,a5
    8001e346:	70a2                	ld	ra,40(sp)
    8001e348:	7402                	ld	s0,32(sp)
    8001e34a:	6145                	addi	sp,sp,48
    8001e34c:	8082                	ret

000000008001e34e <vector_clear>:

void vector_clear(Vector *vec) {
    8001e34e:	1101                	addi	sp,sp,-32
    8001e350:	ec06                	sd	ra,24(sp)
    8001e352:	e822                	sd	s0,16(sp)
    8001e354:	1000                	addi	s0,sp,32
    8001e356:	fea43423          	sd	a0,-24(s0)
    vector_resize(vec, 0);
    8001e35a:	4581                	li	a1,0
    8001e35c:	fe843503          	ld	a0,-24(s0)
    8001e360:	d25ff0ef          	jal	ra,8001e084 <vector_resize>
}
    8001e364:	0001                	nop
    8001e366:	60e2                	ld	ra,24(sp)
    8001e368:	6442                	ld	s0,16(sp)
    8001e36a:	6105                	addi	sp,sp,32
    8001e36c:	8082                	ret

000000008001e36e <vector_binsearch_ascending>:

int vector_binsearch_ascending(struct Vector *vec, uint64_t key) {
    8001e36e:	7179                	addi	sp,sp,-48
    8001e370:	f406                	sd	ra,40(sp)
    8001e372:	f022                	sd	s0,32(sp)
    8001e374:	1800                	addi	s0,sp,48
    8001e376:	fca43c23          	sd	a0,-40(s0)
    8001e37a:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    8001e37e:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec);
    8001e382:	fd843503          	ld	a0,-40(s0)
    8001e386:	356000ef          	jal	ra,8001e6dc <vector_size>
    8001e38a:	87aa                	mv	a5,a0
    8001e38c:	2781                	sext.w	a5,a5
    8001e38e:	fef42423          	sw	a5,-24(s0)

    while (low < high) {
    8001e392:	a0ad                	j	8001e3fc <vector_binsearch_ascending+0x8e>
        int mid = (low + high) / 2;
    8001e394:	fec42703          	lw	a4,-20(s0)
    8001e398:	fe842783          	lw	a5,-24(s0)
    8001e39c:	9fb9                	addw	a5,a5,a4
    8001e39e:	2781                	sext.w	a5,a5
    8001e3a0:	01f7d71b          	srliw	a4,a5,0x1f
    8001e3a4:	9fb9                	addw	a5,a5,a4
    8001e3a6:	4017d79b          	sraiw	a5,a5,0x1
    8001e3aa:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) > key) {
    8001e3ae:	fe442783          	lw	a5,-28(s0)
    8001e3b2:	85be                	mv	a1,a5
    8001e3b4:	fd843503          	ld	a0,-40(s0)
    8001e3b8:	c13ff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e3bc:	872a                	mv	a4,a0
    8001e3be:	fd043783          	ld	a5,-48(s0)
    8001e3c2:	00e7f863          	bgeu	a5,a4,8001e3d2 <vector_binsearch_ascending+0x64>
            high = mid - 1;
    8001e3c6:	fe442783          	lw	a5,-28(s0)
    8001e3ca:	37fd                	addiw	a5,a5,-1
    8001e3cc:	fef42423          	sw	a5,-24(s0)
    8001e3d0:	a035                	j	8001e3fc <vector_binsearch_ascending+0x8e>
        }
        else if (vector_get_unchecked(vec, mid) < key) {
    8001e3d2:	fe442783          	lw	a5,-28(s0)
    8001e3d6:	85be                	mv	a1,a5
    8001e3d8:	fd843503          	ld	a0,-40(s0)
    8001e3dc:	befff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e3e0:	872a                	mv	a4,a0
    8001e3e2:	fd043783          	ld	a5,-48(s0)
    8001e3e6:	00f77863          	bgeu	a4,a5,8001e3f6 <vector_binsearch_ascending+0x88>
            low = mid + 1;
    8001e3ea:	fe442783          	lw	a5,-28(s0)
    8001e3ee:	2785                	addiw	a5,a5,1
    8001e3f0:	fef42623          	sw	a5,-20(s0)
    8001e3f4:	a021                	j	8001e3fc <vector_binsearch_ascending+0x8e>
        }
        else {
            return mid;
    8001e3f6:	fe442783          	lw	a5,-28(s0)
    8001e3fa:	a811                	j	8001e40e <vector_binsearch_ascending+0xa0>
    while (low < high) {
    8001e3fc:	fec42703          	lw	a4,-20(s0)
    8001e400:	fe842783          	lw	a5,-24(s0)
    8001e404:	2701                	sext.w	a4,a4
    8001e406:	2781                	sext.w	a5,a5
    8001e408:	f8f746e3          	blt	a4,a5,8001e394 <vector_binsearch_ascending+0x26>
        }
    }
    return -1;
    8001e40c:	57fd                	li	a5,-1
}
    8001e40e:	853e                	mv	a0,a5
    8001e410:	70a2                	ld	ra,40(sp)
    8001e412:	7402                	ld	s0,32(sp)
    8001e414:	6145                	addi	sp,sp,48
    8001e416:	8082                	ret

000000008001e418 <vector_binsearch_descending>:

int vector_binsearch_descending(struct Vector *vec, uint64_t key) {
    8001e418:	7179                	addi	sp,sp,-48
    8001e41a:	f406                	sd	ra,40(sp)
    8001e41c:	f022                	sd	s0,32(sp)
    8001e41e:	1800                	addi	s0,sp,48
    8001e420:	fca43c23          	sd	a0,-40(s0)
    8001e424:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    8001e428:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec) - 1;
    8001e42c:	fd843503          	ld	a0,-40(s0)
    8001e430:	2ac000ef          	jal	ra,8001e6dc <vector_size>
    8001e434:	87aa                	mv	a5,a0
    8001e436:	2781                	sext.w	a5,a5
    8001e438:	37fd                	addiw	a5,a5,-1
    8001e43a:	2781                	sext.w	a5,a5
    8001e43c:	fef42423          	sw	a5,-24(s0)

    while (low <= high) {
    8001e440:	a0ad                	j	8001e4aa <vector_binsearch_descending+0x92>
        int mid = (low + high) / 2;
    8001e442:	fec42703          	lw	a4,-20(s0)
    8001e446:	fe842783          	lw	a5,-24(s0)
    8001e44a:	9fb9                	addw	a5,a5,a4
    8001e44c:	2781                	sext.w	a5,a5
    8001e44e:	01f7d71b          	srliw	a4,a5,0x1f
    8001e452:	9fb9                	addw	a5,a5,a4
    8001e454:	4017d79b          	sraiw	a5,a5,0x1
    8001e458:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) < key) {
    8001e45c:	fe442783          	lw	a5,-28(s0)
    8001e460:	85be                	mv	a1,a5
    8001e462:	fd843503          	ld	a0,-40(s0)
    8001e466:	b65ff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e46a:	872a                	mv	a4,a0
    8001e46c:	fd043783          	ld	a5,-48(s0)
    8001e470:	00f77863          	bgeu	a4,a5,8001e480 <vector_binsearch_descending+0x68>
            high = mid - 1;
    8001e474:	fe442783          	lw	a5,-28(s0)
    8001e478:	37fd                	addiw	a5,a5,-1
    8001e47a:	fef42423          	sw	a5,-24(s0)
    8001e47e:	a035                	j	8001e4aa <vector_binsearch_descending+0x92>
        }
        else if (vector_get_unchecked(vec, mid) > key) {
    8001e480:	fe442783          	lw	a5,-28(s0)
    8001e484:	85be                	mv	a1,a5
    8001e486:	fd843503          	ld	a0,-40(s0)
    8001e48a:	b41ff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e48e:	872a                	mv	a4,a0
    8001e490:	fd043783          	ld	a5,-48(s0)
    8001e494:	00e7f863          	bgeu	a5,a4,8001e4a4 <vector_binsearch_descending+0x8c>
            low = mid + 1;
    8001e498:	fe442783          	lw	a5,-28(s0)
    8001e49c:	2785                	addiw	a5,a5,1
    8001e49e:	fef42623          	sw	a5,-20(s0)
    8001e4a2:	a021                	j	8001e4aa <vector_binsearch_descending+0x92>
        }
        else {
            return mid;
    8001e4a4:	fe442783          	lw	a5,-28(s0)
    8001e4a8:	a811                	j	8001e4bc <vector_binsearch_descending+0xa4>
    while (low <= high) {
    8001e4aa:	fec42703          	lw	a4,-20(s0)
    8001e4ae:	fe842783          	lw	a5,-24(s0)
    8001e4b2:	2701                	sext.w	a4,a4
    8001e4b4:	2781                	sext.w	a5,a5
    8001e4b6:	f8e7d6e3          	bge	a5,a4,8001e442 <vector_binsearch_descending+0x2a>
        }
    }
    return -1;
    8001e4ba:	57fd                	li	a5,-1
}
    8001e4bc:	853e                	mv	a0,a5
    8001e4be:	70a2                	ld	ra,40(sp)
    8001e4c0:	7402                	ld	s0,32(sp)
    8001e4c2:	6145                	addi	sp,sp,48
    8001e4c4:	8082                	ret

000000008001e4c6 <vector_sort>:

void vector_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    8001e4c6:	1101                	addi	sp,sp,-32
    8001e4c8:	ec06                	sd	ra,24(sp)
    8001e4ca:	e822                	sd	s0,16(sp)
    8001e4cc:	1000                	addi	s0,sp,32
    8001e4ce:	fea43423          	sd	a0,-24(s0)
    8001e4d2:	feb43023          	sd	a1,-32(s0)
    vector_insertion_sort(vec, comp);
    8001e4d6:	fe043583          	ld	a1,-32(s0)
    8001e4da:	fe843503          	ld	a0,-24(s0)
    8001e4de:	10e000ef          	jal	ra,8001e5ec <vector_insertion_sort>
}
    8001e4e2:	0001                	nop
    8001e4e4:	60e2                	ld	ra,24(sp)
    8001e4e6:	6442                	ld	s0,16(sp)
    8001e4e8:	6105                	addi	sp,sp,32
    8001e4ea:	8082                	ret

000000008001e4ec <vector_selection_sort>:

void vector_selection_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    8001e4ec:	715d                	addi	sp,sp,-80
    8001e4ee:	e486                	sd	ra,72(sp)
    8001e4f0:	e0a2                	sd	s0,64(sp)
    8001e4f2:	fc26                	sd	s1,56(sp)
    8001e4f4:	0880                	addi	s0,sp,80
    8001e4f6:	faa43c23          	sd	a0,-72(s0)
    8001e4fa:	fab43823          	sd	a1,-80(s0)
    uint32_t i;
    uint32_t j;
    uint32_t min_idx;
    uint64_t tmp;

    for (i = 0;i < vector_size(vec);i++) {
    8001e4fe:	fc042e23          	sw	zero,-36(s0)
    8001e502:	a0d1                	j	8001e5c6 <vector_selection_sort+0xda>
        min_idx = i;
    8001e504:	fdc42783          	lw	a5,-36(s0)
    8001e508:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    8001e50c:	fdc42783          	lw	a5,-36(s0)
    8001e510:	2785                	addiw	a5,a5,1
    8001e512:	fcf42c23          	sw	a5,-40(s0)
    8001e516:	a0a9                	j	8001e560 <vector_selection_sort+0x74>
            if (!comp(vector_get_unchecked(vec, min_idx), vector_get_unchecked(vec, j))) {
    8001e518:	fd442783          	lw	a5,-44(s0)
    8001e51c:	85be                	mv	a1,a5
    8001e51e:	fb843503          	ld	a0,-72(s0)
    8001e522:	aa9ff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e526:	84aa                	mv	s1,a0
    8001e528:	fd842783          	lw	a5,-40(s0)
    8001e52c:	85be                	mv	a1,a5
    8001e52e:	fb843503          	ld	a0,-72(s0)
    8001e532:	a99ff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e536:	87aa                	mv	a5,a0
    8001e538:	fb043703          	ld	a4,-80(s0)
    8001e53c:	85be                	mv	a1,a5
    8001e53e:	8526                	mv	a0,s1
    8001e540:	9702                	jalr	a4
    8001e542:	87aa                	mv	a5,a0
    8001e544:	0017c793          	xori	a5,a5,1
    8001e548:	0ff7f793          	andi	a5,a5,255
    8001e54c:	c789                	beqz	a5,8001e556 <vector_selection_sort+0x6a>
                min_idx = j;
    8001e54e:	fd842783          	lw	a5,-40(s0)
    8001e552:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    8001e556:	fd842783          	lw	a5,-40(s0)
    8001e55a:	2785                	addiw	a5,a5,1
    8001e55c:	fcf42c23          	sw	a5,-40(s0)
    8001e560:	fb843503          	ld	a0,-72(s0)
    8001e564:	178000ef          	jal	ra,8001e6dc <vector_size>
    8001e568:	87aa                	mv	a5,a0
    8001e56a:	0007871b          	sext.w	a4,a5
    8001e56e:	fd842783          	lw	a5,-40(s0)
    8001e572:	2781                	sext.w	a5,a5
    8001e574:	fae7e2e3          	bltu	a5,a4,8001e518 <vector_selection_sort+0x2c>
            }
        }
        tmp = vector_get_unchecked(vec, i);
    8001e578:	fdc42783          	lw	a5,-36(s0)
    8001e57c:	85be                	mv	a1,a5
    8001e57e:	fb843503          	ld	a0,-72(s0)
    8001e582:	a49ff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e586:	fca43423          	sd	a0,-56(s0)
        vector_set(vec, i, vector_get_unchecked(vec, min_idx));
    8001e58a:	fd442783          	lw	a5,-44(s0)
    8001e58e:	85be                	mv	a1,a5
    8001e590:	fb843503          	ld	a0,-72(s0)
    8001e594:	a37ff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e598:	872a                	mv	a4,a0
    8001e59a:	fdc42783          	lw	a5,-36(s0)
    8001e59e:	863a                	mv	a2,a4
    8001e5a0:	85be                	mv	a1,a5
    8001e5a2:	fb843503          	ld	a0,-72(s0)
    8001e5a6:	991ff0ef          	jal	ra,8001df36 <vector_set>
        vector_set(vec, min_idx, tmp);
    8001e5aa:	fd442783          	lw	a5,-44(s0)
    8001e5ae:	fc843603          	ld	a2,-56(s0)
    8001e5b2:	85be                	mv	a1,a5
    8001e5b4:	fb843503          	ld	a0,-72(s0)
    8001e5b8:	97fff0ef          	jal	ra,8001df36 <vector_set>
    for (i = 0;i < vector_size(vec);i++) {
    8001e5bc:	fdc42783          	lw	a5,-36(s0)
    8001e5c0:	2785                	addiw	a5,a5,1
    8001e5c2:	fcf42e23          	sw	a5,-36(s0)
    8001e5c6:	fb843503          	ld	a0,-72(s0)
    8001e5ca:	112000ef          	jal	ra,8001e6dc <vector_size>
    8001e5ce:	87aa                	mv	a5,a0
    8001e5d0:	0007871b          	sext.w	a4,a5
    8001e5d4:	fdc42783          	lw	a5,-36(s0)
    8001e5d8:	2781                	sext.w	a5,a5
    8001e5da:	f2e7e5e3          	bltu	a5,a4,8001e504 <vector_selection_sort+0x18>
    }
}
    8001e5de:	0001                	nop
    8001e5e0:	0001                	nop
    8001e5e2:	60a6                	ld	ra,72(sp)
    8001e5e4:	6406                	ld	s0,64(sp)
    8001e5e6:	74e2                	ld	s1,56(sp)
    8001e5e8:	6161                	addi	sp,sp,80
    8001e5ea:	8082                	ret

000000008001e5ec <vector_insertion_sort>:

void vector_insertion_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    8001e5ec:	715d                	addi	sp,sp,-80
    8001e5ee:	e486                	sd	ra,72(sp)
    8001e5f0:	e0a2                	sd	s0,64(sp)
    8001e5f2:	fc26                	sd	s1,56(sp)
    8001e5f4:	0880                	addi	s0,sp,80
    8001e5f6:	faa43c23          	sd	a0,-72(s0)
    8001e5fa:	fab43823          	sd	a1,-80(s0)
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    8001e5fe:	4785                	li	a5,1
    8001e600:	fcf42e23          	sw	a5,-36(s0)
    8001e604:	a84d                	j	8001e6b6 <vector_insertion_sort+0xca>
        uint32_t j = i;
    8001e606:	fdc42783          	lw	a5,-36(s0)
    8001e60a:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    8001e60e:	a8b1                	j	8001e66a <vector_insertion_sort+0x7e>
            uint64_t left = vector_get_unchecked(vec, j - 1);
    8001e610:	fd842783          	lw	a5,-40(s0)
    8001e614:	37fd                	addiw	a5,a5,-1
    8001e616:	2781                	sext.w	a5,a5
    8001e618:	85be                	mv	a1,a5
    8001e61a:	fb843503          	ld	a0,-72(s0)
    8001e61e:	9adff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e622:	fca43823          	sd	a0,-48(s0)
            uint64_t right = vector_get_unchecked(vec, j);
    8001e626:	fd842783          	lw	a5,-40(s0)
    8001e62a:	85be                	mv	a1,a5
    8001e62c:	fb843503          	ld	a0,-72(s0)
    8001e630:	99bff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e634:	fca43423          	sd	a0,-56(s0)

            vector_set(vec, j, left);
    8001e638:	fd842783          	lw	a5,-40(s0)
    8001e63c:	fd043603          	ld	a2,-48(s0)
    8001e640:	85be                	mv	a1,a5
    8001e642:	fb843503          	ld	a0,-72(s0)
    8001e646:	8f1ff0ef          	jal	ra,8001df36 <vector_set>
            vector_set(vec, j - 1, right);
    8001e64a:	fd842783          	lw	a5,-40(s0)
    8001e64e:	37fd                	addiw	a5,a5,-1
    8001e650:	2781                	sext.w	a5,a5
    8001e652:	fc843603          	ld	a2,-56(s0)
    8001e656:	85be                	mv	a1,a5
    8001e658:	fb843503          	ld	a0,-72(s0)
    8001e65c:	8dbff0ef          	jal	ra,8001df36 <vector_set>

            j -= 1;
    8001e660:	fd842783          	lw	a5,-40(s0)
    8001e664:	37fd                	addiw	a5,a5,-1
    8001e666:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    8001e66a:	fd842783          	lw	a5,-40(s0)
    8001e66e:	2781                	sext.w	a5,a5
    8001e670:	cf95                	beqz	a5,8001e6ac <vector_insertion_sort+0xc0>
    8001e672:	fd842783          	lw	a5,-40(s0)
    8001e676:	37fd                	addiw	a5,a5,-1
    8001e678:	2781                	sext.w	a5,a5
    8001e67a:	85be                	mv	a1,a5
    8001e67c:	fb843503          	ld	a0,-72(s0)
    8001e680:	94bff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e684:	84aa                	mv	s1,a0
    8001e686:	fd842783          	lw	a5,-40(s0)
    8001e68a:	85be                	mv	a1,a5
    8001e68c:	fb843503          	ld	a0,-72(s0)
    8001e690:	93bff0ef          	jal	ra,8001dfca <vector_get_unchecked>
    8001e694:	87aa                	mv	a5,a0
    8001e696:	fb043703          	ld	a4,-80(s0)
    8001e69a:	85be                	mv	a1,a5
    8001e69c:	8526                	mv	a0,s1
    8001e69e:	9702                	jalr	a4
    8001e6a0:	87aa                	mv	a5,a0
    8001e6a2:	0017c793          	xori	a5,a5,1
    8001e6a6:	0ff7f793          	andi	a5,a5,255
    8001e6aa:	f3bd                	bnez	a5,8001e610 <vector_insertion_sort+0x24>
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    8001e6ac:	fdc42783          	lw	a5,-36(s0)
    8001e6b0:	2785                	addiw	a5,a5,1
    8001e6b2:	fcf42e23          	sw	a5,-36(s0)
    8001e6b6:	fb843503          	ld	a0,-72(s0)
    8001e6ba:	022000ef          	jal	ra,8001e6dc <vector_size>
    8001e6be:	87aa                	mv	a5,a0
    8001e6c0:	0007871b          	sext.w	a4,a5
    8001e6c4:	fdc42783          	lw	a5,-36(s0)
    8001e6c8:	2781                	sext.w	a5,a5
    8001e6ca:	f2e7eee3          	bltu	a5,a4,8001e606 <vector_insertion_sort+0x1a>
        }
    }
}
    8001e6ce:	0001                	nop
    8001e6d0:	0001                	nop
    8001e6d2:	60a6                	ld	ra,72(sp)
    8001e6d4:	6406                	ld	s0,64(sp)
    8001e6d6:	74e2                	ld	s1,56(sp)
    8001e6d8:	6161                	addi	sp,sp,80
    8001e6da:	8082                	ret

000000008001e6dc <vector_size>:

uint32_t vector_size(Vector *vec) {
    8001e6dc:	1101                	addi	sp,sp,-32
    8001e6de:	ec22                	sd	s0,24(sp)
    8001e6e0:	1000                	addi	s0,sp,32
    8001e6e2:	fea43423          	sd	a0,-24(s0)
    return vec->size;
    8001e6e6:	fe843783          	ld	a5,-24(s0)
    8001e6ea:	439c                	lw	a5,0(a5)
}
    8001e6ec:	853e                	mv	a0,a5
    8001e6ee:	6462                	ld	s0,24(sp)
    8001e6f0:	6105                	addi	sp,sp,32
    8001e6f2:	8082                	ret

000000008001e6f4 <vector_capacity>:

uint32_t vector_capacity(Vector *vec) {
    8001e6f4:	1101                	addi	sp,sp,-32
    8001e6f6:	ec22                	sd	s0,24(sp)
    8001e6f8:	1000                	addi	s0,sp,32
    8001e6fa:	fea43423          	sd	a0,-24(s0)
    return vec->capacity;
    8001e6fe:	fe843783          	ld	a5,-24(s0)
    8001e702:	43dc                	lw	a5,4(a5)
}
    8001e704:	853e                	mv	a0,a5
    8001e706:	6462                	ld	s0,24(sp)
    8001e708:	6105                	addi	sp,sp,32
    8001e70a:	8082                	ret

000000008001e70c <vector_free>:

void vector_free(Vector *vec) {
    8001e70c:	1101                	addi	sp,sp,-32
    8001e70e:	ec06                	sd	ra,24(sp)
    8001e710:	e822                	sd	s0,16(sp)
    8001e712:	1000                	addi	s0,sp,32
    8001e714:	fea43423          	sd	a0,-24(s0)
    g_kfree(vec->values);
    8001e718:	fe843783          	ld	a5,-24(s0)
    8001e71c:	679c                	ld	a5,8(a5)
    8001e71e:	853e                	mv	a0,a5
    8001e720:	8f7fd0ef          	jal	ra,8001c016 <g_kfree>
    vec->size = 0;
    8001e724:	fe843783          	ld	a5,-24(s0)
    8001e728:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    8001e72c:	fe843783          	ld	a5,-24(s0)
    8001e730:	0007a223          	sw	zero,4(a5)
    g_kfree(vec);
    8001e734:	fe843503          	ld	a0,-24(s0)
    8001e738:	8dffd0ef          	jal	ra,8001c016 <g_kfree>
}
    8001e73c:	0001                	nop
    8001e73e:	60e2                	ld	ra,24(sp)
    8001e740:	6442                	ld	s0,16(sp)
    8001e742:	6105                	addi	sp,sp,32
    8001e744:	8082                	ret

000000008001e746 <vector_sort_signed_long_comparator_ascending>:

VECTOR_COMPARATOR(vector_sort_signed_long_comparator_ascending) {
    8001e746:	1101                	addi	sp,sp,-32
    8001e748:	ec22                	sd	s0,24(sp)
    8001e74a:	1000                	addi	s0,sp,32
    8001e74c:	fea43423          	sd	a0,-24(s0)
    8001e750:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    8001e754:	fe843703          	ld	a4,-24(s0)
    8001e758:	fe043783          	ld	a5,-32(s0)
    8001e75c:	00e7a7b3          	slt	a5,a5,a4
    8001e760:	0017c793          	xori	a5,a5,1
    8001e764:	0ff7f793          	andi	a5,a5,255
}
    8001e768:	853e                	mv	a0,a5
    8001e76a:	6462                	ld	s0,24(sp)
    8001e76c:	6105                	addi	sp,sp,32
    8001e76e:	8082                	ret

000000008001e770 <vector_sort_signed_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_signed_long_comparator_descending) {
    8001e770:	1101                	addi	sp,sp,-32
    8001e772:	ec22                	sd	s0,24(sp)
    8001e774:	1000                	addi	s0,sp,32
    8001e776:	fea43423          	sd	a0,-24(s0)
    8001e77a:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    8001e77e:	fe843703          	ld	a4,-24(s0)
    8001e782:	fe043783          	ld	a5,-32(s0)
    8001e786:	00f727b3          	slt	a5,a4,a5
    8001e78a:	0017c793          	xori	a5,a5,1
    8001e78e:	0ff7f793          	andi	a5,a5,255
}
    8001e792:	853e                	mv	a0,a5
    8001e794:	6462                	ld	s0,24(sp)
    8001e796:	6105                	addi	sp,sp,32
    8001e798:	8082                	ret

000000008001e79a <vector_sort_unsigned_long_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_ascending) {
    8001e79a:	1101                	addi	sp,sp,-32
    8001e79c:	ec22                	sd	s0,24(sp)
    8001e79e:	1000                	addi	s0,sp,32
    8001e7a0:	fea43423          	sd	a0,-24(s0)
    8001e7a4:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    8001e7a8:	fe843703          	ld	a4,-24(s0)
    8001e7ac:	fe043783          	ld	a5,-32(s0)
    8001e7b0:	00e7b7b3          	sltu	a5,a5,a4
    8001e7b4:	0017c793          	xori	a5,a5,1
    8001e7b8:	0ff7f793          	andi	a5,a5,255
}
    8001e7bc:	853e                	mv	a0,a5
    8001e7be:	6462                	ld	s0,24(sp)
    8001e7c0:	6105                	addi	sp,sp,32
    8001e7c2:	8082                	ret

000000008001e7c4 <vector_sort_unsigned_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_descending) {
    8001e7c4:	1101                	addi	sp,sp,-32
    8001e7c6:	ec22                	sd	s0,24(sp)
    8001e7c8:	1000                	addi	s0,sp,32
    8001e7ca:	fea43423          	sd	a0,-24(s0)
    8001e7ce:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    8001e7d2:	fe843703          	ld	a4,-24(s0)
    8001e7d6:	fe043783          	ld	a5,-32(s0)
    8001e7da:	00f737b3          	sltu	a5,a4,a5
    8001e7de:	0017c793          	xori	a5,a5,1
    8001e7e2:	0ff7f793          	andi	a5,a5,255
}
    8001e7e6:	853e                	mv	a0,a5
    8001e7e8:	6462                	ld	s0,24(sp)
    8001e7ea:	6105                	addi	sp,sp,32
    8001e7ec:	8082                	ret

000000008001e7ee <vector_sort_string_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_ascending) {
    8001e7ee:	1101                	addi	sp,sp,-32
    8001e7f0:	ec06                	sd	ra,24(sp)
    8001e7f2:	e822                	sd	s0,16(sp)
    8001e7f4:	1000                	addi	s0,sp,32
    8001e7f6:	fea43423          	sd	a0,-24(s0)
    8001e7fa:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    8001e7fe:	fe843783          	ld	a5,-24(s0)
    8001e802:	fe043703          	ld	a4,-32(s0)
    8001e806:	85ba                	mv	a1,a4
    8001e808:	853e                	mv	a0,a5
    8001e80a:	fb1fe0ef          	jal	ra,8001d7ba <strcmp>
    8001e80e:	87aa                	mv	a5,a0
    8001e810:	0017a793          	slti	a5,a5,1
    8001e814:	0ff7f793          	andi	a5,a5,255
}
    8001e818:	853e                	mv	a0,a5
    8001e81a:	60e2                	ld	ra,24(sp)
    8001e81c:	6442                	ld	s0,16(sp)
    8001e81e:	6105                	addi	sp,sp,32
    8001e820:	8082                	ret

000000008001e822 <vector_sort_string_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_descending) {
    8001e822:	1101                	addi	sp,sp,-32
    8001e824:	ec06                	sd	ra,24(sp)
    8001e826:	e822                	sd	s0,16(sp)
    8001e828:	1000                	addi	s0,sp,32
    8001e82a:	fea43423          	sd	a0,-24(s0)
    8001e82e:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    8001e832:	fe843783          	ld	a5,-24(s0)
    8001e836:	fe043703          	ld	a4,-32(s0)
    8001e83a:	85ba                	mv	a1,a4
    8001e83c:	853e                	mv	a0,a5
    8001e83e:	f7dfe0ef          	jal	ra,8001d7ba <strcmp>
    8001e842:	87aa                	mv	a5,a0
    8001e844:	fff7c793          	not	a5,a5
    8001e848:	01f7d79b          	srliw	a5,a5,0x1f
    8001e84c:	0ff7f793          	andi	a5,a5,255
}
    8001e850:	853e                	mv	a0,a5
    8001e852:	60e2                	ld	ra,24(sp)
    8001e854:	6442                	ld	s0,16(sp)
    8001e856:	6105                	addi	sp,sp,32
    8001e858:	8082                	ret
