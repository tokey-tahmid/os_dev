
cosc562.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000080010000 <_memory_start>:
    80010000:	fe22                	sd	s0,312(sp)
    80010002:	f1ca                	sd	s2,224(sp)
    80010004:	0bee                	slli	s7,s7,0x1b
    80010006:	dead                	beqz	a3,8000ff80 <i+0x8000ff60>
    80010008:	7260                	ld	s0,224(a2)
    8001000a:	8001                	c.srli64	s0
	...

0000000080010102 <copy_from>:
*/
unsigned long copy_from(void *dst, 
                        const struct page_table *from_table, 
                        const void *from, 
                        unsigned long size)
{
    80010102:	7119                	addi	sp,sp,-128
    80010104:	fc86                	sd	ra,120(sp)
    80010106:	f8a2                	sd	s0,112(sp)
    80010108:	0100                	addi	s0,sp,128
    8001010a:	f8a43c23          	sd	a0,-104(s0)
    8001010e:	f8b43823          	sd	a1,-112(s0)
    80010112:	f8c43423          	sd	a2,-120(s0)
    80010116:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    8001011a:	fe043423          	sd	zero,-24(s0)

    unsigned long src_start_addr = (unsigned long)from;
    8001011e:	f8843783          	ld	a5,-120(s0)
    80010122:	fcf43423          	sd	a5,-56(s0)
    unsigned long src_end_addr = (unsigned long)from+size;
    80010126:	f8843783          	ld	a5,-120(s0)
    8001012a:	f8043703          	ld	a4,-128(s0)
    8001012e:	97ba                	add	a5,a5,a4
    80010130:	fcf43023          	sd	a5,-64(s0)
    unsigned long src_first_page = ALIGN_DOWN_POT(src_start_addr, PAGE_SIZE_4K);
    80010134:	fc843703          	ld	a4,-56(s0)
    80010138:	77fd                	lui	a5,0xfffff
    8001013a:	8ff9                	and	a5,a5,a4
    8001013c:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    80010140:	fb843783          	ld	a5,-72(s0)
    80010144:	fef43023          	sd	a5,-32(s0)
    80010148:	a06d                	j	800101f2 <copy_from+0xf0>
        void *physical_address = (void*)mmu_translate(from_table, i);
    8001014a:	fe043583          	ld	a1,-32(s0)
    8001014e:	f9043503          	ld	a0,-112(s0)
    80010152:	2db030ef          	jal	ra,80013c2c <mmu_translate>
    80010156:	87aa                	mv	a5,a0
    80010158:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    8001015c:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == src_start_addr;
    80010160:	fe043703          	ld	a4,-32(s0)
    80010164:	fc843783          	ld	a5,-56(s0)
    80010168:	40f707b3          	sub	a5,a4,a5
    8001016c:	0017b793          	seqz	a5,a5
    80010170:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    80010174:	faf44783          	lbu	a5,-81(s0)
    80010178:	0ff7f793          	andi	a5,a5,255
    8001017c:	cb81                	beqz	a5,8001018c <copy_from+0x8a>
            offset = src_start_addr % PAGE_SIZE_4K;
    8001017e:	fc843703          	ld	a4,-56(s0)
    80010182:	6785                	lui	a5,0x1
    80010184:	17fd                	addi	a5,a5,-1
    80010186:	8ff9                	and	a5,a5,a4
    80010188:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    8001018c:	6785                	lui	a5,0x1
    8001018e:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > src_end_addr) {
    80010192:	fe043703          	ld	a4,-32(s0)
    80010196:	6785                	lui	a5,0x1
    80010198:	97ba                	add	a5,a5,a4
    8001019a:	fc043703          	ld	a4,-64(s0)
    8001019e:	00f77a63          	bgeu	a4,a5,800101b2 <copy_from+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = src_end_addr - i;
    800101a2:	fc043703          	ld	a4,-64(s0)
    800101a6:	fe043783          	ld	a5,-32(s0)
    800101aa:	40f707b3          	sub	a5,a4,a5
    800101ae:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(dst + bytes_copied, physical_address + offset, bytes_to_copy_from_page);
    800101b2:	f9843703          	ld	a4,-104(s0)
    800101b6:	fe843783          	ld	a5,-24(s0)
    800101ba:	00f706b3          	add	a3,a4,a5
    800101be:	fb043703          	ld	a4,-80(s0)
    800101c2:	fd843783          	ld	a5,-40(s0)
    800101c6:	97ba                	add	a5,a5,a4
    800101c8:	fd043703          	ld	a4,-48(s0)
    800101cc:	2701                	sext.w	a4,a4
    800101ce:	863a                	mv	a2,a4
    800101d0:	85be                	mv	a1,a5
    800101d2:	8536                	mv	a0,a3
    800101d4:	161070ef          	jal	ra,80017b34 <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800101d8:	fe843703          	ld	a4,-24(s0)
    800101dc:	fd043783          	ld	a5,-48(s0)
    800101e0:	97ba                	add	a5,a5,a4
    800101e2:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    800101e6:	fe043703          	ld	a4,-32(s0)
    800101ea:	6785                	lui	a5,0x1
    800101ec:	97ba                	add	a5,a5,a4
    800101ee:	fef43023          	sd	a5,-32(s0)
    800101f2:	fe043703          	ld	a4,-32(s0)
    800101f6:	fc043783          	ld	a5,-64(s0)
    800101fa:	f4f768e3          	bltu	a4,a5,8001014a <copy_from+0x48>
    }

    return bytes_copied;
    800101fe:	fe843783          	ld	a5,-24(s0)
}
    80010202:	853e                	mv	a0,a5
    80010204:	70e6                	ld	ra,120(sp)
    80010206:	7446                	ld	s0,112(sp)
    80010208:	6109                	addi	sp,sp,128
    8001020a:	8082                	ret

000000008001020c <copy_to>:
*/
unsigned long copy_to(void *to, 
                      const struct page_table *to_table, 
                      const void *src, 
                      unsigned long size)
{
    8001020c:	7119                	addi	sp,sp,-128
    8001020e:	fc86                	sd	ra,120(sp)
    80010210:	f8a2                	sd	s0,112(sp)
    80010212:	0100                	addi	s0,sp,128
    80010214:	f8a43c23          	sd	a0,-104(s0)
    80010218:	f8b43823          	sd	a1,-112(s0)
    8001021c:	f8c43423          	sd	a2,-120(s0)
    80010220:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    80010224:	fe043423          	sd	zero,-24(s0)

    unsigned long dst_start_addr = (unsigned long)to;
    80010228:	f9843783          	ld	a5,-104(s0)
    8001022c:	fcf43423          	sd	a5,-56(s0)
    unsigned long dst_end_addr = (unsigned long)to+size;
    80010230:	f9843783          	ld	a5,-104(s0)
    80010234:	f8043703          	ld	a4,-128(s0)
    80010238:	97ba                	add	a5,a5,a4
    8001023a:	fcf43023          	sd	a5,-64(s0)
    unsigned long dst_first_page = ALIGN_DOWN_POT(dst_start_addr, PAGE_SIZE_4K);
    8001023e:	fc843703          	ld	a4,-56(s0)
    80010242:	77fd                	lui	a5,0xfffff
    80010244:	8ff9                	and	a5,a5,a4
    80010246:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    8001024a:	fb843783          	ld	a5,-72(s0)
    8001024e:	fef43023          	sd	a5,-32(s0)
    80010252:	a06d                	j	800102fc <copy_to+0xf0>
        void *physical_address = (void*)mmu_translate(to_table, i);
    80010254:	fe043583          	ld	a1,-32(s0)
    80010258:	f9043503          	ld	a0,-112(s0)
    8001025c:	1d1030ef          	jal	ra,80013c2c <mmu_translate>
    80010260:	87aa                	mv	a5,a0
    80010262:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    80010266:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == dst_start_addr;
    8001026a:	fe043703          	ld	a4,-32(s0)
    8001026e:	fc843783          	ld	a5,-56(s0)
    80010272:	40f707b3          	sub	a5,a4,a5
    80010276:	0017b793          	seqz	a5,a5
    8001027a:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    8001027e:	faf44783          	lbu	a5,-81(s0)
    80010282:	0ff7f793          	andi	a5,a5,255
    80010286:	cb81                	beqz	a5,80010296 <copy_to+0x8a>
            offset = dst_start_addr % PAGE_SIZE_4K;
    80010288:	fc843703          	ld	a4,-56(s0)
    8001028c:	6785                	lui	a5,0x1
    8001028e:	17fd                	addi	a5,a5,-1
    80010290:	8ff9                	and	a5,a5,a4
    80010292:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    80010296:	6785                	lui	a5,0x1
    80010298:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > dst_end_addr) {
    8001029c:	fe043703          	ld	a4,-32(s0)
    800102a0:	6785                	lui	a5,0x1
    800102a2:	97ba                	add	a5,a5,a4
    800102a4:	fc043703          	ld	a4,-64(s0)
    800102a8:	00f77a63          	bgeu	a4,a5,800102bc <copy_to+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = dst_end_addr - i;
    800102ac:	fc043703          	ld	a4,-64(s0)
    800102b0:	fe043783          	ld	a5,-32(s0)
    800102b4:	40f707b3          	sub	a5,a4,a5
    800102b8:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(physical_address + offset, src + bytes_copied, bytes_to_copy_from_page);
    800102bc:	fb043703          	ld	a4,-80(s0)
    800102c0:	fd843783          	ld	a5,-40(s0)
    800102c4:	00f706b3          	add	a3,a4,a5
    800102c8:	f8843703          	ld	a4,-120(s0)
    800102cc:	fe843783          	ld	a5,-24(s0)
    800102d0:	97ba                	add	a5,a5,a4
    800102d2:	fd043703          	ld	a4,-48(s0)
    800102d6:	2701                	sext.w	a4,a4
    800102d8:	863a                	mv	a2,a4
    800102da:	85be                	mv	a1,a5
    800102dc:	8536                	mv	a0,a3
    800102de:	057070ef          	jal	ra,80017b34 <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800102e2:	fe843703          	ld	a4,-24(s0)
    800102e6:	fd043783          	ld	a5,-48(s0)
    800102ea:	97ba                	add	a5,a5,a4
    800102ec:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    800102f0:	fe043703          	ld	a4,-32(s0)
    800102f4:	6785                	lui	a5,0x1
    800102f6:	97ba                	add	a5,a5,a4
    800102f8:	fef43023          	sd	a5,-32(s0)
    800102fc:	fe043703          	ld	a4,-32(s0)
    80010300:	fc043783          	ld	a5,-64(s0)
    80010304:	f4f768e3          	bltu	a4,a5,80010254 <copy_to+0x48>
    }

    return bytes_copied;
    80010308:	fe843783          	ld	a5,-24(s0)
    8001030c:	853e                	mv	a0,a5
    8001030e:	70e6                	ld	ra,120(sp)
    80010310:	7446                	ld	s0,112(sp)
    80010312:	6109                	addi	sp,sp,128
    80010314:	8082                	ret

0000000080010316 <syscall_exit>:
    (void)hart;         \
    (void)epc;          \
    (void)scratch

SYSCALL(exit)
{
    80010316:	7179                	addi	sp,sp,-48
    80010318:	f422                	sd	s0,40(sp)
    8001031a:	1800                	addi	s0,sp,48
    8001031c:	87aa                	mv	a5,a0
    8001031e:	feb43023          	sd	a1,-32(s0)
    80010322:	fcc43c23          	sd	a2,-40(s0)
    80010326:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Kill the current process on this HART and schedule the next
    // one.
}
    8001032a:	0001                	nop
    8001032c:	7422                	ld	s0,40(sp)
    8001032e:	6145                	addi	sp,sp,48
    80010330:	8082                	ret

0000000080010332 <syscall_putchar>:

SYSCALL(putchar)
{
    80010332:	7179                	addi	sp,sp,-48
    80010334:	f406                	sd	ra,40(sp)
    80010336:	f022                	sd	s0,32(sp)
    80010338:	1800                	addi	s0,sp,48
    8001033a:	87aa                	mv	a5,a0
    8001033c:	feb43023          	sd	a1,-32(s0)
    80010340:	fcc43c23          	sd	a2,-40(s0)
    80010344:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    sbi_putchar(XREG(A0));
    80010348:	fd843783          	ld	a5,-40(s0)
    8001034c:	05078793          	addi	a5,a5,80 # 1050 <i+0x1030>
    80010350:	639c                	ld	a5,0(a5)
    80010352:	0ff7f793          	andi	a5,a5,255
    80010356:	853e                	mv	a0,a5
    80010358:	3da050ef          	jal	ra,80015732 <sbi_putchar>
}
    8001035c:	0001                	nop
    8001035e:	70a2                	ld	ra,40(sp)
    80010360:	7402                	ld	s0,32(sp)
    80010362:	6145                	addi	sp,sp,48
    80010364:	8082                	ret

0000000080010366 <syscall_getchar>:

SYSCALL(getchar)
{
    80010366:	7179                	addi	sp,sp,-48
    80010368:	f406                	sd	ra,40(sp)
    8001036a:	f022                	sd	s0,32(sp)
    8001036c:	1800                	addi	s0,sp,48
    8001036e:	87aa                	mv	a5,a0
    80010370:	feb43023          	sd	a1,-32(s0)
    80010374:	fcc43c23          	sd	a2,-40(s0)
    80010378:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    XREG(A0) = sbi_getchar();
    8001037c:	3d8050ef          	jal	ra,80015754 <sbi_getchar>
    80010380:	87aa                	mv	a5,a0
    80010382:	873e                	mv	a4,a5
    80010384:	fd843783          	ld	a5,-40(s0)
    80010388:	05078793          	addi	a5,a5,80
    8001038c:	e398                	sd	a4,0(a5)
}
    8001038e:	0001                	nop
    80010390:	70a2                	ld	ra,40(sp)
    80010392:	7402                	ld	s0,32(sp)
    80010394:	6145                	addi	sp,sp,48
    80010396:	8082                	ret

0000000080010398 <syscall_yield>:

SYSCALL(yield)
{
    80010398:	7179                	addi	sp,sp,-48
    8001039a:	f422                	sd	s0,40(sp)
    8001039c:	1800                	addi	s0,sp,48
    8001039e:	87aa                	mv	a5,a0
    800103a0:	feb43023          	sd	a1,-32(s0)
    800103a4:	fcc43c23          	sd	a2,-40(s0)
    800103a8:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // sched_invoke(hart);
}
    800103ac:	0001                	nop
    800103ae:	7422                	ld	s0,40(sp)
    800103b0:	6145                	addi	sp,sp,48
    800103b2:	8082                	ret

00000000800103b4 <syscall_sleep>:

SYSCALL(sleep)
{
    800103b4:	7179                	addi	sp,sp,-48
    800103b6:	f422                	sd	s0,40(sp)
    800103b8:	1800                	addi	s0,sp,48
    800103ba:	87aa                	mv	a5,a0
    800103bc:	feb43023          	sd	a1,-32(s0)
    800103c0:	fcc43c23          	sd	a2,-40(s0)
    800103c4:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Sleep the process. VIRT_TIMER_FREQ is 10MHz, divided by 1000, we get 10KHz
    //     p->sleep_until = sbi_get_time() + XREG(A0) * VIRT_TIMER_FREQ / 1000;
    //     p->state = PS_SLEEPING;
}
    800103c8:	0001                	nop
    800103ca:	7422                	ld	s0,40(sp)
    800103cc:	6145                	addi	sp,sp,48
    800103ce:	8082                	ret

00000000800103d0 <syscall_events>:

SYSCALL(events)
{
    800103d0:	7179                	addi	sp,sp,-48
    800103d2:	f422                	sd	s0,40(sp)
    800103d4:	1800                	addi	s0,sp,48
    800103d6:	87aa                	mv	a5,a0
    800103d8:	feb43023          	sd	a1,-32(s0)
    800103dc:	fcc43c23          	sd	a2,-40(s0)
    800103e0:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    
}
    800103e4:	0001                	nop
    800103e6:	7422                	ld	s0,40(sp)
    800103e8:	6145                	addi	sp,sp,48
    800103ea:	8082                	ret

00000000800103ec <syscall_handle>:

static const int NUM_SYSCALLS = sizeof(SYSCALLS) / sizeof(SYSCALLS[0]);

// We get here from the trap.c if this is an ECALL from U-MODE
void syscall_handle(int hart, uint64_t epc, int64_t *scratch)
{
    800103ec:	7179                	addi	sp,sp,-48
    800103ee:	f406                	sd	ra,40(sp)
    800103f0:	f022                	sd	s0,32(sp)
    800103f2:	1800                	addi	s0,sp,48
    800103f4:	87aa                	mv	a5,a0
    800103f6:	feb43023          	sd	a1,-32(s0)
    800103fa:	fcc43c23          	sd	a2,-40(s0)
    800103fe:	fef42623          	sw	a5,-20(s0)
    // Sched invoke will save sepc, so we want it to resume
    // 4 bytes ahead, which will be the next instruction.
    CSR_WRITE("sepc", epc + 4);
    80010402:	fe043783          	ld	a5,-32(s0)
    80010406:	0791                	addi	a5,a5,4
    80010408:	14179073          	csrw	sepc,a5

    if (XREG(A7) >= NUM_SYSCALLS || SYSCALLS[XREG(A7)] == NULL) {
    8001040c:	fd843783          	ld	a5,-40(s0)
    80010410:	08878793          	addi	a5,a5,136
    80010414:	639c                	ld	a5,0(a5)
    80010416:	4719                	li	a4,6
    80010418:	00e7df63          	bge	a5,a4,80010436 <syscall_handle+0x4a>
    8001041c:	fd843783          	ld	a5,-40(s0)
    80010420:	08878793          	addi	a5,a5,136
    80010424:	639c                	ld	a5,0(a5)
    80010426:	0000b717          	auipc	a4,0xb
    8001042a:	bda70713          	addi	a4,a4,-1062 # 8001b000 <SYSCALLS>
    8001042e:	078e                	slli	a5,a5,0x3
    80010430:	97ba                	add	a5,a5,a4
    80010432:	639c                	ld	a5,0(a5)
    80010434:	eb81                	bnez	a5,80010444 <syscall_handle+0x58>
        // Invalid syscall
        XREG(A0) = -EINVAL;
    80010436:	fd843783          	ld	a5,-40(s0)
    8001043a:	05078793          	addi	a5,a5,80
    8001043e:	5729                	li	a4,-22
    80010440:	e398                	sd	a4,0(a5)
    80010442:	a035                	j	8001046e <syscall_handle+0x82>
    }
    else {
        SYSCALL_EXEC(XREG(A7));
    80010444:	fd843783          	ld	a5,-40(s0)
    80010448:	08878793          	addi	a5,a5,136
    8001044c:	639c                	ld	a5,0(a5)
    8001044e:	0000b717          	auipc	a4,0xb
    80010452:	bb270713          	addi	a4,a4,-1102 # 8001b000 <SYSCALLS>
    80010456:	078e                	slli	a5,a5,0x3
    80010458:	97ba                	add	a5,a5,a4
    8001045a:	6398                	ld	a4,0(a5)
    8001045c:	fec42783          	lw	a5,-20(s0)
    80010460:	fd843603          	ld	a2,-40(s0)
    80010464:	fe043583          	ld	a1,-32(s0)
    80010468:	853e                	mv	a0,a5
    8001046a:	9702                	jalr	a4
    }
}
    8001046c:	0001                	nop
    8001046e:	0001                	nop
    80010470:	70a2                	ld	ra,40(sp)
    80010472:	7402                	ld	s0,32(sp)
    80010474:	6145                	addi	sp,sp,48
    80010476:	8082                	ret

0000000080010478 <_putchar>:
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#include "sbi.h"
void _putchar(char c) { sbi_putchar(c); }
    80010478:	1101                	addi	sp,sp,-32
    8001047a:	ec06                	sd	ra,24(sp)
    8001047c:	e822                	sd	s0,16(sp)
    8001047e:	1000                	addi	s0,sp,32
    80010480:	87aa                	mv	a5,a0
    80010482:	fef407a3          	sb	a5,-17(s0)
    80010486:	fef44783          	lbu	a5,-17(s0)
    8001048a:	853e                	mv	a0,a5
    8001048c:	2a6050ef          	jal	ra,80015732 <sbi_putchar>
    80010490:	0001                	nop
    80010492:	60e2                	ld	ra,24(sp)
    80010494:	6442                	ld	s0,16(sp)
    80010496:	6105                	addi	sp,sp,32
    80010498:	8082                	ret

000000008001049a <_out_buffer>:
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx,
                               size_t maxlen)
{
    8001049a:	7179                	addi	sp,sp,-48
    8001049c:	f422                	sd	s0,40(sp)
    8001049e:	1800                	addi	s0,sp,48
    800104a0:	87aa                	mv	a5,a0
    800104a2:	feb43023          	sd	a1,-32(s0)
    800104a6:	fcc43c23          	sd	a2,-40(s0)
    800104aa:	fcd43823          	sd	a3,-48(s0)
    800104ae:	fef407a3          	sb	a5,-17(s0)
    if (idx < maxlen) {
    800104b2:	fd843703          	ld	a4,-40(s0)
    800104b6:	fd043783          	ld	a5,-48(s0)
    800104ba:	00f77b63          	bgeu	a4,a5,800104d0 <_out_buffer+0x36>
        ((char *)buffer)[idx] = character;
    800104be:	fe043703          	ld	a4,-32(s0)
    800104c2:	fd843783          	ld	a5,-40(s0)
    800104c6:	97ba                	add	a5,a5,a4
    800104c8:	fef44703          	lbu	a4,-17(s0)
    800104cc:	00e78023          	sb	a4,0(a5)
    }
}
    800104d0:	0001                	nop
    800104d2:	7422                	ld	s0,40(sp)
    800104d4:	6145                	addi	sp,sp,48
    800104d6:	8082                	ret

00000000800104d8 <_out_null>:

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800104d8:	7179                	addi	sp,sp,-48
    800104da:	f422                	sd	s0,40(sp)
    800104dc:	1800                	addi	s0,sp,48
    800104de:	87aa                	mv	a5,a0
    800104e0:	feb43023          	sd	a1,-32(s0)
    800104e4:	fcc43c23          	sd	a2,-40(s0)
    800104e8:	fcd43823          	sd	a3,-48(s0)
    800104ec:	fef407a3          	sb	a5,-17(s0)
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}
    800104f0:	0001                	nop
    800104f2:	7422                	ld	s0,40(sp)
    800104f4:	6145                	addi	sp,sp,48
    800104f6:	8082                	ret

00000000800104f8 <_out_char>:

// internal _putchar wrapper
static inline void _out_char(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800104f8:	7179                	addi	sp,sp,-48
    800104fa:	f406                	sd	ra,40(sp)
    800104fc:	f022                	sd	s0,32(sp)
    800104fe:	1800                	addi	s0,sp,48
    80010500:	87aa                	mv	a5,a0
    80010502:	feb43023          	sd	a1,-32(s0)
    80010506:	fcc43c23          	sd	a2,-40(s0)
    8001050a:	fcd43823          	sd	a3,-48(s0)
    8001050e:	fef407a3          	sb	a5,-17(s0)
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
    80010512:	fef44783          	lbu	a5,-17(s0)
    80010516:	0ff7f793          	andi	a5,a5,255
    8001051a:	c791                	beqz	a5,80010526 <_out_char+0x2e>
        _putchar(character);
    8001051c:	fef44783          	lbu	a5,-17(s0)
    80010520:	853e                	mv	a0,a5
    80010522:	f57ff0ef          	jal	ra,80010478 <_putchar>
    }
}
    80010526:	0001                	nop
    80010528:	70a2                	ld	ra,40(sp)
    8001052a:	7402                	ld	s0,32(sp)
    8001052c:	6145                	addi	sp,sp,48
    8001052e:	8082                	ret

0000000080010530 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx,
                            size_t maxlen)
{
    80010530:	7179                	addi	sp,sp,-48
    80010532:	f406                	sd	ra,40(sp)
    80010534:	f022                	sd	s0,32(sp)
    80010536:	1800                	addi	s0,sp,48
    80010538:	87aa                	mv	a5,a0
    8001053a:	feb43023          	sd	a1,-32(s0)
    8001053e:	fcc43c23          	sd	a2,-40(s0)
    80010542:	fcd43823          	sd	a3,-48(s0)
    80010546:	fef407a3          	sb	a5,-17(s0)
    (void)idx;
    (void)maxlen;
    if (character) {
    8001054a:	fef44783          	lbu	a5,-17(s0)
    8001054e:	0ff7f793          	andi	a5,a5,255
    80010552:	cf81                	beqz	a5,8001056a <_out_fct+0x3a>
        // buffer is the output fct pointer
        ((out_fct_wrap_type *)buffer)
            ->fct(character, ((out_fct_wrap_type *)buffer)->arg);
    80010554:	fe043783          	ld	a5,-32(s0)
    80010558:	6394                	ld	a3,0(a5)
        ((out_fct_wrap_type *)buffer)
    8001055a:	fe043783          	ld	a5,-32(s0)
    8001055e:	6798                	ld	a4,8(a5)
    80010560:	fef44783          	lbu	a5,-17(s0)
    80010564:	85ba                	mv	a1,a4
    80010566:	853e                	mv	a0,a5
    80010568:	9682                	jalr	a3
    }
}
    8001056a:	0001                	nop
    8001056c:	70a2                	ld	ra,40(sp)
    8001056e:	7402                	ld	s0,32(sp)
    80010570:	6145                	addi	sp,sp,48
    80010572:	8082                	ret

0000000080010574 <_strnlen_s>:

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize)
{
    80010574:	7179                	addi	sp,sp,-48
    80010576:	f422                	sd	s0,40(sp)
    80010578:	1800                	addi	s0,sp,48
    8001057a:	fca43c23          	sd	a0,-40(s0)
    8001057e:	fcb43823          	sd	a1,-48(s0)
    const char *s;
    for (s = str; *s && maxsize--; ++s)
    80010582:	fd843783          	ld	a5,-40(s0)
    80010586:	fef43423          	sd	a5,-24(s0)
    8001058a:	a031                	j	80010596 <_strnlen_s+0x22>
    8001058c:	fe843783          	ld	a5,-24(s0)
    80010590:	0785                	addi	a5,a5,1
    80010592:	fef43423          	sd	a5,-24(s0)
    80010596:	fe843783          	ld	a5,-24(s0)
    8001059a:	0007c783          	lbu	a5,0(a5)
    8001059e:	cb81                	beqz	a5,800105ae <_strnlen_s+0x3a>
    800105a0:	fd043783          	ld	a5,-48(s0)
    800105a4:	fff78713          	addi	a4,a5,-1
    800105a8:	fce43823          	sd	a4,-48(s0)
    800105ac:	f3e5                	bnez	a5,8001058c <_strnlen_s+0x18>
        ;
    return (unsigned int)(s - str);
    800105ae:	fe843703          	ld	a4,-24(s0)
    800105b2:	fd843783          	ld	a5,-40(s0)
    800105b6:	40f707b3          	sub	a5,a4,a5
    800105ba:	2781                	sext.w	a5,a5
}
    800105bc:	853e                	mv	a0,a5
    800105be:	7422                	ld	s0,40(sp)
    800105c0:	6145                	addi	sp,sp,48
    800105c2:	8082                	ret

00000000800105c4 <_is_digit>:

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) { return (ch >= '0') && (ch <= '9'); }
    800105c4:	1101                	addi	sp,sp,-32
    800105c6:	ec22                	sd	s0,24(sp)
    800105c8:	1000                	addi	s0,sp,32
    800105ca:	87aa                	mv	a5,a0
    800105cc:	fef407a3          	sb	a5,-17(s0)
    800105d0:	fef44783          	lbu	a5,-17(s0)
    800105d4:	0ff7f713          	andi	a4,a5,255
    800105d8:	02f00793          	li	a5,47
    800105dc:	00e7fc63          	bgeu	a5,a4,800105f4 <_is_digit+0x30>
    800105e0:	fef44783          	lbu	a5,-17(s0)
    800105e4:	0ff7f713          	andi	a4,a5,255
    800105e8:	03900793          	li	a5,57
    800105ec:	00e7e463          	bltu	a5,a4,800105f4 <_is_digit+0x30>
    800105f0:	4785                	li	a5,1
    800105f2:	a011                	j	800105f6 <_is_digit+0x32>
    800105f4:	4781                	li	a5,0
    800105f6:	8b85                	andi	a5,a5,1
    800105f8:	0ff7f793          	andi	a5,a5,255
    800105fc:	853e                	mv	a0,a5
    800105fe:	6462                	ld	s0,24(sp)
    80010600:	6105                	addi	sp,sp,32
    80010602:	8082                	ret

0000000080010604 <_atoi>:

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str)
{
    80010604:	7179                	addi	sp,sp,-48
    80010606:	f406                	sd	ra,40(sp)
    80010608:	f022                	sd	s0,32(sp)
    8001060a:	1800                	addi	s0,sp,48
    8001060c:	fca43c23          	sd	a0,-40(s0)
    unsigned int i = 0U;
    80010610:	fe042623          	sw	zero,-20(s0)
    while (_is_digit(**str)) {
    80010614:	a825                	j	8001064c <_atoi+0x48>
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
    80010616:	fec42703          	lw	a4,-20(s0)
    8001061a:	87ba                	mv	a5,a4
    8001061c:	0027979b          	slliw	a5,a5,0x2
    80010620:	9fb9                	addw	a5,a5,a4
    80010622:	0017979b          	slliw	a5,a5,0x1
    80010626:	0007871b          	sext.w	a4,a5
    8001062a:	fd843783          	ld	a5,-40(s0)
    8001062e:	639c                	ld	a5,0(a5)
    80010630:	00178613          	addi	a2,a5,1
    80010634:	fd843683          	ld	a3,-40(s0)
    80010638:	e290                	sd	a2,0(a3)
    8001063a:	0007c783          	lbu	a5,0(a5)
    8001063e:	2781                	sext.w	a5,a5
    80010640:	9fb9                	addw	a5,a5,a4
    80010642:	2781                	sext.w	a5,a5
    80010644:	fd07879b          	addiw	a5,a5,-48
    80010648:	fef42623          	sw	a5,-20(s0)
    while (_is_digit(**str)) {
    8001064c:	fd843783          	ld	a5,-40(s0)
    80010650:	639c                	ld	a5,0(a5)
    80010652:	0007c783          	lbu	a5,0(a5)
    80010656:	853e                	mv	a0,a5
    80010658:	f6dff0ef          	jal	ra,800105c4 <_is_digit>
    8001065c:	87aa                	mv	a5,a0
    8001065e:	ffc5                	bnez	a5,80010616 <_atoi+0x12>
    }
    return i;
    80010660:	fec42783          	lw	a5,-20(s0)
}
    80010664:	853e                	mv	a0,a5
    80010666:	70a2                	ld	ra,40(sp)
    80010668:	7402                	ld	s0,32(sp)
    8001066a:	6145                	addi	sp,sp,48
    8001066c:	8082                	ret

000000008001066e <_out_rev>:

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx,
                       size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags)
{
    8001066e:	711d                	addi	sp,sp,-96
    80010670:	ec86                	sd	ra,88(sp)
    80010672:	e8a2                	sd	s0,80(sp)
    80010674:	1080                	addi	s0,sp,96
    80010676:	fca43c23          	sd	a0,-40(s0)
    8001067a:	fcb43823          	sd	a1,-48(s0)
    8001067e:	fcc43423          	sd	a2,-56(s0)
    80010682:	fcd43023          	sd	a3,-64(s0)
    80010686:	fae43c23          	sd	a4,-72(s0)
    8001068a:	faf43823          	sd	a5,-80(s0)
    8001068e:	87c2                	mv	a5,a6
    80010690:	8746                	mv	a4,a7
    80010692:	faf42623          	sw	a5,-84(s0)
    80010696:	87ba                	mv	a5,a4
    80010698:	faf42423          	sw	a5,-88(s0)
    const size_t start_idx = idx;
    8001069c:	fc843783          	ld	a5,-56(s0)
    800106a0:	fef43023          	sd	a5,-32(s0)

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    800106a4:	fa842783          	lw	a5,-88(s0)
    800106a8:	8b89                	andi	a5,a5,2
    800106aa:	2781                	sext.w	a5,a5
    800106ac:	e3c9                	bnez	a5,8001072e <_out_rev+0xc0>
    800106ae:	fa842783          	lw	a5,-88(s0)
    800106b2:	8b85                	andi	a5,a5,1
    800106b4:	2781                	sext.w	a5,a5
    800106b6:	efa5                	bnez	a5,8001072e <_out_rev+0xc0>
        for (size_t i = len; i < width; i++) {
    800106b8:	fb043783          	ld	a5,-80(s0)
    800106bc:	fef43423          	sd	a5,-24(s0)
    800106c0:	a035                	j	800106ec <_out_rev+0x7e>
            out(' ', buffer, idx++, maxlen);
    800106c2:	fc843783          	ld	a5,-56(s0)
    800106c6:	00178713          	addi	a4,a5,1
    800106ca:	fce43423          	sd	a4,-56(s0)
    800106ce:	fd843703          	ld	a4,-40(s0)
    800106d2:	fc043683          	ld	a3,-64(s0)
    800106d6:	863e                	mv	a2,a5
    800106d8:	fd043583          	ld	a1,-48(s0)
    800106dc:	02000513          	li	a0,32
    800106e0:	9702                	jalr	a4
        for (size_t i = len; i < width; i++) {
    800106e2:	fe843783          	ld	a5,-24(s0)
    800106e6:	0785                	addi	a5,a5,1
    800106e8:	fef43423          	sd	a5,-24(s0)
    800106ec:	fac46783          	lwu	a5,-84(s0)
    800106f0:	fe843703          	ld	a4,-24(s0)
    800106f4:	fcf767e3          	bltu	a4,a5,800106c2 <_out_rev+0x54>
        }
    }

    // reverse string
    while (len) {
    800106f8:	a81d                	j	8001072e <_out_rev+0xc0>
        out(buf[--len], buffer, idx++, maxlen);
    800106fa:	fb043783          	ld	a5,-80(s0)
    800106fe:	17fd                	addi	a5,a5,-1
    80010700:	faf43823          	sd	a5,-80(s0)
    80010704:	fb843703          	ld	a4,-72(s0)
    80010708:	fb043783          	ld	a5,-80(s0)
    8001070c:	97ba                	add	a5,a5,a4
    8001070e:	0007c503          	lbu	a0,0(a5)
    80010712:	fc843783          	ld	a5,-56(s0)
    80010716:	00178713          	addi	a4,a5,1
    8001071a:	fce43423          	sd	a4,-56(s0)
    8001071e:	fd843703          	ld	a4,-40(s0)
    80010722:	fc043683          	ld	a3,-64(s0)
    80010726:	863e                	mv	a2,a5
    80010728:	fd043583          	ld	a1,-48(s0)
    8001072c:	9702                	jalr	a4
    while (len) {
    8001072e:	fb043783          	ld	a5,-80(s0)
    80010732:	f7e1                	bnez	a5,800106fa <_out_rev+0x8c>
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
    80010734:	fa842783          	lw	a5,-88(s0)
    80010738:	8b89                	andi	a5,a5,2
    8001073a:	2781                	sext.w	a5,a5
    8001073c:	cb9d                	beqz	a5,80010772 <_out_rev+0x104>
        while (idx - start_idx < width) {
    8001073e:	a00d                	j	80010760 <_out_rev+0xf2>
            out(' ', buffer, idx++, maxlen);
    80010740:	fc843783          	ld	a5,-56(s0)
    80010744:	00178713          	addi	a4,a5,1
    80010748:	fce43423          	sd	a4,-56(s0)
    8001074c:	fd843703          	ld	a4,-40(s0)
    80010750:	fc043683          	ld	a3,-64(s0)
    80010754:	863e                	mv	a2,a5
    80010756:	fd043583          	ld	a1,-48(s0)
    8001075a:	02000513          	li	a0,32
    8001075e:	9702                	jalr	a4
        while (idx - start_idx < width) {
    80010760:	fc843703          	ld	a4,-56(s0)
    80010764:	fe043783          	ld	a5,-32(s0)
    80010768:	8f1d                	sub	a4,a4,a5
    8001076a:	fac46783          	lwu	a5,-84(s0)
    8001076e:	fcf769e3          	bltu	a4,a5,80010740 <_out_rev+0xd2>
        }
    }

    return idx;
    80010772:	fc843783          	ld	a5,-56(s0)
}
    80010776:	853e                	mv	a0,a5
    80010778:	60e6                	ld	ra,88(sp)
    8001077a:	6446                	ld	s0,80(sp)
    8001077c:	6125                	addi	sp,sp,96
    8001077e:	8082                	ret

0000000080010780 <_ntoa_format>:
// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx,
                           size_t maxlen, char *buf, size_t len, bool negative,
                           unsigned int base, unsigned int prec,
                           unsigned int width, unsigned int flags)
{
    80010780:	715d                	addi	sp,sp,-80
    80010782:	e486                	sd	ra,72(sp)
    80010784:	e0a2                	sd	s0,64(sp)
    80010786:	0880                	addi	s0,sp,80
    80010788:	fea43423          	sd	a0,-24(s0)
    8001078c:	feb43023          	sd	a1,-32(s0)
    80010790:	fcc43c23          	sd	a2,-40(s0)
    80010794:	fcd43823          	sd	a3,-48(s0)
    80010798:	fce43423          	sd	a4,-56(s0)
    8001079c:	fcf43023          	sd	a5,-64(s0)
    800107a0:	87c2                	mv	a5,a6
    800107a2:	8746                	mv	a4,a7
    800107a4:	faf40fa3          	sb	a5,-65(s0)
    800107a8:	87ba                	mv	a5,a4
    800107aa:	faf42c23          	sw	a5,-72(s0)
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
    800107ae:	481c                	lw	a5,16(s0)
    800107b0:	8b89                	andi	a5,a5,2
    800107b2:	2781                	sext.w	a5,a5
    800107b4:	ebd1                	bnez	a5,80010848 <_ntoa_format+0xc8>
        if (width && (flags & FLAGS_ZEROPAD) &&
    800107b6:	441c                	lw	a5,8(s0)
    800107b8:	2781                	sext.w	a5,a5
    800107ba:	cf9d                	beqz	a5,800107f8 <_ntoa_format+0x78>
    800107bc:	481c                	lw	a5,16(s0)
    800107be:	8b85                	andi	a5,a5,1
    800107c0:	2781                	sext.w	a5,a5
    800107c2:	cb9d                	beqz	a5,800107f8 <_ntoa_format+0x78>
    800107c4:	fbf44783          	lbu	a5,-65(s0)
    800107c8:	0ff7f793          	andi	a5,a5,255
    800107cc:	e789                	bnez	a5,800107d6 <_ntoa_format+0x56>
            (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    800107ce:	481c                	lw	a5,16(s0)
    800107d0:	8bb1                	andi	a5,a5,12
    800107d2:	2781                	sext.w	a5,a5
    800107d4:	c395                	beqz	a5,800107f8 <_ntoa_format+0x78>
            width--;
    800107d6:	441c                	lw	a5,8(s0)
    800107d8:	37fd                	addiw	a5,a5,-1
    800107da:	c41c                	sw	a5,8(s0)
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800107dc:	a831                	j	800107f8 <_ntoa_format+0x78>
            buf[len++] = '0';
    800107de:	fc043783          	ld	a5,-64(s0)
    800107e2:	00178713          	addi	a4,a5,1
    800107e6:	fce43023          	sd	a4,-64(s0)
    800107ea:	fc843703          	ld	a4,-56(s0)
    800107ee:	97ba                	add	a5,a5,a4
    800107f0:	03000713          	li	a4,48
    800107f4:	00e78023          	sb	a4,0(a5)
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800107f8:	00046783          	lwu	a5,0(s0)
    800107fc:	fc043703          	ld	a4,-64(s0)
    80010800:	02f77563          	bgeu	a4,a5,8001082a <_ntoa_format+0xaa>
    80010804:	fc043703          	ld	a4,-64(s0)
    80010808:	47fd                	li	a5,31
    8001080a:	fce7fae3          	bgeu	a5,a4,800107de <_ntoa_format+0x5e>
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    8001080e:	a831                	j	8001082a <_ntoa_format+0xaa>
               (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
    80010810:	fc043783          	ld	a5,-64(s0)
    80010814:	00178713          	addi	a4,a5,1
    80010818:	fce43023          	sd	a4,-64(s0)
    8001081c:	fc843703          	ld	a4,-56(s0)
    80010820:	97ba                	add	a5,a5,a4
    80010822:	03000713          	li	a4,48
    80010826:	00e78023          	sb	a4,0(a5)
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    8001082a:	481c                	lw	a5,16(s0)
    8001082c:	8b85                	andi	a5,a5,1
    8001082e:	2781                	sext.w	a5,a5
    80010830:	cf81                	beqz	a5,80010848 <_ntoa_format+0xc8>
    80010832:	00846783          	lwu	a5,8(s0)
    80010836:	fc043703          	ld	a4,-64(s0)
    8001083a:	00f77763          	bgeu	a4,a5,80010848 <_ntoa_format+0xc8>
    8001083e:	fc043703          	ld	a4,-64(s0)
    80010842:	47fd                	li	a5,31
    80010844:	fce7f6e3          	bgeu	a5,a4,80010810 <_ntoa_format+0x90>
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
    80010848:	481c                	lw	a5,16(s0)
    8001084a:	8bc1                	andi	a5,a5,16
    8001084c:	2781                	sext.w	a5,a5
    8001084e:	12078363          	beqz	a5,80010974 <_ntoa_format+0x1f4>
        if (!(flags & FLAGS_PRECISION) && len &&
    80010852:	481c                	lw	a5,16(s0)
    80010854:	4007f793          	andi	a5,a5,1024
    80010858:	2781                	sext.w	a5,a5
    8001085a:	e7a1                	bnez	a5,800108a2 <_ntoa_format+0x122>
    8001085c:	fc043783          	ld	a5,-64(s0)
    80010860:	c3a9                	beqz	a5,800108a2 <_ntoa_format+0x122>
            ((len == prec) || (len == width))) {
    80010862:	00046783          	lwu	a5,0(s0)
        if (!(flags & FLAGS_PRECISION) && len &&
    80010866:	fc043703          	ld	a4,-64(s0)
    8001086a:	00f70863          	beq	a4,a5,8001087a <_ntoa_format+0xfa>
            ((len == prec) || (len == width))) {
    8001086e:	00846783          	lwu	a5,8(s0)
    80010872:	fc043703          	ld	a4,-64(s0)
    80010876:	02f71663          	bne	a4,a5,800108a2 <_ntoa_format+0x122>
            len--;
    8001087a:	fc043783          	ld	a5,-64(s0)
    8001087e:	17fd                	addi	a5,a5,-1
    80010880:	fcf43023          	sd	a5,-64(s0)
            if (len && (base == 16U)) {
    80010884:	fc043783          	ld	a5,-64(s0)
    80010888:	cf89                	beqz	a5,800108a2 <_ntoa_format+0x122>
    8001088a:	fb842783          	lw	a5,-72(s0)
    8001088e:	0007871b          	sext.w	a4,a5
    80010892:	47c1                	li	a5,16
    80010894:	00f71763          	bne	a4,a5,800108a2 <_ntoa_format+0x122>
                len--;
    80010898:	fc043783          	ld	a5,-64(s0)
    8001089c:	17fd                	addi	a5,a5,-1
    8001089e:	fcf43023          	sd	a5,-64(s0)
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) &&
    800108a2:	fb842783          	lw	a5,-72(s0)
    800108a6:	0007871b          	sext.w	a4,a5
    800108aa:	47c1                	li	a5,16
    800108ac:	02f71a63          	bne	a4,a5,800108e0 <_ntoa_format+0x160>
    800108b0:	481c                	lw	a5,16(s0)
    800108b2:	0207f793          	andi	a5,a5,32
    800108b6:	2781                	sext.w	a5,a5
    800108b8:	e785                	bnez	a5,800108e0 <_ntoa_format+0x160>
    800108ba:	fc043703          	ld	a4,-64(s0)
    800108be:	47fd                	li	a5,31
    800108c0:	02e7e063          	bltu	a5,a4,800108e0 <_ntoa_format+0x160>
            (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'x';
    800108c4:	fc043783          	ld	a5,-64(s0)
    800108c8:	00178713          	addi	a4,a5,1
    800108cc:	fce43023          	sd	a4,-64(s0)
    800108d0:	fc843703          	ld	a4,-56(s0)
    800108d4:	97ba                	add	a5,a5,a4
    800108d6:	07800713          	li	a4,120
    800108da:	00e78023          	sb	a4,0(a5)
    800108de:	a88d                	j	80010950 <_ntoa_format+0x1d0>
        }
        else if ((base == 16U) && (flags & FLAGS_UPPERCASE) &&
    800108e0:	fb842783          	lw	a5,-72(s0)
    800108e4:	0007871b          	sext.w	a4,a5
    800108e8:	47c1                	li	a5,16
    800108ea:	02f71a63          	bne	a4,a5,8001091e <_ntoa_format+0x19e>
    800108ee:	481c                	lw	a5,16(s0)
    800108f0:	0207f793          	andi	a5,a5,32
    800108f4:	2781                	sext.w	a5,a5
    800108f6:	c785                	beqz	a5,8001091e <_ntoa_format+0x19e>
    800108f8:	fc043703          	ld	a4,-64(s0)
    800108fc:	47fd                	li	a5,31
    800108fe:	02e7e063          	bltu	a5,a4,8001091e <_ntoa_format+0x19e>
                 (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'X';
    80010902:	fc043783          	ld	a5,-64(s0)
    80010906:	00178713          	addi	a4,a5,1
    8001090a:	fce43023          	sd	a4,-64(s0)
    8001090e:	fc843703          	ld	a4,-56(s0)
    80010912:	97ba                	add	a5,a5,a4
    80010914:	05800713          	li	a4,88
    80010918:	00e78023          	sb	a4,0(a5)
    8001091c:	a815                	j	80010950 <_ntoa_format+0x1d0>
        }
        else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    8001091e:	fb842783          	lw	a5,-72(s0)
    80010922:	0007871b          	sext.w	a4,a5
    80010926:	4789                	li	a5,2
    80010928:	02f71463          	bne	a4,a5,80010950 <_ntoa_format+0x1d0>
    8001092c:	fc043703          	ld	a4,-64(s0)
    80010930:	47fd                	li	a5,31
    80010932:	00e7ef63          	bltu	a5,a4,80010950 <_ntoa_format+0x1d0>
            buf[len++] = 'b';
    80010936:	fc043783          	ld	a5,-64(s0)
    8001093a:	00178713          	addi	a4,a5,1
    8001093e:	fce43023          	sd	a4,-64(s0)
    80010942:	fc843703          	ld	a4,-56(s0)
    80010946:	97ba                	add	a5,a5,a4
    80010948:	06200713          	li	a4,98
    8001094c:	00e78023          	sb	a4,0(a5)
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80010950:	fc043703          	ld	a4,-64(s0)
    80010954:	47fd                	li	a5,31
    80010956:	00e7ef63          	bltu	a5,a4,80010974 <_ntoa_format+0x1f4>
            buf[len++] = '0';
    8001095a:	fc043783          	ld	a5,-64(s0)
    8001095e:	00178713          	addi	a4,a5,1
    80010962:	fce43023          	sd	a4,-64(s0)
    80010966:	fc843703          	ld	a4,-56(s0)
    8001096a:	97ba                	add	a5,a5,a4
    8001096c:	03000713          	li	a4,48
    80010970:	00e78023          	sb	a4,0(a5)
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80010974:	fc043703          	ld	a4,-64(s0)
    80010978:	47fd                	li	a5,31
    8001097a:	06e7e863          	bltu	a5,a4,800109ea <_ntoa_format+0x26a>
        if (negative) {
    8001097e:	fbf44783          	lbu	a5,-65(s0)
    80010982:	0ff7f793          	andi	a5,a5,255
    80010986:	cf99                	beqz	a5,800109a4 <_ntoa_format+0x224>
            buf[len++] = '-';
    80010988:	fc043783          	ld	a5,-64(s0)
    8001098c:	00178713          	addi	a4,a5,1
    80010990:	fce43023          	sd	a4,-64(s0)
    80010994:	fc843703          	ld	a4,-56(s0)
    80010998:	97ba                	add	a5,a5,a4
    8001099a:	02d00713          	li	a4,45
    8001099e:	00e78023          	sb	a4,0(a5)
    800109a2:	a0a1                	j	800109ea <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_PLUS) {
    800109a4:	481c                	lw	a5,16(s0)
    800109a6:	8b91                	andi	a5,a5,4
    800109a8:	2781                	sext.w	a5,a5
    800109aa:	cf99                	beqz	a5,800109c8 <_ntoa_format+0x248>
            buf[len++] = '+';  // ignore the space if the '+' exists
    800109ac:	fc043783          	ld	a5,-64(s0)
    800109b0:	00178713          	addi	a4,a5,1
    800109b4:	fce43023          	sd	a4,-64(s0)
    800109b8:	fc843703          	ld	a4,-56(s0)
    800109bc:	97ba                	add	a5,a5,a4
    800109be:	02b00713          	li	a4,43
    800109c2:	00e78023          	sb	a4,0(a5)
    800109c6:	a015                	j	800109ea <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_SPACE) {
    800109c8:	481c                	lw	a5,16(s0)
    800109ca:	8ba1                	andi	a5,a5,8
    800109cc:	2781                	sext.w	a5,a5
    800109ce:	cf91                	beqz	a5,800109ea <_ntoa_format+0x26a>
            buf[len++] = ' ';
    800109d0:	fc043783          	ld	a5,-64(s0)
    800109d4:	00178713          	addi	a4,a5,1
    800109d8:	fce43023          	sd	a4,-64(s0)
    800109dc:	fc843703          	ld	a4,-56(s0)
    800109e0:	97ba                	add	a5,a5,a4
    800109e2:	02000713          	li	a4,32
    800109e6:	00e78023          	sb	a4,0(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    800109ea:	4818                	lw	a4,16(s0)
    800109ec:	441c                	lw	a5,8(s0)
    800109ee:	88ba                	mv	a7,a4
    800109f0:	883e                	mv	a6,a5
    800109f2:	fc043783          	ld	a5,-64(s0)
    800109f6:	fc843703          	ld	a4,-56(s0)
    800109fa:	fd043683          	ld	a3,-48(s0)
    800109fe:	fd843603          	ld	a2,-40(s0)
    80010a02:	fe043583          	ld	a1,-32(s0)
    80010a06:	fe843503          	ld	a0,-24(s0)
    80010a0a:	c65ff0ef          	jal	ra,8001066e <_out_rev>
    80010a0e:	87aa                	mv	a5,a0
}
    80010a10:	853e                	mv	a0,a5
    80010a12:	60a6                	ld	ra,72(sp)
    80010a14:	6406                	ld	s0,64(sp)
    80010a16:	6161                	addi	sp,sp,80
    80010a18:	8082                	ret

0000000080010a1a <_ntoa_long>:
// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
                         size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec,
                         unsigned int width, unsigned int flags)
{
    80010a1a:	7135                	addi	sp,sp,-160
    80010a1c:	ed06                	sd	ra,152(sp)
    80010a1e:	e922                	sd	s0,144(sp)
    80010a20:	1100                	addi	s0,sp,160
    80010a22:	faa43c23          	sd	a0,-72(s0)
    80010a26:	fab43823          	sd	a1,-80(s0)
    80010a2a:	fac43423          	sd	a2,-88(s0)
    80010a2e:	fad43023          	sd	a3,-96(s0)
    80010a32:	f8e43c23          	sd	a4,-104(s0)
    80010a36:	f9043423          	sd	a6,-120(s0)
    80010a3a:	8746                	mv	a4,a7
    80010a3c:	f8f40ba3          	sb	a5,-105(s0)
    80010a40:	87ba                	mv	a5,a4
    80010a42:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80010a46:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80010a4a:	f9843783          	ld	a5,-104(s0)
    80010a4e:	e781                	bnez	a5,80010a56 <_ntoa_long+0x3c>
        flags &= ~FLAGS_HASH;
    80010a50:	441c                	lw	a5,8(s0)
    80010a52:	9bbd                	andi	a5,a5,-17
    80010a54:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80010a56:	441c                	lw	a5,8(s0)
    80010a58:	4007f793          	andi	a5,a5,1024
    80010a5c:	2781                	sext.w	a5,a5
    80010a5e:	c781                	beqz	a5,80010a66 <_ntoa_long+0x4c>
    80010a60:	f9843783          	ld	a5,-104(s0)
    80010a64:	c7c1                	beqz	a5,80010aec <_ntoa_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80010a66:	f9843703          	ld	a4,-104(s0)
    80010a6a:	f8843783          	ld	a5,-120(s0)
    80010a6e:	02f777b3          	remu	a5,a4,a5
    80010a72:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80010a76:	fe744783          	lbu	a5,-25(s0)
    80010a7a:	0ff7f713          	andi	a4,a5,255
    80010a7e:	47a5                	li	a5,9
    80010a80:	00e7e963          	bltu	a5,a4,80010a92 <_ntoa_long+0x78>
    80010a84:	fe744783          	lbu	a5,-25(s0)
    80010a88:	0307879b          	addiw	a5,a5,48
    80010a8c:	0ff7f793          	andi	a5,a5,255
    80010a90:	a01d                	j	80010ab6 <_ntoa_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80010a92:	441c                	lw	a5,8(s0)
    80010a94:	0207f793          	andi	a5,a5,32
    80010a98:	2781                	sext.w	a5,a5
    80010a9a:	c781                	beqz	a5,80010aa2 <_ntoa_long+0x88>
    80010a9c:	04100793          	li	a5,65
    80010aa0:	a019                	j	80010aa6 <_ntoa_long+0x8c>
    80010aa2:	06100793          	li	a5,97
    80010aa6:	fe744703          	lbu	a4,-25(s0)
    80010aaa:	9fb9                	addw	a5,a5,a4
    80010aac:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80010ab0:	37d9                	addiw	a5,a5,-10
    80010ab2:	0ff7f793          	andi	a5,a5,255
    80010ab6:	fe843703          	ld	a4,-24(s0)
    80010aba:	00170693          	addi	a3,a4,1
    80010abe:	fed43423          	sd	a3,-24(s0)
    80010ac2:	ff040693          	addi	a3,s0,-16
    80010ac6:	9736                	add	a4,a4,a3
    80010ac8:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010acc:	f9843703          	ld	a4,-104(s0)
    80010ad0:	f8843783          	ld	a5,-120(s0)
    80010ad4:	02f757b3          	divu	a5,a4,a5
    80010ad8:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010adc:	f9843783          	ld	a5,-104(s0)
    80010ae0:	c791                	beqz	a5,80010aec <_ntoa_long+0xd2>
    80010ae2:	fe843703          	ld	a4,-24(s0)
    80010ae6:	47fd                	li	a5,31
    80010ae8:	f6e7ffe3          	bgeu	a5,a4,80010a66 <_ntoa_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010aec:	f8843783          	ld	a5,-120(s0)
    80010af0:	0007861b          	sext.w	a2,a5
    80010af4:	f9744683          	lbu	a3,-105(s0)
    80010af8:	fc040713          	addi	a4,s0,-64
    80010afc:	441c                	lw	a5,8(s0)
    80010afe:	e83e                	sd	a5,16(sp)
    80010b00:	401c                	lw	a5,0(s0)
    80010b02:	e43e                	sd	a5,8(sp)
    80010b04:	f9042783          	lw	a5,-112(s0)
    80010b08:	e03e                	sd	a5,0(sp)
    80010b0a:	88b2                	mv	a7,a2
    80010b0c:	8836                	mv	a6,a3
    80010b0e:	fe843783          	ld	a5,-24(s0)
    80010b12:	fa043683          	ld	a3,-96(s0)
    80010b16:	fa843603          	ld	a2,-88(s0)
    80010b1a:	fb043583          	ld	a1,-80(s0)
    80010b1e:	fb843503          	ld	a0,-72(s0)
    80010b22:	c5fff0ef          	jal	ra,80010780 <_ntoa_format>
    80010b26:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010b28:	853e                	mv	a0,a5
    80010b2a:	60ea                	ld	ra,152(sp)
    80010b2c:	644a                	ld	s0,144(sp)
    80010b2e:	610d                	addi	sp,sp,160
    80010b30:	8082                	ret

0000000080010b32 <_ntoa_long_long>:
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
                              size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base,
                              unsigned int prec, unsigned int width,
                              unsigned int flags)
{
    80010b32:	7135                	addi	sp,sp,-160
    80010b34:	ed06                	sd	ra,152(sp)
    80010b36:	e922                	sd	s0,144(sp)
    80010b38:	1100                	addi	s0,sp,160
    80010b3a:	faa43c23          	sd	a0,-72(s0)
    80010b3e:	fab43823          	sd	a1,-80(s0)
    80010b42:	fac43423          	sd	a2,-88(s0)
    80010b46:	fad43023          	sd	a3,-96(s0)
    80010b4a:	f8e43c23          	sd	a4,-104(s0)
    80010b4e:	f9043423          	sd	a6,-120(s0)
    80010b52:	8746                	mv	a4,a7
    80010b54:	f8f40ba3          	sb	a5,-105(s0)
    80010b58:	87ba                	mv	a5,a4
    80010b5a:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80010b5e:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80010b62:	f9843783          	ld	a5,-104(s0)
    80010b66:	e781                	bnez	a5,80010b6e <_ntoa_long_long+0x3c>
        flags &= ~FLAGS_HASH;
    80010b68:	441c                	lw	a5,8(s0)
    80010b6a:	9bbd                	andi	a5,a5,-17
    80010b6c:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80010b6e:	441c                	lw	a5,8(s0)
    80010b70:	4007f793          	andi	a5,a5,1024
    80010b74:	2781                	sext.w	a5,a5
    80010b76:	c781                	beqz	a5,80010b7e <_ntoa_long_long+0x4c>
    80010b78:	f9843783          	ld	a5,-104(s0)
    80010b7c:	c7c1                	beqz	a5,80010c04 <_ntoa_long_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80010b7e:	f9843703          	ld	a4,-104(s0)
    80010b82:	f8843783          	ld	a5,-120(s0)
    80010b86:	02f777b3          	remu	a5,a4,a5
    80010b8a:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80010b8e:	fe744783          	lbu	a5,-25(s0)
    80010b92:	0ff7f713          	andi	a4,a5,255
    80010b96:	47a5                	li	a5,9
    80010b98:	00e7e963          	bltu	a5,a4,80010baa <_ntoa_long_long+0x78>
    80010b9c:	fe744783          	lbu	a5,-25(s0)
    80010ba0:	0307879b          	addiw	a5,a5,48
    80010ba4:	0ff7f793          	andi	a5,a5,255
    80010ba8:	a01d                	j	80010bce <_ntoa_long_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80010baa:	441c                	lw	a5,8(s0)
    80010bac:	0207f793          	andi	a5,a5,32
    80010bb0:	2781                	sext.w	a5,a5
    80010bb2:	c781                	beqz	a5,80010bba <_ntoa_long_long+0x88>
    80010bb4:	04100793          	li	a5,65
    80010bb8:	a019                	j	80010bbe <_ntoa_long_long+0x8c>
    80010bba:	06100793          	li	a5,97
    80010bbe:	fe744703          	lbu	a4,-25(s0)
    80010bc2:	9fb9                	addw	a5,a5,a4
    80010bc4:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80010bc8:	37d9                	addiw	a5,a5,-10
    80010bca:	0ff7f793          	andi	a5,a5,255
    80010bce:	fe843703          	ld	a4,-24(s0)
    80010bd2:	00170693          	addi	a3,a4,1
    80010bd6:	fed43423          	sd	a3,-24(s0)
    80010bda:	ff040693          	addi	a3,s0,-16
    80010bde:	9736                	add	a4,a4,a3
    80010be0:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010be4:	f9843703          	ld	a4,-104(s0)
    80010be8:	f8843783          	ld	a5,-120(s0)
    80010bec:	02f757b3          	divu	a5,a4,a5
    80010bf0:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010bf4:	f9843783          	ld	a5,-104(s0)
    80010bf8:	c791                	beqz	a5,80010c04 <_ntoa_long_long+0xd2>
    80010bfa:	fe843703          	ld	a4,-24(s0)
    80010bfe:	47fd                	li	a5,31
    80010c00:	f6e7ffe3          	bgeu	a5,a4,80010b7e <_ntoa_long_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010c04:	f8843783          	ld	a5,-120(s0)
    80010c08:	0007861b          	sext.w	a2,a5
    80010c0c:	f9744683          	lbu	a3,-105(s0)
    80010c10:	fc040713          	addi	a4,s0,-64
    80010c14:	441c                	lw	a5,8(s0)
    80010c16:	e83e                	sd	a5,16(sp)
    80010c18:	401c                	lw	a5,0(s0)
    80010c1a:	e43e                	sd	a5,8(sp)
    80010c1c:	f9042783          	lw	a5,-112(s0)
    80010c20:	e03e                	sd	a5,0(sp)
    80010c22:	88b2                	mv	a7,a2
    80010c24:	8836                	mv	a6,a3
    80010c26:	fe843783          	ld	a5,-24(s0)
    80010c2a:	fa043683          	ld	a3,-96(s0)
    80010c2e:	fa843603          	ld	a2,-88(s0)
    80010c32:	fb043583          	ld	a1,-80(s0)
    80010c36:	fb843503          	ld	a0,-72(s0)
    80010c3a:	b47ff0ef          	jal	ra,80010780 <_ntoa_format>
    80010c3e:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010c40:	853e                	mv	a0,a5
    80010c42:	60ea                	ld	ra,152(sp)
    80010c44:	644a                	ld	s0,144(sp)
    80010c46:	610d                	addi	sp,sp,160
    80010c48:	8082                	ret

0000000080010c4a <_ftoa>:

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80010c4a:	7135                	addi	sp,sp,-160
    80010c4c:	ed06                	sd	ra,152(sp)
    80010c4e:	e922                	sd	s0,144(sp)
    80010c50:	1100                	addi	s0,sp,160
    80010c52:	f8a43c23          	sd	a0,-104(s0)
    80010c56:	f8b43823          	sd	a1,-112(s0)
    80010c5a:	f8c43423          	sd	a2,-120(s0)
    80010c5e:	f8d43023          	sd	a3,-128(s0)
    80010c62:	f6a43c27          	fsd	fa0,-136(s0)
    80010c66:	863a                	mv	a2,a4
    80010c68:	86be                	mv	a3,a5
    80010c6a:	8742                	mv	a4,a6
    80010c6c:	87b2                	mv	a5,a2
    80010c6e:	f6f42a23          	sw	a5,-140(s0)
    80010c72:	87b6                	mv	a5,a3
    80010c74:	f6f42823          	sw	a5,-144(s0)
    80010c78:	87ba                	mv	a5,a4
    80010c7a:	f6f42623          	sw	a5,-148(s0)
    char buf[PRINTF_FTOA_BUFFER_SIZE];
    size_t len                  = 0U;
    80010c7e:	fe043423          	sd	zero,-24(s0)
    double diff                 = 0.0;
    80010c82:	fc043423          	sd	zero,-56(s0)
    static const double pow10[] = {1,         10,        100,     1000,
                                   10000,     100000,    1000000, 10000000,
                                   100000000, 1000000000};

    // test for special values
    if (value != value)
    80010c86:	f7843707          	fld	fa4,-136(s0)
    80010c8a:	f7843787          	fld	fa5,-136(s0)
    80010c8e:	a2f727d3          	feq.d	a5,fa4,fa5
    80010c92:	eb85                	bnez	a5,80010cc2 <_ftoa+0x78>
        return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
    80010c94:	f6c42703          	lw	a4,-148(s0)
    80010c98:	f7042783          	lw	a5,-144(s0)
    80010c9c:	88ba                	mv	a7,a4
    80010c9e:	883e                	mv	a6,a5
    80010ca0:	478d                	li	a5,3
    80010ca2:	0000a717          	auipc	a4,0xa
    80010ca6:	38e70713          	addi	a4,a4,910 # 8001b030 <SYSCALLS+0x30>
    80010caa:	f8043683          	ld	a3,-128(s0)
    80010cae:	f8843603          	ld	a2,-120(s0)
    80010cb2:	f9043583          	ld	a1,-112(s0)
    80010cb6:	f9843503          	ld	a0,-104(s0)
    80010cba:	9b5ff0ef          	jal	ra,8001066e <_out_rev>
    80010cbe:	87aa                	mv	a5,a0
    80010cc0:	a1f1                	j	8001118c <_ftoa+0x542>
    if (value < -DBL_MAX)
    80010cc2:	f7843707          	fld	fa4,-136(s0)
    80010cc6:	0000a797          	auipc	a5,0xa
    80010cca:	5ba78793          	addi	a5,a5,1466 # 8001b280 <pow10.0+0x50>
    80010cce:	239c                	fld	fa5,0(a5)
    80010cd0:	a2f717d3          	flt.d	a5,fa4,fa5
    80010cd4:	cb85                	beqz	a5,80010d04 <_ftoa+0xba>
        return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    80010cd6:	f6c42703          	lw	a4,-148(s0)
    80010cda:	f7042783          	lw	a5,-144(s0)
    80010cde:	88ba                	mv	a7,a4
    80010ce0:	883e                	mv	a6,a5
    80010ce2:	4791                	li	a5,4
    80010ce4:	0000a717          	auipc	a4,0xa
    80010ce8:	35470713          	addi	a4,a4,852 # 8001b038 <SYSCALLS+0x38>
    80010cec:	f8043683          	ld	a3,-128(s0)
    80010cf0:	f8843603          	ld	a2,-120(s0)
    80010cf4:	f9043583          	ld	a1,-112(s0)
    80010cf8:	f9843503          	ld	a0,-104(s0)
    80010cfc:	973ff0ef          	jal	ra,8001066e <_out_rev>
    80010d00:	87aa                	mv	a5,a0
    80010d02:	a169                	j	8001118c <_ftoa+0x542>
    if (value > DBL_MAX)
    80010d04:	f7843707          	fld	fa4,-136(s0)
    80010d08:	0000a797          	auipc	a5,0xa
    80010d0c:	58078793          	addi	a5,a5,1408 # 8001b288 <pow10.0+0x58>
    80010d10:	239c                	fld	fa5,0(a5)
    80010d12:	a2e797d3          	flt.d	a5,fa5,fa4
    80010d16:	cba9                	beqz	a5,80010d68 <_ftoa+0x11e>
        return _out_rev(out, buffer, idx, maxlen,
                        (flags & FLAGS_PLUS) ? "fni+" : "fni",
    80010d18:	f6c42783          	lw	a5,-148(s0)
    80010d1c:	8b91                	andi	a5,a5,4
    80010d1e:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010d20:	c791                	beqz	a5,80010d2c <_ftoa+0xe2>
    80010d22:	0000a717          	auipc	a4,0xa
    80010d26:	31e70713          	addi	a4,a4,798 # 8001b040 <SYSCALLS+0x40>
    80010d2a:	a029                	j	80010d34 <_ftoa+0xea>
    80010d2c:	0000a717          	auipc	a4,0xa
    80010d30:	31c70713          	addi	a4,a4,796 # 8001b048 <SYSCALLS+0x48>
                        (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
    80010d34:	f6c42783          	lw	a5,-148(s0)
    80010d38:	8b91                	andi	a5,a5,4
    80010d3a:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010d3c:	c399                	beqz	a5,80010d42 <_ftoa+0xf8>
    80010d3e:	4791                	li	a5,4
    80010d40:	a011                	j	80010d44 <_ftoa+0xfa>
    80010d42:	478d                	li	a5,3
    80010d44:	f6c42603          	lw	a2,-148(s0)
    80010d48:	f7042683          	lw	a3,-144(s0)
    80010d4c:	88b2                	mv	a7,a2
    80010d4e:	8836                	mv	a6,a3
    80010d50:	f8043683          	ld	a3,-128(s0)
    80010d54:	f8843603          	ld	a2,-120(s0)
    80010d58:	f9043583          	ld	a1,-112(s0)
    80010d5c:	f9843503          	ld	a0,-104(s0)
    80010d60:	90fff0ef          	jal	ra,8001066e <_out_rev>
    80010d64:	87aa                	mv	a5,a0
    80010d66:	a11d                	j	8001118c <_ftoa+0x542>

    // test for very large values
    // standard printf behavior is to print EVERY whole number digit -- which
    // could be 100s of characters overflowing your buffers == bad
    if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
    80010d68:	f7843707          	fld	fa4,-136(s0)
    80010d6c:	0000a797          	auipc	a5,0xa
    80010d70:	52478793          	addi	a5,a5,1316 # 8001b290 <pow10.0+0x60>
    80010d74:	239c                	fld	fa5,0(a5)
    80010d76:	a2e797d3          	flt.d	a5,fa5,fa4
    80010d7a:	eb99                	bnez	a5,80010d90 <_ftoa+0x146>
    80010d7c:	f7843707          	fld	fa4,-136(s0)
    80010d80:	0000a797          	auipc	a5,0xa
    80010d84:	51878793          	addi	a5,a5,1304 # 8001b298 <pow10.0+0x68>
    80010d88:	239c                	fld	fa5,0(a5)
    80010d8a:	a2f717d3          	flt.d	a5,fa4,fa5
    80010d8e:	c795                	beqz	a5,80010dba <_ftoa+0x170>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80010d90:	f6c42683          	lw	a3,-148(s0)
    80010d94:	f7042783          	lw	a5,-144(s0)
    80010d98:	f7442703          	lw	a4,-140(s0)
    80010d9c:	8836                	mv	a6,a3
    80010d9e:	f7843507          	fld	fa0,-136(s0)
    80010da2:	f8043683          	ld	a3,-128(s0)
    80010da6:	f8843603          	ld	a2,-120(s0)
    80010daa:	f9043583          	ld	a1,-112(s0)
    80010dae:	f9843503          	ld	a0,-104(s0)
    80010db2:	3e4000ef          	jal	ra,80011196 <_etoa>
    80010db6:	87aa                	mv	a5,a0
    80010db8:	aed1                	j	8001118c <_ftoa+0x542>
        return 0U;
#endif
    }

    // test for negative
    bool negative = false;
    80010dba:	fe0403a3          	sb	zero,-25(s0)
    if (value < 0) {
    80010dbe:	f7843787          	fld	fa5,-136(s0)
    80010dc2:	f2000753          	fmv.d.x	fa4,zero
    80010dc6:	a2e797d3          	flt.d	a5,fa5,fa4
    80010dca:	cf81                	beqz	a5,80010de2 <_ftoa+0x198>
        negative = true;
    80010dcc:	4785                	li	a5,1
    80010dce:	fef403a3          	sb	a5,-25(s0)
        value    = 0 - value;
    80010dd2:	f2000753          	fmv.d.x	fa4,zero
    80010dd6:	f7843787          	fld	fa5,-136(s0)
    80010dda:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010dde:	f6f43c27          	fsd	fa5,-136(s0)
    }

    // set default precision, if not set explicitly
    if (!(flags & FLAGS_PRECISION)) {
    80010de2:	f6c42783          	lw	a5,-148(s0)
    80010de6:	4007f793          	andi	a5,a5,1024
    80010dea:	2781                	sext.w	a5,a5
    80010dec:	e79d                	bnez	a5,80010e1a <_ftoa+0x1d0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80010dee:	4799                	li	a5,6
    80010df0:	f6f42a23          	sw	a5,-140(s0)
    }
    // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010df4:	a01d                	j	80010e1a <_ftoa+0x1d0>
        buf[len++] = '0';
    80010df6:	fe843783          	ld	a5,-24(s0)
    80010dfa:	00178713          	addi	a4,a5,1
    80010dfe:	fee43423          	sd	a4,-24(s0)
    80010e02:	ff040713          	addi	a4,s0,-16
    80010e06:	97ba                	add	a5,a5,a4
    80010e08:	03000713          	li	a4,48
    80010e0c:	fae78823          	sb	a4,-80(a5)
        prec--;
    80010e10:	f7442783          	lw	a5,-140(s0)
    80010e14:	37fd                	addiw	a5,a5,-1
    80010e16:	f6f42a23          	sw	a5,-140(s0)
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010e1a:	fe843703          	ld	a4,-24(s0)
    80010e1e:	47fd                	li	a5,31
    80010e20:	00e7e963          	bltu	a5,a4,80010e32 <_ftoa+0x1e8>
    80010e24:	f7442783          	lw	a5,-140(s0)
    80010e28:	0007871b          	sext.w	a4,a5
    80010e2c:	47a5                	li	a5,9
    80010e2e:	fce7e4e3          	bltu	a5,a4,80010df6 <_ftoa+0x1ac>
    }

    int whole          = (int)value;
    80010e32:	f7843787          	fld	fa5,-136(s0)
    80010e36:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80010e3a:	fef42023          	sw	a5,-32(s0)
    double tmp         = (value - whole) * pow10[prec];
    80010e3e:	fe042783          	lw	a5,-32(s0)
    80010e42:	d20787d3          	fcvt.d.w	fa5,a5
    80010e46:	f7843707          	fld	fa4,-136(s0)
    80010e4a:	0af77753          	fsub.d	fa4,fa4,fa5
    80010e4e:	0000a717          	auipc	a4,0xa
    80010e52:	3e270713          	addi	a4,a4,994 # 8001b230 <pow10.0>
    80010e56:	f7446783          	lwu	a5,-140(s0)
    80010e5a:	078e                	slli	a5,a5,0x3
    80010e5c:	97ba                	add	a5,a5,a4
    80010e5e:	239c                	fld	fa5,0(a5)
    80010e60:	12f777d3          	fmul.d	fa5,fa4,fa5
    80010e64:	fcf43027          	fsd	fa5,-64(s0)
    unsigned long frac = (unsigned long)tmp;
    80010e68:	fc043787          	fld	fa5,-64(s0)
    80010e6c:	c23797d3          	fcvt.lu.d	a5,fa5,rtz
    80010e70:	fcf43c23          	sd	a5,-40(s0)
    diff               = tmp - frac;
    80010e74:	fd843783          	ld	a5,-40(s0)
    80010e78:	d237f7d3          	fcvt.d.lu	fa5,a5
    80010e7c:	fc043707          	fld	fa4,-64(s0)
    80010e80:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010e84:	fcf43427          	fsd	fa5,-56(s0)

    if (diff > 0.5) {
    80010e88:	fc843707          	fld	fa4,-56(s0)
    80010e8c:	0000a797          	auipc	a5,0xa
    80010e90:	41478793          	addi	a5,a5,1044 # 8001b2a0 <pow10.0+0x70>
    80010e94:	239c                	fld	fa5,0(a5)
    80010e96:	a2e797d3          	flt.d	a5,fa5,fa4
    80010e9a:	cf95                	beqz	a5,80010ed6 <_ftoa+0x28c>
        ++frac;
    80010e9c:	fd843783          	ld	a5,-40(s0)
    80010ea0:	0785                	addi	a5,a5,1
    80010ea2:	fcf43c23          	sd	a5,-40(s0)
        // handle rollover, e.g. case 0.99 with prec 1 is 1.0
        if (frac >= pow10[prec]) {
    80010ea6:	fd843783          	ld	a5,-40(s0)
    80010eaa:	d237f753          	fcvt.d.lu	fa4,a5
    80010eae:	0000a717          	auipc	a4,0xa
    80010eb2:	38270713          	addi	a4,a4,898 # 8001b230 <pow10.0>
    80010eb6:	f7446783          	lwu	a5,-140(s0)
    80010eba:	078e                	slli	a5,a5,0x3
    80010ebc:	97ba                	add	a5,a5,a4
    80010ebe:	239c                	fld	fa5,0(a5)
    80010ec0:	a2e787d3          	fle.d	a5,fa5,fa4
    80010ec4:	cf9d                	beqz	a5,80010f02 <_ftoa+0x2b8>
            frac = 0;
    80010ec6:	fc043c23          	sd	zero,-40(s0)
            ++whole;
    80010eca:	fe042783          	lw	a5,-32(s0)
    80010ece:	2785                	addiw	a5,a5,1
    80010ed0:	fef42023          	sw	a5,-32(s0)
    80010ed4:	a03d                	j	80010f02 <_ftoa+0x2b8>
        }
    }
    else if (diff < 0.5) {
    80010ed6:	fc843707          	fld	fa4,-56(s0)
    80010eda:	0000a797          	auipc	a5,0xa
    80010ede:	3c678793          	addi	a5,a5,966 # 8001b2a0 <pow10.0+0x70>
    80010ee2:	239c                	fld	fa5,0(a5)
    80010ee4:	a2f717d3          	flt.d	a5,fa4,fa5
    80010ee8:	ef89                	bnez	a5,80010f02 <_ftoa+0x2b8>
    }
    else if ((frac == 0U) || (frac & 1U)) {
    80010eea:	fd843783          	ld	a5,-40(s0)
    80010eee:	c789                	beqz	a5,80010ef8 <_ftoa+0x2ae>
    80010ef0:	fd843783          	ld	a5,-40(s0)
    80010ef4:	8b85                	andi	a5,a5,1
    80010ef6:	c791                	beqz	a5,80010f02 <_ftoa+0x2b8>
        // if halfway, round up if odd OR if last digit is 0
        ++frac;
    80010ef8:	fd843783          	ld	a5,-40(s0)
    80010efc:	0785                	addi	a5,a5,1
    80010efe:	fcf43c23          	sd	a5,-40(s0)
    }

    if (prec == 0U) {
    80010f02:	f7442783          	lw	a5,-140(s0)
    80010f06:	2781                	sext.w	a5,a5
    80010f08:	e3bd                	bnez	a5,80010f6e <_ftoa+0x324>
        diff = value - (double)whole;
    80010f0a:	fe042783          	lw	a5,-32(s0)
    80010f0e:	d20787d3          	fcvt.d.w	fa5,a5
    80010f12:	f7843707          	fld	fa4,-136(s0)
    80010f16:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010f1a:	fcf43427          	fsd	fa5,-56(s0)
        if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    80010f1e:	fc843707          	fld	fa4,-56(s0)
    80010f22:	0000a797          	auipc	a5,0xa
    80010f26:	37e78793          	addi	a5,a5,894 # 8001b2a0 <pow10.0+0x70>
    80010f2a:	239c                	fld	fa5,0(a5)
    80010f2c:	a2f717d3          	flt.d	a5,fa4,fa5
    80010f30:	00f037b3          	snez	a5,a5
    80010f34:	0ff7f793          	andi	a5,a5,255
    80010f38:	0017c793          	xori	a5,a5,1
    80010f3c:	0ff7f793          	andi	a5,a5,255
    80010f40:	eb99                	bnez	a5,80010f56 <_ftoa+0x30c>
    80010f42:	fc843707          	fld	fa4,-56(s0)
    80010f46:	0000a797          	auipc	a5,0xa
    80010f4a:	35a78793          	addi	a5,a5,858 # 8001b2a0 <pow10.0+0x70>
    80010f4e:	239c                	fld	fa5,0(a5)
    80010f50:	a2e797d3          	flt.d	a5,fa5,fa4
    80010f54:	cbf1                	beqz	a5,80011028 <_ftoa+0x3de>
    80010f56:	fe042783          	lw	a5,-32(s0)
    80010f5a:	8b85                	andi	a5,a5,1
    80010f5c:	2781                	sext.w	a5,a5
    80010f5e:	10078863          	beqz	a5,8001106e <_ftoa+0x424>
            // exactly 0.5 and ODD, then round up
            // 1.5 -> 2, but 2.5 -> 2
            ++whole;
    80010f62:	fe042783          	lw	a5,-32(s0)
    80010f66:	2785                	addiw	a5,a5,1
    80010f68:	fef42023          	sw	a5,-32(s0)
    80010f6c:	a209                	j	8001106e <_ftoa+0x424>
        }
    }
    else {
        unsigned int count = prec;
    80010f6e:	f7442783          	lw	a5,-140(s0)
    80010f72:	fcf42a23          	sw	a5,-44(s0)
        // now do fractional part, as an unsigned number
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010f76:	a0b1                	j	80010fc2 <_ftoa+0x378>
            --count;
    80010f78:	fd442783          	lw	a5,-44(s0)
    80010f7c:	37fd                	addiw	a5,a5,-1
    80010f7e:	fcf42a23          	sw	a5,-44(s0)
            buf[len++] = (char)(48U + (frac % 10U));
    80010f82:	fd843703          	ld	a4,-40(s0)
    80010f86:	47a9                	li	a5,10
    80010f88:	02f777b3          	remu	a5,a4,a5
    80010f8c:	0ff7f713          	andi	a4,a5,255
    80010f90:	fe843783          	ld	a5,-24(s0)
    80010f94:	00178693          	addi	a3,a5,1
    80010f98:	fed43423          	sd	a3,-24(s0)
    80010f9c:	0307071b          	addiw	a4,a4,48
    80010fa0:	0ff77713          	andi	a4,a4,255
    80010fa4:	ff040693          	addi	a3,s0,-16
    80010fa8:	97b6                	add	a5,a5,a3
    80010faa:	fae78823          	sb	a4,-80(a5)
            if (!(frac /= 10U)) {
    80010fae:	fd843703          	ld	a4,-40(s0)
    80010fb2:	47a9                	li	a5,10
    80010fb4:	02f757b3          	divu	a5,a4,a5
    80010fb8:	fcf43c23          	sd	a5,-40(s0)
    80010fbc:	fd843783          	ld	a5,-40(s0)
    80010fc0:	c799                	beqz	a5,80010fce <_ftoa+0x384>
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010fc2:	fe843703          	ld	a4,-24(s0)
    80010fc6:	47fd                	li	a5,31
    80010fc8:	fae7f8e3          	bgeu	a5,a4,80010f78 <_ftoa+0x32e>
    80010fcc:	a005                	j	80010fec <_ftoa+0x3a2>
                break;
    80010fce:	0001                	nop
            }
        }
        // add extra 0s
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010fd0:	a831                	j	80010fec <_ftoa+0x3a2>
            buf[len++] = '0';
    80010fd2:	fe843783          	ld	a5,-24(s0)
    80010fd6:	00178713          	addi	a4,a5,1
    80010fda:	fee43423          	sd	a4,-24(s0)
    80010fde:	ff040713          	addi	a4,s0,-16
    80010fe2:	97ba                	add	a5,a5,a4
    80010fe4:	03000713          	li	a4,48
    80010fe8:	fae78823          	sb	a4,-80(a5)
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010fec:	fe843703          	ld	a4,-24(s0)
    80010ff0:	47fd                	li	a5,31
    80010ff2:	00e7e963          	bltu	a5,a4,80011004 <_ftoa+0x3ba>
    80010ff6:	fd442783          	lw	a5,-44(s0)
    80010ffa:	fff7871b          	addiw	a4,a5,-1
    80010ffe:	fce42a23          	sw	a4,-44(s0)
    80011002:	fbe1                	bnez	a5,80010fd2 <_ftoa+0x388>
        }
        if (len < PRINTF_FTOA_BUFFER_SIZE) {
    80011004:	fe843703          	ld	a4,-24(s0)
    80011008:	47fd                	li	a5,31
    8001100a:	06e7e263          	bltu	a5,a4,8001106e <_ftoa+0x424>
            // add decimal
            buf[len++] = '.';
    8001100e:	fe843783          	ld	a5,-24(s0)
    80011012:	00178713          	addi	a4,a5,1
    80011016:	fee43423          	sd	a4,-24(s0)
    8001101a:	ff040713          	addi	a4,s0,-16
    8001101e:	97ba                	add	a5,a5,a4
    80011020:	02e00713          	li	a4,46
    80011024:	fae78823          	sb	a4,-80(a5)
        }
    }

    // do whole part, number is reversed
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80011028:	a099                	j	8001106e <_ftoa+0x424>
        buf[len++] = (char)(48 + (whole % 10));
    8001102a:	fe042703          	lw	a4,-32(s0)
    8001102e:	47a9                	li	a5,10
    80011030:	02f767bb          	remw	a5,a4,a5
    80011034:	2781                	sext.w	a5,a5
    80011036:	0ff7f713          	andi	a4,a5,255
    8001103a:	fe843783          	ld	a5,-24(s0)
    8001103e:	00178693          	addi	a3,a5,1
    80011042:	fed43423          	sd	a3,-24(s0)
    80011046:	0307071b          	addiw	a4,a4,48
    8001104a:	0ff77713          	andi	a4,a4,255
    8001104e:	ff040693          	addi	a3,s0,-16
    80011052:	97b6                	add	a5,a5,a3
    80011054:	fae78823          	sb	a4,-80(a5)
        if (!(whole /= 10)) {
    80011058:	fe042703          	lw	a4,-32(s0)
    8001105c:	47a9                	li	a5,10
    8001105e:	02f747bb          	divw	a5,a4,a5
    80011062:	fef42023          	sw	a5,-32(s0)
    80011066:	fe042783          	lw	a5,-32(s0)
    8001106a:	2781                	sext.w	a5,a5
    8001106c:	c799                	beqz	a5,8001107a <_ftoa+0x430>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    8001106e:	fe843703          	ld	a4,-24(s0)
    80011072:	47fd                	li	a5,31
    80011074:	fae7fbe3          	bgeu	a5,a4,8001102a <_ftoa+0x3e0>
    80011078:	a011                	j	8001107c <_ftoa+0x432>
            break;
    8001107a:	0001                	nop
        }
    }

    // pad leading zeros
    if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    8001107c:	f6c42783          	lw	a5,-148(s0)
    80011080:	8b89                	andi	a5,a5,2
    80011082:	2781                	sext.w	a5,a5
    80011084:	e3b5                	bnez	a5,800110e8 <_ftoa+0x49e>
    80011086:	f6c42783          	lw	a5,-148(s0)
    8001108a:	8b85                	andi	a5,a5,1
    8001108c:	2781                	sext.w	a5,a5
    8001108e:	cfa9                	beqz	a5,800110e8 <_ftoa+0x49e>
        if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80011090:	f7042783          	lw	a5,-144(s0)
    80011094:	2781                	sext.w	a5,a5
    80011096:	cf95                	beqz	a5,800110d2 <_ftoa+0x488>
    80011098:	fe744783          	lbu	a5,-25(s0)
    8001109c:	0ff7f793          	andi	a5,a5,255
    800110a0:	e791                	bnez	a5,800110ac <_ftoa+0x462>
    800110a2:	f6c42783          	lw	a5,-148(s0)
    800110a6:	8bb1                	andi	a5,a5,12
    800110a8:	2781                	sext.w	a5,a5
    800110aa:	c785                	beqz	a5,800110d2 <_ftoa+0x488>
            width--;
    800110ac:	f7042783          	lw	a5,-144(s0)
    800110b0:	37fd                	addiw	a5,a5,-1
    800110b2:	f6f42823          	sw	a5,-144(s0)
        }
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800110b6:	a831                	j	800110d2 <_ftoa+0x488>
            buf[len++] = '0';
    800110b8:	fe843783          	ld	a5,-24(s0)
    800110bc:	00178713          	addi	a4,a5,1
    800110c0:	fee43423          	sd	a4,-24(s0)
    800110c4:	ff040713          	addi	a4,s0,-16
    800110c8:	97ba                	add	a5,a5,a4
    800110ca:	03000713          	li	a4,48
    800110ce:	fae78823          	sb	a4,-80(a5)
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800110d2:	f7046783          	lwu	a5,-144(s0)
    800110d6:	fe843703          	ld	a4,-24(s0)
    800110da:	00f77763          	bgeu	a4,a5,800110e8 <_ftoa+0x49e>
    800110de:	fe843703          	ld	a4,-24(s0)
    800110e2:	47fd                	li	a5,31
    800110e4:	fce7fae3          	bgeu	a5,a4,800110b8 <_ftoa+0x46e>
        }
    }

    if (len < PRINTF_FTOA_BUFFER_SIZE) {
    800110e8:	fe843703          	ld	a4,-24(s0)
    800110ec:	47fd                	li	a5,31
    800110ee:	06e7ea63          	bltu	a5,a4,80011162 <_ftoa+0x518>
        if (negative) {
    800110f2:	fe744783          	lbu	a5,-25(s0)
    800110f6:	0ff7f793          	andi	a5,a5,255
    800110fa:	cf99                	beqz	a5,80011118 <_ftoa+0x4ce>
            buf[len++] = '-';
    800110fc:	fe843783          	ld	a5,-24(s0)
    80011100:	00178713          	addi	a4,a5,1
    80011104:	fee43423          	sd	a4,-24(s0)
    80011108:	ff040713          	addi	a4,s0,-16
    8001110c:	97ba                	add	a5,a5,a4
    8001110e:	02d00713          	li	a4,45
    80011112:	fae78823          	sb	a4,-80(a5)
    80011116:	a0b1                	j	80011162 <_ftoa+0x518>
        }
        else if (flags & FLAGS_PLUS) {
    80011118:	f6c42783          	lw	a5,-148(s0)
    8001111c:	8b91                	andi	a5,a5,4
    8001111e:	2781                	sext.w	a5,a5
    80011120:	cf99                	beqz	a5,8001113e <_ftoa+0x4f4>
            buf[len++] = '+';  // ignore the space if the '+' exists
    80011122:	fe843783          	ld	a5,-24(s0)
    80011126:	00178713          	addi	a4,a5,1
    8001112a:	fee43423          	sd	a4,-24(s0)
    8001112e:	ff040713          	addi	a4,s0,-16
    80011132:	97ba                	add	a5,a5,a4
    80011134:	02b00713          	li	a4,43
    80011138:	fae78823          	sb	a4,-80(a5)
    8001113c:	a01d                	j	80011162 <_ftoa+0x518>
        }
        else if (flags & FLAGS_SPACE) {
    8001113e:	f6c42783          	lw	a5,-148(s0)
    80011142:	8ba1                	andi	a5,a5,8
    80011144:	2781                	sext.w	a5,a5
    80011146:	cf91                	beqz	a5,80011162 <_ftoa+0x518>
            buf[len++] = ' ';
    80011148:	fe843783          	ld	a5,-24(s0)
    8001114c:	00178713          	addi	a4,a5,1
    80011150:	fee43423          	sd	a4,-24(s0)
    80011154:	ff040713          	addi	a4,s0,-16
    80011158:	97ba                	add	a5,a5,a4
    8001115a:	02000713          	li	a4,32
    8001115e:	fae78823          	sb	a4,-80(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    80011162:	f6c42683          	lw	a3,-148(s0)
    80011166:	f7042783          	lw	a5,-144(s0)
    8001116a:	fa040713          	addi	a4,s0,-96
    8001116e:	88b6                	mv	a7,a3
    80011170:	883e                	mv	a6,a5
    80011172:	fe843783          	ld	a5,-24(s0)
    80011176:	f8043683          	ld	a3,-128(s0)
    8001117a:	f8843603          	ld	a2,-120(s0)
    8001117e:	f9043583          	ld	a1,-112(s0)
    80011182:	f9843503          	ld	a0,-104(s0)
    80011186:	ce8ff0ef          	jal	ra,8001066e <_out_rev>
    8001118a:	87aa                	mv	a5,a0
}
    8001118c:	853e                	mv	a0,a5
    8001118e:	60ea                	ld	ra,152(sp)
    80011190:	644a                	ld	s0,144(sp)
    80011192:	610d                	addi	sp,sp,160
    80011194:	8082                	ret

0000000080011196 <_etoa>:
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80011196:	7135                	addi	sp,sp,-160
    80011198:	ed06                	sd	ra,152(sp)
    8001119a:	e922                	sd	s0,144(sp)
    8001119c:	1100                	addi	s0,sp,160
    8001119e:	faa43423          	sd	a0,-88(s0)
    800111a2:	fab43023          	sd	a1,-96(s0)
    800111a6:	f8c43c23          	sd	a2,-104(s0)
    800111aa:	f8d43823          	sd	a3,-112(s0)
    800111ae:	f8a43427          	fsd	fa0,-120(s0)
    800111b2:	863a                	mv	a2,a4
    800111b4:	86be                	mv	a3,a5
    800111b6:	8742                	mv	a4,a6
    800111b8:	87b2                	mv	a5,a2
    800111ba:	f8f42223          	sw	a5,-124(s0)
    800111be:	87b6                	mv	a5,a3
    800111c0:	f8f42023          	sw	a5,-128(s0)
    800111c4:	87ba                	mv	a5,a4
    800111c6:	f6f42e23          	sw	a5,-132(s0)
    // check for NaN and special values
    if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    800111ca:	f8843707          	fld	fa4,-120(s0)
    800111ce:	f8843787          	fld	fa5,-120(s0)
    800111d2:	a2f727d3          	feq.d	a5,fa4,fa5
    800111d6:	c78d                	beqz	a5,80011200 <_etoa+0x6a>
    800111d8:	f8843707          	fld	fa4,-120(s0)
    800111dc:	0000a797          	auipc	a5,0xa
    800111e0:	0ac78793          	addi	a5,a5,172 # 8001b288 <pow10.0+0x58>
    800111e4:	239c                	fld	fa5,0(a5)
    800111e6:	a2e797d3          	flt.d	a5,fa5,fa4
    800111ea:	eb99                	bnez	a5,80011200 <_etoa+0x6a>
    800111ec:	f8843707          	fld	fa4,-120(s0)
    800111f0:	0000a797          	auipc	a5,0xa
    800111f4:	09078793          	addi	a5,a5,144 # 8001b280 <pow10.0+0x50>
    800111f8:	239c                	fld	fa5,0(a5)
    800111fa:	a2f717d3          	flt.d	a5,fa4,fa5
    800111fe:	c795                	beqz	a5,8001122a <_etoa+0x94>
        return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80011200:	f7c42683          	lw	a3,-132(s0)
    80011204:	f8042783          	lw	a5,-128(s0)
    80011208:	f8442703          	lw	a4,-124(s0)
    8001120c:	8836                	mv	a6,a3
    8001120e:	f8843507          	fld	fa0,-120(s0)
    80011212:	f9043683          	ld	a3,-112(s0)
    80011216:	f9843603          	ld	a2,-104(s0)
    8001121a:	fa043583          	ld	a1,-96(s0)
    8001121e:	fa843503          	ld	a0,-88(s0)
    80011222:	a29ff0ef          	jal	ra,80010c4a <_ftoa>
    80011226:	87aa                	mv	a5,a0
    80011228:	a11d                	j	8001164e <_etoa+0x4b8>
    }

    // determine the sign
    const bool negative = value < 0;
    8001122a:	f8843787          	fld	fa5,-120(s0)
    8001122e:	f2000753          	fmv.d.x	fa4,zero
    80011232:	a2e797d3          	flt.d	a5,fa5,fa4
    80011236:	00f037b3          	snez	a5,a5
    8001123a:	fef401a3          	sb	a5,-29(s0)
    if (negative) {
    8001123e:	fe344783          	lbu	a5,-29(s0)
    80011242:	0ff7f793          	andi	a5,a5,255
    80011246:	c799                	beqz	a5,80011254 <_etoa+0xbe>
        value = -value;
    80011248:	f8843787          	fld	fa5,-120(s0)
    8001124c:	22f797d3          	fneg.d	fa5,fa5
    80011250:	f8f43427          	fsd	fa5,-120(s0)
    }

    // default precision
    if (!(flags & FLAGS_PRECISION)) {
    80011254:	f7c42783          	lw	a5,-132(s0)
    80011258:	4007f793          	andi	a5,a5,1024
    8001125c:	2781                	sext.w	a5,a5
    8001125e:	e781                	bnez	a5,80011266 <_etoa+0xd0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80011260:	4799                	li	a5,6
    80011262:	f8f42223          	sw	a5,-124(s0)
    union {
        uint64_t U;
        double F;
    } conv;

    conv.F   = value;
    80011266:	f8843787          	fld	fa5,-120(s0)
    8001126a:	faf43c27          	fsd	fa5,-72(s0)
    int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;  // effectively log2
    8001126e:	fb843783          	ld	a5,-72(s0)
    80011272:	93d1                	srli	a5,a5,0x34
    80011274:	2781                	sext.w	a5,a5
    80011276:	7ff7f793          	andi	a5,a5,2047
    8001127a:	2781                	sext.w	a5,a5
    8001127c:	c017879b          	addiw	a5,a5,-1023
    80011280:	fcf42e23          	sw	a5,-36(s0)
    conv.U   = (conv.U & ((1ULL << 52U) - 1U)) |
    80011284:	fb843703          	ld	a4,-72(s0)
    80011288:	57fd                	li	a5,-1
    8001128a:	83b1                	srli	a5,a5,0xc
    8001128c:	8f7d                	and	a4,a4,a5
    8001128e:	3ff00793          	li	a5,1023
    80011292:	17d2                	slli	a5,a5,0x34
    80011294:	8fd9                	or	a5,a5,a4
    80011296:	faf43c23          	sd	a5,-72(s0)
             (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    // now approximate log10 from the log2 integer part and an expansion of ln
    // around 1.5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    8001129a:	fdc42783          	lw	a5,-36(s0)
    8001129e:	d2078753          	fcvt.d.w	fa4,a5
    800112a2:	0000a797          	auipc	a5,0xa
    800112a6:	00678793          	addi	a5,a5,6 # 8001b2a8 <pow10.0+0x78>
    800112aa:	239c                	fld	fa5,0(a5)
    800112ac:	12f77753          	fmul.d	fa4,fa4,fa5
    800112b0:	0000a797          	auipc	a5,0xa
    800112b4:	00078793          	mv	a5,a5
    800112b8:	239c                	fld	fa5,0(a5)
    800112ba:	02f77753          	fadd.d	fa4,fa4,fa5
                       (conv.F - 1.5) * 0.289529654602168);
    800112be:	fb843687          	fld	fa3,-72(s0)
    800112c2:	0000a797          	auipc	a5,0xa
    800112c6:	ff678793          	addi	a5,a5,-10 # 8001b2b8 <pow10.0+0x88>
    800112ca:	239c                	fld	fa5,0(a5)
    800112cc:	0af6f6d3          	fsub.d	fa3,fa3,fa5
    800112d0:	0000a797          	auipc	a5,0xa
    800112d4:	ff078793          	addi	a5,a5,-16 # 8001b2c0 <pow10.0+0x90>
    800112d8:	239c                	fld	fa5,0(a5)
    800112da:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    800112de:	02f777d3          	fadd.d	fa5,fa4,fa5
    800112e2:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    800112e6:	fef42623          	sw	a5,-20(s0)
    // now we want to compute 10^expval but we want to be sure it won't overflow
    exp2            = (int)(expval * 3.321928094887362 + 0.5);
    800112ea:	fec42783          	lw	a5,-20(s0)
    800112ee:	d2078753          	fcvt.d.w	fa4,a5
    800112f2:	0000a797          	auipc	a5,0xa
    800112f6:	fd678793          	addi	a5,a5,-42 # 8001b2c8 <pow10.0+0x98>
    800112fa:	239c                	fld	fa5,0(a5)
    800112fc:	12f77753          	fmul.d	fa4,fa4,fa5
    80011300:	0000a797          	auipc	a5,0xa
    80011304:	fa078793          	addi	a5,a5,-96 # 8001b2a0 <pow10.0+0x70>
    80011308:	239c                	fld	fa5,0(a5)
    8001130a:	02f777d3          	fadd.d	fa5,fa4,fa5
    8001130e:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80011312:	fcf42e23          	sw	a5,-36(s0)
    const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    80011316:	fec42783          	lw	a5,-20(s0)
    8001131a:	d2078753          	fcvt.d.w	fa4,a5
    8001131e:	0000a797          	auipc	a5,0xa
    80011322:	fb278793          	addi	a5,a5,-78 # 8001b2d0 <pow10.0+0xa0>
    80011326:	239c                	fld	fa5,0(a5)
    80011328:	12f77753          	fmul.d	fa4,fa4,fa5
    8001132c:	fdc42783          	lw	a5,-36(s0)
    80011330:	d20786d3          	fcvt.d.w	fa3,a5
    80011334:	0000a797          	auipc	a5,0xa
    80011338:	fa478793          	addi	a5,a5,-92 # 8001b2d8 <pow10.0+0xa8>
    8001133c:	239c                	fld	fa5,0(a5)
    8001133e:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    80011342:	0af777d3          	fsub.d	fa5,fa4,fa5
    80011346:	fcf43827          	fsd	fa5,-48(s0)
    const double z2 = z * z;
    8001134a:	fd043787          	fld	fa5,-48(s0)
    8001134e:	12f7f7d3          	fmul.d	fa5,fa5,fa5
    80011352:	fcf43427          	fsd	fa5,-56(s0)
    conv.U          = (uint64_t)(exp2 + 1023) << 52U;
    80011356:	fdc42783          	lw	a5,-36(s0)
    8001135a:	3ff7879b          	addiw	a5,a5,1023
    8001135e:	2781                	sext.w	a5,a5
    80011360:	17d2                	slli	a5,a5,0x34
    80011362:	faf43c23          	sd	a5,-72(s0)
    // compute exp(z) using continued fractions, see
    // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    80011366:	fb843707          	fld	fa4,-72(s0)
    8001136a:	fd043787          	fld	fa5,-48(s0)
    8001136e:	02f7f6d3          	fadd.d	fa3,fa5,fa5
    80011372:	0000a797          	auipc	a5,0xa
    80011376:	f6e78793          	addi	a5,a5,-146 # 8001b2e0 <pow10.0+0xb0>
    8001137a:	2390                	fld	fa2,0(a5)
    8001137c:	fd043787          	fld	fa5,-48(s0)
    80011380:	0af67653          	fsub.d	fa2,fa2,fa5
    80011384:	fc843587          	fld	fa1,-56(s0)
    80011388:	0000a797          	auipc	a5,0xa
    8001138c:	f6078793          	addi	a5,a5,-160 # 8001b2e8 <pow10.0+0xb8>
    80011390:	239c                	fld	fa5,0(a5)
    80011392:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    80011396:	0000a797          	auipc	a5,0xa
    8001139a:	f5a78793          	addi	a5,a5,-166 # 8001b2f0 <pow10.0+0xc0>
    8001139e:	239c                	fld	fa5,0(a5)
    800113a0:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800113a4:	fc843587          	fld	fa1,-56(s0)
    800113a8:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    800113ac:	0000a797          	auipc	a5,0xa
    800113b0:	f4c78793          	addi	a5,a5,-180 # 8001b2f8 <pow10.0+0xc8>
    800113b4:	239c                	fld	fa5,0(a5)
    800113b6:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800113ba:	fc843587          	fld	fa1,-56(s0)
    800113be:	1af5f7d3          	fdiv.d	fa5,fa1,fa5
    800113c2:	02f677d3          	fadd.d	fa5,fa2,fa5
    800113c6:	1af6f6d3          	fdiv.d	fa3,fa3,fa5
    800113ca:	0000a797          	auipc	a5,0xa
    800113ce:	f3678793          	addi	a5,a5,-202 # 8001b300 <pow10.0+0xd0>
    800113d2:	239c                	fld	fa5,0(a5)
    800113d4:	02f6f7d3          	fadd.d	fa5,fa3,fa5
    800113d8:	12f777d3          	fmul.d	fa5,fa4,fa5
    800113dc:	faf43c27          	fsd	fa5,-72(s0)
    // correct for rounding errors
    if (value < conv.F) {
    800113e0:	fb843787          	fld	fa5,-72(s0)
    800113e4:	f8843707          	fld	fa4,-120(s0)
    800113e8:	a2f717d3          	flt.d	a5,fa4,fa5
    800113ec:	c38d                	beqz	a5,8001140e <_etoa+0x278>
        expval--;
    800113ee:	fec42783          	lw	a5,-20(s0)
    800113f2:	37fd                	addiw	a5,a5,-1
    800113f4:	fef42623          	sw	a5,-20(s0)
        conv.F /= 10;
    800113f8:	fb843707          	fld	fa4,-72(s0)
    800113fc:	0000a797          	auipc	a5,0xa
    80011400:	ef478793          	addi	a5,a5,-268 # 8001b2f0 <pow10.0+0xc0>
    80011404:	239c                	fld	fa5,0(a5)
    80011406:	1af777d3          	fdiv.d	fa5,fa4,fa5
    8001140a:	faf43c27          	fsd	fa5,-72(s0)
    }

    // the exponent format is "%+03d" and largest value is "307", so set aside
    // 4-5 characters
    unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    8001140e:	fec42783          	lw	a5,-20(s0)
    80011412:	0007871b          	sext.w	a4,a5
    80011416:	06300793          	li	a5,99
    8001141a:	00e7cc63          	blt	a5,a4,80011432 <_etoa+0x29c>
    8001141e:	fec42783          	lw	a5,-20(s0)
    80011422:	0007871b          	sext.w	a4,a5
    80011426:	f9d00793          	li	a5,-99
    8001142a:	00f74463          	blt	a4,a5,80011432 <_etoa+0x29c>
    8001142e:	4791                	li	a5,4
    80011430:	a011                	j	80011434 <_etoa+0x29e>
    80011432:	4795                	li	a5,5
    80011434:	fef42423          	sw	a5,-24(s0)

    // in "%g" mode, "prec" is the number of *significant figures* not decimals
    if (flags & FLAGS_ADAPT_EXP) {
    80011438:	f7c42703          	lw	a4,-132(s0)
    8001143c:	6785                	lui	a5,0x1
    8001143e:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80011442:	8ff9                	and	a5,a5,a4
    80011444:	2781                	sext.w	a5,a5
    80011446:	c7c1                	beqz	a5,800114ce <_etoa+0x338>
        // do we want to fall-back to "%f" mode?
        if ((value >= 1e-4) && (value < 1e6)) {
    80011448:	f8843707          	fld	fa4,-120(s0)
    8001144c:	0000a797          	auipc	a5,0xa
    80011450:	ebc78793          	addi	a5,a5,-324 # 8001b308 <pow10.0+0xd8>
    80011454:	239c                	fld	fa5,0(a5)
    80011456:	a2e787d3          	fle.d	a5,fa5,fa4
    8001145a:	cbb9                	beqz	a5,800114b0 <_etoa+0x31a>
    8001145c:	f8843707          	fld	fa4,-120(s0)
    80011460:	0000a797          	auipc	a5,0xa
    80011464:	eb078793          	addi	a5,a5,-336 # 8001b310 <pow10.0+0xe0>
    80011468:	239c                	fld	fa5,0(a5)
    8001146a:	a2f717d3          	flt.d	a5,fa4,fa5
    8001146e:	c3a9                	beqz	a5,800114b0 <_etoa+0x31a>
            if ((int)prec > expval) {
    80011470:	f8442703          	lw	a4,-124(s0)
    80011474:	fec42783          	lw	a5,-20(s0)
    80011478:	2781                	sext.w	a5,a5
    8001147a:	00e7de63          	bge	a5,a4,80011496 <_etoa+0x300>
                prec = (unsigned)((int)prec - expval - 1);
    8001147e:	f8442703          	lw	a4,-124(s0)
    80011482:	fec42783          	lw	a5,-20(s0)
    80011486:	40f707bb          	subw	a5,a4,a5
    8001148a:	2781                	sext.w	a5,a5
    8001148c:	37fd                	addiw	a5,a5,-1
    8001148e:	2781                	sext.w	a5,a5
    80011490:	f8f42223          	sw	a5,-124(s0)
    80011494:	a019                	j	8001149a <_etoa+0x304>
            }
            else {
                prec = 0;
    80011496:	f8042223          	sw	zero,-124(s0)
            }
            flags |= FLAGS_PRECISION;  // make sure _ftoa respects precision
    8001149a:	f7c42783          	lw	a5,-132(s0)
    8001149e:	4007e793          	ori	a5,a5,1024
    800114a2:	f6f42e23          	sw	a5,-132(s0)
            // no characters in exponent
            minwidth = 0U;
    800114a6:	fe042423          	sw	zero,-24(s0)
            expval   = 0;
    800114aa:	fe042623          	sw	zero,-20(s0)
    800114ae:	a005                	j	800114ce <_etoa+0x338>
        }
        else {
            // we use one sigfig for the whole part
            if ((prec > 0) && (flags & FLAGS_PRECISION)) {
    800114b0:	f8442783          	lw	a5,-124(s0)
    800114b4:	2781                	sext.w	a5,a5
    800114b6:	cf81                	beqz	a5,800114ce <_etoa+0x338>
    800114b8:	f7c42783          	lw	a5,-132(s0)
    800114bc:	4007f793          	andi	a5,a5,1024
    800114c0:	2781                	sext.w	a5,a5
    800114c2:	c791                	beqz	a5,800114ce <_etoa+0x338>
                --prec;
    800114c4:	f8442783          	lw	a5,-124(s0)
    800114c8:	37fd                	addiw	a5,a5,-1
    800114ca:	f8f42223          	sw	a5,-124(s0)
            }
        }
    }

    // will everything fit?
    unsigned int fwidth = width;
    800114ce:	f8042783          	lw	a5,-128(s0)
    800114d2:	fef42223          	sw	a5,-28(s0)
    if (width > minwidth) {
    800114d6:	f8042703          	lw	a4,-128(s0)
    800114da:	fe842783          	lw	a5,-24(s0)
    800114de:	2701                	sext.w	a4,a4
    800114e0:	2781                	sext.w	a5,a5
    800114e2:	00e7fb63          	bgeu	a5,a4,800114f8 <_etoa+0x362>
        // we didn't fall-back so subtract the characters required for the
        // exponent
        fwidth -= minwidth;
    800114e6:	fe442703          	lw	a4,-28(s0)
    800114ea:	fe842783          	lw	a5,-24(s0)
    800114ee:	40f707bb          	subw	a5,a4,a5
    800114f2:	fef42223          	sw	a5,-28(s0)
    800114f6:	a019                	j	800114fc <_etoa+0x366>
    }
    else {
        // not enough characters, so go back to default sizing
        fwidth = 0U;
    800114f8:	fe042223          	sw	zero,-28(s0)
    }
    if ((flags & FLAGS_LEFT) && minwidth) {
    800114fc:	f7c42783          	lw	a5,-132(s0)
    80011500:	8b89                	andi	a5,a5,2
    80011502:	2781                	sext.w	a5,a5
    80011504:	c799                	beqz	a5,80011512 <_etoa+0x37c>
    80011506:	fe842783          	lw	a5,-24(s0)
    8001150a:	2781                	sext.w	a5,a5
    8001150c:	c399                	beqz	a5,80011512 <_etoa+0x37c>
        // if we're padding on the right, DON'T pad the floating part
        fwidth = 0U;
    8001150e:	fe042223          	sw	zero,-28(s0)
    }

    // rescale the float value
    if (expval) {
    80011512:	fec42783          	lw	a5,-20(s0)
    80011516:	2781                	sext.w	a5,a5
    80011518:	cb89                	beqz	a5,8001152a <_etoa+0x394>
        value /= conv.F;
    8001151a:	fb843787          	fld	fa5,-72(s0)
    8001151e:	f8843707          	fld	fa4,-120(s0)
    80011522:	1af777d3          	fdiv.d	fa5,fa4,fa5
    80011526:	f8f43427          	fsd	fa5,-120(s0)
    }

    // output the floating part
    const size_t start_idx = idx;
    8001152a:	f9843783          	ld	a5,-104(s0)
    8001152e:	fcf43023          	sd	a5,-64(s0)
    idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec,
    80011532:	fe344783          	lbu	a5,-29(s0)
    80011536:	0ff7f793          	andi	a5,a5,255
    8001153a:	c791                	beqz	a5,80011546 <_etoa+0x3b0>
    8001153c:	f8843787          	fld	fa5,-120(s0)
    80011540:	22f797d3          	fneg.d	fa5,fa5
    80011544:	a019                	j	8001154a <_etoa+0x3b4>
    80011546:	f8843787          	fld	fa5,-120(s0)
    8001154a:	f7c42703          	lw	a4,-132(s0)
    8001154e:	77fd                	lui	a5,0xfffff
    80011550:	7ff78793          	addi	a5,a5,2047 # fffffffffffff7ff <_heap_end+0xffffffff77fef7ff>
    80011554:	8ff9                	and	a5,a5,a4
    80011556:	0007869b          	sext.w	a3,a5
    8001155a:	fe442783          	lw	a5,-28(s0)
    8001155e:	f8442703          	lw	a4,-124(s0)
    80011562:	8836                	mv	a6,a3
    80011564:	22f78553          	fmv.d	fa0,fa5
    80011568:	f9043683          	ld	a3,-112(s0)
    8001156c:	f9843603          	ld	a2,-104(s0)
    80011570:	fa043583          	ld	a1,-96(s0)
    80011574:	fa843503          	ld	a0,-88(s0)
    80011578:	ed2ff0ef          	jal	ra,80010c4a <_ftoa>
    8001157c:	f8a43c23          	sd	a0,-104(s0)
                fwidth, flags & ~FLAGS_ADAPT_EXP);

    // output the exponent part
    if (minwidth) {
    80011580:	fe842783          	lw	a5,-24(s0)
    80011584:	2781                	sext.w	a5,a5
    80011586:	c3f1                	beqz	a5,8001164a <_etoa+0x4b4>
        // output the exponential symbol
        out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    80011588:	f7c42783          	lw	a5,-132(s0)
    8001158c:	0207f793          	andi	a5,a5,32
    80011590:	2781                	sext.w	a5,a5
    80011592:	c781                	beqz	a5,8001159a <_etoa+0x404>
    80011594:	04500793          	li	a5,69
    80011598:	a019                	j	8001159e <_etoa+0x408>
    8001159a:	06500793          	li	a5,101
    8001159e:	f9843703          	ld	a4,-104(s0)
    800115a2:	00170693          	addi	a3,a4,1
    800115a6:	f8d43c23          	sd	a3,-104(s0)
    800115aa:	fa843803          	ld	a6,-88(s0)
    800115ae:	f9043683          	ld	a3,-112(s0)
    800115b2:	863a                	mv	a2,a4
    800115b4:	fa043583          	ld	a1,-96(s0)
    800115b8:	853e                	mv	a0,a5
    800115ba:	9802                	jalr	a6
        // output the exponent value
        idx = _ntoa_long(out, buffer, idx, maxlen,
                         (expval < 0) ? -expval : expval, expval < 0, 10, 0,
    800115bc:	fec42783          	lw	a5,-20(s0)
    800115c0:	41f7d79b          	sraiw	a5,a5,0x1f
    800115c4:	fec42703          	lw	a4,-20(s0)
    800115c8:	8f3d                	xor	a4,a4,a5
    800115ca:	40f707bb          	subw	a5,a4,a5
    800115ce:	2781                	sext.w	a5,a5
        idx = _ntoa_long(out, buffer, idx, maxlen,
    800115d0:	863e                	mv	a2,a5
    800115d2:	fec42783          	lw	a5,-20(s0)
    800115d6:	01f7d79b          	srliw	a5,a5,0x1f
    800115da:	0ff7f693          	andi	a3,a5,255
    800115de:	fe842783          	lw	a5,-24(s0)
    800115e2:	37fd                	addiw	a5,a5,-1
    800115e4:	2781                	sext.w	a5,a5
    800115e6:	4715                	li	a4,5
    800115e8:	e43a                	sd	a4,8(sp)
    800115ea:	e03e                	sd	a5,0(sp)
    800115ec:	4881                	li	a7,0
    800115ee:	4829                	li	a6,10
    800115f0:	87b6                	mv	a5,a3
    800115f2:	8732                	mv	a4,a2
    800115f4:	f9043683          	ld	a3,-112(s0)
    800115f8:	f9843603          	ld	a2,-104(s0)
    800115fc:	fa043583          	ld	a1,-96(s0)
    80011600:	fa843503          	ld	a0,-88(s0)
    80011604:	c16ff0ef          	jal	ra,80010a1a <_ntoa_long>
    80011608:	f8a43c23          	sd	a0,-104(s0)
                         minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
        // might need to right-pad spaces
        if (flags & FLAGS_LEFT) {
    8001160c:	f7c42783          	lw	a5,-132(s0)
    80011610:	8b89                	andi	a5,a5,2
    80011612:	2781                	sext.w	a5,a5
    80011614:	cb9d                	beqz	a5,8001164a <_etoa+0x4b4>
            while (idx - start_idx < width)
    80011616:	a00d                	j	80011638 <_etoa+0x4a2>
                out(' ', buffer, idx++, maxlen);
    80011618:	f9843783          	ld	a5,-104(s0)
    8001161c:	00178713          	addi	a4,a5,1
    80011620:	f8e43c23          	sd	a4,-104(s0)
    80011624:	fa843703          	ld	a4,-88(s0)
    80011628:	f9043683          	ld	a3,-112(s0)
    8001162c:	863e                	mv	a2,a5
    8001162e:	fa043583          	ld	a1,-96(s0)
    80011632:	02000513          	li	a0,32
    80011636:	9702                	jalr	a4
            while (idx - start_idx < width)
    80011638:	f9843703          	ld	a4,-104(s0)
    8001163c:	fc043783          	ld	a5,-64(s0)
    80011640:	8f1d                	sub	a4,a4,a5
    80011642:	f8046783          	lwu	a5,-128(s0)
    80011646:	fcf769e3          	bltu	a4,a5,80011618 <_etoa+0x482>
        }
    }
    return idx;
    8001164a:	f9843783          	ld	a5,-104(s0)
}
    8001164e:	853e                	mv	a0,a5
    80011650:	60ea                	ld	ra,152(sp)
    80011652:	644a                	ld	s0,144(sp)
    80011654:	610d                	addi	sp,sp,160
    80011656:	8082                	ret

0000000080011658 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
                      const char *format, va_list va)
{
    80011658:	7135                	addi	sp,sp,-160
    8001165a:	ed06                	sd	ra,152(sp)
    8001165c:	e922                	sd	s0,144(sp)
    8001165e:	1100                	addi	s0,sp,160
    80011660:	f8a43c23          	sd	a0,-104(s0)
    80011664:	f8b43823          	sd	a1,-112(s0)
    80011668:	f8c43423          	sd	a2,-120(s0)
    8001166c:	f8d43023          	sd	a3,-128(s0)
    80011670:	f6e43c23          	sd	a4,-136(s0)
    unsigned int flags, width, precision, n;
    size_t idx = 0U;
    80011674:	fc043c23          	sd	zero,-40(s0)

    if (!buffer) {
    80011678:	f9043783          	ld	a5,-112(s0)
    8001167c:	380792e3          	bnez	a5,80012200 <_vsnprintf+0xba8>
        // use null output function
        out = _out_null;
    80011680:	fffff797          	auipc	a5,0xfffff
    80011684:	e5878793          	addi	a5,a5,-424 # 800104d8 <_out_null>
    80011688:	f8f43c23          	sd	a5,-104(s0)
    }

    while (*format) {
    8001168c:	3750006f          	j	80012200 <_vsnprintf+0xba8>
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
    80011690:	f8043783          	ld	a5,-128(s0)
    80011694:	0007c783          	lbu	a5,0(a5)
    80011698:	873e                	mv	a4,a5
    8001169a:	02500793          	li	a5,37
    8001169e:	02f70b63          	beq	a4,a5,800116d4 <_vsnprintf+0x7c>
            // no
            out(*format, buffer, idx++, maxlen);
    800116a2:	f8043783          	ld	a5,-128(s0)
    800116a6:	0007c503          	lbu	a0,0(a5)
    800116aa:	fd843783          	ld	a5,-40(s0)
    800116ae:	00178713          	addi	a4,a5,1
    800116b2:	fce43c23          	sd	a4,-40(s0)
    800116b6:	f9843703          	ld	a4,-104(s0)
    800116ba:	f8843683          	ld	a3,-120(s0)
    800116be:	863e                	mv	a2,a5
    800116c0:	f9043583          	ld	a1,-112(s0)
    800116c4:	9702                	jalr	a4
            format++;
    800116c6:	f8043783          	ld	a5,-128(s0)
    800116ca:	0785                	addi	a5,a5,1
    800116cc:	f8f43023          	sd	a5,-128(s0)
            continue;
    800116d0:	3310006f          	j	80012200 <_vsnprintf+0xba8>
        }
        else {
            // yes, evaluate it
            format++;
    800116d4:	f8043783          	ld	a5,-128(s0)
    800116d8:	0785                	addi	a5,a5,1
    800116da:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate flags
        flags = 0U;
    800116de:	fe042623          	sw	zero,-20(s0)
        do {
            switch (*format) {
    800116e2:	f8043783          	ld	a5,-128(s0)
    800116e6:	0007c783          	lbu	a5,0(a5)
    800116ea:	2781                	sext.w	a5,a5
    800116ec:	fe07869b          	addiw	a3,a5,-32
    800116f0:	0006871b          	sext.w	a4,a3
    800116f4:	47c1                	li	a5,16
    800116f6:	0ce7e063          	bltu	a5,a4,800117b6 <_vsnprintf+0x15e>
    800116fa:	02069793          	slli	a5,a3,0x20
    800116fe:	9381                	srli	a5,a5,0x20
    80011700:	00279713          	slli	a4,a5,0x2
    80011704:	0000a797          	auipc	a5,0xa
    80011708:	94878793          	addi	a5,a5,-1720 # 8001b04c <SYSCALLS+0x4c>
    8001170c:	97ba                	add	a5,a5,a4
    8001170e:	439c                	lw	a5,0(a5)
    80011710:	0007871b          	sext.w	a4,a5
    80011714:	0000a797          	auipc	a5,0xa
    80011718:	93878793          	addi	a5,a5,-1736 # 8001b04c <SYSCALLS+0x4c>
    8001171c:	97ba                	add	a5,a5,a4
    8001171e:	8782                	jr	a5
                case '0':
                    flags |= FLAGS_ZEROPAD;
    80011720:	fec42783          	lw	a5,-20(s0)
    80011724:	0017e793          	ori	a5,a5,1
    80011728:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001172c:	f8043783          	ld	a5,-128(s0)
    80011730:	0785                	addi	a5,a5,1
    80011732:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011736:	4785                	li	a5,1
    80011738:	fef42023          	sw	a5,-32(s0)
                    break;
    8001173c:	a041                	j	800117bc <_vsnprintf+0x164>
                case '-':
                    flags |= FLAGS_LEFT;
    8001173e:	fec42783          	lw	a5,-20(s0)
    80011742:	0027e793          	ori	a5,a5,2
    80011746:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001174a:	f8043783          	ld	a5,-128(s0)
    8001174e:	0785                	addi	a5,a5,1
    80011750:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011754:	4785                	li	a5,1
    80011756:	fef42023          	sw	a5,-32(s0)
                    break;
    8001175a:	a08d                	j	800117bc <_vsnprintf+0x164>
                case '+':
                    flags |= FLAGS_PLUS;
    8001175c:	fec42783          	lw	a5,-20(s0)
    80011760:	0047e793          	ori	a5,a5,4
    80011764:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011768:	f8043783          	ld	a5,-128(s0)
    8001176c:	0785                	addi	a5,a5,1
    8001176e:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011772:	4785                	li	a5,1
    80011774:	fef42023          	sw	a5,-32(s0)
                    break;
    80011778:	a091                	j	800117bc <_vsnprintf+0x164>
                case ' ':
                    flags |= FLAGS_SPACE;
    8001177a:	fec42783          	lw	a5,-20(s0)
    8001177e:	0087e793          	ori	a5,a5,8
    80011782:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011786:	f8043783          	ld	a5,-128(s0)
    8001178a:	0785                	addi	a5,a5,1
    8001178c:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011790:	4785                	li	a5,1
    80011792:	fef42023          	sw	a5,-32(s0)
                    break;
    80011796:	a01d                	j	800117bc <_vsnprintf+0x164>
                case '#':
                    flags |= FLAGS_HASH;
    80011798:	fec42783          	lw	a5,-20(s0)
    8001179c:	0107e793          	ori	a5,a5,16
    800117a0:	fef42623          	sw	a5,-20(s0)
                    format++;
    800117a4:	f8043783          	ld	a5,-128(s0)
    800117a8:	0785                	addi	a5,a5,1
    800117aa:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    800117ae:	4785                	li	a5,1
    800117b0:	fef42023          	sw	a5,-32(s0)
                    break;
    800117b4:	a021                	j	800117bc <_vsnprintf+0x164>
                default:
                    n = 0U;
    800117b6:	fe042023          	sw	zero,-32(s0)
                    break;
    800117ba:	0001                	nop
            }
        } while (n);
    800117bc:	fe042783          	lw	a5,-32(s0)
    800117c0:	2781                	sext.w	a5,a5
    800117c2:	f385                	bnez	a5,800116e2 <_vsnprintf+0x8a>

        // evaluate width field
        width = 0U;
    800117c4:	fe042423          	sw	zero,-24(s0)
        if (_is_digit(*format)) {
    800117c8:	f8043783          	ld	a5,-128(s0)
    800117cc:	0007c783          	lbu	a5,0(a5)
    800117d0:	853e                	mv	a0,a5
    800117d2:	df3fe0ef          	jal	ra,800105c4 <_is_digit>
    800117d6:	87aa                	mv	a5,a0
    800117d8:	cb91                	beqz	a5,800117ec <_vsnprintf+0x194>
            width = _atoi(&format);
    800117da:	f8040793          	addi	a5,s0,-128
    800117de:	853e                	mv	a0,a5
    800117e0:	e25fe0ef          	jal	ra,80010604 <_atoi>
    800117e4:	87aa                	mv	a5,a0
    800117e6:	fef42423          	sw	a5,-24(s0)
    800117ea:	a8b9                	j	80011848 <_vsnprintf+0x1f0>
        }
        else if (*format == '*') {
    800117ec:	f8043783          	ld	a5,-128(s0)
    800117f0:	0007c783          	lbu	a5,0(a5)
    800117f4:	873e                	mv	a4,a5
    800117f6:	02a00793          	li	a5,42
    800117fa:	04f71763          	bne	a4,a5,80011848 <_vsnprintf+0x1f0>
            const int w = va_arg(va, int);
    800117fe:	f7843783          	ld	a5,-136(s0)
    80011802:	00878713          	addi	a4,a5,8
    80011806:	f6e43c23          	sd	a4,-136(s0)
    8001180a:	439c                	lw	a5,0(a5)
    8001180c:	fcf42023          	sw	a5,-64(s0)
            if (w < 0) {
    80011810:	fc042783          	lw	a5,-64(s0)
    80011814:	2781                	sext.w	a5,a5
    80011816:	0207d063          	bgez	a5,80011836 <_vsnprintf+0x1de>
                flags |= FLAGS_LEFT;  // reverse padding
    8001181a:	fec42783          	lw	a5,-20(s0)
    8001181e:	0027e793          	ori	a5,a5,2
    80011822:	fef42623          	sw	a5,-20(s0)
                width = (unsigned int)-w;
    80011826:	fc042783          	lw	a5,-64(s0)
    8001182a:	40f007bb          	negw	a5,a5
    8001182e:	2781                	sext.w	a5,a5
    80011830:	fef42423          	sw	a5,-24(s0)
    80011834:	a029                	j	8001183e <_vsnprintf+0x1e6>
            }
            else {
                width = (unsigned int)w;
    80011836:	fc042783          	lw	a5,-64(s0)
    8001183a:	fef42423          	sw	a5,-24(s0)
            }
            format++;
    8001183e:	f8043783          	ld	a5,-128(s0)
    80011842:	0785                	addi	a5,a5,1
    80011844:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate precision field
        precision = 0U;
    80011848:	fe042223          	sw	zero,-28(s0)
        if (*format == '.') {
    8001184c:	f8043783          	ld	a5,-128(s0)
    80011850:	0007c783          	lbu	a5,0(a5)
    80011854:	873e                	mv	a4,a5
    80011856:	02e00793          	li	a5,46
    8001185a:	08f71063          	bne	a4,a5,800118da <_vsnprintf+0x282>
            flags |= FLAGS_PRECISION;
    8001185e:	fec42783          	lw	a5,-20(s0)
    80011862:	4007e793          	ori	a5,a5,1024
    80011866:	fef42623          	sw	a5,-20(s0)
            format++;
    8001186a:	f8043783          	ld	a5,-128(s0)
    8001186e:	0785                	addi	a5,a5,1
    80011870:	f8f43023          	sd	a5,-128(s0)
            if (_is_digit(*format)) {
    80011874:	f8043783          	ld	a5,-128(s0)
    80011878:	0007c783          	lbu	a5,0(a5)
    8001187c:	853e                	mv	a0,a5
    8001187e:	d47fe0ef          	jal	ra,800105c4 <_is_digit>
    80011882:	87aa                	mv	a5,a0
    80011884:	cb91                	beqz	a5,80011898 <_vsnprintf+0x240>
                precision = _atoi(&format);
    80011886:	f8040793          	addi	a5,s0,-128
    8001188a:	853e                	mv	a0,a5
    8001188c:	d79fe0ef          	jal	ra,80010604 <_atoi>
    80011890:	87aa                	mv	a5,a0
    80011892:	fef42223          	sw	a5,-28(s0)
    80011896:	a091                	j	800118da <_vsnprintf+0x282>
            }
            else if (*format == '*') {
    80011898:	f8043783          	ld	a5,-128(s0)
    8001189c:	0007c783          	lbu	a5,0(a5)
    800118a0:	873e                	mv	a4,a5
    800118a2:	02a00793          	li	a5,42
    800118a6:	02f71a63          	bne	a4,a5,800118da <_vsnprintf+0x282>
                const int prec = (int)va_arg(va, int);
    800118aa:	f7843783          	ld	a5,-136(s0)
    800118ae:	00878713          	addi	a4,a5,8
    800118b2:	f6e43c23          	sd	a4,-136(s0)
    800118b6:	439c                	lw	a5,0(a5)
    800118b8:	faf42e23          	sw	a5,-68(s0)
                precision      = prec > 0 ? (unsigned int)prec : 0U;
    800118bc:	fbc42783          	lw	a5,-68(s0)
    800118c0:	0007871b          	sext.w	a4,a5
    800118c4:	00075363          	bgez	a4,800118ca <_vsnprintf+0x272>
    800118c8:	4781                	li	a5,0
    800118ca:	2781                	sext.w	a5,a5
    800118cc:	fef42223          	sw	a5,-28(s0)
                format++;
    800118d0:	f8043783          	ld	a5,-128(s0)
    800118d4:	0785                	addi	a5,a5,1
    800118d6:	f8f43023          	sd	a5,-128(s0)
            }
        }

        // evaluate length field
        switch (*format) {
    800118da:	f8043783          	ld	a5,-128(s0)
    800118de:	0007c783          	lbu	a5,0(a5)
    800118e2:	2781                	sext.w	a5,a5
    800118e4:	f987869b          	addiw	a3,a5,-104
    800118e8:	0006871b          	sext.w	a4,a3
    800118ec:	47c9                	li	a5,18
    800118ee:	0ee7e963          	bltu	a5,a4,800119e0 <_vsnprintf+0x388>
    800118f2:	02069793          	slli	a5,a3,0x20
    800118f6:	9381                	srli	a5,a5,0x20
    800118f8:	00279713          	slli	a4,a5,0x2
    800118fc:	00009797          	auipc	a5,0x9
    80011900:	79478793          	addi	a5,a5,1940 # 8001b090 <SYSCALLS+0x90>
    80011904:	97ba                	add	a5,a5,a4
    80011906:	439c                	lw	a5,0(a5)
    80011908:	0007871b          	sext.w	a4,a5
    8001190c:	00009797          	auipc	a5,0x9
    80011910:	78478793          	addi	a5,a5,1924 # 8001b090 <SYSCALLS+0x90>
    80011914:	97ba                	add	a5,a5,a4
    80011916:	8782                	jr	a5
            case 'l':
                flags |= FLAGS_LONG;
    80011918:	fec42783          	lw	a5,-20(s0)
    8001191c:	1007e793          	ori	a5,a5,256
    80011920:	fef42623          	sw	a5,-20(s0)
                format++;
    80011924:	f8043783          	ld	a5,-128(s0)
    80011928:	0785                	addi	a5,a5,1
    8001192a:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'l') {
    8001192e:	f8043783          	ld	a5,-128(s0)
    80011932:	0007c783          	lbu	a5,0(a5)
    80011936:	873e                	mv	a4,a5
    80011938:	06c00793          	li	a5,108
    8001193c:	0af71463          	bne	a4,a5,800119e4 <_vsnprintf+0x38c>
                    flags |= FLAGS_LONG_LONG;
    80011940:	fec42783          	lw	a5,-20(s0)
    80011944:	2007e793          	ori	a5,a5,512
    80011948:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001194c:	f8043783          	ld	a5,-128(s0)
    80011950:	0785                	addi	a5,a5,1
    80011952:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80011956:	a079                	j	800119e4 <_vsnprintf+0x38c>
            case 'h':
                flags |= FLAGS_SHORT;
    80011958:	fec42783          	lw	a5,-20(s0)
    8001195c:	0807e793          	ori	a5,a5,128
    80011960:	fef42623          	sw	a5,-20(s0)
                format++;
    80011964:	f8043783          	ld	a5,-128(s0)
    80011968:	0785                	addi	a5,a5,1
    8001196a:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'h') {
    8001196e:	f8043783          	ld	a5,-128(s0)
    80011972:	0007c783          	lbu	a5,0(a5)
    80011976:	873e                	mv	a4,a5
    80011978:	06800793          	li	a5,104
    8001197c:	06f71663          	bne	a4,a5,800119e8 <_vsnprintf+0x390>
                    flags |= FLAGS_CHAR;
    80011980:	fec42783          	lw	a5,-20(s0)
    80011984:	0407e793          	ori	a5,a5,64
    80011988:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001198c:	f8043783          	ld	a5,-128(s0)
    80011990:	0785                	addi	a5,a5,1
    80011992:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80011996:	a889                	j	800119e8 <_vsnprintf+0x390>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
            case 't':
                flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG
    80011998:	fec42783          	lw	a5,-20(s0)
    8001199c:	1007e793          	ori	a5,a5,256
    800119a0:	fef42623          	sw	a5,-20(s0)
                                                            : FLAGS_LONG_LONG);
                format++;
    800119a4:	f8043783          	ld	a5,-128(s0)
    800119a8:	0785                	addi	a5,a5,1
    800119aa:	f8f43023          	sd	a5,-128(s0)
                break;
    800119ae:	a835                	j	800119ea <_vsnprintf+0x392>
#endif
            case 'j':
                flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG
    800119b0:	fec42783          	lw	a5,-20(s0)
    800119b4:	1007e793          	ori	a5,a5,256
    800119b8:	fef42623          	sw	a5,-20(s0)
                                                           : FLAGS_LONG_LONG);
                format++;
    800119bc:	f8043783          	ld	a5,-128(s0)
    800119c0:	0785                	addi	a5,a5,1
    800119c2:	f8f43023          	sd	a5,-128(s0)
                break;
    800119c6:	a015                	j	800119ea <_vsnprintf+0x392>
            case 'z':
                flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG
    800119c8:	fec42783          	lw	a5,-20(s0)
    800119cc:	1007e793          	ori	a5,a5,256
    800119d0:	fef42623          	sw	a5,-20(s0)
                                                         : FLAGS_LONG_LONG);
                format++;
    800119d4:	f8043783          	ld	a5,-128(s0)
    800119d8:	0785                	addi	a5,a5,1
    800119da:	f8f43023          	sd	a5,-128(s0)
                break;
    800119de:	a031                	j	800119ea <_vsnprintf+0x392>
            default:
                break;
    800119e0:	0001                	nop
    800119e2:	a021                	j	800119ea <_vsnprintf+0x392>
                break;
    800119e4:	0001                	nop
    800119e6:	a011                	j	800119ea <_vsnprintf+0x392>
                break;
    800119e8:	0001                	nop
        }

        // evaluate specifier
        switch (*format) {
    800119ea:	f8043783          	ld	a5,-128(s0)
    800119ee:	0007c783          	lbu	a5,0(a5)
    800119f2:	2781                	sext.w	a5,a5
    800119f4:	fdb7869b          	addiw	a3,a5,-37
    800119f8:	0006871b          	sext.w	a4,a3
    800119fc:	05300793          	li	a5,83
    80011a00:	7ce7e863          	bltu	a5,a4,800121d0 <_vsnprintf+0xb78>
    80011a04:	02069793          	slli	a5,a3,0x20
    80011a08:	9381                	srli	a5,a5,0x20
    80011a0a:	00279713          	slli	a4,a5,0x2
    80011a0e:	00009797          	auipc	a5,0x9
    80011a12:	6ce78793          	addi	a5,a5,1742 # 8001b0dc <SYSCALLS+0xdc>
    80011a16:	97ba                	add	a5,a5,a4
    80011a18:	439c                	lw	a5,0(a5)
    80011a1a:	0007871b          	sext.w	a4,a5
    80011a1e:	00009797          	auipc	a5,0x9
    80011a22:	6be78793          	addi	a5,a5,1726 # 8001b0dc <SYSCALLS+0xdc>
    80011a26:	97ba                	add	a5,a5,a4
    80011a28:	8782                	jr	a5
            case 'X':
            case 'o':
            case 'b': {
                // set the base
                unsigned int base;
                if (*format == 'x' || *format == 'X') {
    80011a2a:	f8043783          	ld	a5,-128(s0)
    80011a2e:	0007c783          	lbu	a5,0(a5)
    80011a32:	873e                	mv	a4,a5
    80011a34:	07800793          	li	a5,120
    80011a38:	00f70b63          	beq	a4,a5,80011a4e <_vsnprintf+0x3f6>
    80011a3c:	f8043783          	ld	a5,-128(s0)
    80011a40:	0007c783          	lbu	a5,0(a5)
    80011a44:	873e                	mv	a4,a5
    80011a46:	05800793          	li	a5,88
    80011a4a:	00f71663          	bne	a4,a5,80011a56 <_vsnprintf+0x3fe>
                    base = 16U;
    80011a4e:	47c1                	li	a5,16
    80011a50:	fcf42a23          	sw	a5,-44(s0)
    80011a54:	a099                	j	80011a9a <_vsnprintf+0x442>
                }
                else if (*format == 'o') {
    80011a56:	f8043783          	ld	a5,-128(s0)
    80011a5a:	0007c783          	lbu	a5,0(a5)
    80011a5e:	873e                	mv	a4,a5
    80011a60:	06f00793          	li	a5,111
    80011a64:	00f71663          	bne	a4,a5,80011a70 <_vsnprintf+0x418>
                    base = 8U;
    80011a68:	47a1                	li	a5,8
    80011a6a:	fcf42a23          	sw	a5,-44(s0)
    80011a6e:	a035                	j	80011a9a <_vsnprintf+0x442>
                }
                else if (*format == 'b') {
    80011a70:	f8043783          	ld	a5,-128(s0)
    80011a74:	0007c783          	lbu	a5,0(a5)
    80011a78:	873e                	mv	a4,a5
    80011a7a:	06200793          	li	a5,98
    80011a7e:	00f71663          	bne	a4,a5,80011a8a <_vsnprintf+0x432>
                    base = 2U;
    80011a82:	4789                	li	a5,2
    80011a84:	fcf42a23          	sw	a5,-44(s0)
    80011a88:	a809                	j	80011a9a <_vsnprintf+0x442>
                }
                else {
                    base = 10U;
    80011a8a:	47a9                	li	a5,10
    80011a8c:	fcf42a23          	sw	a5,-44(s0)
                    flags &= ~FLAGS_HASH;  // no hash for dec format
    80011a90:	fec42783          	lw	a5,-20(s0)
    80011a94:	9bbd                	andi	a5,a5,-17
    80011a96:	fef42623          	sw	a5,-20(s0)
                }
                // uppercase
                if (*format == 'X') {
    80011a9a:	f8043783          	ld	a5,-128(s0)
    80011a9e:	0007c783          	lbu	a5,0(a5)
    80011aa2:	873e                	mv	a4,a5
    80011aa4:	05800793          	li	a5,88
    80011aa8:	00f71863          	bne	a4,a5,80011ab8 <_vsnprintf+0x460>
                    flags |= FLAGS_UPPERCASE;
    80011aac:	fec42783          	lw	a5,-20(s0)
    80011ab0:	0207e793          	ori	a5,a5,32
    80011ab4:	fef42623          	sw	a5,-20(s0)
                }

                // no plus or space flag for u, x, X, o, b
                if ((*format != 'i') && (*format != 'd')) {
    80011ab8:	f8043783          	ld	a5,-128(s0)
    80011abc:	0007c783          	lbu	a5,0(a5)
    80011ac0:	873e                	mv	a4,a5
    80011ac2:	06900793          	li	a5,105
    80011ac6:	02f70063          	beq	a4,a5,80011ae6 <_vsnprintf+0x48e>
    80011aca:	f8043783          	ld	a5,-128(s0)
    80011ace:	0007c783          	lbu	a5,0(a5)
    80011ad2:	873e                	mv	a4,a5
    80011ad4:	06400793          	li	a5,100
    80011ad8:	00f70763          	beq	a4,a5,80011ae6 <_vsnprintf+0x48e>
                    flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    80011adc:	fec42783          	lw	a5,-20(s0)
    80011ae0:	9bcd                	andi	a5,a5,-13
    80011ae2:	fef42623          	sw	a5,-20(s0)
                }

                // ignore '0' flag when precision is given
                if (flags & FLAGS_PRECISION) {
    80011ae6:	fec42783          	lw	a5,-20(s0)
    80011aea:	4007f793          	andi	a5,a5,1024
    80011aee:	2781                	sext.w	a5,a5
    80011af0:	c791                	beqz	a5,80011afc <_vsnprintf+0x4a4>
                    flags &= ~FLAGS_ZEROPAD;
    80011af2:	fec42783          	lw	a5,-20(s0)
    80011af6:	9bf9                	andi	a5,a5,-2
    80011af8:	fef42623          	sw	a5,-20(s0)
                }

                // convert the integer
                if ((*format == 'i') || (*format == 'd')) {
    80011afc:	f8043783          	ld	a5,-128(s0)
    80011b00:	0007c783          	lbu	a5,0(a5)
    80011b04:	873e                	mv	a4,a5
    80011b06:	06900793          	li	a5,105
    80011b0a:	00f70b63          	beq	a4,a5,80011b20 <_vsnprintf+0x4c8>
    80011b0e:	f8043783          	ld	a5,-128(s0)
    80011b12:	0007c783          	lbu	a5,0(a5)
    80011b16:	873e                	mv	a4,a5
    80011b18:	06400793          	li	a5,100
    80011b1c:	18f71d63          	bne	a4,a5,80011cb6 <_vsnprintf+0x65e>
                    // signed
                    if (flags & FLAGS_LONG_LONG) {
    80011b20:	fec42783          	lw	a5,-20(s0)
    80011b24:	2007f793          	andi	a5,a5,512
    80011b28:	2781                	sext.w	a5,a5
    80011b2a:	c3bd                	beqz	a5,80011b90 <_vsnprintf+0x538>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        const long long value = va_arg(va, long long);
    80011b2c:	f7843783          	ld	a5,-136(s0)
    80011b30:	00878713          	addi	a4,a5,8
    80011b34:	f6e43c23          	sd	a4,-136(s0)
    80011b38:	639c                	ld	a5,0(a5)
    80011b3a:	faf43023          	sd	a5,-96(s0)
                        idx                   = _ntoa_long_long(
                                              out, buffer, idx, maxlen,
                                              (unsigned long long)(value > 0 ? value : 0 - value),
    80011b3e:	fa043783          	ld	a5,-96(s0)
    80011b42:	43f7d713          	srai	a4,a5,0x3f
    80011b46:	fa043783          	ld	a5,-96(s0)
    80011b4a:	8fb9                	xor	a5,a5,a4
    80011b4c:	8f99                	sub	a5,a5,a4
                        idx                   = _ntoa_long_long(
    80011b4e:	85be                	mv	a1,a5
    80011b50:	fa043783          	ld	a5,-96(s0)
    80011b54:	93fd                	srli	a5,a5,0x3f
    80011b56:	0ff7f713          	andi	a4,a5,255
    80011b5a:	fd446683          	lwu	a3,-44(s0)
    80011b5e:	fe442603          	lw	a2,-28(s0)
    80011b62:	fec42783          	lw	a5,-20(s0)
    80011b66:	e43e                	sd	a5,8(sp)
    80011b68:	fe842783          	lw	a5,-24(s0)
    80011b6c:	e03e                	sd	a5,0(sp)
    80011b6e:	88b2                	mv	a7,a2
    80011b70:	8836                	mv	a6,a3
    80011b72:	87ba                	mv	a5,a4
    80011b74:	872e                	mv	a4,a1
    80011b76:	f8843683          	ld	a3,-120(s0)
    80011b7a:	fd843603          	ld	a2,-40(s0)
    80011b7e:	f9043583          	ld	a1,-112(s0)
    80011b82:	f9843503          	ld	a0,-104(s0)
    80011b86:	fadfe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80011b8a:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011b8e:	ac89                	j	80011de0 <_vsnprintf+0x788>
                                              value < 0, base, precision, width, flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80011b90:	fec42783          	lw	a5,-20(s0)
    80011b94:	1007f793          	andi	a5,a5,256
    80011b98:	2781                	sext.w	a5,a5
    80011b9a:	c3bd                	beqz	a5,80011c00 <_vsnprintf+0x5a8>
                        const long value = va_arg(va, long);
    80011b9c:	f7843783          	ld	a5,-136(s0)
    80011ba0:	00878713          	addi	a4,a5,8
    80011ba4:	f6e43c23          	sd	a4,-136(s0)
    80011ba8:	639c                	ld	a5,0(a5)
    80011baa:	faf43423          	sd	a5,-88(s0)
                        idx              = _ntoa_long(
                                         out, buffer, idx, maxlen,
                                         (unsigned long)(value > 0 ? value : 0 - value),
    80011bae:	fa843783          	ld	a5,-88(s0)
    80011bb2:	43f7d713          	srai	a4,a5,0x3f
    80011bb6:	fa843783          	ld	a5,-88(s0)
    80011bba:	8fb9                	xor	a5,a5,a4
    80011bbc:	8f99                	sub	a5,a5,a4
                        idx              = _ntoa_long(
    80011bbe:	85be                	mv	a1,a5
    80011bc0:	fa843783          	ld	a5,-88(s0)
    80011bc4:	93fd                	srli	a5,a5,0x3f
    80011bc6:	0ff7f713          	andi	a4,a5,255
    80011bca:	fd446683          	lwu	a3,-44(s0)
    80011bce:	fe442603          	lw	a2,-28(s0)
    80011bd2:	fec42783          	lw	a5,-20(s0)
    80011bd6:	e43e                	sd	a5,8(sp)
    80011bd8:	fe842783          	lw	a5,-24(s0)
    80011bdc:	e03e                	sd	a5,0(sp)
    80011bde:	88b2                	mv	a7,a2
    80011be0:	8836                	mv	a6,a3
    80011be2:	87ba                	mv	a5,a4
    80011be4:	872e                	mv	a4,a1
    80011be6:	f8843683          	ld	a3,-120(s0)
    80011bea:	fd843603          	ld	a2,-40(s0)
    80011bee:	f9043583          	ld	a1,-112(s0)
    80011bf2:	f9843503          	ld	a0,-104(s0)
    80011bf6:	e25fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011bfa:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011bfe:	a2cd                	j	80011de0 <_vsnprintf+0x788>
                                         value < 0, base, precision, width, flags);
                    }
                    else {
                        const int value =
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011c00:	fec42783          	lw	a5,-20(s0)
    80011c04:	0407f793          	andi	a5,a5,64
    80011c08:	2781                	sext.w	a5,a5
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c0a:	cf81                	beqz	a5,80011c22 <_vsnprintf+0x5ca>
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011c0c:	f7843783          	ld	a5,-136(s0)
    80011c10:	00878713          	addi	a4,a5,8
    80011c14:	f6e43c23          	sd	a4,-136(s0)
    80011c18:	439c                	lw	a5,0(a5)
    80011c1a:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c1e:	2781                	sext.w	a5,a5
    80011c20:	a81d                	j	80011c56 <_vsnprintf+0x5fe>
    80011c22:	fec42783          	lw	a5,-20(s0)
    80011c26:	0807f793          	andi	a5,a5,128
    80011c2a:	2781                	sext.w	a5,a5
                                                    : va_arg(va, int);
    80011c2c:	cf91                	beqz	a5,80011c48 <_vsnprintf+0x5f0>
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c2e:	f7843783          	ld	a5,-136(s0)
    80011c32:	00878713          	addi	a4,a5,8
    80011c36:	f6e43c23          	sd	a4,-136(s0)
    80011c3a:	439c                	lw	a5,0(a5)
    80011c3c:	0107979b          	slliw	a5,a5,0x10
    80011c40:	4107d79b          	sraiw	a5,a5,0x10
                                                    : va_arg(va, int);
    80011c44:	2781                	sext.w	a5,a5
    80011c46:	a801                	j	80011c56 <_vsnprintf+0x5fe>
    80011c48:	f7843783          	ld	a5,-136(s0)
    80011c4c:	00878713          	addi	a4,a5,8
    80011c50:	f6e43c23          	sd	a4,-136(s0)
    80011c54:	439c                	lw	a5,0(a5)
                        const int value =
    80011c56:	faf42823          	sw	a5,-80(s0)
                        idx = _ntoa_long(
                            out, buffer, idx, maxlen,
                            (unsigned int)(value > 0 ? value : 0 - value),
    80011c5a:	fb042783          	lw	a5,-80(s0)
    80011c5e:	41f7d79b          	sraiw	a5,a5,0x1f
    80011c62:	fb042703          	lw	a4,-80(s0)
    80011c66:	8f3d                	xor	a4,a4,a5
    80011c68:	40f707bb          	subw	a5,a4,a5
    80011c6c:	2781                	sext.w	a5,a5
    80011c6e:	2781                	sext.w	a5,a5
                        idx = _ntoa_long(
    80011c70:	02079713          	slli	a4,a5,0x20
    80011c74:	9301                	srli	a4,a4,0x20
    80011c76:	fb042783          	lw	a5,-80(s0)
    80011c7a:	01f7d79b          	srliw	a5,a5,0x1f
    80011c7e:	0ff7f693          	andi	a3,a5,255
    80011c82:	fd446603          	lwu	a2,-44(s0)
    80011c86:	fe442583          	lw	a1,-28(s0)
    80011c8a:	fec42783          	lw	a5,-20(s0)
    80011c8e:	e43e                	sd	a5,8(sp)
    80011c90:	fe842783          	lw	a5,-24(s0)
    80011c94:	e03e                	sd	a5,0(sp)
    80011c96:	88ae                	mv	a7,a1
    80011c98:	8832                	mv	a6,a2
    80011c9a:	87b6                	mv	a5,a3
    80011c9c:	f8843683          	ld	a3,-120(s0)
    80011ca0:	fd843603          	ld	a2,-40(s0)
    80011ca4:	f9043583          	ld	a1,-112(s0)
    80011ca8:	f9843503          	ld	a0,-104(s0)
    80011cac:	d6ffe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011cb0:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011cb4:	a235                	j	80011de0 <_vsnprintf+0x788>
                            value < 0, base, precision, width, flags);
                    }
                }
                else {
                    // unsigned
                    if (flags & FLAGS_LONG_LONG) {
    80011cb6:	fec42783          	lw	a5,-20(s0)
    80011cba:	2007f793          	andi	a5,a5,512
    80011cbe:	2781                	sext.w	a5,a5
    80011cc0:	c3b1                	beqz	a5,80011d04 <_vsnprintf+0x6ac>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80011cc2:	f7843783          	ld	a5,-136(s0)
    80011cc6:	00878713          	addi	a4,a5,8
    80011cca:	f6e43c23          	sd	a4,-136(s0)
    80011cce:	6398                	ld	a4,0(a5)
    80011cd0:	fd446683          	lwu	a3,-44(s0)
    80011cd4:	fe442603          	lw	a2,-28(s0)
    80011cd8:	fec42783          	lw	a5,-20(s0)
    80011cdc:	e43e                	sd	a5,8(sp)
    80011cde:	fe842783          	lw	a5,-24(s0)
    80011ce2:	e03e                	sd	a5,0(sp)
    80011ce4:	88b2                	mv	a7,a2
    80011ce6:	8836                	mv	a6,a3
    80011ce8:	4781                	li	a5,0
    80011cea:	f8843683          	ld	a3,-120(s0)
    80011cee:	fd843603          	ld	a2,-40(s0)
    80011cf2:	f9043583          	ld	a1,-112(s0)
    80011cf6:	f9843503          	ld	a0,-104(s0)
    80011cfa:	e39fe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80011cfe:	fca43c23          	sd	a0,-40(s0)
    80011d02:	a8f9                	j	80011de0 <_vsnprintf+0x788>
                                              va_arg(va, unsigned long long),
                                              false, base, precision, width,
                                              flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80011d04:	fec42783          	lw	a5,-20(s0)
    80011d08:	1007f793          	andi	a5,a5,256
    80011d0c:	2781                	sext.w	a5,a5
    80011d0e:	c3b1                	beqz	a5,80011d52 <_vsnprintf+0x6fa>
                        idx = _ntoa_long(out, buffer, idx, maxlen,
    80011d10:	f7843783          	ld	a5,-136(s0)
    80011d14:	00878713          	addi	a4,a5,8
    80011d18:	f6e43c23          	sd	a4,-136(s0)
    80011d1c:	6398                	ld	a4,0(a5)
    80011d1e:	fd446683          	lwu	a3,-44(s0)
    80011d22:	fe442603          	lw	a2,-28(s0)
    80011d26:	fec42783          	lw	a5,-20(s0)
    80011d2a:	e43e                	sd	a5,8(sp)
    80011d2c:	fe842783          	lw	a5,-24(s0)
    80011d30:	e03e                	sd	a5,0(sp)
    80011d32:	88b2                	mv	a7,a2
    80011d34:	8836                	mv	a6,a3
    80011d36:	4781                	li	a5,0
    80011d38:	f8843683          	ld	a3,-120(s0)
    80011d3c:	fd843603          	ld	a2,-40(s0)
    80011d40:	f9043583          	ld	a1,-112(s0)
    80011d44:	f9843503          	ld	a0,-104(s0)
    80011d48:	cd3fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011d4c:	fca43c23          	sd	a0,-40(s0)
    80011d50:	a841                	j	80011de0 <_vsnprintf+0x788>
                                         va_arg(va, unsigned long), false, base,
                                         precision, width, flags);
                    }
                    else {
                        const unsigned int value =
                            (flags & FLAGS_CHAR)
    80011d52:	fec42783          	lw	a5,-20(s0)
    80011d56:	0407f793          	andi	a5,a5,64
    80011d5a:	2781                	sext.w	a5,a5
                                ? (unsigned char)va_arg(va, unsigned int)
                            : (flags & FLAGS_SHORT)
    80011d5c:	cf81                	beqz	a5,80011d74 <_vsnprintf+0x71c>
                                ? (unsigned char)va_arg(va, unsigned int)
    80011d5e:	f7843783          	ld	a5,-136(s0)
    80011d62:	00878713          	addi	a4,a5,8
    80011d66:	f6e43c23          	sd	a4,-136(s0)
    80011d6a:	439c                	lw	a5,0(a5)
    80011d6c:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT)
    80011d70:	2781                	sext.w	a5,a5
    80011d72:	a815                	j	80011da6 <_vsnprintf+0x74e>
    80011d74:	fec42783          	lw	a5,-20(s0)
    80011d78:	0807f793          	andi	a5,a5,128
    80011d7c:	2781                	sext.w	a5,a5
                                ? (unsigned short int)va_arg(va, unsigned int)
                                : va_arg(va, unsigned int);
    80011d7e:	cf81                	beqz	a5,80011d96 <_vsnprintf+0x73e>
                                ? (unsigned short int)va_arg(va, unsigned int)
    80011d80:	f7843783          	ld	a5,-136(s0)
    80011d84:	00878713          	addi	a4,a5,8
    80011d88:	f6e43c23          	sd	a4,-136(s0)
    80011d8c:	439c                	lw	a5,0(a5)
    80011d8e:	17c2                	slli	a5,a5,0x30
    80011d90:	93c1                	srli	a5,a5,0x30
                                : va_arg(va, unsigned int);
    80011d92:	2781                	sext.w	a5,a5
    80011d94:	a801                	j	80011da4 <_vsnprintf+0x74c>
    80011d96:	f7843783          	ld	a5,-136(s0)
    80011d9a:	00878713          	addi	a4,a5,8
    80011d9e:	f6e43c23          	sd	a4,-136(s0)
    80011da2:	439c                	lw	a5,0(a5)
                            : (flags & FLAGS_SHORT)
    80011da4:	2781                	sext.w	a5,a5
                        const unsigned int value =
    80011da6:	faf42a23          	sw	a5,-76(s0)
                        idx = _ntoa_long(out, buffer, idx, maxlen, value, false,
    80011daa:	fb446703          	lwu	a4,-76(s0)
    80011dae:	fd446683          	lwu	a3,-44(s0)
    80011db2:	fe442603          	lw	a2,-28(s0)
    80011db6:	fec42783          	lw	a5,-20(s0)
    80011dba:	e43e                	sd	a5,8(sp)
    80011dbc:	fe842783          	lw	a5,-24(s0)
    80011dc0:	e03e                	sd	a5,0(sp)
    80011dc2:	88b2                	mv	a7,a2
    80011dc4:	8836                	mv	a6,a3
    80011dc6:	4781                	li	a5,0
    80011dc8:	f8843683          	ld	a3,-120(s0)
    80011dcc:	fd843603          	ld	a2,-40(s0)
    80011dd0:	f9043583          	ld	a1,-112(s0)
    80011dd4:	f9843503          	ld	a0,-104(s0)
    80011dd8:	c43fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011ddc:	fca43c23          	sd	a0,-40(s0)
                                         base, precision, width, flags);
                    }
                }
                format++;
    80011de0:	f8043783          	ld	a5,-128(s0)
    80011de4:	0785                	addi	a5,a5,1
    80011de6:	f8f43023          	sd	a5,-128(s0)
                break;
    80011dea:	a919                	j	80012200 <_vsnprintf+0xba8>
            }
#if defined(PRINTF_SUPPORT_FLOAT)
            case 'f':
            case 'F':
                if (*format == 'F')
    80011dec:	f8043783          	ld	a5,-128(s0)
    80011df0:	0007c783          	lbu	a5,0(a5)
    80011df4:	873e                	mv	a4,a5
    80011df6:	04600793          	li	a5,70
    80011dfa:	00f71863          	bne	a4,a5,80011e0a <_vsnprintf+0x7b2>
                    flags |= FLAGS_UPPERCASE;
    80011dfe:	fec42783          	lw	a5,-20(s0)
    80011e02:	0207e793          	ori	a5,a5,32
    80011e06:	fef42623          	sw	a5,-20(s0)
                idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011e0a:	f7843783          	ld	a5,-136(s0)
    80011e0e:	00878713          	addi	a4,a5,8
    80011e12:	f6e43c23          	sd	a4,-136(s0)
    80011e16:	239c                	fld	fa5,0(a5)
    80011e18:	fec42683          	lw	a3,-20(s0)
    80011e1c:	fe842783          	lw	a5,-24(s0)
    80011e20:	fe442703          	lw	a4,-28(s0)
    80011e24:	8836                	mv	a6,a3
    80011e26:	22f78553          	fmv.d	fa0,fa5
    80011e2a:	f8843683          	ld	a3,-120(s0)
    80011e2e:	fd843603          	ld	a2,-40(s0)
    80011e32:	f9043583          	ld	a1,-112(s0)
    80011e36:	f9843503          	ld	a0,-104(s0)
    80011e3a:	e11fe0ef          	jal	ra,80010c4a <_ftoa>
    80011e3e:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011e42:	f8043783          	ld	a5,-128(s0)
    80011e46:	0785                	addi	a5,a5,1
    80011e48:	f8f43023          	sd	a5,-128(s0)
                break;
    80011e4c:	ae55                	j	80012200 <_vsnprintf+0xba8>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
            case 'e':
            case 'E':
            case 'g':
            case 'G':
                if ((*format == 'g') || (*format == 'G'))
    80011e4e:	f8043783          	ld	a5,-128(s0)
    80011e52:	0007c783          	lbu	a5,0(a5)
    80011e56:	873e                	mv	a4,a5
    80011e58:	06700793          	li	a5,103
    80011e5c:	00f70b63          	beq	a4,a5,80011e72 <_vsnprintf+0x81a>
    80011e60:	f8043783          	ld	a5,-128(s0)
    80011e64:	0007c783          	lbu	a5,0(a5)
    80011e68:	873e                	mv	a4,a5
    80011e6a:	04700793          	li	a5,71
    80011e6e:	00f71a63          	bne	a4,a5,80011e82 <_vsnprintf+0x82a>
                    flags |= FLAGS_ADAPT_EXP;
    80011e72:	fec42703          	lw	a4,-20(s0)
    80011e76:	6785                	lui	a5,0x1
    80011e78:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80011e7c:	8fd9                	or	a5,a5,a4
    80011e7e:	fef42623          	sw	a5,-20(s0)
                if ((*format == 'E') || (*format == 'G'))
    80011e82:	f8043783          	ld	a5,-128(s0)
    80011e86:	0007c783          	lbu	a5,0(a5)
    80011e8a:	873e                	mv	a4,a5
    80011e8c:	04500793          	li	a5,69
    80011e90:	00f70b63          	beq	a4,a5,80011ea6 <_vsnprintf+0x84e>
    80011e94:	f8043783          	ld	a5,-128(s0)
    80011e98:	0007c783          	lbu	a5,0(a5)
    80011e9c:	873e                	mv	a4,a5
    80011e9e:	04700793          	li	a5,71
    80011ea2:	00f71863          	bne	a4,a5,80011eb2 <_vsnprintf+0x85a>
                    flags |= FLAGS_UPPERCASE;
    80011ea6:	fec42783          	lw	a5,-20(s0)
    80011eaa:	0207e793          	ori	a5,a5,32
    80011eae:	fef42623          	sw	a5,-20(s0)
                idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011eb2:	f7843783          	ld	a5,-136(s0)
    80011eb6:	00878713          	addi	a4,a5,8
    80011eba:	f6e43c23          	sd	a4,-136(s0)
    80011ebe:	239c                	fld	fa5,0(a5)
    80011ec0:	fec42683          	lw	a3,-20(s0)
    80011ec4:	fe842783          	lw	a5,-24(s0)
    80011ec8:	fe442703          	lw	a4,-28(s0)
    80011ecc:	8836                	mv	a6,a3
    80011ece:	22f78553          	fmv.d	fa0,fa5
    80011ed2:	f8843683          	ld	a3,-120(s0)
    80011ed6:	fd843603          	ld	a2,-40(s0)
    80011eda:	f9043583          	ld	a1,-112(s0)
    80011ede:	f9843503          	ld	a0,-104(s0)
    80011ee2:	ab4ff0ef          	jal	ra,80011196 <_etoa>
    80011ee6:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011eea:	f8043783          	ld	a5,-128(s0)
    80011eee:	0785                	addi	a5,a5,1
    80011ef0:	f8f43023          	sd	a5,-128(s0)
                break;
    80011ef4:	a631                	j	80012200 <_vsnprintf+0xba8>
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
            case 'c': {
                unsigned int l = 1U;
    80011ef6:	4785                	li	a5,1
    80011ef8:	fcf42823          	sw	a5,-48(s0)
                // pre padding
                if (!(flags & FLAGS_LEFT)) {
    80011efc:	fec42783          	lw	a5,-20(s0)
    80011f00:	8b89                	andi	a5,a5,2
    80011f02:	2781                	sext.w	a5,a5
    80011f04:	ef8d                	bnez	a5,80011f3e <_vsnprintf+0x8e6>
                    while (l++ < width) {
    80011f06:	a00d                	j	80011f28 <_vsnprintf+0x8d0>
                        out(' ', buffer, idx++, maxlen);
    80011f08:	fd843783          	ld	a5,-40(s0)
    80011f0c:	00178713          	addi	a4,a5,1
    80011f10:	fce43c23          	sd	a4,-40(s0)
    80011f14:	f9843703          	ld	a4,-104(s0)
    80011f18:	f8843683          	ld	a3,-120(s0)
    80011f1c:	863e                	mv	a2,a5
    80011f1e:	f9043583          	ld	a1,-112(s0)
    80011f22:	02000513          	li	a0,32
    80011f26:	9702                	jalr	a4
                    while (l++ < width) {
    80011f28:	fd042783          	lw	a5,-48(s0)
    80011f2c:	0017871b          	addiw	a4,a5,1
    80011f30:	fce42823          	sw	a4,-48(s0)
    80011f34:	fe842703          	lw	a4,-24(s0)
    80011f38:	2701                	sext.w	a4,a4
    80011f3a:	fce7e7e3          	bltu	a5,a4,80011f08 <_vsnprintf+0x8b0>
                    }
                }
                // char output
                out((char)va_arg(va, int), buffer, idx++, maxlen);
    80011f3e:	f7843783          	ld	a5,-136(s0)
    80011f42:	00878713          	addi	a4,a5,8
    80011f46:	f6e43c23          	sd	a4,-136(s0)
    80011f4a:	439c                	lw	a5,0(a5)
    80011f4c:	0ff7f513          	andi	a0,a5,255
    80011f50:	fd843783          	ld	a5,-40(s0)
    80011f54:	00178713          	addi	a4,a5,1
    80011f58:	fce43c23          	sd	a4,-40(s0)
    80011f5c:	f9843703          	ld	a4,-104(s0)
    80011f60:	f8843683          	ld	a3,-120(s0)
    80011f64:	863e                	mv	a2,a5
    80011f66:	f9043583          	ld	a1,-112(s0)
    80011f6a:	9702                	jalr	a4
                // post padding
                if (flags & FLAGS_LEFT) {
    80011f6c:	fec42783          	lw	a5,-20(s0)
    80011f70:	8b89                	andi	a5,a5,2
    80011f72:	2781                	sext.w	a5,a5
    80011f74:	cf8d                	beqz	a5,80011fae <_vsnprintf+0x956>
                    while (l++ < width) {
    80011f76:	a00d                	j	80011f98 <_vsnprintf+0x940>
                        out(' ', buffer, idx++, maxlen);
    80011f78:	fd843783          	ld	a5,-40(s0)
    80011f7c:	00178713          	addi	a4,a5,1
    80011f80:	fce43c23          	sd	a4,-40(s0)
    80011f84:	f9843703          	ld	a4,-104(s0)
    80011f88:	f8843683          	ld	a3,-120(s0)
    80011f8c:	863e                	mv	a2,a5
    80011f8e:	f9043583          	ld	a1,-112(s0)
    80011f92:	02000513          	li	a0,32
    80011f96:	9702                	jalr	a4
                    while (l++ < width) {
    80011f98:	fd042783          	lw	a5,-48(s0)
    80011f9c:	0017871b          	addiw	a4,a5,1
    80011fa0:	fce42823          	sw	a4,-48(s0)
    80011fa4:	fe842703          	lw	a4,-24(s0)
    80011fa8:	2701                	sext.w	a4,a4
    80011faa:	fce7e7e3          	bltu	a5,a4,80011f78 <_vsnprintf+0x920>
                    }
                }
                format++;
    80011fae:	f8043783          	ld	a5,-128(s0)
    80011fb2:	0785                	addi	a5,a5,1
    80011fb4:	f8f43023          	sd	a5,-128(s0)
                break;
    80011fb8:	a4a1                	j	80012200 <_vsnprintf+0xba8>
            }

            case 's': {
                const char *p = va_arg(va, char *);
    80011fba:	f7843783          	ld	a5,-136(s0)
    80011fbe:	00878713          	addi	a4,a5,8
    80011fc2:	f6e43c23          	sd	a4,-136(s0)
    80011fc6:	639c                	ld	a5,0(a5)
    80011fc8:	fcf43423          	sd	a5,-56(s0)
                unsigned int l =
                    _strnlen_s(p, precision ? precision : (size_t)-1);
    80011fcc:	fe442783          	lw	a5,-28(s0)
    80011fd0:	2781                	sext.w	a5,a5
    80011fd2:	c781                	beqz	a5,80011fda <_vsnprintf+0x982>
    80011fd4:	fe446783          	lwu	a5,-28(s0)
    80011fd8:	a011                	j	80011fdc <_vsnprintf+0x984>
    80011fda:	57fd                	li	a5,-1
    80011fdc:	85be                	mv	a1,a5
    80011fde:	fc843503          	ld	a0,-56(s0)
    80011fe2:	d92fe0ef          	jal	ra,80010574 <_strnlen_s>
    80011fe6:	87aa                	mv	a5,a0
    80011fe8:	fcf42223          	sw	a5,-60(s0)
                // pre padding
                if (flags & FLAGS_PRECISION) {
    80011fec:	fec42783          	lw	a5,-20(s0)
    80011ff0:	4007f793          	andi	a5,a5,1024
    80011ff4:	2781                	sext.w	a5,a5
    80011ff6:	cf91                	beqz	a5,80012012 <_vsnprintf+0x9ba>
                    l = (l < precision ? l : precision);
    80011ff8:	fc442603          	lw	a2,-60(s0)
    80011ffc:	fe442783          	lw	a5,-28(s0)
    80012000:	0007869b          	sext.w	a3,a5
    80012004:	0006071b          	sext.w	a4,a2
    80012008:	00d77363          	bgeu	a4,a3,8001200e <_vsnprintf+0x9b6>
    8001200c:	87b2                	mv	a5,a2
    8001200e:	fcf42223          	sw	a5,-60(s0)
                }
                if (!(flags & FLAGS_LEFT)) {
    80012012:	fec42783          	lw	a5,-20(s0)
    80012016:	8b89                	andi	a5,a5,2
    80012018:	2781                	sext.w	a5,a5
    8001201a:	e7a5                	bnez	a5,80012082 <_vsnprintf+0xa2a>
                    while (l++ < width) {
    8001201c:	a00d                	j	8001203e <_vsnprintf+0x9e6>
                        out(' ', buffer, idx++, maxlen);
    8001201e:	fd843783          	ld	a5,-40(s0)
    80012022:	00178713          	addi	a4,a5,1
    80012026:	fce43c23          	sd	a4,-40(s0)
    8001202a:	f9843703          	ld	a4,-104(s0)
    8001202e:	f8843683          	ld	a3,-120(s0)
    80012032:	863e                	mv	a2,a5
    80012034:	f9043583          	ld	a1,-112(s0)
    80012038:	02000513          	li	a0,32
    8001203c:	9702                	jalr	a4
                    while (l++ < width) {
    8001203e:	fc442783          	lw	a5,-60(s0)
    80012042:	0017871b          	addiw	a4,a5,1
    80012046:	fce42223          	sw	a4,-60(s0)
    8001204a:	fe842703          	lw	a4,-24(s0)
    8001204e:	2701                	sext.w	a4,a4
    80012050:	fce7e7e3          	bltu	a5,a4,8001201e <_vsnprintf+0x9c6>
                    }
                }
                // string output
                while ((*p != 0) &&
    80012054:	a03d                	j	80012082 <_vsnprintf+0xa2a>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
                    out(*(p++), buffer, idx++, maxlen);
    80012056:	fc843783          	ld	a5,-56(s0)
    8001205a:	00178713          	addi	a4,a5,1
    8001205e:	fce43423          	sd	a4,-56(s0)
    80012062:	0007c503          	lbu	a0,0(a5)
    80012066:	fd843783          	ld	a5,-40(s0)
    8001206a:	00178713          	addi	a4,a5,1
    8001206e:	fce43c23          	sd	a4,-40(s0)
    80012072:	f9843703          	ld	a4,-104(s0)
    80012076:	f8843683          	ld	a3,-120(s0)
    8001207a:	863e                	mv	a2,a5
    8001207c:	f9043583          	ld	a1,-112(s0)
    80012080:	9702                	jalr	a4
                while ((*p != 0) &&
    80012082:	fc843783          	ld	a5,-56(s0)
    80012086:	0007c783          	lbu	a5,0(a5)
    8001208a:	cf91                	beqz	a5,800120a6 <_vsnprintf+0xa4e>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    8001208c:	fec42783          	lw	a5,-20(s0)
    80012090:	4007f793          	andi	a5,a5,1024
    80012094:	2781                	sext.w	a5,a5
                while ((*p != 0) &&
    80012096:	d3e1                	beqz	a5,80012056 <_vsnprintf+0x9fe>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    80012098:	fe442783          	lw	a5,-28(s0)
    8001209c:	fff7871b          	addiw	a4,a5,-1
    800120a0:	fee42223          	sw	a4,-28(s0)
    800120a4:	fbcd                	bnez	a5,80012056 <_vsnprintf+0x9fe>
                }
                // post padding
                if (flags & FLAGS_LEFT) {
    800120a6:	fec42783          	lw	a5,-20(s0)
    800120aa:	8b89                	andi	a5,a5,2
    800120ac:	2781                	sext.w	a5,a5
    800120ae:	cf8d                	beqz	a5,800120e8 <_vsnprintf+0xa90>
                    while (l++ < width) {
    800120b0:	a00d                	j	800120d2 <_vsnprintf+0xa7a>
                        out(' ', buffer, idx++, maxlen);
    800120b2:	fd843783          	ld	a5,-40(s0)
    800120b6:	00178713          	addi	a4,a5,1
    800120ba:	fce43c23          	sd	a4,-40(s0)
    800120be:	f9843703          	ld	a4,-104(s0)
    800120c2:	f8843683          	ld	a3,-120(s0)
    800120c6:	863e                	mv	a2,a5
    800120c8:	f9043583          	ld	a1,-112(s0)
    800120cc:	02000513          	li	a0,32
    800120d0:	9702                	jalr	a4
                    while (l++ < width) {
    800120d2:	fc442783          	lw	a5,-60(s0)
    800120d6:	0017871b          	addiw	a4,a5,1
    800120da:	fce42223          	sw	a4,-60(s0)
    800120de:	fe842703          	lw	a4,-24(s0)
    800120e2:	2701                	sext.w	a4,a4
    800120e4:	fce7e7e3          	bltu	a5,a4,800120b2 <_vsnprintf+0xa5a>
                    }
                }
                format++;
    800120e8:	f8043783          	ld	a5,-128(s0)
    800120ec:	0785                	addi	a5,a5,1
    800120ee:	f8f43023          	sd	a5,-128(s0)
                break;
    800120f2:	a239                	j	80012200 <_vsnprintf+0xba8>
            }

            case 'p': {
                width = sizeof(void *) * 2U;
    800120f4:	47c1                	li	a5,16
    800120f6:	fef42423          	sw	a5,-24(s0)
                flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    800120fa:	fec42783          	lw	a5,-20(s0)
    800120fe:	0217e793          	ori	a5,a5,33
    80012102:	fef42623          	sw	a5,-20(s0)
#if defined(PRINTF_SUPPORT_LONG_LONG)
                const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
    80012106:	4785                	li	a5,1
    80012108:	faf40da3          	sb	a5,-69(s0)
                if (is_ll) {
    8001210c:	fbb44783          	lbu	a5,-69(s0)
    80012110:	0ff7f793          	andi	a5,a5,255
    80012114:	c3b1                	beqz	a5,80012158 <_vsnprintf+0xb00>
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
                                          (uintptr_t)va_arg(va, void *), false,
    80012116:	f7843783          	ld	a5,-136(s0)
    8001211a:	00878713          	addi	a4,a5,8
    8001211e:	f6e43c23          	sd	a4,-136(s0)
    80012122:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80012124:	86be                	mv	a3,a5
    80012126:	fe442703          	lw	a4,-28(s0)
    8001212a:	fec42783          	lw	a5,-20(s0)
    8001212e:	e43e                	sd	a5,8(sp)
    80012130:	fe842783          	lw	a5,-24(s0)
    80012134:	e03e                	sd	a5,0(sp)
    80012136:	88ba                	mv	a7,a4
    80012138:	4841                	li	a6,16
    8001213a:	4781                	li	a5,0
    8001213c:	8736                	mv	a4,a3
    8001213e:	f8843683          	ld	a3,-120(s0)
    80012142:	fd843603          	ld	a2,-40(s0)
    80012146:	f9043583          	ld	a1,-112(s0)
    8001214a:	f9843503          	ld	a0,-104(s0)
    8001214e:	9e5fe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80012152:	fca43c23          	sd	a0,-40(s0)
    80012156:	a089                	j	80012198 <_vsnprintf+0xb40>
                }
                else {
#endif
                    idx = _ntoa_long(
                        out, buffer, idx, maxlen,
                        (unsigned long)((uintptr_t)va_arg(va, void *)), false,
    80012158:	f7843783          	ld	a5,-136(s0)
    8001215c:	00878713          	addi	a4,a5,8
    80012160:	f6e43c23          	sd	a4,-136(s0)
    80012164:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long(
    80012166:	86be                	mv	a3,a5
    80012168:	fe442703          	lw	a4,-28(s0)
    8001216c:	fec42783          	lw	a5,-20(s0)
    80012170:	e43e                	sd	a5,8(sp)
    80012172:	fe842783          	lw	a5,-24(s0)
    80012176:	e03e                	sd	a5,0(sp)
    80012178:	88ba                	mv	a7,a4
    8001217a:	4841                	li	a6,16
    8001217c:	4781                	li	a5,0
    8001217e:	8736                	mv	a4,a3
    80012180:	f8843683          	ld	a3,-120(s0)
    80012184:	fd843603          	ld	a2,-40(s0)
    80012188:	f9043583          	ld	a1,-112(s0)
    8001218c:	f9843503          	ld	a0,-104(s0)
    80012190:	88bfe0ef          	jal	ra,80010a1a <_ntoa_long>
    80012194:	fca43c23          	sd	a0,-40(s0)
                        16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
                }
#endif
                format++;
    80012198:	f8043783          	ld	a5,-128(s0)
    8001219c:	0785                	addi	a5,a5,1
    8001219e:	f8f43023          	sd	a5,-128(s0)
                break;
    800121a2:	a8b9                	j	80012200 <_vsnprintf+0xba8>
            }

            case '%':
                out('%', buffer, idx++, maxlen);
    800121a4:	fd843783          	ld	a5,-40(s0)
    800121a8:	00178713          	addi	a4,a5,1
    800121ac:	fce43c23          	sd	a4,-40(s0)
    800121b0:	f9843703          	ld	a4,-104(s0)
    800121b4:	f8843683          	ld	a3,-120(s0)
    800121b8:	863e                	mv	a2,a5
    800121ba:	f9043583          	ld	a1,-112(s0)
    800121be:	02500513          	li	a0,37
    800121c2:	9702                	jalr	a4
                format++;
    800121c4:	f8043783          	ld	a5,-128(s0)
    800121c8:	0785                	addi	a5,a5,1
    800121ca:	f8f43023          	sd	a5,-128(s0)
                break;
    800121ce:	a80d                	j	80012200 <_vsnprintf+0xba8>

            default:
                out(*format, buffer, idx++, maxlen);
    800121d0:	f8043783          	ld	a5,-128(s0)
    800121d4:	0007c503          	lbu	a0,0(a5)
    800121d8:	fd843783          	ld	a5,-40(s0)
    800121dc:	00178713          	addi	a4,a5,1
    800121e0:	fce43c23          	sd	a4,-40(s0)
    800121e4:	f9843703          	ld	a4,-104(s0)
    800121e8:	f8843683          	ld	a3,-120(s0)
    800121ec:	863e                	mv	a2,a5
    800121ee:	f9043583          	ld	a1,-112(s0)
    800121f2:	9702                	jalr	a4
                format++;
    800121f4:	f8043783          	ld	a5,-128(s0)
    800121f8:	0785                	addi	a5,a5,1
    800121fa:	f8f43023          	sd	a5,-128(s0)
                break;
    800121fe:	0001                	nop
    while (*format) {
    80012200:	f8043783          	ld	a5,-128(s0)
    80012204:	0007c783          	lbu	a5,0(a5)
    80012208:	c8079463          	bnez	a5,80011690 <_vsnprintf+0x38>
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    8001220c:	fd843703          	ld	a4,-40(s0)
    80012210:	f8843783          	ld	a5,-120(s0)
    80012214:	00f76663          	bltu	a4,a5,80012220 <_vsnprintf+0xbc8>
    80012218:	f8843783          	ld	a5,-120(s0)
    8001221c:	17fd                	addi	a5,a5,-1
    8001221e:	a019                	j	80012224 <_vsnprintf+0xbcc>
    80012220:	fd843783          	ld	a5,-40(s0)
    80012224:	f9843703          	ld	a4,-104(s0)
    80012228:	f8843683          	ld	a3,-120(s0)
    8001222c:	863e                	mv	a2,a5
    8001222e:	f9043583          	ld	a1,-112(s0)
    80012232:	4501                	li	a0,0
    80012234:	9702                	jalr	a4

    // return written chars without terminating \0
    return (int)idx;
    80012236:	fd843783          	ld	a5,-40(s0)
    8001223a:	2781                	sext.w	a5,a5
}
    8001223c:	853e                	mv	a0,a5
    8001223e:	60ea                	ld	ra,152(sp)
    80012240:	644a                	ld	s0,144(sp)
    80012242:	610d                	addi	sp,sp,160
    80012244:	8082                	ret

0000000080012246 <printf>:

///////////////////////////////////////////////////////////////////////////////

int printf(const char *format, ...)
{
    80012246:	7119                	addi	sp,sp,-128
    80012248:	fc06                	sd	ra,56(sp)
    8001224a:	f822                	sd	s0,48(sp)
    8001224c:	0080                	addi	s0,sp,64
    8001224e:	fca43423          	sd	a0,-56(s0)
    80012252:	e40c                	sd	a1,8(s0)
    80012254:	e810                	sd	a2,16(s0)
    80012256:	ec14                	sd	a3,24(s0)
    80012258:	f018                	sd	a4,32(s0)
    8001225a:	f41c                	sd	a5,40(s0)
    8001225c:	03043823          	sd	a6,48(s0)
    80012260:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, format);
    80012264:	04040793          	addi	a5,s0,64
    80012268:	fcf43023          	sd	a5,-64(s0)
    8001226c:	fc043783          	ld	a5,-64(s0)
    80012270:	fc878793          	addi	a5,a5,-56
    80012274:	fef43023          	sd	a5,-32(s0)
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80012278:	fe043703          	ld	a4,-32(s0)
    8001227c:	fd840793          	addi	a5,s0,-40
    80012280:	fc843683          	ld	a3,-56(s0)
    80012284:	567d                	li	a2,-1
    80012286:	85be                	mv	a1,a5
    80012288:	ffffe517          	auipc	a0,0xffffe
    8001228c:	27050513          	addi	a0,a0,624 # 800104f8 <_out_char>
    80012290:	bc8ff0ef          	jal	ra,80011658 <_vsnprintf>
    80012294:	87aa                	mv	a5,a0
    80012296:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    8001229a:	fec42783          	lw	a5,-20(s0)
}
    8001229e:	853e                	mv	a0,a5
    800122a0:	70e2                	ld	ra,56(sp)
    800122a2:	7442                	ld	s0,48(sp)
    800122a4:	6109                	addi	sp,sp,128
    800122a6:	8082                	ret

00000000800122a8 <sprintf>:

int sprintf(char *buffer, const char *format, ...)
{
    800122a8:	7159                	addi	sp,sp,-112
    800122aa:	fc06                	sd	ra,56(sp)
    800122ac:	f822                	sd	s0,48(sp)
    800122ae:	0080                	addi	s0,sp,64
    800122b0:	fca43c23          	sd	a0,-40(s0)
    800122b4:	fcb43823          	sd	a1,-48(s0)
    800122b8:	e010                	sd	a2,0(s0)
    800122ba:	e414                	sd	a3,8(s0)
    800122bc:	e818                	sd	a4,16(s0)
    800122be:	ec1c                	sd	a5,24(s0)
    800122c0:	03043023          	sd	a6,32(s0)
    800122c4:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    800122c8:	03040793          	addi	a5,s0,48
    800122cc:	fcf43423          	sd	a5,-56(s0)
    800122d0:	fc843783          	ld	a5,-56(s0)
    800122d4:	fd078793          	addi	a5,a5,-48
    800122d8:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
    800122dc:	fe043783          	ld	a5,-32(s0)
    800122e0:	873e                	mv	a4,a5
    800122e2:	fd043683          	ld	a3,-48(s0)
    800122e6:	567d                	li	a2,-1
    800122e8:	fd843583          	ld	a1,-40(s0)
    800122ec:	ffffe517          	auipc	a0,0xffffe
    800122f0:	1ae50513          	addi	a0,a0,430 # 8001049a <_out_buffer>
    800122f4:	b64ff0ef          	jal	ra,80011658 <_vsnprintf>
    800122f8:	87aa                	mv	a5,a0
    800122fa:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    800122fe:	fec42783          	lw	a5,-20(s0)
}
    80012302:	853e                	mv	a0,a5
    80012304:	70e2                	ld	ra,56(sp)
    80012306:	7442                	ld	s0,48(sp)
    80012308:	6165                	addi	sp,sp,112
    8001230a:	8082                	ret

000000008001230c <snprintf>:

int snprintf(char *buffer, size_t count, const char *format, ...)
{
    8001230c:	7159                	addi	sp,sp,-112
    8001230e:	fc06                	sd	ra,56(sp)
    80012310:	f822                	sd	s0,48(sp)
    80012312:	0080                	addi	s0,sp,64
    80012314:	fca43c23          	sd	a0,-40(s0)
    80012318:	fcb43823          	sd	a1,-48(s0)
    8001231c:	fcc43423          	sd	a2,-56(s0)
    80012320:	e414                	sd	a3,8(s0)
    80012322:	e818                	sd	a4,16(s0)
    80012324:	ec1c                	sd	a5,24(s0)
    80012326:	03043023          	sd	a6,32(s0)
    8001232a:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    8001232e:	03040793          	addi	a5,s0,48
    80012332:	fcf43023          	sd	a5,-64(s0)
    80012336:	fc043783          	ld	a5,-64(s0)
    8001233a:	fd878793          	addi	a5,a5,-40
    8001233e:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    80012342:	fe043783          	ld	a5,-32(s0)
    80012346:	873e                	mv	a4,a5
    80012348:	fc843683          	ld	a3,-56(s0)
    8001234c:	fd043603          	ld	a2,-48(s0)
    80012350:	fd843583          	ld	a1,-40(s0)
    80012354:	ffffe517          	auipc	a0,0xffffe
    80012358:	14650513          	addi	a0,a0,326 # 8001049a <_out_buffer>
    8001235c:	afcff0ef          	jal	ra,80011658 <_vsnprintf>
    80012360:	87aa                	mv	a5,a0
    80012362:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80012366:	fec42783          	lw	a5,-20(s0)
}
    8001236a:	853e                	mv	a0,a5
    8001236c:	70e2                	ld	ra,56(sp)
    8001236e:	7442                	ld	s0,48(sp)
    80012370:	6165                	addi	sp,sp,112
    80012372:	8082                	ret

0000000080012374 <vprintf_>:

int vprintf_(const char *format, va_list va)
{
    80012374:	7179                	addi	sp,sp,-48
    80012376:	f406                	sd	ra,40(sp)
    80012378:	f022                	sd	s0,32(sp)
    8001237a:	1800                	addi	s0,sp,48
    8001237c:	fca43c23          	sd	a0,-40(s0)
    80012380:	fcb43823          	sd	a1,-48(s0)
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80012384:	fe840793          	addi	a5,s0,-24
    80012388:	fd043703          	ld	a4,-48(s0)
    8001238c:	fd843683          	ld	a3,-40(s0)
    80012390:	567d                	li	a2,-1
    80012392:	85be                	mv	a1,a5
    80012394:	ffffe517          	auipc	a0,0xffffe
    80012398:	16450513          	addi	a0,a0,356 # 800104f8 <_out_char>
    8001239c:	abcff0ef          	jal	ra,80011658 <_vsnprintf>
    800123a0:	87aa                	mv	a5,a0
}
    800123a2:	853e                	mv	a0,a5
    800123a4:	70a2                	ld	ra,40(sp)
    800123a6:	7402                	ld	s0,32(sp)
    800123a8:	6145                	addi	sp,sp,48
    800123aa:	8082                	ret

00000000800123ac <vsnprintf_>:

int vsnprintf_(char *buffer, size_t count, const char *format, va_list va)
{
    800123ac:	7179                	addi	sp,sp,-48
    800123ae:	f406                	sd	ra,40(sp)
    800123b0:	f022                	sd	s0,32(sp)
    800123b2:	1800                	addi	s0,sp,48
    800123b4:	fea43423          	sd	a0,-24(s0)
    800123b8:	feb43023          	sd	a1,-32(s0)
    800123bc:	fcc43c23          	sd	a2,-40(s0)
    800123c0:	fcd43823          	sd	a3,-48(s0)
    return _vsnprintf(_out_buffer, buffer, count, format, va);
    800123c4:	fd043703          	ld	a4,-48(s0)
    800123c8:	fd843683          	ld	a3,-40(s0)
    800123cc:	fe043603          	ld	a2,-32(s0)
    800123d0:	fe843583          	ld	a1,-24(s0)
    800123d4:	ffffe517          	auipc	a0,0xffffe
    800123d8:	0c650513          	addi	a0,a0,198 # 8001049a <_out_buffer>
    800123dc:	a7cff0ef          	jal	ra,80011658 <_vsnprintf>
    800123e0:	87aa                	mv	a5,a0
}
    800123e2:	853e                	mv	a0,a5
    800123e4:	70a2                	ld	ra,40(sp)
    800123e6:	7402                	ld	s0,32(sp)
    800123e8:	6145                	addi	sp,sp,48
    800123ea:	8082                	ret

00000000800123ec <fctprintf>:

int fctprintf(void (*out)(char character, void *arg), void *arg,
              const char *format, ...)
{
    800123ec:	7119                	addi	sp,sp,-128
    800123ee:	e486                	sd	ra,72(sp)
    800123f0:	e0a2                	sd	s0,64(sp)
    800123f2:	0880                	addi	s0,sp,80
    800123f4:	fca43423          	sd	a0,-56(s0)
    800123f8:	fcb43023          	sd	a1,-64(s0)
    800123fc:	fac43c23          	sd	a2,-72(s0)
    80012400:	e414                	sd	a3,8(s0)
    80012402:	e818                	sd	a4,16(s0)
    80012404:	ec1c                	sd	a5,24(s0)
    80012406:	03043023          	sd	a6,32(s0)
    8001240a:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    8001240e:	03040793          	addi	a5,s0,48
    80012412:	faf43823          	sd	a5,-80(s0)
    80012416:	fb043783          	ld	a5,-80(s0)
    8001241a:	fd878793          	addi	a5,a5,-40
    8001241e:	fef43023          	sd	a5,-32(s0)
    const out_fct_wrap_type out_fct_wrap = {out, arg};
    80012422:	fc843783          	ld	a5,-56(s0)
    80012426:	fcf43823          	sd	a5,-48(s0)
    8001242a:	fc043783          	ld	a5,-64(s0)
    8001242e:	fcf43c23          	sd	a5,-40(s0)
    const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap,
    80012432:	fe043703          	ld	a4,-32(s0)
    80012436:	fd040793          	addi	a5,s0,-48
    8001243a:	fb843683          	ld	a3,-72(s0)
    8001243e:	567d                	li	a2,-1
    80012440:	85be                	mv	a1,a5
    80012442:	ffffe517          	auipc	a0,0xffffe
    80012446:	0ee50513          	addi	a0,a0,238 # 80010530 <_out_fct>
    8001244a:	a0eff0ef          	jal	ra,80011658 <_vsnprintf>
    8001244e:	87aa                	mv	a5,a0
    80012450:	fef42623          	sw	a5,-20(s0)
                               (size_t)-1, format, va);
    va_end(va);
    return ret;
    80012454:	fec42783          	lw	a5,-20(s0)
}
    80012458:	853e                	mv	a0,a5
    8001245a:	60a6                	ld	ra,72(sp)
    8001245c:	6406                	ld	s0,64(sp)
    8001245e:	6109                	addi	sp,sp,128
    80012460:	8082                	ret

0000000080012462 <os_trap_handler>:
// From src/syscall.c
void syscall_handle(int hart, uint64_t epc, int64_t *scratch);

// Called from asm/spawn.S: _spawn_kthread
void os_trap_handler(void)
{
    80012462:	7139                	addi	sp,sp,-64
    80012464:	fc06                	sd	ra,56(sp)
    80012466:	f822                	sd	s0,48(sp)
    80012468:	0080                	addi	s0,sp,64
    debugf("Testing\n");
    8001246a:	00009517          	auipc	a0,0x9
    8001246e:	eae50513          	addi	a0,a0,-338 # 8001b318 <pow10.0+0xe8>
    80012472:	1a8030ef          	jal	ra,8001561a <debugf>
    unsigned long cause;
    long *scratch;
    unsigned long epc;
    unsigned long tval;
    unsigned long sie;
    CSR_READ(cause, "scause");
    80012476:	142027f3          	csrr	a5,scause
    8001247a:	fef43423          	sd	a5,-24(s0)
    CSR_READ(scratch, "sscratch");
    8001247e:	140027f3          	csrr	a5,sscratch
    80012482:	fef43023          	sd	a5,-32(s0)
    CSR_READ(epc, "sepc");
    80012486:	141027f3          	csrr	a5,sepc
    8001248a:	fcf43c23          	sd	a5,-40(s0)
    CSR_READ(tval, "stval");
    8001248e:	143027f3          	csrr	a5,stval
    80012492:	fcf43823          	sd	a5,-48(s0)
    CSR_READ(sie, "sie");
    80012496:	104027f3          	csrr	a5,sie
    8001249a:	fcf43423          	sd	a5,-56(s0)
    // debugf("SPP: %lx\n", status & SSTATUS_SPP_BIT);

    // debugf("Scause: %lx\n", cause);
    // debugf("Sscratch: %lx\n", scratch);

    int hart = sbi_whoami();
    8001249e:	42a030ef          	jal	ra,800158c8 <sbi_whoami>
    800124a2:	87aa                	mv	a5,a0
    800124a4:	fcf42223          	sw	a5,-60(s0)
    // __asm__ volatile ("li t1,2\n"
    //                 "csrs sstatus, t1\n"
    //                 "csrs sie, t1\n");


    debugf("Is async: %d\n", SCAUSE_IS_ASYNC(cause));
    800124a8:	fe843783          	ld	a5,-24(s0)
    800124ac:	93fd                	srli	a5,a5,0x3f
    800124ae:	85be                	mv	a1,a5
    800124b0:	00009517          	auipc	a0,0x9
    800124b4:	e7850513          	addi	a0,a0,-392 # 8001b328 <pow10.0+0xf8>
    800124b8:	162030ef          	jal	ra,8001561a <debugf>

    if (SCAUSE_IS_ASYNC(cause)) {
    800124bc:	fe843783          	ld	a5,-24(s0)
    800124c0:	0807d163          	bgez	a5,80012542 <os_trap_handler+0xe0>
        debugf("Is async!\n");
    800124c4:	00009517          	auipc	a0,0x9
    800124c8:	e7450513          	addi	a0,a0,-396 # 8001b338 <pow10.0+0x108>
    800124cc:	14e030ef          	jal	ra,8001561a <debugf>
        cause = SCAUSE_NUM(cause);
    800124d0:	fe843783          	ld	a5,-24(s0)
    800124d4:	0ff7f793          	andi	a5,a5,255
    800124d8:	fef43423          	sd	a5,-24(s0)
        switch (cause) {
    800124dc:	fe843703          	ld	a4,-24(s0)
    800124e0:	4795                	li	a5,5
    800124e2:	00f70863          	beq	a4,a5,800124f2 <os_trap_handler+0x90>
    800124e6:	fe843703          	ld	a4,-24(s0)
    800124ea:	47a5                	li	a5,9
    800124ec:	00f70e63          	beq	a4,a5,80012508 <os_trap_handler+0xa6>
    800124f0:	a835                	j	8001252c <os_trap_handler+0xca>
            case CAUSE_STIP:
                // Ack timer will reset the timer to INFINITE
                // In src/sbi.c
                debugf("HANDLING TIMER!!!!!!!!!!!!!!!\n");
    800124f2:	00009517          	auipc	a0,0x9
    800124f6:	e5650513          	addi	a0,a0,-426 # 8001b348 <pow10.0+0x118>
    800124fa:	120030ef          	jal	ra,8001561a <debugf>
                CSR_CLEAR("sip");
    800124fe:	14401073          	csrw	sip,zero
                sbi_ack_timer();
    80012502:	390030ef          	jal	ra,80015892 <sbi_ack_timer>
                // We typically invoke our scheduler if we get a timer
                // sched_invoke(hart);
                break;
    80012506:	a225                	j	8001262e <os_trap_handler+0x1cc>
            case CAUSE_SEIP:
                // Forward to src/plic.c
                debugf("HANDLING IRQ!!!!!!!!!!!!!!!\n");
    80012508:	00009517          	auipc	a0,0x9
    8001250c:	e6050513          	addi	a0,a0,-416 # 8001b368 <pow10.0+0x138>
    80012510:	10a030ef          	jal	ra,8001561a <debugf>
                plic_handle_irq(hart);
    80012514:	fc442783          	lw	a5,-60(s0)
    80012518:	853e                	mv	a0,a5
    8001251a:	662030ef          	jal	ra,80015b7c <plic_handle_irq>
                debugf("Left plic handle\n");
    8001251e:	00009517          	auipc	a0,0x9
    80012522:	e6a50513          	addi	a0,a0,-406 # 8001b388 <pow10.0+0x158>
    80012526:	0f4030ef          	jal	ra,8001561a <debugf>
                
                // fatalf("Could not return from trap\n");
                break;
    8001252a:	a211                	j	8001262e <os_trap_handler+0x1cc>
            default:
                fatalf("Unhandled Asynchronous interrupt %ld\n", cause);
    8001252c:	fe843583          	ld	a1,-24(s0)
    80012530:	00009517          	auipc	a0,0x9
    80012534:	e7050513          	addi	a0,a0,-400 # 8001b3a0 <pow10.0+0x170>
    80012538:	138030ef          	jal	ra,80015670 <fatalf>
                WFI_LOOP();
    8001253c:	10500073          	wfi
    80012540:	bff5                	j	8001253c <os_trap_handler+0xda>
                break;
        }
    }
    else {
        debugf("Is sync!\n");
    80012542:	00009517          	auipc	a0,0x9
    80012546:	e8650513          	addi	a0,a0,-378 # 8001b3c8 <pow10.0+0x198>
    8001254a:	0d0030ef          	jal	ra,8001561a <debugf>
    8001254e:	fe843703          	ld	a4,-24(s0)
    80012552:	47b5                	li	a5,13
    80012554:	0ae7eb63          	bltu	a5,a4,8001260a <os_trap_handler+0x1a8>
    80012558:	fe843783          	ld	a5,-24(s0)
    8001255c:	00279713          	slli	a4,a5,0x2
    80012560:	00009797          	auipc	a5,0x9
    80012564:	f7c78793          	addi	a5,a5,-132 # 8001b4dc <pow10.0+0x2ac>
    80012568:	97ba                	add	a5,a5,a4
    8001256a:	439c                	lw	a5,0(a5)
    8001256c:	0007871b          	sext.w	a4,a5
    80012570:	00009797          	auipc	a5,0x9
    80012574:	f6c78793          	addi	a5,a5,-148 # 8001b4dc <pow10.0+0x2ac>
    80012578:	97ba                	add	a5,a5,a4
    8001257a:	8782                	jr	a5
        switch (cause) {
            case CAUSE_ILLEGAL_INSTRUCTION:
                fatalf("Illegal instruction \"%x\" at %p\n", *((uint64_t*)epc), epc);
    8001257c:	fd843783          	ld	a5,-40(s0)
    80012580:	639c                	ld	a5,0(a5)
    80012582:	fd843603          	ld	a2,-40(s0)
    80012586:	85be                	mv	a1,a5
    80012588:	00009517          	auipc	a0,0x9
    8001258c:	e5050513          	addi	a0,a0,-432 # 8001b3d8 <pow10.0+0x1a8>
    80012590:	0e0030ef          	jal	ra,80015670 <fatalf>
                CSR_WRITE("sepc", epc + 4);
    80012594:	fd843783          	ld	a5,-40(s0)
    80012598:	0791                	addi	a5,a5,4
    8001259a:	14179073          	csrw	sepc,a5
                break;
    8001259e:	a841                	j	8001262e <os_trap_handler+0x1cc>
            case CAUSE_INSTRUCTION_ACCESS_FAULT:
                fatalf("Couldn't access instruction=%p at instruction %p\n", tval, epc);
    800125a0:	fd843603          	ld	a2,-40(s0)
    800125a4:	fd043583          	ld	a1,-48(s0)
    800125a8:	00009517          	auipc	a0,0x9
    800125ac:	e5050513          	addi	a0,a0,-432 # 8001b3f8 <pow10.0+0x1c8>
    800125b0:	0c0030ef          	jal	ra,80015670 <fatalf>
                break;
    800125b4:	a8ad                	j	8001262e <os_trap_handler+0x1cc>
            case CAUSE_INSTRUCTION_PAGE_FAULT:
                fatalf("Instruction page fault at instruction %p accessing address %p\n", epc, tval);
    800125b6:	fd043603          	ld	a2,-48(s0)
    800125ba:	fd843583          	ld	a1,-40(s0)
    800125be:	00009517          	auipc	a0,0x9
    800125c2:	e7250513          	addi	a0,a0,-398 # 8001b430 <pow10.0+0x200>
    800125c6:	0aa030ef          	jal	ra,80015670 <fatalf>
                break;
    800125ca:	a095                	j	8001262e <os_trap_handler+0x1cc>
            case CAUSE_LOAD_PAGE_FAULT:
                fatalf("Load page fault at %p = %p", epc, tval);
    800125cc:	fd043603          	ld	a2,-48(s0)
    800125d0:	fd843583          	ld	a1,-40(s0)
    800125d4:	00009517          	auipc	a0,0x9
    800125d8:	e9c50513          	addi	a0,a0,-356 # 8001b470 <pow10.0+0x240>
    800125dc:	094030ef          	jal	ra,80015670 <fatalf>
                break;
    800125e0:	a0b9                	j	8001262e <os_trap_handler+0x1cc>
            case CAUSE_ECALL_U_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                syscall_handle(hart, epc, scratch);
    800125e2:	fc442783          	lw	a5,-60(s0)
    800125e6:	fe043603          	ld	a2,-32(s0)
    800125ea:	fd843583          	ld	a1,-40(s0)
    800125ee:	853e                	mv	a0,a5
    800125f0:	dfdfd0ef          	jal	ra,800103ec <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    800125f4:	a82d                	j	8001262e <os_trap_handler+0x1cc>
            case CAUSE_ECALL_S_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                syscall_handle(hart, epc, scratch);
    800125f6:	fc442783          	lw	a5,-60(s0)
    800125fa:	fe043603          	ld	a2,-32(s0)
    800125fe:	fd843583          	ld	a1,-40(s0)
    80012602:	853e                	mv	a0,a5
    80012604:	de9fd0ef          	jal	ra,800103ec <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    80012608:	a01d                	j	8001262e <os_trap_handler+0x1cc>
            default:
                debugf(
    8001260a:	fc442783          	lw	a5,-60(s0)
    8001260e:	873e                	mv	a4,a5
    80012610:	fd043683          	ld	a3,-48(s0)
    80012614:	fd843603          	ld	a2,-40(s0)
    80012618:	fe843583          	ld	a1,-24(s0)
    8001261c:	00009517          	auipc	a0,0x9
    80012620:	e7450513          	addi	a0,a0,-396 # 8001b490 <pow10.0+0x260>
    80012624:	7f7020ef          	jal	ra,8001561a <debugf>
                    "Unhandled Synchronous interrupt %ld @ 0x%08lx [0x%08lx]. "
                    "Hanging hart %d\n",
                    cause, epc, tval, hart);
                WFI_LOOP();
    80012628:	10500073          	wfi
    8001262c:	bff5                	j	80012628 <os_trap_handler+0x1c6>
    // __asm__ volatile ("savefp");
    // __asm__ volatile ("savegp");

    // SRET();
    // fatalf("Could not return from trap\n");
    8001262e:	0001                	nop
    80012630:	70e2                	ld	ra,56(sp)
    80012632:	7442                	ld	s0,48(sp)
    80012634:	6121                	addi	sp,sp,64
    80012636:	8082                	ret

0000000080012638 <rng_init>:

//use this like a queue
volatile static Vector *rng_active_jobs;
volatile static VirtioDevice *rng_device;

void rng_init() {
    80012638:	1141                	addi	sp,sp,-16
    8001263a:	e406                	sd	ra,8(sp)
    8001263c:	e022                	sd	s0,0(sp)
    8001263e:	0800                	addi	s0,sp,16
    rng_active_jobs = vector_new();
    80012640:	645050ef          	jal	ra,80018484 <vector_new>
    80012644:	872a                	mv	a4,a0
    80012646:	00008797          	auipc	a5,0x8
    8001264a:	9e278793          	addi	a5,a5,-1566 # 8001a028 <rng_active_jobs>
    8001264e:	e398                	sd	a4,0(a5)
    rng_device = virtio_get_rng_device();
    80012650:	72c030ef          	jal	ra,80015d7c <virtio_get_rng_device>
    80012654:	872a                	mv	a4,a0
    80012656:	00008797          	auipc	a5,0x8
    8001265a:	9da78793          	addi	a5,a5,-1574 # 8001a030 <rng_device>
    8001265e:	e398                	sd	a4,0(a5)
    debugf("RNG init done for device at %p\n", rng_device->pcidev->ecam_header);
    80012660:	00008797          	auipc	a5,0x8
    80012664:	9d078793          	addi	a5,a5,-1584 # 8001a030 <rng_device>
    80012668:	639c                	ld	a5,0(a5)
    8001266a:	639c                	ld	a5,0(a5)
    8001266c:	639c                	ld	a5,0(a5)
    8001266e:	85be                	mv	a1,a5
    80012670:	00009517          	auipc	a0,0x9
    80012674:	ea850513          	addi	a0,a0,-344 # 8001b518 <pow10.0+0x2e8>
    80012678:	7a3020ef          	jal	ra,8001561a <debugf>
    rng_device->ready = true;
    8001267c:	00008797          	auipc	a5,0x8
    80012680:	9b478793          	addi	a5,a5,-1612 # 8001a030 <rng_device>
    80012684:	639c                	ld	a5,0(a5)
    80012686:	4705                	li	a4,1
    80012688:	04e78723          	sb	a4,78(a5)
}
    8001268c:	0001                	nop
    8001268e:	60a2                	ld	ra,8(sp)
    80012690:	6402                	ld	s0,0(sp)
    80012692:	0141                	addi	sp,sp,16
    80012694:	8082                	ret

0000000080012696 <rng_fill>:


bool rng_fill(void *virtual_buffer_address, uint16_t size) {
    80012696:	7179                	addi	sp,sp,-48
    80012698:	f406                	sd	ra,40(sp)
    8001269a:	f022                	sd	s0,32(sp)
    8001269c:	1800                	addi	s0,sp,48
    8001269e:	fca43c23          	sd	a0,-40(s0)
    800126a2:	87ae                	mv	a5,a1
    800126a4:	fcf41b23          	sh	a5,-42(s0)
    if (!virtio_is_rng_device(rng_device)) {
    800126a8:	00008797          	auipc	a5,0x8
    800126ac:	98878793          	addi	a5,a5,-1656 # 8001a030 <rng_device>
    800126b0:	639c                	ld	a5,0(a5)
    800126b2:	853e                	mv	a0,a5
    800126b4:	5da030ef          	jal	ra,80015c8e <virtio_is_rng_device>
    800126b8:	87aa                	mv	a5,a0
    800126ba:	0017c793          	xori	a5,a5,1
    800126be:	0ff7f793          	andi	a5,a5,255
    800126c2:	c799                	beqz	a5,800126d0 <rng_fill+0x3a>
        fatalf("[RNG] Incorrect device provided\n");
    800126c4:	00009517          	auipc	a0,0x9
    800126c8:	e7450513          	addi	a0,a0,-396 # 8001b538 <pow10.0+0x308>
    800126cc:	7a5020ef          	jal	ra,80015670 <fatalf>
    }

    if (!rng_device->ready) {
    800126d0:	00008797          	auipc	a5,0x8
    800126d4:	96078793          	addi	a5,a5,-1696 # 8001a030 <rng_device>
    800126d8:	639c                	ld	a5,0(a5)
    800126da:	04e7c783          	lbu	a5,78(a5)
    800126de:	0ff7f793          	andi	a5,a5,255
    800126e2:	0017c793          	xori	a5,a5,1
    800126e6:	0ff7f793          	andi	a5,a5,255
    800126ea:	cb89                	beqz	a5,800126fc <rng_fill+0x66>
        fatalf("RNG is not ready\n");
    800126ec:	00009517          	auipc	a0,0x9
    800126f0:	e7450513          	addi	a0,a0,-396 # 8001b560 <pow10.0+0x330>
    800126f4:	77d020ef          	jal	ra,80015670 <fatalf>
        return false;
    800126f8:	4781                	li	a5,0
    800126fa:	a091                	j	8001273e <rng_fill+0xa8>
    }

    VirtioDescriptor desc;
    desc.addr = kernel_mmu_translate(virtual_buffer_address);
    800126fc:	fd843783          	ld	a5,-40(s0)
    80012700:	853e                	mv	a0,a5
    80012702:	6a8010ef          	jal	ra,80013daa <kernel_mmu_translate>
    80012706:	87aa                	mv	a5,a0
    80012708:	fef43023          	sd	a5,-32(s0)
    desc.len = size;
    8001270c:	fd645783          	lhu	a5,-42(s0)
    80012710:	2781                	sext.w	a5,a5
    80012712:	fef42423          	sw	a5,-24(s0)
    desc.flags = VIRTQ_DESC_F_WRITE;
    80012716:	4789                	li	a5,2
    80012718:	fef41623          	sh	a5,-20(s0)
    desc.next = 0;
    8001271c:	fe041723          	sh	zero,-18(s0)

    virtio_send_descriptor(rng_device, 0, desc, true);
    80012720:	00008797          	auipc	a5,0x8
    80012724:	91078793          	addi	a5,a5,-1776 # 8001a030 <rng_device>
    80012728:	639c                	ld	a5,0(a5)
    8001272a:	4705                	li	a4,1
    8001272c:	fe043603          	ld	a2,-32(s0)
    80012730:	fe843683          	ld	a3,-24(s0)
    80012734:	4581                	li	a1,0
    80012736:	853e                	mv	a0,a5
    80012738:	623030ef          	jal	ra,8001655a <virtio_send_descriptor>
    // // debugf("Notifying RNG...\n");
    
    // virtio_notify(rng_device, 0);
    // os_trap_handler
    // debugf("Done\n");
    return true;
    8001273c:	4785                	li	a5,1
    8001273e:	853e                	mv	a0,a5
    80012740:	70a2                	ld	ra,40(sp)
    80012742:	7402                	ld	s0,32(sp)
    80012744:	6145                	addi	sp,sp,48
    80012746:	8082                	ret

0000000080012748 <pci_device_exists>:
// `irq_pci_devices` vector contains devices that share an IRQ number (32, 33, 34, and 35).
// These vectors contain the pointers to the devices in the ECAM address space.
static struct Vector *all_pci_devices, *irq_pci_devices[4];

static inline bool pci_device_exists(uint16_t vendor_id)
{
    80012748:	1101                	addi	sp,sp,-32
    8001274a:	ec22                	sd	s0,24(sp)
    8001274c:	1000                	addi	s0,sp,32
    8001274e:	87aa                	mv	a5,a0
    80012750:	fef41723          	sh	a5,-18(s0)
    return !((vendor_id == 0x0000) || (vendor_id == 0xFFFF));
    80012754:	fee45783          	lhu	a5,-18(s0)
    80012758:	2781                	sext.w	a5,a5
    8001275a:	cb99                	beqz	a5,80012770 <pci_device_exists+0x28>
    8001275c:	fee45783          	lhu	a5,-18(s0)
    80012760:	0007871b          	sext.w	a4,a5
    80012764:	67c1                	lui	a5,0x10
    80012766:	17fd                	addi	a5,a5,-1
    80012768:	00f70463          	beq	a4,a5,80012770 <pci_device_exists+0x28>
    8001276c:	4785                	li	a5,1
    8001276e:	a011                	j	80012772 <pci_device_exists+0x2a>
    80012770:	4781                	li	a5,0
    80012772:	8b85                	andi	a5,a5,1
    80012774:	0ff7f793          	andi	a5,a5,255
}
    80012778:	853e                	mv	a0,a5
    8001277a:	6462                	ld	s0,24(sp)
    8001277c:	6105                	addi	sp,sp,32
    8001277e:	8082                	ret

0000000080012780 <pci_is_virtio_device>:

// Is this a virtio device?
bool pci_is_virtio_device(PCIDevice *dev) {
    80012780:	1101                	addi	sp,sp,-32
    80012782:	ec22                	sd	s0,24(sp)
    80012784:	1000                	addi	s0,sp,32
    80012786:	fea43423          	sd	a0,-24(s0)
    return dev->ecam_header->vendor_id == 0x1AF4;
    8001278a:	fe843783          	ld	a5,-24(s0)
    8001278e:	639c                	ld	a5,0(a5)
    80012790:	0007d783          	lhu	a5,0(a5) # 10000 <i+0xffe0>
    80012794:	17c2                	slli	a5,a5,0x30
    80012796:	93c1                	srli	a5,a5,0x30
    80012798:	0007871b          	sext.w	a4,a5
    8001279c:	6789                	lui	a5,0x2
    8001279e:	af478793          	addi	a5,a5,-1292 # 1af4 <i+0x1ad4>
    800127a2:	40f707b3          	sub	a5,a4,a5
    800127a6:	0017b793          	seqz	a5,a5
    800127aa:	0ff7f793          	andi	a5,a5,255
}
    800127ae:	853e                	mv	a0,a5
    800127b0:	6462                	ld	s0,24(sp)
    800127b2:	6105                	addi	sp,sp,32
    800127b4:	8082                	ret

00000000800127b6 <pci_find_saved_device>:

// Find the saved PCI device with the given vendor and device ID.
// This will retrieve the bookkeeping structure for the PCI device
// maintained by the OS.
PCIDevice *pci_find_saved_device(uint16_t vendor_id, uint16_t device_id) {
    800127b6:	7179                	addi	sp,sp,-48
    800127b8:	f406                	sd	ra,40(sp)
    800127ba:	f022                	sd	s0,32(sp)
    800127bc:	1800                	addi	s0,sp,48
    800127be:	87aa                	mv	a5,a0
    800127c0:	872e                	mv	a4,a1
    800127c2:	fcf41f23          	sh	a5,-34(s0)
    800127c6:	87ba                	mv	a5,a4
    800127c8:	fcf41e23          	sh	a5,-36(s0)
    // debugf("Searching for device with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    // Iterate through the devices
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    800127cc:	fe042623          	sw	zero,-20(s0)
    800127d0:	a8a1                	j	80012828 <pci_find_saved_device+0x72>
        // Check if the device has the given vendor and device ID
        PCIDevice *pcidev = pci_get_nth_saved_device(i);
    800127d2:	fec42783          	lw	a5,-20(s0)
    800127d6:	17c2                	slli	a5,a5,0x30
    800127d8:	93c1                	srli	a5,a5,0x30
    800127da:	853e                	mv	a0,a5
    800127dc:	3ea000ef          	jal	ra,80012bc6 <pci_get_nth_saved_device>
    800127e0:	fea43023          	sd	a0,-32(s0)
        // debugf("Checking device with vendor ID: 0x%04x, device ID: 0x%04x\n", pcidev->ecam_header->vendor_id, pcidev->ecam_header->device_id);
        if (pcidev->ecam_header->vendor_id == vendor_id && pcidev->ecam_header->device_id == device_id) {
    800127e4:	fe043783          	ld	a5,-32(s0)
    800127e8:	639c                	ld	a5,0(a5)
    800127ea:	0007d783          	lhu	a5,0(a5)
    800127ee:	17c2                	slli	a5,a5,0x30
    800127f0:	93c1                	srli	a5,a5,0x30
    800127f2:	fde45703          	lhu	a4,-34(s0)
    800127f6:	2701                	sext.w	a4,a4
    800127f8:	2781                	sext.w	a5,a5
    800127fa:	02f71263          	bne	a4,a5,8001281e <pci_find_saved_device+0x68>
    800127fe:	fe043783          	ld	a5,-32(s0)
    80012802:	639c                	ld	a5,0(a5)
    80012804:	0027d783          	lhu	a5,2(a5)
    80012808:	17c2                	slli	a5,a5,0x30
    8001280a:	93c1                	srli	a5,a5,0x30
    8001280c:	fdc45703          	lhu	a4,-36(s0)
    80012810:	2701                	sext.w	a4,a4
    80012812:	2781                	sext.w	a5,a5
    80012814:	00f71563          	bne	a4,a5,8001281e <pci_find_saved_device+0x68>
            return pcidev;
    80012818:	fe043783          	ld	a5,-32(s0)
    8001281c:	a03d                	j	8001284a <pci_find_saved_device+0x94>
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    8001281e:	fec42783          	lw	a5,-20(s0)
    80012822:	2785                	addiw	a5,a5,1
    80012824:	fef42623          	sw	a5,-20(s0)
    80012828:	00008797          	auipc	a5,0x8
    8001282c:	81078793          	addi	a5,a5,-2032 # 8001a038 <all_pci_devices>
    80012830:	639c                	ld	a5,0(a5)
    80012832:	853e                	mv	a0,a5
    80012834:	5b0060ef          	jal	ra,80018de4 <vector_size>
    80012838:	87aa                	mv	a5,a0
    8001283a:	0007871b          	sext.w	a4,a5
    8001283e:	fec42783          	lw	a5,-20(s0)
    80012842:	2781                	sext.w	a5,a5
    80012844:	f8e7e7e3          	bltu	a5,a4,800127d2 <pci_find_saved_device+0x1c>
        }
    }
    // If we get here, we didn't find the device
    // debugf("No device found with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    return NULL;
    80012848:	4781                	li	a5,0
}
    8001284a:	853e                	mv	a0,a5
    8001284c:	70a2                	ld	ra,40(sp)
    8001284e:	7402                	ld	s0,32(sp)
    80012850:	6145                	addi	sp,sp,48
    80012852:	8082                	ret

0000000080012854 <pci_get_capability>:

// Get the nth PCI capability for the PCI device. This is used with `0x9` as the type
// to enumerate all of the several Virtio capabilities for a PCI device with the Virtio
// vendor ID.
volatile struct pci_cape *pci_get_capability(PCIDevice *device, uint8_t type, uint8_t nth) {
    80012854:	7139                	addi	sp,sp,-64
    80012856:	fc06                	sd	ra,56(sp)
    80012858:	f822                	sd	s0,48(sp)
    8001285a:	0080                	addi	s0,sp,64
    8001285c:	fca43423          	sd	a0,-56(s0)
    80012860:	87ae                	mv	a5,a1
    80012862:	8732                	mv	a4,a2
    80012864:	fcf403a3          	sb	a5,-57(s0)
    80012868:	87ba                	mv	a5,a4
    8001286a:	fcf40323          	sb	a5,-58(s0)
    // Get the header for the device
    volatile struct pci_ecam *header = device->ecam_header;
    8001286e:	fc843783          	ld	a5,-56(s0)
    80012872:	639c                	ld	a5,0(a5)
    80012874:	fef43023          	sd	a5,-32(s0)
    if (!(header->status_reg & (1 << 4))) {
    80012878:	fe043783          	ld	a5,-32(s0)
    8001287c:	0067d783          	lhu	a5,6(a5)
    80012880:	17c2                	slli	a5,a5,0x30
    80012882:	93c1                	srli	a5,a5,0x30
    80012884:	2781                	sext.w	a5,a5
    80012886:	8bc1                	andi	a5,a5,16
    80012888:	2781                	sext.w	a5,a5
    8001288a:	eb89                	bnez	a5,8001289c <pci_get_capability+0x48>
        debugf("Status reg bit 4 not set; no capabilities for device\n");
    8001288c:	00009517          	auipc	a0,0x9
    80012890:	cec50513          	addi	a0,a0,-788 # 8001b578 <pow10.0+0x348>
    80012894:	587020ef          	jal	ra,8001561a <debugf>
        return NULL;
    80012898:	4781                	li	a5,0
    8001289a:	a8c1                	j	8001296a <pci_get_capability+0x116>
    }
    
    // Get the offset of the first capability
    uint8_t cap_pointer = header->type0.capes_pointer;
    8001289c:	fe043783          	ld	a5,-32(s0)
    800128a0:	0347c783          	lbu	a5,52(a5)
    800128a4:	fef407a3          	sb	a5,-17(s0)
    // Count the number of capabilities we've seen
    uint8_t count = 0;
    800128a8:	fe040723          	sb	zero,-18(s0)
    
    // While the capability pointer is not zero
    while (cap_pointer) {
    800128ac:	a84d                	j	8001295e <pci_get_capability+0x10a>
        // Get the capability at the offset
        volatile struct pci_cape* cape = (struct pci_cape*)((uintptr_t)header + cap_pointer);
    800128ae:	fef44703          	lbu	a4,-17(s0)
    800128b2:	fe043783          	ld	a5,-32(s0)
    800128b6:	97ba                	add	a5,a5,a4
    800128b8:	fcf43c23          	sd	a5,-40(s0)
        // If the capability ID matches the type we're looking for
        switch (cape->id) {
    800128bc:	fd843783          	ld	a5,-40(s0)
    800128c0:	0007c783          	lbu	a5,0(a5)
    800128c4:	0ff7f793          	andi	a5,a5,255
    800128c8:	2781                	sext.w	a5,a5
    800128ca:	86be                	mv	a3,a5
    800128cc:	4725                	li	a4,9
    800128ce:	04e68663          	beq	a3,a4,8001291a <pci_get_capability+0xc6>
    800128d2:	86be                	mv	a3,a5
    800128d4:	4725                	li	a4,9
    800128d6:	00e6ca63          	blt	a3,a4,800128ea <pci_get_capability+0x96>
    800128da:	2781                	sext.w	a5,a5
    800128dc:	37c1                	addiw	a5,a5,-16
    800128de:	2781                	sext.w	a5,a5
    800128e0:	873e                	mv	a4,a5
    800128e2:	4785                	li	a5,1
    800128e4:	00e7e363          	bltu	a5,a4,800128ea <pci_get_capability+0x96>
            {
            }
            case 0x11: /* MSI-x */
            {
            }
            break;
    800128e8:	a815                	j	8001291c <pci_get_capability+0xc8>
            default:
                debugf("Unknown capability ID 0x%02x (next: 0x%02x)\n", cape->id, cape->next);
    800128ea:	fd843783          	ld	a5,-40(s0)
    800128ee:	0007c783          	lbu	a5,0(a5)
    800128f2:	0ff7f793          	andi	a5,a5,255
    800128f6:	0007871b          	sext.w	a4,a5
    800128fa:	fd843783          	ld	a5,-40(s0)
    800128fe:	0017c783          	lbu	a5,1(a5)
    80012902:	0ff7f793          	andi	a5,a5,255
    80012906:	2781                	sext.w	a5,a5
    80012908:	863e                	mv	a2,a5
    8001290a:	85ba                	mv	a1,a4
    8001290c:	00009517          	auipc	a0,0x9
    80012910:	ca450513          	addi	a0,a0,-860 # 8001b5b0 <pow10.0+0x380>
    80012914:	507020ef          	jal	ra,8001561a <debugf>
            break;
    80012918:	a011                	j	8001291c <pci_get_capability+0xc8>
            break;
    8001291a:	0001                	nop
        }

        if (cape->id == type) {
    8001291c:	fd843783          	ld	a5,-40(s0)
    80012920:	0007c783          	lbu	a5,0(a5)
    80012924:	0ff7f713          	andi	a4,a5,255
    80012928:	fc744783          	lbu	a5,-57(s0)
    8001292c:	0ff7f793          	andi	a5,a5,255
    80012930:	02e79163          	bne	a5,a4,80012952 <pci_get_capability+0xfe>
            // If we've seen the nth capability, return it
            if (count++ == nth) {
    80012934:	fee44783          	lbu	a5,-18(s0)
    80012938:	0017871b          	addiw	a4,a5,1
    8001293c:	fee40723          	sb	a4,-18(s0)
    80012940:	fc644703          	lbu	a4,-58(s0)
    80012944:	0ff77713          	andi	a4,a4,255
    80012948:	00f71563          	bne	a4,a5,80012952 <pci_get_capability+0xfe>
                return cape;
    8001294c:	fd843783          	ld	a5,-40(s0)
    80012950:	a829                	j	8001296a <pci_get_capability+0x116>
            }
        }
        // Otherwise, continue to the next capability
        cap_pointer = cape->next; 
    80012952:	fd843783          	ld	a5,-40(s0)
    80012956:	0017c783          	lbu	a5,1(a5)
    8001295a:	fef407a3          	sb	a5,-17(s0)
    while (cap_pointer) {
    8001295e:	fef44783          	lbu	a5,-17(s0)
    80012962:	0ff7f793          	andi	a5,a5,255
    80012966:	f7a1                	bnez	a5,800128ae <pci_get_capability+0x5a>
    }
    return NULL;
    80012968:	4781                	li	a5,0
}
    8001296a:	853e                	mv	a0,a5
    8001296c:	70e2                	ld	ra,56(sp)
    8001296e:	7442                	ld	s0,48(sp)
    80012970:	6121                	addi	sp,sp,64
    80012972:	8082                	ret

0000000080012974 <pci_get_virtio_capability>:
// For the common configuration capability, use `VIRTIO_PCI_CAP_COMMON_CFG`.
// For the notify capability, use `VIRTIO_PCI_CAP_NOTIFY_CFG`.
// For the ISR capability, use `VIRTIO_PCI_CAP_ISR_CFG`.
// For the device configuration capability, use `VIRTIO_PCI_CAP_DEVICE_CFG`.
// For the PCI configuration access capability, use `VIRTIO_PCI_CAP_PCI_CFG`.
volatile struct VirtioCapability *pci_get_virtio_capability(PCIDevice *device, uint8_t virtio_cap_type) {
    80012974:	7139                	addi	sp,sp,-64
    80012976:	fc06                	sd	ra,56(sp)
    80012978:	f822                	sd	s0,48(sp)
    8001297a:	0080                	addi	s0,sp,64
    8001297c:	fca43423          	sd	a0,-56(s0)
    80012980:	87ae                	mv	a5,a1
    80012982:	fcf403a3          	sb	a5,-57(s0)
    // Iterate through the first 10 capabilities
    for (uint8_t i=0; i<10; i++) {
    80012986:	fe0407a3          	sb	zero,-17(s0)
    8001298a:	a095                	j	800129ee <pci_get_virtio_capability+0x7a>
        // Get the capability
        volatile struct pci_cape *cape = pci_get_capability(device, 0x09, i);
    8001298c:	fef44783          	lbu	a5,-17(s0)
    80012990:	863e                	mv	a2,a5
    80012992:	45a5                	li	a1,9
    80012994:	fc843503          	ld	a0,-56(s0)
    80012998:	ebdff0ef          	jal	ra,80012854 <pci_get_capability>
    8001299c:	fea43023          	sd	a0,-32(s0)
        volatile struct VirtioCapability *virtio_cap = (struct VirtioCapability *)cape;
    800129a0:	fe043783          	ld	a5,-32(s0)
    800129a4:	fcf43c23          	sd	a5,-40(s0)
        // If the capability isnt NULL and the type matches, return it
        if (virtio_cap && virtio_cap->type == virtio_cap_type) {
    800129a8:	fd843783          	ld	a5,-40(s0)
    800129ac:	cf85                	beqz	a5,800129e4 <pci_get_virtio_capability+0x70>
    800129ae:	fd843783          	ld	a5,-40(s0)
    800129b2:	0037c783          	lbu	a5,3(a5)
    800129b6:	0ff7f713          	andi	a4,a5,255
    800129ba:	fc744783          	lbu	a5,-57(s0)
    800129be:	0ff7f793          	andi	a5,a5,255
    800129c2:	02e79163          	bne	a5,a4,800129e4 <pci_get_virtio_capability+0x70>
            debugf("Got capability of type %x at %p\n", virtio_cap_type, virtio_cap);
    800129c6:	fc744783          	lbu	a5,-57(s0)
    800129ca:	2781                	sext.w	a5,a5
    800129cc:	fd843603          	ld	a2,-40(s0)
    800129d0:	85be                	mv	a1,a5
    800129d2:	00009517          	auipc	a0,0x9
    800129d6:	c0e50513          	addi	a0,a0,-1010 # 8001b5e0 <pow10.0+0x3b0>
    800129da:	441020ef          	jal	ra,8001561a <debugf>
            return virtio_cap;
    800129de:	fd843783          	ld	a5,-40(s0)
    800129e2:	a805                	j	80012a12 <pci_get_virtio_capability+0x9e>
    for (uint8_t i=0; i<10; i++) {
    800129e4:	fef44783          	lbu	a5,-17(s0)
    800129e8:	2785                	addiw	a5,a5,1
    800129ea:	fef407a3          	sb	a5,-17(s0)
    800129ee:	fef44783          	lbu	a5,-17(s0)
    800129f2:	0ff7f713          	andi	a4,a5,255
    800129f6:	47a5                	li	a5,9
    800129f8:	f8e7fae3          	bgeu	a5,a4,8001298c <pci_get_virtio_capability+0x18>
        }
    }
    // If we get here, we didn't find the capability
    debugf("No virtio capability found with type %d\n", virtio_cap_type);
    800129fc:	fc744783          	lbu	a5,-57(s0)
    80012a00:	2781                	sext.w	a5,a5
    80012a02:	85be                	mv	a1,a5
    80012a04:	00009517          	auipc	a0,0x9
    80012a08:	c0450513          	addi	a0,a0,-1020 # 8001b608 <pow10.0+0x3d8>
    80012a0c:	40f020ef          	jal	ra,8001561a <debugf>
    return NULL;
    80012a10:	4781                	li	a5,0
}
    80012a12:	853e                	mv	a0,a5
    80012a14:	70e2                	ld	ra,56(sp)
    80012a16:	7442                	ld	s0,48(sp)
    80012a18:	6121                	addi	sp,sp,64
    80012a1a:	8082                	ret

0000000080012a1c <pci_count_saved_devices>:

// Return the number of bookkeeping PCI devices saved by the OS.
uint64_t pci_count_saved_devices(void) {
    80012a1c:	1141                	addi	sp,sp,-16
    80012a1e:	e406                	sd	ra,8(sp)
    80012a20:	e022                	sd	s0,0(sp)
    80012a22:	0800                	addi	s0,sp,16
    return vector_size(all_pci_devices);
    80012a24:	00007797          	auipc	a5,0x7
    80012a28:	61478793          	addi	a5,a5,1556 # 8001a038 <all_pci_devices>
    80012a2c:	639c                	ld	a5,0(a5)
    80012a2e:	853e                	mv	a0,a5
    80012a30:	3b4060ef          	jal	ra,80018de4 <vector_size>
    80012a34:	87aa                	mv	a5,a0
    80012a36:	2781                	sext.w	a5,a5
    80012a38:	1782                	slli	a5,a5,0x20
    80012a3a:	9381                	srli	a5,a5,0x20
}
    80012a3c:	853e                	mv	a0,a5
    80012a3e:	60a2                	ld	ra,8(sp)
    80012a40:	6402                	ld	s0,0(sp)
    80012a42:	0141                	addi	sp,sp,16
    80012a44:	8082                	ret

0000000080012a46 <pci_count_irq_listeners>:

// Count how many devices are listening for the given IRQ.
uint64_t pci_count_irq_listeners(uint8_t irq) {
    80012a46:	7179                	addi	sp,sp,-48
    80012a48:	f406                	sd	ra,40(sp)
    80012a4a:	f022                	sd	s0,32(sp)
    80012a4c:	1800                	addi	s0,sp,48
    80012a4e:	87aa                	mv	a5,a0
    80012a50:	fcf40fa3          	sb	a5,-33(s0)
    uint32_t vector_idx = irq - 32;
    80012a54:	fdf44783          	lbu	a5,-33(s0)
    80012a58:	2781                	sext.w	a5,a5
    80012a5a:	3781                	addiw	a5,a5,-32
    80012a5c:	2781                	sext.w	a5,a5
    80012a5e:	fef42623          	sw	a5,-20(s0)
    return vector_size(irq_pci_devices[vector_idx]);
    80012a62:	00007717          	auipc	a4,0x7
    80012a66:	5de70713          	addi	a4,a4,1502 # 8001a040 <irq_pci_devices>
    80012a6a:	fec46783          	lwu	a5,-20(s0)
    80012a6e:	078e                	slli	a5,a5,0x3
    80012a70:	97ba                	add	a5,a5,a4
    80012a72:	639c                	ld	a5,0(a5)
    80012a74:	853e                	mv	a0,a5
    80012a76:	36e060ef          	jal	ra,80018de4 <vector_size>
    80012a7a:	87aa                	mv	a5,a0
    80012a7c:	2781                	sext.w	a5,a5
    80012a7e:	1782                	slli	a5,a5,0x20
    80012a80:	9381                	srli	a5,a5,0x20
}
    80012a82:	853e                	mv	a0,a5
    80012a84:	70a2                	ld	ra,40(sp)
    80012a86:	7402                	ld	s0,32(sp)
    80012a88:	6145                	addi	sp,sp,48
    80012a8a:	8082                	ret

0000000080012a8c <pci_get_bus_number>:

// Get the bus number for the given PCI device.
uint8_t pci_get_bus_number(PCIDevice *dev) {
    80012a8c:	1101                	addi	sp,sp,-32
    80012a8e:	ec22                	sd	s0,24(sp)
    80012a90:	1000                	addi	s0,sp,32
    80012a92:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 20) & 0xF;
    80012a96:	fe843783          	ld	a5,-24(s0)
    80012a9a:	639c                	ld	a5,0(a5)
    80012a9c:	83d1                	srli	a5,a5,0x14
    80012a9e:	0ff7f793          	andi	a5,a5,255
    80012aa2:	8bbd                	andi	a5,a5,15
    80012aa4:	0ff7f793          	andi	a5,a5,255
}
    80012aa8:	853e                	mv	a0,a5
    80012aaa:	6462                	ld	s0,24(sp)
    80012aac:	6105                	addi	sp,sp,32
    80012aae:	8082                	ret

0000000080012ab0 <pci_get_slot_number>:

// Get the slot number for the given PCI device.
uint8_t pci_get_slot_number(PCIDevice *dev) {
    80012ab0:	1101                	addi	sp,sp,-32
    80012ab2:	ec22                	sd	s0,24(sp)
    80012ab4:	1000                	addi	s0,sp,32
    80012ab6:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 15) & 0x1F;
    80012aba:	fe843783          	ld	a5,-24(s0)
    80012abe:	639c                	ld	a5,0(a5)
    80012ac0:	83bd                	srli	a5,a5,0xf
    80012ac2:	0ff7f793          	andi	a5,a5,255
    80012ac6:	8bfd                	andi	a5,a5,31
    80012ac8:	0ff7f793          	andi	a5,a5,255
}
    80012acc:	853e                	mv	a0,a5
    80012ace:	6462                	ld	s0,24(sp)
    80012ad0:	6105                	addi	sp,sp,32
    80012ad2:	8082                	ret

0000000080012ad4 <pci_save_device>:

// Save the PCI device for bookkeeping. This will save some
// information about the device for quick access later.
PCIDevice *pci_save_device(PCIDevice device) {
    80012ad4:	7179                	addi	sp,sp,-48
    80012ad6:	f406                	sd	ra,40(sp)
    80012ad8:	f022                	sd	s0,32(sp)
    80012ada:	ec26                	sd	s1,24(sp)
    80012adc:	1800                	addi	s0,sp,48
    80012ade:	84aa                	mv	s1,a0
    // Allocate some memory for the device's bookkeeping structure
    PCIDevice *pcidev = (PCIDevice *)kzalloc(sizeof(PCIDevice));
    80012ae0:	03800593          	li	a1,56
    80012ae4:	4505                	li	a0,1
    80012ae6:	5b9010ef          	jal	ra,8001489e <kcalloc>
    80012aea:	fca43c23          	sd	a0,-40(s0)
    // Record the device's ECAM header
    memcpy(pcidev, &device, sizeof(PCIDevice));
    80012aee:	03800613          	li	a2,56
    80012af2:	85a6                	mv	a1,s1
    80012af4:	fd843503          	ld	a0,-40(s0)
    80012af8:	03c050ef          	jal	ra,80017b34 <memcpy>
    // Store the device in the all devices vector
    vector_push_ptr(all_pci_devices, pcidev);
    80012afc:	00007797          	auipc	a5,0x7
    80012b00:	53c78793          	addi	a5,a5,1340 # 8001a038 <all_pci_devices>
    80012b04:	639c                	ld	a5,0(a5)
    80012b06:	fd843703          	ld	a4,-40(s0)
    80012b0a:	85ba                	mv	a1,a4
    80012b0c:	853e                	mv	a0,a5
    80012b0e:	217050ef          	jal	ra,80018524 <vector_push>
    // Store the device in the appropriate IRQ vector
    uint8_t bus = pci_get_bus_number(pcidev);
    80012b12:	fd843503          	ld	a0,-40(s0)
    80012b16:	f77ff0ef          	jal	ra,80012a8c <pci_get_bus_number>
    80012b1a:	87aa                	mv	a5,a0
    80012b1c:	fcf40ba3          	sb	a5,-41(s0)
    uint8_t slot = pci_get_slot_number(pcidev);
    80012b20:	fd843503          	ld	a0,-40(s0)
    80012b24:	f8dff0ef          	jal	ra,80012ab0 <pci_get_slot_number>
    80012b28:	87aa                	mv	a5,a0
    80012b2a:	fcf40b23          	sb	a5,-42(s0)
    debugf("Saving device with vendor ID: 0x%04x, device ID: 0x%04x, class code: 0x%04x\n", device.ecam_header->vendor_id, device.ecam_header->device_id, device.ecam_header->class_code);
    80012b2e:	609c                	ld	a5,0(s1)
    80012b30:	0007d783          	lhu	a5,0(a5)
    80012b34:	17c2                	slli	a5,a5,0x30
    80012b36:	93c1                	srli	a5,a5,0x30
    80012b38:	0007871b          	sext.w	a4,a5
    80012b3c:	609c                	ld	a5,0(s1)
    80012b3e:	0027d783          	lhu	a5,2(a5)
    80012b42:	17c2                	slli	a5,a5,0x30
    80012b44:	93c1                	srli	a5,a5,0x30
    80012b46:	0007861b          	sext.w	a2,a5
    80012b4a:	609c                	ld	a5,0(s1)
    80012b4c:	00a7d783          	lhu	a5,10(a5)
    80012b50:	17c2                	slli	a5,a5,0x30
    80012b52:	93c1                	srli	a5,a5,0x30
    80012b54:	2781                	sext.w	a5,a5
    80012b56:	86be                	mv	a3,a5
    80012b58:	85ba                	mv	a1,a4
    80012b5a:	00009517          	auipc	a0,0x9
    80012b5e:	ade50513          	addi	a0,a0,-1314 # 8001b638 <pow10.0+0x408>
    80012b62:	2b9020ef          	jal	ra,8001561a <debugf>
    debugf("  Bus: %d, slot: %d\n", bus, slot);
    80012b66:	fd744783          	lbu	a5,-41(s0)
    80012b6a:	2781                	sext.w	a5,a5
    80012b6c:	fd644703          	lbu	a4,-42(s0)
    80012b70:	2701                	sext.w	a4,a4
    80012b72:	863a                	mv	a2,a4
    80012b74:	85be                	mv	a1,a5
    80012b76:	00009517          	auipc	a0,0x9
    80012b7a:	b1250513          	addi	a0,a0,-1262 # 8001b688 <pow10.0+0x458>
    80012b7e:	29d020ef          	jal	ra,8001561a <debugf>
    uint32_t vector_idx = (bus + slot) % 4;
    80012b82:	fd744703          	lbu	a4,-41(s0)
    80012b86:	fd644783          	lbu	a5,-42(s0)
    80012b8a:	9fb9                	addw	a5,a5,a4
    80012b8c:	0ff7f793          	andi	a5,a5,255
    80012b90:	2781                	sext.w	a5,a5
    80012b92:	8b8d                	andi	a5,a5,3
    80012b94:	fcf42823          	sw	a5,-48(s0)
    vector_push_ptr(irq_pci_devices[vector_idx], pcidev);
    80012b98:	00007717          	auipc	a4,0x7
    80012b9c:	4a870713          	addi	a4,a4,1192 # 8001a040 <irq_pci_devices>
    80012ba0:	fd046783          	lwu	a5,-48(s0)
    80012ba4:	078e                	slli	a5,a5,0x3
    80012ba6:	97ba                	add	a5,a5,a4
    80012ba8:	639c                	ld	a5,0(a5)
    80012baa:	fd843703          	ld	a4,-40(s0)
    80012bae:	85ba                	mv	a1,a4
    80012bb0:	853e                	mv	a0,a5
    80012bb2:	173050ef          	jal	ra,80018524 <vector_push>
    // Return the device's bookkeeping structure in memory
    return pcidev;
    80012bb6:	fd843783          	ld	a5,-40(s0)
}
    80012bba:	853e                	mv	a0,a5
    80012bbc:	70a2                	ld	ra,40(sp)
    80012bbe:	7402                	ld	s0,32(sp)
    80012bc0:	64e2                	ld	s1,24(sp)
    80012bc2:	6145                	addi	sp,sp,48
    80012bc4:	8082                	ret

0000000080012bc6 <pci_get_nth_saved_device>:

// Get the nth saved PCI device structure kept by the OS.
PCIDevice *pci_get_nth_saved_device(uint16_t n) {
    80012bc6:	7179                	addi	sp,sp,-48
    80012bc8:	f406                	sd	ra,40(sp)
    80012bca:	f022                	sd	s0,32(sp)
    80012bcc:	1800                	addi	s0,sp,48
    80012bce:	87aa                	mv	a5,a0
    80012bd0:	fcf41f23          	sh	a5,-34(s0)
    PCIDevice *pcidev;
    vector_get_ptr(all_pci_devices, n, &pcidev);
    80012bd4:	00007797          	auipc	a5,0x7
    80012bd8:	46478793          	addi	a5,a5,1124 # 8001a038 <all_pci_devices>
    80012bdc:	639c                	ld	a5,0(a5)
    80012bde:	fde45703          	lhu	a4,-34(s0)
    80012be2:	2701                	sext.w	a4,a4
    80012be4:	fe840693          	addi	a3,s0,-24
    80012be8:	8636                	mv	a2,a3
    80012bea:	85ba                	mv	a1,a4
    80012bec:	853e                	mv	a0,a5
    80012bee:	297050ef          	jal	ra,80018684 <vector_get>
    return pcidev;
    80012bf2:	fe843783          	ld	a5,-24(s0)
}
    80012bf6:	853e                	mv	a0,a5
    80012bf8:	70a2                	ld	ra,40(sp)
    80012bfa:	7402                	ld	s0,32(sp)
    80012bfc:	6145                	addi	sp,sp,48
    80012bfe:	8082                	ret

0000000080012c00 <pci_find_device_by_irq>:

// Get the device responsible for a given IRQ.
PCIDevice *pci_find_device_by_irq(uint8_t irq) {
    80012c00:	7139                	addi	sp,sp,-64
    80012c02:	fc06                	sd	ra,56(sp)
    80012c04:	f822                	sd	s0,48(sp)
    80012c06:	0080                	addi	s0,sp,64
    80012c08:	87aa                	mv	a5,a0
    80012c0a:	fcf407a3          	sb	a5,-49(s0)
    uint32_t vector_idx = irq - 32;
    80012c0e:	fcf44783          	lbu	a5,-49(s0)
    80012c12:	2781                	sext.w	a5,a5
    80012c14:	3781                	addiw	a5,a5,-32
    80012c16:	2781                	sext.w	a5,a5
    80012c18:	fef42423          	sw	a5,-24(s0)
    debugf("Finding device with IRQ %d\n", irq);
    80012c1c:	fcf44783          	lbu	a5,-49(s0)
    80012c20:	2781                	sext.w	a5,a5
    80012c22:	85be                	mv	a1,a5
    80012c24:	00009517          	auipc	a0,0x9
    80012c28:	a7c50513          	addi	a0,a0,-1412 # 8001b6a0 <pow10.0+0x470>
    80012c2c:	1ef020ef          	jal	ra,8001561a <debugf>

    // Check all devices in the vector
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    80012c30:	fe042623          	sw	zero,-20(s0)
    80012c34:	aa99                	j	80012d8a <pci_find_device_by_irq+0x18a>
        // Get the nth PCI device listening for the IRQ
        volatile PCIDevice *device = NULL;
    80012c36:	fc043823          	sd	zero,-48(s0)
        vector_get_ptr(irq_pci_devices[vector_idx], i, &device);
    80012c3a:	00007717          	auipc	a4,0x7
    80012c3e:	40670713          	addi	a4,a4,1030 # 8001a040 <irq_pci_devices>
    80012c42:	fe846783          	lwu	a5,-24(s0)
    80012c46:	078e                	slli	a5,a5,0x3
    80012c48:	97ba                	add	a5,a5,a4
    80012c4a:	639c                	ld	a5,0(a5)
    80012c4c:	fd040693          	addi	a3,s0,-48
    80012c50:	fec42703          	lw	a4,-20(s0)
    80012c54:	8636                	mv	a2,a3
    80012c56:	85ba                	mv	a1,a4
    80012c58:	853e                	mv	a0,a5
    80012c5a:	22b050ef          	jal	ra,80018684 <vector_get>
        debugf("Device: %p\n", device->ecam_header);
    80012c5e:	fd043783          	ld	a5,-48(s0)
    80012c62:	639c                	ld	a5,0(a5)
    80012c64:	85be                	mv	a1,a5
    80012c66:	00009517          	auipc	a0,0x9
    80012c6a:	a5a50513          	addi	a0,a0,-1446 # 8001b6c0 <pow10.0+0x490>
    80012c6e:	1ad020ef          	jal	ra,8001561a <debugf>
        // If the device is a Virtio device, check the Virtio ISR status
        if (!pci_is_virtio_device(device)) {
    80012c72:	fd043783          	ld	a5,-48(s0)
    80012c76:	853e                	mv	a0,a5
    80012c78:	b09ff0ef          	jal	ra,80012780 <pci_is_virtio_device>
    80012c7c:	87aa                	mv	a5,a0
    80012c7e:	0017c793          	xori	a5,a5,1
    80012c82:	0ff7f793          	andi	a5,a5,255
    80012c86:	cb99                	beqz	a5,80012c9c <pci_find_device_by_irq+0x9c>
            debugf("%p not a virtio device\n", device);
    80012c88:	fd043783          	ld	a5,-48(s0)
    80012c8c:	85be                	mv	a1,a5
    80012c8e:	00009517          	auipc	a0,0x9
    80012c92:	a4250513          	addi	a0,a0,-1470 # 8001b6d0 <pow10.0+0x4a0>
    80012c96:	185020ef          	jal	ra,8001561a <debugf>
            continue;
    80012c9a:	a0dd                	j	80012d80 <pci_find_device_by_irq+0x180>
        }
        
        // Confirm that the device exists
        if (!pci_device_exists(device->ecam_header->vendor_id)) {
    80012c9c:	fd043783          	ld	a5,-48(s0)
    80012ca0:	639c                	ld	a5,0(a5)
    80012ca2:	0007d783          	lhu	a5,0(a5)
    80012ca6:	17c2                	slli	a5,a5,0x30
    80012ca8:	93c1                	srli	a5,a5,0x30
    80012caa:	853e                	mv	a0,a5
    80012cac:	a9dff0ef          	jal	ra,80012748 <pci_device_exists>
    80012cb0:	87aa                	mv	a5,a0
    80012cb2:	0017c793          	xori	a5,a5,1
    80012cb6:	0ff7f793          	andi	a5,a5,255
    80012cba:	cb99                	beqz	a5,80012cd0 <pci_find_device_by_irq+0xd0>
            debugf("%p device doesn't exist\n", device);
    80012cbc:	fd043783          	ld	a5,-48(s0)
    80012cc0:	85be                	mv	a1,a5
    80012cc2:	00009517          	auipc	a0,0x9
    80012cc6:	a2650513          	addi	a0,a0,-1498 # 8001b6e8 <pow10.0+0x4b8>
    80012cca:	151020ef          	jal	ra,8001561a <debugf>
            continue;
    80012cce:	a84d                	j	80012d80 <pci_find_device_by_irq+0x180>
        }

        // Get the Virtio ISR status
        volatile struct VirtioPciIsrCfg *isr = pci_get_virtio_isr_status(device);
    80012cd0:	fd043783          	ld	a5,-48(s0)
    80012cd4:	853e                	mv	a0,a5
    80012cd6:	2f8000ef          	jal	ra,80012fce <pci_get_virtio_isr_status>
    80012cda:	fea43023          	sd	a0,-32(s0)
        int result = isr->isr_cap;
    80012cde:	fe043783          	ld	a5,-32(s0)
    80012ce2:	439c                	lw	a5,0(a5)
    80012ce4:	2781                	sext.w	a5,a5
    80012ce6:	fcf42e23          	sw	a5,-36(s0)
        debugf("ISR at %p=0x%x\n", isr, result);
    80012cea:	fdc42783          	lw	a5,-36(s0)
    80012cee:	863e                	mv	a2,a5
    80012cf0:	fe043583          	ld	a1,-32(s0)
    80012cf4:	00009517          	auipc	a0,0x9
    80012cf8:	a1450513          	addi	a0,a0,-1516 # 8001b708 <pow10.0+0x4d8>
    80012cfc:	11f020ef          	jal	ra,8001561a <debugf>
        if (result) {
    80012d00:	fdc42783          	lw	a5,-36(s0)
    80012d04:	2781                	sext.w	a5,a5
    80012d06:	cf89                	beqz	a5,80012d20 <pci_find_device_by_irq+0x120>
            debugf("IRQ device responsible: %p\n", device);
    80012d08:	fd043783          	ld	a5,-48(s0)
    80012d0c:	85be                	mv	a1,a5
    80012d0e:	00009517          	auipc	a0,0x9
    80012d12:	a0a50513          	addi	a0,a0,-1526 # 8001b718 <pow10.0+0x4e8>
    80012d16:	105020ef          	jal	ra,8001561a <debugf>
            return device;
    80012d1a:	fd043783          	ld	a5,-48(s0)
    80012d1e:	a06d                	j	80012dc8 <pci_find_device_by_irq+0x1c8>
        }

        // Check if the device's configuration has changed
        if (isr->isr_cap) {
    80012d20:	fe043783          	ld	a5,-32(s0)
    80012d24:	439c                	lw	a5,0(a5)
    80012d26:	2781                	sext.w	a5,a5
    80012d28:	c39d                	beqz	a5,80012d4e <pci_find_device_by_irq+0x14e>
            debugf("Device configuration interrupt from device 0x%04x\n", device->ecam_header->device_id);
    80012d2a:	fd043783          	ld	a5,-48(s0)
    80012d2e:	639c                	ld	a5,0(a5)
    80012d30:	0027d783          	lhu	a5,2(a5)
    80012d34:	17c2                	slli	a5,a5,0x30
    80012d36:	93c1                	srli	a5,a5,0x30
    80012d38:	2781                	sext.w	a5,a5
    80012d3a:	85be                	mv	a1,a5
    80012d3c:	00009517          	auipc	a0,0x9
    80012d40:	9fc50513          	addi	a0,a0,-1540 # 8001b738 <pow10.0+0x508>
    80012d44:	0d7020ef          	jal	ra,8001561a <debugf>
            return device;
    80012d48:	fd043783          	ld	a5,-48(s0)
    80012d4c:	a8b5                	j	80012dc8 <pci_find_device_by_irq+0x1c8>
        }

        // Check if the device's queue has an interrupt
        if (isr->queue_interrupt) {
    80012d4e:	fe043783          	ld	a5,-32(s0)
    80012d52:	439c                	lw	a5,0(a5)
    80012d54:	8b85                	andi	a5,a5,1
    80012d56:	0ff7f793          	andi	a5,a5,255
    80012d5a:	c39d                	beqz	a5,80012d80 <pci_find_device_by_irq+0x180>
            debugf("Device queue interrupt from device 0x%04x\n", device->ecam_header->device_id);
    80012d5c:	fd043783          	ld	a5,-48(s0)
    80012d60:	639c                	ld	a5,0(a5)
    80012d62:	0027d783          	lhu	a5,2(a5)
    80012d66:	17c2                	slli	a5,a5,0x30
    80012d68:	93c1                	srli	a5,a5,0x30
    80012d6a:	2781                	sext.w	a5,a5
    80012d6c:	85be                	mv	a1,a5
    80012d6e:	00009517          	auipc	a0,0x9
    80012d72:	a0250513          	addi	a0,a0,-1534 # 8001b770 <pow10.0+0x540>
    80012d76:	0a5020ef          	jal	ra,8001561a <debugf>
            return device;
    80012d7a:	fd043783          	ld	a5,-48(s0)
    80012d7e:	a0a9                	j	80012dc8 <pci_find_device_by_irq+0x1c8>
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    80012d80:	fec42783          	lw	a5,-20(s0)
    80012d84:	2785                	addiw	a5,a5,1
    80012d86:	fef42623          	sw	a5,-20(s0)
    80012d8a:	00007717          	auipc	a4,0x7
    80012d8e:	2b670713          	addi	a4,a4,694 # 8001a040 <irq_pci_devices>
    80012d92:	fe846783          	lwu	a5,-24(s0)
    80012d96:	078e                	slli	a5,a5,0x3
    80012d98:	97ba                	add	a5,a5,a4
    80012d9a:	639c                	ld	a5,0(a5)
    80012d9c:	853e                	mv	a0,a5
    80012d9e:	046060ef          	jal	ra,80018de4 <vector_size>
    80012da2:	87aa                	mv	a5,a0
    80012da4:	0007871b          	sext.w	a4,a5
    80012da8:	fec42783          	lw	a5,-20(s0)
    80012dac:	2781                	sext.w	a5,a5
    80012dae:	e8e7e4e3          	bltu	a5,a4,80012c36 <pci_find_device_by_irq+0x36>
        }
    }
    debugf("No device found with IRQ %d\n", irq);
    80012db2:	fcf44783          	lbu	a5,-49(s0)
    80012db6:	2781                	sext.w	a5,a5
    80012db8:	85be                	mv	a1,a5
    80012dba:	00009517          	auipc	a0,0x9
    80012dbe:	9e650513          	addi	a0,a0,-1562 # 8001b7a0 <pow10.0+0x570>
    80012dc2:	059020ef          	jal	ra,8001561a <debugf>
    return NULL;
    80012dc6:	4781                	li	a5,0
}
    80012dc8:	853e                	mv	a0,a5
    80012dca:	70e2                	ld	ra,56(sp)
    80012dcc:	7442                	ld	s0,48(sp)
    80012dce:	6121                	addi	sp,sp,64
    80012dd0:	8082                	ret

0000000080012dd2 <pci_get_device_specific_config>:


// Get the common configuration capability for the given virtio device.
volatile void *pci_get_device_specific_config(PCIDevice *device) {
    80012dd2:	7179                	addi	sp,sp,-48
    80012dd4:	f406                	sd	ra,40(sp)
    80012dd6:	f022                	sd	s0,32(sp)
    80012dd8:	1800                	addi	s0,sp,48
    80012dda:	fca43c23          	sd	a0,-40(s0)
    struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_DEVICE_CFG);
    80012dde:	4591                	li	a1,4
    80012de0:	fd843503          	ld	a0,-40(s0)
    80012de4:	b91ff0ef          	jal	ra,80012974 <pci_get_virtio_capability>
    80012de8:	fea43423          	sd	a0,-24(s0)
    debugf("Getting device specific config from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uint64_t)vio_cap->offset);
    80012dec:	fe843783          	ld	a5,-24(s0)
    80012df0:	0047c783          	lbu	a5,4(a5)
    80012df4:	0007859b          	sext.w	a1,a5
    80012df8:	fd843783          	ld	a5,-40(s0)
    80012dfc:	6398                	ld	a4,0(a5)
    80012dfe:	fe843783          	ld	a5,-24(s0)
    80012e02:	0047c783          	lbu	a5,4(a5)
    80012e06:	2781                	sext.w	a5,a5
    80012e08:	0791                	addi	a5,a5,4
    80012e0a:	078a                	slli	a5,a5,0x2
    80012e0c:	97ba                	add	a5,a5,a4
    80012e0e:	439c                	lw	a5,0(a5)
    80012e10:	2781                	sext.w	a5,a5
    80012e12:	1782                	slli	a5,a5,0x20
    80012e14:	9381                	srli	a5,a5,0x20
    80012e16:	ff07f713          	andi	a4,a5,-16
    80012e1a:	fe843783          	ld	a5,-24(s0)
    80012e1e:	479c                	lw	a5,8(a5)
    80012e20:	1782                	slli	a5,a5,0x20
    80012e22:	9381                	srli	a5,a5,0x20
    80012e24:	86be                	mv	a3,a5
    80012e26:	863a                	mv	a2,a4
    80012e28:	00009517          	auipc	a0,0x9
    80012e2c:	99850513          	addi	a0,a0,-1640 # 8001b7c0 <pow10.0+0x590>
    80012e30:	7ea020ef          	jal	ra,8001561a <debugf>
    return (volatile void*)(((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uint64_t)vio_cap->offset);
    80012e34:	fd843783          	ld	a5,-40(s0)
    80012e38:	6398                	ld	a4,0(a5)
    80012e3a:	fe843783          	ld	a5,-24(s0)
    80012e3e:	0047c783          	lbu	a5,4(a5)
    80012e42:	2781                	sext.w	a5,a5
    80012e44:	0791                	addi	a5,a5,4
    80012e46:	078a                	slli	a5,a5,0x2
    80012e48:	97ba                	add	a5,a5,a4
    80012e4a:	439c                	lw	a5,0(a5)
    80012e4c:	2781                	sext.w	a5,a5
    80012e4e:	1782                	slli	a5,a5,0x20
    80012e50:	9381                	srli	a5,a5,0x20
    80012e52:	ff07f713          	andi	a4,a5,-16
    80012e56:	fe843783          	ld	a5,-24(s0)
    80012e5a:	479c                	lw	a5,8(a5)
    80012e5c:	1782                	slli	a5,a5,0x20
    80012e5e:	9381                	srli	a5,a5,0x20
    80012e60:	97ba                	add	a5,a5,a4
}
    80012e62:	853e                	mv	a0,a5
    80012e64:	70a2                	ld	ra,40(sp)
    80012e66:	7402                	ld	s0,32(sp)
    80012e68:	6145                	addi	sp,sp,48
    80012e6a:	8082                	ret

0000000080012e6c <pci_get_virtio_common_config>:

// Get the common configuration capability for the given virtio device.
volatile struct VirtioPciCommonCfg *pci_get_virtio_common_config(PCIDevice *device) {
    80012e6c:	7179                	addi	sp,sp,-48
    80012e6e:	f406                	sd	ra,40(sp)
    80012e70:	f022                	sd	s0,32(sp)
    80012e72:	1800                	addi	s0,sp,48
    80012e74:	fca43c23          	sd	a0,-40(s0)
    struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_COMMON_CFG);
    80012e78:	4585                	li	a1,1
    80012e7a:	fd843503          	ld	a0,-40(s0)
    80012e7e:	af7ff0ef          	jal	ra,80012974 <pci_get_virtio_capability>
    80012e82:	fea43423          	sd	a0,-24(s0)
    debugf("Getting common capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uint64_t)vio_cap->offset);
    80012e86:	fe843783          	ld	a5,-24(s0)
    80012e8a:	0047c783          	lbu	a5,4(a5)
    80012e8e:	0007859b          	sext.w	a1,a5
    80012e92:	fd843783          	ld	a5,-40(s0)
    80012e96:	6398                	ld	a4,0(a5)
    80012e98:	fe843783          	ld	a5,-24(s0)
    80012e9c:	0047c783          	lbu	a5,4(a5)
    80012ea0:	2781                	sext.w	a5,a5
    80012ea2:	0791                	addi	a5,a5,4
    80012ea4:	078a                	slli	a5,a5,0x2
    80012ea6:	97ba                	add	a5,a5,a4
    80012ea8:	439c                	lw	a5,0(a5)
    80012eaa:	2781                	sext.w	a5,a5
    80012eac:	1782                	slli	a5,a5,0x20
    80012eae:	9381                	srli	a5,a5,0x20
    80012eb0:	ff07f713          	andi	a4,a5,-16
    80012eb4:	fe843783          	ld	a5,-24(s0)
    80012eb8:	479c                	lw	a5,8(a5)
    80012eba:	1782                	slli	a5,a5,0x20
    80012ebc:	9381                	srli	a5,a5,0x20
    80012ebe:	86be                	mv	a3,a5
    80012ec0:	863a                	mv	a2,a4
    80012ec2:	00009517          	auipc	a0,0x9
    80012ec6:	93e50513          	addi	a0,a0,-1730 # 8001b800 <pow10.0+0x5d0>
    80012eca:	750020ef          	jal	ra,8001561a <debugf>
    return (volatile struct VirtioPciCommonCfg *)(((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uint64_t)vio_cap->offset);
    80012ece:	fd843783          	ld	a5,-40(s0)
    80012ed2:	6398                	ld	a4,0(a5)
    80012ed4:	fe843783          	ld	a5,-24(s0)
    80012ed8:	0047c783          	lbu	a5,4(a5)
    80012edc:	2781                	sext.w	a5,a5
    80012ede:	0791                	addi	a5,a5,4
    80012ee0:	078a                	slli	a5,a5,0x2
    80012ee2:	97ba                	add	a5,a5,a4
    80012ee4:	439c                	lw	a5,0(a5)
    80012ee6:	2781                	sext.w	a5,a5
    80012ee8:	1782                	slli	a5,a5,0x20
    80012eea:	9381                	srli	a5,a5,0x20
    80012eec:	ff07f713          	andi	a4,a5,-16
    80012ef0:	fe843783          	ld	a5,-24(s0)
    80012ef4:	479c                	lw	a5,8(a5)
    80012ef6:	1782                	slli	a5,a5,0x20
    80012ef8:	9381                	srli	a5,a5,0x20
    80012efa:	97ba                	add	a5,a5,a4
}
    80012efc:	853e                	mv	a0,a5
    80012efe:	70a2                	ld	ra,40(sp)
    80012f00:	7402                	ld	s0,32(sp)
    80012f02:	6145                	addi	sp,sp,48
    80012f04:	8082                	ret

0000000080012f06 <pci_get_virtio_notify_capability>:

// Get the notify capability for the given virtio device.
volatile struct VirtioPciNotifyCfg *pci_get_virtio_notify_capability(PCIDevice *device) {
    80012f06:	7179                	addi	sp,sp,-48
    80012f08:	f406                	sd	ra,40(sp)
    80012f0a:	f022                	sd	s0,32(sp)
    80012f0c:	1800                	addi	s0,sp,48
    80012f0e:	fca43c23          	sd	a0,-40(s0)
    struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_NOTIFY_CFG);
    80012f12:	4589                	li	a1,2
    80012f14:	fd843503          	ld	a0,-40(s0)
    80012f18:	a5dff0ef          	jal	ra,80012974 <pci_get_virtio_capability>
    80012f1c:	fea43423          	sd	a0,-24(s0)
    debugf("Cap at %p\n", vio_cap);
    80012f20:	fe843583          	ld	a1,-24(s0)
    80012f24:	00009517          	auipc	a0,0x9
    80012f28:	91450513          	addi	a0,a0,-1772 # 8001b838 <pow10.0+0x608>
    80012f2c:	6ee020ef          	jal	ra,8001561a <debugf>
    debugf("Getting notify capability from bar #%d = %p + 0x%x (len=%d) %d\n", vio_cap->bar, ((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uint64_t)vio_cap->offset, vio_cap->len, sizeof(VirtioPciNotifyCfg));
    80012f30:	fe843783          	ld	a5,-24(s0)
    80012f34:	0047c783          	lbu	a5,4(a5)
    80012f38:	0007859b          	sext.w	a1,a5
    80012f3c:	fd843783          	ld	a5,-40(s0)
    80012f40:	6398                	ld	a4,0(a5)
    80012f42:	fe843783          	ld	a5,-24(s0)
    80012f46:	0047c783          	lbu	a5,4(a5)
    80012f4a:	2781                	sext.w	a5,a5
    80012f4c:	0791                	addi	a5,a5,4
    80012f4e:	078a                	slli	a5,a5,0x2
    80012f50:	97ba                	add	a5,a5,a4
    80012f52:	439c                	lw	a5,0(a5)
    80012f54:	2781                	sext.w	a5,a5
    80012f56:	1782                	slli	a5,a5,0x20
    80012f58:	9381                	srli	a5,a5,0x20
    80012f5a:	ff07f613          	andi	a2,a5,-16
    80012f5e:	fe843783          	ld	a5,-24(s0)
    80012f62:	479c                	lw	a5,8(a5)
    80012f64:	02079693          	slli	a3,a5,0x20
    80012f68:	9281                	srli	a3,a3,0x20
    80012f6a:	fe843783          	ld	a5,-24(s0)
    80012f6e:	0027c783          	lbu	a5,2(a5)
    80012f72:	0007871b          	sext.w	a4,a5
    80012f76:	47d1                	li	a5,20
    80012f78:	00009517          	auipc	a0,0x9
    80012f7c:	8d050513          	addi	a0,a0,-1840 # 8001b848 <pow10.0+0x618>
    80012f80:	69a020ef          	jal	ra,8001561a <debugf>
    return vio_cap;
    80012f84:	fe843783          	ld	a5,-24(s0)
}
    80012f88:	853e                	mv	a0,a5
    80012f8a:	70a2                	ld	ra,40(sp)
    80012f8c:	7402                	ld	s0,32(sp)
    80012f8e:	6145                	addi	sp,sp,48
    80012f90:	8082                	ret

0000000080012f92 <pci_get_device_bar>:

volatile uint8_t *pci_get_device_bar(PCIDevice *device, uint8_t bar_num) {
    80012f92:	1101                	addi	sp,sp,-32
    80012f94:	ec22                	sd	s0,24(sp)
    80012f96:	1000                	addi	s0,sp,32
    80012f98:	fea43423          	sd	a0,-24(s0)
    80012f9c:	87ae                	mv	a5,a1
    80012f9e:	fef403a3          	sb	a5,-25(s0)
    return device->ecam_header->type0.bar[bar_num] & ~0xf;
    80012fa2:	fe843783          	ld	a5,-24(s0)
    80012fa6:	6398                	ld	a4,0(a5)
    80012fa8:	fe744783          	lbu	a5,-25(s0)
    80012fac:	2781                	sext.w	a5,a5
    80012fae:	0791                	addi	a5,a5,4
    80012fb0:	078a                	slli	a5,a5,0x2
    80012fb2:	97ba                	add	a5,a5,a4
    80012fb4:	439c                	lw	a5,0(a5)
    80012fb6:	2781                	sext.w	a5,a5
    80012fb8:	02079713          	slli	a4,a5,0x20
    80012fbc:	9301                	srli	a4,a4,0x20
    80012fbe:	4785                	li	a5,1
    80012fc0:	1782                	slli	a5,a5,0x20
    80012fc2:	17c1                	addi	a5,a5,-16
    80012fc4:	8ff9                	and	a5,a5,a4
}
    80012fc6:	853e                	mv	a0,a5
    80012fc8:	6462                	ld	s0,24(sp)
    80012fca:	6105                	addi	sp,sp,32
    80012fcc:	8082                	ret

0000000080012fce <pci_get_virtio_isr_status>:


// Get the ISR capability for the given virtio device.
volatile struct VirtioPciIsrCfg *pci_get_virtio_isr_status(PCIDevice *device) {
    80012fce:	7179                	addi	sp,sp,-48
    80012fd0:	f406                	sd	ra,40(sp)
    80012fd2:	f022                	sd	s0,32(sp)
    80012fd4:	1800                	addi	s0,sp,48
    80012fd6:	fca43c23          	sd	a0,-40(s0)
    struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_ISR_CFG);
    80012fda:	458d                	li	a1,3
    80012fdc:	fd843503          	ld	a0,-40(s0)
    80012fe0:	995ff0ef          	jal	ra,80012974 <pci_get_virtio_capability>
    80012fe4:	fea43423          	sd	a0,-24(s0)
    debugf("Getting ISR capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uint64_t)vio_cap->offset);
    80012fe8:	fe843783          	ld	a5,-24(s0)
    80012fec:	0047c783          	lbu	a5,4(a5)
    80012ff0:	0007859b          	sext.w	a1,a5
    80012ff4:	fd843783          	ld	a5,-40(s0)
    80012ff8:	6398                	ld	a4,0(a5)
    80012ffa:	fe843783          	ld	a5,-24(s0)
    80012ffe:	0047c783          	lbu	a5,4(a5)
    80013002:	2781                	sext.w	a5,a5
    80013004:	0791                	addi	a5,a5,4
    80013006:	078a                	slli	a5,a5,0x2
    80013008:	97ba                	add	a5,a5,a4
    8001300a:	439c                	lw	a5,0(a5)
    8001300c:	2781                	sext.w	a5,a5
    8001300e:	1782                	slli	a5,a5,0x20
    80013010:	9381                	srli	a5,a5,0x20
    80013012:	ff07f713          	andi	a4,a5,-16
    80013016:	fe843783          	ld	a5,-24(s0)
    8001301a:	479c                	lw	a5,8(a5)
    8001301c:	1782                	slli	a5,a5,0x20
    8001301e:	9381                	srli	a5,a5,0x20
    80013020:	86be                	mv	a3,a5
    80013022:	863a                	mv	a2,a4
    80013024:	00009517          	auipc	a0,0x9
    80013028:	86450513          	addi	a0,a0,-1948 # 8001b888 <pow10.0+0x658>
    8001302c:	5ee020ef          	jal	ra,8001561a <debugf>
    return (volatile struct VirtioPciIsrCfg *)(((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uint64_t)vio_cap->offset);
    80013030:	fd843783          	ld	a5,-40(s0)
    80013034:	6398                	ld	a4,0(a5)
    80013036:	fe843783          	ld	a5,-24(s0)
    8001303a:	0047c783          	lbu	a5,4(a5)
    8001303e:	2781                	sext.w	a5,a5
    80013040:	0791                	addi	a5,a5,4
    80013042:	078a                	slli	a5,a5,0x2
    80013044:	97ba                	add	a5,a5,a4
    80013046:	439c                	lw	a5,0(a5)
    80013048:	2781                	sext.w	a5,a5
    8001304a:	1782                	slli	a5,a5,0x20
    8001304c:	9381                	srli	a5,a5,0x20
    8001304e:	ff07f713          	andi	a4,a5,-16
    80013052:	fe843783          	ld	a5,-24(s0)
    80013056:	479c                	lw	a5,8(a5)
    80013058:	1782                	slli	a5,a5,0x20
    8001305a:	9381                	srli	a5,a5,0x20
    8001305c:	97ba                	add	a5,a5,a4
    // return vio_cap;
}
    8001305e:	853e                	mv	a0,a5
    80013060:	70a2                	ld	ra,40(sp)
    80013062:	7402                	ld	s0,32(sp)
    80013064:	6145                	addi	sp,sp,48
    80013066:	8082                	ret

0000000080013068 <pci_get_ecam>:

static volatile struct pci_ecam *pci_get_ecam(uint8_t bus,
                                              uint8_t device,
                                              uint8_t function,
                                              uint16_t reg) 
{
    80013068:	715d                	addi	sp,sp,-80
    8001306a:	e486                	sd	ra,72(sp)
    8001306c:	e0a2                	sd	s0,64(sp)
    8001306e:	0880                	addi	s0,sp,80
    80013070:	87aa                	mv	a5,a0
    80013072:	8736                	mv	a4,a3
    80013074:	faf40fa3          	sb	a5,-65(s0)
    80013078:	87ae                	mv	a5,a1
    8001307a:	faf40f23          	sb	a5,-66(s0)
    8001307e:	87b2                	mv	a5,a2
    80013080:	faf40ea3          	sb	a5,-67(s0)
    80013084:	87ba                	mv	a5,a4
    80013086:	faf41d23          	sh	a5,-70(s0)
    // Since we're shifting, we need to make sure we
    // have enough space to shift into.
    uint64_t bus64 = bus & 0xff;
    8001308a:	fbf44783          	lbu	a5,-65(s0)
    8001308e:	fef43423          	sd	a5,-24(s0)
    uint64_t device64 = device & 0x1f;
    80013092:	fbe44783          	lbu	a5,-66(s0)
    80013096:	8bfd                	andi	a5,a5,31
    80013098:	fef43023          	sd	a5,-32(s0)
    uint64_t function64 = function & 0x7;
    8001309c:	fbd44783          	lbu	a5,-67(s0)
    800130a0:	8b9d                	andi	a5,a5,7
    800130a2:	fcf43c23          	sd	a5,-40(s0)
    uint64_t reg64 = reg & 0x3ff; 
    800130a6:	fba45783          	lhu	a5,-70(s0)
    800130aa:	3ff7f793          	andi	a5,a5,1023
    800130ae:	fcf43823          	sd	a5,-48(s0)
    
    // Finally, put the address together
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    800130b2:	fe843783          	ld	a5,-24(s0)
    800130b6:	01479713          	slli	a4,a5,0x14
                     (device64 << 15) |   // device number A[19:15]
    800130ba:	fe043783          	ld	a5,-32(s0)
    800130be:	07be                	slli	a5,a5,0xf
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    800130c0:	8f5d                	or	a4,a4,a5
                     (function64 << 12) | // function number A[14:12]
    800130c2:	fd843783          	ld	a5,-40(s0)
    800130c6:	07b2                	slli	a5,a5,0xc
                     (device64 << 15) |   // device number A[19:15]
    800130c8:	8f5d                	or	a4,a4,a5
                     (reg64 << 2));       // register number A[11:2]
    800130ca:	fd043783          	ld	a5,-48(s0)
    800130ce:	078a                	slli	a5,a5,0x2
                     (function64 << 12) | // function number A[14:12]
    800130d0:	8f5d                	or	a4,a4,a5
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
    800130d2:	300007b7          	lui	a5,0x30000
    800130d6:	8fd9                	or	a5,a5,a4
    800130d8:	fcf43423          	sd	a5,-56(s0)
        
    if (addr < PCIE_ECAM_BASE || addr > PCIE_ECAM_END) {
    800130dc:	fc843703          	ld	a4,-56(s0)
    800130e0:	300007b7          	lui	a5,0x30000
    800130e4:	00f76863          	bltu	a4,a5,800130f4 <pci_get_ecam+0x8c>
    800130e8:	fc843703          	ld	a4,-56(s0)
    800130ec:	400007b7          	lui	a5,0x40000
    800130f0:	00f76c63          	bltu	a4,a5,80013108 <pci_get_ecam+0xa0>
        fatalf("pci_get_ecam: PCI address (0x%08x) out of bounds!\n", addr);
    800130f4:	fc843583          	ld	a1,-56(s0)
    800130f8:	00008517          	auipc	a0,0x8
    800130fc:	7c850513          	addi	a0,a0,1992 # 8001b8c0 <pow10.0+0x690>
    80013100:	570020ef          	jal	ra,80015670 <fatalf>
        return 0; 
    80013104:	4781                	li	a5,0
    80013106:	a019                	j	8001310c <pci_get_ecam+0xa4>
    }
    return (struct pci_ecam *)addr;
    80013108:	fc843783          	ld	a5,-56(s0)
}
    8001310c:	853e                	mv	a0,a5
    8001310e:	60a6                	ld	ra,72(sp)
    80013110:	6406                	ld	s0,64(sp)
    80013112:	6161                	addi	sp,sp,80
    80013114:	8082                	ret

0000000080013116 <pci_enumerate_bus>:

static uint64_t next_mmio_address;
static uint8_t subordinate = 1;

static void pci_enumerate_bus() 
{
    80013116:	1101                	addi	sp,sp,-32
    80013118:	ec06                	sd	ra,24(sp)
    8001311a:	e822                	sd	s0,16(sp)
    8001311c:	1000                	addi	s0,sp,32
    for (int bus = 0; bus < 256; bus++) {
    8001311e:	fe042623          	sw	zero,-20(s0)
    80013122:	a0f9                	j	800131f0 <pci_enumerate_bus+0xda>
        for (int device = 0; device < 32; device++) {
    80013124:	fe042423          	sw	zero,-24(s0)
    80013128:	a845                	j	800131d8 <pci_enumerate_bus+0xc2>
            volatile struct pci_ecam *ecam = pci_get_ecam(bus, device, 0, 0);
    8001312a:	fec42783          	lw	a5,-20(s0)
    8001312e:	0ff7f793          	andi	a5,a5,255
    80013132:	fe842703          	lw	a4,-24(s0)
    80013136:	0ff77713          	andi	a4,a4,255
    8001313a:	4681                	li	a3,0
    8001313c:	4601                	li	a2,0
    8001313e:	85ba                	mv	a1,a4
    80013140:	853e                	mv	a0,a5
    80013142:	f27ff0ef          	jal	ra,80013068 <pci_get_ecam>
    80013146:	fea43023          	sd	a0,-32(s0)

            if (!pci_device_exists(ecam->vendor_id)) {
    8001314a:	fe043783          	ld	a5,-32(s0)
    8001314e:	0007d783          	lhu	a5,0(a5) # 40000000 <i+0x3fffffe0>
    80013152:	17c2                	slli	a5,a5,0x30
    80013154:	93c1                	srli	a5,a5,0x30
    80013156:	853e                	mv	a0,a5
    80013158:	df0ff0ef          	jal	ra,80012748 <pci_device_exists>
    8001315c:	87aa                	mv	a5,a0
    8001315e:	0017c793          	xori	a5,a5,1
    80013162:	0ff7f793          	andi	a5,a5,255
    80013166:	e3bd                	bnez	a5,800131cc <pci_enumerate_bus+0xb6>
                // debugf("pci_enumerate_bus: No device found at bus %d, device %d\n", bus, device);
                continue;
            }

            if ((ecam->header_type & 0x7F) == 1) {
    80013168:	fe043783          	ld	a5,-32(s0)
    8001316c:	00e7c783          	lbu	a5,14(a5)
    80013170:	0ff7f793          	andi	a5,a5,255
    80013174:	2781                	sext.w	a5,a5
    80013176:	07f7f793          	andi	a5,a5,127
    8001317a:	2781                	sext.w	a5,a5
    8001317c:	873e                	mv	a4,a5
    8001317e:	4785                	li	a5,1
    80013180:	00f71c63          	bne	a4,a5,80013198 <pci_enumerate_bus+0x82>
                // debugf("pci_enumerate_bus: Found bridge at bus %d, device %d, \n", bus, device);
                pci_configure_bridge(ecam, bus);
    80013184:	fec42783          	lw	a5,-20(s0)
    80013188:	0ff7f793          	andi	a5,a5,255
    8001318c:	85be                	mv	a1,a5
    8001318e:	fe043503          	ld	a0,-32(s0)
    80013192:	07a000ef          	jal	ra,8001320c <pci_configure_bridge>
    80013196:	a825                	j	800131ce <pci_enumerate_bus+0xb8>
            } else if ((ecam->header_type & 0x7F) == 0) {
    80013198:	fe043783          	ld	a5,-32(s0)
    8001319c:	00e7c783          	lbu	a5,14(a5)
    800131a0:	0ff7f793          	andi	a5,a5,255
    800131a4:	2781                	sext.w	a5,a5
    800131a6:	07f7f793          	andi	a5,a5,127
    800131aa:	2781                	sext.w	a5,a5
    800131ac:	e38d                	bnez	a5,800131ce <pci_enumerate_bus+0xb8>
                // debugf("pci_enumerate_bus: Found device at bus %d, device %d, \n", bus, device);
                pci_configure_device(ecam, bus, device);
    800131ae:	fec42783          	lw	a5,-20(s0)
    800131b2:	0ff7f793          	andi	a5,a5,255
    800131b6:	fe842703          	lw	a4,-24(s0)
    800131ba:	0ff77713          	andi	a4,a4,255
    800131be:	863a                	mv	a2,a4
    800131c0:	85be                	mv	a1,a5
    800131c2:	fe043503          	ld	a0,-32(s0)
    800131c6:	190000ef          	jal	ra,80013356 <pci_configure_device>
    800131ca:	a011                	j	800131ce <pci_enumerate_bus+0xb8>
                continue;
    800131cc:	0001                	nop
        for (int device = 0; device < 32; device++) {
    800131ce:	fe842783          	lw	a5,-24(s0)
    800131d2:	2785                	addiw	a5,a5,1
    800131d4:	fef42423          	sw	a5,-24(s0)
    800131d8:	fe842783          	lw	a5,-24(s0)
    800131dc:	0007871b          	sext.w	a4,a5
    800131e0:	47fd                	li	a5,31
    800131e2:	f4e7d4e3          	bge	a5,a4,8001312a <pci_enumerate_bus+0x14>
    for (int bus = 0; bus < 256; bus++) {
    800131e6:	fec42783          	lw	a5,-20(s0)
    800131ea:	2785                	addiw	a5,a5,1
    800131ec:	fef42623          	sw	a5,-20(s0)
    800131f0:	fec42783          	lw	a5,-20(s0)
    800131f4:	0007871b          	sext.w	a4,a5
    800131f8:	0ff00793          	li	a5,255
    800131fc:	f2e7d4e3          	bge	a5,a4,80013124 <pci_enumerate_bus+0xe>
                // PCIDevice *device = pci_find_saved_device(ecam->vendor_id, ecam->device_id);
                // print_vendor_specific_capabilities(device);
            }
        }
    }
}
    80013200:	0001                	nop
    80013202:	0001                	nop
    80013204:	60e2                	ld	ra,24(sp)
    80013206:	6442                	ld	s0,16(sp)
    80013208:	6105                	addi	sp,sp,32
    8001320a:	8082                	ret

000000008001320c <pci_configure_bridge>:


static void pci_configure_bridge(volatile struct pci_ecam *bridge, uint8_t bus_no)
{
    8001320c:	7179                	addi	sp,sp,-48
    8001320e:	f422                	sd	s0,40(sp)
    80013210:	1800                	addi	s0,sp,48
    80013212:	fca43c23          	sd	a0,-40(s0)
    80013216:	87ae                	mv	a5,a1
    80013218:	fcf40ba3          	sb	a5,-41(s0)
    next_mmio_address += 0x01000000;
    */

    // Make sure to set the bus master (2) and memory space (1) bits and clear
    // I/O space bit (0) before configuring the bridges
    bridge->command_reg |= COMMAND_REG_BUSMASTER;
    8001321c:	fd843783          	ld	a5,-40(s0)
    80013220:	0047d783          	lhu	a5,4(a5)
    80013224:	17c2                	slli	a5,a5,0x30
    80013226:	93c1                	srli	a5,a5,0x30
    80013228:	0047e793          	ori	a5,a5,4
    8001322c:	03079713          	slli	a4,a5,0x30
    80013230:	9341                	srli	a4,a4,0x30
    80013232:	fd843783          	ld	a5,-40(s0)
    80013236:	00e79223          	sh	a4,4(a5)
    bridge->command_reg |= COMMAND_REG_MMIO;
    8001323a:	fd843783          	ld	a5,-40(s0)
    8001323e:	0047d783          	lhu	a5,4(a5)
    80013242:	17c2                	slli	a5,a5,0x30
    80013244:	93c1                	srli	a5,a5,0x30
    80013246:	0027e793          	ori	a5,a5,2
    8001324a:	03079713          	slli	a4,a5,0x30
    8001324e:	9341                	srli	a4,a4,0x30
    80013250:	fd843783          	ld	a5,-40(s0)
    80013254:	00e79223          	sh	a4,4(a5)
    bridge->command_reg &= ~COMMAND_REG_PIO;
    80013258:	fd843783          	ld	a5,-40(s0)
    8001325c:	0047d783          	lhu	a5,4(a5)
    80013260:	17c2                	slli	a5,a5,0x30
    80013262:	93c1                	srli	a5,a5,0x30
    80013264:	9bf9                	andi	a5,a5,-2
    80013266:	03079713          	slli	a4,a5,0x30
    8001326a:	9341                	srli	a4,a4,0x30
    8001326c:	fd843783          	ld	a5,-40(s0)
    80013270:	00e79223          	sh	a4,4(a5)

    uint64_t addrst = 0x40000000 | ((uint64_t)subordinate << 20);
    80013274:	0000b797          	auipc	a5,0xb
    80013278:	d8c78793          	addi	a5,a5,-628 # 8001e000 <subordinate>
    8001327c:	0007c783          	lbu	a5,0(a5)
    80013280:	01479713          	slli	a4,a5,0x14
    80013284:	400007b7          	lui	a5,0x40000
    80013288:	8fd9                	or	a5,a5,a4
    8001328a:	fef43423          	sd	a5,-24(s0)
    uint64_t addred = addrst + ((1 << 20) - 1);
    8001328e:	fe843703          	ld	a4,-24(s0)
    80013292:	001007b7          	lui	a5,0x100
    80013296:	17fd                	addi	a5,a5,-1
    80013298:	97ba                	add	a5,a5,a4
    8001329a:	fef43023          	sd	a5,-32(s0)
    next_mmio_address = addrst;
    8001329e:	00007797          	auipc	a5,0x7
    800132a2:	dc278793          	addi	a5,a5,-574 # 8001a060 <next_mmio_address>
    800132a6:	fe843703          	ld	a4,-24(s0)
    800132aa:	e398                	sd	a4,0(a5)
    
    bridge->type1.memory_base = addrst >> 16;
    800132ac:	fe843783          	ld	a5,-24(s0)
    800132b0:	83c1                	srli	a5,a5,0x10
    800132b2:	03079713          	slli	a4,a5,0x30
    800132b6:	9341                	srli	a4,a4,0x30
    800132b8:	fd843783          	ld	a5,-40(s0)
    800132bc:	02e79023          	sh	a4,32(a5)
    bridge->type1.memory_limit = addred >> 16;
    800132c0:	fe043783          	ld	a5,-32(s0)
    800132c4:	83c1                	srli	a5,a5,0x10
    800132c6:	03079713          	slli	a4,a5,0x30
    800132ca:	9341                	srli	a4,a4,0x30
    800132cc:	fd843783          	ld	a5,-40(s0)
    800132d0:	02e79123          	sh	a4,34(a5)
    bridge->type1.prefetch_memory_base = addrst >> 16;
    800132d4:	fe843783          	ld	a5,-24(s0)
    800132d8:	83c1                	srli	a5,a5,0x10
    800132da:	03079713          	slli	a4,a5,0x30
    800132de:	9341                	srli	a4,a4,0x30
    800132e0:	fd843783          	ld	a5,-40(s0)
    800132e4:	02e79223          	sh	a4,36(a5)
    bridge->type1.prefetch_memory_limit = addred >> 16;
    800132e8:	fe043783          	ld	a5,-32(s0)
    800132ec:	83c1                	srli	a5,a5,0x10
    800132ee:	03079713          	slli	a4,a5,0x30
    800132f2:	9341                	srli	a4,a4,0x30
    800132f4:	fd843783          	ld	a5,-40(s0)
    800132f8:	02e79323          	sh	a4,38(a5)
    bridge->type1.primary_bus_no = bus_no;
    800132fc:	fd843783          	ld	a5,-40(s0)
    80013300:	fd744703          	lbu	a4,-41(s0)
    80013304:	00e78c23          	sb	a4,24(a5)
    bridge->type1.secondary_bus_no = subordinate;
    80013308:	0000b797          	auipc	a5,0xb
    8001330c:	cf878793          	addi	a5,a5,-776 # 8001e000 <subordinate>
    80013310:	0007c703          	lbu	a4,0(a5)
    80013314:	fd843783          	ld	a5,-40(s0)
    80013318:	00e78ca3          	sb	a4,25(a5)
    bridge->type1.subordinate_bus_no = subordinate;
    8001331c:	0000b797          	auipc	a5,0xb
    80013320:	ce478793          	addi	a5,a5,-796 # 8001e000 <subordinate>
    80013324:	0007c703          	lbu	a4,0(a5)
    80013328:	fd843783          	ld	a5,-40(s0)
    8001332c:	00e78d23          	sb	a4,26(a5)
    subordinate += 1;
    80013330:	0000b797          	auipc	a5,0xb
    80013334:	cd078793          	addi	a5,a5,-816 # 8001e000 <subordinate>
    80013338:	0007c783          	lbu	a5,0(a5)
    8001333c:	2785                	addiw	a5,a5,1
    8001333e:	0ff7f713          	andi	a4,a5,255
    80013342:	0000b797          	auipc	a5,0xb
    80013346:	cbe78793          	addi	a5,a5,-834 # 8001e000 <subordinate>
    8001334a:	00e78023          	sb	a4,0(a5)
}
    8001334e:	0001                	nop
    80013350:	7422                	ld	s0,40(sp)
    80013352:	6145                	addi	sp,sp,48
    80013354:	8082                	ret

0000000080013356 <pci_configure_device>:

static void pci_configure_device(volatile struct pci_ecam *device, uint8_t bus_no, uint8_t device_no)
{
    80013356:	7171                	addi	sp,sp,-176
    80013358:	f506                	sd	ra,168(sp)
    8001335a:	f122                	sd	s0,160(sp)
    8001335c:	1900                	addi	s0,sp,176
    8001335e:	f8a43c23          	sd	a0,-104(s0)
    80013362:	87ae                	mv	a5,a1
    80013364:	8732                	mv	a4,a2
    80013366:	f8f40ba3          	sb	a5,-105(s0)
    8001336a:	87ba                	mv	a5,a4
    8001336c:	f8f40b23          	sb	a5,-106(s0)
    // uint32_t vector_idx = (bus + slot) % 4;
    // debugf("Pushing device at bus %d, slot %d into vector %d\n", bus, slot, vector_idx);
    // vector_push(all_pci_devices, (uint64_t)device);
    // vector_push(irq_pci_devices[vector_idx], (uint64_t)device);

    debugf("pci_configure_device: At bus %d, device %d = (%p)\n", bus_no, device_no, device);
    80013370:	f9744783          	lbu	a5,-105(s0)
    80013374:	2781                	sext.w	a5,a5
    80013376:	f9644703          	lbu	a4,-106(s0)
    8001337a:	2701                	sext.w	a4,a4
    8001337c:	f9843683          	ld	a3,-104(s0)
    80013380:	863a                	mv	a2,a4
    80013382:	85be                	mv	a1,a5
    80013384:	00008517          	auipc	a0,0x8
    80013388:	57450513          	addi	a0,a0,1396 # 8001b8f8 <pow10.0+0x6c8>
    8001338c:	28e020ef          	jal	ra,8001561a <debugf>

    // Disable the device before modifying the BAR
    device->command_reg &= ~COMMAND_REG_MMIO; // Clear memory space bit
    80013390:	f9843783          	ld	a5,-104(s0)
    80013394:	0047d783          	lhu	a5,4(a5)
    80013398:	17c2                	slli	a5,a5,0x30
    8001339a:	93c1                	srli	a5,a5,0x30
    8001339c:	9bf5                	andi	a5,a5,-3
    8001339e:	03079713          	slli	a4,a5,0x30
    800133a2:	9341                	srli	a4,a4,0x30
    800133a4:	f9843783          	ld	a5,-104(s0)
    800133a8:	00e79223          	sh	a4,4(a5)
    device->command_reg &= ~COMMAND_REG_PIO; // Clear I/O space bit
    800133ac:	f9843783          	ld	a5,-104(s0)
    800133b0:	0047d783          	lhu	a5,4(a5)
    800133b4:	17c2                	slli	a5,a5,0x30
    800133b6:	93c1                	srli	a5,a5,0x30
    800133b8:	9bf9                	andi	a5,a5,-2
    800133ba:	03079713          	slli	a4,a5,0x30
    800133be:	9341                	srli	a4,a4,0x30
    800133c0:	f9843783          	ld	a5,-104(s0)
    800133c4:	00e79223          	sh	a4,4(a5)

    uint32_t addr = PCIE_MMIO_BASE + (bus_no << 20) + (device_no << 16);
    800133c8:	f9744783          	lbu	a5,-105(s0)
    800133cc:	2781                	sext.w	a5,a5
    800133ce:	0147979b          	slliw	a5,a5,0x14
    800133d2:	0007871b          	sext.w	a4,a5
    800133d6:	400007b7          	lui	a5,0x40000
    800133da:	9fb9                	addw	a5,a5,a4
    800133dc:	0007871b          	sext.w	a4,a5
    800133e0:	f9644783          	lbu	a5,-106(s0)
    800133e4:	2781                	sext.w	a5,a5
    800133e6:	0107979b          	slliw	a5,a5,0x10
    800133ea:	2781                	sext.w	a5,a5
    800133ec:	9fb9                	addw	a5,a5,a4
    800133ee:	2781                	sext.w	a5,a5
    800133f0:	fef42623          	sw	a5,-20(s0)
    PCIDevice pcidev;
    pcidev.ecam_header = device;
    800133f4:	f9843783          	ld	a5,-104(s0)
    800133f8:	faf43023          	sd	a5,-96(s0)
    
    for (int i = 0; i < 6; i++) {
    800133fc:	fe042423          	sw	zero,-24(s0)
    80013400:	a4b9                	j	8001364e <pci_configure_device+0x2f8>
        device->type0.bar[i] = -1U;
    80013402:	f9843703          	ld	a4,-104(s0)
    80013406:	fe842783          	lw	a5,-24(s0)
    8001340a:	0791                	addi	a5,a5,4
    8001340c:	078a                	slli	a5,a5,0x2
    8001340e:	97ba                	add	a5,a5,a4
    80013410:	577d                	li	a4,-1
    80013412:	c398                	sw	a4,0(a5)
        pcidev.bars[i] = NULL;
    80013414:	fe842783          	lw	a5,-24(s0)
    80013418:	078e                	slli	a5,a5,0x3
    8001341a:	ff040713          	addi	a4,s0,-16
    8001341e:	97ba                	add	a5,a5,a4
    80013420:	fa07bc23          	sd	zero,-72(a5) # 3fffffb8 <i+0x3fffff98>
        
        // BAR not writable
        if (device->type0.bar[i] == 0) {
    80013424:	f9843703          	ld	a4,-104(s0)
    80013428:	fe842783          	lw	a5,-24(s0)
    8001342c:	0791                	addi	a5,a5,4
    8001342e:	078a                	slli	a5,a5,0x2
    80013430:	97ba                	add	a5,a5,a4
    80013432:	439c                	lw	a5,0(a5)
    80013434:	2781                	sext.w	a5,a5
    80013436:	20078663          	beqz	a5,80013642 <pci_configure_device+0x2ec>
            continue;
        }

        uint64_t size;

        if ((device->type0.bar[i] & 0x6) == 0x4) {
    8001343a:	f9843703          	ld	a4,-104(s0)
    8001343e:	fe842783          	lw	a5,-24(s0)
    80013442:	0791                	addi	a5,a5,4
    80013444:	078a                	slli	a5,a5,0x2
    80013446:	97ba                	add	a5,a5,a4
    80013448:	439c                	lw	a5,0(a5)
    8001344a:	2781                	sext.w	a5,a5
    8001344c:	8b99                	andi	a5,a5,6
    8001344e:	2781                	sext.w	a5,a5
    80013450:	873e                	mv	a4,a5
    80013452:	4791                	li	a5,4
    80013454:	16f71263          	bne	a4,a5,800135b8 <pci_configure_device+0x262>
            debugf("  BAR[%d] is 64-bit\n", i);
    80013458:	fe842783          	lw	a5,-24(s0)
    8001345c:	85be                	mv	a1,a5
    8001345e:	00008517          	auipc	a0,0x8
    80013462:	4d250513          	addi	a0,a0,1234 # 8001b930 <pow10.0+0x700>
    80013466:	1b4020ef          	jal	ra,8001561a <debugf>
            device->type0.bar[i+1] = -1U;
    8001346a:	fe842783          	lw	a5,-24(s0)
    8001346e:	2785                	addiw	a5,a5,1
    80013470:	2781                	sext.w	a5,a5
    80013472:	f9843703          	ld	a4,-104(s0)
    80013476:	0791                	addi	a5,a5,4
    80013478:	078a                	slli	a5,a5,0x2
    8001347a:	97ba                	add	a5,a5,a4
    8001347c:	577d                	li	a4,-1
    8001347e:	c398                	sw	a4,0(a5)
            uint64_t bar_value = (uint64_t) device->type0.bar[i+1] << 32 | device->type0.bar[i];
    80013480:	fe842783          	lw	a5,-24(s0)
    80013484:	2785                	addiw	a5,a5,1
    80013486:	2781                	sext.w	a5,a5
    80013488:	f9843703          	ld	a4,-104(s0)
    8001348c:	0791                	addi	a5,a5,4
    8001348e:	078a                	slli	a5,a5,0x2
    80013490:	97ba                	add	a5,a5,a4
    80013492:	439c                	lw	a5,0(a5)
    80013494:	2781                	sext.w	a5,a5
    80013496:	1782                	slli	a5,a5,0x20
    80013498:	9381                	srli	a5,a5,0x20
    8001349a:	02079713          	slli	a4,a5,0x20
    8001349e:	f9843683          	ld	a3,-104(s0)
    800134a2:	fe842783          	lw	a5,-24(s0)
    800134a6:	0791                	addi	a5,a5,4
    800134a8:	078a                	slli	a5,a5,0x2
    800134aa:	97b6                	add	a5,a5,a3
    800134ac:	439c                	lw	a5,0(a5)
    800134ae:	2781                	sext.w	a5,a5
    800134b0:	1782                	slli	a5,a5,0x20
    800134b2:	9381                	srli	a5,a5,0x20
    800134b4:	8fd9                	or	a5,a5,a4
    800134b6:	fcf43c23          	sd	a5,-40(s0)
            size = ~(bar_value & ~0xF) + 1;
    800134ba:	fd843783          	ld	a5,-40(s0)
    800134be:	9bc1                	andi	a5,a5,-16
    800134c0:	40f007b3          	neg	a5,a5
    800134c4:	fef43023          	sd	a5,-32(s0)
            addr += size;
    800134c8:	fe043783          	ld	a5,-32(s0)
    800134cc:	2781                	sext.w	a5,a5
    800134ce:	fec42703          	lw	a4,-20(s0)
    800134d2:	9fb9                	addw	a5,a5,a4
    800134d4:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    800134d8:	f9843703          	ld	a4,-104(s0)
    800134dc:	fe842783          	lw	a5,-24(s0)
    800134e0:	0791                	addi	a5,a5,4
    800134e2:	078a                	slli	a5,a5,0x2
    800134e4:	97ba                	add	a5,a5,a4
    800134e6:	fec42703          	lw	a4,-20(s0)
    800134ea:	c398                	sw	a4,0(a5)
            device->type0.bar[i+1] = 0;
    800134ec:	fe842783          	lw	a5,-24(s0)
    800134f0:	2785                	addiw	a5,a5,1
    800134f2:	2781                	sext.w	a5,a5
    800134f4:	f9843703          	ld	a4,-104(s0)
    800134f8:	0791                	addi	a5,a5,4
    800134fa:	078a                	slli	a5,a5,0x2
    800134fc:	97ba                	add	a5,a5,a4
    800134fe:	0007a023          	sw	zero,0(a5)
            pcidev.bars[i] = device->type0.bar[i] & ~0xf;
    80013502:	f9843703          	ld	a4,-104(s0)
    80013506:	fe842783          	lw	a5,-24(s0)
    8001350a:	0791                	addi	a5,a5,4
    8001350c:	078a                	slli	a5,a5,0x2
    8001350e:	97ba                	add	a5,a5,a4
    80013510:	439c                	lw	a5,0(a5)
    80013512:	2781                	sext.w	a5,a5
    80013514:	02079713          	slli	a4,a5,0x20
    80013518:	9301                	srli	a4,a4,0x20
    8001351a:	4785                	li	a5,1
    8001351c:	1782                	slli	a5,a5,0x20
    8001351e:	17c1                	addi	a5,a5,-16
    80013520:	8ff9                	and	a5,a5,a4
    80013522:	873e                	mv	a4,a5
    80013524:	fe842783          	lw	a5,-24(s0)
    80013528:	078e                	slli	a5,a5,0x3
    8001352a:	ff040693          	addi	a3,s0,-16
    8001352e:	97b6                	add	a5,a5,a3
    80013530:	fae7bc23          	sd	a4,-72(a5)
            pcidev.bars[i+1] = 0;
    80013534:	fe842783          	lw	a5,-24(s0)
    80013538:	2785                	addiw	a5,a5,1
    8001353a:	2781                	sext.w	a5,a5
    8001353c:	078e                	slli	a5,a5,0x3
    8001353e:	ff040713          	addi	a4,s0,-16
    80013542:	97ba                	add	a5,a5,a4
    80013544:	fa07bc23          	sd	zero,-72(a5)
            // pcidev.bars[i+1] = 0;
            debugf("    device->type0.bar[i] == 0x%08x\n", device->type0.bar[i]);
    80013548:	f9843703          	ld	a4,-104(s0)
    8001354c:	fe842783          	lw	a5,-24(s0)
    80013550:	0791                	addi	a5,a5,4
    80013552:	078a                	slli	a5,a5,0x2
    80013554:	97ba                	add	a5,a5,a4
    80013556:	439c                	lw	a5,0(a5)
    80013558:	2781                	sext.w	a5,a5
    8001355a:	85be                	mv	a1,a5
    8001355c:	00008517          	auipc	a0,0x8
    80013560:	3ec50513          	addi	a0,a0,1004 # 8001b948 <pow10.0+0x718>
    80013564:	0b6020ef          	jal	ra,8001561a <debugf>
            debugf("    device->type0.bar[i+1] == 0x%08x\n", device->type0.bar[i+1]);
    80013568:	fe842783          	lw	a5,-24(s0)
    8001356c:	2785                	addiw	a5,a5,1
    8001356e:	2781                	sext.w	a5,a5
    80013570:	f9843703          	ld	a4,-104(s0)
    80013574:	0791                	addi	a5,a5,4
    80013576:	078a                	slli	a5,a5,0x2
    80013578:	97ba                	add	a5,a5,a4
    8001357a:	439c                	lw	a5,0(a5)
    8001357c:	2781                	sext.w	a5,a5
    8001357e:	85be                	mv	a1,a5
    80013580:	00008517          	auipc	a0,0x8
    80013584:	3f050513          	addi	a0,a0,1008 # 8001b970 <pow10.0+0x740>
    80013588:	092020ef          	jal	ra,8001561a <debugf>
            debugf("    bar_value == 0x%016llx\n", bar_value);
    8001358c:	fd843583          	ld	a1,-40(s0)
    80013590:	00008517          	auipc	a0,0x8
    80013594:	40850513          	addi	a0,a0,1032 # 8001b998 <pow10.0+0x768>
    80013598:	082020ef          	jal	ra,8001561a <debugf>
            debugf("    size == %016llx\n", size);
    8001359c:	fe043583          	ld	a1,-32(s0)
    800135a0:	00008517          	auipc	a0,0x8
    800135a4:	41850513          	addi	a0,a0,1048 # 8001b9b8 <pow10.0+0x788>
    800135a8:	072020ef          	jal	ra,8001561a <debugf>
            ++i;
    800135ac:	fe842783          	lw	a5,-24(s0)
    800135b0:	2785                	addiw	a5,a5,1
    800135b2:	fef42423          	sw	a5,-24(s0)
    800135b6:	a079                	j	80013644 <pci_configure_device+0x2ee>
        } else {
            debugf("  BAR[%d] is 32-bit\n", i);
    800135b8:	fe842783          	lw	a5,-24(s0)
    800135bc:	85be                	mv	a1,a5
    800135be:	00008517          	auipc	a0,0x8
    800135c2:	41250513          	addi	a0,a0,1042 # 8001b9d0 <pow10.0+0x7a0>
    800135c6:	054020ef          	jal	ra,8001561a <debugf>
            size = ~(device->type0.bar[i] & ~0xF) + 1;
    800135ca:	f9843703          	ld	a4,-104(s0)
    800135ce:	fe842783          	lw	a5,-24(s0)
    800135d2:	0791                	addi	a5,a5,4
    800135d4:	078a                	slli	a5,a5,0x2
    800135d6:	97ba                	add	a5,a5,a4
    800135d8:	439c                	lw	a5,0(a5)
    800135da:	2781                	sext.w	a5,a5
    800135dc:	9bc1                	andi	a5,a5,-16
    800135de:	2781                	sext.w	a5,a5
    800135e0:	40f007bb          	negw	a5,a5
    800135e4:	2781                	sext.w	a5,a5
    800135e6:	1782                	slli	a5,a5,0x20
    800135e8:	9381                	srli	a5,a5,0x20
    800135ea:	fef43023          	sd	a5,-32(s0)
            debugf("    size == %016llx\n", size);
    800135ee:	fe043583          	ld	a1,-32(s0)
    800135f2:	00008517          	auipc	a0,0x8
    800135f6:	3c650513          	addi	a0,a0,966 # 8001b9b8 <pow10.0+0x788>
    800135fa:	020020ef          	jal	ra,8001561a <debugf>
            addr += size;
    800135fe:	fe043783          	ld	a5,-32(s0)
    80013602:	2781                	sext.w	a5,a5
    80013604:	fec42703          	lw	a4,-20(s0)
    80013608:	9fb9                	addw	a5,a5,a4
    8001360a:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    8001360e:	f9843703          	ld	a4,-104(s0)
    80013612:	fe842783          	lw	a5,-24(s0)
    80013616:	0791                	addi	a5,a5,4
    80013618:	078a                	slli	a5,a5,0x2
    8001361a:	97ba                	add	a5,a5,a4
    8001361c:	fec42703          	lw	a4,-20(s0)
    80013620:	c398                	sw	a4,0(a5)
            pcidev.bars[i] = addr & ~0xf;
    80013622:	fec46703          	lwu	a4,-20(s0)
    80013626:	4785                	li	a5,1
    80013628:	1782                	slli	a5,a5,0x20
    8001362a:	17c1                	addi	a5,a5,-16
    8001362c:	8ff9                	and	a5,a5,a4
    8001362e:	873e                	mv	a4,a5
    80013630:	fe842783          	lw	a5,-24(s0)
    80013634:	078e                	slli	a5,a5,0x3
    80013636:	ff040693          	addi	a3,s0,-16
    8001363a:	97b6                	add	a5,a5,a3
    8001363c:	fae7bc23          	sd	a4,-72(a5)
    80013640:	a011                	j	80013644 <pci_configure_device+0x2ee>
            continue;
    80013642:	0001                	nop
    for (int i = 0; i < 6; i++) {
    80013644:	fe842783          	lw	a5,-24(s0)
    80013648:	2785                	addiw	a5,a5,1
    8001364a:	fef42423          	sw	a5,-24(s0)
    8001364e:	fe842783          	lw	a5,-24(s0)
    80013652:	0007871b          	sext.w	a4,a5
    80013656:	4795                	li	a5,5
    80013658:	dae7d5e3          	bge	a5,a4,80013402 <pci_configure_device+0xac>
        }
    }

    // Re-enable the device after modifying the BAR
    device->command_reg |= COMMAND_REG_MMIO;
    8001365c:	f9843783          	ld	a5,-104(s0)
    80013660:	0047d783          	lhu	a5,4(a5)
    80013664:	17c2                	slli	a5,a5,0x30
    80013666:	93c1                	srli	a5,a5,0x30
    80013668:	0027e793          	ori	a5,a5,2
    8001366c:	03079713          	slli	a4,a5,0x30
    80013670:	9341                	srli	a4,a4,0x30
    80013672:	f9843783          	ld	a5,-104(s0)
    80013676:	00e79223          	sh	a4,4(a5)
    pcidev.ecam_header = device;
    8001367a:	f9843783          	ld	a5,-104(s0)
    8001367e:	faf43023          	sd	a5,-96(s0)
    pci_save_device(pcidev);
    80013682:	fa043803          	ld	a6,-96(s0)
    80013686:	fa843503          	ld	a0,-88(s0)
    8001368a:	fb043583          	ld	a1,-80(s0)
    8001368e:	fb843603          	ld	a2,-72(s0)
    80013692:	fc043683          	ld	a3,-64(s0)
    80013696:	fc843703          	ld	a4,-56(s0)
    8001369a:	fd043783          	ld	a5,-48(s0)
    8001369e:	f5043823          	sd	a6,-176(s0)
    800136a2:	f4a43c23          	sd	a0,-168(s0)
    800136a6:	f6b43023          	sd	a1,-160(s0)
    800136aa:	f6c43423          	sd	a2,-152(s0)
    800136ae:	f6d43823          	sd	a3,-144(s0)
    800136b2:	f6e43c23          	sd	a4,-136(s0)
    800136b6:	f8f43023          	sd	a5,-128(s0)
    800136ba:	f5040793          	addi	a5,s0,-176
    800136be:	853e                	mv	a0,a5
    800136c0:	c14ff0ef          	jal	ra,80012ad4 <pci_save_device>
}
    800136c4:	0001                	nop
    800136c6:	70aa                	ld	ra,168(sp)
    800136c8:	740a                	ld	s0,160(sp)
    800136ca:	614d                	addi	sp,sp,176
    800136cc:	8082                	ret

00000000800136ce <print_vendor_specific_capabilities>:

void print_vendor_specific_capabilities(PCIDevice *pcidevice)
{
    800136ce:	7179                	addi	sp,sp,-48
    800136d0:	f406                	sd	ra,40(sp)
    800136d2:	f022                	sd	s0,32(sp)
    800136d4:	1800                	addi	s0,sp,48
    800136d6:	fca43c23          	sd	a0,-40(s0)
    if (!pci_is_virtio_device(pcidevice)) return;
    800136da:	fd843503          	ld	a0,-40(s0)
    800136de:	8a2ff0ef          	jal	ra,80012780 <pci_is_virtio_device>
    800136e2:	87aa                	mv	a5,a0
    800136e4:	0017c793          	xori	a5,a5,1
    800136e8:	0ff7f793          	andi	a5,a5,255
    800136ec:	e7cd                	bnez	a5,80013796 <print_vendor_specific_capabilities+0xc8>
    struct pci_ecam *header = pcidevice->ecam_header;
    800136ee:	fd843783          	ld	a5,-40(s0)
    800136f2:	639c                	ld	a5,0(a5)
    800136f4:	fef43423          	sd	a5,-24(s0)

    uint8_t cap_pointer = header->type0.capes_pointer;
    800136f8:	fe843783          	ld	a5,-24(s0)
    800136fc:	0347c783          	lbu	a5,52(a5)
    80013700:	fef403a3          	sb	a5,-25(s0)
    debugf("Vendor specific capabilities with offset 0x%02x\n", cap_pointer);
    80013704:	fe744783          	lbu	a5,-25(s0)
    80013708:	2781                	sext.w	a5,a5
    8001370a:	85be                	mv	a1,a5
    8001370c:	00008517          	auipc	a0,0x8
    80013710:	2dc50513          	addi	a0,a0,732 # 8001b9e8 <pow10.0+0x7b8>
    80013714:	707010ef          	jal	ra,8001561a <debugf>
    debugf("  Common configuration capability at: 0x%08x\n", pci_get_virtio_common_config(pcidevice));
    80013718:	fd843503          	ld	a0,-40(s0)
    8001371c:	f50ff0ef          	jal	ra,80012e6c <pci_get_virtio_common_config>
    80013720:	87aa                	mv	a5,a0
    80013722:	85be                	mv	a1,a5
    80013724:	00008517          	auipc	a0,0x8
    80013728:	2fc50513          	addi	a0,a0,764 # 8001ba20 <pow10.0+0x7f0>
    8001372c:	6ef010ef          	jal	ra,8001561a <debugf>
    debugf("  Notify configuration capability at: 0x%08x\n", pci_get_virtio_notify_capability(pcidevice));
    80013730:	fd843503          	ld	a0,-40(s0)
    80013734:	fd2ff0ef          	jal	ra,80012f06 <pci_get_virtio_notify_capability>
    80013738:	87aa                	mv	a5,a0
    8001373a:	85be                	mv	a1,a5
    8001373c:	00008517          	auipc	a0,0x8
    80013740:	31450513          	addi	a0,a0,788 # 8001ba50 <pow10.0+0x820>
    80013744:	6d7010ef          	jal	ra,8001561a <debugf>
    debugf("  ISR configuration capability at: 0x%08x\n", pci_get_virtio_isr_status(pcidevice));
    80013748:	fd843503          	ld	a0,-40(s0)
    8001374c:	883ff0ef          	jal	ra,80012fce <pci_get_virtio_isr_status>
    80013750:	87aa                	mv	a5,a0
    80013752:	85be                	mv	a1,a5
    80013754:	00008517          	auipc	a0,0x8
    80013758:	32c50513          	addi	a0,a0,812 # 8001ba80 <pow10.0+0x850>
    8001375c:	6bf010ef          	jal	ra,8001561a <debugf>
    debugf("  Device configuration capability at: 0x%08x\n", pci_get_virtio_capability(pcidevice, 0x04));
    80013760:	4591                	li	a1,4
    80013762:	fd843503          	ld	a0,-40(s0)
    80013766:	a0eff0ef          	jal	ra,80012974 <pci_get_virtio_capability>
    8001376a:	87aa                	mv	a5,a0
    8001376c:	85be                	mv	a1,a5
    8001376e:	00008517          	auipc	a0,0x8
    80013772:	34250513          	addi	a0,a0,834 # 8001bab0 <pow10.0+0x880>
    80013776:	6a5010ef          	jal	ra,8001561a <debugf>
    debugf("  PCI configuration access capability at: 0x%08x\n", pci_get_virtio_capability(pcidevice, 0x05));
    8001377a:	4595                	li	a1,5
    8001377c:	fd843503          	ld	a0,-40(s0)
    80013780:	9f4ff0ef          	jal	ra,80012974 <pci_get_virtio_capability>
    80013784:	87aa                	mv	a5,a0
    80013786:	85be                	mv	a1,a5
    80013788:	00008517          	auipc	a0,0x8
    8001378c:	35850513          	addi	a0,a0,856 # 8001bae0 <pow10.0+0x8b0>
    80013790:	68b010ef          	jal	ra,8001561a <debugf>
    80013794:	a011                	j	80013798 <print_vendor_specific_capabilities+0xca>
    if (!pci_is_virtio_device(pcidevice)) return;
    80013796:	0001                	nop
        }

        cap_pointer = cape->next;  
    }
    */
}
    80013798:	70a2                	ld	ra,40(sp)
    8001379a:	7402                	ld	s0,32(sp)
    8001379c:	6145                	addi	sp,sp,48
    8001379e:	8082                	ret

00000000800137a0 <pci_init>:

void pci_init(void)
{
    800137a0:	1101                	addi	sp,sp,-32
    800137a2:	ec06                	sd	ra,24(sp)
    800137a4:	e822                	sd	s0,16(sp)
    800137a6:	1000                	addi	s0,sp,32
    all_pci_devices = vector_new();
    800137a8:	4dd040ef          	jal	ra,80018484 <vector_new>
    800137ac:	872a                	mv	a4,a0
    800137ae:	00007797          	auipc	a5,0x7
    800137b2:	88a78793          	addi	a5,a5,-1910 # 8001a038 <all_pci_devices>
    800137b6:	e398                	sd	a4,0(a5)
    for (int i=0; i<4; i++) {
    800137b8:	fe042623          	sw	zero,-20(s0)
    800137bc:	a015                	j	800137e0 <pci_init+0x40>
        irq_pci_devices[i] = vector_new();
    800137be:	4c7040ef          	jal	ra,80018484 <vector_new>
    800137c2:	86aa                	mv	a3,a0
    800137c4:	00007717          	auipc	a4,0x7
    800137c8:	87c70713          	addi	a4,a4,-1924 # 8001a040 <irq_pci_devices>
    800137cc:	fec42783          	lw	a5,-20(s0)
    800137d0:	078e                	slli	a5,a5,0x3
    800137d2:	97ba                	add	a5,a5,a4
    800137d4:	e394                	sd	a3,0(a5)
    for (int i=0; i<4; i++) {
    800137d6:	fec42783          	lw	a5,-20(s0)
    800137da:	2785                	addiw	a5,a5,1
    800137dc:	fef42623          	sw	a5,-20(s0)
    800137e0:	fec42783          	lw	a5,-20(s0)
    800137e4:	0007871b          	sext.w	a4,a5
    800137e8:	478d                	li	a5,3
    800137ea:	fce7dae3          	bge	a5,a4,800137be <pci_init+0x1e>
    }

    pci_enumerate_bus();
    800137ee:	929ff0ef          	jal	ra,80013116 <pci_enumerate_bus>

    debugf("PCI devices: %d\n", pci_count_saved_devices());
    800137f2:	a2aff0ef          	jal	ra,80012a1c <pci_count_saved_devices>
    800137f6:	87aa                	mv	a5,a0
    800137f8:	85be                	mv	a1,a5
    800137fa:	00008517          	auipc	a0,0x8
    800137fe:	31e50513          	addi	a0,a0,798 # 8001bb18 <pow10.0+0x8e8>
    80013802:	619010ef          	jal	ra,8001561a <debugf>
    debugf("PCI devices sharing IRQ 32: %d\n", pci_count_irq_listeners(32));
    80013806:	02000513          	li	a0,32
    8001380a:	a3cff0ef          	jal	ra,80012a46 <pci_count_irq_listeners>
    8001380e:	87aa                	mv	a5,a0
    80013810:	85be                	mv	a1,a5
    80013812:	00008517          	auipc	a0,0x8
    80013816:	31e50513          	addi	a0,a0,798 # 8001bb30 <pow10.0+0x900>
    8001381a:	601010ef          	jal	ra,8001561a <debugf>
    debugf("PCI devices sharing IRQ 33: %d\n", pci_count_irq_listeners(33));
    8001381e:	02100513          	li	a0,33
    80013822:	a24ff0ef          	jal	ra,80012a46 <pci_count_irq_listeners>
    80013826:	87aa                	mv	a5,a0
    80013828:	85be                	mv	a1,a5
    8001382a:	00008517          	auipc	a0,0x8
    8001382e:	32650513          	addi	a0,a0,806 # 8001bb50 <pow10.0+0x920>
    80013832:	5e9010ef          	jal	ra,8001561a <debugf>
    debugf("PCI devices sharing IRQ 34: %d\n", pci_count_irq_listeners(34));
    80013836:	02200513          	li	a0,34
    8001383a:	a0cff0ef          	jal	ra,80012a46 <pci_count_irq_listeners>
    8001383e:	87aa                	mv	a5,a0
    80013840:	85be                	mv	a1,a5
    80013842:	00008517          	auipc	a0,0x8
    80013846:	32e50513          	addi	a0,a0,814 # 8001bb70 <pow10.0+0x940>
    8001384a:	5d1010ef          	jal	ra,8001561a <debugf>
    debugf("PCI devices sharing IRQ 35: %d\n", pci_count_irq_listeners(35));
    8001384e:	02300513          	li	a0,35
    80013852:	9f4ff0ef          	jal	ra,80012a46 <pci_count_irq_listeners>
    80013856:	87aa                	mv	a5,a0
    80013858:	85be                	mv	a1,a5
    8001385a:	00008517          	auipc	a0,0x8
    8001385e:	33650513          	addi	a0,a0,822 # 8001bb90 <pow10.0+0x960>
    80013862:	5b9010ef          	jal	ra,8001561a <debugf>
}
    80013866:	0001                	nop
    80013868:	60e2                	ld	ra,24(sp)
    8001386a:	6442                	ld	s0,16(sp)
    8001386c:	6105                	addi	sp,sp,32
    8001386e:	8082                	ret

0000000080013870 <pci_dispatch_irq>:
/**
 * @brief Dispatch an interrupt to the PCI subsystem
 * @param irq - the IRQ number that interrupted
 */
void pci_dispatch_irq(int irq)
{
    80013870:	7179                	addi	sp,sp,-48
    80013872:	f406                	sd	ra,40(sp)
    80013874:	f022                	sd	s0,32(sp)
    80013876:	1800                	addi	s0,sp,48
    80013878:	87aa                	mv	a5,a0
    8001387a:	fcf42e23          	sw	a5,-36(s0)
    // device changed its configuration, and that was the reason
    // the interrupt occurred.

    // IRQ#=32+(bus+slot)mod4
    // uint32_t vector_idx = irq - 32;
    PCIDevice *pcidevice = pci_find_device_by_irq(irq);
    8001387e:	fdc42783          	lw	a5,-36(s0)
    80013882:	0ff7f793          	andi	a5,a5,255
    80013886:	853e                	mv	a0,a5
    80013888:	b78ff0ef          	jal	ra,80012c00 <pci_find_device_by_irq>
    8001388c:	fea43423          	sd	a0,-24(s0)
    if (pcidevice == NULL) {
    80013890:	fe843783          	ld	a5,-24(s0)
    80013894:	eb99                	bnez	a5,800138aa <pci_dispatch_irq+0x3a>
        debugf("No PCI device found with IRQ %d\n", irq);
    80013896:	fdc42783          	lw	a5,-36(s0)
    8001389a:	85be                	mv	a1,a5
    8001389c:	00008517          	auipc	a0,0x8
    800138a0:	31450513          	addi	a0,a0,788 # 8001bbb0 <pow10.0+0x980>
    800138a4:	577010ef          	jal	ra,8001561a <debugf>
        return;
    800138a8:	a8ad                	j	80013922 <pci_dispatch_irq+0xb2>
    }
    debugf("PCI device with IRQ %d: 0x%04x\n", irq, pcidevice->ecam_header->device_id);
    800138aa:	fe843783          	ld	a5,-24(s0)
    800138ae:	639c                	ld	a5,0(a5)
    800138b0:	0027d783          	lhu	a5,2(a5)
    800138b4:	17c2                	slli	a5,a5,0x30
    800138b6:	93c1                	srli	a5,a5,0x30
    800138b8:	0007871b          	sext.w	a4,a5
    800138bc:	fdc42783          	lw	a5,-36(s0)
    800138c0:	863a                	mv	a2,a4
    800138c2:	85be                	mv	a1,a5
    800138c4:	00008517          	auipc	a0,0x8
    800138c8:	31450513          	addi	a0,a0,788 # 8001bbd8 <pow10.0+0x9a8>
    800138cc:	54f010ef          	jal	ra,8001561a <debugf>
    // Is this a virtio device?
    if (pci_is_virtio_device(pcidevice)) { 
    800138d0:	fe843503          	ld	a0,-24(s0)
    800138d4:	eadfe0ef          	jal	ra,80012780 <pci_is_virtio_device>
    800138d8:	87aa                	mv	a5,a0
    800138da:	cf95                	beqz	a5,80013916 <pci_dispatch_irq+0xa6>
        // Access through ecam_header
        VirtioDevice *virtdevice = virtio_get_by_device(pcidevice);
    800138dc:	fe843503          	ld	a0,-24(s0)
    800138e0:	56e020ef          	jal	ra,80015e4e <virtio_get_by_device>
    800138e4:	fea43023          	sd	a0,-32(s0)
        debugf("Virtio device! %p\n", virtdevice->pcidev->ecam_header);
    800138e8:	fe043783          	ld	a5,-32(s0)
    800138ec:	639c                	ld	a5,0(a5)
    800138ee:	639c                	ld	a5,0(a5)
    800138f0:	85be                	mv	a1,a5
    800138f2:	00008517          	auipc	a0,0x8
    800138f6:	30650513          	addi	a0,a0,774 # 8001bbf8 <pow10.0+0x9c8>
    800138fa:	521010ef          	jal	ra,8001561a <debugf>
        
        if (virtio_is_rng_device(virtdevice)) {
    800138fe:	fe043503          	ld	a0,-32(s0)
    80013902:	38c020ef          	jal	ra,80015c8e <virtio_is_rng_device>
    80013906:	87aa                	mv	a5,a0
    80013908:	c799                	beqz	a5,80013916 <pci_dispatch_irq+0xa6>
            debugf("RNG sent interrupt!\n");
    8001390a:	00008517          	auipc	a0,0x8
    8001390e:	30650513          	addi	a0,a0,774 # 8001bc10 <pow10.0+0x9e0>
    80013912:	509010ef          	jal	ra,8001561a <debugf>
        }
    }

    debugf("Leaving dispatch IRQ\n");
    80013916:	00008517          	auipc	a0,0x8
    8001391a:	31250513          	addi	a0,a0,786 # 8001bc28 <pow10.0+0x9f8>
    8001391e:	4fd010ef          	jal	ra,8001561a <debugf>
}
    80013922:	70a2                	ld	ra,40(sp)
    80013924:	7402                	ld	s0,32(sp)
    80013926:	6145                	addi	sp,sp,48
    80013928:	8082                	ret

000000008001392a <mutex_trylock>:
#include <config.h>
#include <lock.h>
#include <compiler.h>

bool mutex_trylock(Mutex *mutex)
{
    8001392a:	7179                	addi	sp,sp,-48
    8001392c:	f422                	sd	s0,40(sp)
    8001392e:	1800                	addi	s0,sp,48
    80013930:	fca43c23          	sd	a0,-40(s0)
    int old;
    asm volatile("amoswap.w.aq %0, %1, (%2)" : "=r"(old) : "r"(MUTEX_LOCKED), "r"(mutex));
    80013934:	4785                	li	a5,1
    80013936:	fd843703          	ld	a4,-40(s0)
    8001393a:	0cf727af          	amoswap.w.aq	a5,a5,(a4)
    8001393e:	fef42623          	sw	a5,-20(s0)
    // If old == MUTEX_LOCKED, that means the mutex was already
    // locked when we tried to lock it. That means we didn't acquire
    // it.
    return old != MUTEX_LOCKED;
    80013942:	fec42783          	lw	a5,-20(s0)
    80013946:	0007871b          	sext.w	a4,a5
    8001394a:	4785                	li	a5,1
    8001394c:	40f707b3          	sub	a5,a4,a5
    80013950:	00f037b3          	snez	a5,a5
    80013954:	0ff7f793          	andi	a5,a5,255
}
    80013958:	853e                	mv	a0,a5
    8001395a:	7422                	ld	s0,40(sp)
    8001395c:	6145                	addi	sp,sp,48
    8001395e:	8082                	ret

0000000080013960 <mutex_spinlock>:

void mutex_spinlock(Mutex *mutex)
{
    80013960:	1101                	addi	sp,sp,-32
    80013962:	ec06                	sd	ra,24(sp)
    80013964:	e822                	sd	s0,16(sp)
    80013966:	1000                	addi	s0,sp,32
    80013968:	fea43423          	sd	a0,-24(s0)
    while (!mutex_trylock(mutex))
    8001396c:	0001                	nop
    8001396e:	fe843503          	ld	a0,-24(s0)
    80013972:	fb9ff0ef          	jal	ra,8001392a <mutex_trylock>
    80013976:	87aa                	mv	a5,a0
    80013978:	0017c793          	xori	a5,a5,1
    8001397c:	0ff7f793          	andi	a5,a5,255
    80013980:	f7fd                	bnez	a5,8001396e <mutex_spinlock+0xe>
        ;
}
    80013982:	0001                	nop
    80013984:	0001                	nop
    80013986:	60e2                	ld	ra,24(sp)
    80013988:	6442                	ld	s0,16(sp)
    8001398a:	6105                	addi	sp,sp,32
    8001398c:	8082                	ret

000000008001398e <mutex_unlock>:

void mutex_unlock(Mutex *mutex)
{
    8001398e:	1101                	addi	sp,sp,-32
    80013990:	ec22                	sd	s0,24(sp)
    80013992:	1000                	addi	s0,sp,32
    80013994:	fea43423          	sd	a0,-24(s0)
    asm volatile("amoswap.w.rl zero, zero, (%0)" : : "r"(mutex));
    80013998:	fe843783          	ld	a5,-24(s0)
    8001399c:	0a07a02f          	amoswap.w.rl	zero,zero,(a5)
}
    800139a0:	0001                	nop
    800139a2:	6462                	ld	s0,24(sp)
    800139a4:	6105                	addi	sp,sp,32
    800139a6:	8082                	ret

00000000800139a8 <mmu_table_create>:
#define ADDR_1_BIT   21
#define ADDR_2_BIT   30


struct page_table *mmu_table_create(void)
{
    800139a8:	1141                	addi	sp,sp,-16
    800139aa:	e406                	sd	ra,8(sp)
    800139ac:	e022                	sd	s0,0(sp)
    800139ae:	0800                	addi	s0,sp,16
    return page_zalloc();
    800139b0:	4505                	li	a0,1
    800139b2:	4ba030ef          	jal	ra,80016e6c <page_znalloc>
    800139b6:	87aa                	mv	a5,a0
}
    800139b8:	853e                	mv	a0,a5
    800139ba:	60a2                	ld	ra,8(sp)
    800139bc:	6402                	ld	s0,0(sp)
    800139be:	0141                	addi	sp,sp,16
    800139c0:	8082                	ret

00000000800139c2 <is_valid>:

// Check the valid bit of a page table entry.
static inline bool is_valid(unsigned long pte)
{
    800139c2:	1101                	addi	sp,sp,-32
    800139c4:	ec22                	sd	s0,24(sp)
    800139c6:	1000                	addi	s0,sp,32
    800139c8:	fea43423          	sd	a0,-24(s0)
    return pte & 1UL;
    800139cc:	fe843783          	ld	a5,-24(s0)
    800139d0:	8b85                	andi	a5,a5,1
    800139d2:	00f037b3          	snez	a5,a5
    800139d6:	0ff7f793          	andi	a5,a5,255
}
    800139da:	853e                	mv	a0,a5
    800139dc:	6462                	ld	s0,24(sp)
    800139de:	6105                	addi	sp,sp,32
    800139e0:	8082                	ret

00000000800139e2 <is_leaf>:

// Check if a page table entry is a leaf, return false if it's a branch.
static inline bool is_leaf(unsigned long pte)
{
    800139e2:	1101                	addi	sp,sp,-32
    800139e4:	ec22                	sd	s0,24(sp)
    800139e6:	1000                	addi	s0,sp,32
    800139e8:	fea43423          	sd	a0,-24(s0)
    return (pte & 0xE) != 0;
    800139ec:	fe843783          	ld	a5,-24(s0)
    800139f0:	8bb9                	andi	a5,a5,14
    800139f2:	00f037b3          	snez	a5,a5
    800139f6:	0ff7f793          	andi	a5,a5,255
}
    800139fa:	853e                	mv	a0,a5
    800139fc:	6462                	ld	s0,24(sp)
    800139fe:	6105                	addi	sp,sp,32
    80013a00:	8082                	ret

0000000080013a02 <mmu_map>:

bool mmu_map(struct page_table *tab, uint64_t vaddr, uint64_t paddr, uint8_t lvl, uint64_t bits)
{
    80013a02:	7135                	addi	sp,sp,-160
    80013a04:	ed06                	sd	ra,152(sp)
    80013a06:	e922                	sd	s0,144(sp)
    80013a08:	1100                	addi	s0,sp,160
    80013a0a:	f8a43423          	sd	a0,-120(s0)
    80013a0e:	f8b43023          	sd	a1,-128(s0)
    80013a12:	f6c43c23          	sd	a2,-136(s0)
    80013a16:	87b6                	mv	a5,a3
    80013a18:	f6e43423          	sd	a4,-152(s0)
    80013a1c:	f6f40ba3          	sb	a5,-137(s0)
    if (tab == NULL || lvl > MMU_LEVEL_1G || (bits & 0xE) == 0) {
    80013a20:	f8843783          	ld	a5,-120(s0)
    80013a24:	cf81                	beqz	a5,80013a3c <mmu_map+0x3a>
    80013a26:	f7744783          	lbu	a5,-137(s0)
    80013a2a:	0ff7f713          	andi	a4,a5,255
    80013a2e:	4789                	li	a5,2
    80013a30:	00e7e663          	bltu	a5,a4,80013a3c <mmu_map+0x3a>
    80013a34:	f6843783          	ld	a5,-152(s0)
    80013a38:	8bb9                	andi	a5,a5,14
    80013a3a:	e399                	bnez	a5,80013a40 <mmu_map+0x3e>
        // debugf("mmu_map: invalid argument");
        return false;
    80013a3c:	4781                	li	a5,0
    80013a3e:	aab9                	j	80013b9c <mmu_map+0x19a>

    // debugf("mmu_map: page table at 0x%08lx\n", tab);
    // debugf("mmu_map: vaddr == 0x%08lx\n", vaddr);
    // debugf("mmu_map: paddr == 0x%08lx\n", paddr);

    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80013a40:	f8043783          	ld	a5,-128(s0)
    80013a44:	83b1                	srli	a5,a5,0xc
    80013a46:	1ff7f793          	andi	a5,a5,511
    80013a4a:	faf43823          	sd	a5,-80(s0)
    80013a4e:	f8043783          	ld	a5,-128(s0)
    80013a52:	83d5                	srli	a5,a5,0x15
    80013a54:	1ff7f793          	andi	a5,a5,511
    80013a58:	faf43c23          	sd	a5,-72(s0)
                            (vaddr >> ADDR_2_BIT) & 0x1FF};
    80013a5c:	f8043783          	ld	a5,-128(s0)
    80013a60:	83f9                	srli	a5,a5,0x1e
    80013a62:	1ff7f793          	andi	a5,a5,511
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80013a66:	fcf43023          	sd	a5,-64(s0)
    // debugf("mmu_map: vpn = {%d, %d, %d}\n", vpn[0], vpn[1], vpn[2]);
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80013a6a:	f7843783          	ld	a5,-136(s0)
    80013a6e:	83b1                	srli	a5,a5,0xc
    80013a70:	1ff7f793          	andi	a5,a5,511
    80013a74:	f8f43c23          	sd	a5,-104(s0)
    80013a78:	f7843783          	ld	a5,-136(s0)
    80013a7c:	83d5                	srli	a5,a5,0x15
    80013a7e:	1ff7f793          	andi	a5,a5,511
    80013a82:	faf43023          	sd	a5,-96(s0)
                            (paddr >> ADDR_2_BIT) & 0x3FFFFFF};
    80013a86:	f7843783          	ld	a5,-136(s0)
    80013a8a:	01e7d713          	srli	a4,a5,0x1e
    80013a8e:	040007b7          	lui	a5,0x4000
    80013a92:	17fd                	addi	a5,a5,-1
    80013a94:	8ff9                	and	a5,a5,a4
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80013a96:	faf43423          	sd	a5,-88(s0)

    int i;
    struct page_table *pt = tab;
    80013a9a:	f8843783          	ld	a5,-120(s0)
    80013a9e:	fef43023          	sd	a5,-32(s0)

    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    80013aa2:	4789                	li	a5,2
    80013aa4:	fef42623          	sw	a5,-20(s0)
    80013aa8:	a871                	j	80013b44 <mmu_map+0x142>
        unsigned long pte = pt->entries[vpn[i]];
    80013aaa:	fec42783          	lw	a5,-20(s0)
    80013aae:	078e                	slli	a5,a5,0x3
    80013ab0:	ff040713          	addi	a4,s0,-16
    80013ab4:	97ba                	add	a5,a5,a4
    80013ab6:	fc07b783          	ld	a5,-64(a5) # 3ffffc0 <i+0x3ffffa0>
    80013aba:	fe043703          	ld	a4,-32(s0)
    80013abe:	078e                	slli	a5,a5,0x3
    80013ac0:	97ba                	add	a5,a5,a4
    80013ac2:	639c                	ld	a5,0(a5)
    80013ac4:	fcf43823          	sd	a5,-48(s0)

        if (!is_valid(pte)) {
    80013ac8:	fd043503          	ld	a0,-48(s0)
    80013acc:	ef7ff0ef          	jal	ra,800139c2 <is_valid>
    80013ad0:	87aa                	mv	a5,a0
    80013ad2:	0017c793          	xori	a5,a5,1
    80013ad6:	0ff7f793          	andi	a5,a5,255
    80013ada:	cf8d                	beqz	a5,80013b14 <mmu_map+0x112>
            // debugf("mmu_map: entry %d in page table at 0x%08lx is invalid\n", vpn[i], pt);
            struct page_table *new_pt = mmu_table_create();
    80013adc:	ecdff0ef          	jal	ra,800139a8 <mmu_table_create>
    80013ae0:	fca43423          	sd	a0,-56(s0)
            if (new_pt == NULL) {
    80013ae4:	fc843783          	ld	a5,-56(s0)
    80013ae8:	e399                	bnez	a5,80013aee <mmu_map+0xec>
                // debugf("mmu_map: mmu_table_create returned null");
                return false;
    80013aea:	4781                	li	a5,0
    80013aec:	a845                	j	80013b9c <mmu_map+0x19a>
            }
            // debugf("mmu_map: create a new page table at 0x%08lx\n", new_pt);
            pt->entries[vpn[i]] = (unsigned long)new_pt >> 2 | PB_VALID;
    80013aee:	fc843783          	ld	a5,-56(s0)
    80013af2:	0027d713          	srli	a4,a5,0x2
    80013af6:	fec42783          	lw	a5,-20(s0)
    80013afa:	078e                	slli	a5,a5,0x3
    80013afc:	ff040693          	addi	a3,s0,-16
    80013b00:	97b6                	add	a5,a5,a3
    80013b02:	fc07b783          	ld	a5,-64(a5)
    80013b06:	00176713          	ori	a4,a4,1
    80013b0a:	fe043683          	ld	a3,-32(s0)
    80013b0e:	078e                	slli	a5,a5,0x3
    80013b10:	97b6                	add	a5,a5,a3
    80013b12:	e398                	sd	a4,0(a5)
            // debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d branch to 0x%08lx\n", vpn[i], pt, i, new_pt);
        } else {
            // debugf("mmu_map: entry %d in page table at 0x%08lx is valid\n", vpn[i], pt);
        }
        pt = (struct page_table*)((pt->entries[vpn[i]] & ~0x3FF) << 2);
    80013b14:	fec42783          	lw	a5,-20(s0)
    80013b18:	078e                	slli	a5,a5,0x3
    80013b1a:	ff040713          	addi	a4,s0,-16
    80013b1e:	97ba                	add	a5,a5,a4
    80013b20:	fc07b783          	ld	a5,-64(a5)
    80013b24:	fe043703          	ld	a4,-32(s0)
    80013b28:	078e                	slli	a5,a5,0x3
    80013b2a:	97ba                	add	a5,a5,a4
    80013b2c:	639c                	ld	a5,0(a5)
    80013b2e:	00279713          	slli	a4,a5,0x2
    80013b32:	77fd                	lui	a5,0xfffff
    80013b34:	8ff9                	and	a5,a5,a4
    80013b36:	fef43023          	sd	a5,-32(s0)
    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    80013b3a:	fec42783          	lw	a5,-20(s0)
    80013b3e:	37fd                	addiw	a5,a5,-1
    80013b40:	fef42623          	sw	a5,-20(s0)
    80013b44:	f7744783          	lbu	a5,-137(s0)
    80013b48:	0007871b          	sext.w	a4,a5
    80013b4c:	fec42783          	lw	a5,-20(s0)
    80013b50:	2781                	sext.w	a5,a5
    80013b52:	f4f74ce3          	blt	a4,a5,80013aaa <mmu_map+0xa8>
    }

    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80013b56:	fa843783          	ld	a5,-88(s0)
    80013b5a:	01c79713          	slli	a4,a5,0x1c
                             ppn[1] << PTE_PPN1_BIT |
    80013b5e:	fa043783          	ld	a5,-96(s0)
    80013b62:	07ce                	slli	a5,a5,0x13
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80013b64:	8f5d                	or	a4,a4,a5
                             ppn[0] << PTE_PPN0_BIT;
    80013b66:	f9843783          	ld	a5,-104(s0)
    80013b6a:	07aa                	slli	a5,a5,0xa
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80013b6c:	8fd9                	or	a5,a5,a4
    80013b6e:	fcf43c23          	sd	a5,-40(s0)
    
    // debugf("mmu_map: ppn_leaf == 0x%x\n", (ppn_leaf << 2));
    pt->entries[vpn[i]] = ppn_leaf | bits | PB_VALID;
    80013b72:	fd843703          	ld	a4,-40(s0)
    80013b76:	f6843783          	ld	a5,-152(s0)
    80013b7a:	8f5d                	or	a4,a4,a5
    80013b7c:	fec42783          	lw	a5,-20(s0)
    80013b80:	078e                	slli	a5,a5,0x3
    80013b82:	ff040693          	addi	a3,s0,-16
    80013b86:	97b6                	add	a5,a5,a3
    80013b88:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    80013b8c:	00176713          	ori	a4,a4,1
    80013b90:	fe043683          	ld	a3,-32(s0)
    80013b94:	078e                	slli	a5,a5,0x3
    80013b96:	97b6                	add	a5,a5,a3
    80013b98:	e398                	sd	a4,0(a5)

    // debugf("mmu_map: set bits of address 0x%08lx to 0x%08lx\n", &pt->entries[vpn[i]], ppn_leaf | bits | PB_VALID);

    // debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d leaf to 0x%08lx\n", vpn[i], pt, i, ppn_leaf << 2);
    return true;
    80013b9a:	4785                	li	a5,1
}
    80013b9c:	853e                	mv	a0,a5
    80013b9e:	60ea                	ld	ra,152(sp)
    80013ba0:	644a                	ld	s0,144(sp)
    80013ba2:	610d                	addi	sp,sp,160
    80013ba4:	8082                	ret

0000000080013ba6 <mmu_free>:

void mmu_free(struct page_table *tab) 
{ 
    80013ba6:	7179                	addi	sp,sp,-48
    80013ba8:	f406                	sd	ra,40(sp)
    80013baa:	f022                	sd	s0,32(sp)
    80013bac:	1800                	addi	s0,sp,48
    80013bae:	fca43c23          	sd	a0,-40(s0)
    uint64_t entry; 
    int i; 

    if (tab == NULL) { 
    80013bb2:	fd843783          	ld	a5,-40(s0)
    80013bb6:	c7b5                	beqz	a5,80013c22 <mmu_free+0x7c>
        return; 
    } 

    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    80013bb8:	fe042623          	sw	zero,-20(s0)
    80013bbc:	a0a1                	j	80013c04 <mmu_free+0x5e>
        entry = tab->entries[i]; 
    80013bbe:	fd843703          	ld	a4,-40(s0)
    80013bc2:	fec42783          	lw	a5,-20(s0)
    80013bc6:	078e                	slli	a5,a5,0x3
    80013bc8:	97ba                	add	a5,a5,a4
    80013bca:	639c                	ld	a5,0(a5)
    80013bcc:	fef43023          	sd	a5,-32(s0)
        if (entry & PB_VALID) {
    80013bd0:	fe043783          	ld	a5,-32(s0)
    80013bd4:	8b85                	andi	a5,a5,1
    80013bd6:	cb91                	beqz	a5,80013bea <mmu_free+0x44>
            mmu_free((struct page_table *)((entry & ~0x3FF) << 2)); // Recurse into the next level
    80013bd8:	fe043783          	ld	a5,-32(s0)
    80013bdc:	00279713          	slli	a4,a5,0x2
    80013be0:	77fd                	lui	a5,0xfffff
    80013be2:	8ff9                	and	a5,a5,a4
    80013be4:	853e                	mv	a0,a5
    80013be6:	fc1ff0ef          	jal	ra,80013ba6 <mmu_free>
        }
        tab->entries[i] = 0; 
    80013bea:	fd843703          	ld	a4,-40(s0)
    80013bee:	fec42783          	lw	a5,-20(s0)
    80013bf2:	078e                	slli	a5,a5,0x3
    80013bf4:	97ba                	add	a5,a5,a4
    80013bf6:	0007b023          	sd	zero,0(a5) # fffffffffffff000 <_heap_end+0xffffffff77fef000>
    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    80013bfa:	fec42783          	lw	a5,-20(s0)
    80013bfe:	2785                	addiw	a5,a5,1
    80013c00:	fef42623          	sw	a5,-20(s0)
    80013c04:	fec42783          	lw	a5,-20(s0)
    80013c08:	0007871b          	sext.w	a4,a5
    80013c0c:	1ff00793          	li	a5,511
    80013c10:	fae7d7e3          	bge	a5,a4,80013bbe <mmu_free+0x18>
    } 

    page_free(tab); 
    80013c14:	fd843503          	ld	a0,-40(s0)
    80013c18:	2f0030ef          	jal	ra,80016f08 <page_free>
    SFENCE_ALL();
    80013c1c:	12000073          	sfence.vma
    80013c20:	a011                	j	80013c24 <mmu_free+0x7e>
        return; 
    80013c22:	0001                	nop
}
    80013c24:	70a2                	ld	ra,40(sp)
    80013c26:	7402                	ld	s0,32(sp)
    80013c28:	6145                	addi	sp,sp,48
    80013c2a:	8082                	ret

0000000080013c2c <mmu_translate>:

uint64_t mmu_translate(const struct page_table *tab, uint64_t vaddr) 
{ 
    80013c2c:	711d                	addi	sp,sp,-96
    80013c2e:	ec86                	sd	ra,88(sp)
    80013c30:	e8a2                	sd	s0,80(sp)
    80013c32:	1080                	addi	s0,sp,96
    80013c34:	faa43423          	sd	a0,-88(s0)
    80013c38:	fab43023          	sd	a1,-96(s0)

    // debugf("mmu_translate: page table at 0x%016lx\n", tab);
    // debugf("mmu_translate: vaddr == 0x%016lx\n", vaddr);

    if (tab == NULL) { 
    80013c3c:	fa843783          	ld	a5,-88(s0)
    80013c40:	e399                	bnez	a5,80013c46 <mmu_translate+0x1a>
        // debugf("mmu_translate: tab == NULL\n");
        return MMU_TRANSLATE_PAGE_FAULT; 
    80013c42:	57fd                	li	a5,-1
    80013c44:	aab1                	j	80013da0 <mmu_translate+0x174>
    } 

    // Extract the virtual page numbers
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80013c46:	fa043783          	ld	a5,-96(s0)
    80013c4a:	83b1                	srli	a5,a5,0xc
    80013c4c:	1ff7f793          	andi	a5,a5,511
    80013c50:	faf43823          	sd	a5,-80(s0)
                      (vaddr >> ADDR_1_BIT) & 0x1FF, 
    80013c54:	fa043783          	ld	a5,-96(s0)
    80013c58:	83d5                	srli	a5,a5,0x15
    80013c5a:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80013c5e:	faf43c23          	sd	a5,-72(s0)
                      (vaddr >> ADDR_2_BIT) & 0x1FF};
    80013c62:	fa043783          	ld	a5,-96(s0)
    80013c66:	83f9                	srli	a5,a5,0x1e
    80013c68:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80013c6c:	fcf43023          	sd	a5,-64(s0)
    // debugf("mmu_translate: vpn[0] == 0x%03lx\n", vpn[0]);
    // debugf("mmu_translate: vpn[1] == 0x%03lx\n", vpn[1]);
    // debugf("mmu_translate: vpn[2] == 0x%03lx\n", vpn[2]);

    uint64_t lvl = MMU_LEVEL_1G;
    80013c70:	4789                	li	a5,2
    80013c72:	fef43423          	sd	a5,-24(s0)
    // Traverse the page table hierarchy using the virtual page numbers
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    80013c76:	4789                	li	a5,2
    80013c78:	fef42223          	sw	a5,-28(s0)
    80013c7c:	a075                	j	80013d28 <mmu_translate+0xfc>
        // Iterate through and print the page table entries
        // debugf("mmu_translate: tab->entries == 0x%08lx\n", tab->entries);
        for (int j = 0; j < (PAGE_SIZE / 8); j++) {
    80013c7e:	fe042023          	sw	zero,-32(s0)
    80013c82:	a031                	j	80013c8e <mmu_translate+0x62>
    80013c84:	fe042783          	lw	a5,-32(s0)
    80013c88:	2785                	addiw	a5,a5,1
    80013c8a:	fef42023          	sw	a5,-32(s0)
    80013c8e:	fe042783          	lw	a5,-32(s0)
    80013c92:	0007871b          	sext.w	a4,a5
    80013c96:	1ff00793          	li	a5,511
    80013c9a:	fee7d5e3          	bge	a5,a4,80013c84 <mmu_translate+0x58>
            if (tab->entries[j] & PB_VALID) {
                // debugf("mmu_translate: tab->entries[%x] == 0x%0lx\n", j, tab->entries[j]);
            }
        }

        if (!(tab->entries[vpn[i]] & PB_VALID)) {
    80013c9e:	fe442783          	lw	a5,-28(s0)
    80013ca2:	078e                	slli	a5,a5,0x3
    80013ca4:	ff040713          	addi	a4,s0,-16
    80013ca8:	97ba                	add	a5,a5,a4
    80013caa:	fc07b783          	ld	a5,-64(a5)
    80013cae:	fa843703          	ld	a4,-88(s0)
    80013cb2:	078e                	slli	a5,a5,0x3
    80013cb4:	97ba                	add	a5,a5,a4
    80013cb6:	639c                	ld	a5,0(a5)
    80013cb8:	8b85                	andi	a5,a5,1
    80013cba:	e399                	bnez	a5,80013cc0 <mmu_translate+0x94>
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is invalid\n", vpn[i], tab);
            return MMU_TRANSLATE_PAGE_FAULT; // Entry is not valid
    80013cbc:	57fd                	li	a5,-1
    80013cbe:	a0cd                	j	80013da0 <mmu_translate+0x174>
        } else if (!is_leaf(tab->entries[vpn[i]])) {
    80013cc0:	fe442783          	lw	a5,-28(s0)
    80013cc4:	078e                	slli	a5,a5,0x3
    80013cc6:	ff040713          	addi	a4,s0,-16
    80013cca:	97ba                	add	a5,a5,a4
    80013ccc:	fc07b783          	ld	a5,-64(a5)
    80013cd0:	fa843703          	ld	a4,-88(s0)
    80013cd4:	078e                	slli	a5,a5,0x3
    80013cd6:	97ba                	add	a5,a5,a4
    80013cd8:	639c                	ld	a5,0(a5)
    80013cda:	853e                	mv	a0,a5
    80013cdc:	d07ff0ef          	jal	ra,800139e2 <is_leaf>
    80013ce0:	87aa                	mv	a5,a0
    80013ce2:	0017c793          	xori	a5,a5,1
    80013ce6:	0ff7f793          	andi	a5,a5,255
    80013cea:	c78d                	beqz	a5,80013d14 <mmu_translate+0xe8>
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is a branch to 0x%08lx\n", vpn[i], tab, (tab->entries[vpn[i]] & ~0x3FF) << 2);
            tab = (struct page_table *)((tab->entries[vpn[i]] & ~0x3FF) << 2);
    80013cec:	fe442783          	lw	a5,-28(s0)
    80013cf0:	078e                	slli	a5,a5,0x3
    80013cf2:	ff040713          	addi	a4,s0,-16
    80013cf6:	97ba                	add	a5,a5,a4
    80013cf8:	fc07b783          	ld	a5,-64(a5)
    80013cfc:	fa843703          	ld	a4,-88(s0)
    80013d00:	078e                	slli	a5,a5,0x3
    80013d02:	97ba                	add	a5,a5,a4
    80013d04:	639c                	ld	a5,0(a5)
    80013d06:	00279713          	slli	a4,a5,0x2
    80013d0a:	77fd                	lui	a5,0xfffff
    80013d0c:	8ff9                	and	a5,a5,a4
    80013d0e:	faf43423          	sd	a5,-88(s0)
    80013d12:	a031                	j	80013d1e <mmu_translate+0xf2>
        } else {
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is a leaf\n", vpn[i], tab);
            lvl = i;
    80013d14:	fe442783          	lw	a5,-28(s0)
    80013d18:	fef43423          	sd	a5,-24(s0)
            break; // Entry is a leaf
    80013d1c:	a819                	j	80013d32 <mmu_translate+0x106>
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    80013d1e:	fe442783          	lw	a5,-28(s0)
    80013d22:	37fd                	addiw	a5,a5,-1
    80013d24:	fef42223          	sw	a5,-28(s0)
    80013d28:	fe442783          	lw	a5,-28(s0)
    80013d2c:	2781                	sext.w	a5,a5
    80013d2e:	f407d8e3          	bgez	a5,80013c7e <mmu_translate+0x52>
        }
    }

    // debugf("mmu_translate: vaddr == 0x%08lx\n", vaddr);

    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    80013d32:	fe843783          	ld	a5,-24(s0)
    80013d36:	2781                	sext.w	a5,a5
    80013d38:	873e                	mv	a4,a5
    80013d3a:	87ba                	mv	a5,a4
    80013d3c:	0037979b          	slliw	a5,a5,0x3
    80013d40:	9fb9                	addw	a5,a5,a4
    80013d42:	2781                	sext.w	a5,a5
    80013d44:	27b1                	addiw	a5,a5,12
    80013d46:	2781                	sext.w	a5,a5
    80013d48:	4705                	li	a4,1
    80013d4a:	00f717bb          	sllw	a5,a4,a5
    80013d4e:	2781                	sext.w	a5,a5
    80013d50:	37fd                	addiw	a5,a5,-1
    80013d52:	2781                	sext.w	a5,a5
    80013d54:	fcf43c23          	sd	a5,-40(s0)
    
    // Extract the physical address from the final page table entry
    uint64_t paddr = ((tab->entries[vpn[lvl]] & ~0x3FF) << 2) & ~page_mask;
    80013d58:	fe843783          	ld	a5,-24(s0)
    80013d5c:	078e                	slli	a5,a5,0x3
    80013d5e:	ff040713          	addi	a4,s0,-16
    80013d62:	97ba                	add	a5,a5,a4
    80013d64:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    80013d68:	fa843703          	ld	a4,-88(s0)
    80013d6c:	078e                	slli	a5,a5,0x3
    80013d6e:	97ba                	add	a5,a5,a4
    80013d70:	639c                	ld	a5,0(a5)
    80013d72:	00279713          	slli	a4,a5,0x2
    80013d76:	fd843783          	ld	a5,-40(s0)
    80013d7a:	fff7c793          	not	a5,a5
    80013d7e:	8f7d                	and	a4,a4,a5
    80013d80:	77fd                	lui	a5,0xfffff
    80013d82:	8ff9                	and	a5,a5,a4
    80013d84:	fcf43823          	sd	a5,-48(s0)

    uint64_t result = paddr | (vaddr & page_mask);
    80013d88:	fa043703          	ld	a4,-96(s0)
    80013d8c:	fd843783          	ld	a5,-40(s0)
    80013d90:	8ff9                	and	a5,a5,a4
    80013d92:	fd043703          	ld	a4,-48(s0)
    80013d96:	8fd9                	or	a5,a5,a4
    80013d98:	fcf43423          	sd	a5,-56(s0)
    // debugf("mmu_translate: paddr == 0x%08lx\n", result);

    return result; // Combine with the offset within the page
    80013d9c:	fc843783          	ld	a5,-56(s0)
}
    80013da0:	853e                	mv	a0,a5
    80013da2:	60e6                	ld	ra,88(sp)
    80013da4:	6446                	ld	s0,80(sp)
    80013da6:	6125                	addi	sp,sp,96
    80013da8:	8082                	ret

0000000080013daa <kernel_mmu_translate>:

uint64_t kernel_mmu_translate(uint64_t vaddr) 
{ 
    80013daa:	1101                	addi	sp,sp,-32
    80013dac:	ec06                	sd	ra,24(sp)
    80013dae:	e822                	sd	s0,16(sp)
    80013db0:	1000                	addi	s0,sp,32
    80013db2:	fea43423          	sd	a0,-24(s0)
    return mmu_translate(kernel_mmu_table, vaddr); 
    80013db6:	00006797          	auipc	a5,0x6
    80013dba:	24a78793          	addi	a5,a5,586 # 8001a000 <kernel_mmu_table>
    80013dbe:	639c                	ld	a5,0(a5)
    80013dc0:	fe843583          	ld	a1,-24(s0)
    80013dc4:	853e                	mv	a0,a5
    80013dc6:	e67ff0ef          	jal	ra,80013c2c <mmu_translate>
    80013dca:	87aa                	mv	a5,a0
}
    80013dcc:	853e                	mv	a0,a5
    80013dce:	60e2                	ld	ra,24(sp)
    80013dd0:	6442                	ld	s0,16(sp)
    80013dd2:	6105                	addi	sp,sp,32
    80013dd4:	8082                	ret

0000000080013dd6 <mmu_map_range>:
                       uint64_t start_virt, 
                       uint64_t end_virt, 
                       uint64_t start_phys,
                       uint8_t lvl, 
                       uint64_t bits)
{
    80013dd6:	711d                	addi	sp,sp,-96
    80013dd8:	ec86                	sd	ra,88(sp)
    80013dda:	e8a2                	sd	s0,80(sp)
    80013ddc:	1080                	addi	s0,sp,96
    80013dde:	fca43423          	sd	a0,-56(s0)
    80013de2:	fcb43023          	sd	a1,-64(s0)
    80013de6:	fac43c23          	sd	a2,-72(s0)
    80013dea:	fad43823          	sd	a3,-80(s0)
    80013dee:	faf43023          	sd	a5,-96(s0)
    80013df2:	87ba                	mv	a5,a4
    80013df4:	faf407a3          	sb	a5,-81(s0)
    // debugf("mmu_map_range: page table at 0x%08lx\n", tab);
    start_virt            = ALIGN_DOWN_POT(start_virt, PAGE_SIZE_AT_LVL(lvl));
    80013df8:	faf44783          	lbu	a5,-81(s0)
    80013dfc:	2781                	sext.w	a5,a5
    80013dfe:	873e                	mv	a4,a5
    80013e00:	87ba                	mv	a5,a4
    80013e02:	0037979b          	slliw	a5,a5,0x3
    80013e06:	9fb9                	addw	a5,a5,a4
    80013e08:	2781                	sext.w	a5,a5
    80013e0a:	27b1                	addiw	a5,a5,12
    80013e0c:	2781                	sext.w	a5,a5
    80013e0e:	4705                	li	a4,1
    80013e10:	00f717bb          	sllw	a5,a4,a5
    80013e14:	2781                	sext.w	a5,a5
    80013e16:	40f007bb          	negw	a5,a5
    80013e1a:	2781                	sext.w	a5,a5
    80013e1c:	873e                	mv	a4,a5
    80013e1e:	fc043783          	ld	a5,-64(s0)
    80013e22:	8ff9                	and	a5,a5,a4
    80013e24:	fcf43023          	sd	a5,-64(s0)
    start_phys            = ALIGN_DOWN_POT(start_phys, PAGE_SIZE_AT_LVL(lvl));
    80013e28:	faf44783          	lbu	a5,-81(s0)
    80013e2c:	2781                	sext.w	a5,a5
    80013e2e:	873e                	mv	a4,a5
    80013e30:	87ba                	mv	a5,a4
    80013e32:	0037979b          	slliw	a5,a5,0x3
    80013e36:	9fb9                	addw	a5,a5,a4
    80013e38:	2781                	sext.w	a5,a5
    80013e3a:	27b1                	addiw	a5,a5,12
    80013e3c:	2781                	sext.w	a5,a5
    80013e3e:	4705                	li	a4,1
    80013e40:	00f717bb          	sllw	a5,a4,a5
    80013e44:	2781                	sext.w	a5,a5
    80013e46:	40f007bb          	negw	a5,a5
    80013e4a:	2781                	sext.w	a5,a5
    80013e4c:	873e                	mv	a4,a5
    80013e4e:	fb043783          	ld	a5,-80(s0)
    80013e52:	8ff9                	and	a5,a5,a4
    80013e54:	faf43823          	sd	a5,-80(s0)
    end_virt              = ALIGN_UP_POT(end_virt, PAGE_SIZE_AT_LVL(lvl));
    80013e58:	faf44783          	lbu	a5,-81(s0)
    80013e5c:	2781                	sext.w	a5,a5
    80013e5e:	873e                	mv	a4,a5
    80013e60:	87ba                	mv	a5,a4
    80013e62:	0037979b          	slliw	a5,a5,0x3
    80013e66:	9fb9                	addw	a5,a5,a4
    80013e68:	2781                	sext.w	a5,a5
    80013e6a:	27b1                	addiw	a5,a5,12
    80013e6c:	2781                	sext.w	a5,a5
    80013e6e:	4705                	li	a4,1
    80013e70:	00f717bb          	sllw	a5,a4,a5
    80013e74:	2781                	sext.w	a5,a5
    80013e76:	873e                	mv	a4,a5
    80013e78:	fb843783          	ld	a5,-72(s0)
    80013e7c:	97ba                	add	a5,a5,a4
    80013e7e:	fff78713          	addi	a4,a5,-1
    80013e82:	faf44783          	lbu	a5,-81(s0)
    80013e86:	2781                	sext.w	a5,a5
    80013e88:	86be                	mv	a3,a5
    80013e8a:	87b6                	mv	a5,a3
    80013e8c:	0037979b          	slliw	a5,a5,0x3
    80013e90:	9fb5                	addw	a5,a5,a3
    80013e92:	2781                	sext.w	a5,a5
    80013e94:	27b1                	addiw	a5,a5,12
    80013e96:	2781                	sext.w	a5,a5
    80013e98:	4685                	li	a3,1
    80013e9a:	00f697bb          	sllw	a5,a3,a5
    80013e9e:	2781                	sext.w	a5,a5
    80013ea0:	40f007bb          	negw	a5,a5
    80013ea4:	2781                	sext.w	a5,a5
    80013ea6:	8ff9                	and	a5,a5,a4
    80013ea8:	faf43c23          	sd	a5,-72(s0)
    uint64_t num_bytes    = end_virt - start_virt;
    80013eac:	fb843703          	ld	a4,-72(s0)
    80013eb0:	fc043783          	ld	a5,-64(s0)
    80013eb4:	40f707b3          	sub	a5,a4,a5
    80013eb8:	fcf43c23          	sd	a5,-40(s0)
    // debugf("mmu_map_range: start_virt = 0x%08lx\n", start_virt);
    // debugf("mmu_map_range: start_phys = 0x%08lx\n", start_phys);
    // debugf("mmu_map_range: mapping = %d bytes\n", num_bytes);
    uint64_t pages_mapped = 0;
    80013ebc:	fe043423          	sd	zero,-24(s0)

    uint64_t i;
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80013ec0:	fe043023          	sd	zero,-32(s0)
    80013ec4:	a0ad                	j	80013f2e <mmu_map_range+0x158>
        // debugf("mmu_map_range: mapping %d bytes for page %d\n", PAGE_SIZE_AT_LVL(lvl), i / PAGE_SIZE_AT_LVL(lvl));
        if (!mmu_map(tab, start_virt + i, start_phys + i, lvl, bits)) {
    80013ec6:	fc043703          	ld	a4,-64(s0)
    80013eca:	fe043783          	ld	a5,-32(s0)
    80013ece:	00f705b3          	add	a1,a4,a5
    80013ed2:	fb043703          	ld	a4,-80(s0)
    80013ed6:	fe043783          	ld	a5,-32(s0)
    80013eda:	97ba                	add	a5,a5,a4
    80013edc:	faf44683          	lbu	a3,-81(s0)
    80013ee0:	fa043703          	ld	a4,-96(s0)
    80013ee4:	863e                	mv	a2,a5
    80013ee6:	fc843503          	ld	a0,-56(s0)
    80013eea:	b19ff0ef          	jal	ra,80013a02 <mmu_map>
    80013eee:	87aa                	mv	a5,a0
    80013ef0:	0017c793          	xori	a5,a5,1
    80013ef4:	0ff7f793          	andi	a5,a5,255
    80013ef8:	e3b1                	bnez	a5,80013f3c <mmu_map_range+0x166>
            break;
        }
        pages_mapped += 1;
    80013efa:	fe843783          	ld	a5,-24(s0)
    80013efe:	0785                	addi	a5,a5,1
    80013f00:	fef43423          	sd	a5,-24(s0)
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80013f04:	faf44783          	lbu	a5,-81(s0)
    80013f08:	2781                	sext.w	a5,a5
    80013f0a:	873e                	mv	a4,a5
    80013f0c:	87ba                	mv	a5,a4
    80013f0e:	0037979b          	slliw	a5,a5,0x3
    80013f12:	9fb9                	addw	a5,a5,a4
    80013f14:	2781                	sext.w	a5,a5
    80013f16:	27b1                	addiw	a5,a5,12
    80013f18:	2781                	sext.w	a5,a5
    80013f1a:	4705                	li	a4,1
    80013f1c:	00f717bb          	sllw	a5,a4,a5
    80013f20:	2781                	sext.w	a5,a5
    80013f22:	873e                	mv	a4,a5
    80013f24:	fe043783          	ld	a5,-32(s0)
    80013f28:	97ba                	add	a5,a5,a4
    80013f2a:	fef43023          	sd	a5,-32(s0)
    80013f2e:	fe043703          	ld	a4,-32(s0)
    80013f32:	fd843783          	ld	a5,-40(s0)
    80013f36:	f8f768e3          	bltu	a4,a5,80013ec6 <mmu_map_range+0xf0>
    80013f3a:	a011                	j	80013f3e <mmu_map_range+0x168>
            break;
    80013f3c:	0001                	nop
    }
    // debugf("mmu_map_range: mapped %d pages\n", pages_mapped);
    SFENCE_ALL();
    80013f3e:	12000073          	sfence.vma
    return pages_mapped;
    80013f42:	fe843783          	ld	a5,-24(s0)
} 
    80013f46:	853e                	mv	a0,a5
    80013f48:	60e6                	ld	ra,88(sp)
    80013f4a:	6446                	ld	s0,80(sp)
    80013f4c:	6125                	addi	sp,sp,96
    80013f4e:	8082                	ret

0000000080013f50 <debug_page_table>:

// This function performs some basic sanity checks on the page table.
// For each level of the page table, it prints out the entries that are valid.
void debug_page_table(struct page_table *tab, uint8_t lvl) {
    80013f50:	715d                	addi	sp,sp,-80
    80013f52:	e486                	sd	ra,72(sp)
    80013f54:	e0a2                	sd	s0,64(sp)
    80013f56:	0880                	addi	s0,sp,80
    80013f58:	faa43c23          	sd	a0,-72(s0)
    80013f5c:	87ae                	mv	a5,a1
    80013f5e:	faf40ba3          	sb	a5,-73(s0)
    // debugf("debug_page_table: debugging page table at 0x%016lx\n", tab);
    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    80013f62:	fb744783          	lbu	a5,-73(s0)
    80013f66:	2781                	sext.w	a5,a5
    80013f68:	873e                	mv	a4,a5
    80013f6a:	87ba                	mv	a5,a4
    80013f6c:	0037979b          	slliw	a5,a5,0x3
    80013f70:	9fb9                	addw	a5,a5,a4
    80013f72:	2781                	sext.w	a5,a5
    80013f74:	27b1                	addiw	a5,a5,12
    80013f76:	2781                	sext.w	a5,a5
    80013f78:	4705                	li	a4,1
    80013f7a:	00f717bb          	sllw	a5,a4,a5
    80013f7e:	2781                	sext.w	a5,a5
    80013f80:	37fd                	addiw	a5,a5,-1
    80013f82:	2781                	sext.w	a5,a5
    80013f84:	fef43023          	sd	a5,-32(s0)

    for (uint64_t i=0; i < 512; i++) {
    80013f88:	fe043423          	sd	zero,-24(s0)
    80013f8c:	a21d                	j	800140b2 <debug_page_table+0x162>
        // Is the entry a leaf?
        bool is_leaf = (tab->entries[i] & 0xE) != 0;
    80013f8e:	fb843703          	ld	a4,-72(s0)
    80013f92:	fe843783          	ld	a5,-24(s0)
    80013f96:	078e                	slli	a5,a5,0x3
    80013f98:	97ba                	add	a5,a5,a4
    80013f9a:	639c                	ld	a5,0(a5)
    80013f9c:	8bb9                	andi	a5,a5,14
    80013f9e:	00f037b3          	snez	a5,a5
    80013fa2:	fcf40fa3          	sb	a5,-33(s0)

        // Is the entry valid?
        bool is_valid = tab->entries[i] & PB_VALID;
    80013fa6:	fb843703          	ld	a4,-72(s0)
    80013faa:	fe843783          	ld	a5,-24(s0)
    80013fae:	078e                	slli	a5,a5,0x3
    80013fb0:	97ba                	add	a5,a5,a4
    80013fb2:	639c                	ld	a5,0(a5)
    80013fb4:	8b85                	andi	a5,a5,1
    80013fb6:	00f037b3          	snez	a5,a5
    80013fba:	fcf40f23          	sb	a5,-34(s0)

        // Is the entry a branch?
        bool is_branch = is_valid && !is_leaf;
    80013fbe:	fde44783          	lbu	a5,-34(s0)
    80013fc2:	0ff7f793          	andi	a5,a5,255
    80013fc6:	cb91                	beqz	a5,80013fda <debug_page_table+0x8a>
    80013fc8:	fdf44783          	lbu	a5,-33(s0)
    80013fcc:	0017c793          	xori	a5,a5,1
    80013fd0:	0ff7f793          	andi	a5,a5,255
    80013fd4:	c399                	beqz	a5,80013fda <debug_page_table+0x8a>
    80013fd6:	4785                	li	a5,1
    80013fd8:	a011                	j	80013fdc <debug_page_table+0x8c>
    80013fda:	4781                	li	a5,0
    80013fdc:	fcf40ea3          	sb	a5,-35(s0)
    80013fe0:	fdd44783          	lbu	a5,-35(s0)
    80013fe4:	8b85                	andi	a5,a5,1
    80013fe6:	fcf40ea3          	sb	a5,-35(s0)

        uint64_t paddr = ((tab->entries[i] & ~0x3FF) << 2) & ~page_mask;
    80013fea:	fb843703          	ld	a4,-72(s0)
    80013fee:	fe843783          	ld	a5,-24(s0)
    80013ff2:	078e                	slli	a5,a5,0x3
    80013ff4:	97ba                	add	a5,a5,a4
    80013ff6:	639c                	ld	a5,0(a5)
    80013ff8:	00279713          	slli	a4,a5,0x2
    80013ffc:	fe043783          	ld	a5,-32(s0)
    80014000:	fff7c793          	not	a5,a5
    80014004:	8f7d                	and	a4,a4,a5
    80014006:	77fd                	lui	a5,0xfffff
    80014008:	8ff9                	and	a5,a5,a4
    8001400a:	fcf43823          	sd	a5,-48(s0)
        if (paddr == (uint64_t)tab) {
    8001400e:	fb843783          	ld	a5,-72(s0)
    80014012:	fd043703          	ld	a4,-48(s0)
    80014016:	08f70663          	beq	a4,a5,800140a2 <debug_page_table+0x152>
            continue;
        }

        uint64_t vaddr = paddr;
    8001401a:	fd043783          	ld	a5,-48(s0)
    8001401e:	fcf43423          	sd	a5,-56(s0)
        if (is_valid && is_leaf) {
    80014022:	fde44783          	lbu	a5,-34(s0)
    80014026:	0ff7f793          	andi	a5,a5,255
    8001402a:	cf9d                	beqz	a5,80014068 <debug_page_table+0x118>
    8001402c:	fdf44783          	lbu	a5,-33(s0)
    80014030:	0ff7f793          	andi	a5,a5,255
    80014034:	cb95                	beqz	a5,80014068 <debug_page_table+0x118>
            // Confirm that we can translate the address
            uint64_t translated = mmu_translate(tab, vaddr);
    80014036:	fc843583          	ld	a1,-56(s0)
    8001403a:	fb843503          	ld	a0,-72(s0)
    8001403e:	befff0ef          	jal	ra,80013c2c <mmu_translate>
    80014042:	fca43023          	sd	a0,-64(s0)
            if (translated != paddr) {
    80014046:	fc043703          	ld	a4,-64(s0)
    8001404a:	fd043783          	ld	a5,-48(s0)
    8001404e:	04f70c63          	beq	a4,a5,800140a6 <debug_page_table+0x156>
                // debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                // debugf("debug_page_table: expected 0x%08lx, got 0x%08lx\n", paddr, translated);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    80014052:	fb843603          	ld	a2,-72(s0)
    80014056:	fe843583          	ld	a1,-24(s0)
    8001405a:	00008517          	auipc	a0,0x8
    8001405e:	be650513          	addi	a0,a0,-1050 # 8001bc40 <pow10.0+0xa10>
    80014062:	60e010ef          	jal	ra,80015670 <fatalf>
        if (is_valid && is_leaf) {
    80014066:	a081                	j	800140a6 <debug_page_table+0x156>
            } else {
                // debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
            }
        } else if (is_branch && lvl > MMU_LEVEL_4K) {
    80014068:	fdd44783          	lbu	a5,-35(s0)
    8001406c:	0ff7f793          	andi	a5,a5,255
    80014070:	c791                	beqz	a5,8001407c <debug_page_table+0x12c>
    80014072:	fb744783          	lbu	a5,-73(s0)
    80014076:	0ff7f793          	andi	a5,a5,255
    8001407a:	e79d                	bnez	a5,800140a8 <debug_page_table+0x158>
            // Recurse into the next level
            // debugf("debug_page_table: entry %d in page table at 0x%08lx is a branch to 0x%08lx\n", i, tab, (tab->entries[i] & ~0x3FF) << 2);
            // debug_page_table((struct page_table *)((tab->entries[i] & ~0x3FF) << 2), lvl - 1);
        } else {
            // Invalid entry, confirm that it's all zeroes
            if (tab->entries[i] != 0) {
    8001407c:	fb843703          	ld	a4,-72(s0)
    80014080:	fe843783          	ld	a5,-24(s0)
    80014084:	078e                	slli	a5,a5,0x3
    80014086:	97ba                	add	a5,a5,a4
    80014088:	639c                	ld	a5,0(a5)
    8001408a:	cf99                	beqz	a5,800140a8 <debug_page_table+0x158>
                // debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                // debugf("debug_page_table: expected all zeroes, got 0x%08lx\n", tab->entries[i]);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    8001408c:	fb843603          	ld	a2,-72(s0)
    80014090:	fe843583          	ld	a1,-24(s0)
    80014094:	00008517          	auipc	a0,0x8
    80014098:	bac50513          	addi	a0,a0,-1108 # 8001bc40 <pow10.0+0xa10>
    8001409c:	5d4010ef          	jal	ra,80015670 <fatalf>
    800140a0:	a021                	j	800140a8 <debug_page_table+0x158>
            continue;
    800140a2:	0001                	nop
    800140a4:	a011                	j	800140a8 <debug_page_table+0x158>
        if (is_valid && is_leaf) {
    800140a6:	0001                	nop
    for (uint64_t i=0; i < 512; i++) {
    800140a8:	fe843783          	ld	a5,-24(s0)
    800140ac:	0785                	addi	a5,a5,1
    800140ae:	fef43423          	sd	a5,-24(s0)
    800140b2:	fe843703          	ld	a4,-24(s0)
    800140b6:	1ff00793          	li	a5,511
    800140ba:	ece7fae3          	bgeu	a5,a4,80013f8e <debug_page_table+0x3e>
            }
        }
    }

    // debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
}
    800140be:	0001                	nop
    800140c0:	0001                	nop
    800140c2:	60a6                	ld	ra,72(sp)
    800140c4:	6406                	ld	s0,64(sp)
    800140c6:	6161                	addi	sp,sp,80
    800140c8:	8082                	ret

00000000800140ca <insert_block>:
 * into free list, sorted by addr.
 * If disabled, add block has new head of
 * the free list.
 */
static void insert_block(Block *block)
{
    800140ca:	7179                	addi	sp,sp,-48
    800140cc:	f422                	sd	s0,40(sp)
    800140ce:	1800                	addi	s0,sp,48
    800140d0:	fca43c23          	sd	a0,-40(s0)
    Block *ptr  = heap->free;
    800140d4:	00006797          	auipc	a5,0x6
    800140d8:	f9478793          	addi	a5,a5,-108 # 8001a068 <heap>
    800140dc:	639c                	ld	a5,0(a5)
    800140de:	639c                	ld	a5,0(a5)
    800140e0:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    800140e4:	fe043023          	sd	zero,-32(s0)
    while (ptr != NULL) {
    800140e8:	a01d                	j	8001410e <insert_block+0x44>
        if ((size_t)block->addr <= (size_t)ptr->addr) {
    800140ea:	fd843783          	ld	a5,-40(s0)
    800140ee:	639c                	ld	a5,0(a5)
    800140f0:	873e                	mv	a4,a5
    800140f2:	fe843783          	ld	a5,-24(s0)
    800140f6:	639c                	ld	a5,0(a5)
    800140f8:	00e7ff63          	bgeu	a5,a4,80014116 <insert_block+0x4c>
            break;
        }
        prev = ptr;
    800140fc:	fe843783          	ld	a5,-24(s0)
    80014100:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    80014104:	fe843783          	ld	a5,-24(s0)
    80014108:	679c                	ld	a5,8(a5)
    8001410a:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    8001410e:	fe843783          	ld	a5,-24(s0)
    80014112:	ffe1                	bnez	a5,800140ea <insert_block+0x20>
    80014114:	a011                	j	80014118 <insert_block+0x4e>
            break;
    80014116:	0001                	nop
    }
    if (prev != NULL) {
    80014118:	fe043783          	ld	a5,-32(s0)
    8001411c:	c799                	beqz	a5,8001412a <insert_block+0x60>
        prev->next = block;
    8001411e:	fe043783          	ld	a5,-32(s0)
    80014122:	fd843703          	ld	a4,-40(s0)
    80014126:	e798                	sd	a4,8(a5)
    80014128:	a809                	j	8001413a <insert_block+0x70>
    }
    else {
        heap->free = block;
    8001412a:	00006797          	auipc	a5,0x6
    8001412e:	f3e78793          	addi	a5,a5,-194 # 8001a068 <heap>
    80014132:	639c                	ld	a5,0(a5)
    80014134:	fd843703          	ld	a4,-40(s0)
    80014138:	e398                	sd	a4,0(a5)
    }
    block->next = ptr;
    8001413a:	fd843783          	ld	a5,-40(s0)
    8001413e:	fe843703          	ld	a4,-24(s0)
    80014142:	e798                	sd	a4,8(a5)
}
    80014144:	0001                	nop
    80014146:	7422                	ld	s0,40(sp)
    80014148:	6145                	addi	sp,sp,48
    8001414a:	8082                	ret

000000008001414c <release_blocks>:

#ifndef TA_DISABLE_COMPACT
static void release_blocks(Block *scan, Block *to)
{
    8001414c:	7179                	addi	sp,sp,-48
    8001414e:	f422                	sd	s0,40(sp)
    80014150:	1800                	addi	s0,sp,48
    80014152:	fca43c23          	sd	a0,-40(s0)
    80014156:	fcb43823          	sd	a1,-48(s0)
    Block *scan_next;
    while (scan != to) {
    8001415a:	a099                	j	800141a0 <release_blocks+0x54>
        scan_next   = scan->next;
    8001415c:	fd843783          	ld	a5,-40(s0)
    80014160:	679c                	ld	a5,8(a5)
    80014162:	fef43423          	sd	a5,-24(s0)
        scan->next  = heap->fresh;
    80014166:	00006797          	auipc	a5,0x6
    8001416a:	f0278793          	addi	a5,a5,-254 # 8001a068 <heap>
    8001416e:	639c                	ld	a5,0(a5)
    80014170:	6b98                	ld	a4,16(a5)
    80014172:	fd843783          	ld	a5,-40(s0)
    80014176:	e798                	sd	a4,8(a5)
        heap->fresh = scan;
    80014178:	00006797          	auipc	a5,0x6
    8001417c:	ef078793          	addi	a5,a5,-272 # 8001a068 <heap>
    80014180:	639c                	ld	a5,0(a5)
    80014182:	fd843703          	ld	a4,-40(s0)
    80014186:	eb98                	sd	a4,16(a5)
        scan->addr  = 0;
    80014188:	fd843783          	ld	a5,-40(s0)
    8001418c:	0007b023          	sd	zero,0(a5)
        scan->size  = 0;
    80014190:	fd843783          	ld	a5,-40(s0)
    80014194:	0007b823          	sd	zero,16(a5)
        scan        = scan_next;
    80014198:	fe843783          	ld	a5,-24(s0)
    8001419c:	fcf43c23          	sd	a5,-40(s0)
    while (scan != to) {
    800141a0:	fd843703          	ld	a4,-40(s0)
    800141a4:	fd043783          	ld	a5,-48(s0)
    800141a8:	faf71ae3          	bne	a4,a5,8001415c <release_blocks+0x10>
    }
}
    800141ac:	0001                	nop
    800141ae:	0001                	nop
    800141b0:	7422                	ld	s0,40(sp)
    800141b2:	6145                	addi	sp,sp,48
    800141b4:	8082                	ret

00000000800141b6 <compact>:

static void compact()
{
    800141b6:	7139                	addi	sp,sp,-64
    800141b8:	fc06                	sd	ra,56(sp)
    800141ba:	f822                	sd	s0,48(sp)
    800141bc:	0080                	addi	s0,sp,64
    Block *ptr = heap->free;
    800141be:	00006797          	auipc	a5,0x6
    800141c2:	eaa78793          	addi	a5,a5,-342 # 8001a068 <heap>
    800141c6:	639c                	ld	a5,0(a5)
    800141c8:	639c                	ld	a5,0(a5)
    800141ca:	fef43423          	sd	a5,-24(s0)
    Block *prev;
    Block *scan;
    while (ptr != NULL) {
    800141ce:	a075                	j	8001427a <compact+0xc4>
        prev = ptr;
    800141d0:	fe843783          	ld	a5,-24(s0)
    800141d4:	fef43023          	sd	a5,-32(s0)
        scan = ptr->next;
    800141d8:	fe843783          	ld	a5,-24(s0)
    800141dc:	679c                	ld	a5,8(a5)
    800141de:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    800141e2:	a811                	j	800141f6 <compact+0x40>
            prev = scan;
    800141e4:	fd843783          	ld	a5,-40(s0)
    800141e8:	fef43023          	sd	a5,-32(s0)
            scan = scan->next;
    800141ec:	fd843783          	ld	a5,-40(s0)
    800141f0:	679c                	ld	a5,8(a5)
    800141f2:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    800141f6:	fd843783          	ld	a5,-40(s0)
    800141fa:	cf91                	beqz	a5,80014216 <compact+0x60>
    800141fc:	fe043783          	ld	a5,-32(s0)
    80014200:	639c                	ld	a5,0(a5)
    80014202:	873e                	mv	a4,a5
    80014204:	fe043783          	ld	a5,-32(s0)
    80014208:	6b9c                	ld	a5,16(a5)
    8001420a:	97ba                	add	a5,a5,a4
    8001420c:	fd843703          	ld	a4,-40(s0)
    80014210:	6318                	ld	a4,0(a4)
    80014212:	fce789e3          	beq	a5,a4,800141e4 <compact+0x2e>
        }
        if (prev != ptr) {
    80014216:	fe043703          	ld	a4,-32(s0)
    8001421a:	fe843783          	ld	a5,-24(s0)
    8001421e:	04f70963          	beq	a4,a5,80014270 <compact+0xba>
            size_t new_size = (size_t)prev->addr - (size_t)ptr->addr + prev->size;
    80014222:	fe043783          	ld	a5,-32(s0)
    80014226:	639c                	ld	a5,0(a5)
    80014228:	873e                	mv	a4,a5
    8001422a:	fe843783          	ld	a5,-24(s0)
    8001422e:	639c                	ld	a5,0(a5)
    80014230:	8f1d                	sub	a4,a4,a5
    80014232:	fe043783          	ld	a5,-32(s0)
    80014236:	6b9c                	ld	a5,16(a5)
    80014238:	97ba                	add	a5,a5,a4
    8001423a:	fcf43823          	sd	a5,-48(s0)
            ptr->size       = new_size;
    8001423e:	fe843783          	ld	a5,-24(s0)
    80014242:	fd043703          	ld	a4,-48(s0)
    80014246:	eb98                	sd	a4,16(a5)
            Block *next     = prev->next;
    80014248:	fe043783          	ld	a5,-32(s0)
    8001424c:	679c                	ld	a5,8(a5)
    8001424e:	fcf43423          	sd	a5,-56(s0)
            // make merged blocks available
            release_blocks(ptr->next, prev->next);
    80014252:	fe843783          	ld	a5,-24(s0)
    80014256:	6798                	ld	a4,8(a5)
    80014258:	fe043783          	ld	a5,-32(s0)
    8001425c:	679c                	ld	a5,8(a5)
    8001425e:	85be                	mv	a1,a5
    80014260:	853a                	mv	a0,a4
    80014262:	eebff0ef          	jal	ra,8001414c <release_blocks>
            // relink
            ptr->next = next;
    80014266:	fe843783          	ld	a5,-24(s0)
    8001426a:	fc843703          	ld	a4,-56(s0)
    8001426e:	e798                	sd	a4,8(a5)
        }
        ptr = ptr->next;
    80014270:	fe843783          	ld	a5,-24(s0)
    80014274:	679c                	ld	a5,8(a5)
    80014276:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    8001427a:	fe843783          	ld	a5,-24(s0)
    8001427e:	fba9                	bnez	a5,800141d0 <compact+0x1a>
    }
}
    80014280:	0001                	nop
    80014282:	0001                	nop
    80014284:	70e2                	ld	ra,56(sp)
    80014286:	7442                	ld	s0,48(sp)
    80014288:	6121                	addi	sp,sp,64
    8001428a:	8082                	ret

000000008001428c <init>:
#endif

static bool init(const void *base, const void *limit, const size_t heap_blocks,
                 const size_t split_thresh, const size_t alignment)
{
    8001428c:	715d                	addi	sp,sp,-80
    8001428e:	e4a2                	sd	s0,72(sp)
    80014290:	0880                	addi	s0,sp,80
    80014292:	fca43c23          	sd	a0,-40(s0)
    80014296:	fcb43823          	sd	a1,-48(s0)
    8001429a:	fcc43423          	sd	a2,-56(s0)
    8001429e:	fcd43023          	sd	a3,-64(s0)
    800142a2:	fae43c23          	sd	a4,-72(s0)
    heap              = (Heap *)base;
    800142a6:	00006797          	auipc	a5,0x6
    800142aa:	dc278793          	addi	a5,a5,-574 # 8001a068 <heap>
    800142ae:	fd843703          	ld	a4,-40(s0)
    800142b2:	e398                	sd	a4,0(a5)
    heap_limit        = limit;
    800142b4:	00006797          	auipc	a5,0x6
    800142b8:	dbc78793          	addi	a5,a5,-580 # 8001a070 <heap_limit>
    800142bc:	fd043703          	ld	a4,-48(s0)
    800142c0:	e398                	sd	a4,0(a5)
    heap_split_thresh = split_thresh;
    800142c2:	00006797          	auipc	a5,0x6
    800142c6:	db678793          	addi	a5,a5,-586 # 8001a078 <heap_split_thresh>
    800142ca:	fc043703          	ld	a4,-64(s0)
    800142ce:	e398                	sd	a4,0(a5)
    heap_alignment    = alignment;
    800142d0:	00006797          	auipc	a5,0x6
    800142d4:	db078793          	addi	a5,a5,-592 # 8001a080 <heap_alignment>
    800142d8:	fb843703          	ld	a4,-72(s0)
    800142dc:	e398                	sd	a4,0(a5)
    heap_max_blocks   = heap_blocks;
    800142de:	00006797          	auipc	a5,0x6
    800142e2:	daa78793          	addi	a5,a5,-598 # 8001a088 <heap_max_blocks>
    800142e6:	fc843703          	ld	a4,-56(s0)
    800142ea:	e398                	sd	a4,0(a5)

    heap->free        = NULL;
    800142ec:	00006797          	auipc	a5,0x6
    800142f0:	d7c78793          	addi	a5,a5,-644 # 8001a068 <heap>
    800142f4:	639c                	ld	a5,0(a5)
    800142f6:	0007b023          	sd	zero,0(a5)
    heap->used        = NULL;
    800142fa:	00006797          	auipc	a5,0x6
    800142fe:	d6e78793          	addi	a5,a5,-658 # 8001a068 <heap>
    80014302:	639c                	ld	a5,0(a5)
    80014304:	0007b423          	sd	zero,8(a5)
    heap->fresh       = (Block *)(heap + 1);
    80014308:	00006797          	auipc	a5,0x6
    8001430c:	d6078793          	addi	a5,a5,-672 # 8001a068 <heap>
    80014310:	6398                	ld	a4,0(a5)
    80014312:	00006797          	auipc	a5,0x6
    80014316:	d5678793          	addi	a5,a5,-682 # 8001a068 <heap>
    8001431a:	639c                	ld	a5,0(a5)
    8001431c:	02070713          	addi	a4,a4,32
    80014320:	eb98                	sd	a4,16(a5)
    heap->top         = (size_t)(heap->fresh + heap_blocks);
    80014322:	00006797          	auipc	a5,0x6
    80014326:	d4678793          	addi	a5,a5,-698 # 8001a068 <heap>
    8001432a:	639c                	ld	a5,0(a5)
    8001432c:	6b94                	ld	a3,16(a5)
    8001432e:	fc843703          	ld	a4,-56(s0)
    80014332:	87ba                	mv	a5,a4
    80014334:	0786                	slli	a5,a5,0x1
    80014336:	97ba                	add	a5,a5,a4
    80014338:	078e                	slli	a5,a5,0x3
    8001433a:	00f68733          	add	a4,a3,a5
    8001433e:	00006797          	auipc	a5,0x6
    80014342:	d2a78793          	addi	a5,a5,-726 # 8001a068 <heap>
    80014346:	639c                	ld	a5,0(a5)
    80014348:	ef98                	sd	a4,24(a5)

    Block *block      = heap->fresh;
    8001434a:	00006797          	auipc	a5,0x6
    8001434e:	d1e78793          	addi	a5,a5,-738 # 8001a068 <heap>
    80014352:	639c                	ld	a5,0(a5)
    80014354:	6b9c                	ld	a5,16(a5)
    80014356:	fef43423          	sd	a5,-24(s0)
    size_t i          = heap_max_blocks - 1;
    8001435a:	00006797          	auipc	a5,0x6
    8001435e:	d2e78793          	addi	a5,a5,-722 # 8001a088 <heap_max_blocks>
    80014362:	639c                	ld	a5,0(a5)
    80014364:	17fd                	addi	a5,a5,-1
    80014366:	fef43023          	sd	a5,-32(s0)
    while (i--) {
    8001436a:	a829                	j	80014384 <init+0xf8>
        block->next = block + 1;
    8001436c:	fe843783          	ld	a5,-24(s0)
    80014370:	01878713          	addi	a4,a5,24
    80014374:	fe843783          	ld	a5,-24(s0)
    80014378:	e798                	sd	a4,8(a5)
        block++;
    8001437a:	fe843783          	ld	a5,-24(s0)
    8001437e:	07e1                	addi	a5,a5,24
    80014380:	fef43423          	sd	a5,-24(s0)
    while (i--) {
    80014384:	fe043783          	ld	a5,-32(s0)
    80014388:	fff78713          	addi	a4,a5,-1
    8001438c:	fee43023          	sd	a4,-32(s0)
    80014390:	fff1                	bnez	a5,8001436c <init+0xe0>
    }
    block->next = NULL;
    80014392:	fe843783          	ld	a5,-24(s0)
    80014396:	0007b423          	sd	zero,8(a5)
    return true;
    8001439a:	4785                	li	a5,1
}
    8001439c:	853e                	mv	a0,a5
    8001439e:	6426                	ld	s0,72(sp)
    800143a0:	6161                	addi	sp,sp,80
    800143a2:	8082                	ret

00000000800143a4 <free>:

static bool free(const void *free)
{
    800143a4:	7179                	addi	sp,sp,-48
    800143a6:	f406                	sd	ra,40(sp)
    800143a8:	f022                	sd	s0,32(sp)
    800143aa:	1800                	addi	s0,sp,48
    800143ac:	fca43c23          	sd	a0,-40(s0)
    Block *block = heap->used;
    800143b0:	00006797          	auipc	a5,0x6
    800143b4:	cb878793          	addi	a5,a5,-840 # 8001a068 <heap>
    800143b8:	639c                	ld	a5,0(a5)
    800143ba:	679c                	ld	a5,8(a5)
    800143bc:	fef43423          	sd	a5,-24(s0)
    Block *prev  = NULL;
    800143c0:	fe043023          	sd	zero,-32(s0)
    while (block != NULL) {
    800143c4:	a8a1                	j	8001441c <free+0x78>
        if (free == block->addr) {
    800143c6:	fe843783          	ld	a5,-24(s0)
    800143ca:	639c                	ld	a5,0(a5)
    800143cc:	fd843703          	ld	a4,-40(s0)
    800143d0:	02f71d63          	bne	a4,a5,8001440a <free+0x66>
            if (prev) {
    800143d4:	fe043783          	ld	a5,-32(s0)
    800143d8:	cb81                	beqz	a5,800143e8 <free+0x44>
                prev->next = block->next;
    800143da:	fe843783          	ld	a5,-24(s0)
    800143de:	6798                	ld	a4,8(a5)
    800143e0:	fe043783          	ld	a5,-32(s0)
    800143e4:	e798                	sd	a4,8(a5)
    800143e6:	a811                	j	800143fa <free+0x56>
            }
            else {
                heap->used = block->next;
    800143e8:	00006797          	auipc	a5,0x6
    800143ec:	c8078793          	addi	a5,a5,-896 # 8001a068 <heap>
    800143f0:	639c                	ld	a5,0(a5)
    800143f2:	fe843703          	ld	a4,-24(s0)
    800143f6:	6718                	ld	a4,8(a4)
    800143f8:	e798                	sd	a4,8(a5)
            }
            insert_block(block);
    800143fa:	fe843503          	ld	a0,-24(s0)
    800143fe:	ccdff0ef          	jal	ra,800140ca <insert_block>
            compact();
    80014402:	db5ff0ef          	jal	ra,800141b6 <compact>
            return true;
    80014406:	4785                	li	a5,1
    80014408:	a831                	j	80014424 <free+0x80>
        }
        prev  = block;
    8001440a:	fe843783          	ld	a5,-24(s0)
    8001440e:	fef43023          	sd	a5,-32(s0)
        block = block->next;
    80014412:	fe843783          	ld	a5,-24(s0)
    80014416:	679c                	ld	a5,8(a5)
    80014418:	fef43423          	sd	a5,-24(s0)
    while (block != NULL) {
    8001441c:	fe843783          	ld	a5,-24(s0)
    80014420:	f3dd                	bnez	a5,800143c6 <free+0x22>
    }
    return false;
    80014422:	4781                	li	a5,0
}
    80014424:	853e                	mv	a0,a5
    80014426:	70a2                	ld	ra,40(sp)
    80014428:	7402                	ld	s0,32(sp)
    8001442a:	6145                	addi	sp,sp,48
    8001442c:	8082                	ret

000000008001442e <alloc_block>:

static Block *alloc_block(size_t num)
{
    8001442e:	711d                	addi	sp,sp,-96
    80014430:	ec86                	sd	ra,88(sp)
    80014432:	e8a2                	sd	s0,80(sp)
    80014434:	1080                	addi	s0,sp,96
    80014436:	faa43423          	sd	a0,-88(s0)
    Block *ptr  = heap->free;
    8001443a:	00006797          	auipc	a5,0x6
    8001443e:	c2e78793          	addi	a5,a5,-978 # 8001a068 <heap>
    80014442:	639c                	ld	a5,0(a5)
    80014444:	639c                	ld	a5,0(a5)
    80014446:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    8001444a:	fe043023          	sd	zero,-32(s0)
    size_t top  = heap->top;
    8001444e:	00006797          	auipc	a5,0x6
    80014452:	c1a78793          	addi	a5,a5,-998 # 8001a068 <heap>
    80014456:	639c                	ld	a5,0(a5)
    80014458:	6f9c                	ld	a5,24(a5)
    8001445a:	fcf43c23          	sd	a5,-40(s0)
    num         = (num + heap_alignment - 1) & -heap_alignment;
    8001445e:	00006797          	auipc	a5,0x6
    80014462:	c2278793          	addi	a5,a5,-990 # 8001a080 <heap_alignment>
    80014466:	6398                	ld	a4,0(a5)
    80014468:	fa843783          	ld	a5,-88(s0)
    8001446c:	97ba                	add	a5,a5,a4
    8001446e:	fff78713          	addi	a4,a5,-1
    80014472:	00006797          	auipc	a5,0x6
    80014476:	c0e78793          	addi	a5,a5,-1010 # 8001a080 <heap_alignment>
    8001447a:	639c                	ld	a5,0(a5)
    8001447c:	40f007b3          	neg	a5,a5
    80014480:	8ff9                	and	a5,a5,a4
    80014482:	faf43423          	sd	a5,-88(s0)
    while (ptr != NULL) {
    80014486:	a2bd                	j	800145f4 <alloc_block+0x1c6>
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    80014488:	fe843783          	ld	a5,-24(s0)
    8001448c:	639c                	ld	a5,0(a5)
    8001448e:	873e                	mv	a4,a5
    80014490:	fe843783          	ld	a5,-24(s0)
    80014494:	6b9c                	ld	a5,16(a5)
    80014496:	97ba                	add	a5,a5,a4
    80014498:	fd843703          	ld	a4,-40(s0)
    8001449c:	02e7e263          	bltu	a5,a4,800144c0 <alloc_block+0x92>
                           ((size_t)ptr->addr + num <= (size_t)heap_limit);
    800144a0:	fe843783          	ld	a5,-24(s0)
    800144a4:	639c                	ld	a5,0(a5)
    800144a6:	873e                	mv	a4,a5
    800144a8:	fa843783          	ld	a5,-88(s0)
    800144ac:	97ba                	add	a5,a5,a4
    800144ae:	00006717          	auipc	a4,0x6
    800144b2:	bc270713          	addi	a4,a4,-1086 # 8001a070 <heap_limit>
    800144b6:	6318                	ld	a4,0(a4)
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    800144b8:	00f76463          	bltu	a4,a5,800144c0 <alloc_block+0x92>
    800144bc:	4785                	li	a5,1
    800144be:	a011                	j	800144c2 <alloc_block+0x94>
    800144c0:	4781                	li	a5,0
    800144c2:	fcf42623          	sw	a5,-52(s0)
        if (is_top || ptr->size >= num) {
    800144c6:	fcc42783          	lw	a5,-52(s0)
    800144ca:	2781                	sext.w	a5,a5
    800144cc:	eb81                	bnez	a5,800144dc <alloc_block+0xae>
    800144ce:	fe843783          	ld	a5,-24(s0)
    800144d2:	6b9c                	ld	a5,16(a5)
    800144d4:	fa843703          	ld	a4,-88(s0)
    800144d8:	10e7e563          	bltu	a5,a4,800145e2 <alloc_block+0x1b4>
            if (prev != NULL) {
    800144dc:	fe043783          	ld	a5,-32(s0)
    800144e0:	cb81                	beqz	a5,800144f0 <alloc_block+0xc2>
                prev->next = ptr->next;
    800144e2:	fe843783          	ld	a5,-24(s0)
    800144e6:	6798                	ld	a4,8(a5)
    800144e8:	fe043783          	ld	a5,-32(s0)
    800144ec:	e798                	sd	a4,8(a5)
    800144ee:	a811                	j	80014502 <alloc_block+0xd4>
            }
            else {
                heap->free = ptr->next;
    800144f0:	00006797          	auipc	a5,0x6
    800144f4:	b7878793          	addi	a5,a5,-1160 # 8001a068 <heap>
    800144f8:	639c                	ld	a5,0(a5)
    800144fa:	fe843703          	ld	a4,-24(s0)
    800144fe:	6718                	ld	a4,8(a4)
    80014500:	e398                	sd	a4,0(a5)
            }
            ptr->next  = heap->used;
    80014502:	00006797          	auipc	a5,0x6
    80014506:	b6678793          	addi	a5,a5,-1178 # 8001a068 <heap>
    8001450a:	639c                	ld	a5,0(a5)
    8001450c:	6798                	ld	a4,8(a5)
    8001450e:	fe843783          	ld	a5,-24(s0)
    80014512:	e798                	sd	a4,8(a5)
            heap->used = ptr;
    80014514:	00006797          	auipc	a5,0x6
    80014518:	b5478793          	addi	a5,a5,-1196 # 8001a068 <heap>
    8001451c:	639c                	ld	a5,0(a5)
    8001451e:	fe843703          	ld	a4,-24(s0)
    80014522:	e798                	sd	a4,8(a5)
            if (is_top) {
    80014524:	fcc42783          	lw	a5,-52(s0)
    80014528:	2781                	sext.w	a5,a5
    8001452a:	c785                	beqz	a5,80014552 <alloc_block+0x124>
                ptr->size = num;
    8001452c:	fe843783          	ld	a5,-24(s0)
    80014530:	fa843703          	ld	a4,-88(s0)
    80014534:	eb98                	sd	a4,16(a5)
                heap->top = (size_t)ptr->addr + num;
    80014536:	fe843783          	ld	a5,-24(s0)
    8001453a:	639c                	ld	a5,0(a5)
    8001453c:	86be                	mv	a3,a5
    8001453e:	00006797          	auipc	a5,0x6
    80014542:	b2a78793          	addi	a5,a5,-1238 # 8001a068 <heap>
    80014546:	639c                	ld	a5,0(a5)
    80014548:	fa843703          	ld	a4,-88(s0)
    8001454c:	9736                	add	a4,a4,a3
    8001454e:	ef98                	sd	a4,24(a5)
    80014550:	a071                	j	800145dc <alloc_block+0x1ae>
            }
            else if (heap->fresh != NULL) {
    80014552:	00006797          	auipc	a5,0x6
    80014556:	b1678793          	addi	a5,a5,-1258 # 8001a068 <heap>
    8001455a:	639c                	ld	a5,0(a5)
    8001455c:	6b9c                	ld	a5,16(a5)
    8001455e:	cfbd                	beqz	a5,800145dc <alloc_block+0x1ae>
                size_t excess = ptr->size - num;
    80014560:	fe843783          	ld	a5,-24(s0)
    80014564:	6b98                	ld	a4,16(a5)
    80014566:	fa843783          	ld	a5,-88(s0)
    8001456a:	40f707b3          	sub	a5,a4,a5
    8001456e:	fcf43023          	sd	a5,-64(s0)
                if (excess >= heap_split_thresh) {
    80014572:	00006797          	auipc	a5,0x6
    80014576:	b0678793          	addi	a5,a5,-1274 # 8001a078 <heap_split_thresh>
    8001457a:	639c                	ld	a5,0(a5)
    8001457c:	fc043703          	ld	a4,-64(s0)
    80014580:	04f76e63          	bltu	a4,a5,800145dc <alloc_block+0x1ae>
                    ptr->size    = num;
    80014584:	fe843783          	ld	a5,-24(s0)
    80014588:	fa843703          	ld	a4,-88(s0)
    8001458c:	eb98                	sd	a4,16(a5)
                    Block *split = heap->fresh;
    8001458e:	00006797          	auipc	a5,0x6
    80014592:	ada78793          	addi	a5,a5,-1318 # 8001a068 <heap>
    80014596:	639c                	ld	a5,0(a5)
    80014598:	6b9c                	ld	a5,16(a5)
    8001459a:	faf43c23          	sd	a5,-72(s0)
                    heap->fresh  = split->next;
    8001459e:	00006797          	auipc	a5,0x6
    800145a2:	aca78793          	addi	a5,a5,-1334 # 8001a068 <heap>
    800145a6:	639c                	ld	a5,0(a5)
    800145a8:	fb843703          	ld	a4,-72(s0)
    800145ac:	6718                	ld	a4,8(a4)
    800145ae:	eb98                	sd	a4,16(a5)
                    split->addr  = (void *)((size_t)ptr->addr + num);
    800145b0:	fe843783          	ld	a5,-24(s0)
    800145b4:	639c                	ld	a5,0(a5)
    800145b6:	873e                	mv	a4,a5
    800145b8:	fa843783          	ld	a5,-88(s0)
    800145bc:	97ba                	add	a5,a5,a4
    800145be:	873e                	mv	a4,a5
    800145c0:	fb843783          	ld	a5,-72(s0)
    800145c4:	e398                	sd	a4,0(a5)
                    split->size  = excess;
    800145c6:	fb843783          	ld	a5,-72(s0)
    800145ca:	fc043703          	ld	a4,-64(s0)
    800145ce:	eb98                	sd	a4,16(a5)
                    insert_block(split);
    800145d0:	fb843503          	ld	a0,-72(s0)
    800145d4:	af7ff0ef          	jal	ra,800140ca <insert_block>
                    compact();
    800145d8:	bdfff0ef          	jal	ra,800141b6 <compact>
                }
            }
            return ptr;
    800145dc:	fe843783          	ld	a5,-24(s0)
    800145e0:	a875                	j	8001469c <alloc_block+0x26e>
        }
        prev = ptr;
    800145e2:	fe843783          	ld	a5,-24(s0)
    800145e6:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    800145ea:	fe843783          	ld	a5,-24(s0)
    800145ee:	679c                	ld	a5,8(a5)
    800145f0:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    800145f4:	fe843783          	ld	a5,-24(s0)
    800145f8:	e80798e3          	bnez	a5,80014488 <alloc_block+0x5a>
    }
    // no matching free blocks
    // see if any other blocks available
    size_t new_top = top + num;
    800145fc:	fd843703          	ld	a4,-40(s0)
    80014600:	fa843783          	ld	a5,-88(s0)
    80014604:	97ba                	add	a5,a5,a4
    80014606:	fcf43823          	sd	a5,-48(s0)
    if (heap->fresh != NULL && new_top <= (size_t)heap_limit) {
    8001460a:	00006797          	auipc	a5,0x6
    8001460e:	a5e78793          	addi	a5,a5,-1442 # 8001a068 <heap>
    80014612:	639c                	ld	a5,0(a5)
    80014614:	6b9c                	ld	a5,16(a5)
    80014616:	c3d1                	beqz	a5,8001469a <alloc_block+0x26c>
    80014618:	00006797          	auipc	a5,0x6
    8001461c:	a5878793          	addi	a5,a5,-1448 # 8001a070 <heap_limit>
    80014620:	639c                	ld	a5,0(a5)
    80014622:	873e                	mv	a4,a5
    80014624:	fd043783          	ld	a5,-48(s0)
    80014628:	06f76963          	bltu	a4,a5,8001469a <alloc_block+0x26c>
        ptr         = heap->fresh;
    8001462c:	00006797          	auipc	a5,0x6
    80014630:	a3c78793          	addi	a5,a5,-1476 # 8001a068 <heap>
    80014634:	639c                	ld	a5,0(a5)
    80014636:	6b9c                	ld	a5,16(a5)
    80014638:	fef43423          	sd	a5,-24(s0)
        heap->fresh = ptr->next;
    8001463c:	00006797          	auipc	a5,0x6
    80014640:	a2c78793          	addi	a5,a5,-1492 # 8001a068 <heap>
    80014644:	639c                	ld	a5,0(a5)
    80014646:	fe843703          	ld	a4,-24(s0)
    8001464a:	6718                	ld	a4,8(a4)
    8001464c:	eb98                	sd	a4,16(a5)
        ptr->addr   = (void *)top;
    8001464e:	fd843703          	ld	a4,-40(s0)
    80014652:	fe843783          	ld	a5,-24(s0)
    80014656:	e398                	sd	a4,0(a5)
        ptr->next   = heap->used;
    80014658:	00006797          	auipc	a5,0x6
    8001465c:	a1078793          	addi	a5,a5,-1520 # 8001a068 <heap>
    80014660:	639c                	ld	a5,0(a5)
    80014662:	6798                	ld	a4,8(a5)
    80014664:	fe843783          	ld	a5,-24(s0)
    80014668:	e798                	sd	a4,8(a5)
        ptr->size   = num;
    8001466a:	fe843783          	ld	a5,-24(s0)
    8001466e:	fa843703          	ld	a4,-88(s0)
    80014672:	eb98                	sd	a4,16(a5)
        heap->used  = ptr;
    80014674:	00006797          	auipc	a5,0x6
    80014678:	9f478793          	addi	a5,a5,-1548 # 8001a068 <heap>
    8001467c:	639c                	ld	a5,0(a5)
    8001467e:	fe843703          	ld	a4,-24(s0)
    80014682:	e798                	sd	a4,8(a5)
        heap->top   = new_top;
    80014684:	00006797          	auipc	a5,0x6
    80014688:	9e478793          	addi	a5,a5,-1564 # 8001a068 <heap>
    8001468c:	639c                	ld	a5,0(a5)
    8001468e:	fd043703          	ld	a4,-48(s0)
    80014692:	ef98                	sd	a4,24(a5)
        return ptr;
    80014694:	fe843783          	ld	a5,-24(s0)
    80014698:	a011                	j	8001469c <alloc_block+0x26e>
    }
    return NULL;
    8001469a:	4781                	li	a5,0
}
    8001469c:	853e                	mv	a0,a5
    8001469e:	60e6                	ld	ra,88(sp)
    800146a0:	6446                	ld	s0,80(sp)
    800146a2:	6125                	addi	sp,sp,96
    800146a4:	8082                	ret

00000000800146a6 <alloc>:

static void *alloc(size_t num)
{
    800146a6:	7179                	addi	sp,sp,-48
    800146a8:	f406                	sd	ra,40(sp)
    800146aa:	f022                	sd	s0,32(sp)
    800146ac:	1800                	addi	s0,sp,48
    800146ae:	fca43c23          	sd	a0,-40(s0)
    Block *block = alloc_block(num);
    800146b2:	fd843503          	ld	a0,-40(s0)
    800146b6:	d79ff0ef          	jal	ra,8001442e <alloc_block>
    800146ba:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    800146be:	fe843783          	ld	a5,-24(s0)
    800146c2:	c789                	beqz	a5,800146cc <alloc+0x26>
        return block->addr;
    800146c4:	fe843783          	ld	a5,-24(s0)
    800146c8:	639c                	ld	a5,0(a5)
    800146ca:	a011                	j	800146ce <alloc+0x28>
    }
    return NULL;
    800146cc:	4781                	li	a5,0
}
    800146ce:	853e                	mv	a0,a5
    800146d0:	70a2                	ld	ra,40(sp)
    800146d2:	7402                	ld	s0,32(sp)
    800146d4:	6145                	addi	sp,sp,48
    800146d6:	8082                	ret

00000000800146d8 <calloc>:

static void *calloc(size_t num, size_t size)
{
    800146d8:	7179                	addi	sp,sp,-48
    800146da:	f406                	sd	ra,40(sp)
    800146dc:	f022                	sd	s0,32(sp)
    800146de:	1800                	addi	s0,sp,48
    800146e0:	fca43c23          	sd	a0,-40(s0)
    800146e4:	fcb43823          	sd	a1,-48(s0)
    num *= size;
    800146e8:	fd843703          	ld	a4,-40(s0)
    800146ec:	fd043783          	ld	a5,-48(s0)
    800146f0:	02f707b3          	mul	a5,a4,a5
    800146f4:	fcf43c23          	sd	a5,-40(s0)
    Block *block = alloc_block(num);
    800146f8:	fd843503          	ld	a0,-40(s0)
    800146fc:	d33ff0ef          	jal	ra,8001442e <alloc_block>
    80014700:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80014704:	fe843783          	ld	a5,-24(s0)
    80014708:	c385                	beqz	a5,80014728 <calloc+0x50>
        memset(block->addr, 0, num);
    8001470a:	fe843783          	ld	a5,-24(s0)
    8001470e:	639c                	ld	a5,0(a5)
    80014710:	fd843703          	ld	a4,-40(s0)
    80014714:	2701                	sext.w	a4,a4
    80014716:	863a                	mv	a2,a4
    80014718:	4581                	li	a1,0
    8001471a:	853e                	mv	a0,a5
    8001471c:	316030ef          	jal	ra,80017a32 <memset>
        return block->addr;
    80014720:	fe843783          	ld	a5,-24(s0)
    80014724:	639c                	ld	a5,0(a5)
    80014726:	a011                	j	8001472a <calloc+0x52>
    }
    return NULL;
    80014728:	4781                	li	a5,0
}
    8001472a:	853e                	mv	a0,a5
    8001472c:	70a2                	ld	ra,40(sp)
    8001472e:	7402                	ld	s0,32(sp)
    80014730:	6145                	addi	sp,sp,48
    80014732:	8082                	ret

0000000080014734 <count_blocks>:

static size_t count_blocks(Block *ptr)
{
    80014734:	7179                	addi	sp,sp,-48
    80014736:	f422                	sd	s0,40(sp)
    80014738:	1800                	addi	s0,sp,48
    8001473a:	fca43c23          	sd	a0,-40(s0)
    size_t num = 0;
    8001473e:	fe043423          	sd	zero,-24(s0)
    while (ptr != NULL) {
    80014742:	a819                	j	80014758 <count_blocks+0x24>
        num++;
    80014744:	fe843783          	ld	a5,-24(s0)
    80014748:	0785                	addi	a5,a5,1
    8001474a:	fef43423          	sd	a5,-24(s0)
        ptr = ptr->next;
    8001474e:	fd843783          	ld	a5,-40(s0)
    80014752:	679c                	ld	a5,8(a5)
    80014754:	fcf43c23          	sd	a5,-40(s0)
    while (ptr != NULL) {
    80014758:	fd843783          	ld	a5,-40(s0)
    8001475c:	f7e5                	bnez	a5,80014744 <count_blocks+0x10>
    }
    return num;
    8001475e:	fe843783          	ld	a5,-24(s0)
}
    80014762:	853e                	mv	a0,a5
    80014764:	7422                	ld	s0,40(sp)
    80014766:	6145                	addi	sp,sp,48
    80014768:	8082                	ret

000000008001476a <heap_num_free>:
static size_t heap_num_free()
{
    8001476a:	1141                	addi	sp,sp,-16
    8001476c:	e406                	sd	ra,8(sp)
    8001476e:	e022                	sd	s0,0(sp)
    80014770:	0800                	addi	s0,sp,16
    return count_blocks(heap->free);
    80014772:	00006797          	auipc	a5,0x6
    80014776:	8f678793          	addi	a5,a5,-1802 # 8001a068 <heap>
    8001477a:	639c                	ld	a5,0(a5)
    8001477c:	639c                	ld	a5,0(a5)
    8001477e:	853e                	mv	a0,a5
    80014780:	fb5ff0ef          	jal	ra,80014734 <count_blocks>
    80014784:	87aa                	mv	a5,a0
}
    80014786:	853e                	mv	a0,a5
    80014788:	60a2                	ld	ra,8(sp)
    8001478a:	6402                	ld	s0,0(sp)
    8001478c:	0141                	addi	sp,sp,16
    8001478e:	8082                	ret

0000000080014790 <heap_num_used>:
static size_t heap_num_used()
{
    80014790:	1141                	addi	sp,sp,-16
    80014792:	e406                	sd	ra,8(sp)
    80014794:	e022                	sd	s0,0(sp)
    80014796:	0800                	addi	s0,sp,16
    return count_blocks(heap->used);
    80014798:	00006797          	auipc	a5,0x6
    8001479c:	8d078793          	addi	a5,a5,-1840 # 8001a068 <heap>
    800147a0:	639c                	ld	a5,0(a5)
    800147a2:	679c                	ld	a5,8(a5)
    800147a4:	853e                	mv	a0,a5
    800147a6:	f8fff0ef          	jal	ra,80014734 <count_blocks>
    800147aa:	87aa                	mv	a5,a0
}
    800147ac:	853e                	mv	a0,a5
    800147ae:	60a2                	ld	ra,8(sp)
    800147b0:	6402                	ld	s0,0(sp)
    800147b2:	0141                	addi	sp,sp,16
    800147b4:	8082                	ret

00000000800147b6 <heap_num_fresh>:
static size_t heap_num_fresh()
{
    800147b6:	1141                	addi	sp,sp,-16
    800147b8:	e406                	sd	ra,8(sp)
    800147ba:	e022                	sd	s0,0(sp)
    800147bc:	0800                	addi	s0,sp,16
    return count_blocks(heap->fresh);
    800147be:	00006797          	auipc	a5,0x6
    800147c2:	8aa78793          	addi	a5,a5,-1878 # 8001a068 <heap>
    800147c6:	639c                	ld	a5,0(a5)
    800147c8:	6b9c                	ld	a5,16(a5)
    800147ca:	853e                	mv	a0,a5
    800147cc:	f69ff0ef          	jal	ra,80014734 <count_blocks>
    800147d0:	87aa                	mv	a5,a0
}
    800147d2:	853e                	mv	a0,a5
    800147d4:	60a2                	ld	ra,8(sp)
    800147d6:	6402                	ld	s0,0(sp)
    800147d8:	0141                	addi	sp,sp,16
    800147da:	8082                	ret

00000000800147dc <heap_check>:
static bool heap_check()
{
    800147dc:	1101                	addi	sp,sp,-32
    800147de:	ec06                	sd	ra,24(sp)
    800147e0:	e822                	sd	s0,16(sp)
    800147e2:	e426                	sd	s1,8(sp)
    800147e4:	1000                	addi	s0,sp,32
    return heap_max_blocks == heap_num_free() + heap_num_used() + heap_num_fresh();
    800147e6:	f85ff0ef          	jal	ra,8001476a <heap_num_free>
    800147ea:	84aa                	mv	s1,a0
    800147ec:	fa5ff0ef          	jal	ra,80014790 <heap_num_used>
    800147f0:	87aa                	mv	a5,a0
    800147f2:	94be                	add	s1,s1,a5
    800147f4:	fc3ff0ef          	jal	ra,800147b6 <heap_num_fresh>
    800147f8:	87aa                	mv	a5,a0
    800147fa:	00f48733          	add	a4,s1,a5
    800147fe:	00006797          	auipc	a5,0x6
    80014802:	88a78793          	addi	a5,a5,-1910 # 8001a088 <heap_max_blocks>
    80014806:	639c                	ld	a5,0(a5)
    80014808:	40f707b3          	sub	a5,a4,a5
    8001480c:	0017b793          	seqz	a5,a5
    80014810:	0ff7f793          	andi	a5,a5,255
}
    80014814:	853e                	mv	a0,a5
    80014816:	60e2                	ld	ra,24(sp)
    80014818:	6442                	ld	s0,16(sp)
    8001481a:	64a2                	ld	s1,8(sp)
    8001481c:	6105                	addi	sp,sp,32
    8001481e:	8082                	ret

0000000080014820 <heap_print_stats>:

void heap_print_stats(void)
{
    80014820:	7179                	addi	sp,sp,-48
    80014822:	f406                	sd	ra,40(sp)
    80014824:	f022                	sd	s0,32(sp)
    80014826:	ec26                	sd	s1,24(sp)
    80014828:	e84a                	sd	s2,16(sp)
    8001482a:	e44e                	sd	s3,8(sp)
    8001482c:	1800                	addi	s0,sp,48
    debugf(
    8001482e:	f3dff0ef          	jal	ra,8001476a <heap_num_free>
    80014832:	84aa                	mv	s1,a0
    80014834:	f5dff0ef          	jal	ra,80014790 <heap_num_used>
    80014838:	892a                	mv	s2,a0
    8001483a:	f7dff0ef          	jal	ra,800147b6 <heap_num_fresh>
    8001483e:	89aa                	mv	s3,a0
        "HEAP\n~~~~\nFree blocks:    %lu\nUsed blocks:    %lu\nFresh blocks:   %lu\nHeap "
        "check:     %s\n",
        heap_num_free(), heap_num_used(), heap_num_fresh(), heap_check() ? "good" : "bad");
    80014840:	f9dff0ef          	jal	ra,800147dc <heap_check>
    80014844:	87aa                	mv	a5,a0
    debugf(
    80014846:	c791                	beqz	a5,80014852 <heap_print_stats+0x32>
    80014848:	00007797          	auipc	a5,0x7
    8001484c:	44078793          	addi	a5,a5,1088 # 8001bc88 <pow10.0+0xa58>
    80014850:	a029                	j	8001485a <heap_print_stats+0x3a>
    80014852:	00007797          	auipc	a5,0x7
    80014856:	43e78793          	addi	a5,a5,1086 # 8001bc90 <pow10.0+0xa60>
    8001485a:	873e                	mv	a4,a5
    8001485c:	86ce                	mv	a3,s3
    8001485e:	864a                	mv	a2,s2
    80014860:	85a6                	mv	a1,s1
    80014862:	00007517          	auipc	a0,0x7
    80014866:	43650513          	addi	a0,a0,1078 # 8001bc98 <pow10.0+0xa68>
    8001486a:	5b1000ef          	jal	ra,8001561a <debugf>
}
    8001486e:	0001                	nop
    80014870:	70a2                	ld	ra,40(sp)
    80014872:	7402                	ld	s0,32(sp)
    80014874:	64e2                	ld	s1,24(sp)
    80014876:	6942                	ld	s2,16(sp)
    80014878:	69a2                	ld	s3,8(sp)
    8001487a:	6145                	addi	sp,sp,48
    8001487c:	8082                	ret

000000008001487e <kmalloc>:
void *kmalloc(size_t sz)
{
    8001487e:	1101                	addi	sp,sp,-32
    80014880:	ec06                	sd	ra,24(sp)
    80014882:	e822                	sd	s0,16(sp)
    80014884:	1000                	addi	s0,sp,32
    80014886:	fea43423          	sd	a0,-24(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kmalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return alloc(sz);
    8001488a:	fe843503          	ld	a0,-24(s0)
    8001488e:	e19ff0ef          	jal	ra,800146a6 <alloc>
    80014892:	87aa                	mv	a5,a0
}
    80014894:	853e                	mv	a0,a5
    80014896:	60e2                	ld	ra,24(sp)
    80014898:	6442                	ld	s0,16(sp)
    8001489a:	6105                	addi	sp,sp,32
    8001489c:	8082                	ret

000000008001489e <kcalloc>:
void *kcalloc(size_t n, size_t sz)
{
    8001489e:	1101                	addi	sp,sp,-32
    800148a0:	ec06                	sd	ra,24(sp)
    800148a2:	e822                	sd	s0,16(sp)
    800148a4:	1000                	addi	s0,sp,32
    800148a6:	fea43423          	sd	a0,-24(s0)
    800148aa:	feb43023          	sd	a1,-32(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kcalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return calloc(n, sz);
    800148ae:	fe043583          	ld	a1,-32(s0)
    800148b2:	fe843503          	ld	a0,-24(s0)
    800148b6:	e23ff0ef          	jal	ra,800146d8 <calloc>
    800148ba:	87aa                	mv	a5,a0
}
    800148bc:	853e                	mv	a0,a5
    800148be:	60e2                	ld	ra,24(sp)
    800148c0:	6442                	ld	s0,16(sp)
    800148c2:	6105                	addi	sp,sp,32
    800148c4:	8082                	ret

00000000800148c6 <kfree>:
void kfree(void *m)
{
    800148c6:	1101                	addi	sp,sp,-32
    800148c8:	ec06                	sd	ra,24(sp)
    800148ca:	e822                	sd	s0,16(sp)
    800148cc:	1000                	addi	s0,sp,32
    800148ce:	fea43423          	sd	a0,-24(s0)
    if (m != NULL) {
    800148d2:	fe843783          	ld	a5,-24(s0)
    800148d6:	c789                	beqz	a5,800148e0 <kfree+0x1a>
        free(m);
    800148d8:	fe843503          	ld	a0,-24(s0)
    800148dc:	ac9ff0ef          	jal	ra,800143a4 <free>
    }
#ifdef DEBUG_KMALLOC
    debugf("[kfree]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
}
    800148e0:	0001                	nop
    800148e2:	60e2                	ld	ra,24(sp)
    800148e4:	6442                	ld	s0,16(sp)
    800148e6:	6105                	addi	sp,sp,32
    800148e8:	8082                	ret

00000000800148ea <heap_init>:

void heap_init(void)
{
    800148ea:	1101                	addi	sp,sp,-32
    800148ec:	ec06                	sd	ra,24(sp)
    800148ee:	e822                	sd	s0,16(sp)
    800148f0:	1000                	addi	s0,sp,32
#ifdef DEBUG_HEAP
    debugf("[heap_init]: Prior to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif
    void *start = page_znalloc(KERNEL_HEAP_PAGES);
    800148f2:	6505                	lui	a0,0x1
    800148f4:	578020ef          	jal	ra,80016e6c <page_znalloc>
    800148f8:	fea43423          	sd	a0,-24(s0)
    debugf("[heap_init]: Heap start at 0x%08lx\n", start);
    debugf("[heap_init]: After to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif

    mmu_map_range(kernel_mmu_table, KERNEL_HEAP_START_VADDR, KERNEL_HEAP_END_VADDR, (uint64_t)start,
    800148fc:	00005797          	auipc	a5,0x5
    80014900:	70478793          	addi	a5,a5,1796 # 8001a000 <kernel_mmu_table>
    80014904:	6388                	ld	a0,0(a5)
    80014906:	fe843683          	ld	a3,-24(s0)
    8001490a:	4799                	li	a5,6
    8001490c:	4701                	li	a4,0
    8001490e:	00e08637          	lui	a2,0xe08
    80014912:	7f760613          	addi	a2,a2,2039 # e087f7 <i+0xe087d7>
    80014916:	0636                	slli	a2,a2,0xd
    80014918:	00e085b7          	lui	a1,0xe08
    8001491c:	15dd                	addi	a1,a1,-9
    8001491e:	05b6                	slli	a1,a1,0xd
    80014920:	cb6ff0ef          	jal	ra,80013dd6 <mmu_map_range>
                  MMU_LEVEL_4K, PB_READ | PB_WRITE);
    init((void *)KERNEL_HEAP_START_VADDR, (void *)KERNEL_HEAP_END_VADDR, KERNEL_HEAP_PAGES / 4, 16,
    80014924:	4721                	li	a4,8
    80014926:	46c1                	li	a3,16
    80014928:	40000613          	li	a2,1024
    8001492c:	00e087b7          	lui	a5,0xe08
    80014930:	7f778793          	addi	a5,a5,2039 # e087f7 <i+0xe087d7>
    80014934:	00d79593          	slli	a1,a5,0xd
    80014938:	00e087b7          	lui	a5,0xe08
    8001493c:	17dd                	addi	a5,a5,-9
    8001493e:	00d79513          	slli	a0,a5,0xd
    80014942:	94bff0ef          	jal	ra,8001428c <init>
         8);

}
    80014946:	0001                	nop
    80014948:	60e2                	ld	ra,24(sp)
    8001494a:	6442                	ld	s0,16(sp)
    8001494c:	6105                	addi	sp,sp,32
    8001494e:	8082                	ret

0000000080014950 <init_systems>:
// the kernel.
// Defined in src/include/mmu.h
struct page_table *kernel_mmu_table;

static void init_systems(void)
{
    80014950:	715d                	addi	sp,sp,-80
    80014952:	e486                	sd	ra,72(sp)
    80014954:	e0a2                	sd	s0,64(sp)
    80014956:	0880                	addi	s0,sp,80
    void plic_init(void);
    plic_init();
    80014958:	286010ef          	jal	ra,80015bde <plic_init>
    debugf("plic_init() done\n");
    8001495c:	00007517          	auipc	a0,0x7
    80014960:	39c50513          	addi	a0,a0,924 # 8001bcf8 <pow10.0+0xac8>
    80014964:	4b7000ef          	jal	ra,8001561a <debugf>
    void page_init(void);
    page_init();
    80014968:	10c020ef          	jal	ra,80016a74 <page_init>
    debugf("page_init() done\n");
    8001496c:	00007517          	auipc	a0,0x7
    80014970:	3a450513          	addi	a0,a0,932 # 8001bd10 <pow10.0+0xae0>
    80014974:	4a7000ef          	jal	ra,8001561a <debugf>

#ifdef USE_MMU
    struct page_table *pt = mmu_table_create();
    80014978:	830ff0ef          	jal	ra,800139a8 <mmu_table_create>
    8001497c:	fca43c23          	sd	a0,-40(s0)
    kernel_mmu_table = pt;
    80014980:	00005797          	auipc	a5,0x5
    80014984:	68078793          	addi	a5,a5,1664 # 8001a000 <kernel_mmu_table>
    80014988:	fd843703          	ld	a4,-40(s0)
    8001498c:	e398                	sd	a4,0(a5)

    debugf("Kernel page table at %p\n", pt);
    8001498e:	fd843583          	ld	a1,-40(s0)
    80014992:	00007517          	auipc	a0,0x7
    80014996:	39650513          	addi	a0,a0,918 # 8001bd28 <pow10.0+0xaf8>
    8001499a:	481000ef          	jal	ra,8001561a <debugf>
    // Map memory segments for our kernel
    debugf("Mapping kernel segments\n");
    8001499e:	00007517          	auipc	a0,0x7
    800149a2:	3aa50513          	addi	a0,a0,938 # 8001bd48 <pow10.0+0xb18>
    800149a6:	475000ef          	jal	ra,8001561a <debugf>
    mmu_map_range(pt, sym_start(text), sym_end(heap), sym_start(text), MMU_LEVEL_1G,
    800149aa:	ffffb597          	auipc	a1,0xffffb
    800149ae:	65658593          	addi	a1,a1,1622 # 80010000 <_memory_start>
    800149b2:	07ffb617          	auipc	a2,0x7ffb
    800149b6:	64e60613          	addi	a2,a2,1614 # 88010000 <_heap_end>
    800149ba:	ffffb697          	auipc	a3,0xffffb
    800149be:	64668693          	addi	a3,a3,1606 # 80010000 <_memory_start>
    800149c2:	47b9                	li	a5,14
    800149c4:	4709                	li	a4,2
    800149c6:	fd843503          	ld	a0,-40(s0)
    800149ca:	c0cff0ef          	jal	ra,80013dd6 <mmu_map_range>
                  PB_READ | PB_WRITE | PB_EXECUTE);
    // PLIC
    debugf("Mapping PLIC\n");
    800149ce:	00007517          	auipc	a0,0x7
    800149d2:	39a50513          	addi	a0,a0,922 # 8001bd68 <pow10.0+0xb38>
    800149d6:	445000ef          	jal	ra,8001561a <debugf>
    mmu_map_range(pt, 0x0C000000, 0x0C2FFFFF, 0x0C000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    800149da:	4799                	li	a5,6
    800149dc:	4705                	li	a4,1
    800149de:	0c0006b7          	lui	a3,0xc000
    800149e2:	0c300637          	lui	a2,0xc300
    800149e6:	167d                	addi	a2,a2,-1
    800149e8:	0c0005b7          	lui	a1,0xc000
    800149ec:	fd843503          	ld	a0,-40(s0)
    800149f0:	be6ff0ef          	jal	ra,80013dd6 <mmu_map_range>
    // PCIe ECAM
    debugf("Mapping PCIe ECAM\n");
    800149f4:	00007517          	auipc	a0,0x7
    800149f8:	38450513          	addi	a0,a0,900 # 8001bd78 <pow10.0+0xb48>
    800149fc:	41f000ef          	jal	ra,8001561a <debugf>
    mmu_map_range(pt, 0x30000000, 0x3FFFFFFF, 0x30000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80014a00:	4799                	li	a5,6
    80014a02:	4705                	li	a4,1
    80014a04:	300006b7          	lui	a3,0x30000
    80014a08:	40000637          	lui	a2,0x40000
    80014a0c:	167d                	addi	a2,a2,-1
    80014a0e:	300005b7          	lui	a1,0x30000
    80014a12:	fd843503          	ld	a0,-40(s0)
    80014a16:	bc0ff0ef          	jal	ra,80013dd6 <mmu_map_range>
    // PCIe MMIO
    debugf("Mapping PCIe MMIO\n");
    80014a1a:	00007517          	auipc	a0,0x7
    80014a1e:	37650513          	addi	a0,a0,886 # 8001bd90 <pow10.0+0xb60>
    80014a22:	3f9000ef          	jal	ra,8001561a <debugf>
    mmu_map_range(pt, 0x40000000, 0x5FFFFFFF, 0x40000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80014a26:	4799                	li	a5,6
    80014a28:	4705                	li	a4,1
    80014a2a:	400006b7          	lui	a3,0x40000
    80014a2e:	60000637          	lui	a2,0x60000
    80014a32:	167d                	addi	a2,a2,-1
    80014a34:	400005b7          	lui	a1,0x40000
    80014a38:	fd843503          	ld	a0,-40(s0)
    80014a3c:	b9aff0ef          	jal	ra,80013dd6 <mmu_map_range>
    //                    uint64_t start_virt, 
    //                    uint64_t end_virt, 
    //                    uint64_t start_phys)
    // debug_page_table(pt, MMU_LEVEL_1G);

    debugf("About to set SATP to %016lx\n", SATP_KERNEL);
    80014a40:	00005797          	auipc	a5,0x5
    80014a44:	5c078793          	addi	a5,a5,1472 # 8001a000 <kernel_mmu_table>
    80014a48:	639c                	ld	a5,0(a5)
    80014a4a:	00c7d713          	srli	a4,a5,0xc
    80014a4e:	57fd                	li	a5,-1
    80014a50:	83d1                	srli	a5,a5,0x14
    80014a52:	8f7d                	and	a4,a4,a5
    80014a54:	8ffff7b7          	lui	a5,0x8ffff
    80014a58:	1782                	slli	a5,a5,0x20
    80014a5a:	8fd9                	or	a5,a5,a4
    80014a5c:	85be                	mv	a1,a5
    80014a5e:	00007517          	auipc	a0,0x7
    80014a62:	34a50513          	addi	a0,a0,842 # 8001bda8 <pow10.0+0xb78>
    80014a66:	3b5000ef          	jal	ra,8001561a <debugf>
    // TODO: turn on the MMU when you've written the src/mmu.c functions
    CSR_WRITE("satp", SATP_KERNEL); 
    80014a6a:	00005797          	auipc	a5,0x5
    80014a6e:	59678793          	addi	a5,a5,1430 # 8001a000 <kernel_mmu_table>
    80014a72:	639c                	ld	a5,0(a5)
    80014a74:	00c7d713          	srli	a4,a5,0xc
    80014a78:	57fd                	li	a5,-1
    80014a7a:	83d1                	srli	a5,a5,0x14
    80014a7c:	8f7d                	and	a4,a4,a5
    80014a7e:	8ffff7b7          	lui	a5,0x8ffff
    80014a82:	1782                	slli	a5,a5,0x20
    80014a84:	8fd9                	or	a5,a5,a4
    80014a86:	18079073          	csrw	satp,a5
    SFENCE_ALL();
    80014a8a:	12000073          	sfence.vma
    debugf("MMU enabled\n");
    80014a8e:	00007517          	auipc	a0,0x7
    80014a92:	33a50513          	addi	a0,a0,826 # 8001bdc8 <pow10.0+0xb98>
    80014a96:	385000ef          	jal	ra,8001561a <debugf>
    void *kcalloc(uint64_t elem, uint64_t size);
    void kfree(void *ptr);
    void util_connect_galloc(void *(*malloc)(uint64_t size),
                             void *(*calloc)(uint64_t elem, uint64_t size),
                             void (*free)(void *ptr));
    util_connect_galloc(kmalloc, kcalloc, kfree);
    80014a9a:	00000617          	auipc	a2,0x0
    80014a9e:	e2c60613          	addi	a2,a2,-468 # 800148c6 <kfree>
    80014aa2:	00000597          	auipc	a1,0x0
    80014aa6:	dfc58593          	addi	a1,a1,-516 # 8001489e <kcalloc>
    80014aaa:	00000517          	auipc	a0,0x0
    80014aae:	dd450513          	addi	a0,a0,-556 # 8001487e <kmalloc>
    80014ab2:	0d7020ef          	jal	ra,80017388 <util_connect_galloc>
    heap_init();
    80014ab6:	e35ff0ef          	jal	ra,800148ea <heap_init>
    debugf("heap_init() done\n");
    80014aba:	00007517          	auipc	a0,0x7
    80014abe:	31e50513          	addi	a0,a0,798 # 8001bdd8 <pow10.0+0xba8>
    80014ac2:	359000ef          	jal	ra,8001561a <debugf>

    // Call kmalloc() here to ensure it works.
    void *ptr = kmalloc(1024);
    80014ac6:	40000513          	li	a0,1024
    80014aca:	db5ff0ef          	jal	ra,8001487e <kmalloc>
    80014ace:	fca43823          	sd	a0,-48(s0)
    strcpy(ptr, "Hello, world!");
    80014ad2:	00007597          	auipc	a1,0x7
    80014ad6:	31e58593          	addi	a1,a1,798 # 8001bdf0 <pow10.0+0xbc0>
    80014ada:	fd043503          	ld	a0,-48(s0)
    80014ade:	720030ef          	jal	ra,800181fe <strcpy>
    debugf("kmalloc(1024) = %p\n", ptr);
    80014ae2:	fd043583          	ld	a1,-48(s0)
    80014ae6:	00007517          	auipc	a0,0x7
    80014aea:	31a50513          	addi	a0,a0,794 # 8001be00 <pow10.0+0xbd0>
    80014aee:	32d000ef          	jal	ra,8001561a <debugf>
    debugf("kmalloc(1024) = %s\n", ptr);
    80014af2:	fd043583          	ld	a1,-48(s0)
    80014af6:	00007517          	auipc	a0,0x7
    80014afa:	32250513          	addi	a0,a0,802 # 8001be18 <pow10.0+0xbe8>
    80014afe:	31d000ef          	jal	ra,8001561a <debugf>
    kfree(ptr);
    80014b02:	fd043503          	ld	a0,-48(s0)
    80014b06:	dc1ff0ef          	jal	ra,800148c6 <kfree>
#endif
#ifdef USE_PCI
    pci_init();
    80014b0a:	c97fe0ef          	jal	ra,800137a0 <pci_init>
#endif
#ifdef USE_VIRTIO
    virtio_init();
    80014b0e:	414010ef          	jal	ra,80015f22 <virtio_init>
    uint64_t stvec = trampoline_trap_start;
    80014b12:	00008797          	auipc	a5,0x8
    80014b16:	59778793          	addi	a5,a5,1431 # 8001d0a9 <trampoline_trap_start>
    80014b1a:	639c                	ld	a5,0(a5)
    80014b1c:	fcf43423          	sd	a5,-56(s0)
    // # 552  - stvec
    // # 560  - trap_satp
    // # 568  - trap_stack
    // trampoline_thread_start();

    stvec &= ~0x3;
    80014b20:	fc843783          	ld	a5,-56(s0)
    80014b24:	9bf1                	andi	a5,a5,-4
    80014b26:	fcf43423          	sd	a5,-56(s0)
    CSR_WRITE("stvec", trampoline_trap_start);
    80014b2a:	00008797          	auipc	a5,0x8
    80014b2e:	57f78793          	addi	a5,a5,1407 # 8001d0a9 <trampoline_trap_start>
    80014b32:	639c                	ld	a5,0(a5)
    80014b34:	10579073          	csrw	stvec,a5
    debugf("STVEC: 0x%p, 0x%p\n", stvec, trampoline_trap_start);
    80014b38:	00008797          	auipc	a5,0x8
    80014b3c:	57178793          	addi	a5,a5,1393 # 8001d0a9 <trampoline_trap_start>
    80014b40:	639c                	ld	a5,0(a5)
    80014b42:	863e                	mv	a2,a5
    80014b44:	fc843583          	ld	a1,-56(s0)
    80014b48:	00007517          	auipc	a0,0x7
    80014b4c:	2e850513          	addi	a0,a0,744 # 8001be30 <pow10.0+0xc00>
    80014b50:	2cb000ef          	jal	ra,8001561a <debugf>

    Trapframe *sscratch = kzalloc(sizeof(Trapframe) * 0x1000);
    80014b54:	002405b7          	lui	a1,0x240
    80014b58:	4505                	li	a0,1
    80014b5a:	d45ff0ef          	jal	ra,8001489e <kcalloc>
    80014b5e:	fca43023          	sd	a0,-64(s0)
    
    CSR_READ(sscratch->sepc, "sepc");
    80014b62:	14102773          	csrr	a4,sepc
    80014b66:	fc043783          	ld	a5,-64(s0)
    80014b6a:	20e7b023          	sd	a4,512(a5)
    CSR_READ(sscratch->sstatus, "sstatus");
    80014b6e:	10002773          	csrr	a4,sstatus
    80014b72:	fc043783          	ld	a5,-64(s0)
    80014b76:	20e7b423          	sd	a4,520(a5)
    CSR_READ(sscratch->sie, "sie");
    80014b7a:	10402773          	csrr	a4,sie
    80014b7e:	fc043783          	ld	a5,-64(s0)
    80014b82:	20e7b823          	sd	a4,528(a5)
    CSR_READ(sscratch->satp, "satp");
    80014b86:	18002773          	csrr	a4,satp
    80014b8a:	fc043783          	ld	a5,-64(s0)
    80014b8e:	20e7bc23          	sd	a4,536(a5)
    CSR_READ(sscratch->stvec, "stvec");
    80014b92:	10502773          	csrr	a4,stvec
    80014b96:	fc043783          	ld	a5,-64(s0)
    80014b9a:	22e7b423          	sd	a4,552(a5)
    CSR_READ(sscratch->trap_satp, "satp");
    80014b9e:	18002773          	csrr	a4,satp
    80014ba2:	fc043783          	ld	a5,-64(s0)
    80014ba6:	22e7b823          	sd	a4,560(a5)
    sscratch->trap_stack = (uint64_t)kmalloc(0x4000);
    80014baa:	6511                	lui	a0,0x4
    80014bac:	cd3ff0ef          	jal	ra,8001487e <kmalloc>
    80014bb0:	87aa                	mv	a5,a0
    80014bb2:	873e                	mv	a4,a5
    80014bb4:	fc043783          	ld	a5,-64(s0)
    80014bb8:	22e7bc23          	sd	a4,568(a5)
    CSR_WRITE("sscratch", sscratch);
    80014bbc:	fc043783          	ld	a5,-64(s0)
    80014bc0:	14079073          	csrw	sscratch,a5

    uint8_t buffer[16] = {0};
    80014bc4:	fa043823          	sd	zero,-80(s0)
    80014bc8:	fa043c23          	sd	zero,-72(s0)
    debugf("RNG State Before:");
    80014bcc:	00007517          	auipc	a0,0x7
    80014bd0:	27c50513          	addi	a0,a0,636 # 8001be48 <pow10.0+0xc18>
    80014bd4:	247000ef          	jal	ra,8001561a <debugf>
    for (int i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80014bd8:	fe042623          	sw	zero,-20(s0)
    80014bdc:	a02d                	j	80014c06 <init_systems+0x2b6>
        debugf(" %d ", buffer[i]);
    80014bde:	fec42783          	lw	a5,-20(s0)
    80014be2:	ff040713          	addi	a4,s0,-16
    80014be6:	97ba                	add	a5,a5,a4
    80014be8:	fc07c783          	lbu	a5,-64(a5)
    80014bec:	2781                	sext.w	a5,a5
    80014bee:	85be                	mv	a1,a5
    80014bf0:	00007517          	auipc	a0,0x7
    80014bf4:	27050513          	addi	a0,a0,624 # 8001be60 <pow10.0+0xc30>
    80014bf8:	223000ef          	jal	ra,8001561a <debugf>
    for (int i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80014bfc:	fec42783          	lw	a5,-20(s0)
    80014c00:	2785                	addiw	a5,a5,1
    80014c02:	fef42623          	sw	a5,-20(s0)
    80014c06:	fec42783          	lw	a5,-20(s0)
    80014c0a:	873e                	mv	a4,a5
    80014c0c:	47bd                	li	a5,15
    80014c0e:	fce7f8e3          	bgeu	a5,a4,80014bde <init_systems+0x28e>
    }
    debugf("\n");
    80014c12:	00007517          	auipc	a0,0x7
    80014c16:	25650513          	addi	a0,a0,598 # 8001be68 <pow10.0+0xc38>
    80014c1a:	201000ef          	jal	ra,8001561a <debugf>

    debugf("RNG init done; about to fill\n");
    80014c1e:	00007517          	auipc	a0,0x7
    80014c22:	25250513          	addi	a0,a0,594 # 8001be70 <pow10.0+0xc40>
    80014c26:	1f5000ef          	jal	ra,8001561a <debugf>
    rng_fill(buffer, 16);
    80014c2a:	fb040793          	addi	a5,s0,-80
    80014c2e:	45c1                	li	a1,16
    80014c30:	853e                	mv	a0,a5
    80014c32:	a65fd0ef          	jal	ra,80012696 <rng_fill>
    debugf("RNG State After:");
    80014c36:	00007517          	auipc	a0,0x7
    80014c3a:	25a50513          	addi	a0,a0,602 # 8001be90 <pow10.0+0xc60>
    80014c3e:	1dd000ef          	jal	ra,8001561a <debugf>
    for (int i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80014c42:	fe042423          	sw	zero,-24(s0)
    80014c46:	a02d                	j	80014c70 <init_systems+0x320>
        debugf(" %d ", buffer[i]);
    80014c48:	fe842783          	lw	a5,-24(s0)
    80014c4c:	ff040713          	addi	a4,s0,-16
    80014c50:	97ba                	add	a5,a5,a4
    80014c52:	fc07c783          	lbu	a5,-64(a5)
    80014c56:	2781                	sext.w	a5,a5
    80014c58:	85be                	mv	a1,a5
    80014c5a:	00007517          	auipc	a0,0x7
    80014c5e:	20650513          	addi	a0,a0,518 # 8001be60 <pow10.0+0xc30>
    80014c62:	1b9000ef          	jal	ra,8001561a <debugf>
    for (int i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80014c66:	fe842783          	lw	a5,-24(s0)
    80014c6a:	2785                	addiw	a5,a5,1
    80014c6c:	fef42423          	sw	a5,-24(s0)
    80014c70:	fe842783          	lw	a5,-24(s0)
    80014c74:	873e                	mv	a4,a5
    80014c76:	47bd                	li	a5,15
    80014c78:	fce7f8e3          	bgeu	a5,a4,80014c48 <init_systems+0x2f8>
    }
    
    rng_fill(buffer, 16);
    80014c7c:	fb040793          	addi	a5,s0,-80
    80014c80:	45c1                	li	a1,16
    80014c82:	853e                	mv	a0,a5
    80014c84:	a13fd0ef          	jal	ra,80012696 <rng_fill>
    for (int i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80014c88:	fe042223          	sw	zero,-28(s0)
    80014c8c:	a02d                	j	80014cb6 <init_systems+0x366>
        debugf(" %d ", buffer[i]);
    80014c8e:	fe442783          	lw	a5,-28(s0)
    80014c92:	ff040713          	addi	a4,s0,-16
    80014c96:	97ba                	add	a5,a5,a4
    80014c98:	fc07c783          	lbu	a5,-64(a5)
    80014c9c:	2781                	sext.w	a5,a5
    80014c9e:	85be                	mv	a1,a5
    80014ca0:	00007517          	auipc	a0,0x7
    80014ca4:	1c050513          	addi	a0,a0,448 # 8001be60 <pow10.0+0xc30>
    80014ca8:	173000ef          	jal	ra,8001561a <debugf>
    for (int i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80014cac:	fe442783          	lw	a5,-28(s0)
    80014cb0:	2785                	addiw	a5,a5,1
    80014cb2:	fef42223          	sw	a5,-28(s0)
    80014cb6:	fe442783          	lw	a5,-28(s0)
    80014cba:	873e                	mv	a4,a5
    80014cbc:	47bd                	li	a5,15
    80014cbe:	fce7f8e3          	bgeu	a5,a4,80014c8e <init_systems+0x33e>
    // bytes[1], 
    // bytes[2], 
    // bytes[3], 
    // bytes[4]);
#endif
}
    80014cc2:	0001                	nop
    80014cc4:	0001                	nop
    80014cc6:	60a6                	ld	ra,72(sp)
    80014cc8:	6406                	ld	s0,64(sp)
    80014cca:	6161                	addi	sp,sp,80
    80014ccc:	8082                	ret

0000000080014cce <main>:
static const char *hart_status_values[] = {"NOT PRESENT", "STOPPED", "STARTING", "RUNNING"};
#ifdef RUN_INTERNAL_CONSOLE
static void console(void);
#endif
void main(unsigned int hart)
{
    80014cce:	7179                	addi	sp,sp,-48
    80014cd0:	f406                	sd	ra,40(sp)
    80014cd2:	f022                	sd	s0,32(sp)
    80014cd4:	1800                	addi	s0,sp,48
    80014cd6:	87aa                	mv	a5,a0
    80014cd8:	fcf42e23          	sw	a5,-36(s0)
    // Initialize the page allocator
    // Allocate and zero the kernel's page table.

    // Kind of neat to see our memory mappings to ensure they make sense.
    logf(LOG_INFO, "[[ MEMORY MAPPINGS ]]\n");
    80014cdc:	00007597          	auipc	a1,0x7
    80014ce0:	1fc58593          	addi	a1,a1,508 # 8001bed8 <pow10.0+0xca8>
    80014ce4:	4511                	li	a0,4
    80014ce6:	0d7000ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  [TEXT]  : 0x%08lx -> 0x%08lx\n", sym_start(text), sym_end(text));
    80014cea:	ffffb797          	auipc	a5,0xffffb
    80014cee:	31678793          	addi	a5,a5,790 # 80010000 <_memory_start>
    80014cf2:	00004717          	auipc	a4,0x4
    80014cf6:	27070713          	addi	a4,a4,624 # 80018f62 <_text_end>
    80014cfa:	86ba                	mv	a3,a4
    80014cfc:	863e                	mv	a2,a5
    80014cfe:	00007597          	auipc	a1,0x7
    80014d02:	1f258593          	addi	a1,a1,498 # 8001bef0 <pow10.0+0xcc0>
    80014d06:	4511                	li	a0,4
    80014d08:	0b5000ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  [BSS]   : 0x%08lx -> 0x%08lx\n", sym_start(bss), sym_end(bss));
    80014d0c:	00005797          	auipc	a5,0x5
    80014d10:	2f478793          	addi	a5,a5,756 # 8001a000 <kernel_mmu_table>
    80014d14:	00005717          	auipc	a4,0x5
    80014d18:	3a470713          	addi	a4,a4,932 # 8001a0b8 <_bss_end>
    80014d1c:	86ba                	mv	a3,a4
    80014d1e:	863e                	mv	a2,a5
    80014d20:	00007597          	auipc	a1,0x7
    80014d24:	1f058593          	addi	a1,a1,496 # 8001bf10 <pow10.0+0xce0>
    80014d28:	4511                	li	a0,4
    80014d2a:	093000ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  [RODATA]: 0x%08lx -> 0x%08lx\n", sym_start(rodata), sym_end(rodata));
    80014d2e:	00006797          	auipc	a5,0x6
    80014d32:	2d278793          	addi	a5,a5,722 # 8001b000 <SYSCALLS>
    80014d36:	00008717          	auipc	a4,0x8
    80014d3a:	38b70713          	addi	a4,a4,907 # 8001d0c1 <_rodata_end>
    80014d3e:	86ba                	mv	a3,a4
    80014d40:	863e                	mv	a2,a5
    80014d42:	00007597          	auipc	a1,0x7
    80014d46:	1ee58593          	addi	a1,a1,494 # 8001bf30 <pow10.0+0xd00>
    80014d4a:	4511                	li	a0,4
    80014d4c:	071000ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  [DATA]  : 0x%08lx -> 0x%08lx\n", sym_start(data), sym_end(data));
    80014d50:	00009797          	auipc	a5,0x9
    80014d54:	2b078793          	addi	a5,a5,688 # 8001e000 <subordinate>
    80014d58:	00009717          	auipc	a4,0x9
    80014d5c:	2d070713          	addi	a4,a4,720 # 8001e028 <_data_end>
    80014d60:	86ba                	mv	a3,a4
    80014d62:	863e                	mv	a2,a5
    80014d64:	00007597          	auipc	a1,0x7
    80014d68:	1ec58593          	addi	a1,a1,492 # 8001bf50 <pow10.0+0xd20>
    80014d6c:	4511                	li	a0,4
    80014d6e:	04f000ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  [STACK] : 0x%08lx -> 0x%08lx\n", sym_start(stack), sym_end(stack));
    80014d72:	0000a797          	auipc	a5,0xa
    80014d76:	28e78793          	addi	a5,a5,654 # 8001f000 <_stack_start>
    80014d7a:	00012717          	auipc	a4,0x12
    80014d7e:	28670713          	addi	a4,a4,646 # 80027000 <_heap_start>
    80014d82:	86ba                	mv	a3,a4
    80014d84:	863e                	mv	a2,a5
    80014d86:	00007597          	auipc	a1,0x7
    80014d8a:	1ea58593          	addi	a1,a1,490 # 8001bf70 <pow10.0+0xd40>
    80014d8e:	4511                	li	a0,4
    80014d90:	02d000ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  [HEAP]  : 0x%08lx -> 0x%08lx\n", sym_start(heap), sym_end(heap));
    80014d94:	00012797          	auipc	a5,0x12
    80014d98:	26c78793          	addi	a5,a5,620 # 80027000 <_heap_start>
    80014d9c:	07ffb717          	auipc	a4,0x7ffb
    80014da0:	26470713          	addi	a4,a4,612 # 88010000 <_heap_end>
    80014da4:	86ba                	mv	a3,a4
    80014da6:	863e                	mv	a2,a5
    80014da8:	00007597          	auipc	a1,0x7
    80014dac:	1e858593          	addi	a1,a1,488 # 8001bf90 <pow10.0+0xd60>
    80014db0:	4511                	li	a0,4
    80014db2:	00b000ef          	jal	ra,800155bc <logf>

    logf(LOG_INFO, "[[ HART MAPPINGS ]]\n");
    80014db6:	00007597          	auipc	a1,0x7
    80014dba:	1fa58593          	addi	a1,a1,506 # 8001bfb0 <pow10.0+0xd80>
    80014dbe:	4511                	li	a0,4
    80014dc0:	7fc000ef          	jal	ra,800155bc <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80014dc4:	fe042623          	sw	zero,-20(s0)
    80014dc8:	a8bd                	j	80014e46 <main+0x178>
        if (i == hart) {
    80014dca:	fec42703          	lw	a4,-20(s0)
    80014dce:	fdc42783          	lw	a5,-36(s0)
    80014dd2:	2701                	sext.w	a4,a4
    80014dd4:	2781                	sext.w	a5,a5
    80014dd6:	02f71b63          	bne	a4,a5,80014e0c <main+0x13e>
            logf(LOG_INFO, "  [HART#%d]: %s (this HART).\n", i, hart_status_values[sbi_hart_get_status(i)]);
    80014dda:	fec42783          	lw	a5,-20(s0)
    80014dde:	853e                	mv	a0,a5
    80014de0:	195000ef          	jal	ra,80015774 <sbi_hart_get_status>
    80014de4:	87aa                	mv	a5,a0
    80014de6:	00009717          	auipc	a4,0x9
    80014dea:	22270713          	addi	a4,a4,546 # 8001e008 <hart_status_values>
    80014dee:	078e                	slli	a5,a5,0x3
    80014df0:	97ba                	add	a5,a5,a4
    80014df2:	6398                	ld	a4,0(a5)
    80014df4:	fec42783          	lw	a5,-20(s0)
    80014df8:	86ba                	mv	a3,a4
    80014dfa:	863e                	mv	a2,a5
    80014dfc:	00007597          	auipc	a1,0x7
    80014e00:	1cc58593          	addi	a1,a1,460 # 8001bfc8 <pow10.0+0xd98>
    80014e04:	4511                	li	a0,4
    80014e06:	7b6000ef          	jal	ra,800155bc <logf>
    80014e0a:	a80d                	j	80014e3c <main+0x16e>
        }
        else {
            logf(LOG_INFO, "  [HART#%d]: %s.\n", i, hart_status_values[sbi_hart_get_status(i)]);
    80014e0c:	fec42783          	lw	a5,-20(s0)
    80014e10:	853e                	mv	a0,a5
    80014e12:	163000ef          	jal	ra,80015774 <sbi_hart_get_status>
    80014e16:	87aa                	mv	a5,a0
    80014e18:	00009717          	auipc	a4,0x9
    80014e1c:	1f070713          	addi	a4,a4,496 # 8001e008 <hart_status_values>
    80014e20:	078e                	slli	a5,a5,0x3
    80014e22:	97ba                	add	a5,a5,a4
    80014e24:	6398                	ld	a4,0(a5)
    80014e26:	fec42783          	lw	a5,-20(s0)
    80014e2a:	86ba                	mv	a3,a4
    80014e2c:	863e                	mv	a2,a5
    80014e2e:	00007597          	auipc	a1,0x7
    80014e32:	1ba58593          	addi	a1,a1,442 # 8001bfe8 <pow10.0+0xdb8>
    80014e36:	4511                	li	a0,4
    80014e38:	784000ef          	jal	ra,800155bc <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80014e3c:	fec42783          	lw	a5,-20(s0)
    80014e40:	2785                	addiw	a5,a5,1
    80014e42:	fef42623          	sw	a5,-20(s0)
    80014e46:	fec42783          	lw	a5,-20(s0)
    80014e4a:	0007871b          	sext.w	a4,a5
    80014e4e:	478d                	li	a5,3
    80014e50:	f6e7fde3          	bgeu	a5,a4,80014dca <main+0xfc>
        }
    }

    // Initialize all submodules here, including PCI, VirtIO, Heap, etc.
    // Many will require the MMU, so write those functions first.
    init_systems();
    80014e54:	afdff0ef          	jal	ra,80014950 <init_systems>

    // Now that all submodules are initialized, you need to schedule the init process
    // and the idle processes for each HART.
    logf(LOG_INFO, "Congratulations! You made it to the OS! Going back to sleep.\n");
    80014e58:	00007597          	auipc	a1,0x7
    80014e5c:	1a858593          	addi	a1,a1,424 # 8001c000 <pow10.0+0xdd0>
    80014e60:	4511                	li	a0,4
    80014e62:	75a000ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, 
    80014e66:	00007597          	auipc	a1,0x7
    80014e6a:	1da58593          	addi	a1,a1,474 # 8001c040 <pow10.0+0xe10>
    80014e6e:	4511                	li	a0,4
    80014e70:	74c000ef          	jal	ra,800155bc <logf>
        "The logf function in the OS uses sbi_putchar(), so this means ECALLs from S-mode are "
        "working!\n");
    logf(LOG_INFO, 
    80014e74:	00007597          	auipc	a1,0x7
    80014e78:	22c58593          	addi	a1,a1,556 # 8001c0a0 <pow10.0+0xe70>
    80014e7c:	4511                	li	a0,4
    80014e7e:	73e000ef          	jal	ra,800155bc <logf>
    // Below is just a little shell that demonstrates the sbi_getchar and
    // how the console works.

    // This is defined above main()
#ifdef RUN_INTERNAL_CONSOLE
    console();
    80014e82:	004000ef          	jal	ra,80014e86 <console>

0000000080014e86 <console>:
#endif
}

#ifdef RUN_INTERNAL_CONSOLE
ATTR_NORET static void console(void)
{
    80014e86:	7179                	addi	sp,sp,-48
    80014e88:	f406                	sd	ra,40(sp)
    80014e8a:	f022                	sd	s0,32(sp)
    80014e8c:	1800                	addi	s0,sp,48
    const int BUFFER_SIZE = 56;
    80014e8e:	03800313          	li	t1,56
    80014e92:	fe642423          	sw	t1,-24(s0)
    int at                = 0;
    80014e96:	fe042623          	sw	zero,-20(s0)
    char input[BUFFER_SIZE];
    80014e9a:	fe842303          	lw	t1,-24(s0)
    80014e9e:	137d                	addi	t1,t1,-1
    80014ea0:	fe643023          	sd	t1,-32(s0)
    80014ea4:	fe842303          	lw	t1,-24(s0)
    80014ea8:	881a                	mv	a6,t1
    80014eaa:	4881                	li	a7,0
    80014eac:	03d85313          	srli	t1,a6,0x3d
    80014eb0:	00389693          	slli	a3,a7,0x3
    80014eb4:	00d366b3          	or	a3,t1,a3
    80014eb8:	00381613          	slli	a2,a6,0x3
    80014ebc:	fe842683          	lw	a3,-24(s0)
    80014ec0:	8536                	mv	a0,a3
    80014ec2:	4581                	li	a1,0
    80014ec4:	03d55693          	srli	a3,a0,0x3d
    80014ec8:	00359793          	slli	a5,a1,0x3
    80014ecc:	8fd5                	or	a5,a5,a3
    80014ece:	00351713          	slli	a4,a0,0x3
    80014ed2:	fe842783          	lw	a5,-24(s0)
    80014ed6:	07bd                	addi	a5,a5,15
    80014ed8:	8391                	srli	a5,a5,0x4
    80014eda:	0792                	slli	a5,a5,0x4
    80014edc:	40f10133          	sub	sp,sp,a5
    80014ee0:	878a                	mv	a5,sp
    80014ee2:	00078793          	mv	a5,a5
    80014ee6:	fcf43c23          	sd	a5,-40(s0)
    logf(LOG_TEXT, "> ");
    80014eea:	00007597          	auipc	a1,0x7
    80014eee:	21658593          	addi	a1,a1,534 # 8001c100 <pow10.0+0xed0>
    80014ef2:	4541                	li	a0,16
    80014ef4:	6c8000ef          	jal	ra,800155bc <logf>
    do {
        char c;
        // Recall that sbi_getchar() will return -1, 0xff, 255
        // if the receiver is empty.
        if ((c = sbi_getchar()) != 0xff) {
    80014ef8:	05d000ef          	jal	ra,80015754 <sbi_getchar>
    80014efc:	87aa                	mv	a5,a0
    80014efe:	fcf40ba3          	sb	a5,-41(s0)
    80014f02:	fd744783          	lbu	a5,-41(s0)
    80014f06:	0ff7f713          	andi	a4,a5,255
    80014f0a:	0ff00793          	li	a5,255
    80014f0e:	22f70263          	beq	a4,a5,80015132 <console+0x2ac>
            if (c == '\r' || c == '\n') {
    80014f12:	fd744783          	lbu	a5,-41(s0)
    80014f16:	0ff7f713          	andi	a4,a5,255
    80014f1a:	47b5                	li	a5,13
    80014f1c:	00f70963          	beq	a4,a5,80014f2e <console+0xa8>
    80014f20:	fd744783          	lbu	a5,-41(s0)
    80014f24:	0ff7f713          	andi	a4,a5,255
    80014f28:	47a9                	li	a5,10
    80014f2a:	0cf71c63          	bne	a4,a5,80015002 <console+0x17c>
                if (at > 0) {
    80014f2e:	fec42783          	lw	a5,-20(s0)
    80014f32:	2781                	sext.w	a5,a5
    80014f34:	0af05f63          	blez	a5,80014ff2 <console+0x16c>
                    input[at] = '\0';
    80014f38:	fd843703          	ld	a4,-40(s0)
    80014f3c:	fec42783          	lw	a5,-20(s0)
    80014f40:	97ba                	add	a5,a5,a4
    80014f42:	00078023          	sb	zero,0(a5)
                    if (!strcmp(input, "quit")) {
    80014f46:	00007597          	auipc	a1,0x7
    80014f4a:	1c258593          	addi	a1,a1,450 # 8001c108 <pow10.0+0xed8>
    80014f4e:	fd843503          	ld	a0,-40(s0)
    80014f52:	771020ef          	jal	ra,80017ec2 <strcmp>
    80014f56:	87aa                	mv	a5,a0
    80014f58:	eb99                	bnez	a5,80014f6e <console+0xe8>
                        logf(LOG_TEXT, "\nShutting down...\n\n");
    80014f5a:	00007597          	auipc	a1,0x7
    80014f5e:	1b658593          	addi	a1,a1,438 # 8001c110 <pow10.0+0xee0>
    80014f62:	4541                	li	a0,16
    80014f64:	658000ef          	jal	ra,800155bc <logf>
                        sbi_poweroff();
    80014f68:	09d000ef          	jal	ra,80015804 <sbi_poweroff>
    80014f6c:	a049                	j	80014fee <console+0x168>
                    }
                    else if (!strcmp(input, "fatal")) {
    80014f6e:	00007597          	auipc	a1,0x7
    80014f72:	1ba58593          	addi	a1,a1,442 # 8001c128 <pow10.0+0xef8>
    80014f76:	fd843503          	ld	a0,-40(s0)
    80014f7a:	749020ef          	jal	ra,80017ec2 <strcmp>
    80014f7e:	87aa                	mv	a5,a0
    80014f80:	eb95                	bnez	a5,80014fb4 <console+0x12e>
                        logf(LOG_TEXT, "\n");
    80014f82:	00007597          	auipc	a1,0x7
    80014f86:	ee658593          	addi	a1,a1,-282 # 8001be68 <pow10.0+0xc38>
    80014f8a:	4541                	li	a0,16
    80014f8c:	630000ef          	jal	ra,800155bc <logf>
                        fatalf("Testing fatal error @ %lu.\nHanging HART...\n", sbi_rtc_get_time());
    80014f90:	119000ef          	jal	ra,800158a8 <sbi_rtc_get_time>
    80014f94:	87aa                	mv	a5,a0
    80014f96:	85be                	mv	a1,a5
    80014f98:	00007517          	auipc	a0,0x7
    80014f9c:	19850513          	addi	a0,a0,408 # 8001c130 <pow10.0+0xf00>
    80014fa0:	6d0000ef          	jal	ra,80015670 <fatalf>
                        logf(LOG_ERROR, "If I get here, fatal didn't work :'(.\n");
    80014fa4:	00007597          	auipc	a1,0x7
    80014fa8:	1bc58593          	addi	a1,a1,444 # 8001c160 <pow10.0+0xf30>
    80014fac:	4505                	li	a0,1
    80014fae:	60e000ef          	jal	ra,800155bc <logf>
    80014fb2:	a835                	j	80014fee <console+0x168>
                    }
                    else if (!strcmp(input, "heap")) {
    80014fb4:	00007597          	auipc	a1,0x7
    80014fb8:	1d458593          	addi	a1,a1,468 # 8001c188 <pow10.0+0xf58>
    80014fbc:	fd843503          	ld	a0,-40(s0)
    80014fc0:	703020ef          	jal	ra,80017ec2 <strcmp>
    80014fc4:	87aa                	mv	a5,a0
    80014fc6:	eb99                	bnez	a5,80014fdc <console+0x156>
                        logf(LOG_TEXT, "\n");
    80014fc8:	00007597          	auipc	a1,0x7
    80014fcc:	ea058593          	addi	a1,a1,-352 # 8001be68 <pow10.0+0xc38>
    80014fd0:	4541                	li	a0,16
    80014fd2:	5ea000ef          	jal	ra,800155bc <logf>
                        void heap_print_stats(void);
                        heap_print_stats();
    80014fd6:	84bff0ef          	jal	ra,80014820 <heap_print_stats>
    80014fda:	a811                	j	80014fee <console+0x168>
                    }
                    else {
                        logf(LOG_TEXT, "\nUnknown command '%s'\n", input);
    80014fdc:	fd843603          	ld	a2,-40(s0)
    80014fe0:	00007597          	auipc	a1,0x7
    80014fe4:	1b058593          	addi	a1,a1,432 # 8001c190 <pow10.0+0xf60>
    80014fe8:	4541                	li	a0,16
    80014fea:	5d2000ef          	jal	ra,800155bc <logf>
                    }
                    at = 0;
    80014fee:	fe042623          	sw	zero,-20(s0)
                }
                logf(LOG_TEXT, "\n> ");
    80014ff2:	00007597          	auipc	a1,0x7
    80014ff6:	1b658593          	addi	a1,a1,438 # 8001c1a8 <pow10.0+0xf78>
    80014ffa:	4541                	li	a0,16
    80014ffc:	5c0000ef          	jal	ra,800155bc <logf>
    80015000:	aa2d                	j	8001513a <console+0x2b4>
            }
            else if (c == 127) {
    80015002:	fd744783          	lbu	a5,-41(s0)
    80015006:	0ff7f713          	andi	a4,a5,255
    8001500a:	07f00793          	li	a5,127
    8001500e:	02f71463          	bne	a4,a5,80015036 <console+0x1b0>
                // BACKSPACE
                if (at > 0) {
    80015012:	fec42783          	lw	a5,-20(s0)
    80015016:	2781                	sext.w	a5,a5
    80015018:	eef050e3          	blez	a5,80014ef8 <console+0x72>
                    logf(LOG_TEXT, "\b \b");
    8001501c:	00007597          	auipc	a1,0x7
    80015020:	19458593          	addi	a1,a1,404 # 8001c1b0 <pow10.0+0xf80>
    80015024:	4541                	li	a0,16
    80015026:	596000ef          	jal	ra,800155bc <logf>
                    at -= 1;
    8001502a:	fec42783          	lw	a5,-20(s0)
    8001502e:	37fd                	addiw	a5,a5,-1
    80015030:	fef42623          	sw	a5,-20(s0)
    80015034:	b5d1                	j	80014ef8 <console+0x72>
                }
            }
            else if (c == 0x1B) {
    80015036:	fd744783          	lbu	a5,-41(s0)
    8001503a:	0ff7f713          	andi	a4,a5,255
    8001503e:	47ed                	li	a5,27
    80015040:	0af71663          	bne	a4,a5,800150ec <console+0x266>
                // Escape sequence
                char esc1 = sbi_getchar();
    80015044:	710000ef          	jal	ra,80015754 <sbi_getchar>
    80015048:	87aa                	mv	a5,a0
    8001504a:	fcf40b23          	sb	a5,-42(s0)
                char esc2 = sbi_getchar();
    8001504e:	706000ef          	jal	ra,80015754 <sbi_getchar>
    80015052:	87aa                	mv	a5,a0
    80015054:	fcf40aa3          	sb	a5,-43(s0)
                if (esc1 == 0x5B) {
    80015058:	fd644783          	lbu	a5,-42(s0)
    8001505c:	0ff7f713          	andi	a4,a5,255
    80015060:	05b00793          	li	a5,91
    80015064:	0cf71a63          	bne	a4,a5,80015138 <console+0x2b2>
                    switch (esc2) {
    80015068:	fd544783          	lbu	a5,-43(s0)
    8001506c:	2781                	sext.w	a5,a5
    8001506e:	86be                	mv	a3,a5
    80015070:	04400713          	li	a4,68
    80015074:	06e68463          	beq	a3,a4,800150dc <console+0x256>
    80015078:	86be                	mv	a3,a5
    8001507a:	04400713          	li	a4,68
    8001507e:	e6d74de3          	blt	a4,a3,80014ef8 <console+0x72>
    80015082:	86be                	mv	a3,a5
    80015084:	04300713          	li	a4,67
    80015088:	04e68263          	beq	a3,a4,800150cc <console+0x246>
    8001508c:	86be                	mv	a3,a5
    8001508e:	04300713          	li	a4,67
    80015092:	e6d743e3          	blt	a4,a3,80014ef8 <console+0x72>
    80015096:	86be                	mv	a3,a5
    80015098:	04100713          	li	a4,65
    8001509c:	00e68863          	beq	a3,a4,800150ac <console+0x226>
    800150a0:	873e                	mv	a4,a5
    800150a2:	04200793          	li	a5,66
    800150a6:	00f70b63          	beq	a4,a5,800150bc <console+0x236>
    800150aa:	a841                	j	8001513a <console+0x2b4>
                        case 0x41:
                            logf(LOG_INFO, "UP\n");
    800150ac:	00007597          	auipc	a1,0x7
    800150b0:	10c58593          	addi	a1,a1,268 # 8001c1b8 <pow10.0+0xf88>
    800150b4:	4511                	li	a0,4
    800150b6:	506000ef          	jal	ra,800155bc <logf>
                            break;
    800150ba:	a041                	j	8001513a <console+0x2b4>
                        case 0x42:
                            logf(LOG_INFO, "DOWN\n");
    800150bc:	00007597          	auipc	a1,0x7
    800150c0:	10458593          	addi	a1,a1,260 # 8001c1c0 <pow10.0+0xf90>
    800150c4:	4511                	li	a0,4
    800150c6:	4f6000ef          	jal	ra,800155bc <logf>
                            break;
    800150ca:	a885                	j	8001513a <console+0x2b4>
                        case 0x43:
                            logf(LOG_INFO, "RIGHT\n");
    800150cc:	00007597          	auipc	a1,0x7
    800150d0:	0fc58593          	addi	a1,a1,252 # 8001c1c8 <pow10.0+0xf98>
    800150d4:	4511                	li	a0,4
    800150d6:	4e6000ef          	jal	ra,800155bc <logf>
                            break;
    800150da:	a085                	j	8001513a <console+0x2b4>
                        case 0x44:
                            logf(LOG_INFO, "LEFT\n");
    800150dc:	00007597          	auipc	a1,0x7
    800150e0:	0f458593          	addi	a1,a1,244 # 8001c1d0 <pow10.0+0xfa0>
    800150e4:	4511                	li	a0,4
    800150e6:	4d6000ef          	jal	ra,800155bc <logf>
                            break;
    800150ea:	a881                	j	8001513a <console+0x2b4>
                    }
                }
            }
            else {
                if (at < (BUFFER_SIZE - 1)) {
    800150ec:	fe842783          	lw	a5,-24(s0)
    800150f0:	37fd                	addiw	a5,a5,-1
    800150f2:	0007871b          	sext.w	a4,a5
    800150f6:	fec42783          	lw	a5,-20(s0)
    800150fa:	2781                	sext.w	a5,a5
    800150fc:	dee7dee3          	bge	a5,a4,80014ef8 <console+0x72>
                    input[at++] = c;
    80015100:	fec42783          	lw	a5,-20(s0)
    80015104:	0017871b          	addiw	a4,a5,1
    80015108:	fee42623          	sw	a4,-20(s0)
    8001510c:	fd843703          	ld	a4,-40(s0)
    80015110:	97ba                	add	a5,a5,a4
    80015112:	fd744703          	lbu	a4,-41(s0)
    80015116:	00e78023          	sb	a4,0(a5)
                    logf(LOG_TEXT, "%c", c);
    8001511a:	fd744783          	lbu	a5,-41(s0)
    8001511e:	2781                	sext.w	a5,a5
    80015120:	863e                	mv	a2,a5
    80015122:	00007597          	auipc	a1,0x7
    80015126:	0b658593          	addi	a1,a1,182 # 8001c1d8 <pow10.0+0xfa8>
    8001512a:	4541                	li	a0,16
    8001512c:	490000ef          	jal	ra,800155bc <logf>
    80015130:	b3e1                	j	80014ef8 <console+0x72>
            }
        }
        else {
            // We can WFI here since interrupts are enabled
            // for the UART.
            WFI();
    80015132:	10500073          	wfi
    80015136:	b3c9                	j	80014ef8 <console+0x72>
                }
    80015138:	0001                	nop
    do {
    8001513a:	bb7d                	j	80014ef8 <console+0x72>

000000008001513c <process_new>:
#define STACK_PAGES 2
#define STACK_SIZE  (STACK_PAGES * PAGE_SIZE)
#define STACK_TOP   0xfffffffc0ffee000UL

struct process *process_new(process_mode mode)
{
    8001513c:	715d                	addi	sp,sp,-80
    8001513e:	e486                	sd	ra,72(sp)
    80015140:	e0a2                	sd	s0,64(sp)
    80015142:	0880                	addi	s0,sp,80
    80015144:	87aa                	mv	a5,a0
    80015146:	faf42e23          	sw	a5,-68(s0)
    struct process *p       = (struct process *)kzalloc(sizeof(*p));
    8001514a:	29000593          	li	a1,656
    8001514e:	4505                	li	a0,1
    80015150:	f4eff0ef          	jal	ra,8001489e <kcalloc>
    80015154:	fea43023          	sd	a0,-32(s0)

    p->hart                 = -1U;
    80015158:	fe043783          	ld	a5,-32(s0)
    8001515c:	577d                	li	a4,-1
    8001515e:	c3d8                	sw	a4,4(a5)
    p->ptable               = mmu_table_create();
    80015160:	849fe0ef          	jal	ra,800139a8 <mmu_table_create>
    80015164:	872a                	mv	a4,a0
    80015166:	fe043783          	ld	a5,-32(s0)
    8001516a:	26e7bc23          	sd	a4,632(a5)
    p->state                = PS_WAITING;
    8001516e:	fe043783          	ld	a5,-32(s0)
    80015172:	4705                	li	a4,1
    80015174:	c7d8                	sw	a4,12(a5)
    // p->pid               = fill_in_with_unique_pid

    // Set the trap frame and create all necessary structures.
    // p->frame.sepc = filled_in_by_ELF_loader
    p->frame.sstatus        = SSTATUS_SPP_BOOL(mode) | SSTATUS_FS_INITIAL | SSTATUS_SPIE;
    80015176:	fbc42783          	lw	a5,-68(s0)
    8001517a:	2781                	sext.w	a5,a5
    8001517c:	c789                	beqz	a5,80015186 <process_new+0x4a>
    8001517e:	6789                	lui	a5,0x2
    80015180:	12078793          	addi	a5,a5,288 # 2120 <i+0x2100>
    80015184:	a021                	j	8001518c <process_new+0x50>
    80015186:	6789                	lui	a5,0x2
    80015188:	02078793          	addi	a5,a5,32 # 2020 <i+0x2000>
    8001518c:	fe043703          	ld	a4,-32(s0)
    80015190:	24f73023          	sd	a5,576(a4)
    p->frame.sie            = SIE_SEIE | SIE_SSIE | SIE_STIE;
    80015194:	fe043783          	ld	a5,-32(s0)
    80015198:	22200713          	li	a4,546
    8001519c:	24e7b423          	sd	a4,584(a5)
    p->frame.satp           = SATP(p->ptable, p->pid);
    800151a0:	fe043783          	ld	a5,-32(s0)
    800151a4:	2787b783          	ld	a5,632(a5)
    800151a8:	00c7d713          	srli	a4,a5,0xc
    800151ac:	57fd                	li	a5,-1
    800151ae:	83d1                	srli	a5,a5,0x14
    800151b0:	8f7d                	and	a4,a4,a5
    800151b2:	fe043783          	ld	a5,-32(s0)
    800151b6:	0007d783          	lhu	a5,0(a5)
    800151ba:	17b2                	slli	a5,a5,0x2c
    800151bc:	8f5d                	or	a4,a4,a5
    800151be:	57fd                	li	a5,-1
    800151c0:	17fe                	slli	a5,a5,0x3f
    800151c2:	8f5d                	or	a4,a4,a5
    800151c4:	fe043783          	ld	a5,-32(s0)
    800151c8:	24e7b823          	sd	a4,592(a5)
    p->frame.sscratch       = (unsigned long)&p->frame;
    800151cc:	fe043783          	ld	a5,-32(s0)
    800151d0:	03878793          	addi	a5,a5,56
    800151d4:	873e                	mv	a4,a5
    800151d6:	fe043783          	ld	a5,-32(s0)
    800151da:	24e7bc23          	sd	a4,600(a5)
    p->frame.stvec          = trampoline_trap_start;
    800151de:	00008797          	auipc	a5,0x8
    800151e2:	ecb78793          	addi	a5,a5,-309 # 8001d0a9 <trampoline_trap_start>
    800151e6:	6398                	ld	a4,0(a5)
    800151e8:	fe043783          	ld	a5,-32(s0)
    800151ec:	26e7b023          	sd	a4,608(a5)
    p->frame.trap_satp      = SATP_KERNEL;
    800151f0:	00005797          	auipc	a5,0x5
    800151f4:	e1078793          	addi	a5,a5,-496 # 8001a000 <kernel_mmu_table>
    800151f8:	639c                	ld	a5,0(a5)
    800151fa:	00c7d713          	srli	a4,a5,0xc
    800151fe:	57fd                	li	a5,-1
    80015200:	83d1                	srli	a5,a5,0x14
    80015202:	8f7d                	and	a4,a4,a5
    80015204:	8ffff7b7          	lui	a5,0x8ffff
    80015208:	1782                	slli	a5,a5,0x20
    8001520a:	8f5d                	or	a4,a4,a5
    8001520c:	fe043783          	ld	a5,-32(s0)
    80015210:	26e7b423          	sd	a4,616(a5) # ffffffff8ffff268 <_heap_end+0xffffffff07fef268>
    // p->frame.trap_stack = filled_in_by_SCHEDULER

    p->fds = vector_new_with_capacity(5);
    80015214:	4515                	li	a0,5
    80015216:	2e0030ef          	jal	ra,800184f6 <vector_new_with_capacity>
    8001521a:	872a                	mv	a4,a0
    8001521c:	fe043783          	ld	a5,-32(s0)
    80015220:	28e7b423          	sd	a4,648(a5)
    p->pages = list_new();
    80015224:	1d2020ef          	jal	ra,800173f6 <list_new>
    80015228:	872a                	mv	a4,a0
    8001522a:	fe043783          	ld	a5,-32(s0)
    8001522e:	28e7b023          	sd	a4,640(a5)

    // We need to keep track of the stack itself in the kernel, so we can free it
    // later, but the user process will interact with the stack via the SP register.
    p->frame.xregs[XREG_SP] = STACK_TOP + STACK_SIZE;
    80015232:	fe043783          	ld	a5,-32(s0)
    80015236:	c0fff737          	lui	a4,0xc0fff
    8001523a:	0712                	slli	a4,a4,0x4
    8001523c:	e7b8                	sd	a4,72(a5)
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    8001523e:	fe043423          	sd	zero,-24(s0)
    80015242:	a085                	j	800152a2 <process_new+0x166>
        void *stack = page_zalloc();
    80015244:	4505                	li	a0,1
    80015246:	427010ef          	jal	ra,80016e6c <page_znalloc>
    8001524a:	fca43423          	sd	a0,-56(s0)
        list_add_ptr(p->pages, stack);
    8001524e:	fe043783          	ld	a5,-32(s0)
    80015252:	2807b783          	ld	a5,640(a5)
    80015256:	fc843703          	ld	a4,-56(s0)
    8001525a:	85ba                	mv	a1,a4
    8001525c:	853e                	mv	a0,a5
    8001525e:	1c8020ef          	jal	ra,80017426 <list_add>
        mmu_map(p->ptable, STACK_TOP + PAGE_SIZE * i, (unsigned long)stack,
    80015262:	fe043783          	ld	a5,-32(s0)
    80015266:	2787b503          	ld	a0,632(a5)
    8001526a:	fe843783          	ld	a5,-24(s0)
    8001526e:	00c79713          	slli	a4,a5,0xc
    80015272:	ffe087b7          	lui	a5,0xffe08
    80015276:	17dd                	addi	a5,a5,-9
    80015278:	07b6                	slli	a5,a5,0xd
    8001527a:	00f705b3          	add	a1,a4,a5
    8001527e:	fc843603          	ld	a2,-56(s0)
    80015282:	fbc42783          	lw	a5,-68(s0)
    80015286:	2781                	sext.w	a5,a5
    80015288:	e399                	bnez	a5,8001528e <process_new+0x152>
    8001528a:	47c1                	li	a5,16
    8001528c:	a011                	j	80015290 <process_new+0x154>
    8001528e:	4799                	li	a5,6
    80015290:	873e                	mv	a4,a5
    80015292:	4681                	li	a3,0
    80015294:	f6efe0ef          	jal	ra,80013a02 <mmu_map>
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    80015298:	fe843783          	ld	a5,-24(s0)
    8001529c:	0785                	addi	a5,a5,1
    8001529e:	fef43423          	sd	a5,-24(s0)
    800152a2:	fe843703          	ld	a4,-24(s0)
    800152a6:	4785                	li	a5,1
    800152a8:	f8e7fee3          	bgeu	a5,a4,80015244 <process_new+0x108>
    }

    // We need to map certain kernel portions into the user's page table. Notice
    // that the PB_USER is NOT set, but it needs to be there because we need to execute
    // the trap/start instructions while using the user's page table until we change SATP.
    unsigned long trans_trampoline_start = mmu_translate(kernel_mmu_table, trampoline_thread_start);
    800152ac:	00005797          	auipc	a5,0x5
    800152b0:	d5478793          	addi	a5,a5,-684 # 8001a000 <kernel_mmu_table>
    800152b4:	6398                	ld	a4,0(a5)
    800152b6:	00008797          	auipc	a5,0x8
    800152ba:	ddb78793          	addi	a5,a5,-549 # 8001d091 <trampoline_thread_start>
    800152be:	639c                	ld	a5,0(a5)
    800152c0:	85be                	mv	a1,a5
    800152c2:	853a                	mv	a0,a4
    800152c4:	969fe0ef          	jal	ra,80013c2c <mmu_translate>
    800152c8:	fca43c23          	sd	a0,-40(s0)
    unsigned long trans_trampoline_trap  = mmu_translate(kernel_mmu_table, trampoline_trap_start);
    800152cc:	00005797          	auipc	a5,0x5
    800152d0:	d3478793          	addi	a5,a5,-716 # 8001a000 <kernel_mmu_table>
    800152d4:	6398                	ld	a4,0(a5)
    800152d6:	00008797          	auipc	a5,0x8
    800152da:	dd378793          	addi	a5,a5,-557 # 8001d0a9 <trampoline_trap_start>
    800152de:	639c                	ld	a5,0(a5)
    800152e0:	85be                	mv	a1,a5
    800152e2:	853a                	mv	a0,a4
    800152e4:	949fe0ef          	jal	ra,80013c2c <mmu_translate>
    800152e8:	fca43823          	sd	a0,-48(s0)
    mmu_map(p->ptable, trampoline_thread_start, trans_trampoline_start, MMU_LEVEL_4K,
    800152ec:	fe043783          	ld	a5,-32(s0)
    800152f0:	2787b503          	ld	a0,632(a5)
    800152f4:	00008797          	auipc	a5,0x8
    800152f8:	d9d78793          	addi	a5,a5,-611 # 8001d091 <trampoline_thread_start>
    800152fc:	639c                	ld	a5,0(a5)
    800152fe:	4729                	li	a4,10
    80015300:	4681                	li	a3,0
    80015302:	fd843603          	ld	a2,-40(s0)
    80015306:	85be                	mv	a1,a5
    80015308:	efafe0ef          	jal	ra,80013a02 <mmu_map>
            PB_READ | PB_EXECUTE);
    mmu_map(p->ptable, trampoline_trap_start, trans_trampoline_trap, MMU_LEVEL_4K,
    8001530c:	fe043783          	ld	a5,-32(s0)
    80015310:	2787b503          	ld	a0,632(a5)
    80015314:	00008797          	auipc	a5,0x8
    80015318:	d9578793          	addi	a5,a5,-619 # 8001d0a9 <trampoline_trap_start>
    8001531c:	639c                	ld	a5,0(a5)
    8001531e:	4729                	li	a4,10
    80015320:	4681                	li	a3,0
    80015322:	fd043603          	ld	a2,-48(s0)
    80015326:	85be                	mv	a1,a5
    80015328:	edafe0ef          	jal	ra,80013a02 <mmu_map>
            PB_READ | PB_EXECUTE);

    SFENCE_ASID(p->pid);
    8001532c:	fe043783          	ld	a5,-32(s0)
    80015330:	0007d783          	lhu	a5,0(a5)
    80015334:	12f00073          	sfence.vma	zero,a5

    return p;
    80015338:	fe043783          	ld	a5,-32(s0)
}
    8001533c:	853e                	mv	a0,a5
    8001533e:	60a6                	ld	ra,72(sp)
    80015340:	6406                	ld	s0,64(sp)
    80015342:	6161                	addi	sp,sp,80
    80015344:	8082                	ret

0000000080015346 <process_free>:

int process_free(struct process *p)
{
    80015346:	7179                	addi	sp,sp,-48
    80015348:	f406                	sd	ra,40(sp)
    8001534a:	f022                	sd	s0,32(sp)
    8001534c:	1800                	addi	s0,sp,48
    8001534e:	fca43c23          	sd	a0,-40(s0)
    struct ListElem *e;
    unsigned int i;

    if (!p || !ON_HART_NONE(p)) {
    80015352:	fd843783          	ld	a5,-40(s0)
    80015356:	cb81                	beqz	a5,80015366 <process_free+0x20>
    80015358:	fd843783          	ld	a5,-40(s0)
    8001535c:	43dc                	lw	a5,4(a5)
    8001535e:	873e                	mv	a4,a5
    80015360:	57fd                	li	a5,-1
    80015362:	00f70463          	beq	a4,a5,8001536a <process_free+0x24>
        // Process is invalid or running somewhere, or this is stale.
        return -1;
    80015366:	57fd                	li	a5,-1
    80015368:	a8d1                	j	8001543c <process_free+0xf6>
    }

    // Free all resources allocated to the process.

    if (p->ptable) {
    8001536a:	fd843783          	ld	a5,-40(s0)
    8001536e:	2787b783          	ld	a5,632(a5)
    80015372:	cf91                	beqz	a5,8001538e <process_free+0x48>
        mmu_free(p->ptable);
    80015374:	fd843783          	ld	a5,-40(s0)
    80015378:	2787b783          	ld	a5,632(a5)
    8001537c:	853e                	mv	a0,a5
    8001537e:	829fe0ef          	jal	ra,80013ba6 <mmu_free>
        SFENCE_ASID(p->pid);
    80015382:	fd843783          	ld	a5,-40(s0)
    80015386:	0007d783          	lhu	a5,0(a5)
    8001538a:	12f00073          	sfence.vma	zero,a5
    }

    if (p->pages) {
    8001538e:	fd843783          	ld	a5,-40(s0)
    80015392:	2807b783          	ld	a5,640(a5)
    80015396:	cbb9                	beqz	a5,800153ec <process_free+0xa6>
        list_for_each(p->pages, e) {
    80015398:	fd843783          	ld	a5,-40(s0)
    8001539c:	2807b783          	ld	a5,640(a5)
    800153a0:	853e                	mv	a0,a5
    800153a2:	4a4020ef          	jal	ra,80017846 <list_elem_start_ascending>
    800153a6:	fea43423          	sd	a0,-24(s0)
    800153aa:	a839                	j	800153c8 <process_free+0x82>
            page_free(list_elem_value_ptr(e));
    800153ac:	fe843503          	ld	a0,-24(s0)
    800153b0:	4f6020ef          	jal	ra,800178a6 <list_elem_value>
    800153b4:	87aa                	mv	a5,a0
    800153b6:	853e                	mv	a0,a5
    800153b8:	351010ef          	jal	ra,80016f08 <page_free>
        list_for_each(p->pages, e) {
    800153bc:	fe843503          	ld	a0,-24(s0)
    800153c0:	4ce020ef          	jal	ra,8001788e <list_elem_prev>
    800153c4:	fea43423          	sd	a0,-24(s0)
    800153c8:	fd843783          	ld	a5,-40(s0)
    800153cc:	2807b783          	ld	a5,640(a5)
    800153d0:	fe843583          	ld	a1,-24(s0)
    800153d4:	853e                	mv	a0,a5
    800153d6:	3e2020ef          	jal	ra,800177b8 <list_elem_valid>
    800153da:	87aa                	mv	a5,a0
    800153dc:	fbe1                	bnez	a5,800153ac <process_free+0x66>
        }
        list_free(p->pages);
    800153de:	fd843783          	ld	a5,-40(s0)
    800153e2:	2807b783          	ld	a5,640(a5)
    800153e6:	853e                	mv	a0,a5
    800153e8:	378020ef          	jal	ra,80017760 <list_free>
    }

    if (p->fds) {
    800153ec:	fd843783          	ld	a5,-40(s0)
    800153f0:	2887b783          	ld	a5,648(a5)
    800153f4:	cf9d                	beqz	a5,80015432 <process_free+0xec>
        for (i = 0;i < vector_size(p->fds);i += 1) {
    800153f6:	fe042223          	sw	zero,-28(s0)
    800153fa:	a031                	j	80015406 <process_free+0xc0>
    800153fc:	fe442783          	lw	a5,-28(s0)
    80015400:	2785                	addiw	a5,a5,1
    80015402:	fef42223          	sw	a5,-28(s0)
    80015406:	fd843783          	ld	a5,-40(s0)
    8001540a:	2887b783          	ld	a5,648(a5)
    8001540e:	853e                	mv	a0,a5
    80015410:	1d5030ef          	jal	ra,80018de4 <vector_size>
    80015414:	87aa                	mv	a5,a0
    80015416:	0007871b          	sext.w	a4,a5
    8001541a:	fe442783          	lw	a5,-28(s0)
    8001541e:	2781                	sext.w	a5,a5
    80015420:	fce7eee3          	bltu	a5,a4,800153fc <process_free+0xb6>
            // Clean up any file descriptor stuff here.
        }
        vector_free(p->fds);
    80015424:	fd843783          	ld	a5,-40(s0)
    80015428:	2887b783          	ld	a5,648(a5)
    8001542c:	853e                	mv	a0,a5
    8001542e:	1e7030ef          	jal	ra,80018e14 <vector_free>
    }
    

    kfree(p);
    80015432:	fd843503          	ld	a0,-40(s0)
    80015436:	c90ff0ef          	jal	ra,800148c6 <kfree>

    return 0;
    8001543a:	4781                	li	a5,0
}
    8001543c:	853e                	mv	a0,a5
    8001543e:	70a2                	ld	ra,40(sp)
    80015440:	7402                	ld	s0,32(sp)
    80015442:	6145                	addi	sp,sp,48
    80015444:	8082                	ret

0000000080015446 <process_run>:

bool process_run(struct process *p, unsigned int hart)
{
    80015446:	7179                	addi	sp,sp,-48
    80015448:	f406                	sd	ra,40(sp)
    8001544a:	f022                	sd	s0,32(sp)
    8001544c:	1800                	addi	s0,sp,48
    8001544e:	fca43c23          	sd	a0,-40(s0)
    80015452:	87ae                	mv	a5,a1
    80015454:	fcf42a23          	sw	a5,-44(s0)
    void process_asm_run(void *frame_addr);
    unsigned int me = sbi_whoami();
    80015458:	470000ef          	jal	ra,800158c8 <sbi_whoami>
    8001545c:	87aa                	mv	a5,a0
    8001545e:	fef42623          	sw	a5,-20(s0)

    if (me == hart) {
    80015462:	fec42703          	lw	a4,-20(s0)
    80015466:	fd442783          	lw	a5,-44(s0)
    8001546a:	2701                	sext.w	a4,a4
    8001546c:	2781                	sext.w	a5,a5
    8001546e:	00f71b63          	bne	a4,a5,80015484 <process_run+0x3e>
        process_asm_run(&p->frame);
    80015472:	fd843783          	ld	a5,-40(s0)
    80015476:	03878793          	addi	a5,a5,56
    8001547a:	853e                	mv	a0,a5
    8001547c:	639010ef          	jal	ra,800172b4 <process_asm_run>
        // process_asm_run should not return, but if it does
        // something went wrong.
        return false;
    80015480:	4781                	li	a5,0
    80015482:	a815                	j	800154b6 <process_run+0x70>
    }

    return sbi_hart_start(hart, trampoline_thread_start, (unsigned long)&p->frame, p->frame.satp);
    80015484:	00008797          	auipc	a5,0x8
    80015488:	c0d78793          	addi	a5,a5,-1011 # 8001d091 <trampoline_thread_start>
    8001548c:	6398                	ld	a4,0(a5)
    8001548e:	fd843783          	ld	a5,-40(s0)
    80015492:	03878793          	addi	a5,a5,56
    80015496:	863e                	mv	a2,a5
    80015498:	fd843783          	ld	a5,-40(s0)
    8001549c:	2507b683          	ld	a3,592(a5)
    800154a0:	fd442783          	lw	a5,-44(s0)
    800154a4:	85ba                	mv	a1,a4
    800154a6:	853e                	mv	a0,a5
    800154a8:	2f8000ef          	jal	ra,800157a0 <sbi_hart_start>
    800154ac:	87aa                	mv	a5,a0
    800154ae:	00f037b3          	snez	a5,a5
    800154b2:	0ff7f793          	andi	a5,a5,255
}
    800154b6:	853e                	mv	a0,a5
    800154b8:	70a2                	ld	ra,40(sp)
    800154ba:	7402                	ld	s0,32(sp)
    800154bc:	6145                	addi	sp,sp,48
    800154be:	8082                	ret

00000000800154c0 <lgprefix>:
#include <stdarg.h>
#include <csr.h>

static int k_log_level = 0xFFF;

static const char *lgprefix(log_type lt) {
    800154c0:	1101                	addi	sp,sp,-32
    800154c2:	ec22                	sd	s0,24(sp)
    800154c4:	1000                	addi	s0,sp,32
    800154c6:	87aa                	mv	a5,a0
    800154c8:	fef42623          	sw	a5,-20(s0)
    switch (lt) {
    800154cc:	fec42783          	lw	a5,-20(s0)
    800154d0:	0007871b          	sext.w	a4,a5
    800154d4:	47a1                	li	a5,8
    800154d6:	06f70463          	beq	a4,a5,8001553e <lgprefix+0x7e>
    800154da:	fec42783          	lw	a5,-20(s0)
    800154de:	0007871b          	sext.w	a4,a5
    800154e2:	47a1                	li	a5,8
    800154e4:	06e7e263          	bltu	a5,a4,80015548 <lgprefix+0x88>
    800154e8:	fec42783          	lw	a5,-20(s0)
    800154ec:	0007871b          	sext.w	a4,a5
    800154f0:	4791                	li	a5,4
    800154f2:	02f70c63          	beq	a4,a5,8001552a <lgprefix+0x6a>
    800154f6:	fec42783          	lw	a5,-20(s0)
    800154fa:	0007871b          	sext.w	a4,a5
    800154fe:	4791                	li	a5,4
    80015500:	04e7e463          	bltu	a5,a4,80015548 <lgprefix+0x88>
    80015504:	fec42783          	lw	a5,-20(s0)
    80015508:	0007871b          	sext.w	a4,a5
    8001550c:	4785                	li	a5,1
    8001550e:	02f70363          	beq	a4,a5,80015534 <lgprefix+0x74>
    80015512:	fec42783          	lw	a5,-20(s0)
    80015516:	0007871b          	sext.w	a4,a5
    8001551a:	4789                	li	a5,2
    8001551c:	02f71663          	bne	a4,a5,80015548 <lgprefix+0x88>
        case LOG_DEBUG:
            return "[DEBUG]: ";
    80015520:	00007797          	auipc	a5,0x7
    80015524:	cc078793          	addi	a5,a5,-832 # 8001c1e0 <pow10.0+0xfb0>
    80015528:	a025                	j	80015550 <lgprefix+0x90>
        case LOG_INFO:
            return "[INFO]: ";
    8001552a:	00007797          	auipc	a5,0x7
    8001552e:	cc678793          	addi	a5,a5,-826 # 8001c1f0 <pow10.0+0xfc0>
    80015532:	a839                	j	80015550 <lgprefix+0x90>
        case LOG_ERROR:
            return "[ERROR]: ";
    80015534:	00007797          	auipc	a5,0x7
    80015538:	ccc78793          	addi	a5,a5,-820 # 8001c200 <pow10.0+0xfd0>
    8001553c:	a811                	j	80015550 <lgprefix+0x90>
        case LOG_FATAL:
            return "[FATAL]: ";
    8001553e:	00007797          	auipc	a5,0x7
    80015542:	cd278793          	addi	a5,a5,-814 # 8001c210 <pow10.0+0xfe0>
    80015546:	a029                	j	80015550 <lgprefix+0x90>
        default:
            return "";
    80015548:	00007797          	auipc	a5,0x7
    8001554c:	cd878793          	addi	a5,a5,-808 # 8001c220 <pow10.0+0xff0>
    }
}
    80015550:	853e                	mv	a0,a5
    80015552:	6462                	ld	s0,24(sp)
    80015554:	6105                	addi	sp,sp,32
    80015556:	8082                	ret

0000000080015558 <vlogf>:

static int vlogf(log_type lt, const char *fmt, va_list args)
{
    80015558:	7179                	addi	sp,sp,-48
    8001555a:	f406                	sd	ra,40(sp)
    8001555c:	f022                	sd	s0,32(sp)
    8001555e:	1800                	addi	s0,sp,48
    80015560:	87aa                	mv	a5,a0
    80015562:	feb43023          	sd	a1,-32(s0)
    80015566:	fcc43c23          	sd	a2,-40(s0)
    8001556a:	fef42623          	sw	a5,-20(s0)
    if (!(lt & k_log_level)) {
    8001556e:	00009797          	auipc	a5,0x9
    80015572:	a9678793          	addi	a5,a5,-1386 # 8001e004 <k_log_level>
    80015576:	439c                	lw	a5,0(a5)
    80015578:	0007871b          	sext.w	a4,a5
    8001557c:	fec42783          	lw	a5,-20(s0)
    80015580:	8ff9                	and	a5,a5,a4
    80015582:	2781                	sext.w	a5,a5
    80015584:	e399                	bnez	a5,8001558a <vlogf+0x32>
        return 0;
    80015586:	4781                	li	a5,0
    80015588:	a02d                	j	800155b2 <vlogf+0x5a>
    }
    int printf(const char *fmt, ...);
    printf("%s", lgprefix(lt));
    8001558a:	fec42783          	lw	a5,-20(s0)
    8001558e:	853e                	mv	a0,a5
    80015590:	f31ff0ef          	jal	ra,800154c0 <lgprefix>
    80015594:	87aa                	mv	a5,a0
    80015596:	85be                	mv	a1,a5
    80015598:	00007517          	auipc	a0,0x7
    8001559c:	c9050513          	addi	a0,a0,-880 # 8001c228 <pow10.0+0xff8>
    800155a0:	ca7fc0ef          	jal	ra,80012246 <printf>
    int vprintf_(const char *format, va_list va);
    return vprintf_(fmt, args);
    800155a4:	fd843583          	ld	a1,-40(s0)
    800155a8:	fe043503          	ld	a0,-32(s0)
    800155ac:	dc9fc0ef          	jal	ra,80012374 <vprintf_>
    800155b0:	87aa                	mv	a5,a0
}
    800155b2:	853e                	mv	a0,a5
    800155b4:	70a2                	ld	ra,40(sp)
    800155b6:	7402                	ld	s0,32(sp)
    800155b8:	6145                	addi	sp,sp,48
    800155ba:	8082                	ret

00000000800155bc <logf>:

int logf(log_type lt, const char *fmt, ...)
{
    800155bc:	7159                	addi	sp,sp,-112
    800155be:	fc06                	sd	ra,56(sp)
    800155c0:	f822                	sd	s0,48(sp)
    800155c2:	0080                	addi	s0,sp,64
    800155c4:	fcb43823          	sd	a1,-48(s0)
    800155c8:	e010                	sd	a2,0(s0)
    800155ca:	e414                	sd	a3,8(s0)
    800155cc:	e818                	sd	a4,16(s0)
    800155ce:	ec1c                	sd	a5,24(s0)
    800155d0:	03043023          	sd	a6,32(s0)
    800155d4:	03143423          	sd	a7,40(s0)
    800155d8:	87aa                	mv	a5,a0
    800155da:	fcf42e23          	sw	a5,-36(s0)
    va_list va;
    va_start(va, fmt);
    800155de:	03040793          	addi	a5,s0,48
    800155e2:	fcf43423          	sd	a5,-56(s0)
    800155e6:	fc843783          	ld	a5,-56(s0)
    800155ea:	fd078793          	addi	a5,a5,-48
    800155ee:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(lt, fmt, va);
    800155f2:	fe043703          	ld	a4,-32(s0)
    800155f6:	fdc42783          	lw	a5,-36(s0)
    800155fa:	863a                	mv	a2,a4
    800155fc:	fd043583          	ld	a1,-48(s0)
    80015600:	853e                	mv	a0,a5
    80015602:	f57ff0ef          	jal	ra,80015558 <vlogf>
    80015606:	87aa                	mv	a5,a0
    80015608:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001560c:	fec42783          	lw	a5,-20(s0)
}
    80015610:	853e                	mv	a0,a5
    80015612:	70e2                	ld	ra,56(sp)
    80015614:	7442                	ld	s0,48(sp)
    80015616:	6165                	addi	sp,sp,112
    80015618:	8082                	ret

000000008001561a <debugf>:

int debugf(const char *fmt, ...)
{
    8001561a:	7159                	addi	sp,sp,-112
    8001561c:	f406                	sd	ra,40(sp)
    8001561e:	f022                	sd	s0,32(sp)
    80015620:	1800                	addi	s0,sp,48
    80015622:	fca43c23          	sd	a0,-40(s0)
    80015626:	e40c                	sd	a1,8(s0)
    80015628:	e810                	sd	a2,16(s0)
    8001562a:	ec14                	sd	a3,24(s0)
    8001562c:	f018                	sd	a4,32(s0)
    8001562e:	f41c                	sd	a5,40(s0)
    80015630:	03043823          	sd	a6,48(s0)
    80015634:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    80015638:	04040793          	addi	a5,s0,64
    8001563c:	fcf43823          	sd	a5,-48(s0)
    80015640:	fd043783          	ld	a5,-48(s0)
    80015644:	fc878793          	addi	a5,a5,-56
    80015648:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_DEBUG, fmt, va);
    8001564c:	fe043783          	ld	a5,-32(s0)
    80015650:	863e                	mv	a2,a5
    80015652:	fd843583          	ld	a1,-40(s0)
    80015656:	4509                	li	a0,2
    80015658:	f01ff0ef          	jal	ra,80015558 <vlogf>
    8001565c:	87aa                	mv	a5,a0
    8001565e:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    80015662:	fec42783          	lw	a5,-20(s0)
}
    80015666:	853e                	mv	a0,a5
    80015668:	70a2                	ld	ra,40(sp)
    8001566a:	7402                	ld	s0,32(sp)
    8001566c:	6165                	addi	sp,sp,112
    8001566e:	8082                	ret

0000000080015670 <fatalf>:

ATTR_NORET void fatalf(const char *fmt, ...)
{
    80015670:	7159                	addi	sp,sp,-112
    80015672:	f406                	sd	ra,40(sp)
    80015674:	f022                	sd	s0,32(sp)
    80015676:	1800                	addi	s0,sp,48
    80015678:	fca43c23          	sd	a0,-40(s0)
    8001567c:	e40c                	sd	a1,8(s0)
    8001567e:	e810                	sd	a2,16(s0)
    80015680:	ec14                	sd	a3,24(s0)
    80015682:	f018                	sd	a4,32(s0)
    80015684:	f41c                	sd	a5,40(s0)
    80015686:	03043823          	sd	a6,48(s0)
    8001568a:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001568e:	04040793          	addi	a5,s0,64
    80015692:	fcf43823          	sd	a5,-48(s0)
    80015696:	fd043783          	ld	a5,-48(s0)
    8001569a:	fc878793          	addi	a5,a5,-56
    8001569e:	fef43423          	sd	a5,-24(s0)
    vlogf(LOG_FATAL, fmt, va);
    800156a2:	fe843783          	ld	a5,-24(s0)
    800156a6:	863e                	mv	a2,a5
    800156a8:	fd843583          	ld	a1,-40(s0)
    800156ac:	4521                	li	a0,8
    800156ae:	eabff0ef          	jal	ra,80015558 <vlogf>
    va_end(va);

    CSR_CLEAR("sstatus");
    800156b2:	10001073          	csrw	sstatus,zero
    WFI_LOOP();
    800156b6:	10500073          	wfi
    800156ba:	bff5                	j	800156b6 <fatalf+0x46>

00000000800156bc <klogset>:
}

void klogset(log_type lt)
{
    800156bc:	1101                	addi	sp,sp,-32
    800156be:	ec22                	sd	s0,24(sp)
    800156c0:	1000                	addi	s0,sp,32
    800156c2:	87aa                	mv	a5,a0
    800156c4:	fef42623          	sw	a5,-20(s0)
    k_log_level |= lt;
    800156c8:	00009797          	auipc	a5,0x9
    800156cc:	93c78793          	addi	a5,a5,-1732 # 8001e004 <k_log_level>
    800156d0:	439c                	lw	a5,0(a5)
    800156d2:	0007871b          	sext.w	a4,a5
    800156d6:	fec42783          	lw	a5,-20(s0)
    800156da:	8fd9                	or	a5,a5,a4
    800156dc:	2781                	sext.w	a5,a5
    800156de:	0007871b          	sext.w	a4,a5
    800156e2:	00009797          	auipc	a5,0x9
    800156e6:	92278793          	addi	a5,a5,-1758 # 8001e004 <k_log_level>
    800156ea:	c398                	sw	a4,0(a5)
}
    800156ec:	0001                	nop
    800156ee:	6462                	ld	s0,24(sp)
    800156f0:	6105                	addi	sp,sp,32
    800156f2:	8082                	ret

00000000800156f4 <klogclear>:

void klogclear(log_type lt)
{
    800156f4:	1101                	addi	sp,sp,-32
    800156f6:	ec22                	sd	s0,24(sp)
    800156f8:	1000                	addi	s0,sp,32
    800156fa:	87aa                	mv	a5,a0
    800156fc:	fef42623          	sw	a5,-20(s0)
    k_log_level &= ~lt;
    80015700:	fec42783          	lw	a5,-20(s0)
    80015704:	fff7c793          	not	a5,a5
    80015708:	0007871b          	sext.w	a4,a5
    8001570c:	00009797          	auipc	a5,0x9
    80015710:	8f878793          	addi	a5,a5,-1800 # 8001e004 <k_log_level>
    80015714:	439c                	lw	a5,0(a5)
    80015716:	2781                	sext.w	a5,a5
    80015718:	8ff9                	and	a5,a5,a4
    8001571a:	2781                	sext.w	a5,a5
    8001571c:	0007871b          	sext.w	a4,a5
    80015720:	00009797          	auipc	a5,0x9
    80015724:	8e478793          	addi	a5,a5,-1820 # 8001e004 <k_log_level>
    80015728:	c398                	sw	a4,0(a5)
}
    8001572a:	0001                	nop
    8001572c:	6462                	ld	s0,24(sp)
    8001572e:	6105                	addi	sp,sp,32
    80015730:	8082                	ret

0000000080015732 <sbi_putchar>:
#include <compiler.h>
#include <config.h>
#include <sbi.h>

void sbi_putchar(char c)
{
    80015732:	1101                	addi	sp,sp,-32
    80015734:	ec22                	sd	s0,24(sp)
    80015736:	1000                	addi	s0,sp,32
    80015738:	87aa                	mv	a5,a0
    8001573a:	fef407a3          	sb	a5,-17(s0)
    asm volatile("mv a7, %0\nmv a0, %1\necall" ::"r"(SBI_SVCALL_PUTCHAR), "r"(c) : "a7", "a0");
    8001573e:	47a5                	li	a5,9
    80015740:	fef44703          	lbu	a4,-17(s0)
    80015744:	88be                	mv	a7,a5
    80015746:	853a                	mv	a0,a4
    80015748:	00000073          	ecall
}
    8001574c:	0001                	nop
    8001574e:	6462                	ld	s0,24(sp)
    80015750:	6105                	addi	sp,sp,32
    80015752:	8082                	ret

0000000080015754 <sbi_getchar>:

char sbi_getchar(void)
{
    80015754:	1101                	addi	sp,sp,-32
    80015756:	ec22                	sd	s0,24(sp)
    80015758:	1000                	addi	s0,sp,32
    char c;
    asm volatile("mv a7, %1\necall\nmv %0, a0\n" : "=r"(c) : "r"(SBI_SVCALL_GETCHAR) : "a7", "a0");
    8001575a:	47a9                	li	a5,10
    8001575c:	88be                	mv	a7,a5
    8001575e:	00000073          	ecall
    80015762:	87aa                	mv	a5,a0
    80015764:	fef407a3          	sb	a5,-17(s0)
    return c;
    80015768:	fef44783          	lbu	a5,-17(s0)
}
    8001576c:	853e                	mv	a0,a5
    8001576e:	6462                	ld	s0,24(sp)
    80015770:	6105                	addi	sp,sp,32
    80015772:	8082                	ret

0000000080015774 <sbi_hart_get_status>:

int sbi_hart_get_status(unsigned int hart)
{
    80015774:	7179                	addi	sp,sp,-48
    80015776:	f422                	sd	s0,40(sp)
    80015778:	1800                	addi	s0,sp,48
    8001577a:	87aa                	mv	a5,a0
    8001577c:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\necall\nmv %0, a0\n"
    80015780:	4785                	li	a5,1
    80015782:	fdc42703          	lw	a4,-36(s0)
    80015786:	88be                	mv	a7,a5
    80015788:	853a                	mv	a0,a4
    8001578a:	00000073          	ecall
    8001578e:	87aa                	mv	a5,a0
    80015790:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_STATUS), "r"(hart)
                 : "a0", "a7");
    return stat;
    80015794:	fec42783          	lw	a5,-20(s0)
}
    80015798:	853e                	mv	a0,a5
    8001579a:	7422                	ld	s0,40(sp)
    8001579c:	6145                	addi	sp,sp,48
    8001579e:	8082                	ret

00000000800157a0 <sbi_hart_start>:

int sbi_hart_start(unsigned int hart, unsigned long target, unsigned long scratch, unsigned long satp)
{
    800157a0:	7139                	addi	sp,sp,-64
    800157a2:	fc22                	sd	s0,56(sp)
    800157a4:	0080                	addi	s0,sp,64
    800157a6:	87aa                	mv	a5,a0
    800157a8:	fcb43823          	sd	a1,-48(s0)
    800157ac:	fcc43423          	sd	a2,-56(s0)
    800157b0:	fcd43023          	sd	a3,-64(s0)
    800157b4:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\nmv a1, %3\nmv a2, %4\nmv a3, %5\necall\nmv %0, a0\n"
    800157b8:	4789                	li	a5,2
    800157ba:	fdc42703          	lw	a4,-36(s0)
    800157be:	fd043683          	ld	a3,-48(s0)
    800157c2:	fc843803          	ld	a6,-56(s0)
    800157c6:	fc043303          	ld	t1,-64(s0)
    800157ca:	88be                	mv	a7,a5
    800157cc:	853a                	mv	a0,a4
    800157ce:	85b6                	mv	a1,a3
    800157d0:	8642                	mv	a2,a6
    800157d2:	869a                	mv	a3,t1
    800157d4:	00000073          	ecall
    800157d8:	87aa                	mv	a5,a0
    800157da:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_START), "r"(hart), "r"(target), "r"(scratch), "r"(satp)
                 : "a0", "a1", "a2", "a7");
    return stat;
    800157de:	fec42783          	lw	a5,-20(s0)
}
    800157e2:	853e                	mv	a0,a5
    800157e4:	7462                	ld	s0,56(sp)
    800157e6:	6121                	addi	sp,sp,64
    800157e8:	8082                	ret

00000000800157ea <sbi_hart_stop>:

void sbi_hart_stop(void)
{
    800157ea:	1141                	addi	sp,sp,-16
    800157ec:	e422                	sd	s0,8(sp)
    800157ee:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall\nwfi" : : "r"(SBI_SVCALL_HART_STOP) : "a0", "a7");
    800157f0:	478d                	li	a5,3
    800157f2:	88be                	mv	a7,a5
    800157f4:	00000073          	ecall
    800157f8:	10500073          	wfi
}
    800157fc:	0001                	nop
    800157fe:	6422                	ld	s0,8(sp)
    80015800:	0141                	addi	sp,sp,16
    80015802:	8082                	ret

0000000080015804 <sbi_poweroff>:

void sbi_poweroff(void)
{
    80015804:	1141                	addi	sp,sp,-16
    80015806:	e422                	sd	s0,8(sp)
    80015808:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" : : "r"(SBI_SVCALL_POWEROFF) : "a0", "a7");
    8001580a:	47b1                	li	a5,12
    8001580c:	88be                	mv	a7,a5
    8001580e:	00000073          	ecall
}
    80015812:	0001                	nop
    80015814:	6422                	ld	s0,8(sp)
    80015816:	0141                	addi	sp,sp,16
    80015818:	8082                	ret

000000008001581a <sbi_get_time>:

unsigned long sbi_get_time(void)
{
    8001581a:	1101                	addi	sp,sp,-32
    8001581c:	ec22                	sd	s0,24(sp)
    8001581e:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_GET_TIME) : "a0", "a7");
    80015820:	4791                	li	a5,4
    80015822:	88be                	mv	a7,a5
    80015824:	00000073          	ecall
    80015828:	87aa                	mv	a5,a0
    8001582a:	fef43423          	sd	a5,-24(s0)
    return ret;
    8001582e:	fe843783          	ld	a5,-24(s0)
}
    80015832:	853e                	mv	a0,a5
    80015834:	6462                	ld	s0,24(sp)
    80015836:	6105                	addi	sp,sp,32
    80015838:	8082                	ret

000000008001583a <sbi_set_timer>:

void sbi_set_timer(unsigned int hart, unsigned long val)
{
    8001583a:	1101                	addi	sp,sp,-32
    8001583c:	ec22                	sd	s0,24(sp)
    8001583e:	1000                	addi	s0,sp,32
    80015840:	87aa                	mv	a5,a0
    80015842:	feb43023          	sd	a1,-32(s0)
    80015846:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_SET_TIMECMP), "r"(hart),
    8001584a:	4795                	li	a5,5
    8001584c:	fec42703          	lw	a4,-20(s0)
    80015850:	fe043683          	ld	a3,-32(s0)
    80015854:	88be                	mv	a7,a5
    80015856:	853a                	mv	a0,a4
    80015858:	85b6                	mv	a1,a3
    8001585a:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    8001585e:	0001                	nop
    80015860:	6462                	ld	s0,24(sp)
    80015862:	6105                	addi	sp,sp,32
    80015864:	8082                	ret

0000000080015866 <sbi_add_timer>:

void sbi_add_timer(unsigned int hart, unsigned long val)
{
    80015866:	1101                	addi	sp,sp,-32
    80015868:	ec22                	sd	s0,24(sp)
    8001586a:	1000                	addi	s0,sp,32
    8001586c:	87aa                	mv	a5,a0
    8001586e:	feb43023          	sd	a1,-32(s0)
    80015872:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_ADD_TIMECMP), "r"(hart),
    80015876:	4799                	li	a5,6
    80015878:	fec42703          	lw	a4,-20(s0)
    8001587c:	fe043683          	ld	a3,-32(s0)
    80015880:	88be                	mv	a7,a5
    80015882:	853a                	mv	a0,a4
    80015884:	85b6                	mv	a1,a3
    80015886:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    8001588a:	0001                	nop
    8001588c:	6462                	ld	s0,24(sp)
    8001588e:	6105                	addi	sp,sp,32
    80015890:	8082                	ret

0000000080015892 <sbi_ack_timer>:

void sbi_ack_timer(void)
{
    80015892:	1141                	addi	sp,sp,-16
    80015894:	e422                	sd	s0,8(sp)
    80015896:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" ::"r"(SBI_SVCALL_ACK_TIMER) : "a7");
    80015898:	479d                	li	a5,7
    8001589a:	88be                	mv	a7,a5
    8001589c:	00000073          	ecall
}
    800158a0:	0001                	nop
    800158a2:	6422                	ld	s0,8(sp)
    800158a4:	0141                	addi	sp,sp,16
    800158a6:	8082                	ret

00000000800158a8 <sbi_rtc_get_time>:

unsigned long sbi_rtc_get_time(void)
{
    800158a8:	1101                	addi	sp,sp,-32
    800158aa:	ec22                	sd	s0,24(sp)
    800158ac:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0"
    800158ae:	47a1                	li	a5,8
    800158b0:	88be                	mv	a7,a5
    800158b2:	00000073          	ecall
    800158b6:	87aa                	mv	a5,a0
    800158b8:	fef43423          	sd	a5,-24(s0)
                 : "=r"(ret)
                 : "r"(SBI_SVCALL_RTC_GET_TIME)
                 : "a0", "a7");
    return ret;
    800158bc:	fe843783          	ld	a5,-24(s0)
}
    800158c0:	853e                	mv	a0,a5
    800158c2:	6462                	ld	s0,24(sp)
    800158c4:	6105                	addi	sp,sp,32
    800158c6:	8082                	ret

00000000800158c8 <sbi_whoami>:

int sbi_whoami(void)
{
    800158c8:	1101                	addi	sp,sp,-32
    800158ca:	ec22                	sd	s0,24(sp)
    800158cc:	1000                	addi	s0,sp,32
    int ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_WHOAMI) : "a0", "a7");
    800158ce:	47ad                	li	a5,11
    800158d0:	88be                	mv	a7,a5
    800158d2:	00000073          	ecall
    800158d6:	87aa                	mv	a5,a0
    800158d8:	fef42623          	sw	a5,-20(s0)
    return ret;
    800158dc:	fec42783          	lw	a5,-20(s0)
}
    800158e0:	853e                	mv	a0,a5
    800158e2:	6462                	ld	s0,24(sp)
    800158e4:	6105                	addi	sp,sp,32
    800158e6:	8082                	ret

00000000800158e8 <sbi_num_harts>:

int sbi_num_harts(void)
{
    800158e8:	1101                	addi	sp,sp,-32
    800158ea:	ec06                	sd	ra,24(sp)
    800158ec:	e822                	sd	s0,16(sp)
    800158ee:	1000                	addi	s0,sp,32
    unsigned int i;
    int num_harts = 0;
    800158f0:	fe042423          	sw	zero,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800158f4:	fe042623          	sw	zero,-20(s0)
    800158f8:	a015                	j	8001591c <sbi_num_harts+0x34>
        if (sbi_hart_get_status(i) != 0) {
    800158fa:	fec42783          	lw	a5,-20(s0)
    800158fe:	853e                	mv	a0,a5
    80015900:	e75ff0ef          	jal	ra,80015774 <sbi_hart_get_status>
    80015904:	87aa                	mv	a5,a0
    80015906:	c791                	beqz	a5,80015912 <sbi_num_harts+0x2a>
            num_harts += 1;
    80015908:	fe842783          	lw	a5,-24(s0)
    8001590c:	2785                	addiw	a5,a5,1
    8001590e:	fef42423          	sw	a5,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80015912:	fec42783          	lw	a5,-20(s0)
    80015916:	2785                	addiw	a5,a5,1
    80015918:	fef42623          	sw	a5,-20(s0)
    8001591c:	fec42783          	lw	a5,-20(s0)
    80015920:	0007871b          	sext.w	a4,a5
    80015924:	478d                	li	a5,3
    80015926:	fce7fae3          	bgeu	a5,a4,800158fa <sbi_num_harts+0x12>
        }
    }
    return num_harts;
    8001592a:	fe842783          	lw	a5,-24(s0)
}
    8001592e:	853e                	mv	a0,a5
    80015930:	60e2                	ld	ra,24(sp)
    80015932:	6442                	ld	s0,16(sp)
    80015934:	6105                	addi	sp,sp,32
    80015936:	8082                	ret

0000000080015938 <plic_set_priority>:
#define PLIC_PCI_INTB 33
#define PLIC_PCI_INTC 34
#define PLIC_PCI_INTD 35

void plic_set_priority(int interrupt_id, char priority)
{
    80015938:	7179                	addi	sp,sp,-48
    8001593a:	f422                	sd	s0,40(sp)
    8001593c:	1800                	addi	s0,sp,48
    8001593e:	87aa                	mv	a5,a0
    80015940:	872e                	mv	a4,a1
    80015942:	fcf42e23          	sw	a5,-36(s0)
    80015946:	87ba                	mv	a5,a4
    80015948:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_PRIORITY(interrupt_id);
    8001594c:	fdc42783          	lw	a5,-36(s0)
    80015950:	0027979b          	slliw	a5,a5,0x2
    80015954:	2781                	sext.w	a5,a5
    80015956:	873e                	mv	a4,a5
    80015958:	0c0007b7          	lui	a5,0xc000
    8001595c:	97ba                	add	a5,a5,a4
    8001595e:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    80015962:	fdb44783          	lbu	a5,-37(s0)
    80015966:	2781                	sext.w	a5,a5
    80015968:	8b9d                	andi	a5,a5,7
    8001596a:	0007871b          	sext.w	a4,a5
    8001596e:	fe843783          	ld	a5,-24(s0)
    80015972:	c398                	sw	a4,0(a5)
}
    80015974:	0001                	nop
    80015976:	7422                	ld	s0,40(sp)
    80015978:	6145                	addi	sp,sp,48
    8001597a:	8082                	ret

000000008001597c <plic_set_threshold>:
void plic_set_threshold(int hart, char priority)
{
    8001597c:	7179                	addi	sp,sp,-48
    8001597e:	f422                	sd	s0,40(sp)
    80015980:	1800                	addi	s0,sp,48
    80015982:	87aa                	mv	a5,a0
    80015984:	872e                	mv	a4,a1
    80015986:	fcf42e23          	sw	a5,-36(s0)
    8001598a:	87ba                	mv	a5,a4
    8001598c:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_THRESHOLD(hart, PLIC_MODE_SUPERVISOR);
    80015990:	fdc42783          	lw	a5,-36(s0)
    80015994:	0017979b          	slliw	a5,a5,0x1
    80015998:	2781                	sext.w	a5,a5
    8001599a:	2785                	addiw	a5,a5,1
    8001599c:	2781                	sext.w	a5,a5
    8001599e:	00c7979b          	slliw	a5,a5,0xc
    800159a2:	2781                	sext.w	a5,a5
    800159a4:	873e                	mv	a4,a5
    800159a6:	0c2007b7          	lui	a5,0xc200
    800159aa:	97ba                	add	a5,a5,a4
    800159ac:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    800159b0:	fdb44783          	lbu	a5,-37(s0)
    800159b4:	2781                	sext.w	a5,a5
    800159b6:	8b9d                	andi	a5,a5,7
    800159b8:	0007871b          	sext.w	a4,a5
    800159bc:	fe843783          	ld	a5,-24(s0)
    800159c0:	c398                	sw	a4,0(a5)
}
    800159c2:	0001                	nop
    800159c4:	7422                	ld	s0,40(sp)
    800159c6:	6145                	addi	sp,sp,48
    800159c8:	8082                	ret

00000000800159ca <plic_enable>:
void plic_enable(int hart, int interrupt_id)
{
    800159ca:	7179                	addi	sp,sp,-48
    800159cc:	f422                	sd	s0,40(sp)
    800159ce:	1800                	addi	s0,sp,48
    800159d0:	87aa                	mv	a5,a0
    800159d2:	872e                	mv	a4,a1
    800159d4:	fcf42e23          	sw	a5,-36(s0)
    800159d8:	87ba                	mv	a5,a4
    800159da:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    800159de:	fdc42783          	lw	a5,-36(s0)
    800159e2:	0017979b          	slliw	a5,a5,0x1
    800159e6:	2781                	sext.w	a5,a5
    800159e8:	2785                	addiw	a5,a5,1
    800159ea:	2781                	sext.w	a5,a5
    800159ec:	0077979b          	slliw	a5,a5,0x7
    800159f0:	2781                	sext.w	a5,a5
    800159f2:	873e                	mv	a4,a5
    800159f4:	0c0027b7          	lui	a5,0xc002
    800159f8:	97ba                	add	a5,a5,a4
    800159fa:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] |= 1UL << (interrupt_id % 32);
    800159fe:	fd842783          	lw	a5,-40(s0)
    80015a02:	41f7d71b          	sraiw	a4,a5,0x1f
    80015a06:	01b7571b          	srliw	a4,a4,0x1b
    80015a0a:	9fb9                	addw	a5,a5,a4
    80015a0c:	4057d79b          	sraiw	a5,a5,0x5
    80015a10:	0007869b          	sext.w	a3,a5
    80015a14:	87b6                	mv	a5,a3
    80015a16:	078a                	slli	a5,a5,0x2
    80015a18:	fe843703          	ld	a4,-24(s0)
    80015a1c:	97ba                	add	a5,a5,a4
    80015a1e:	438c                	lw	a1,0(a5)
    80015a20:	fd842703          	lw	a4,-40(s0)
    80015a24:	41f7579b          	sraiw	a5,a4,0x1f
    80015a28:	01b7d79b          	srliw	a5,a5,0x1b
    80015a2c:	9f3d                	addw	a4,a4,a5
    80015a2e:	8b7d                	andi	a4,a4,31
    80015a30:	40f707bb          	subw	a5,a4,a5
    80015a34:	2781                	sext.w	a5,a5
    80015a36:	873e                	mv	a4,a5
    80015a38:	4785                	li	a5,1
    80015a3a:	00e797b3          	sll	a5,a5,a4
    80015a3e:	0007861b          	sext.w	a2,a5
    80015a42:	87b6                	mv	a5,a3
    80015a44:	078a                	slli	a5,a5,0x2
    80015a46:	fe843703          	ld	a4,-24(s0)
    80015a4a:	97ba                	add	a5,a5,a4
    80015a4c:	86ae                	mv	a3,a1
    80015a4e:	8732                	mv	a4,a2
    80015a50:	8f55                	or	a4,a4,a3
    80015a52:	2701                	sext.w	a4,a4
    80015a54:	c398                	sw	a4,0(a5)
}
    80015a56:	0001                	nop
    80015a58:	7422                	ld	s0,40(sp)
    80015a5a:	6145                	addi	sp,sp,48
    80015a5c:	8082                	ret

0000000080015a5e <plic_disable>:
void plic_disable(int hart, int interrupt_id)
{
    80015a5e:	7179                	addi	sp,sp,-48
    80015a60:	f422                	sd	s0,40(sp)
    80015a62:	1800                	addi	s0,sp,48
    80015a64:	87aa                	mv	a5,a0
    80015a66:	872e                	mv	a4,a1
    80015a68:	fcf42e23          	sw	a5,-36(s0)
    80015a6c:	87ba                	mv	a5,a4
    80015a6e:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    80015a72:	fdc42783          	lw	a5,-36(s0)
    80015a76:	0017979b          	slliw	a5,a5,0x1
    80015a7a:	2781                	sext.w	a5,a5
    80015a7c:	2785                	addiw	a5,a5,1
    80015a7e:	2781                	sext.w	a5,a5
    80015a80:	0077979b          	slliw	a5,a5,0x7
    80015a84:	2781                	sext.w	a5,a5
    80015a86:	873e                	mv	a4,a5
    80015a88:	0c0027b7          	lui	a5,0xc002
    80015a8c:	97ba                	add	a5,a5,a4
    80015a8e:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] &= ~(1UL << (interrupt_id % 32));
    80015a92:	fd842783          	lw	a5,-40(s0)
    80015a96:	41f7d71b          	sraiw	a4,a5,0x1f
    80015a9a:	01b7571b          	srliw	a4,a4,0x1b
    80015a9e:	9fb9                	addw	a5,a5,a4
    80015aa0:	4057d79b          	sraiw	a5,a5,0x5
    80015aa4:	0007869b          	sext.w	a3,a5
    80015aa8:	87b6                	mv	a5,a3
    80015aaa:	078a                	slli	a5,a5,0x2
    80015aac:	fe843703          	ld	a4,-24(s0)
    80015ab0:	97ba                	add	a5,a5,a4
    80015ab2:	438c                	lw	a1,0(a5)
    80015ab4:	fd842703          	lw	a4,-40(s0)
    80015ab8:	41f7579b          	sraiw	a5,a4,0x1f
    80015abc:	01b7d79b          	srliw	a5,a5,0x1b
    80015ac0:	9f3d                	addw	a4,a4,a5
    80015ac2:	8b7d                	andi	a4,a4,31
    80015ac4:	40f707bb          	subw	a5,a4,a5
    80015ac8:	2781                	sext.w	a5,a5
    80015aca:	873e                	mv	a4,a5
    80015acc:	4785                	li	a5,1
    80015ace:	00e797b3          	sll	a5,a5,a4
    80015ad2:	2781                	sext.w	a5,a5
    80015ad4:	fff7c793          	not	a5,a5
    80015ad8:	0007861b          	sext.w	a2,a5
    80015adc:	87b6                	mv	a5,a3
    80015ade:	078a                	slli	a5,a5,0x2
    80015ae0:	fe843703          	ld	a4,-24(s0)
    80015ae4:	97ba                	add	a5,a5,a4
    80015ae6:	86ae                	mv	a3,a1
    80015ae8:	8732                	mv	a4,a2
    80015aea:	8f75                	and	a4,a4,a3
    80015aec:	2701                	sext.w	a4,a4
    80015aee:	c398                	sw	a4,0(a5)
}
    80015af0:	0001                	nop
    80015af2:	7422                	ld	s0,40(sp)
    80015af4:	6145                	addi	sp,sp,48
    80015af6:	8082                	ret

0000000080015af8 <plic_claim>:
uint32_t plic_claim(int hart)
{
    80015af8:	7179                	addi	sp,sp,-48
    80015afa:	f422                	sd	s0,40(sp)
    80015afc:	1800                	addi	s0,sp,48
    80015afe:	87aa                	mv	a5,a0
    80015b00:	fcf42e23          	sw	a5,-36(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    80015b04:	fdc42783          	lw	a5,-36(s0)
    80015b08:	0017979b          	slliw	a5,a5,0x1
    80015b0c:	2781                	sext.w	a5,a5
    80015b0e:	2785                	addiw	a5,a5,1
    80015b10:	2781                	sext.w	a5,a5
    80015b12:	00c7979b          	slliw	a5,a5,0xc
    80015b16:	2781                	sext.w	a5,a5
    80015b18:	873e                	mv	a4,a5
    80015b1a:	0c2007b7          	lui	a5,0xc200
    80015b1e:	0791                	addi	a5,a5,4
    80015b20:	97ba                	add	a5,a5,a4
    80015b22:	fef43423          	sd	a5,-24(s0)
    return *base;
    80015b26:	fe843783          	ld	a5,-24(s0)
    80015b2a:	439c                	lw	a5,0(a5)
}
    80015b2c:	853e                	mv	a0,a5
    80015b2e:	7422                	ld	s0,40(sp)
    80015b30:	6145                	addi	sp,sp,48
    80015b32:	8082                	ret

0000000080015b34 <plic_complete>:
void plic_complete(int hart, int id)
{
    80015b34:	7179                	addi	sp,sp,-48
    80015b36:	f422                	sd	s0,40(sp)
    80015b38:	1800                	addi	s0,sp,48
    80015b3a:	87aa                	mv	a5,a0
    80015b3c:	872e                	mv	a4,a1
    80015b3e:	fcf42e23          	sw	a5,-36(s0)
    80015b42:	87ba                	mv	a5,a4
    80015b44:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    80015b48:	fdc42783          	lw	a5,-36(s0)
    80015b4c:	0017979b          	slliw	a5,a5,0x1
    80015b50:	2781                	sext.w	a5,a5
    80015b52:	2785                	addiw	a5,a5,1
    80015b54:	2781                	sext.w	a5,a5
    80015b56:	00c7979b          	slliw	a5,a5,0xc
    80015b5a:	2781                	sext.w	a5,a5
    80015b5c:	873e                	mv	a4,a5
    80015b5e:	0c2007b7          	lui	a5,0xc200
    80015b62:	0791                	addi	a5,a5,4
    80015b64:	97ba                	add	a5,a5,a4
    80015b66:	fef43423          	sd	a5,-24(s0)
    *base          = id;
    80015b6a:	fd842703          	lw	a4,-40(s0)
    80015b6e:	fe843783          	ld	a5,-24(s0)
    80015b72:	c398                	sw	a4,0(a5)
}
    80015b74:	0001                	nop
    80015b76:	7422                	ld	s0,40(sp)
    80015b78:	6145                	addi	sp,sp,48
    80015b7a:	8082                	ret

0000000080015b7c <plic_handle_irq>:

void plic_handle_irq(int hart)
{
    80015b7c:	7179                	addi	sp,sp,-48
    80015b7e:	f406                	sd	ra,40(sp)
    80015b80:	f022                	sd	s0,32(sp)
    80015b82:	1800                	addi	s0,sp,48
    80015b84:	87aa                	mv	a5,a0
    80015b86:	fcf42e23          	sw	a5,-36(s0)
    int irq = plic_claim(hart);
    80015b8a:	fdc42783          	lw	a5,-36(s0)
    80015b8e:	853e                	mv	a0,a5
    80015b90:	f69ff0ef          	jal	ra,80015af8 <plic_claim>
    80015b94:	87aa                	mv	a5,a0
    80015b96:	2781                	sext.w	a5,a5
    80015b98:	fef42623          	sw	a5,-20(s0)
    80015b9c:	fec42783          	lw	a5,-20(s0)
    80015ba0:	3781                	addiw	a5,a5,-32
    80015ba2:	2781                	sext.w	a5,a5

    switch (irq) {
    80015ba4:	873e                	mv	a4,a5
    80015ba6:	478d                	li	a5,3
    80015ba8:	00e7e863          	bltu	a5,a4,80015bb8 <plic_handle_irq+0x3c>
        // PCI devices 32-35
        case PLIC_PCI_INTA: [[fallthrough]]
        case PLIC_PCI_INTB: [[fallthrough]]
        case PLIC_PCI_INTC: [[fallthrough]]
        case PLIC_PCI_INTD:
            pci_dispatch_irq(irq);
    80015bac:	fec42783          	lw	a5,-20(s0)
    80015bb0:	853e                	mv	a0,a5
    80015bb2:	cbffd0ef          	jal	ra,80013870 <pci_dispatch_irq>
            break;
    80015bb6:	0001                	nop
    }
    plic_complete(hart, irq);
    80015bb8:	fec42703          	lw	a4,-20(s0)
    80015bbc:	fdc42783          	lw	a5,-36(s0)
    80015bc0:	85ba                	mv	a1,a4
    80015bc2:	853e                	mv	a0,a5
    80015bc4:	f71ff0ef          	jal	ra,80015b34 <plic_complete>
    debugf("Handled IRQ\n");
    80015bc8:	00006517          	auipc	a0,0x6
    80015bcc:	66850513          	addi	a0,a0,1640 # 8001c230 <pow10.0+0x1000>
    80015bd0:	a4bff0ef          	jal	ra,8001561a <debugf>
}
    80015bd4:	0001                	nop
    80015bd6:	70a2                	ld	ra,40(sp)
    80015bd8:	7402                	ld	s0,32(sp)
    80015bda:	6145                	addi	sp,sp,48
    80015bdc:	8082                	ret

0000000080015bde <plic_init>:

void plic_init(void)
{
    80015bde:	1141                	addi	sp,sp,-16
    80015be0:	e406                	sd	ra,8(sp)
    80015be2:	e022                	sd	s0,0(sp)
    80015be4:	0800                	addi	s0,sp,16
    plic_enable(0, PLIC_PCI_INTA);
    80015be6:	02000593          	li	a1,32
    80015bea:	4501                	li	a0,0
    80015bec:	ddfff0ef          	jal	ra,800159ca <plic_enable>
    plic_enable(0, PLIC_PCI_INTB);
    80015bf0:	02100593          	li	a1,33
    80015bf4:	4501                	li	a0,0
    80015bf6:	dd5ff0ef          	jal	ra,800159ca <plic_enable>
    plic_enable(0, PLIC_PCI_INTC);
    80015bfa:	02200593          	li	a1,34
    80015bfe:	4501                	li	a0,0
    80015c00:	dcbff0ef          	jal	ra,800159ca <plic_enable>
    plic_enable(0, PLIC_PCI_INTD);
    80015c04:	02300593          	li	a1,35
    80015c08:	4501                	li	a0,0
    80015c0a:	dc1ff0ef          	jal	ra,800159ca <plic_enable>

    plic_set_threshold(0, 0);
    80015c0e:	4581                	li	a1,0
    80015c10:	4501                	li	a0,0
    80015c12:	d6bff0ef          	jal	ra,8001597c <plic_set_threshold>

    plic_set_priority(PLIC_PCI_INTA, 7);
    80015c16:	459d                	li	a1,7
    80015c18:	02000513          	li	a0,32
    80015c1c:	d1dff0ef          	jal	ra,80015938 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTB, 7);
    80015c20:	459d                	li	a1,7
    80015c22:	02100513          	li	a0,33
    80015c26:	d13ff0ef          	jal	ra,80015938 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTC, 7);
    80015c2a:	459d                	li	a1,7
    80015c2c:	02200513          	li	a0,34
    80015c30:	d09ff0ef          	jal	ra,80015938 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTD, 7);
    80015c34:	459d                	li	a1,7
    80015c36:	02300513          	li	a0,35
    80015c3a:	cffff0ef          	jal	ra,80015938 <plic_set_priority>
}
    80015c3e:	0001                	nop
    80015c40:	60a2                	ld	ra,8(sp)
    80015c42:	6402                	ld	s0,0(sp)
    80015c44:	0141                	addi	sp,sp,16
    80015c46:	8082                	ret

0000000080015c48 <virtio_get_block_config>:

#include "include/virtio.h"

static Vector *virtio_devices = NULL;

volatile struct VirtioBlockConfig *virtio_get_block_config(VirtioDevice *device) {
    80015c48:	1101                	addi	sp,sp,-32
    80015c4a:	ec06                	sd	ra,24(sp)
    80015c4c:	e822                	sd	s0,16(sp)
    80015c4e:	1000                	addi	s0,sp,32
    80015c50:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioBlockConfig *)pci_get_device_specific_config(device->pcidev);
    80015c54:	fe843783          	ld	a5,-24(s0)
    80015c58:	639c                	ld	a5,0(a5)
    80015c5a:	853e                	mv	a0,a5
    80015c5c:	976fd0ef          	jal	ra,80012dd2 <pci_get_device_specific_config>
    80015c60:	87aa                	mv	a5,a0
}
    80015c62:	853e                	mv	a0,a5
    80015c64:	60e2                	ld	ra,24(sp)
    80015c66:	6442                	ld	s0,16(sp)
    80015c68:	6105                	addi	sp,sp,32
    80015c6a:	8082                	ret

0000000080015c6c <virtio_get_device_id>:

uint16_t virtio_get_device_id(VirtioDevice *dev) {
    80015c6c:	1101                	addi	sp,sp,-32
    80015c6e:	ec22                	sd	s0,24(sp)
    80015c70:	1000                	addi	s0,sp,32
    80015c72:	fea43423          	sd	a0,-24(s0)
    return dev->pcidev->ecam_header->device_id;
    80015c76:	fe843783          	ld	a5,-24(s0)
    80015c7a:	639c                	ld	a5,0(a5)
    80015c7c:	639c                	ld	a5,0(a5)
    80015c7e:	0027d783          	lhu	a5,2(a5) # c200002 <i+0xc1fffe2>
    80015c82:	17c2                	slli	a5,a5,0x30
    80015c84:	93c1                	srli	a5,a5,0x30
}
    80015c86:	853e                	mv	a0,a5
    80015c88:	6462                	ld	s0,24(sp)
    80015c8a:	6105                	addi	sp,sp,32
    80015c8c:	8082                	ret

0000000080015c8e <virtio_is_rng_device>:

bool virtio_is_rng_device(VirtioDevice *dev) {
    80015c8e:	1101                	addi	sp,sp,-32
    80015c90:	ec06                	sd	ra,24(sp)
    80015c92:	e822                	sd	s0,16(sp)
    80015c94:	1000                	addi	s0,sp,32
    80015c96:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_ENTROPY);
    80015c9a:	fe843503          	ld	a0,-24(s0)
    80015c9e:	fcfff0ef          	jal	ra,80015c6c <virtio_get_device_id>
    80015ca2:	87aa                	mv	a5,a0
    80015ca4:	0007871b          	sext.w	a4,a5
    80015ca8:	6785                	lui	a5,0x1
    80015caa:	04478793          	addi	a5,a5,68 # 1044 <i+0x1024>
    80015cae:	40f707b3          	sub	a5,a4,a5
    80015cb2:	0017b793          	seqz	a5,a5
    80015cb6:	0ff7f793          	andi	a5,a5,255
}
    80015cba:	853e                	mv	a0,a5
    80015cbc:	60e2                	ld	ra,24(sp)
    80015cbe:	6442                	ld	s0,16(sp)
    80015cc0:	6105                	addi	sp,sp,32
    80015cc2:	8082                	ret

0000000080015cc4 <virtio_is_block_device>:

bool virtio_is_block_device(VirtioDevice *dev) {
    80015cc4:	1101                	addi	sp,sp,-32
    80015cc6:	ec06                	sd	ra,24(sp)
    80015cc8:	e822                	sd	s0,16(sp)
    80015cca:	1000                	addi	s0,sp,32
    80015ccc:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_BLOCK);
    80015cd0:	fe843503          	ld	a0,-24(s0)
    80015cd4:	f99ff0ef          	jal	ra,80015c6c <virtio_get_device_id>
    80015cd8:	87aa                	mv	a5,a0
    80015cda:	0007871b          	sext.w	a4,a5
    80015cde:	6785                	lui	a5,0x1
    80015ce0:	04278793          	addi	a5,a5,66 # 1042 <i+0x1022>
    80015ce4:	40f707b3          	sub	a5,a4,a5
    80015ce8:	0017b793          	seqz	a5,a5
    80015cec:	0ff7f793          	andi	a5,a5,255
}
    80015cf0:	853e                	mv	a0,a5
    80015cf2:	60e2                	ld	ra,24(sp)
    80015cf4:	6442                	ld	s0,16(sp)
    80015cf6:	6105                	addi	sp,sp,32
    80015cf8:	8082                	ret

0000000080015cfa <virtio_get_device>:

VirtioDevice *virtio_get_device(uint16_t device_type) {
    80015cfa:	7139                	addi	sp,sp,-64
    80015cfc:	fc06                	sd	ra,56(sp)
    80015cfe:	f822                	sd	s0,48(sp)
    80015d00:	f426                	sd	s1,40(sp)
    80015d02:	0080                	addi	s0,sp,64
    80015d04:	87aa                	mv	a5,a0
    80015d06:	fcf41723          	sh	a5,-50(s0)
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    80015d0a:	fc041f23          	sh	zero,-34(s0)
    80015d0e:	a099                	j	80015d54 <virtio_get_device+0x5a>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    80015d10:	fde45783          	lhu	a5,-34(s0)
    80015d14:	853e                	mv	a0,a5
    80015d16:	0b4000ef          	jal	ra,80015dca <virtio_get_nth_saved_device>
    80015d1a:	fca43823          	sd	a0,-48(s0)
        if (virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(device_type)) {
    80015d1e:	fd043503          	ld	a0,-48(s0)
    80015d22:	f4bff0ef          	jal	ra,80015c6c <virtio_get_device_id>
    80015d26:	87aa                	mv	a5,a0
    80015d28:	0007869b          	sext.w	a3,a5
    80015d2c:	fce45783          	lhu	a5,-50(s0)
    80015d30:	0007871b          	sext.w	a4,a5
    80015d34:	6785                	lui	a5,0x1
    80015d36:	0407879b          	addiw	a5,a5,64
    80015d3a:	9fb9                	addw	a5,a5,a4
    80015d3c:	2781                	sext.w	a5,a5
    80015d3e:	8736                	mv	a4,a3
    80015d40:	00f71563          	bne	a4,a5,80015d4a <virtio_get_device+0x50>
            return dev;
    80015d44:	fd043783          	ld	a5,-48(s0)
    80015d48:	a025                	j	80015d70 <virtio_get_device+0x76>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    80015d4a:	fde45783          	lhu	a5,-34(s0)
    80015d4e:	2785                	addiw	a5,a5,1
    80015d50:	fcf41f23          	sh	a5,-34(s0)
    80015d54:	fde45483          	lhu	s1,-34(s0)
    80015d58:	170000ef          	jal	ra,80015ec8 <virtio_count_saved_devices>
    80015d5c:	87aa                	mv	a5,a0
    80015d5e:	faf4e9e3          	bltu	s1,a5,80015d10 <virtio_get_device+0x16>
        }
    }

    debugf("No device could be found");
    80015d62:	00006517          	auipc	a0,0x6
    80015d66:	4de50513          	addi	a0,a0,1246 # 8001c240 <pow10.0+0x1010>
    80015d6a:	8b1ff0ef          	jal	ra,8001561a <debugf>
    return NULL;
    80015d6e:	4781                	li	a5,0
}
    80015d70:	853e                	mv	a0,a5
    80015d72:	70e2                	ld	ra,56(sp)
    80015d74:	7442                	ld	s0,48(sp)
    80015d76:	74a2                	ld	s1,40(sp)
    80015d78:	6121                	addi	sp,sp,64
    80015d7a:	8082                	ret

0000000080015d7c <virtio_get_rng_device>:

VirtioDevice *virtio_get_rng_device(void) {
    80015d7c:	1141                	addi	sp,sp,-16
    80015d7e:	e406                	sd	ra,8(sp)
    80015d80:	e022                	sd	s0,0(sp)
    80015d82:	0800                	addi	s0,sp,16
    return virtio_get_device(VIRTIO_PCI_DEVICE_ENTROPY);
    80015d84:	4511                	li	a0,4
    80015d86:	f75ff0ef          	jal	ra,80015cfa <virtio_get_device>
    80015d8a:	87aa                	mv	a5,a0
}
    80015d8c:	853e                	mv	a0,a5
    80015d8e:	60a2                	ld	ra,8(sp)
    80015d90:	6402                	ld	s0,0(sp)
    80015d92:	0141                	addi	sp,sp,16
    80015d94:	8082                	ret

0000000080015d96 <virtio_get_block_device>:

VirtioDevice *virtio_get_block_device(void) {
    80015d96:	1141                	addi	sp,sp,-16
    80015d98:	e406                	sd	ra,8(sp)
    80015d9a:	e022                	sd	s0,0(sp)
    80015d9c:	0800                	addi	s0,sp,16
    return virtio_get_device(VIRTIO_PCI_DEVICE_BLOCK);
    80015d9e:	4509                	li	a0,2
    80015da0:	f5bff0ef          	jal	ra,80015cfa <virtio_get_device>
    80015da4:	87aa                	mv	a5,a0
}
    80015da6:	853e                	mv	a0,a5
    80015da8:	60a2                	ld	ra,8(sp)
    80015daa:	6402                	ld	s0,0(sp)
    80015dac:	0141                	addi	sp,sp,16
    80015dae:	8082                	ret

0000000080015db0 <virtio_get_gpu_device>:

VirtioDevice *virtio_get_gpu_device(void) {
    80015db0:	1141                	addi	sp,sp,-16
    80015db2:	e406                	sd	ra,8(sp)
    80015db4:	e022                	sd	s0,0(sp)
    80015db6:	0800                	addi	s0,sp,16
    return virtio_get_device(VIRTIO_PCI_DEVICE_GPU);
    80015db8:	4541                	li	a0,16
    80015dba:	f41ff0ef          	jal	ra,80015cfa <virtio_get_device>
    80015dbe:	87aa                	mv	a5,a0
}
    80015dc0:	853e                	mv	a0,a5
    80015dc2:	60a2                	ld	ra,8(sp)
    80015dc4:	6402                	ld	s0,0(sp)
    80015dc6:	0141                	addi	sp,sp,16
    80015dc8:	8082                	ret

0000000080015dca <virtio_get_nth_saved_device>:

VirtioDevice *virtio_get_nth_saved_device(uint16_t n) {
    80015dca:	7179                	addi	sp,sp,-48
    80015dcc:	f406                	sd	ra,40(sp)
    80015dce:	f022                	sd	s0,32(sp)
    80015dd0:	1800                	addi	s0,sp,48
    80015dd2:	87aa                	mv	a5,a0
    80015dd4:	fcf41f23          	sh	a5,-34(s0)
    VirtioDevice *result;
    vector_get_ptr(virtio_devices, n, &result);
    80015dd8:	00004797          	auipc	a5,0x4
    80015ddc:	2b878793          	addi	a5,a5,696 # 8001a090 <virtio_devices>
    80015de0:	639c                	ld	a5,0(a5)
    80015de2:	fde45703          	lhu	a4,-34(s0)
    80015de6:	2701                	sext.w	a4,a4
    80015de8:	fe840693          	addi	a3,s0,-24
    80015dec:	8636                	mv	a2,a3
    80015dee:	85ba                	mv	a1,a4
    80015df0:	853e                	mv	a0,a5
    80015df2:	093020ef          	jal	ra,80018684 <vector_get>
    return result;
    80015df6:	fe843783          	ld	a5,-24(s0)
}
    80015dfa:	853e                	mv	a0,a5
    80015dfc:	70a2                	ld	ra,40(sp)
    80015dfe:	7402                	ld	s0,32(sp)
    80015e00:	6145                	addi	sp,sp,48
    80015e02:	8082                	ret

0000000080015e04 <virtio_save_device>:

void virtio_save_device(VirtioDevice device) {
    80015e04:	7179                	addi	sp,sp,-48
    80015e06:	f406                	sd	ra,40(sp)
    80015e08:	f022                	sd	s0,32(sp)
    80015e0a:	ec26                	sd	s1,24(sp)
    80015e0c:	1800                	addi	s0,sp,48
    80015e0e:	84aa                	mv	s1,a0
    VirtioDevice *mem = (VirtioDevice *)kzalloc(sizeof(VirtioDevice));
    80015e10:	05000593          	li	a1,80
    80015e14:	4505                	li	a0,1
    80015e16:	a89fe0ef          	jal	ra,8001489e <kcalloc>
    80015e1a:	fca43c23          	sd	a0,-40(s0)
    memcpy(mem, &device, sizeof(VirtioDevice));
    80015e1e:	05000613          	li	a2,80
    80015e22:	85a6                	mv	a1,s1
    80015e24:	fd843503          	ld	a0,-40(s0)
    80015e28:	50d010ef          	jal	ra,80017b34 <memcpy>
    vector_push_ptr(virtio_devices, mem);
    80015e2c:	00004797          	auipc	a5,0x4
    80015e30:	26478793          	addi	a5,a5,612 # 8001a090 <virtio_devices>
    80015e34:	639c                	ld	a5,0(a5)
    80015e36:	fd843703          	ld	a4,-40(s0)
    80015e3a:	85ba                	mv	a1,a4
    80015e3c:	853e                	mv	a0,a5
    80015e3e:	6e6020ef          	jal	ra,80018524 <vector_push>
}
    80015e42:	0001                	nop
    80015e44:	70a2                	ld	ra,40(sp)
    80015e46:	7402                	ld	s0,32(sp)
    80015e48:	64e2                	ld	s1,24(sp)
    80015e4a:	6145                	addi	sp,sp,48
    80015e4c:	8082                	ret

0000000080015e4e <virtio_get_by_device>:

volatile VirtioDevice *virtio_get_by_device(volatile PCIDevice *pcidevice) {
    80015e4e:	7179                	addi	sp,sp,-48
    80015e50:	f406                	sd	ra,40(sp)
    80015e52:	f022                	sd	s0,32(sp)
    80015e54:	1800                	addi	s0,sp,48
    80015e56:	fca43c23          	sd	a0,-40(s0)
    for(int i = 0; i < vector_size(virtio_devices);i++){
    80015e5a:	fe042623          	sw	zero,-20(s0)
    80015e5e:	a081                	j	80015e9e <virtio_get_by_device+0x50>
        VirtioDevice *curr_virt_device = NULL;
    80015e60:	fe043023          	sd	zero,-32(s0)
        vector_get_ptr(virtio_devices, i, &curr_virt_device);
    80015e64:	00004797          	auipc	a5,0x4
    80015e68:	22c78793          	addi	a5,a5,556 # 8001a090 <virtio_devices>
    80015e6c:	639c                	ld	a5,0(a5)
    80015e6e:	fec42703          	lw	a4,-20(s0)
    80015e72:	fe040693          	addi	a3,s0,-32
    80015e76:	8636                	mv	a2,a3
    80015e78:	85ba                	mv	a1,a4
    80015e7a:	853e                	mv	a0,a5
    80015e7c:	009020ef          	jal	ra,80018684 <vector_get>
        if(curr_virt_device->pcidev == pcidevice){
    80015e80:	fe043783          	ld	a5,-32(s0)
    80015e84:	639c                	ld	a5,0(a5)
    80015e86:	fd843703          	ld	a4,-40(s0)
    80015e8a:	00f71563          	bne	a4,a5,80015e94 <virtio_get_by_device+0x46>
            return curr_virt_device;
    80015e8e:	fe043783          	ld	a5,-32(s0)
    80015e92:	a035                	j	80015ebe <virtio_get_by_device+0x70>
    for(int i = 0; i < vector_size(virtio_devices);i++){
    80015e94:	fec42783          	lw	a5,-20(s0)
    80015e98:	2785                	addiw	a5,a5,1
    80015e9a:	fef42623          	sw	a5,-20(s0)
    80015e9e:	00004797          	auipc	a5,0x4
    80015ea2:	1f278793          	addi	a5,a5,498 # 8001a090 <virtio_devices>
    80015ea6:	639c                	ld	a5,0(a5)
    80015ea8:	853e                	mv	a0,a5
    80015eaa:	73b020ef          	jal	ra,80018de4 <vector_size>
    80015eae:	87aa                	mv	a5,a0
    80015eb0:	0007871b          	sext.w	a4,a5
    80015eb4:	fec42783          	lw	a5,-20(s0)
    80015eb8:	fae7e4e3          	bltu	a5,a4,80015e60 <virtio_get_by_device+0x12>
        }
    }
    return NULL;
    80015ebc:	4781                	li	a5,0
}
    80015ebe:	853e                	mv	a0,a5
    80015ec0:	70a2                	ld	ra,40(sp)
    80015ec2:	7402                	ld	s0,32(sp)
    80015ec4:	6145                	addi	sp,sp,48
    80015ec6:	8082                	ret

0000000080015ec8 <virtio_count_saved_devices>:

// Get the number of saved Virtio devices.
uint64_t virtio_count_saved_devices(void) {
    80015ec8:	1141                	addi	sp,sp,-16
    80015eca:	e406                	sd	ra,8(sp)
    80015ecc:	e022                	sd	s0,0(sp)
    80015ece:	0800                	addi	s0,sp,16
    return vector_size(virtio_devices);
    80015ed0:	00004797          	auipc	a5,0x4
    80015ed4:	1c078793          	addi	a5,a5,448 # 8001a090 <virtio_devices>
    80015ed8:	639c                	ld	a5,0(a5)
    80015eda:	853e                	mv	a0,a5
    80015edc:	709020ef          	jal	ra,80018de4 <vector_size>
    80015ee0:	87aa                	mv	a5,a0
    80015ee2:	2781                	sext.w	a5,a5
    80015ee4:	1782                	slli	a5,a5,0x20
    80015ee6:	9381                	srli	a5,a5,0x20
}
    80015ee8:	853e                	mv	a0,a5
    80015eea:	60a2                	ld	ra,8(sp)
    80015eec:	6402                	ld	s0,0(sp)
    80015eee:	0141                	addi	sp,sp,16
    80015ef0:	8082                	ret

0000000080015ef2 <virtio_get_capability>:

// Get a virtio capability for a given device by the virtio capability's type.
// If this is zero, it will get the common configuration capability. If this is
// one, it will get the notify capability. If this is two, it will get the ISR
// capability. Etc.
volatile struct VirtioCapability *virtio_get_capability(volatile VirtioDevice *dev, uint8_t type) {
    80015ef2:	1101                	addi	sp,sp,-32
    80015ef4:	ec06                	sd	ra,24(sp)
    80015ef6:	e822                	sd	s0,16(sp)
    80015ef8:	1000                	addi	s0,sp,32
    80015efa:	fea43423          	sd	a0,-24(s0)
    80015efe:	87ae                	mv	a5,a1
    80015f00:	fef403a3          	sb	a5,-25(s0)
    return pci_get_virtio_capability(dev->pcidev, type);
    80015f04:	fe843783          	ld	a5,-24(s0)
    80015f08:	639c                	ld	a5,0(a5)
    80015f0a:	fe744703          	lbu	a4,-25(s0)
    80015f0e:	85ba                	mv	a1,a4
    80015f10:	853e                	mv	a0,a5
    80015f12:	a63fc0ef          	jal	ra,80012974 <pci_get_virtio_capability>
    80015f16:	87aa                	mv	a5,a0
}
    80015f18:	853e                	mv	a0,a5
    80015f1a:	60e2                	ld	ra,24(sp)
    80015f1c:	6442                	ld	s0,16(sp)
    80015f1e:	6105                	addi	sp,sp,32
    80015f20:	8082                	ret

0000000080015f22 <virtio_init>:
/**
 * @brief Initialize the virtio system
 */


void virtio_init(void) {
    80015f22:	7151                	addi	sp,sp,-240
    80015f24:	f586                	sd	ra,232(sp)
    80015f26:	f1a2                	sd	s0,224(sp)
    80015f28:	1980                	addi	s0,sp,240
    debugf("virtio_init: Initializing virtio system...\n");
    80015f2a:	00006517          	auipc	a0,0x6
    80015f2e:	33650513          	addi	a0,a0,822 # 8001c260 <pow10.0+0x1030>
    80015f32:	ee8ff0ef          	jal	ra,8001561a <debugf>
    // Initialize the vector of virtio devices
    virtio_devices = vector_new();
    80015f36:	54e020ef          	jal	ra,80018484 <vector_new>
    80015f3a:	872a                	mv	a4,a0
    80015f3c:	00004797          	auipc	a5,0x4
    80015f40:	15478793          	addi	a5,a5,340 # 8001a090 <virtio_devices>
    80015f44:	e398                	sd	a4,0(a5)

    // Get the number of PCI devices saved
    // This will allow us to iterate through all of them and find the virtio devices
    uint64_t num_pci_devices = pci_count_saved_devices();
    80015f46:	ad7fc0ef          	jal	ra,80012a1c <pci_count_saved_devices>
    80015f4a:	fea43023          	sd	a0,-32(s0)
    
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    80015f4e:	fe043423          	sd	zero,-24(s0)
    80015f52:	aed5                	j	80016346 <virtio_init+0x424>
        // Get the PCI device
        volatile PCIDevice *pcidevice = pci_get_nth_saved_device(i);
    80015f54:	fe843783          	ld	a5,-24(s0)
    80015f58:	17c2                	slli	a5,a5,0x30
    80015f5a:	93c1                	srli	a5,a5,0x30
    80015f5c:	853e                	mv	a0,a5
    80015f5e:	c69fc0ef          	jal	ra,80012bc6 <pci_get_nth_saved_device>
    80015f62:	fca43c23          	sd	a0,-40(s0)
        
        // Is this a virtio device?
        if (pci_is_virtio_device(pcidevice)) { // Access through ecam_header
    80015f66:	fd843503          	ld	a0,-40(s0)
    80015f6a:	817fc0ef          	jal	ra,80012780 <pci_is_virtio_device>
    80015f6e:	87aa                	mv	a5,a0
    80015f70:	3c078663          	beqz	a5,8001633c <virtio_init+0x41a>
            // Create a new bookkeeping structure for the virtio device
            volatile VirtioDevice viodev;
            // Add the PCI device to the bookkeeping structure
            viodev.pcidev = pcidevice;
    80015f74:	fd843783          	ld	a5,-40(s0)
    80015f78:	f6f43423          	sd	a5,-152(s0)
            // Add the common configuration, notify capability, and ISR to the bookkeeping structure
            viodev.common_cfg = pci_get_virtio_common_config(pcidevice);
    80015f7c:	fd843503          	ld	a0,-40(s0)
    80015f80:	eedfc0ef          	jal	ra,80012e6c <pci_get_virtio_common_config>
    80015f84:	87aa                	mv	a5,a0
    80015f86:	f6f43823          	sd	a5,-144(s0)
            viodev.notify_cap = pci_get_virtio_notify_capability(pcidevice);
    80015f8a:	fd843503          	ld	a0,-40(s0)
    80015f8e:	f79fc0ef          	jal	ra,80012f06 <pci_get_virtio_notify_capability>
    80015f92:	87aa                	mv	a5,a0
    80015f94:	f6f43c23          	sd	a5,-136(s0)
            viodev.isr = pci_get_virtio_isr_status(pcidevice);
    80015f98:	fd843503          	ld	a0,-40(s0)
    80015f9c:	832fd0ef          	jal	ra,80012fce <pci_get_virtio_isr_status>
    80015fa0:	87aa                	mv	a5,a0
    80015fa2:	f8f43023          	sd	a5,-128(s0)

            debugf("Common config at 0x%08x\n", viodev.common_cfg);
    80015fa6:	f7043783          	ld	a5,-144(s0)
    80015faa:	85be                	mv	a1,a5
    80015fac:	00006517          	auipc	a0,0x6
    80015fb0:	2e450513          	addi	a0,a0,740 # 8001c290 <pow10.0+0x1060>
    80015fb4:	e66ff0ef          	jal	ra,8001561a <debugf>
            debugf("Notify config at 0x%08x\n", viodev.notify_cap);
    80015fb8:	f7843783          	ld	a5,-136(s0)
    80015fbc:	85be                	mv	a1,a5
    80015fbe:	00006517          	auipc	a0,0x6
    80015fc2:	2f250513          	addi	a0,a0,754 # 8001c2b0 <pow10.0+0x1080>
    80015fc6:	e54ff0ef          	jal	ra,8001561a <debugf>
            debugf("ISR config at 0x%08x\n", viodev.isr);
    80015fca:	f8043783          	ld	a5,-128(s0)
    80015fce:	85be                	mv	a1,a5
    80015fd0:	00006517          	auipc	a0,0x6
    80015fd4:	30050513          	addi	a0,a0,768 # 8001c2d0 <pow10.0+0x10a0>
    80015fd8:	e42ff0ef          	jal	ra,8001561a <debugf>

            debugf("Status: %x\n", viodev.common_cfg->device_status);
    80015fdc:	f7043783          	ld	a5,-144(s0)
    80015fe0:	0147c783          	lbu	a5,20(a5)
    80015fe4:	0ff7f793          	andi	a5,a5,255
    80015fe8:	2781                	sext.w	a5,a5
    80015fea:	85be                	mv	a1,a5
    80015fec:	00006517          	auipc	a0,0x6
    80015ff0:	2fc50513          	addi	a0,a0,764 # 8001c2e8 <pow10.0+0x10b8>
    80015ff4:	e26ff0ef          	jal	ra,8001561a <debugf>
            viodev.common_cfg->device_status = VIRTIO_F_RESET;
    80015ff8:	f7043783          	ld	a5,-144(s0)
    80015ffc:	00078a23          	sb	zero,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
    80016000:	f7043783          	ld	a5,-144(s0)
    80016004:	0147c783          	lbu	a5,20(a5)
    80016008:	0ff7f793          	andi	a5,a5,255
    8001600c:	2781                	sext.w	a5,a5
    8001600e:	85be                	mv	a1,a5
    80016010:	00006517          	auipc	a0,0x6
    80016014:	2d850513          	addi	a0,a0,728 # 8001c2e8 <pow10.0+0x10b8>
    80016018:	e02ff0ef          	jal	ra,8001561a <debugf>
            viodev.common_cfg->device_status = VIRTIO_F_ACKNOWLEDGE;
    8001601c:	f7043783          	ld	a5,-144(s0)
    80016020:	4705                	li	a4,1
    80016022:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
    80016026:	f7043783          	ld	a5,-144(s0)
    8001602a:	0147c783          	lbu	a5,20(a5)
    8001602e:	0ff7f793          	andi	a5,a5,255
    80016032:	2781                	sext.w	a5,a5
    80016034:	85be                	mv	a1,a5
    80016036:	00006517          	auipc	a0,0x6
    8001603a:	2b250513          	addi	a0,a0,690 # 8001c2e8 <pow10.0+0x10b8>
    8001603e:	ddcff0ef          	jal	ra,8001561a <debugf>
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER;
    80016042:	f7043783          	ld	a5,-144(s0)
    80016046:	0147c703          	lbu	a4,20(a5)
    8001604a:	0ff77713          	andi	a4,a4,255
    8001604e:	00276713          	ori	a4,a4,2
    80016052:	0ff77713          	andi	a4,a4,255
    80016056:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
    8001605a:	f7043783          	ld	a5,-144(s0)
    8001605e:	0147c783          	lbu	a5,20(a5)
    80016062:	0ff7f793          	andi	a5,a5,255
    80016066:	2781                	sext.w	a5,a5
    80016068:	85be                	mv	a1,a5
    8001606a:	00006517          	auipc	a0,0x6
    8001606e:	27e50513          	addi	a0,a0,638 # 8001c2e8 <pow10.0+0x10b8>
    80016072:	da8ff0ef          	jal	ra,8001561a <debugf>
            viodev.common_cfg->device_status |= VIRTIO_F_FEATURES_OK;
    80016076:	f7043783          	ld	a5,-144(s0)
    8001607a:	0147c703          	lbu	a4,20(a5)
    8001607e:	0ff77713          	andi	a4,a4,255
    80016082:	00876713          	ori	a4,a4,8
    80016086:	0ff77713          	andi	a4,a4,255
    8001608a:	00e78a23          	sb	a4,20(a5)
            if (!(viodev.common_cfg->device_status & VIRTIO_F_FEATURES_OK)) {
    8001608e:	f7043783          	ld	a5,-144(s0)
    80016092:	0147c783          	lbu	a5,20(a5)
    80016096:	0ff7f793          	andi	a5,a5,255
    8001609a:	2781                	sext.w	a5,a5
    8001609c:	8ba1                	andi	a5,a5,8
    8001609e:	2781                	sext.w	a5,a5
    800160a0:	e799                	bnez	a5,800160ae <virtio_init+0x18c>
                debugf("Device does not accept features\n");
    800160a2:	00006517          	auipc	a0,0x6
    800160a6:	25650513          	addi	a0,a0,598 # 8001c2f8 <pow10.0+0x10c8>
    800160aa:	d70ff0ef          	jal	ra,8001561a <debugf>
            }
            
            // Fix qsize below
            viodev.common_cfg->queue_select = 0;
    800160ae:	f7043783          	ld	a5,-144(s0)
    800160b2:	00079b23          	sh	zero,22(a5)
            uint16_t qsize = viodev.common_cfg->queue_size;
    800160b6:	f7043783          	ld	a5,-144(s0)
    800160ba:	0187d783          	lhu	a5,24(a5)
    800160be:	fcf41b23          	sh	a5,-42(s0)
            debugf("Virtio device has queue size %d\n", qsize);
    800160c2:	fd645783          	lhu	a5,-42(s0)
    800160c6:	2781                	sext.w	a5,a5
    800160c8:	85be                	mv	a1,a5
    800160ca:	00006517          	auipc	a0,0x6
    800160ce:	25650513          	addi	a0,a0,598 # 8001c320 <pow10.0+0x10f0>
    800160d2:	d48ff0ef          	jal	ra,8001561a <debugf>

            // Allocate contiguous physical memory for descriptor table, driver ring, and device ring
            // These are virtual memory pointers that we will use in the OS side.
            viodev.desc = (VirtioDescriptor *)kzalloc(VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
    800160d6:	fd645783          	lhu	a5,-42(s0)
    800160da:	2781                	sext.w	a5,a5
    800160dc:	0047979b          	slliw	a5,a5,0x4
    800160e0:	2781                	sext.w	a5,a5
    800160e2:	85be                	mv	a1,a5
    800160e4:	4505                	li	a0,1
    800160e6:	fb8fe0ef          	jal	ra,8001489e <kcalloc>
    800160ea:	87aa                	mv	a5,a0
    800160ec:	f8f43423          	sd	a5,-120(s0)
            viodev.driver = (VirtioDriverRing *)kzalloc(VIRTIO_DRIVER_TABLE_BYTES(qsize));
    800160f0:	fd645783          	lhu	a5,-42(s0)
    800160f4:	2781                	sext.w	a5,a5
    800160f6:	278d                	addiw	a5,a5,3
    800160f8:	2781                	sext.w	a5,a5
    800160fa:	0017979b          	slliw	a5,a5,0x1
    800160fe:	2781                	sext.w	a5,a5
    80016100:	85be                	mv	a1,a5
    80016102:	4505                	li	a0,1
    80016104:	f9afe0ef          	jal	ra,8001489e <kcalloc>
    80016108:	87aa                	mv	a5,a0
    8001610a:	f8f43823          	sd	a5,-112(s0)
            viodev.device = (VirtioDeviceRing *)kzalloc(VIRTIO_DEVICE_TABLE_BYTES(qsize));
    8001610e:	fd645783          	lhu	a5,-42(s0)
    80016112:	2781                	sext.w	a5,a5
    80016114:	0037979b          	slliw	a5,a5,0x3
    80016118:	2781                	sext.w	a5,a5
    8001611a:	2799                	addiw	a5,a5,6
    8001611c:	2781                	sext.w	a5,a5
    8001611e:	85be                	mv	a1,a5
    80016120:	4505                	li	a0,1
    80016122:	f7cfe0ef          	jal	ra,8001489e <kcalloc>
    80016126:	87aa                	mv	a5,a0
    80016128:	f8f43c23          	sd	a5,-104(s0)
            debugf("Descriptor ring size: %d\n", VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
    8001612c:	fd645783          	lhu	a5,-42(s0)
    80016130:	2781                	sext.w	a5,a5
    80016132:	0047979b          	slliw	a5,a5,0x4
    80016136:	2781                	sext.w	a5,a5
    80016138:	85be                	mv	a1,a5
    8001613a:	00006517          	auipc	a0,0x6
    8001613e:	20e50513          	addi	a0,a0,526 # 8001c348 <pow10.0+0x1118>
    80016142:	cd8ff0ef          	jal	ra,8001561a <debugf>
            debugf("Driver ring size: %d\n", VIRTIO_DRIVER_TABLE_BYTES(qsize));
    80016146:	fd645783          	lhu	a5,-42(s0)
    8001614a:	2781                	sext.w	a5,a5
    8001614c:	278d                	addiw	a5,a5,3
    8001614e:	2781                	sext.w	a5,a5
    80016150:	0017979b          	slliw	a5,a5,0x1
    80016154:	2781                	sext.w	a5,a5
    80016156:	85be                	mv	a1,a5
    80016158:	00006517          	auipc	a0,0x6
    8001615c:	21050513          	addi	a0,a0,528 # 8001c368 <pow10.0+0x1138>
    80016160:	cbaff0ef          	jal	ra,8001561a <debugf>
            debugf("Device ring size: %d\n", VIRTIO_DEVICE_TABLE_BYTES(qsize));
    80016164:	fd645783          	lhu	a5,-42(s0)
    80016168:	2781                	sext.w	a5,a5
    8001616a:	0037979b          	slliw	a5,a5,0x3
    8001616e:	2781                	sext.w	a5,a5
    80016170:	2799                	addiw	a5,a5,6
    80016172:	2781                	sext.w	a5,a5
    80016174:	85be                	mv	a1,a5
    80016176:	00006517          	auipc	a0,0x6
    8001617a:	20a50513          	addi	a0,a0,522 # 8001c380 <pow10.0+0x1150>
    8001617e:	c9cff0ef          	jal	ra,8001561a <debugf>

            // Initialize the indices
            viodev.desc_idx = 0;
    80016182:	fa041823          	sh	zero,-80(s0)
            viodev.driver_idx = 0;
    80016186:	fa041923          	sh	zero,-78(s0)
            viodev.device_idx = 0;
    8001618a:	fa041a23          	sh	zero,-76(s0)

            // Add the physical addresses for the descriptor table, driver ring, and device ring to the common configuration
            // We translate the virtual addresses so the devices can actuall access the memory.
            void *phys_desc = kernel_mmu_translate(viodev.desc),
    8001618e:	f8843783          	ld	a5,-120(s0)
    80016192:	853e                	mv	a0,a5
    80016194:	c17fd0ef          	jal	ra,80013daa <kernel_mmu_translate>
    80016198:	87aa                	mv	a5,a0
    8001619a:	fcf43423          	sd	a5,-56(s0)
                *phys_driver = kernel_mmu_translate(viodev.driver),
    8001619e:	f9043783          	ld	a5,-112(s0)
    800161a2:	853e                	mv	a0,a5
    800161a4:	c07fd0ef          	jal	ra,80013daa <kernel_mmu_translate>
    800161a8:	87aa                	mv	a5,a0
    800161aa:	fcf43023          	sd	a5,-64(s0)
                *phys_device = kernel_mmu_translate(viodev.device);
    800161ae:	f9843783          	ld	a5,-104(s0)
    800161b2:	853e                	mv	a0,a5
    800161b4:	bf7fd0ef          	jal	ra,80013daa <kernel_mmu_translate>
    800161b8:	87aa                	mv	a5,a0
    800161ba:	faf43c23          	sd	a5,-72(s0)
            viodev.common_cfg->queue_desc = phys_desc;
    800161be:	f7043783          	ld	a5,-144(s0)
    800161c2:	fc843703          	ld	a4,-56(s0)
    800161c6:	f398                	sd	a4,32(a5)
            viodev.common_cfg->queue_driver = phys_driver;
    800161c8:	f7043783          	ld	a5,-144(s0)
    800161cc:	fc043703          	ld	a4,-64(s0)
    800161d0:	f798                	sd	a4,40(a5)
            viodev.common_cfg->queue_device = phys_device;
    800161d2:	f7043783          	ld	a5,-144(s0)
    800161d6:	fb843703          	ld	a4,-72(s0)
    800161da:	fb98                	sd	a4,48(a5)
            debugf("virtio_init: queue_desc = 0x%08lx physical (0x%08lx virtual)\n", phys_desc, viodev.desc);
    800161dc:	f8843783          	ld	a5,-120(s0)
    800161e0:	863e                	mv	a2,a5
    800161e2:	fc843583          	ld	a1,-56(s0)
    800161e6:	00006517          	auipc	a0,0x6
    800161ea:	1b250513          	addi	a0,a0,434 # 8001c398 <pow10.0+0x1168>
    800161ee:	c2cff0ef          	jal	ra,8001561a <debugf>
            debugf("virtio_init: queue_driver = 0x%08lx physical (0x%08lx virtual)\n", phys_driver, viodev.driver);
    800161f2:	f9043783          	ld	a5,-112(s0)
    800161f6:	863e                	mv	a2,a5
    800161f8:	fc043583          	ld	a1,-64(s0)
    800161fc:	00006517          	auipc	a0,0x6
    80016200:	1dc50513          	addi	a0,a0,476 # 8001c3d8 <pow10.0+0x11a8>
    80016204:	c16ff0ef          	jal	ra,8001561a <debugf>
            debugf("virtio_init: queue_device = 0x%08lx physical (0x%08lx virtual)\n", phys_device, viodev.device);
    80016208:	f9843783          	ld	a5,-104(s0)
    8001620c:	863e                	mv	a2,a5
    8001620e:	fb843583          	ld	a1,-72(s0)
    80016212:	00006517          	auipc	a0,0x6
    80016216:	20650513          	addi	a0,a0,518 # 8001c418 <pow10.0+0x11e8>
    8001621a:	c00ff0ef          	jal	ra,8001561a <debugf>
            if (viodev.common_cfg->queue_desc != phys_desc) {
    8001621e:	f7043783          	ld	a5,-144(s0)
    80016222:	739c                	ld	a5,32(a5)
    80016224:	873e                	mv	a4,a5
    80016226:	fc843783          	ld	a5,-56(s0)
    8001622a:	02e78363          	beq	a5,a4,80016250 <virtio_init+0x32e>
                debugf("Device does not reflect physical desc ring  @0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_desc, phys_desc, viodev.common_cfg->queue_desc);
    8001622e:	f7043783          	ld	a5,-144(s0)
    80016232:	02078713          	addi	a4,a5,32
    80016236:	f7043783          	ld	a5,-144(s0)
    8001623a:	739c                	ld	a5,32(a5)
    8001623c:	86be                	mv	a3,a5
    8001623e:	fc843603          	ld	a2,-56(s0)
    80016242:	85ba                	mv	a1,a4
    80016244:	00006517          	auipc	a0,0x6
    80016248:	21450513          	addi	a0,a0,532 # 8001c458 <pow10.0+0x1228>
    8001624c:	bceff0ef          	jal	ra,8001561a <debugf>
            }
            if (viodev.common_cfg->queue_driver != phys_driver) {
    80016250:	f7043783          	ld	a5,-144(s0)
    80016254:	779c                	ld	a5,40(a5)
    80016256:	873e                	mv	a4,a5
    80016258:	fc043783          	ld	a5,-64(s0)
    8001625c:	02e78363          	beq	a5,a4,80016282 <virtio_init+0x360>
                debugf("Device does not reflect physical driver ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_driver, phys_driver, viodev.common_cfg->queue_driver);
    80016260:	f7043783          	ld	a5,-144(s0)
    80016264:	02878713          	addi	a4,a5,40
    80016268:	f7043783          	ld	a5,-144(s0)
    8001626c:	779c                	ld	a5,40(a5)
    8001626e:	86be                	mv	a3,a5
    80016270:	fc043603          	ld	a2,-64(s0)
    80016274:	85ba                	mv	a1,a4
    80016276:	00006517          	auipc	a0,0x6
    8001627a:	23250513          	addi	a0,a0,562 # 8001c4a8 <pow10.0+0x1278>
    8001627e:	b9cff0ef          	jal	ra,8001561a <debugf>
            }
            if (viodev.common_cfg->queue_device != phys_device){
    80016282:	f7043783          	ld	a5,-144(s0)
    80016286:	7b9c                	ld	a5,48(a5)
    80016288:	873e                	mv	a4,a5
    8001628a:	fb843783          	ld	a5,-72(s0)
    8001628e:	02e78363          	beq	a5,a4,800162b4 <virtio_init+0x392>
                debugf("Device does not reflect physical device ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_device, phys_device, viodev.common_cfg->queue_device);
    80016292:	f7043783          	ld	a5,-144(s0)
    80016296:	03078713          	addi	a4,a5,48
    8001629a:	f7043783          	ld	a5,-144(s0)
    8001629e:	7b9c                	ld	a5,48(a5)
    800162a0:	86be                	mv	a3,a5
    800162a2:	fb843603          	ld	a2,-72(s0)
    800162a6:	85ba                	mv	a1,a4
    800162a8:	00006517          	auipc	a0,0x6
    800162ac:	25050513          	addi	a0,a0,592 # 8001c4f8 <pow10.0+0x12c8>
    800162b0:	b6aff0ef          	jal	ra,8001561a <debugf>
            }
            debugf("Set up tables for virtio device\n");
    800162b4:	00006517          	auipc	a0,0x6
    800162b8:	29450513          	addi	a0,a0,660 # 8001c548 <pow10.0+0x1318>
    800162bc:	b5eff0ef          	jal	ra,8001561a <debugf>
            viodev.common_cfg->queue_enable = 1;
    800162c0:	f7043783          	ld	a5,-144(s0)
    800162c4:	4705                	li	a4,1
    800162c6:	00e79e23          	sh	a4,28(a5)
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER_OK;
    800162ca:	f7043783          	ld	a5,-144(s0)
    800162ce:	0147c703          	lbu	a4,20(a5)
    800162d2:	0ff77713          	andi	a4,a4,255
    800162d6:	00476713          	ori	a4,a4,4
    800162da:	0ff77713          	andi	a4,a4,255
    800162de:	00e78a23          	sb	a4,20(a5)
            // Add to vector using vector_push
            virtio_save_device(viodev);
    800162e2:	f6843e03          	ld	t3,-152(s0)
    800162e6:	f7043303          	ld	t1,-144(s0)
    800162ea:	f7843883          	ld	a7,-136(s0)
    800162ee:	f8043803          	ld	a6,-128(s0)
    800162f2:	f8843503          	ld	a0,-120(s0)
    800162f6:	f9043583          	ld	a1,-112(s0)
    800162fa:	f9843603          	ld	a2,-104(s0)
    800162fe:	fa043683          	ld	a3,-96(s0)
    80016302:	fa843703          	ld	a4,-88(s0)
    80016306:	fb043783          	ld	a5,-80(s0)
    8001630a:	f1c43823          	sd	t3,-240(s0)
    8001630e:	f0643c23          	sd	t1,-232(s0)
    80016312:	f3143023          	sd	a7,-224(s0)
    80016316:	f3043423          	sd	a6,-216(s0)
    8001631a:	f2a43823          	sd	a0,-208(s0)
    8001631e:	f2b43c23          	sd	a1,-200(s0)
    80016322:	f4c43023          	sd	a2,-192(s0)
    80016326:	f4d43423          	sd	a3,-184(s0)
    8001632a:	f4e43823          	sd	a4,-176(s0)
    8001632e:	f4f43c23          	sd	a5,-168(s0)
    80016332:	f1040793          	addi	a5,s0,-240
    80016336:	853e                	mv	a0,a5
    80016338:	acdff0ef          	jal	ra,80015e04 <virtio_save_device>
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    8001633c:	fe843783          	ld	a5,-24(s0)
    80016340:	0785                	addi	a5,a5,1
    80016342:	fef43423          	sd	a5,-24(s0)
    80016346:	fe843703          	ld	a4,-24(s0)
    8001634a:	fe043783          	ld	a5,-32(s0)
    8001634e:	c0f763e3          	bltu	a4,a5,80015f54 <virtio_init+0x32>
        }
    }
    rng_init();
    80016352:	ae6fc0ef          	jal	ra,80012638 <rng_init>
    block_device_init();
    80016356:	535000ef          	jal	ra,8001708a <block_device_init>
    debugf("virtio_init: Done initializing virtio system\n");
    8001635a:	00006517          	auipc	a0,0x6
    8001635e:	21650513          	addi	a0,a0,534 # 8001c570 <pow10.0+0x1340>
    80016362:	ab8ff0ef          	jal	ra,8001561a <debugf>
}
    80016366:	0001                	nop
    80016368:	70ae                	ld	ra,232(sp)
    8001636a:	740e                	ld	s0,224(sp)
    8001636c:	616d                	addi	sp,sp,240
    8001636e:	8082                	ret

0000000080016370 <virtio_notify_register>:


// Get the notify capability for the given virtio device.
volatile uint32_t *virtio_notify_register(volatile VirtioDevice *device) {
    80016370:	715d                	addi	sp,sp,-80
    80016372:	e486                	sd	ra,72(sp)
    80016374:	e0a2                	sd	s0,64(sp)
    80016376:	0880                	addi	s0,sp,80
    80016378:	faa43c23          	sd	a0,-72(s0)
    // struct VirtioCapability *vio_cap = pci_get_virtio_capability(device->pcidev, VIRTIO_PCI_CAP_NOTIFY_CFG);
    // volatile VirtioPciNotifyCfg *notify_cap = pci_get_virtio_notify_capability(device->pcidev);
    uint8_t bar_num = device->notify_cap->cap.bar;
    8001637c:	fb843783          	ld	a5,-72(s0)
    80016380:	6b9c                	ld	a5,16(a5)
    80016382:	0047c783          	lbu	a5,4(a5)
    80016386:	fef407a3          	sb	a5,-17(s0)
    uint64_t offset = device->notify_cap->cap.offset;
    8001638a:	fb843783          	ld	a5,-72(s0)
    8001638e:	6b9c                	ld	a5,16(a5)
    80016390:	479c                	lw	a5,8(a5)
    80016392:	2781                	sext.w	a5,a5
    80016394:	1782                	slli	a5,a5,0x20
    80016396:	9381                	srli	a5,a5,0x20
    80016398:	fef43023          	sd	a5,-32(s0)
    uint16_t queue_notify_off = device->common_cfg->queue_notify_off;
    8001639c:	fb843783          	ld	a5,-72(s0)
    800163a0:	679c                	ld	a5,8(a5)
    800163a2:	01e7d783          	lhu	a5,30(a5)
    800163a6:	fcf41f23          	sh	a5,-34(s0)
    uint32_t notify_off_multiplier = device->notify_cap->notify_off_multiplier;
    800163aa:	fb843783          	ld	a5,-72(s0)
    800163ae:	6b9c                	ld	a5,16(a5)
    800163b0:	4b9c                	lw	a5,16(a5)
    800163b2:	fcf42c23          	sw	a5,-40(s0)
    uint64_t bar = (uint64_t)pci_get_device_bar(device->pcidev, bar_num);
    800163b6:	fb843783          	ld	a5,-72(s0)
    800163ba:	639c                	ld	a5,0(a5)
    800163bc:	fef44703          	lbu	a4,-17(s0)
    800163c0:	85ba                	mv	a1,a4
    800163c2:	853e                	mv	a0,a5
    800163c4:	bcffc0ef          	jal	ra,80012f92 <pci_get_device_bar>
    800163c8:	87aa                	mv	a5,a0
    800163ca:	fcf43823          	sd	a5,-48(s0)
    debugf("Notify cap bar=%d offset=%x, (len=%d)\n", bar_num, offset, device->notify_cap->cap.length);
    800163ce:	fef44783          	lbu	a5,-17(s0)
    800163d2:	0007871b          	sext.w	a4,a5
    800163d6:	fb843783          	ld	a5,-72(s0)
    800163da:	6b9c                	ld	a5,16(a5)
    800163dc:	47dc                	lw	a5,12(a5)
    800163de:	2781                	sext.w	a5,a5
    800163e0:	86be                	mv	a3,a5
    800163e2:	fe043603          	ld	a2,-32(s0)
    800163e6:	85ba                	mv	a1,a4
    800163e8:	00006517          	auipc	a0,0x6
    800163ec:	1b850513          	addi	a0,a0,440 # 8001c5a0 <pow10.0+0x1370>
    800163f0:	a2aff0ef          	jal	ra,8001561a <debugf>
    debugf("BAR at %x, offset=%x, queue_notify_off=%x, notify_off_mult=%x\n", bar, offset, queue_notify_off, notify_off_multiplier);
    800163f4:	fde45783          	lhu	a5,-34(s0)
    800163f8:	2781                	sext.w	a5,a5
    800163fa:	fd842703          	lw	a4,-40(s0)
    800163fe:	86be                	mv	a3,a5
    80016400:	fe043603          	ld	a2,-32(s0)
    80016404:	fd043583          	ld	a1,-48(s0)
    80016408:	00006517          	auipc	a0,0x6
    8001640c:	1c050513          	addi	a0,a0,448 # 8001c5c8 <pow10.0+0x1398>
    80016410:	a0aff0ef          	jal	ra,8001561a <debugf>

    uint32_t *notify = bar + BAR_NOTIFY_CAP(offset, queue_notify_off, notify_off_multiplier);
    80016414:	fde45783          	lhu	a5,-34(s0)
    80016418:	2781                	sext.w	a5,a5
    8001641a:	fd842703          	lw	a4,-40(s0)
    8001641e:	02f707bb          	mulw	a5,a4,a5
    80016422:	2781                	sext.w	a5,a5
    80016424:	02079713          	slli	a4,a5,0x20
    80016428:	9301                	srli	a4,a4,0x20
    8001642a:	fe043783          	ld	a5,-32(s0)
    8001642e:	973e                	add	a4,a4,a5
    80016430:	fd043783          	ld	a5,-48(s0)
    80016434:	97ba                	add	a5,a5,a4
    80016436:	fcf43423          	sd	a5,-56(s0)
    return notify;
    8001643a:	fc843783          	ld	a5,-56(s0)
}
    8001643e:	853e                	mv	a0,a5
    80016440:	60a6                	ld	ra,72(sp)
    80016442:	6406                	ld	s0,64(sp)
    80016444:	6161                	addi	sp,sp,80
    80016446:	8082                	ret

0000000080016448 <virtio_notify>:
 * @brief Virtio notification
 * @param viodev - virtio device to notify for
 * @param which_queue - queue number to notify
 */
void virtio_notify(volatile VirtioDevice *viodev, uint16_t which_queue)
{
    80016448:	7179                	addi	sp,sp,-48
    8001644a:	f406                	sd	ra,40(sp)
    8001644c:	f022                	sd	s0,32(sp)
    8001644e:	1800                	addi	s0,sp,48
    80016450:	fca43c23          	sd	a0,-40(s0)
    80016454:	87ae                	mv	a5,a1
    80016456:	fcf41b23          	sh	a5,-42(s0)
    uint16_t num_queues = viodev->common_cfg->num_queues;
    8001645a:	fd843783          	ld	a5,-40(s0)
    8001645e:	679c                	ld	a5,8(a5)
    80016460:	0127d783          	lhu	a5,18(a5)
    80016464:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    80016468:	fd645703          	lhu	a4,-42(s0)
    8001646c:	fee45783          	lhu	a5,-18(s0)
    80016470:	2701                	sext.w	a4,a4
    80016472:	2781                	sext.w	a5,a5
    80016474:	02f76263          	bltu	a4,a5,80016498 <virtio_notify+0x50>
        logf(LOG_ERROR, "virtio_notify: Provided queue number %d is too big (num_queues=%d)...\n", which_queue, num_queues);
    80016478:	fd645783          	lhu	a5,-42(s0)
    8001647c:	2781                	sext.w	a5,a5
    8001647e:	fee45703          	lhu	a4,-18(s0)
    80016482:	2701                	sext.w	a4,a4
    80016484:	86ba                	mv	a3,a4
    80016486:	863e                	mv	a2,a5
    80016488:	00006597          	auipc	a1,0x6
    8001648c:	18058593          	addi	a1,a1,384 # 8001c608 <pow10.0+0x13d8>
    80016490:	4505                	li	a0,1
    80016492:	92aff0ef          	jal	ra,800155bc <logf>
        return;
    80016496:	a091                	j	800164da <virtio_notify+0x92>
    }

    // Select the queue we are looking at
    viodev->common_cfg->queue_select = which_queue;
    80016498:	fd843783          	ld	a5,-40(s0)
    8001649c:	679c                	ld	a5,8(a5)
    8001649e:	fd645703          	lhu	a4,-42(s0)
    800164a2:	00e79b23          	sh	a4,22(a5)

    volatile uint16_t *notify_register = virtio_notify_register(viodev);
    800164a6:	fd843503          	ld	a0,-40(s0)
    800164aa:	ec7ff0ef          	jal	ra,80016370 <virtio_notify_register>
    800164ae:	fea43023          	sd	a0,-32(s0)
    debugf("Notifying at 0x%p on instruction...\n", notify_register);
    800164b2:	fe043583          	ld	a1,-32(s0)
    800164b6:	00006517          	auipc	a0,0x6
    800164ba:	19a50513          	addi	a0,a0,410 # 8001c650 <pow10.0+0x1420>
    800164be:	95cff0ef          	jal	ra,8001561a <debugf>
    *notify_register = which_queue;
    800164c2:	fe043783          	ld	a5,-32(s0)
    800164c6:	fd645703          	lhu	a4,-42(s0)
    800164ca:	00e79023          	sh	a4,0(a5)
    debugf("Notified device\n\n");
    800164ce:	00006517          	auipc	a0,0x6
    800164d2:	1aa50513          	addi	a0,a0,426 # 8001c678 <pow10.0+0x1448>
    800164d6:	944ff0ef          	jal	ra,8001561a <debugf>
}
    800164da:	70a2                	ld	ra,40(sp)
    800164dc:	7402                	ld	s0,32(sp)
    800164de:	6145                	addi	sp,sp,48
    800164e0:	8082                	ret

00000000800164e2 <virtio_set_queue_and_get_size>:

// Select the queue and get its size
uint64_t virtio_set_queue_and_get_size(volatile VirtioDevice *device, uint16_t which_queue) {
    800164e2:	7179                	addi	sp,sp,-48
    800164e4:	f406                	sd	ra,40(sp)
    800164e6:	f022                	sd	s0,32(sp)
    800164e8:	1800                	addi	s0,sp,48
    800164ea:	fca43c23          	sd	a0,-40(s0)
    800164ee:	87ae                	mv	a5,a1
    800164f0:	fcf41b23          	sh	a5,-42(s0)
    device->common_cfg->queue_select = which_queue;
    800164f4:	fd843783          	ld	a5,-40(s0)
    800164f8:	679c                	ld	a5,8(a5)
    800164fa:	fd645703          	lhu	a4,-42(s0)
    800164fe:	00e79b23          	sh	a4,22(a5)
    uint16_t num_queues = device->common_cfg->num_queues;
    80016502:	fd843783          	ld	a5,-40(s0)
    80016506:	679c                	ld	a5,8(a5)
    80016508:	0127d783          	lhu	a5,18(a5)
    8001650c:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    80016510:	fd645703          	lhu	a4,-42(s0)
    80016514:	fee45783          	lhu	a5,-18(s0)
    80016518:	2701                	sext.w	a4,a4
    8001651a:	2781                	sext.w	a5,a5
    8001651c:	02f76363          	bltu	a4,a5,80016542 <virtio_set_queue_and_get_size+0x60>
        fatalf(LOG_ERROR, "virtio_notify: Provided queue number %d is too big (num_queues=%d)...\n", which_queue, num_queues);
    80016520:	fd645783          	lhu	a5,-42(s0)
    80016524:	2781                	sext.w	a5,a5
    80016526:	fee45703          	lhu	a4,-18(s0)
    8001652a:	2701                	sext.w	a4,a4
    8001652c:	86ba                	mv	a3,a4
    8001652e:	863e                	mv	a2,a5
    80016530:	00006597          	auipc	a1,0x6
    80016534:	0d858593          	addi	a1,a1,216 # 8001c608 <pow10.0+0x13d8>
    80016538:	4505                	li	a0,1
    8001653a:	936ff0ef          	jal	ra,80015670 <fatalf>
        return -1ULL;
    8001653e:	57fd                	li	a5,-1
    80016540:	a801                	j	80016550 <virtio_set_queue_and_get_size+0x6e>
    }

    return device->common_cfg->queue_size;
    80016542:	fd843783          	ld	a5,-40(s0)
    80016546:	679c                	ld	a5,8(a5)
    80016548:	0187d783          	lhu	a5,24(a5)
    8001654c:	17c2                	slli	a5,a5,0x30
    8001654e:	93c1                	srli	a5,a5,0x30
}
    80016550:	853e                	mv	a0,a5
    80016552:	70a2                	ld	ra,40(sp)
    80016554:	7402                	ld	s0,32(sp)
    80016556:	6145                	addi	sp,sp,48
    80016558:	8082                	ret

000000008001655a <virtio_send_descriptor>:

void virtio_send_descriptor(volatile VirtioDevice *device, uint16_t which_queue, VirtioDescriptor descriptor, bool notify_device_when_done) {
    8001655a:	7139                	addi	sp,sp,-64
    8001655c:	fc06                	sd	ra,56(sp)
    8001655e:	f822                	sd	s0,48(sp)
    80016560:	0080                	addi	s0,sp,64
    80016562:	fca43c23          	sd	a0,-40(s0)
    80016566:	87ae                	mv	a5,a1
    80016568:	fcc43023          	sd	a2,-64(s0)
    8001656c:	fcd43423          	sd	a3,-56(s0)
    80016570:	fcf41b23          	sh	a5,-42(s0)
    80016574:	87ba                	mv	a5,a4
    80016576:	fcf40aa3          	sb	a5,-43(s0)
    // Confirm the device is ready
    if (!device->ready) {
    8001657a:	fd843783          	ld	a5,-40(s0)
    8001657e:	04e7c783          	lbu	a5,78(a5)
    80016582:	0ff7f793          	andi	a5,a5,255
    80016586:	0017c793          	xori	a5,a5,1
    8001658a:	0ff7f793          	andi	a5,a5,255
    8001658e:	cb81                	beqz	a5,8001659e <virtio_send_descriptor+0x44>
        fatalf("device is not ready\n");
    80016590:	00006517          	auipc	a0,0x6
    80016594:	10050513          	addi	a0,a0,256 # 8001c690 <pow10.0+0x1460>
    80016598:	8d8ff0ef          	jal	ra,80015670 <fatalf>
        return;
    8001659c:	a229                	j	800166a6 <virtio_send_descriptor+0x14c>
    }

    // Select the queue we're using
    if (which_queue >= device->common_cfg->num_queues) {
    8001659e:	fd843783          	ld	a5,-40(s0)
    800165a2:	679c                	ld	a5,8(a5)
    800165a4:	0127d783          	lhu	a5,18(a5)
    800165a8:	17c2                	slli	a5,a5,0x30
    800165aa:	93c1                	srli	a5,a5,0x30
    800165ac:	fd645703          	lhu	a4,-42(s0)
    800165b0:	2701                	sext.w	a4,a4
    800165b2:	2781                	sext.w	a5,a5
    800165b4:	02f76763          	bltu	a4,a5,800165e2 <virtio_send_descriptor+0x88>
        fatalf("queue number %d is too big (num_queues=%d)\n", which_queue, device->common_cfg->num_queues);
    800165b8:	fd645783          	lhu	a5,-42(s0)
    800165bc:	0007871b          	sext.w	a4,a5
    800165c0:	fd843783          	ld	a5,-40(s0)
    800165c4:	679c                	ld	a5,8(a5)
    800165c6:	0127d783          	lhu	a5,18(a5)
    800165ca:	17c2                	slli	a5,a5,0x30
    800165cc:	93c1                	srli	a5,a5,0x30
    800165ce:	2781                	sext.w	a5,a5
    800165d0:	863e                	mv	a2,a5
    800165d2:	85ba                	mv	a1,a4
    800165d4:	00006517          	auipc	a0,0x6
    800165d8:	0d450513          	addi	a0,a0,212 # 8001c6a8 <pow10.0+0x1478>
    800165dc:	894ff0ef          	jal	ra,80015670 <fatalf>
        return;
    800165e0:	a0d9                	j	800166a6 <virtio_send_descriptor+0x14c>
    }

    // The size of the queue we're using
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    800165e2:	fd645783          	lhu	a5,-42(s0)
    800165e6:	85be                	mv	a1,a5
    800165e8:	fd843503          	ld	a0,-40(s0)
    800165ec:	ef7ff0ef          	jal	ra,800164e2 <virtio_set_queue_and_get_size>
    800165f0:	fea43423          	sd	a0,-24(s0)
    uint64_t descriptor_index = device->desc_idx;
    800165f4:	fd843783          	ld	a5,-40(s0)
    800165f8:	0487d783          	lhu	a5,72(a5)
    800165fc:	17c2                	slli	a5,a5,0x30
    800165fe:	93c1                	srli	a5,a5,0x30
    80016600:	fef43023          	sd	a5,-32(s0)

    // Put the descriptor in the descriptor table
    device->desc[descriptor_index] = descriptor;
    80016604:	fd843783          	ld	a5,-40(s0)
    80016608:	7398                	ld	a4,32(a5)
    8001660a:	fe043783          	ld	a5,-32(s0)
    8001660e:	0792                	slli	a5,a5,0x4
    80016610:	97ba                	add	a5,a5,a4
    80016612:	fc043703          	ld	a4,-64(s0)
    80016616:	e398                	sd	a4,0(a5)
    80016618:	fc843703          	ld	a4,-56(s0)
    8001661c:	e798                	sd	a4,8(a5)
    // Put the descriptor into the driver ring
    device->driver->ring[device->driver->idx % queue_size] = descriptor_index;
    8001661e:	fd843783          	ld	a5,-40(s0)
    80016622:	7794                	ld	a3,40(a5)
    80016624:	fd843783          	ld	a5,-40(s0)
    80016628:	779c                	ld	a5,40(a5)
    8001662a:	0027d783          	lhu	a5,2(a5)
    8001662e:	17c2                	slli	a5,a5,0x30
    80016630:	93c1                	srli	a5,a5,0x30
    80016632:	873e                	mv	a4,a5
    80016634:	fe843783          	ld	a5,-24(s0)
    80016638:	02f777b3          	remu	a5,a4,a5
    8001663c:	fe043703          	ld	a4,-32(s0)
    80016640:	1742                	slli	a4,a4,0x30
    80016642:	9341                	srli	a4,a4,0x30
    80016644:	0786                	slli	a5,a5,0x1
    80016646:	97b6                	add	a5,a5,a3
    80016648:	00e79223          	sh	a4,4(a5)
    // Increment the index to make it "visible" to the device
    device->driver->idx++;
    8001664c:	fd843783          	ld	a5,-40(s0)
    80016650:	779c                	ld	a5,40(a5)
    80016652:	0027d703          	lhu	a4,2(a5)
    80016656:	1742                	slli	a4,a4,0x30
    80016658:	9341                	srli	a4,a4,0x30
    8001665a:	2705                	addiw	a4,a4,1
    8001665c:	1742                	slli	a4,a4,0x30
    8001665e:	9341                	srli	a4,a4,0x30
    80016660:	00e79123          	sh	a4,2(a5)
    // Update the descriptor index for our bookkeeping
    device->desc_idx = (device->desc_idx + 1) % queue_size;
    80016664:	fd843783          	ld	a5,-40(s0)
    80016668:	0487d783          	lhu	a5,72(a5)
    8001666c:	17c2                	slli	a5,a5,0x30
    8001666e:	93c1                	srli	a5,a5,0x30
    80016670:	2781                	sext.w	a5,a5
    80016672:	2785                	addiw	a5,a5,1
    80016674:	2781                	sext.w	a5,a5
    80016676:	873e                	mv	a4,a5
    80016678:	fe843783          	ld	a5,-24(s0)
    8001667c:	02f777b3          	remu	a5,a4,a5
    80016680:	03079713          	slli	a4,a5,0x30
    80016684:	9341                	srli	a4,a4,0x30
    80016686:	fd843783          	ld	a5,-40(s0)
    8001668a:	04e79423          	sh	a4,72(a5)

    // Notify the device if we're ready to do so
    if (notify_device_when_done) {
    8001668e:	fd544783          	lbu	a5,-43(s0)
    80016692:	0ff7f793          	andi	a5,a5,255
    80016696:	cb81                	beqz	a5,800166a6 <virtio_send_descriptor+0x14c>
        virtio_notify(device, which_queue);
    80016698:	fd645783          	lhu	a5,-42(s0)
    8001669c:	85be                	mv	a1,a5
    8001669e:	fd843503          	ld	a0,-40(s0)
    800166a2:	da7ff0ef          	jal	ra,80016448 <virtio_notify>
    }
}
    800166a6:	70e2                	ld	ra,56(sp)
    800166a8:	7442                	ld	s0,48(sp)
    800166aa:	6121                	addi	sp,sp,64
    800166ac:	8082                	ret

00000000800166ae <virtio_receive_descriptor>:

VirtioDescriptor *virtio_receive_descriptor(volatile VirtioDevice *device, uint16_t which_queue, uint32_t *id, uint32_t *len) {
    800166ae:	715d                	addi	sp,sp,-80
    800166b0:	e486                	sd	ra,72(sp)
    800166b2:	e0a2                	sd	s0,64(sp)
    800166b4:	0880                	addi	s0,sp,80
    800166b6:	fca43423          	sd	a0,-56(s0)
    800166ba:	87ae                	mv	a5,a1
    800166bc:	fac43c23          	sd	a2,-72(s0)
    800166c0:	fad43823          	sd	a3,-80(s0)
    800166c4:	fcf41323          	sh	a5,-58(s0)
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    800166c8:	fc645783          	lhu	a5,-58(s0)
    800166cc:	85be                	mv	a1,a5
    800166ce:	fc843503          	ld	a0,-56(s0)
    800166d2:	e11ff0ef          	jal	ra,800164e2 <virtio_set_queue_and_get_size>
    800166d6:	fea43423          	sd	a0,-24(s0)
    uint64_t descriptor_index = device->device_idx;
    800166da:	fc843783          	ld	a5,-56(s0)
    800166de:	04c7d783          	lhu	a5,76(a5)
    800166e2:	17c2                	slli	a5,a5,0x30
    800166e4:	93c1                	srli	a5,a5,0x30
    800166e6:	fef43023          	sd	a5,-32(s0)
    VirtioDescriptor *descriptor = &device->desc[descriptor_index];
    800166ea:	fc843783          	ld	a5,-56(s0)
    800166ee:	7398                	ld	a4,32(a5)
    800166f0:	fe043783          	ld	a5,-32(s0)
    800166f4:	0792                	slli	a5,a5,0x4
    800166f6:	97ba                	add	a5,a5,a4
    800166f8:	fcf43c23          	sd	a5,-40(s0)
    *id = device->device->ring[device->device_idx % queue_size].id;
    800166fc:	fc843783          	ld	a5,-56(s0)
    80016700:	7b98                	ld	a4,48(a5)
    80016702:	fc843783          	ld	a5,-56(s0)
    80016706:	04c7d783          	lhu	a5,76(a5)
    8001670a:	17c2                	slli	a5,a5,0x30
    8001670c:	93c1                	srli	a5,a5,0x30
    8001670e:	86be                	mv	a3,a5
    80016710:	fe843783          	ld	a5,-24(s0)
    80016714:	02f6f7b3          	remu	a5,a3,a5
    80016718:	078e                	slli	a5,a5,0x3
    8001671a:	97ba                	add	a5,a5,a4
    8001671c:	43dc                	lw	a5,4(a5)
    8001671e:	0007871b          	sext.w	a4,a5
    80016722:	fb843783          	ld	a5,-72(s0)
    80016726:	c398                	sw	a4,0(a5)
    *len = device->device->ring[device->device_idx % queue_size].len;
    80016728:	fc843783          	ld	a5,-56(s0)
    8001672c:	7b98                	ld	a4,48(a5)
    8001672e:	fc843783          	ld	a5,-56(s0)
    80016732:	04c7d783          	lhu	a5,76(a5)
    80016736:	17c2                	slli	a5,a5,0x30
    80016738:	93c1                	srli	a5,a5,0x30
    8001673a:	86be                	mv	a3,a5
    8001673c:	fe843783          	ld	a5,-24(s0)
    80016740:	02f6f7b3          	remu	a5,a3,a5
    80016744:	078e                	slli	a5,a5,0x3
    80016746:	97ba                	add	a5,a5,a4
    80016748:	479c                	lw	a5,8(a5)
    8001674a:	0007871b          	sext.w	a4,a5
    8001674e:	fb043783          	ld	a5,-80(s0)
    80016752:	c398                	sw	a4,0(a5)
    device->device_idx = (device->device_idx + 1) % queue_size;
    80016754:	fc843783          	ld	a5,-56(s0)
    80016758:	04c7d783          	lhu	a5,76(a5)
    8001675c:	17c2                	slli	a5,a5,0x30
    8001675e:	93c1                	srli	a5,a5,0x30
    80016760:	2781                	sext.w	a5,a5
    80016762:	2785                	addiw	a5,a5,1
    80016764:	2781                	sext.w	a5,a5
    80016766:	873e                	mv	a4,a5
    80016768:	fe843783          	ld	a5,-24(s0)
    8001676c:	02f777b3          	remu	a5,a4,a5
    80016770:	03079713          	slli	a4,a5,0x30
    80016774:	9341                	srli	a4,a4,0x30
    80016776:	fc843783          	ld	a5,-56(s0)
    8001677a:	04e79623          	sh	a4,76(a5)
    return descriptor;
    8001677e:	fd843783          	ld	a5,-40(s0)
}
    80016782:	853e                	mv	a0,a5
    80016784:	60a6                	ld	ra,72(sp)
    80016786:	6406                	ld	s0,64(sp)
    80016788:	6161                	addi	sp,sp,80
    8001678a:	8082                	ret

000000008001678c <virtio_count_received_descriptors>:

uint64_t virtio_count_received_descriptors(volatile VirtioDevice *device, uint16_t which_queue) {
    8001678c:	7139                	addi	sp,sp,-64
    8001678e:	fc06                	sd	ra,56(sp)
    80016790:	f822                	sd	s0,48(sp)
    80016792:	0080                	addi	s0,sp,64
    80016794:	fca43423          	sd	a0,-56(s0)
    80016798:	87ae                	mv	a5,a1
    8001679a:	fcf41323          	sh	a5,-58(s0)
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    8001679e:	fc645783          	lhu	a5,-58(s0)
    800167a2:	85be                	mv	a1,a5
    800167a4:	fc843503          	ld	a0,-56(s0)
    800167a8:	d3bff0ef          	jal	ra,800164e2 <virtio_set_queue_and_get_size>
    800167ac:	fea43023          	sd	a0,-32(s0)
    uint64_t device_idx = device->device_idx;
    800167b0:	fc843783          	ld	a5,-56(s0)
    800167b4:	04c7d783          	lhu	a5,76(a5)
    800167b8:	17c2                	slli	a5,a5,0x30
    800167ba:	93c1                	srli	a5,a5,0x30
    800167bc:	fcf43c23          	sd	a5,-40(s0)
    uint64_t driver_idx = device->driver_idx;
    800167c0:	fc843783          	ld	a5,-56(s0)
    800167c4:	04a7d783          	lhu	a5,74(a5)
    800167c8:	17c2                	slli	a5,a5,0x30
    800167ca:	93c1                	srli	a5,a5,0x30
    800167cc:	fcf43823          	sd	a5,-48(s0)
    uint64_t result = driver_idx - device_idx;
    800167d0:	fd043703          	ld	a4,-48(s0)
    800167d4:	fd843783          	ld	a5,-40(s0)
    800167d8:	40f707b3          	sub	a5,a4,a5
    800167dc:	fef43423          	sd	a5,-24(s0)
    if (device_idx > driver_idx) {
    800167e0:	fd843703          	ld	a4,-40(s0)
    800167e4:	fd043783          	ld	a5,-48(s0)
    800167e8:	00e7f963          	bgeu	a5,a4,800167fa <virtio_count_received_descriptors+0x6e>
        result += queue_size;
    800167ec:	fe843703          	ld	a4,-24(s0)
    800167f0:	fe043783          	ld	a5,-32(s0)
    800167f4:	97ba                	add	a5,a5,a4
    800167f6:	fef43423          	sd	a5,-24(s0)
    }
    return result;
    800167fa:	fe843783          	ld	a5,-24(s0)
    800167fe:	853e                	mv	a0,a5
    80016800:	70e2                	ld	ra,56(sp)
    80016802:	7442                	ld	s0,48(sp)
    80016804:	6121                	addi	sp,sp,64
    80016806:	8082                	ret

0000000080016808 <set_taken>:
static uint8_t *bookkeeping;  // Pointer to the bookkeeping area
static void *heap_start;

// For some reason, the macros didn't work for me, so I used the static functions like Marz said and it works.
static void set_taken(uint64_t index)
{
    80016808:	1101                	addi	sp,sp,-32
    8001680a:	ec22                	sd	s0,24(sp)
    8001680c:	1000                	addi	s0,sp,32
    8001680e:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2));
    80016812:	00004797          	auipc	a5,0x4
    80016816:	88678793          	addi	a5,a5,-1914 # 8001a098 <bookkeeping>
    8001681a:	6398                	ld	a4,0(a5)
    8001681c:	fe843783          	ld	a5,-24(s0)
    80016820:	8389                	srli	a5,a5,0x2
    80016822:	973e                	add	a4,a4,a5
    80016824:	00074703          	lbu	a4,0(a4) # ffffffffc0fff000 <_heap_end+0xffffffff38fef000>
    80016828:	0187169b          	slliw	a3,a4,0x18
    8001682c:	4186d69b          	sraiw	a3,a3,0x18
    80016830:	fe843703          	ld	a4,-24(s0)
    80016834:	2701                	sext.w	a4,a4
    80016836:	8b0d                	andi	a4,a4,3
    80016838:	2701                	sext.w	a4,a4
    8001683a:	0017171b          	slliw	a4,a4,0x1
    8001683e:	2701                	sext.w	a4,a4
    80016840:	4605                	li	a2,1
    80016842:	00e6173b          	sllw	a4,a2,a4
    80016846:	2701                	sext.w	a4,a4
    80016848:	0187171b          	slliw	a4,a4,0x18
    8001684c:	4187571b          	sraiw	a4,a4,0x18
    80016850:	8f55                	or	a4,a4,a3
    80016852:	0187169b          	slliw	a3,a4,0x18
    80016856:	4186d69b          	sraiw	a3,a3,0x18
    8001685a:	00004717          	auipc	a4,0x4
    8001685e:	83e70713          	addi	a4,a4,-1986 # 8001a098 <bookkeeping>
    80016862:	6318                	ld	a4,0(a4)
    80016864:	97ba                	add	a5,a5,a4
    80016866:	0ff6f713          	andi	a4,a3,255
    8001686a:	00e78023          	sb	a4,0(a5)
}
    8001686e:	0001                	nop
    80016870:	6462                	ld	s0,24(sp)
    80016872:	6105                	addi	sp,sp,32
    80016874:	8082                	ret

0000000080016876 <clear_taken>:

static void clear_taken(uint64_t index)
{
    80016876:	1101                	addi	sp,sp,-32
    80016878:	ec22                	sd	s0,24(sp)
    8001687a:	1000                	addi	s0,sp,32
    8001687c:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2));
    80016880:	00004797          	auipc	a5,0x4
    80016884:	81878793          	addi	a5,a5,-2024 # 8001a098 <bookkeeping>
    80016888:	6398                	ld	a4,0(a5)
    8001688a:	fe843783          	ld	a5,-24(s0)
    8001688e:	8389                	srli	a5,a5,0x2
    80016890:	973e                	add	a4,a4,a5
    80016892:	00074703          	lbu	a4,0(a4)
    80016896:	0187169b          	slliw	a3,a4,0x18
    8001689a:	4186d69b          	sraiw	a3,a3,0x18
    8001689e:	fe843703          	ld	a4,-24(s0)
    800168a2:	2701                	sext.w	a4,a4
    800168a4:	8b0d                	andi	a4,a4,3
    800168a6:	2701                	sext.w	a4,a4
    800168a8:	0017171b          	slliw	a4,a4,0x1
    800168ac:	2701                	sext.w	a4,a4
    800168ae:	4605                	li	a2,1
    800168b0:	00e6173b          	sllw	a4,a2,a4
    800168b4:	2701                	sext.w	a4,a4
    800168b6:	0187171b          	slliw	a4,a4,0x18
    800168ba:	4187571b          	sraiw	a4,a4,0x18
    800168be:	fff74713          	not	a4,a4
    800168c2:	0187171b          	slliw	a4,a4,0x18
    800168c6:	4187571b          	sraiw	a4,a4,0x18
    800168ca:	8f75                	and	a4,a4,a3
    800168cc:	0187169b          	slliw	a3,a4,0x18
    800168d0:	4186d69b          	sraiw	a3,a3,0x18
    800168d4:	00003717          	auipc	a4,0x3
    800168d8:	7c470713          	addi	a4,a4,1988 # 8001a098 <bookkeeping>
    800168dc:	6318                	ld	a4,0(a4)
    800168de:	97ba                	add	a5,a5,a4
    800168e0:	0ff6f713          	andi	a4,a3,255
    800168e4:	00e78023          	sb	a4,0(a5)
}
    800168e8:	0001                	nop
    800168ea:	6462                	ld	s0,24(sp)
    800168ec:	6105                	addi	sp,sp,32
    800168ee:	8082                	ret

00000000800168f0 <is_taken>:

static int is_taken(uint64_t index)
{
    800168f0:	1101                	addi	sp,sp,-32
    800168f2:	ec22                	sd	s0,24(sp)
    800168f4:	1000                	addi	s0,sp,32
    800168f6:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2));
    800168fa:	00003797          	auipc	a5,0x3
    800168fe:	79e78793          	addi	a5,a5,1950 # 8001a098 <bookkeeping>
    80016902:	6398                	ld	a4,0(a5)
    80016904:	fe843783          	ld	a5,-24(s0)
    80016908:	8389                	srli	a5,a5,0x2
    8001690a:	97ba                	add	a5,a5,a4
    8001690c:	0007c783          	lbu	a5,0(a5)
    80016910:	0007871b          	sext.w	a4,a5
    80016914:	fe843783          	ld	a5,-24(s0)
    80016918:	2781                	sext.w	a5,a5
    8001691a:	8b8d                	andi	a5,a5,3
    8001691c:	2781                	sext.w	a5,a5
    8001691e:	0017979b          	slliw	a5,a5,0x1
    80016922:	2781                	sext.w	a5,a5
    80016924:	4685                	li	a3,1
    80016926:	00f697bb          	sllw	a5,a3,a5
    8001692a:	2781                	sext.w	a5,a5
    8001692c:	8ff9                	and	a5,a5,a4
    8001692e:	2781                	sext.w	a5,a5
}
    80016930:	853e                	mv	a0,a5
    80016932:	6462                	ld	s0,24(sp)
    80016934:	6105                	addi	sp,sp,32
    80016936:	8082                	ret

0000000080016938 <set_last>:

static void set_last(uint64_t index)
{
    80016938:	1101                	addi	sp,sp,-32
    8001693a:	ec22                	sd	s0,24(sp)
    8001693c:	1000                	addi	s0,sp,32
    8001693e:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2 + 1));
    80016942:	00003797          	auipc	a5,0x3
    80016946:	75678793          	addi	a5,a5,1878 # 8001a098 <bookkeeping>
    8001694a:	6398                	ld	a4,0(a5)
    8001694c:	fe843783          	ld	a5,-24(s0)
    80016950:	8389                	srli	a5,a5,0x2
    80016952:	973e                	add	a4,a4,a5
    80016954:	00074703          	lbu	a4,0(a4)
    80016958:	0187169b          	slliw	a3,a4,0x18
    8001695c:	4186d69b          	sraiw	a3,a3,0x18
    80016960:	fe843703          	ld	a4,-24(s0)
    80016964:	2701                	sext.w	a4,a4
    80016966:	8b0d                	andi	a4,a4,3
    80016968:	2701                	sext.w	a4,a4
    8001696a:	0017171b          	slliw	a4,a4,0x1
    8001696e:	2701                	sext.w	a4,a4
    80016970:	2705                	addiw	a4,a4,1
    80016972:	2701                	sext.w	a4,a4
    80016974:	4605                	li	a2,1
    80016976:	00e6173b          	sllw	a4,a2,a4
    8001697a:	2701                	sext.w	a4,a4
    8001697c:	0187171b          	slliw	a4,a4,0x18
    80016980:	4187571b          	sraiw	a4,a4,0x18
    80016984:	8f55                	or	a4,a4,a3
    80016986:	0187169b          	slliw	a3,a4,0x18
    8001698a:	4186d69b          	sraiw	a3,a3,0x18
    8001698e:	00003717          	auipc	a4,0x3
    80016992:	70a70713          	addi	a4,a4,1802 # 8001a098 <bookkeeping>
    80016996:	6318                	ld	a4,0(a4)
    80016998:	97ba                	add	a5,a5,a4
    8001699a:	0ff6f713          	andi	a4,a3,255
    8001699e:	00e78023          	sb	a4,0(a5)
}
    800169a2:	0001                	nop
    800169a4:	6462                	ld	s0,24(sp)
    800169a6:	6105                	addi	sp,sp,32
    800169a8:	8082                	ret

00000000800169aa <clear_last>:

static void clear_last(uint64_t index)
{
    800169aa:	1101                	addi	sp,sp,-32
    800169ac:	ec22                	sd	s0,24(sp)
    800169ae:	1000                	addi	s0,sp,32
    800169b0:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2 + 1));
    800169b4:	00003797          	auipc	a5,0x3
    800169b8:	6e478793          	addi	a5,a5,1764 # 8001a098 <bookkeeping>
    800169bc:	6398                	ld	a4,0(a5)
    800169be:	fe843783          	ld	a5,-24(s0)
    800169c2:	8389                	srli	a5,a5,0x2
    800169c4:	973e                	add	a4,a4,a5
    800169c6:	00074703          	lbu	a4,0(a4)
    800169ca:	0187169b          	slliw	a3,a4,0x18
    800169ce:	4186d69b          	sraiw	a3,a3,0x18
    800169d2:	fe843703          	ld	a4,-24(s0)
    800169d6:	2701                	sext.w	a4,a4
    800169d8:	8b0d                	andi	a4,a4,3
    800169da:	2701                	sext.w	a4,a4
    800169dc:	0017171b          	slliw	a4,a4,0x1
    800169e0:	2701                	sext.w	a4,a4
    800169e2:	2705                	addiw	a4,a4,1
    800169e4:	2701                	sext.w	a4,a4
    800169e6:	4605                	li	a2,1
    800169e8:	00e6173b          	sllw	a4,a2,a4
    800169ec:	2701                	sext.w	a4,a4
    800169ee:	0187171b          	slliw	a4,a4,0x18
    800169f2:	4187571b          	sraiw	a4,a4,0x18
    800169f6:	fff74713          	not	a4,a4
    800169fa:	0187171b          	slliw	a4,a4,0x18
    800169fe:	4187571b          	sraiw	a4,a4,0x18
    80016a02:	8f75                	and	a4,a4,a3
    80016a04:	0187169b          	slliw	a3,a4,0x18
    80016a08:	4186d69b          	sraiw	a3,a3,0x18
    80016a0c:	00003717          	auipc	a4,0x3
    80016a10:	68c70713          	addi	a4,a4,1676 # 8001a098 <bookkeeping>
    80016a14:	6318                	ld	a4,0(a4)
    80016a16:	97ba                	add	a5,a5,a4
    80016a18:	0ff6f713          	andi	a4,a3,255
    80016a1c:	00e78023          	sb	a4,0(a5)
}
    80016a20:	0001                	nop
    80016a22:	6462                	ld	s0,24(sp)
    80016a24:	6105                	addi	sp,sp,32
    80016a26:	8082                	ret

0000000080016a28 <is_last>:

static int is_last(uint64_t index)
{
    80016a28:	1101                	addi	sp,sp,-32
    80016a2a:	ec22                	sd	s0,24(sp)
    80016a2c:	1000                	addi	s0,sp,32
    80016a2e:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2 + 1));
    80016a32:	00003797          	auipc	a5,0x3
    80016a36:	66678793          	addi	a5,a5,1638 # 8001a098 <bookkeeping>
    80016a3a:	6398                	ld	a4,0(a5)
    80016a3c:	fe843783          	ld	a5,-24(s0)
    80016a40:	8389                	srli	a5,a5,0x2
    80016a42:	97ba                	add	a5,a5,a4
    80016a44:	0007c783          	lbu	a5,0(a5)
    80016a48:	0007871b          	sext.w	a4,a5
    80016a4c:	fe843783          	ld	a5,-24(s0)
    80016a50:	2781                	sext.w	a5,a5
    80016a52:	8b8d                	andi	a5,a5,3
    80016a54:	2781                	sext.w	a5,a5
    80016a56:	0017979b          	slliw	a5,a5,0x1
    80016a5a:	2781                	sext.w	a5,a5
    80016a5c:	2785                	addiw	a5,a5,1
    80016a5e:	2781                	sext.w	a5,a5
    80016a60:	4685                	li	a3,1
    80016a62:	00f697bb          	sllw	a5,a3,a5
    80016a66:	2781                	sext.w	a5,a5
    80016a68:	8ff9                	and	a5,a5,a4
    80016a6a:	2781                	sext.w	a5,a5
}
    80016a6c:	853e                	mv	a0,a5
    80016a6e:	6462                	ld	s0,24(sp)
    80016a70:	6105                	addi	sp,sp,32
    80016a72:	8082                	ret

0000000080016a74 <page_init>:

void page_init(void)
{
    80016a74:	1101                	addi	sp,sp,-32
    80016a76:	ec06                	sd	ra,24(sp)
    80016a78:	e822                	sd	s0,16(sp)
    80016a7a:	1000                	addi	s0,sp,32
    /* Initialize the page system. */
    bookkeeping = (uint8_t*)sym_start(heap);
    80016a7c:	00003797          	auipc	a5,0x3
    80016a80:	61c78793          	addi	a5,a5,1564 # 8001a098 <bookkeeping>
    80016a84:	00010717          	auipc	a4,0x10
    80016a88:	57c70713          	addi	a4,a4,1404 # 80027000 <_heap_start>
    80016a8c:	e398                	sd	a4,0(a5)
    
    // Print bookkeeping area
    mutex_spinlock(&page_lock);
    80016a8e:	00003517          	auipc	a0,0x3
    80016a92:	57a50513          	addi	a0,a0,1402 # 8001a008 <page_lock>
    80016a96:	ecbfc0ef          	jal	ra,80013960 <mutex_spinlock>

    // Initialize the bookkeeping area
    memset(bookkeeping, 0, BK_SIZE_IN_BYTES);
    80016a9a:	00003797          	auipc	a5,0x3
    80016a9e:	5fe78793          	addi	a5,a5,1534 # 8001a098 <bookkeeping>
    80016aa2:	6394                	ld	a3,0(a5)
    80016aa4:	07ff9717          	auipc	a4,0x7ff9
    80016aa8:	55c70713          	addi	a4,a4,1372 # 88010000 <_heap_end>
    80016aac:	00010797          	auipc	a5,0x10
    80016ab0:	55478793          	addi	a5,a5,1364 # 80027000 <_heap_start>
    80016ab4:	40f707b3          	sub	a5,a4,a5
    80016ab8:	83b9                	srli	a5,a5,0xe
    80016aba:	0007871b          	sext.w	a4,a5
    80016abe:	6785                	lui	a5,0x1
    80016ac0:	37fd                	addiw	a5,a5,-1
    80016ac2:	9fb9                	addw	a5,a5,a4
    80016ac4:	2781                	sext.w	a5,a5
    80016ac6:	0007871b          	sext.w	a4,a5
    80016aca:	77fd                	lui	a5,0xfffff
    80016acc:	8ff9                	and	a5,a5,a4
    80016ace:	2781                	sext.w	a5,a5
    80016ad0:	863e                	mv	a2,a5
    80016ad2:	4581                	li	a1,0
    80016ad4:	8536                	mv	a0,a3
    80016ad6:	75d000ef          	jal	ra,80017a32 <memset>
    // Mark the bookkeeping pages as taken
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    80016ada:	fe043423          	sd	zero,-24(s0)
    80016ade:	a811                	j	80016af2 <page_init+0x7e>
        set_taken(i);
    80016ae0:	fe843503          	ld	a0,-24(s0)
    80016ae4:	d25ff0ef          	jal	ra,80016808 <set_taken>
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    80016ae8:	fe843783          	ld	a5,-24(s0)
    80016aec:	0785                	addi	a5,a5,1
    80016aee:	fef43423          	sd	a5,-24(s0)
    80016af2:	07ff9717          	auipc	a4,0x7ff9
    80016af6:	50e70713          	addi	a4,a4,1294 # 88010000 <_heap_end>
    80016afa:	00010797          	auipc	a5,0x10
    80016afe:	50678793          	addi	a5,a5,1286 # 80027000 <_heap_start>
    80016b02:	40f707b3          	sub	a5,a4,a5
    80016b06:	00e7d713          	srli	a4,a5,0xe
    80016b0a:	6785                	lui	a5,0x1
    80016b0c:	17fd                	addi	a5,a5,-1
    80016b0e:	97ba                	add	a5,a5,a4
    80016b10:	83b1                	srli	a5,a5,0xc
    80016b12:	fe843703          	ld	a4,-24(s0)
    80016b16:	fcf765e3          	bltu	a4,a5,80016ae0 <page_init+0x6c>
    }
    set_last(BK_SIZE_IN_PAGES-1);
    80016b1a:	07ff9717          	auipc	a4,0x7ff9
    80016b1e:	4e670713          	addi	a4,a4,1254 # 88010000 <_heap_end>
    80016b22:	00010797          	auipc	a5,0x10
    80016b26:	4de78793          	addi	a5,a5,1246 # 80027000 <_heap_start>
    80016b2a:	40f707b3          	sub	a5,a4,a5
    80016b2e:	00e7d713          	srli	a4,a5,0xe
    80016b32:	6785                	lui	a5,0x1
    80016b34:	17fd                	addi	a5,a5,-1
    80016b36:	97ba                	add	a5,a5,a4
    80016b38:	83b1                	srli	a5,a5,0xc
    80016b3a:	17fd                	addi	a5,a5,-1
    80016b3c:	853e                	mv	a0,a5
    80016b3e:	dfbff0ef          	jal	ra,80016938 <set_last>

    debugf("page_init: bookkeeping area initialized\n");
    80016b42:	00006517          	auipc	a0,0x6
    80016b46:	b9650513          	addi	a0,a0,-1130 # 8001c6d8 <pow10.0+0x14a8>
    80016b4a:	ad1fe0ef          	jal	ra,8001561a <debugf>
    debugf("page_init: bookkeeping area starts at 0x%08lx\n", bookkeeping);
    80016b4e:	00003797          	auipc	a5,0x3
    80016b52:	54a78793          	addi	a5,a5,1354 # 8001a098 <bookkeeping>
    80016b56:	639c                	ld	a5,0(a5)
    80016b58:	85be                	mv	a1,a5
    80016b5a:	00006517          	auipc	a0,0x6
    80016b5e:	bae50513          	addi	a0,a0,-1106 # 8001c708 <pow10.0+0x14d8>
    80016b62:	ab9fe0ef          	jal	ra,8001561a <debugf>
    debugf("page_init: bookkeeping area ends at 0x%08lx\n", bookkeeping + BK_SIZE_IN_BYTES);
    80016b66:	00003797          	auipc	a5,0x3
    80016b6a:	53278793          	addi	a5,a5,1330 # 8001a098 <bookkeeping>
    80016b6e:	6398                	ld	a4,0(a5)
    80016b70:	07ff9697          	auipc	a3,0x7ff9
    80016b74:	49068693          	addi	a3,a3,1168 # 88010000 <_heap_end>
    80016b78:	00010797          	auipc	a5,0x10
    80016b7c:	48878793          	addi	a5,a5,1160 # 80027000 <_heap_start>
    80016b80:	40f687b3          	sub	a5,a3,a5
    80016b84:	00e7d693          	srli	a3,a5,0xe
    80016b88:	6785                	lui	a5,0x1
    80016b8a:	17fd                	addi	a5,a5,-1
    80016b8c:	96be                	add	a3,a3,a5
    80016b8e:	77fd                	lui	a5,0xfffff
    80016b90:	8ff5                	and	a5,a5,a3
    80016b92:	97ba                	add	a5,a5,a4
    80016b94:	85be                	mv	a1,a5
    80016b96:	00006517          	auipc	a0,0x6
    80016b9a:	ba250513          	addi	a0,a0,-1118 # 8001c738 <pow10.0+0x1508>
    80016b9e:	a7dfe0ef          	jal	ra,8001561a <debugf>
    mutex_unlock(&page_lock);
    80016ba2:	00003517          	auipc	a0,0x3
    80016ba6:	46650513          	addi	a0,a0,1126 # 8001a008 <page_lock>
    80016baa:	de5fc0ef          	jal	ra,8001398e <mutex_unlock>

    // Print out the bookkeeping area's contents
    logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    80016bae:	00003797          	auipc	a5,0x3
    80016bb2:	4ea78793          	addi	a5,a5,1258 # 8001a098 <bookkeeping>
    80016bb6:	6390                	ld	a2,0(a5)
    80016bb8:	00003797          	auipc	a5,0x3
    80016bbc:	4e078793          	addi	a5,a5,1248 # 8001a098 <bookkeeping>
    80016bc0:	6398                	ld	a4,0(a5)
    80016bc2:	07ff9697          	auipc	a3,0x7ff9
    80016bc6:	43e68693          	addi	a3,a3,1086 # 88010000 <_heap_end>
    80016bca:	00010797          	auipc	a5,0x10
    80016bce:	43678793          	addi	a5,a5,1078 # 80027000 <_heap_start>
    80016bd2:	40f687b3          	sub	a5,a3,a5
    80016bd6:	00e7d693          	srli	a3,a5,0xe
    80016bda:	6785                	lui	a5,0x1
    80016bdc:	17fd                	addi	a5,a5,-1
    80016bde:	96be                	add	a3,a3,a5
    80016be0:	77fd                	lui	a5,0xfffff
    80016be2:	8ff5                	and	a5,a5,a3
    80016be4:	97ba                	add	a5,a5,a4
    80016be6:	86be                	mv	a3,a5
    80016be8:	00006597          	auipc	a1,0x6
    80016bec:	b8058593          	addi	a1,a1,-1152 # 8001c768 <pow10.0+0x1538>
    80016bf0:	4511                	li	a0,4
    80016bf2:	9cbfe0ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  Heap: 0x%08lx -> 0x%08lx", bookkeeping + BK_SIZE_IN_BYTES, bookkeeping + HEAP_SIZE_IN_BYTES);
    80016bf6:	00003797          	auipc	a5,0x3
    80016bfa:	4a278793          	addi	a5,a5,1186 # 8001a098 <bookkeeping>
    80016bfe:	6398                	ld	a4,0(a5)
    80016c00:	07ff9697          	auipc	a3,0x7ff9
    80016c04:	40068693          	addi	a3,a3,1024 # 88010000 <_heap_end>
    80016c08:	00010797          	auipc	a5,0x10
    80016c0c:	3f878793          	addi	a5,a5,1016 # 80027000 <_heap_start>
    80016c10:	40f687b3          	sub	a5,a3,a5
    80016c14:	00e7d693          	srli	a3,a5,0xe
    80016c18:	6785                	lui	a5,0x1
    80016c1a:	17fd                	addi	a5,a5,-1
    80016c1c:	96be                	add	a3,a3,a5
    80016c1e:	77fd                	lui	a5,0xfffff
    80016c20:	8ff5                	and	a5,a5,a3
    80016c22:	00f70633          	add	a2,a4,a5
    80016c26:	00003797          	auipc	a5,0x3
    80016c2a:	47278793          	addi	a5,a5,1138 # 8001a098 <bookkeeping>
    80016c2e:	6398                	ld	a4,0(a5)
    80016c30:	07ff9697          	auipc	a3,0x7ff9
    80016c34:	3d068693          	addi	a3,a3,976 # 88010000 <_heap_end>
    80016c38:	00010797          	auipc	a5,0x10
    80016c3c:	3c878793          	addi	a5,a5,968 # 80027000 <_heap_start>
    80016c40:	40f687b3          	sub	a5,a3,a5
    80016c44:	97ba                	add	a5,a5,a4
    80016c46:	86be                	mv	a3,a5
    80016c48:	00006597          	auipc	a1,0x6
    80016c4c:	b4058593          	addi	a1,a1,-1216 # 8001c788 <pow10.0+0x1558>
    80016c50:	4511                	li	a0,4
    80016c52:	96bfe0ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    80016c56:	07ff9717          	auipc	a4,0x7ff9
    80016c5a:	3aa70713          	addi	a4,a4,938 # 88010000 <_heap_end>
    80016c5e:	00010797          	auipc	a5,0x10
    80016c62:	3a278793          	addi	a5,a5,930 # 80027000 <_heap_start>
    80016c66:	40f70633          	sub	a2,a4,a5
    80016c6a:	07ff9717          	auipc	a4,0x7ff9
    80016c6e:	39670713          	addi	a4,a4,918 # 88010000 <_heap_end>
    80016c72:	00010797          	auipc	a5,0x10
    80016c76:	38e78793          	addi	a5,a5,910 # 80027000 <_heap_start>
    80016c7a:	40f707b3          	sub	a5,a4,a5
    80016c7e:	83b1                	srli	a5,a5,0xc
    80016c80:	86be                	mv	a3,a5
    80016c82:	00006597          	auipc	a1,0x6
    80016c86:	b2658593          	addi	a1,a1,-1242 # 8001c7a8 <pow10.0+0x1578>
    80016c8a:	4511                	li	a0,4
    80016c8c:	931fe0ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    80016c90:	07ff9717          	auipc	a4,0x7ff9
    80016c94:	37070713          	addi	a4,a4,880 # 88010000 <_heap_end>
    80016c98:	00010797          	auipc	a5,0x10
    80016c9c:	36878793          	addi	a5,a5,872 # 80027000 <_heap_start>
    80016ca0:	40f707b3          	sub	a5,a4,a5
    80016ca4:	00e7d713          	srli	a4,a5,0xe
    80016ca8:	6785                	lui	a5,0x1
    80016caa:	17fd                	addi	a5,a5,-1
    80016cac:	973e                	add	a4,a4,a5
    80016cae:	77fd                	lui	a5,0xfffff
    80016cb0:	00f77633          	and	a2,a4,a5
    80016cb4:	07ff9717          	auipc	a4,0x7ff9
    80016cb8:	34c70713          	addi	a4,a4,844 # 88010000 <_heap_end>
    80016cbc:	00010797          	auipc	a5,0x10
    80016cc0:	34478793          	addi	a5,a5,836 # 80027000 <_heap_start>
    80016cc4:	40f707b3          	sub	a5,a4,a5
    80016cc8:	00e7d713          	srli	a4,a5,0xe
    80016ccc:	6785                	lui	a5,0x1
    80016cce:	17fd                	addi	a5,a5,-1
    80016cd0:	97ba                	add	a5,a5,a4
    80016cd2:	83b1                	srli	a5,a5,0xc
    80016cd4:	86be                	mv	a3,a5
    80016cd6:	00006597          	auipc	a1,0x6
    80016cda:	afa58593          	addi	a1,a1,-1286 # 8001c7d0 <pow10.0+0x15a0>
    80016cde:	4511                	li	a0,4
    80016ce0:	8ddfe0ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    80016ce4:	330000ef          	jal	ra,80017014 <page_count_taken>
    80016ce8:	87aa                	mv	a5,a0
    80016cea:	863e                	mv	a2,a5
    80016cec:	00006597          	auipc	a1,0x6
    80016cf0:	b1458593          	addi	a1,a1,-1260 # 8001c800 <pow10.0+0x15d0>
    80016cf4:	4511                	li	a0,4
    80016cf6:	8c7fe0ef          	jal	ra,800155bc <logf>
    logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
    80016cfa:	2a4000ef          	jal	ra,80016f9e <page_count_free>
    80016cfe:	87aa                	mv	a5,a0
    80016d00:	863e                	mv	a2,a5
    80016d02:	00006597          	auipc	a1,0x6
    80016d06:	b1658593          	addi	a1,a1,-1258 # 8001c818 <pow10.0+0x15e8>
    80016d0a:	4511                	li	a0,4
    80016d0c:	8b1fe0ef          	jal	ra,800155bc <logf>
    // logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    // logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    // logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
}
    80016d10:	0001                	nop
    80016d12:	60e2                	ld	ra,24(sp)
    80016d14:	6442                	ld	s0,16(sp)
    80016d16:	6105                	addi	sp,sp,32
    80016d18:	8082                	ret

0000000080016d1a <page_nalloc>:

void *page_nalloc(int n)
{
    80016d1a:	7139                	addi	sp,sp,-64
    80016d1c:	fc06                	sd	ra,56(sp)
    80016d1e:	f822                	sd	s0,48(sp)
    80016d20:	0080                	addi	s0,sp,64
    80016d22:	87aa                	mv	a5,a0
    80016d24:	fcf42623          	sw	a5,-52(s0)
    if (n <= 0) {
    80016d28:	fcc42783          	lw	a5,-52(s0)
    80016d2c:	2781                	sext.w	a5,a5
    80016d2e:	00f04463          	bgtz	a5,80016d36 <page_nalloc+0x1c>
        return NULL;
    80016d32:	4781                	li	a5,0
    80016d34:	a23d                	j	80016e62 <page_nalloc+0x148>
    }

    mutex_spinlock(&page_lock);
    80016d36:	00003517          	auipc	a0,0x3
    80016d3a:	2d250513          	addi	a0,a0,722 # 8001a008 <page_lock>
    80016d3e:	c23fc0ef          	jal	ra,80013960 <mutex_spinlock>

    int start = 0;
    80016d42:	fe042623          	sw	zero,-20(s0)
    int consecutive = 0;
    80016d46:	fe042423          	sw	zero,-24(s0)

    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80016d4a:	fe043023          	sd	zero,-32(s0)
    80016d4e:	a0e5                	j	80016e36 <page_nalloc+0x11c>
        if (!is_taken(i) && !is_last(i)) {
    80016d50:	fe043503          	ld	a0,-32(s0)
    80016d54:	b9dff0ef          	jal	ra,800168f0 <is_taken>
    80016d58:	87aa                	mv	a5,a0
    80016d5a:	e7f9                	bnez	a5,80016e28 <page_nalloc+0x10e>
    80016d5c:	fe043503          	ld	a0,-32(s0)
    80016d60:	cc9ff0ef          	jal	ra,80016a28 <is_last>
    80016d64:	87aa                	mv	a5,a0
    80016d66:	e3e9                	bnez	a5,80016e28 <page_nalloc+0x10e>
            if (consecutive == 0) {
    80016d68:	fe842783          	lw	a5,-24(s0)
    80016d6c:	2781                	sext.w	a5,a5
    80016d6e:	e789                	bnez	a5,80016d78 <page_nalloc+0x5e>
                start = i;
    80016d70:	fe043783          	ld	a5,-32(s0)
    80016d74:	fef42623          	sw	a5,-20(s0)
            }

            consecutive++;
    80016d78:	fe842783          	lw	a5,-24(s0)
    80016d7c:	2785                	addiw	a5,a5,1
    80016d7e:	fef42423          	sw	a5,-24(s0)

            if (consecutive >= n) {
    80016d82:	fe842703          	lw	a4,-24(s0)
    80016d86:	fcc42783          	lw	a5,-52(s0)
    80016d8a:	2701                	sext.w	a4,a4
    80016d8c:	2781                	sext.w	a5,a5
    80016d8e:	08f74f63          	blt	a4,a5,80016e2c <page_nalloc+0x112>
                // debugf("page_nalloc: found %d consecutive pages starting at 0x%08lx\n", n, start);
                for (int j = 0; j < n; j++) {
    80016d92:	fc042e23          	sw	zero,-36(s0)
    80016d96:	a091                	j	80016dda <page_nalloc+0xc0>
                    // debugf("page_nalloc: marking page 0x%08lx as taken\n", start + j);
                    set_taken(start + j);
    80016d98:	fec42703          	lw	a4,-20(s0)
    80016d9c:	fdc42783          	lw	a5,-36(s0)
    80016da0:	9fb9                	addw	a5,a5,a4
    80016da2:	2781                	sext.w	a5,a5
    80016da4:	853e                	mv	a0,a5
    80016da6:	a63ff0ef          	jal	ra,80016808 <set_taken>
                    if (j == n - 1) {
    80016daa:	fcc42783          	lw	a5,-52(s0)
    80016dae:	37fd                	addiw	a5,a5,-1
    80016db0:	0007871b          	sext.w	a4,a5
    80016db4:	fdc42783          	lw	a5,-36(s0)
    80016db8:	2781                	sext.w	a5,a5
    80016dba:	00e79b63          	bne	a5,a4,80016dd0 <page_nalloc+0xb6>
                        set_last(start + j);
    80016dbe:	fec42703          	lw	a4,-20(s0)
    80016dc2:	fdc42783          	lw	a5,-36(s0)
    80016dc6:	9fb9                	addw	a5,a5,a4
    80016dc8:	2781                	sext.w	a5,a5
    80016dca:	853e                	mv	a0,a5
    80016dcc:	b6dff0ef          	jal	ra,80016938 <set_last>
                for (int j = 0; j < n; j++) {
    80016dd0:	fdc42783          	lw	a5,-36(s0)
    80016dd4:	2785                	addiw	a5,a5,1
    80016dd6:	fcf42e23          	sw	a5,-36(s0)
    80016dda:	fdc42703          	lw	a4,-36(s0)
    80016dde:	fcc42783          	lw	a5,-52(s0)
    80016de2:	2701                	sext.w	a4,a4
    80016de4:	2781                	sext.w	a5,a5
    80016de6:	faf749e3          	blt	a4,a5,80016d98 <page_nalloc+0x7e>
                    }
                }
                // debugf("page_nalloc: marking page 0x%08lx as last\n", start + n - 1);

                mutex_unlock(&page_lock);
    80016dea:	00003517          	auipc	a0,0x3
    80016dee:	21e50513          	addi	a0,a0,542 # 8001a008 <page_lock>
    80016df2:	b9dfc0ef          	jal	ra,8001398e <mutex_unlock>
                // debugf("Found free %d pages at #%d, %d\n", n, start, i);
                void *result = ((uint64_t)bookkeeping + ((uint64_t)start * PAGE_SIZE));
    80016df6:	fec42783          	lw	a5,-20(s0)
    80016dfa:	07b2                	slli	a5,a5,0xc
    80016dfc:	00003717          	auipc	a4,0x3
    80016e00:	29c70713          	addi	a4,a4,668 # 8001a098 <bookkeeping>
    80016e04:	6318                	ld	a4,0(a4)
    80016e06:	97ba                	add	a5,a5,a4
    80016e08:	fcf43823          	sd	a5,-48(s0)

                debugf("Found %d free pages at %p\n", n, result);
    80016e0c:	fcc42783          	lw	a5,-52(s0)
    80016e10:	fd043603          	ld	a2,-48(s0)
    80016e14:	85be                	mv	a1,a5
    80016e16:	00006517          	auipc	a0,0x6
    80016e1a:	a1a50513          	addi	a0,a0,-1510 # 8001c830 <pow10.0+0x1600>
    80016e1e:	ffcfe0ef          	jal	ra,8001561a <debugf>
                return result;
    80016e22:	fd043783          	ld	a5,-48(s0)
    80016e26:	a835                	j	80016e62 <page_nalloc+0x148>
            }
        } else {
            // debugf("page_nalloc: page 0x%08lx is taken\n", i);
            consecutive = 0;
    80016e28:	fe042423          	sw	zero,-24(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80016e2c:	fe043783          	ld	a5,-32(s0)
    80016e30:	0785                	addi	a5,a5,1
    80016e32:	fef43023          	sd	a5,-32(s0)
    80016e36:	07ff9717          	auipc	a4,0x7ff9
    80016e3a:	1ca70713          	addi	a4,a4,458 # 88010000 <_heap_end>
    80016e3e:	00010797          	auipc	a5,0x10
    80016e42:	1c278793          	addi	a5,a5,450 # 80027000 <_heap_start>
    80016e46:	40f707b3          	sub	a5,a4,a5
    80016e4a:	83b1                	srli	a5,a5,0xc
    80016e4c:	fe043703          	ld	a4,-32(s0)
    80016e50:	f0f760e3          	bltu	a4,a5,80016d50 <page_nalloc+0x36>
        }
    }

    mutex_unlock(&page_lock);
    80016e54:	00003517          	auipc	a0,0x3
    80016e58:	1b450513          	addi	a0,a0,436 # 8001a008 <page_lock>
    80016e5c:	b33fc0ef          	jal	ra,8001398e <mutex_unlock>
    return NULL;
    80016e60:	4781                	li	a5,0
}
    80016e62:	853e                	mv	a0,a5
    80016e64:	70e2                	ld	ra,56(sp)
    80016e66:	7442                	ld	s0,48(sp)
    80016e68:	6121                	addi	sp,sp,64
    80016e6a:	8082                	ret

0000000080016e6c <page_znalloc>:

void *page_znalloc(int n)
{
    80016e6c:	7179                	addi	sp,sp,-48
    80016e6e:	f406                	sd	ra,40(sp)
    80016e70:	f022                	sd	s0,32(sp)
    80016e72:	1800                	addi	s0,sp,48
    80016e74:	87aa                	mv	a5,a0
    80016e76:	fcf42e23          	sw	a5,-36(s0)
    if (n <= 0) {
    80016e7a:	fdc42783          	lw	a5,-36(s0)
    80016e7e:	2781                	sext.w	a5,a5
    80016e80:	00f04463          	bgtz	a5,80016e88 <page_znalloc+0x1c>
        return NULL;
    80016e84:	4781                	li	a5,0
    80016e86:	a805                	j	80016eb6 <page_znalloc+0x4a>
    }
    
    void *mem = page_nalloc(n);
    80016e88:	fdc42783          	lw	a5,-36(s0)
    80016e8c:	853e                	mv	a0,a5
    80016e8e:	e8dff0ef          	jal	ra,80016d1a <page_nalloc>
    80016e92:	fea43423          	sd	a0,-24(s0)
    if (mem) {
    80016e96:	fe843783          	ld	a5,-24(s0)
    80016e9a:	cf81                	beqz	a5,80016eb2 <page_znalloc+0x46>
        // debugf("page_znalloc: zeroing out %d pages starting at 0x%08lx\n", n, mem);
        memset(mem, 0, n * PAGE_SIZE);
    80016e9c:	fdc42783          	lw	a5,-36(s0)
    80016ea0:	00c7979b          	slliw	a5,a5,0xc
    80016ea4:	2781                	sext.w	a5,a5
    80016ea6:	863e                	mv	a2,a5
    80016ea8:	4581                	li	a1,0
    80016eaa:	fe843503          	ld	a0,-24(s0)
    80016eae:	385000ef          	jal	ra,80017a32 <memset>
    }
    return mem;
    80016eb2:	fe843783          	ld	a5,-24(s0)
}
    80016eb6:	853e                	mv	a0,a5
    80016eb8:	70a2                	ld	ra,40(sp)
    80016eba:	7402                	ld	s0,32(sp)
    80016ebc:	6145                	addi	sp,sp,48
    80016ebe:	8082                	ret

0000000080016ec0 <page_to_index>:

uint64_t page_to_index(void *page) {
    80016ec0:	1101                	addi	sp,sp,-32
    80016ec2:	ec22                	sd	s0,24(sp)
    80016ec4:	1000                	addi	s0,sp,32
    80016ec6:	fea43423          	sd	a0,-24(s0)
    return ((uint64_t)page - (uint64_t)bookkeeping) / PAGE_SIZE;
    80016eca:	fe843783          	ld	a5,-24(s0)
    80016ece:	00003717          	auipc	a4,0x3
    80016ed2:	1ca70713          	addi	a4,a4,458 # 8001a098 <bookkeeping>
    80016ed6:	6318                	ld	a4,0(a4)
    80016ed8:	8f99                	sub	a5,a5,a4
    80016eda:	83b1                	srli	a5,a5,0xc
}
    80016edc:	853e                	mv	a0,a5
    80016ede:	6462                	ld	s0,24(sp)
    80016ee0:	6105                	addi	sp,sp,32
    80016ee2:	8082                	ret

0000000080016ee4 <index_to_page>:

void *index_to_page(uint64_t idx) {
    80016ee4:	1101                	addi	sp,sp,-32
    80016ee6:	ec22                	sd	s0,24(sp)
    80016ee8:	1000                	addi	s0,sp,32
    80016eea:	fea43423          	sd	a0,-24(s0)
    return (void*)(idx * PAGE_SIZE + (uint64_t)bookkeeping);
    80016eee:	fe843783          	ld	a5,-24(s0)
    80016ef2:	07b2                	slli	a5,a5,0xc
    80016ef4:	00003717          	auipc	a4,0x3
    80016ef8:	1a470713          	addi	a4,a4,420 # 8001a098 <bookkeeping>
    80016efc:	6318                	ld	a4,0(a4)
    80016efe:	97ba                	add	a5,a5,a4
}
    80016f00:	853e                	mv	a0,a5
    80016f02:	6462                	ld	s0,24(sp)
    80016f04:	6105                	addi	sp,sp,32
    80016f06:	8082                	ret

0000000080016f08 <page_free>:

void page_free(void *p)
{
    80016f08:	7179                	addi	sp,sp,-48
    80016f0a:	f406                	sd	ra,40(sp)
    80016f0c:	f022                	sd	s0,32(sp)
    80016f0e:	1800                	addi	s0,sp,48
    80016f10:	fca43c23          	sd	a0,-40(s0)
    if (p == NULL) {
    80016f14:	fd843783          	ld	a5,-40(s0)
    80016f18:	cfb5                	beqz	a5,80016f94 <page_free+0x8c>
        return;
    }
    /* Free the page */
    // uint64_t x = ((uint64_t)p - (uint64_t)bookkeeping) / PAGE_SIZE;
    uint64_t x = page_to_index(p);
    80016f1a:	fd843503          	ld	a0,-40(s0)
    80016f1e:	fa3ff0ef          	jal	ra,80016ec0 <page_to_index>
    80016f22:	fea43423          	sd	a0,-24(s0)
    // debugf("page_free: freeing page %lu at address 0x%p\n", x, p);

    mutex_spinlock(&page_lock);
    80016f26:	00003517          	auipc	a0,0x3
    80016f2a:	0e250513          	addi	a0,a0,226 # 8001a008 <page_lock>
    80016f2e:	a33fc0ef          	jal	ra,80013960 <mutex_spinlock>


    if (!is_taken(x)) {
    80016f32:	fe843503          	ld	a0,-24(s0)
    80016f36:	9bbff0ef          	jal	ra,800168f0 <is_taken>
    80016f3a:	87aa                	mv	a5,a0
    80016f3c:	e38d                	bnez	a5,80016f5e <page_free+0x56>
        // logf(LOG_ERROR, "page_free: page 0x%08lx is already free!\n", x);
        mutex_unlock(&page_lock);
    80016f3e:	00003517          	auipc	a0,0x3
    80016f42:	0ca50513          	addi	a0,a0,202 # 8001a008 <page_lock>
    80016f46:	a49fc0ef          	jal	ra,8001398e <mutex_unlock>
        return;
    80016f4a:	a0b1                	j	80016f96 <page_free+0x8e>
    }

    // Clear all the pages starting at the index until the last page
    while (is_taken(x) && !is_last(x)) {
        clear_taken(x);
    80016f4c:	fe843503          	ld	a0,-24(s0)
    80016f50:	927ff0ef          	jal	ra,80016876 <clear_taken>
        x++;
    80016f54:	fe843783          	ld	a5,-24(s0)
    80016f58:	0785                	addi	a5,a5,1
    80016f5a:	fef43423          	sd	a5,-24(s0)
    while (is_taken(x) && !is_last(x)) {
    80016f5e:	fe843503          	ld	a0,-24(s0)
    80016f62:	98fff0ef          	jal	ra,800168f0 <is_taken>
    80016f66:	87aa                	mv	a5,a0
    80016f68:	c799                	beqz	a5,80016f76 <page_free+0x6e>
    80016f6a:	fe843503          	ld	a0,-24(s0)
    80016f6e:	abbff0ef          	jal	ra,80016a28 <is_last>
    80016f72:	87aa                	mv	a5,a0
    80016f74:	dfe1                	beqz	a5,80016f4c <page_free+0x44>
    }
    clear_taken(x);
    80016f76:	fe843503          	ld	a0,-24(s0)
    80016f7a:	8fdff0ef          	jal	ra,80016876 <clear_taken>
    clear_last(x);
    80016f7e:	fe843503          	ld	a0,-24(s0)
    80016f82:	a29ff0ef          	jal	ra,800169aa <clear_last>


    mutex_unlock(&page_lock);
    80016f86:	00003517          	auipc	a0,0x3
    80016f8a:	08250513          	addi	a0,a0,130 # 8001a008 <page_lock>
    80016f8e:	a01fc0ef          	jal	ra,8001398e <mutex_unlock>
    80016f92:	a011                	j	80016f96 <page_free+0x8e>
        return;
    80016f94:	0001                	nop
}
    80016f96:	70a2                	ld	ra,40(sp)
    80016f98:	7402                	ld	s0,32(sp)
    80016f9a:	6145                	addi	sp,sp,48
    80016f9c:	8082                	ret

0000000080016f9e <page_count_free>:

int page_count_free(void)
{
    80016f9e:	1101                	addi	sp,sp,-32
    80016fa0:	ec06                	sd	ra,24(sp)
    80016fa2:	e822                	sd	s0,16(sp)
    80016fa4:	1000                	addi	s0,sp,32
    int ret = 0;
    80016fa6:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract taken. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract taken pages from it.
    */

    mutex_spinlock(&page_lock);
    80016faa:	00003517          	auipc	a0,0x3
    80016fae:	05e50513          	addi	a0,a0,94 # 8001a008 <page_lock>
    80016fb2:	9affc0ef          	jal	ra,80013960 <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80016fb6:	fe043023          	sd	zero,-32(s0)
    80016fba:	a00d                	j	80016fdc <page_count_free+0x3e>
       if (!is_taken(i)) {
    80016fbc:	fe043503          	ld	a0,-32(s0)
    80016fc0:	931ff0ef          	jal	ra,800168f0 <is_taken>
    80016fc4:	87aa                	mv	a5,a0
    80016fc6:	e791                	bnez	a5,80016fd2 <page_count_free+0x34>
           ret++;
    80016fc8:	fec42783          	lw	a5,-20(s0)
    80016fcc:	2785                	addiw	a5,a5,1
    80016fce:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80016fd2:	fe043783          	ld	a5,-32(s0)
    80016fd6:	0785                	addi	a5,a5,1
    80016fd8:	fef43023          	sd	a5,-32(s0)
    80016fdc:	07ff9717          	auipc	a4,0x7ff9
    80016fe0:	02470713          	addi	a4,a4,36 # 88010000 <_heap_end>
    80016fe4:	00010797          	auipc	a5,0x10
    80016fe8:	01c78793          	addi	a5,a5,28 # 80027000 <_heap_start>
    80016fec:	40f707b3          	sub	a5,a4,a5
    80016ff0:	83b1                	srli	a5,a5,0xc
    80016ff2:	fe043703          	ld	a4,-32(s0)
    80016ff6:	fcf763e3          	bltu	a4,a5,80016fbc <page_count_free+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    80016ffa:	00003517          	auipc	a0,0x3
    80016ffe:	00e50513          	addi	a0,a0,14 # 8001a008 <page_lock>
    80017002:	98dfc0ef          	jal	ra,8001398e <mutex_unlock>

    return ret;
    80017006:	fec42783          	lw	a5,-20(s0)
}
    8001700a:	853e                	mv	a0,a5
    8001700c:	60e2                	ld	ra,24(sp)
    8001700e:	6442                	ld	s0,16(sp)
    80017010:	6105                	addi	sp,sp,32
    80017012:	8082                	ret

0000000080017014 <page_count_taken>:

int page_count_taken(void)
{
    80017014:	1101                	addi	sp,sp,-32
    80017016:	ec06                	sd	ra,24(sp)
    80017018:	e822                	sd	s0,16(sp)
    8001701a:	1000                	addi	s0,sp,32
    int ret = 0;
    8001701c:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract free. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract free pages from it.
    */

    mutex_spinlock(&page_lock);
    80017020:	00003517          	auipc	a0,0x3
    80017024:	fe850513          	addi	a0,a0,-24 # 8001a008 <page_lock>
    80017028:	939fc0ef          	jal	ra,80013960 <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001702c:	fe043023          	sd	zero,-32(s0)
    80017030:	a00d                	j	80017052 <page_count_taken+0x3e>
       if (is_taken(i)) {
    80017032:	fe043503          	ld	a0,-32(s0)
    80017036:	8bbff0ef          	jal	ra,800168f0 <is_taken>
    8001703a:	87aa                	mv	a5,a0
    8001703c:	c791                	beqz	a5,80017048 <page_count_taken+0x34>
           ret++;
    8001703e:	fec42783          	lw	a5,-20(s0)
    80017042:	2785                	addiw	a5,a5,1
    80017044:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    80017048:	fe043783          	ld	a5,-32(s0)
    8001704c:	0785                	addi	a5,a5,1
    8001704e:	fef43023          	sd	a5,-32(s0)
    80017052:	07ff9717          	auipc	a4,0x7ff9
    80017056:	fae70713          	addi	a4,a4,-82 # 88010000 <_heap_end>
    8001705a:	00010797          	auipc	a5,0x10
    8001705e:	fa678793          	addi	a5,a5,-90 # 80027000 <_heap_start>
    80017062:	40f707b3          	sub	a5,a4,a5
    80017066:	83b1                	srli	a5,a5,0xc
    80017068:	fe043703          	ld	a4,-32(s0)
    8001706c:	fcf763e3          	bltu	a4,a5,80017032 <page_count_taken+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    80017070:	00003517          	auipc	a0,0x3
    80017074:	f9850513          	addi	a0,a0,-104 # 8001a008 <page_lock>
    80017078:	917fc0ef          	jal	ra,8001398e <mutex_unlock>

    return ret;
    8001707c:	fec42783          	lw	a5,-20(s0)
}
    80017080:	853e                	mv	a0,a5
    80017082:	60e2                	ld	ra,24(sp)
    80017084:	6442                	ld	s0,16(sp)
    80017086:	6105                	addi	sp,sp,32
    80017088:	8082                	ret

000000008001708a <block_device_init>:

//use this like a queue
volatile static Vector *device_active_jobs;
volatile static VirtioDevice *block_device;

void block_device_init() {
    8001708a:	1141                	addi	sp,sp,-16
    8001708c:	e406                	sd	ra,8(sp)
    8001708e:	e022                	sd	s0,0(sp)
    80017090:	0800                	addi	s0,sp,16
    device_active_jobs = vector_new();
    80017092:	3f2010ef          	jal	ra,80018484 <vector_new>
    80017096:	872a                	mv	a4,a0
    80017098:	00003797          	auipc	a5,0x3
    8001709c:	01078793          	addi	a5,a5,16 # 8001a0a8 <device_active_jobs>
    800170a0:	e398                	sd	a4,0(a5)
    block_device = virtio_get_block_device();
    800170a2:	cf5fe0ef          	jal	ra,80015d96 <virtio_get_block_device>
    800170a6:	87aa                	mv	a5,a0
    800170a8:	873e                	mv	a4,a5
    800170aa:	00003797          	auipc	a5,0x3
    800170ae:	00678793          	addi	a5,a5,6 # 8001a0b0 <block_device>
    800170b2:	e398                	sd	a4,0(a5)
    debugf("Block device init done for device at %p\n", block_device->pcidev->ecam_header);
    800170b4:	00003797          	auipc	a5,0x3
    800170b8:	ffc78793          	addi	a5,a5,-4 # 8001a0b0 <block_device>
    800170bc:	639c                	ld	a5,0(a5)
    800170be:	639c                	ld	a5,0(a5)
    800170c0:	639c                	ld	a5,0(a5)
    800170c2:	85be                	mv	a1,a5
    800170c4:	00005517          	auipc	a0,0x5
    800170c8:	78c50513          	addi	a0,a0,1932 # 8001c850 <pow10.0+0x1620>
    800170cc:	d4efe0ef          	jal	ra,8001561a <debugf>
    block_device->ready = true;
    800170d0:	00003797          	auipc	a5,0x3
    800170d4:	fe078793          	addi	a5,a5,-32 # 8001a0b0 <block_device>
    800170d8:	639c                	ld	a5,0(a5)
    800170da:	4705                	li	a4,1
    800170dc:	04e78723          	sb	a4,78(a5)
}
    800170e0:	0001                	nop
    800170e2:	60a2                	ld	ra,8(sp)
    800170e4:	6402                	ld	s0,0(sp)
    800170e6:	0141                	addi	sp,sp,16
    800170e8:	8082                	ret

00000000800170ea <block_device_send_request>:

void block_device_send_request(BlockRequestPacket *packet) {
    800170ea:	715d                	addi	sp,sp,-80
    800170ec:	e486                	sd	ra,72(sp)
    800170ee:	e0a2                	sd	s0,64(sp)
    800170f0:	0880                	addi	s0,sp,80
    800170f2:	faa43c23          	sd	a0,-72(s0)
    // First descriptor is the header
    VirtioDescriptor header;
    header.addr = kernel_mmu_translate(packet);
    800170f6:	fb843783          	ld	a5,-72(s0)
    800170fa:	853e                	mv	a0,a5
    800170fc:	caffc0ef          	jal	ra,80013daa <kernel_mmu_translate>
    80017100:	87aa                	mv	a5,a0
    80017102:	fef43023          	sd	a5,-32(s0)
    header.flags = VIRTQ_DESC_F_NEXT;
    80017106:	4785                	li	a5,1
    80017108:	fef41623          	sh	a5,-20(s0)
    header.len = sizeof(BlockRequestPacket);
    8001710c:	02000793          	li	a5,32
    80017110:	fef42423          	sw	a5,-24(s0)
    header.next = 1;
    80017114:	4785                	li	a5,1
    80017116:	fef41723          	sh	a5,-18(s0)

    // Second descriptor is the data
    VirtioDescriptor data;
    data.addr = kernel_mmu_translate(packet->data);
    8001711a:	fb843783          	ld	a5,-72(s0)
    8001711e:	6b9c                	ld	a5,16(a5)
    80017120:	853e                	mv	a0,a5
    80017122:	c89fc0ef          	jal	ra,80013daa <kernel_mmu_translate>
    80017126:	87aa                	mv	a5,a0
    80017128:	fcf43823          	sd	a5,-48(s0)
    data.flags = VIRTQ_DESC_F_NEXT | VIRTQ_DESC_F_WRITE;
    8001712c:	478d                	li	a5,3
    8001712e:	fcf41e23          	sh	a5,-36(s0)
    data.len = packet->sector_count * 512;
    80017132:	fb843783          	ld	a5,-72(s0)
    80017136:	0187c783          	lbu	a5,24(a5)
    8001713a:	2781                	sext.w	a5,a5
    8001713c:	0097979b          	slliw	a5,a5,0x9
    80017140:	2781                	sext.w	a5,a5
    80017142:	2781                	sext.w	a5,a5
    80017144:	fcf42c23          	sw	a5,-40(s0)
    data.next = 1;
    80017148:	4785                	li	a5,1
    8001714a:	fcf41f23          	sh	a5,-34(s0)

    // The third descriptor is the status
    VirtioDescriptor status;
    status.addr = kernel_mmu_translate((uint64_t)&packet->status);
    8001714e:	fb843783          	ld	a5,-72(s0)
    80017152:	07e5                	addi	a5,a5,25
    80017154:	853e                	mv	a0,a5
    80017156:	c55fc0ef          	jal	ra,80013daa <kernel_mmu_translate>
    8001715a:	87aa                	mv	a5,a0
    8001715c:	fcf43023          	sd	a5,-64(s0)
    status.flags = VIRTQ_DESC_F_WRITE;
    80017160:	4789                	li	a5,2
    80017162:	fcf41623          	sh	a5,-52(s0)
    status.len = sizeof(packet->status);
    80017166:	4785                	li	a5,1
    80017168:	fcf42423          	sw	a5,-56(s0)
    status.next = 0;
    8001716c:	fc041723          	sh	zero,-50(s0)

    // Create the chain
    virtio_send_descriptor(block_device, 0, header, false);
    80017170:	00003797          	auipc	a5,0x3
    80017174:	f4078793          	addi	a5,a5,-192 # 8001a0b0 <block_device>
    80017178:	639c                	ld	a5,0(a5)
    8001717a:	4701                	li	a4,0
    8001717c:	fe043603          	ld	a2,-32(s0)
    80017180:	fe843683          	ld	a3,-24(s0)
    80017184:	4581                	li	a1,0
    80017186:	853e                	mv	a0,a5
    80017188:	bd2ff0ef          	jal	ra,8001655a <virtio_send_descriptor>
    virtio_send_descriptor(block_device, 0, data, false);
    8001718c:	00003797          	auipc	a5,0x3
    80017190:	f2478793          	addi	a5,a5,-220 # 8001a0b0 <block_device>
    80017194:	639c                	ld	a5,0(a5)
    80017196:	4701                	li	a4,0
    80017198:	fd043603          	ld	a2,-48(s0)
    8001719c:	fd843683          	ld	a3,-40(s0)
    800171a0:	4581                	li	a1,0
    800171a2:	853e                	mv	a0,a5
    800171a4:	bb6ff0ef          	jal	ra,8001655a <virtio_send_descriptor>
    virtio_send_descriptor(block_device, 0, status, true);
    800171a8:	00003797          	auipc	a5,0x3
    800171ac:	f0878793          	addi	a5,a5,-248 # 8001a0b0 <block_device>
    800171b0:	639c                	ld	a5,0(a5)
    800171b2:	4705                	li	a4,1
    800171b4:	fc043603          	ld	a2,-64(s0)
    800171b8:	fc843683          	ld	a3,-56(s0)
    800171bc:	4581                	li	a1,0
    800171be:	853e                	mv	a0,a5
    800171c0:	b9aff0ef          	jal	ra,8001655a <virtio_send_descriptor>
}
    800171c4:	0001                	nop
    800171c6:	60a6                	ld	ra,72(sp)
    800171c8:	6406                	ld	s0,64(sp)
    800171ca:	6161                	addi	sp,sp,80
    800171cc:	8082                	ret

00000000800171ce <block_device_read_sector>:

void block_device_read_sector(uint64_t sector, uint8_t *data) {
    800171ce:	7139                	addi	sp,sp,-64
    800171d0:	fc06                	sd	ra,56(sp)
    800171d2:	f822                	sd	s0,48(sp)
    800171d4:	0080                	addi	s0,sp,64
    800171d6:	fca43423          	sd	a0,-56(s0)
    800171da:	fcb43023          	sd	a1,-64(s0)
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_IN;
    800171de:	fc042823          	sw	zero,-48(s0)
    packet.reserved = 0;
    800171e2:	fc042a23          	sw	zero,-44(s0)
    packet.sector = sector;
    800171e6:	fc843783          	ld	a5,-56(s0)
    800171ea:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    800171ee:	fc043783          	ld	a5,-64(s0)
    800171f2:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    800171f6:	4785                	li	a5,1
    800171f8:	fef40423          	sb	a5,-24(s0)
    packet.status = 0;
    800171fc:	fe0404a3          	sb	zero,-23(s0)

    block_device_send_request(&packet);
    80017200:	fd040793          	addi	a5,s0,-48
    80017204:	853e                	mv	a0,a5
    80017206:	ee5ff0ef          	jal	ra,800170ea <block_device_send_request>
}
    8001720a:	0001                	nop
    8001720c:	70e2                	ld	ra,56(sp)
    8001720e:	7442                	ld	s0,48(sp)
    80017210:	6121                	addi	sp,sp,64
    80017212:	8082                	ret

0000000080017214 <block_device_write_sector>:

void block_device_write_sector(uint64_t sector, uint8_t *data) {
    80017214:	7139                	addi	sp,sp,-64
    80017216:	fc06                	sd	ra,56(sp)
    80017218:	f822                	sd	s0,48(sp)
    8001721a:	0080                	addi	s0,sp,64
    8001721c:	fca43423          	sd	a0,-56(s0)
    80017220:	fcb43023          	sd	a1,-64(s0)
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_OUT;
    80017224:	4785                	li	a5,1
    80017226:	fcf42823          	sw	a5,-48(s0)
    packet.reserved = 0;
    8001722a:	fc042a23          	sw	zero,-44(s0)
    packet.sector = sector;
    8001722e:	fc843783          	ld	a5,-56(s0)
    80017232:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    80017236:	fc043783          	ld	a5,-64(s0)
    8001723a:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    8001723e:	4785                	li	a5,1
    80017240:	fef40423          	sb	a5,-24(s0)
    packet.status = 0;
    80017244:	fe0404a3          	sb	zero,-23(s0)

    block_device_send_request(&packet);
    80017248:	fd040793          	addi	a5,s0,-48
    8001724c:	853e                	mv	a0,a5
    8001724e:	e9dff0ef          	jal	ra,800170ea <block_device_send_request>
}
    80017252:	0001                	nop
    80017254:	70e2                	ld	ra,56(sp)
    80017256:	7442                	ld	s0,48(sp)
    80017258:	6121                	addi	sp,sp,64
    8001725a:	8082                	ret
    8001725c:	0000                	unimp
	...

0000000080017260 <_start>:
.section .text
.global _start
_start:
.option push
.option norelax
	la		sp, _stack_end
    80017260:	00010117          	auipc	sp,0x10
    80017264:	da010113          	addi	sp,sp,-608 # 80027000 <_heap_start>
	la		gp, __global_pointer$
    80017268:	00003197          	auipc	gp,0x3
    8001726c:	d9818193          	addi	gp,gp,-616 # 8001a000 <kernel_mmu_table>
    # Unlike the SBI, we will be trap returning so that
    # we know the registers sstatus, sip, stvec, and sepc are
    # in a place where we expect them to be. We can just jump
    # into main (tail main) like the SBI, but this ensures the CSRs
    # are what we say they are instead of just assuming from the SBI.
	la		t0, main
    80017270:	ffffe297          	auipc	t0,0xffffe
    80017274:	a5e28293          	addi	t0,t0,-1442 # 80014cce <main>
	csrw	sepc, t0
    80017278:	14129073          	csrw	sepc,t0
	li		t0, 1 << 9
    8001727c:	20000293          	li	t0,512
	csrw	sie, t0
    80017280:	10429073          	csrw	sie,t0
    # 1 << 13 - FS:  in the "initial" position
    # 1 << 8  - SPP: into Supervisor Mode
    # 1 << 5  - SPIE: enable interrupts
	li		t0, (1 << 13) | (1 << 8) | (1 << 5)
    80017284:	6289                	lui	t0,0x2
    80017286:	1202829b          	addiw	t0,t0,288
	csrw	sstatus, t0
    8001728a:	10029073          	csrw	sstatus,t0
    # Load the return address (RA) to the park. When main
    # returns, it will park the HART.
	la		ra, park
    8001728e:	00000097          	auipc	ra,0x0
    80017292:	01208093          	addi	ra,ra,18 # 800172a0 <park>
	csrr	a0, sscratch
    80017296:	14002573          	csrr	a0,sscratch
	sret
    8001729a:	10200073          	sret
    8001729e:	0001                	nop

00000000800172a0 <park>:

.section .text
.global park
.align 4
park:
	wfi
    800172a0:	10500073          	wfi
	j	park
    800172a4:	bff5                	j	800172a0 <park>

00000000800172a6 <park_end>:
	...

00000000800172b4 <process_asm_run>:

.section .text
.global process_asm_run
process_asm_run:
    # a0 - Trap frame
    csrw    sscratch, a0
    800172b4:	14051073          	csrw	sscratch,a0
    tail    _spawn_kthread
    800172b8:	5490106f          	j	80019000 <_spawn_kthread>

00000000800172bc <g_kmalloc>:
void *(*__global_kmalloc)(uint64_t size);
void *(*__global_kcalloc)(uint64_t num, uint64_t size);
void (*__global_kfree)(void *ptr);

void *g_kmalloc(uint64_t size)
{
    800172bc:	1101                	addi	sp,sp,-32
    800172be:	ec06                	sd	ra,24(sp)
    800172c0:	e822                	sd	s0,16(sp)
    800172c2:	1000                	addi	s0,sp,32
    800172c4:	fea43423          	sd	a0,-24(s0)
    if (__global_kmalloc == NULL) {
    800172c8:	00003797          	auipc	a5,0x3
    800172cc:	d4878793          	addi	a5,a5,-696 # 8001a010 <__global_kmalloc>
    800172d0:	639c                	ld	a5,0(a5)
    800172d2:	e399                	bnez	a5,800172d8 <g_kmalloc+0x1c>
        return NULL;
    800172d4:	4781                	li	a5,0
    800172d6:	a811                	j	800172ea <g_kmalloc+0x2e>
    }
    return __global_kmalloc(size);
    800172d8:	00003797          	auipc	a5,0x3
    800172dc:	d3878793          	addi	a5,a5,-712 # 8001a010 <__global_kmalloc>
    800172e0:	639c                	ld	a5,0(a5)
    800172e2:	fe843503          	ld	a0,-24(s0)
    800172e6:	9782                	jalr	a5
    800172e8:	87aa                	mv	a5,a0
}
    800172ea:	853e                	mv	a0,a5
    800172ec:	60e2                	ld	ra,24(sp)
    800172ee:	6442                	ld	s0,16(sp)
    800172f0:	6105                	addi	sp,sp,32
    800172f2:	8082                	ret

00000000800172f4 <g_kcalloc>:
void *g_kcalloc(uint64_t num, uint64_t size)
{
    800172f4:	1101                	addi	sp,sp,-32
    800172f6:	ec06                	sd	ra,24(sp)
    800172f8:	e822                	sd	s0,16(sp)
    800172fa:	1000                	addi	s0,sp,32
    800172fc:	fea43423          	sd	a0,-24(s0)
    80017300:	feb43023          	sd	a1,-32(s0)
    if (__global_kcalloc == NULL) {
    80017304:	00003797          	auipc	a5,0x3
    80017308:	d1478793          	addi	a5,a5,-748 # 8001a018 <__global_kcalloc>
    8001730c:	639c                	ld	a5,0(a5)
    8001730e:	e399                	bnez	a5,80017314 <g_kcalloc+0x20>
        return NULL;
    80017310:	4781                	li	a5,0
    80017312:	a821                	j	8001732a <g_kcalloc+0x36>
    }
    return __global_kcalloc(num, size);
    80017314:	00003797          	auipc	a5,0x3
    80017318:	d0478793          	addi	a5,a5,-764 # 8001a018 <__global_kcalloc>
    8001731c:	639c                	ld	a5,0(a5)
    8001731e:	fe043583          	ld	a1,-32(s0)
    80017322:	fe843503          	ld	a0,-24(s0)
    80017326:	9782                	jalr	a5
    80017328:	87aa                	mv	a5,a0
}
    8001732a:	853e                	mv	a0,a5
    8001732c:	60e2                	ld	ra,24(sp)
    8001732e:	6442                	ld	s0,16(sp)
    80017330:	6105                	addi	sp,sp,32
    80017332:	8082                	ret

0000000080017334 <g_kzalloc>:
void *g_kzalloc(uint64_t size)
{
    80017334:	1101                	addi	sp,sp,-32
    80017336:	ec06                	sd	ra,24(sp)
    80017338:	e822                	sd	s0,16(sp)
    8001733a:	1000                	addi	s0,sp,32
    8001733c:	fea43423          	sd	a0,-24(s0)
    return g_kcalloc(1, size);
    80017340:	fe843583          	ld	a1,-24(s0)
    80017344:	4505                	li	a0,1
    80017346:	fafff0ef          	jal	ra,800172f4 <g_kcalloc>
    8001734a:	87aa                	mv	a5,a0
}
    8001734c:	853e                	mv	a0,a5
    8001734e:	60e2                	ld	ra,24(sp)
    80017350:	6442                	ld	s0,16(sp)
    80017352:	6105                	addi	sp,sp,32
    80017354:	8082                	ret

0000000080017356 <g_kfree>:
void g_kfree(void *ptr)
{
    80017356:	1101                	addi	sp,sp,-32
    80017358:	ec06                	sd	ra,24(sp)
    8001735a:	e822                	sd	s0,16(sp)
    8001735c:	1000                	addi	s0,sp,32
    8001735e:	fea43423          	sd	a0,-24(s0)
    if (__global_kfree != NULL) {
    80017362:	00003797          	auipc	a5,0x3
    80017366:	cbe78793          	addi	a5,a5,-834 # 8001a020 <__global_kfree>
    8001736a:	639c                	ld	a5,0(a5)
    8001736c:	cb89                	beqz	a5,8001737e <g_kfree+0x28>
        __global_kfree(ptr);
    8001736e:	00003797          	auipc	a5,0x3
    80017372:	cb278793          	addi	a5,a5,-846 # 8001a020 <__global_kfree>
    80017376:	639c                	ld	a5,0(a5)
    80017378:	fe843503          	ld	a0,-24(s0)
    8001737c:	9782                	jalr	a5
    }
}
    8001737e:	0001                	nop
    80017380:	60e2                	ld	ra,24(sp)
    80017382:	6442                	ld	s0,16(sp)
    80017384:	6105                	addi	sp,sp,32
    80017386:	8082                	ret

0000000080017388 <util_connect_galloc>:

void util_connect_galloc(void *(*malloc)(uint64_t size),
                         void *(*calloc)(uint64_t elem, uint64_t size), void (*free)(void *ptr))
{
    80017388:	7179                	addi	sp,sp,-48
    8001738a:	f422                	sd	s0,40(sp)
    8001738c:	1800                	addi	s0,sp,48
    8001738e:	fea43423          	sd	a0,-24(s0)
    80017392:	feb43023          	sd	a1,-32(s0)
    80017396:	fcc43c23          	sd	a2,-40(s0)
    __global_kmalloc = malloc;
    8001739a:	00003797          	auipc	a5,0x3
    8001739e:	c7678793          	addi	a5,a5,-906 # 8001a010 <__global_kmalloc>
    800173a2:	fe843703          	ld	a4,-24(s0)
    800173a6:	e398                	sd	a4,0(a5)
    __global_kcalloc = calloc;
    800173a8:	00003797          	auipc	a5,0x3
    800173ac:	c7078793          	addi	a5,a5,-912 # 8001a018 <__global_kcalloc>
    800173b0:	fe043703          	ld	a4,-32(s0)
    800173b4:	e398                	sd	a4,0(a5)
    __global_kfree   = free;
    800173b6:	00003797          	auipc	a5,0x3
    800173ba:	c6a78793          	addi	a5,a5,-918 # 8001a020 <__global_kfree>
    800173be:	fd843703          	ld	a4,-40(s0)
    800173c2:	e398                	sd	a4,0(a5)
}
    800173c4:	0001                	nop
    800173c6:	7422                	ld	s0,40(sp)
    800173c8:	6145                	addi	sp,sp,48
    800173ca:	8082                	ret

00000000800173cc <list_init>:
typedef struct List {
    ListElem head;
} List;

static List *list_init(List *lst)
{
    800173cc:	1101                	addi	sp,sp,-32
    800173ce:	ec22                	sd	s0,24(sp)
    800173d0:	1000                	addi	s0,sp,32
    800173d2:	fea43423          	sd	a0,-24(s0)
    lst->head.next = &lst->head;
    800173d6:	fe843703          	ld	a4,-24(s0)
    800173da:	fe843783          	ld	a5,-24(s0)
    800173de:	e798                	sd	a4,8(a5)
    lst->head.prev = &lst->head;
    800173e0:	fe843703          	ld	a4,-24(s0)
    800173e4:	fe843783          	ld	a5,-24(s0)
    800173e8:	eb98                	sd	a4,16(a5)

    return lst;
    800173ea:	fe843783          	ld	a5,-24(s0)
}
    800173ee:	853e                	mv	a0,a5
    800173f0:	6462                	ld	s0,24(sp)
    800173f2:	6105                	addi	sp,sp,32
    800173f4:	8082                	ret

00000000800173f6 <list_new>:

List *list_new(void)
{
    800173f6:	1101                	addi	sp,sp,-32
    800173f8:	ec06                	sd	ra,24(sp)
    800173fa:	e822                	sd	s0,16(sp)
    800173fc:	1000                	addi	s0,sp,32
    List *m = (List *)g_kmalloc(sizeof(List));
    800173fe:	4561                	li	a0,24
    80017400:	ebdff0ef          	jal	ra,800172bc <g_kmalloc>
    80017404:	fea43423          	sd	a0,-24(s0)
    if (m == NULL) {
    80017408:	fe843783          	ld	a5,-24(s0)
    8001740c:	e399                	bnez	a5,80017412 <list_new+0x1c>
        return NULL;
    8001740e:	4781                	li	a5,0
    80017410:	a031                	j	8001741c <list_new+0x26>
    }
    return list_init(m);
    80017412:	fe843503          	ld	a0,-24(s0)
    80017416:	fb7ff0ef          	jal	ra,800173cc <list_init>
    8001741a:	87aa                	mv	a5,a0
}
    8001741c:	853e                	mv	a0,a5
    8001741e:	60e2                	ld	ra,24(sp)
    80017420:	6442                	ld	s0,16(sp)
    80017422:	6105                	addi	sp,sp,32
    80017424:	8082                	ret

0000000080017426 <list_add>:

void list_add(List *lst, uint64_t value)
{
    80017426:	7179                	addi	sp,sp,-48
    80017428:	f406                	sd	ra,40(sp)
    8001742a:	f022                	sd	s0,32(sp)
    8001742c:	1800                	addi	s0,sp,48
    8001742e:	fca43c23          	sd	a0,-40(s0)
    80017432:	fcb43823          	sd	a1,-48(s0)
    ListElem *l;
    l             = (ListElem *)g_kzalloc(sizeof(ListElem));
    80017436:	4561                	li	a0,24
    80017438:	efdff0ef          	jal	ra,80017334 <g_kzalloc>
    8001743c:	fea43423          	sd	a0,-24(s0)
    l->next       = lst->head.next;
    80017440:	fd843783          	ld	a5,-40(s0)
    80017444:	6798                	ld	a4,8(a5)
    80017446:	fe843783          	ld	a5,-24(s0)
    8001744a:	e798                	sd	a4,8(a5)
    l->prev       = &lst->head;
    8001744c:	fd843703          	ld	a4,-40(s0)
    80017450:	fe843783          	ld	a5,-24(s0)
    80017454:	eb98                	sd	a4,16(a5)
    l->next->prev = l;
    80017456:	fe843783          	ld	a5,-24(s0)
    8001745a:	679c                	ld	a5,8(a5)
    8001745c:	fe843703          	ld	a4,-24(s0)
    80017460:	eb98                	sd	a4,16(a5)
    l->prev->next = l;
    80017462:	fe843783          	ld	a5,-24(s0)
    80017466:	6b9c                	ld	a5,16(a5)
    80017468:	fe843703          	ld	a4,-24(s0)
    8001746c:	e798                	sd	a4,8(a5)
    l->value      = value;
    8001746e:	fe843783          	ld	a5,-24(s0)
    80017472:	fd043703          	ld	a4,-48(s0)
    80017476:	e398                	sd	a4,0(a5)
}
    80017478:	0001                	nop
    8001747a:	70a2                	ld	ra,40(sp)
    8001747c:	7402                	ld	s0,32(sp)
    8001747e:	6145                	addi	sp,sp,48
    80017480:	8082                	ret

0000000080017482 <list_clear>:

void list_clear(List *lst)
{
    80017482:	7179                	addi	sp,sp,-48
    80017484:	f406                	sd	ra,40(sp)
    80017486:	f022                	sd	s0,32(sp)
    80017488:	1800                	addi	s0,sp,48
    8001748a:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001748e:	fd843783          	ld	a5,-40(s0)
    80017492:	679c                	ld	a5,8(a5)
    80017494:	fef43423          	sd	a5,-24(s0)
    80017498:	a831                	j	800174b4 <list_clear+0x32>
        n = e->next;
    8001749a:	fe843783          	ld	a5,-24(s0)
    8001749e:	679c                	ld	a5,8(a5)
    800174a0:	fef43023          	sd	a5,-32(s0)
        list_remove_elem(e);
    800174a4:	fe843503          	ld	a0,-24(s0)
    800174a8:	120000ef          	jal	ra,800175c8 <list_remove_elem>
    for (e = lst->head.next; e != &lst->head; e = n) {
    800174ac:	fe043783          	ld	a5,-32(s0)
    800174b0:	fef43423          	sd	a5,-24(s0)
    800174b4:	fd843783          	ld	a5,-40(s0)
    800174b8:	fe843703          	ld	a4,-24(s0)
    800174bc:	fcf71fe3          	bne	a4,a5,8001749a <list_clear+0x18>
    }
}
    800174c0:	0001                	nop
    800174c2:	0001                	nop
    800174c4:	70a2                	ld	ra,40(sp)
    800174c6:	7402                	ld	s0,32(sp)
    800174c8:	6145                	addi	sp,sp,48
    800174ca:	8082                	ret

00000000800174cc <list_sort>:

void list_sort(List *lst, LIST_COMPARATOR_PARAM(comp))
{
    800174cc:	7139                	addi	sp,sp,-64
    800174ce:	fc06                	sd	ra,56(sp)
    800174d0:	f822                	sd	s0,48(sp)
    800174d2:	0080                	addi	s0,sp,64
    800174d4:	fca43423          	sd	a0,-56(s0)
    800174d8:	fcb43023          	sd	a1,-64(s0)
    ListElem *e;
    bool swapped;
    uint64_t tmp;

    do {
        swapped = false;
    800174dc:	fe0403a3          	sb	zero,-25(s0)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    800174e0:	fc843783          	ld	a5,-56(s0)
    800174e4:	6b9c                	ld	a5,16(a5)
    800174e6:	fef43423          	sd	a5,-24(s0)
    800174ea:	a8a9                	j	80017544 <list_sort+0x78>
            if (!comp(e->value, e->prev->value)) {
    800174ec:	fe843783          	ld	a5,-24(s0)
    800174f0:	6398                	ld	a4,0(a5)
    800174f2:	fe843783          	ld	a5,-24(s0)
    800174f6:	6b9c                	ld	a5,16(a5)
    800174f8:	639c                	ld	a5,0(a5)
    800174fa:	fc043683          	ld	a3,-64(s0)
    800174fe:	85be                	mv	a1,a5
    80017500:	853a                	mv	a0,a4
    80017502:	9682                	jalr	a3
    80017504:	87aa                	mv	a5,a0
    80017506:	0017c793          	xori	a5,a5,1
    8001750a:	0ff7f793          	andi	a5,a5,255
    8001750e:	c795                	beqz	a5,8001753a <list_sort+0x6e>
                swapped        = true;
    80017510:	4785                	li	a5,1
    80017512:	fef403a3          	sb	a5,-25(s0)
                tmp            = e->value;
    80017516:	fe843783          	ld	a5,-24(s0)
    8001751a:	639c                	ld	a5,0(a5)
    8001751c:	fcf43c23          	sd	a5,-40(s0)
                e->value       = e->prev->value;
    80017520:	fe843783          	ld	a5,-24(s0)
    80017524:	6b9c                	ld	a5,16(a5)
    80017526:	6398                	ld	a4,0(a5)
    80017528:	fe843783          	ld	a5,-24(s0)
    8001752c:	e398                	sd	a4,0(a5)
                e->prev->value = tmp;
    8001752e:	fe843783          	ld	a5,-24(s0)
    80017532:	6b9c                	ld	a5,16(a5)
    80017534:	fd843703          	ld	a4,-40(s0)
    80017538:	e398                	sd	a4,0(a5)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    8001753a:	fe843783          	ld	a5,-24(s0)
    8001753e:	6b9c                	ld	a5,16(a5)
    80017540:	fef43423          	sd	a5,-24(s0)
    80017544:	fe843783          	ld	a5,-24(s0)
    80017548:	6b98                	ld	a4,16(a5)
    8001754a:	fc843783          	ld	a5,-56(s0)
    8001754e:	f8f71fe3          	bne	a4,a5,800174ec <list_sort+0x20>
            }
        }
    } while (swapped);
    80017552:	fe744783          	lbu	a5,-25(s0)
    80017556:	0ff7f793          	andi	a5,a5,255
    8001755a:	f3c9                	bnez	a5,800174dc <list_sort+0x10>
}
    8001755c:	0001                	nop
    8001755e:	0001                	nop
    80017560:	70e2                	ld	ra,56(sp)
    80017562:	7442                	ld	s0,48(sp)
    80017564:	6121                	addi	sp,sp,64
    80017566:	8082                	ret

0000000080017568 <list_remove>:

bool list_remove(List *lst, uint64_t value)
{
    80017568:	7179                	addi	sp,sp,-48
    8001756a:	f406                	sd	ra,40(sp)
    8001756c:	f022                	sd	s0,32(sp)
    8001756e:	1800                	addi	s0,sp,48
    80017570:	fca43c23          	sd	a0,-40(s0)
    80017574:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(lst, e)
    80017578:	fd843503          	ld	a0,-40(s0)
    8001757c:	2ca000ef          	jal	ra,80017846 <list_elem_start_ascending>
    80017580:	fea43423          	sd	a0,-24(s0)
    80017584:	a025                	j	800175ac <list_remove+0x44>
    {
        if (e->value == value) {
    80017586:	fe843783          	ld	a5,-24(s0)
    8001758a:	639c                	ld	a5,0(a5)
    8001758c:	fd043703          	ld	a4,-48(s0)
    80017590:	00f71863          	bne	a4,a5,800175a0 <list_remove+0x38>
            list_remove_elem(e);
    80017594:	fe843503          	ld	a0,-24(s0)
    80017598:	030000ef          	jal	ra,800175c8 <list_remove_elem>
            return true;
    8001759c:	4785                	li	a5,1
    8001759e:	a005                	j	800175be <list_remove+0x56>
    list_for_each(lst, e)
    800175a0:	fe843503          	ld	a0,-24(s0)
    800175a4:	2ea000ef          	jal	ra,8001788e <list_elem_prev>
    800175a8:	fea43423          	sd	a0,-24(s0)
    800175ac:	fe843583          	ld	a1,-24(s0)
    800175b0:	fd843503          	ld	a0,-40(s0)
    800175b4:	204000ef          	jal	ra,800177b8 <list_elem_valid>
    800175b8:	87aa                	mv	a5,a0
    800175ba:	f7f1                	bnez	a5,80017586 <list_remove+0x1e>
        }
    }
    return false;
    800175bc:	4781                	li	a5,0
}
    800175be:	853e                	mv	a0,a5
    800175c0:	70a2                	ld	ra,40(sp)
    800175c2:	7402                	ld	s0,32(sp)
    800175c4:	6145                	addi	sp,sp,48
    800175c6:	8082                	ret

00000000800175c8 <list_remove_elem>:

void list_remove_elem(ListElem *e)
{
    800175c8:	1101                	addi	sp,sp,-32
    800175ca:	ec06                	sd	ra,24(sp)
    800175cc:	e822                	sd	s0,16(sp)
    800175ce:	1000                	addi	s0,sp,32
    800175d0:	fea43423          	sd	a0,-24(s0)
    e->next->prev = e->prev;
    800175d4:	fe843783          	ld	a5,-24(s0)
    800175d8:	679c                	ld	a5,8(a5)
    800175da:	fe843703          	ld	a4,-24(s0)
    800175de:	6b18                	ld	a4,16(a4)
    800175e0:	eb98                	sd	a4,16(a5)
    e->prev->next = e->next;
    800175e2:	fe843783          	ld	a5,-24(s0)
    800175e6:	6b9c                	ld	a5,16(a5)
    800175e8:	fe843703          	ld	a4,-24(s0)
    800175ec:	6718                	ld	a4,8(a4)
    800175ee:	e798                	sd	a4,8(a5)
    g_kfree(e);
    800175f0:	fe843503          	ld	a0,-24(s0)
    800175f4:	d63ff0ef          	jal	ra,80017356 <g_kfree>
}
    800175f8:	0001                	nop
    800175fa:	60e2                	ld	ra,24(sp)
    800175fc:	6442                	ld	s0,16(sp)
    800175fe:	6105                	addi	sp,sp,32
    80017600:	8082                	ret

0000000080017602 <list_find_elem>:

ListElem *list_find_elem(List *l, uint64_t value)
{
    80017602:	7179                	addi	sp,sp,-48
    80017604:	f406                	sd	ra,40(sp)
    80017606:	f022                	sd	s0,32(sp)
    80017608:	1800                	addi	s0,sp,48
    8001760a:	fca43c23          	sd	a0,-40(s0)
    8001760e:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(l, e)
    80017612:	fd843503          	ld	a0,-40(s0)
    80017616:	230000ef          	jal	ra,80017846 <list_elem_start_ascending>
    8001761a:	fea43423          	sd	a0,-24(s0)
    8001761e:	a00d                	j	80017640 <list_find_elem+0x3e>
    {
        if (e->value == value) {
    80017620:	fe843783          	ld	a5,-24(s0)
    80017624:	639c                	ld	a5,0(a5)
    80017626:	fd043703          	ld	a4,-48(s0)
    8001762a:	00f71563          	bne	a4,a5,80017634 <list_find_elem+0x32>
            return e;
    8001762e:	fe843783          	ld	a5,-24(s0)
    80017632:	a005                	j	80017652 <list_find_elem+0x50>
    list_for_each(l, e)
    80017634:	fe843503          	ld	a0,-24(s0)
    80017638:	256000ef          	jal	ra,8001788e <list_elem_prev>
    8001763c:	fea43423          	sd	a0,-24(s0)
    80017640:	fe843583          	ld	a1,-24(s0)
    80017644:	fd843503          	ld	a0,-40(s0)
    80017648:	170000ef          	jal	ra,800177b8 <list_elem_valid>
    8001764c:	87aa                	mv	a5,a0
    8001764e:	fbe9                	bnez	a5,80017620 <list_find_elem+0x1e>
        }
    }
    return NULL;
    80017650:	4781                	li	a5,0
}
    80017652:	853e                	mv	a0,a5
    80017654:	70a2                	ld	ra,40(sp)
    80017656:	7402                	ld	s0,32(sp)
    80017658:	6145                	addi	sp,sp,48
    8001765a:	8082                	ret

000000008001765c <list_contains>:

bool list_contains(const List *lst, uint64_t value)
{
    8001765c:	7179                	addi	sp,sp,-48
    8001765e:	f406                	sd	ra,40(sp)
    80017660:	f022                	sd	s0,32(sp)
    80017662:	1800                	addi	s0,sp,48
    80017664:	fca43c23          	sd	a0,-40(s0)
    80017668:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e = list_find_celem(lst, value);
    8001766c:	fd043583          	ld	a1,-48(s0)
    80017670:	fd843503          	ld	a0,-40(s0)
    80017674:	178000ef          	jal	ra,800177ec <list_find_celem>
    80017678:	fea43423          	sd	a0,-24(s0)

    return e == NULL ? false : true;
    8001767c:	fe843783          	ld	a5,-24(s0)
    80017680:	00f037b3          	snez	a5,a5
    80017684:	0ff7f793          	andi	a5,a5,255
}
    80017688:	853e                	mv	a0,a5
    8001768a:	70a2                	ld	ra,40(sp)
    8001768c:	7402                	ld	s0,32(sp)
    8001768e:	6145                	addi	sp,sp,48
    80017690:	8082                	ret

0000000080017692 <list_pop_back>:

ListElem *list_pop_back(List *l)
{
    80017692:	7179                	addi	sp,sp,-48
    80017694:	f406                	sd	ra,40(sp)
    80017696:	f022                	sd	s0,32(sp)
    80017698:	1800                	addi	s0,sp,48
    8001769a:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.next) {
    8001769e:	fd843703          	ld	a4,-40(s0)
    800176a2:	fd843783          	ld	a5,-40(s0)
    800176a6:	679c                	ld	a5,8(a5)
    800176a8:	00f71463          	bne	a4,a5,800176b0 <list_pop_back+0x1e>
        return NULL;
    800176ac:	4781                	li	a5,0
    800176ae:	a821                	j	800176c6 <list_pop_back+0x34>
    }
    ListElem *e = l->head.next;
    800176b0:	fd843783          	ld	a5,-40(s0)
    800176b4:	679c                	ld	a5,8(a5)
    800176b6:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    800176ba:	fe843503          	ld	a0,-24(s0)
    800176be:	f0bff0ef          	jal	ra,800175c8 <list_remove_elem>
    return e;
    800176c2:	fe843783          	ld	a5,-24(s0)
}
    800176c6:	853e                	mv	a0,a5
    800176c8:	70a2                	ld	ra,40(sp)
    800176ca:	7402                	ld	s0,32(sp)
    800176cc:	6145                	addi	sp,sp,48
    800176ce:	8082                	ret

00000000800176d0 <list_pop>:

ListElem *list_pop(List *l)
{
    800176d0:	7179                	addi	sp,sp,-48
    800176d2:	f406                	sd	ra,40(sp)
    800176d4:	f022                	sd	s0,32(sp)
    800176d6:	1800                	addi	s0,sp,48
    800176d8:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.prev) {
    800176dc:	fd843703          	ld	a4,-40(s0)
    800176e0:	fd843783          	ld	a5,-40(s0)
    800176e4:	6b9c                	ld	a5,16(a5)
    800176e6:	00f71463          	bne	a4,a5,800176ee <list_pop+0x1e>
        return NULL;
    800176ea:	4781                	li	a5,0
    800176ec:	a821                	j	80017704 <list_pop+0x34>
    }
    ListElem *e = l->head.prev;
    800176ee:	fd843783          	ld	a5,-40(s0)
    800176f2:	6b9c                	ld	a5,16(a5)
    800176f4:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    800176f8:	fe843503          	ld	a0,-24(s0)
    800176fc:	ecdff0ef          	jal	ra,800175c8 <list_remove_elem>
    return e;
    80017700:	fe843783          	ld	a5,-24(s0)
}
    80017704:	853e                	mv	a0,a5
    80017706:	70a2                	ld	ra,40(sp)
    80017708:	7402                	ld	s0,32(sp)
    8001770a:	6145                	addi	sp,sp,48
    8001770c:	8082                	ret

000000008001770e <list_size>:

uint64_t list_size(const List *lst)
{
    8001770e:	7179                	addi	sp,sp,-48
    80017710:	f406                	sd	ra,40(sp)
    80017712:	f022                	sd	s0,32(sp)
    80017714:	1800                	addi	s0,sp,48
    80017716:	fca43c23          	sd	a0,-40(s0)
    uint64_t s = 0;
    8001771a:	fe043423          	sd	zero,-24(s0)
    const ListElem *e;
    list_for_ceach(lst, e)
    8001771e:	fd843503          	ld	a0,-40(s0)
    80017722:	19c000ef          	jal	ra,800178be <list_celem_start_ascending>
    80017726:	fea43023          	sd	a0,-32(s0)
    8001772a:	a821                	j	80017742 <list_size+0x34>
    {
        s += 1;
    8001772c:	fe843783          	ld	a5,-24(s0)
    80017730:	0785                	addi	a5,a5,1
    80017732:	fef43423          	sd	a5,-24(s0)
    list_for_ceach(lst, e)
    80017736:	fe043503          	ld	a0,-32(s0)
    8001773a:	1cc000ef          	jal	ra,80017906 <list_celem_prev>
    8001773e:	fea43023          	sd	a0,-32(s0)
    80017742:	fe043583          	ld	a1,-32(s0)
    80017746:	fd843503          	ld	a0,-40(s0)
    8001774a:	06e000ef          	jal	ra,800177b8 <list_elem_valid>
    8001774e:	87aa                	mv	a5,a0
    80017750:	fff1                	bnez	a5,8001772c <list_size+0x1e>
    }
    return s;
    80017752:	fe843783          	ld	a5,-24(s0)
}
    80017756:	853e                	mv	a0,a5
    80017758:	70a2                	ld	ra,40(sp)
    8001775a:	7402                	ld	s0,32(sp)
    8001775c:	6145                	addi	sp,sp,48
    8001775e:	8082                	ret

0000000080017760 <list_free>:

void list_free(List *lst)
{
    80017760:	7179                	addi	sp,sp,-48
    80017762:	f406                	sd	ra,40(sp)
    80017764:	f022                	sd	s0,32(sp)
    80017766:	1800                	addi	s0,sp,48
    80017768:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    if (lst == NULL) {
    8001776c:	fd843783          	ld	a5,-40(s0)
    80017770:	cf9d                	beqz	a5,800177ae <list_free+0x4e>
        return;
    }
    for (e = lst->head.next; e != &lst->head; e = n) {
    80017772:	fd843783          	ld	a5,-40(s0)
    80017776:	679c                	ld	a5,8(a5)
    80017778:	fef43423          	sd	a5,-24(s0)
    8001777c:	a831                	j	80017798 <list_free+0x38>
        n = e->next;
    8001777e:	fe843783          	ld	a5,-24(s0)
    80017782:	679c                	ld	a5,8(a5)
    80017784:	fef43023          	sd	a5,-32(s0)
        g_kfree(e);
    80017788:	fe843503          	ld	a0,-24(s0)
    8001778c:	bcbff0ef          	jal	ra,80017356 <g_kfree>
    for (e = lst->head.next; e != &lst->head; e = n) {
    80017790:	fe043783          	ld	a5,-32(s0)
    80017794:	fef43423          	sd	a5,-24(s0)
    80017798:	fd843783          	ld	a5,-40(s0)
    8001779c:	fe843703          	ld	a4,-24(s0)
    800177a0:	fcf71fe3          	bne	a4,a5,8001777e <list_free+0x1e>
    }
    g_kfree(lst);
    800177a4:	fd843503          	ld	a0,-40(s0)
    800177a8:	bafff0ef          	jal	ra,80017356 <g_kfree>
    800177ac:	a011                	j	800177b0 <list_free+0x50>
        return;
    800177ae:	0001                	nop
}
    800177b0:	70a2                	ld	ra,40(sp)
    800177b2:	7402                	ld	s0,32(sp)
    800177b4:	6145                	addi	sp,sp,48
    800177b6:	8082                	ret

00000000800177b8 <list_elem_valid>:

bool list_elem_valid(const List *l, const ListElem *e)
{
    800177b8:	1101                	addi	sp,sp,-32
    800177ba:	ec22                	sd	s0,24(sp)
    800177bc:	1000                	addi	s0,sp,32
    800177be:	fea43423          	sd	a0,-24(s0)
    800177c2:	feb43023          	sd	a1,-32(s0)
    return e != NULL && e != &l->head;
    800177c6:	fe043783          	ld	a5,-32(s0)
    800177ca:	cb89                	beqz	a5,800177dc <list_elem_valid+0x24>
    800177cc:	fe843783          	ld	a5,-24(s0)
    800177d0:	fe043703          	ld	a4,-32(s0)
    800177d4:	00f70463          	beq	a4,a5,800177dc <list_elem_valid+0x24>
    800177d8:	4785                	li	a5,1
    800177da:	a011                	j	800177de <list_elem_valid+0x26>
    800177dc:	4781                	li	a5,0
    800177de:	8b85                	andi	a5,a5,1
    800177e0:	0ff7f793          	andi	a5,a5,255
}
    800177e4:	853e                	mv	a0,a5
    800177e6:	6462                	ld	s0,24(sp)
    800177e8:	6105                	addi	sp,sp,32
    800177ea:	8082                	ret

00000000800177ec <list_find_celem>:

const ListElem *list_find_celem(const List *l, uint64_t value) 
{
    800177ec:	7179                	addi	sp,sp,-48
    800177ee:	f406                	sd	ra,40(sp)
    800177f0:	f022                	sd	s0,32(sp)
    800177f2:	1800                	addi	s0,sp,48
    800177f4:	fca43c23          	sd	a0,-40(s0)
    800177f8:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e;
    list_for_ceach(l, e) 
    800177fc:	fd843503          	ld	a0,-40(s0)
    80017800:	0be000ef          	jal	ra,800178be <list_celem_start_ascending>
    80017804:	fea43423          	sd	a0,-24(s0)
    80017808:	a00d                	j	8001782a <list_find_celem+0x3e>
    {
        if (e->value == value) {
    8001780a:	fe843783          	ld	a5,-24(s0)
    8001780e:	639c                	ld	a5,0(a5)
    80017810:	fd043703          	ld	a4,-48(s0)
    80017814:	00f71563          	bne	a4,a5,8001781e <list_find_celem+0x32>
            return e;
    80017818:	fe843783          	ld	a5,-24(s0)
    8001781c:	a005                	j	8001783c <list_find_celem+0x50>
    list_for_ceach(l, e) 
    8001781e:	fe843503          	ld	a0,-24(s0)
    80017822:	0e4000ef          	jal	ra,80017906 <list_celem_prev>
    80017826:	fea43423          	sd	a0,-24(s0)
    8001782a:	fe843583          	ld	a1,-24(s0)
    8001782e:	fd843503          	ld	a0,-40(s0)
    80017832:	f87ff0ef          	jal	ra,800177b8 <list_elem_valid>
    80017836:	87aa                	mv	a5,a0
    80017838:	fbe9                	bnez	a5,8001780a <list_find_celem+0x1e>
        }
    }
    return NULL;
    8001783a:	4781                	li	a5,0
}
    8001783c:	853e                	mv	a0,a5
    8001783e:	70a2                	ld	ra,40(sp)
    80017840:	7402                	ld	s0,32(sp)
    80017842:	6145                	addi	sp,sp,48
    80017844:	8082                	ret

0000000080017846 <list_elem_start_ascending>:

ListElem *list_elem_start_ascending(List *l)
{
    80017846:	1101                	addi	sp,sp,-32
    80017848:	ec22                	sd	s0,24(sp)
    8001784a:	1000                	addi	s0,sp,32
    8001784c:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    80017850:	fe843783          	ld	a5,-24(s0)
    80017854:	6b9c                	ld	a5,16(a5)
}
    80017856:	853e                	mv	a0,a5
    80017858:	6462                	ld	s0,24(sp)
    8001785a:	6105                	addi	sp,sp,32
    8001785c:	8082                	ret

000000008001785e <list_elem_start_descending>:

ListElem *list_elem_start_descending(List *l)
{
    8001785e:	1101                	addi	sp,sp,-32
    80017860:	ec22                	sd	s0,24(sp)
    80017862:	1000                	addi	s0,sp,32
    80017864:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    80017868:	fe843783          	ld	a5,-24(s0)
    8001786c:	679c                	ld	a5,8(a5)
}
    8001786e:	853e                	mv	a0,a5
    80017870:	6462                	ld	s0,24(sp)
    80017872:	6105                	addi	sp,sp,32
    80017874:	8082                	ret

0000000080017876 <list_elem_next>:

ListElem *list_elem_next(ListElem *e)
{
    80017876:	1101                	addi	sp,sp,-32
    80017878:	ec22                	sd	s0,24(sp)
    8001787a:	1000                	addi	s0,sp,32
    8001787c:	fea43423          	sd	a0,-24(s0)
    return e->next;
    80017880:	fe843783          	ld	a5,-24(s0)
    80017884:	679c                	ld	a5,8(a5)
}
    80017886:	853e                	mv	a0,a5
    80017888:	6462                	ld	s0,24(sp)
    8001788a:	6105                	addi	sp,sp,32
    8001788c:	8082                	ret

000000008001788e <list_elem_prev>:

ListElem *list_elem_prev(ListElem *e)
{
    8001788e:	1101                	addi	sp,sp,-32
    80017890:	ec22                	sd	s0,24(sp)
    80017892:	1000                	addi	s0,sp,32
    80017894:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    80017898:	fe843783          	ld	a5,-24(s0)
    8001789c:	6b9c                	ld	a5,16(a5)
}
    8001789e:	853e                	mv	a0,a5
    800178a0:	6462                	ld	s0,24(sp)
    800178a2:	6105                	addi	sp,sp,32
    800178a4:	8082                	ret

00000000800178a6 <list_elem_value>:

uint64_t list_elem_value(const ListElem *e)
{
    800178a6:	1101                	addi	sp,sp,-32
    800178a8:	ec22                	sd	s0,24(sp)
    800178aa:	1000                	addi	s0,sp,32
    800178ac:	fea43423          	sd	a0,-24(s0)
    return e->value;
    800178b0:	fe843783          	ld	a5,-24(s0)
    800178b4:	639c                	ld	a5,0(a5)
}
    800178b6:	853e                	mv	a0,a5
    800178b8:	6462                	ld	s0,24(sp)
    800178ba:	6105                	addi	sp,sp,32
    800178bc:	8082                	ret

00000000800178be <list_celem_start_ascending>:

const ListElem *list_celem_start_ascending(const List *l) {
    800178be:	1101                	addi	sp,sp,-32
    800178c0:	ec22                	sd	s0,24(sp)
    800178c2:	1000                	addi	s0,sp,32
    800178c4:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    800178c8:	fe843783          	ld	a5,-24(s0)
    800178cc:	6b9c                	ld	a5,16(a5)
}
    800178ce:	853e                	mv	a0,a5
    800178d0:	6462                	ld	s0,24(sp)
    800178d2:	6105                	addi	sp,sp,32
    800178d4:	8082                	ret

00000000800178d6 <list_celem_start_descending>:
const ListElem *list_celem_start_descending(const List *l) {
    800178d6:	1101                	addi	sp,sp,-32
    800178d8:	ec22                	sd	s0,24(sp)
    800178da:	1000                	addi	s0,sp,32
    800178dc:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    800178e0:	fe843783          	ld	a5,-24(s0)
    800178e4:	679c                	ld	a5,8(a5)
}
    800178e6:	853e                	mv	a0,a5
    800178e8:	6462                	ld	s0,24(sp)
    800178ea:	6105                	addi	sp,sp,32
    800178ec:	8082                	ret

00000000800178ee <list_celem_next>:
const ListElem *list_celem_next(const ListElem *e) {
    800178ee:	1101                	addi	sp,sp,-32
    800178f0:	ec22                	sd	s0,24(sp)
    800178f2:	1000                	addi	s0,sp,32
    800178f4:	fea43423          	sd	a0,-24(s0)
    return e->next;
    800178f8:	fe843783          	ld	a5,-24(s0)
    800178fc:	679c                	ld	a5,8(a5)
}
    800178fe:	853e                	mv	a0,a5
    80017900:	6462                	ld	s0,24(sp)
    80017902:	6105                	addi	sp,sp,32
    80017904:	8082                	ret

0000000080017906 <list_celem_prev>:
const ListElem *list_celem_prev(const ListElem *e) {
    80017906:	1101                	addi	sp,sp,-32
    80017908:	ec22                	sd	s0,24(sp)
    8001790a:	1000                	addi	s0,sp,32
    8001790c:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    80017910:	fe843783          	ld	a5,-24(s0)
    80017914:	6b9c                	ld	a5,16(a5)
}
    80017916:	853e                	mv	a0,a5
    80017918:	6462                	ld	s0,24(sp)
    8001791a:	6105                	addi	sp,sp,32
    8001791c:	8082                	ret

000000008001791e <list_sort_signed_long_comparator_ascending>:

// Default list comparators
LIST_COMPARATOR(list_sort_signed_long_comparator_ascending)
{
    8001791e:	1101                	addi	sp,sp,-32
    80017920:	ec22                	sd	s0,24(sp)
    80017922:	1000                	addi	s0,sp,32
    80017924:	fea43423          	sd	a0,-24(s0)
    80017928:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    8001792c:	fe843703          	ld	a4,-24(s0)
    80017930:	fe043783          	ld	a5,-32(s0)
    80017934:	00e7a7b3          	slt	a5,a5,a4
    80017938:	0017c793          	xori	a5,a5,1
    8001793c:	0ff7f793          	andi	a5,a5,255
}
    80017940:	853e                	mv	a0,a5
    80017942:	6462                	ld	s0,24(sp)
    80017944:	6105                	addi	sp,sp,32
    80017946:	8082                	ret

0000000080017948 <list_sort_signed_long_comparator_descending>:
LIST_COMPARATOR(list_sort_signed_long_comparator_descending)
{
    80017948:	1101                	addi	sp,sp,-32
    8001794a:	ec22                	sd	s0,24(sp)
    8001794c:	1000                	addi	s0,sp,32
    8001794e:	fea43423          	sd	a0,-24(s0)
    80017952:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    80017956:	fe843703          	ld	a4,-24(s0)
    8001795a:	fe043783          	ld	a5,-32(s0)
    8001795e:	00f727b3          	slt	a5,a4,a5
    80017962:	0017c793          	xori	a5,a5,1
    80017966:	0ff7f793          	andi	a5,a5,255
}
    8001796a:	853e                	mv	a0,a5
    8001796c:	6462                	ld	s0,24(sp)
    8001796e:	6105                	addi	sp,sp,32
    80017970:	8082                	ret

0000000080017972 <list_sort_unsigned_long_comparator_ascending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_ascending)
{
    80017972:	1101                	addi	sp,sp,-32
    80017974:	ec22                	sd	s0,24(sp)
    80017976:	1000                	addi	s0,sp,32
    80017978:	fea43423          	sd	a0,-24(s0)
    8001797c:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    80017980:	fe843703          	ld	a4,-24(s0)
    80017984:	fe043783          	ld	a5,-32(s0)
    80017988:	00e7b7b3          	sltu	a5,a5,a4
    8001798c:	0017c793          	xori	a5,a5,1
    80017990:	0ff7f793          	andi	a5,a5,255
}
    80017994:	853e                	mv	a0,a5
    80017996:	6462                	ld	s0,24(sp)
    80017998:	6105                	addi	sp,sp,32
    8001799a:	8082                	ret

000000008001799c <list_sort_unsigned_long_comparator_descending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_descending)
{
    8001799c:	1101                	addi	sp,sp,-32
    8001799e:	ec22                	sd	s0,24(sp)
    800179a0:	1000                	addi	s0,sp,32
    800179a2:	fea43423          	sd	a0,-24(s0)
    800179a6:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    800179aa:	fe843703          	ld	a4,-24(s0)
    800179ae:	fe043783          	ld	a5,-32(s0)
    800179b2:	00f737b3          	sltu	a5,a4,a5
    800179b6:	0017c793          	xori	a5,a5,1
    800179ba:	0ff7f793          	andi	a5,a5,255
}
    800179be:	853e                	mv	a0,a5
    800179c0:	6462                	ld	s0,24(sp)
    800179c2:	6105                	addi	sp,sp,32
    800179c4:	8082                	ret

00000000800179c6 <list_sort_string_comparator_ascending>:
LIST_COMPARATOR(list_sort_string_comparator_ascending)
{
    800179c6:	1101                	addi	sp,sp,-32
    800179c8:	ec06                	sd	ra,24(sp)
    800179ca:	e822                	sd	s0,16(sp)
    800179cc:	1000                	addi	s0,sp,32
    800179ce:	fea43423          	sd	a0,-24(s0)
    800179d2:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    800179d6:	fe843783          	ld	a5,-24(s0)
    800179da:	fe043703          	ld	a4,-32(s0)
    800179de:	85ba                	mv	a1,a4
    800179e0:	853e                	mv	a0,a5
    800179e2:	4e0000ef          	jal	ra,80017ec2 <strcmp>
    800179e6:	87aa                	mv	a5,a0
    800179e8:	0017a793          	slti	a5,a5,1
    800179ec:	0ff7f793          	andi	a5,a5,255
}
    800179f0:	853e                	mv	a0,a5
    800179f2:	60e2                	ld	ra,24(sp)
    800179f4:	6442                	ld	s0,16(sp)
    800179f6:	6105                	addi	sp,sp,32
    800179f8:	8082                	ret

00000000800179fa <list_sort_string_comparator_descending>:
LIST_COMPARATOR(list_sort_string_comparator_descending)
{
    800179fa:	1101                	addi	sp,sp,-32
    800179fc:	ec06                	sd	ra,24(sp)
    800179fe:	e822                	sd	s0,16(sp)
    80017a00:	1000                	addi	s0,sp,32
    80017a02:	fea43423          	sd	a0,-24(s0)
    80017a06:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    80017a0a:	fe843783          	ld	a5,-24(s0)
    80017a0e:	fe043703          	ld	a4,-32(s0)
    80017a12:	85ba                	mv	a1,a4
    80017a14:	853e                	mv	a0,a5
    80017a16:	4ac000ef          	jal	ra,80017ec2 <strcmp>
    80017a1a:	87aa                	mv	a5,a0
    80017a1c:	fff7c793          	not	a5,a5
    80017a20:	01f7d79b          	srliw	a5,a5,0x1f
    80017a24:	0ff7f793          	andi	a5,a5,255
}
    80017a28:	853e                	mv	a0,a5
    80017a2a:	60e2                	ld	ra,24(sp)
    80017a2c:	6442                	ld	s0,16(sp)
    80017a2e:	6105                	addi	sp,sp,32
    80017a30:	8082                	ret

0000000080017a32 <memset>:
#include <alloc.h>
#include <stdint.h>
#include <util.h>

void *memset(void *dst, char data, int size)
{
    80017a32:	715d                	addi	sp,sp,-80
    80017a34:	e4a2                	sd	s0,72(sp)
    80017a36:	0880                	addi	s0,sp,80
    80017a38:	faa43c23          	sd	a0,-72(s0)
    80017a3c:	87ae                	mv	a5,a1
    80017a3e:	8732                	mv	a4,a2
    80017a40:	faf40ba3          	sb	a5,-73(s0)
    80017a44:	87ba                	mv	a5,a4
    80017a46:	faf42823          	sw	a5,-80(s0)
    int64_t i;
    long *ldst = (long *)dst;
    80017a4a:	fb843783          	ld	a5,-72(s0)
    80017a4e:	fef43023          	sd	a5,-32(s0)
    char *cdst;
    char l[]              = {data, data, data, data, data, data, data, data};
    80017a52:	fb744783          	lbu	a5,-73(s0)
    80017a56:	fcf40423          	sb	a5,-56(s0)
    80017a5a:	fb744783          	lbu	a5,-73(s0)
    80017a5e:	fcf404a3          	sb	a5,-55(s0)
    80017a62:	fb744783          	lbu	a5,-73(s0)
    80017a66:	fcf40523          	sb	a5,-54(s0)
    80017a6a:	fb744783          	lbu	a5,-73(s0)
    80017a6e:	fcf405a3          	sb	a5,-53(s0)
    80017a72:	fb744783          	lbu	a5,-73(s0)
    80017a76:	fcf40623          	sb	a5,-52(s0)
    80017a7a:	fb744783          	lbu	a5,-73(s0)
    80017a7e:	fcf406a3          	sb	a5,-51(s0)
    80017a82:	fb744783          	lbu	a5,-73(s0)
    80017a86:	fcf40723          	sb	a5,-50(s0)
    80017a8a:	fb744783          	lbu	a5,-73(s0)
    80017a8e:	fcf407a3          	sb	a5,-49(s0)

    int num_8_byte_copies = size / 8;
    80017a92:	fb042783          	lw	a5,-80(s0)
    80017a96:	41f7d71b          	sraiw	a4,a5,0x1f
    80017a9a:	01d7571b          	srliw	a4,a4,0x1d
    80017a9e:	9fb9                	addw	a5,a5,a4
    80017aa0:	4037d79b          	sraiw	a5,a5,0x3
    80017aa4:	fcf42a23          	sw	a5,-44(s0)
    int num_1_byte_copies = size % 8;
    80017aa8:	fb042703          	lw	a4,-80(s0)
    80017aac:	41f7579b          	sraiw	a5,a4,0x1f
    80017ab0:	01d7d79b          	srliw	a5,a5,0x1d
    80017ab4:	9f3d                	addw	a4,a4,a5
    80017ab6:	8b1d                	andi	a4,a4,7
    80017ab8:	40f707bb          	subw	a5,a4,a5
    80017abc:	fcf42823          	sw	a5,-48(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    80017ac0:	fe043423          	sd	zero,-24(s0)
    80017ac4:	a005                	j	80017ae4 <memset+0xb2>
        *ldst++ = *((long *)l);
    80017ac6:	fc840713          	addi	a4,s0,-56
    80017aca:	fe043783          	ld	a5,-32(s0)
    80017ace:	00878693          	addi	a3,a5,8
    80017ad2:	fed43023          	sd	a3,-32(s0)
    80017ad6:	6318                	ld	a4,0(a4)
    80017ad8:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    80017ada:	fe843783          	ld	a5,-24(s0)
    80017ade:	0785                	addi	a5,a5,1
    80017ae0:	fef43423          	sd	a5,-24(s0)
    80017ae4:	fd442783          	lw	a5,-44(s0)
    80017ae8:	fe843703          	ld	a4,-24(s0)
    80017aec:	fcf74de3          	blt	a4,a5,80017ac6 <memset+0x94>
    }

    cdst = (char *)ldst;
    80017af0:	fe043783          	ld	a5,-32(s0)
    80017af4:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    80017af8:	fe043423          	sd	zero,-24(s0)
    80017afc:	a005                	j	80017b1c <memset+0xea>
        *cdst++ = data;
    80017afe:	fd843783          	ld	a5,-40(s0)
    80017b02:	00178713          	addi	a4,a5,1
    80017b06:	fce43c23          	sd	a4,-40(s0)
    80017b0a:	fb744703          	lbu	a4,-73(s0)
    80017b0e:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    80017b12:	fe843783          	ld	a5,-24(s0)
    80017b16:	0785                	addi	a5,a5,1
    80017b18:	fef43423          	sd	a5,-24(s0)
    80017b1c:	fd042783          	lw	a5,-48(s0)
    80017b20:	fe843703          	ld	a4,-24(s0)
    80017b24:	fcf74de3          	blt	a4,a5,80017afe <memset+0xcc>
    }

    return dst;
    80017b28:	fb843783          	ld	a5,-72(s0)
}
    80017b2c:	853e                	mv	a0,a5
    80017b2e:	6426                	ld	s0,72(sp)
    80017b30:	6161                	addi	sp,sp,80
    80017b32:	8082                	ret

0000000080017b34 <memcpy>:

void *memcpy(void *dst, const void *src, int size)
{
    80017b34:	711d                	addi	sp,sp,-96
    80017b36:	eca2                	sd	s0,88(sp)
    80017b38:	1080                	addi	s0,sp,96
    80017b3a:	faa43c23          	sd	a0,-72(s0)
    80017b3e:	fab43823          	sd	a1,-80(s0)
    80017b42:	87b2                	mv	a5,a2
    80017b44:	faf42623          	sw	a5,-84(s0)
    int i;
    char *cdst;
    const char *csrc;
    long *ldst            = (long *)dst;
    80017b48:	fb843783          	ld	a5,-72(s0)
    80017b4c:	fcf43823          	sd	a5,-48(s0)
    const long *lsrc      = (long *)src;
    80017b50:	fb043783          	ld	a5,-80(s0)
    80017b54:	fcf43423          	sd	a5,-56(s0)

    int num_8_byte_copies = size / 8;
    80017b58:	fac42783          	lw	a5,-84(s0)
    80017b5c:	41f7d71b          	sraiw	a4,a5,0x1f
    80017b60:	01d7571b          	srliw	a4,a4,0x1d
    80017b64:	9fb9                	addw	a5,a5,a4
    80017b66:	4037d79b          	sraiw	a5,a5,0x3
    80017b6a:	fcf42223          	sw	a5,-60(s0)
    int num_1_byte_copies = size % 8;
    80017b6e:	fac42703          	lw	a4,-84(s0)
    80017b72:	41f7579b          	sraiw	a5,a4,0x1f
    80017b76:	01d7d79b          	srliw	a5,a5,0x1d
    80017b7a:	9f3d                	addw	a4,a4,a5
    80017b7c:	8b1d                	andi	a4,a4,7
    80017b7e:	40f707bb          	subw	a5,a4,a5
    80017b82:	fcf42023          	sw	a5,-64(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    80017b86:	fe042623          	sw	zero,-20(s0)
    80017b8a:	a025                	j	80017bb2 <memcpy+0x7e>
        *ldst++ = *lsrc++;
    80017b8c:	fc843703          	ld	a4,-56(s0)
    80017b90:	00870793          	addi	a5,a4,8
    80017b94:	fcf43423          	sd	a5,-56(s0)
    80017b98:	fd043783          	ld	a5,-48(s0)
    80017b9c:	00878693          	addi	a3,a5,8
    80017ba0:	fcd43823          	sd	a3,-48(s0)
    80017ba4:	6318                	ld	a4,0(a4)
    80017ba6:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    80017ba8:	fec42783          	lw	a5,-20(s0)
    80017bac:	2785                	addiw	a5,a5,1
    80017bae:	fef42623          	sw	a5,-20(s0)
    80017bb2:	fec42703          	lw	a4,-20(s0)
    80017bb6:	fc442783          	lw	a5,-60(s0)
    80017bba:	2701                	sext.w	a4,a4
    80017bbc:	2781                	sext.w	a5,a5
    80017bbe:	fcf747e3          	blt	a4,a5,80017b8c <memcpy+0x58>
    }

    cdst = (char *)ldst;
    80017bc2:	fd043783          	ld	a5,-48(s0)
    80017bc6:	fef43023          	sd	a5,-32(s0)
    csrc = (char *)lsrc;
    80017bca:	fc843783          	ld	a5,-56(s0)
    80017bce:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    80017bd2:	fe042623          	sw	zero,-20(s0)
    80017bd6:	a035                	j	80017c02 <memcpy+0xce>
        *cdst++ = *csrc++;
    80017bd8:	fd843703          	ld	a4,-40(s0)
    80017bdc:	00170793          	addi	a5,a4,1
    80017be0:	fcf43c23          	sd	a5,-40(s0)
    80017be4:	fe043783          	ld	a5,-32(s0)
    80017be8:	00178693          	addi	a3,a5,1
    80017bec:	fed43023          	sd	a3,-32(s0)
    80017bf0:	00074703          	lbu	a4,0(a4)
    80017bf4:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    80017bf8:	fec42783          	lw	a5,-20(s0)
    80017bfc:	2785                	addiw	a5,a5,1
    80017bfe:	fef42623          	sw	a5,-20(s0)
    80017c02:	fec42703          	lw	a4,-20(s0)
    80017c06:	fc042783          	lw	a5,-64(s0)
    80017c0a:	2701                	sext.w	a4,a4
    80017c0c:	2781                	sext.w	a5,a5
    80017c0e:	fcf745e3          	blt	a4,a5,80017bd8 <memcpy+0xa4>
    }

    return dst;
    80017c12:	fb843783          	ld	a5,-72(s0)
}
    80017c16:	853e                	mv	a0,a5
    80017c18:	6466                	ld	s0,88(sp)
    80017c1a:	6125                	addi	sp,sp,96
    80017c1c:	8082                	ret

0000000080017c1e <memmove>:

void *memmove(void *_dst, const void *_src, int n)
{
    80017c1e:	7139                	addi	sp,sp,-64
    80017c20:	fc22                	sd	s0,56(sp)
    80017c22:	0080                	addi	s0,sp,64
    80017c24:	fca43c23          	sd	a0,-40(s0)
    80017c28:	fcb43823          	sd	a1,-48(s0)
    80017c2c:	87b2                	mv	a5,a2
    80017c2e:	fcf42623          	sw	a5,-52(s0)
    const char *src = _src;
    80017c32:	fd043783          	ld	a5,-48(s0)
    80017c36:	fef43423          	sd	a5,-24(s0)
    char *dst       = _dst;
    80017c3a:	fd843783          	ld	a5,-40(s0)
    80017c3e:	fef43023          	sd	a5,-32(s0)

    if (n == 0)
    80017c42:	fcc42783          	lw	a5,-52(s0)
    80017c46:	2781                	sext.w	a5,a5
    80017c48:	e781                	bnez	a5,80017c50 <memmove+0x32>
        return _dst;
    80017c4a:	fd843783          	ld	a5,-40(s0)
    80017c4e:	a845                	j	80017cfe <memmove+0xe0>

    if (src < dst && src + n > dst) {
    80017c50:	fe843703          	ld	a4,-24(s0)
    80017c54:	fe043783          	ld	a5,-32(s0)
    80017c58:	08f77c63          	bgeu	a4,a5,80017cf0 <memmove+0xd2>
    80017c5c:	fcc42783          	lw	a5,-52(s0)
    80017c60:	fe843703          	ld	a4,-24(s0)
    80017c64:	97ba                	add	a5,a5,a4
    80017c66:	fe043703          	ld	a4,-32(s0)
    80017c6a:	08f77363          	bgeu	a4,a5,80017cf0 <memmove+0xd2>
        src += n;
    80017c6e:	fcc42783          	lw	a5,-52(s0)
    80017c72:	fe843703          	ld	a4,-24(s0)
    80017c76:	97ba                	add	a5,a5,a4
    80017c78:	fef43423          	sd	a5,-24(s0)
        dst += n;
    80017c7c:	fcc42783          	lw	a5,-52(s0)
    80017c80:	fe043703          	ld	a4,-32(s0)
    80017c84:	97ba                	add	a5,a5,a4
    80017c86:	fef43023          	sd	a5,-32(s0)
        for (; n > 0; n -= 1) {
    80017c8a:	a805                	j	80017cba <memmove+0x9c>
            *--dst = *--src;
    80017c8c:	fe843783          	ld	a5,-24(s0)
    80017c90:	17fd                	addi	a5,a5,-1
    80017c92:	fef43423          	sd	a5,-24(s0)
    80017c96:	fe043783          	ld	a5,-32(s0)
    80017c9a:	17fd                	addi	a5,a5,-1
    80017c9c:	fef43023          	sd	a5,-32(s0)
    80017ca0:	fe843783          	ld	a5,-24(s0)
    80017ca4:	0007c703          	lbu	a4,0(a5)
    80017ca8:	fe043783          	ld	a5,-32(s0)
    80017cac:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    80017cb0:	fcc42783          	lw	a5,-52(s0)
    80017cb4:	37fd                	addiw	a5,a5,-1
    80017cb6:	fcf42623          	sw	a5,-52(s0)
    80017cba:	fcc42783          	lw	a5,-52(s0)
    80017cbe:	2781                	sext.w	a5,a5
    80017cc0:	fcf046e3          	bgtz	a5,80017c8c <memmove+0x6e>
    if (src < dst && src + n > dst) {
    80017cc4:	a81d                	j	80017cfa <memmove+0xdc>
        }
    }
    else {
        for (; n > 0; n -= 1) {
            *dst++ = *src++;
    80017cc6:	fe843703          	ld	a4,-24(s0)
    80017cca:	00170793          	addi	a5,a4,1
    80017cce:	fef43423          	sd	a5,-24(s0)
    80017cd2:	fe043783          	ld	a5,-32(s0)
    80017cd6:	00178693          	addi	a3,a5,1
    80017cda:	fed43023          	sd	a3,-32(s0)
    80017cde:	00074703          	lbu	a4,0(a4)
    80017ce2:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    80017ce6:	fcc42783          	lw	a5,-52(s0)
    80017cea:	37fd                	addiw	a5,a5,-1
    80017cec:	fcf42623          	sw	a5,-52(s0)
    80017cf0:	fcc42783          	lw	a5,-52(s0)
    80017cf4:	2781                	sext.w	a5,a5
    80017cf6:	fcf048e3          	bgtz	a5,80017cc6 <memmove+0xa8>
        }
    }

    return _dst;
    80017cfa:	fd843783          	ld	a5,-40(s0)
}
    80017cfe:	853e                	mv	a0,a5
    80017d00:	7462                	ld	s0,56(sp)
    80017d02:	6121                	addi	sp,sp,64
    80017d04:	8082                	ret

0000000080017d06 <memcmp>:

int memcmp(const void *haystack, const void *needle, int size)
{
    80017d06:	715d                	addi	sp,sp,-80
    80017d08:	e4a2                	sd	s0,72(sp)
    80017d0a:	0880                	addi	s0,sp,80
    80017d0c:	fca43423          	sd	a0,-56(s0)
    80017d10:	fcb43023          	sd	a1,-64(s0)
    80017d14:	87b2                	mv	a5,a2
    80017d16:	faf42e23          	sw	a5,-68(s0)
    const char *hay  = (char *)haystack;
    80017d1a:	fc843783          	ld	a5,-56(s0)
    80017d1e:	fef43023          	sd	a5,-32(s0)
    const char *need = (char *)needle;
    80017d22:	fc043783          	ld	a5,-64(s0)
    80017d26:	fcf43c23          	sd	a5,-40(s0)
    int i;

    for (i = 0; i < (size - 1); i++) {
    80017d2a:	fe042623          	sw	zero,-20(s0)
    80017d2e:	a8a1                	j	80017d86 <memcmp+0x80>
        if (hay[i] != need[i]) {
    80017d30:	fec42783          	lw	a5,-20(s0)
    80017d34:	fe043703          	ld	a4,-32(s0)
    80017d38:	97ba                	add	a5,a5,a4
    80017d3a:	0007c683          	lbu	a3,0(a5)
    80017d3e:	fec42783          	lw	a5,-20(s0)
    80017d42:	fd843703          	ld	a4,-40(s0)
    80017d46:	97ba                	add	a5,a5,a4
    80017d48:	0007c783          	lbu	a5,0(a5)
    80017d4c:	8736                	mv	a4,a3
    80017d4e:	02f70763          	beq	a4,a5,80017d7c <memcmp+0x76>
            return hay[i] - need[i];
    80017d52:	fec42783          	lw	a5,-20(s0)
    80017d56:	fe043703          	ld	a4,-32(s0)
    80017d5a:	97ba                	add	a5,a5,a4
    80017d5c:	0007c783          	lbu	a5,0(a5)
    80017d60:	0007871b          	sext.w	a4,a5
    80017d64:	fec42783          	lw	a5,-20(s0)
    80017d68:	fd843683          	ld	a3,-40(s0)
    80017d6c:	97b6                	add	a5,a5,a3
    80017d6e:	0007c783          	lbu	a5,0(a5)
    80017d72:	2781                	sext.w	a5,a5
    80017d74:	40f707bb          	subw	a5,a4,a5
    80017d78:	2781                	sext.w	a5,a5
    80017d7a:	a0a1                	j	80017dc2 <memcmp+0xbc>
    for (i = 0; i < (size - 1); i++) {
    80017d7c:	fec42783          	lw	a5,-20(s0)
    80017d80:	2785                	addiw	a5,a5,1
    80017d82:	fef42623          	sw	a5,-20(s0)
    80017d86:	fbc42783          	lw	a5,-68(s0)
    80017d8a:	37fd                	addiw	a5,a5,-1
    80017d8c:	0007871b          	sext.w	a4,a5
    80017d90:	fec42783          	lw	a5,-20(s0)
    80017d94:	2781                	sext.w	a5,a5
    80017d96:	f8e7cde3          	blt	a5,a4,80017d30 <memcmp+0x2a>
        }
    }

    return hay[i] - need[i];
    80017d9a:	fec42783          	lw	a5,-20(s0)
    80017d9e:	fe043703          	ld	a4,-32(s0)
    80017da2:	97ba                	add	a5,a5,a4
    80017da4:	0007c783          	lbu	a5,0(a5)
    80017da8:	0007871b          	sext.w	a4,a5
    80017dac:	fec42783          	lw	a5,-20(s0)
    80017db0:	fd843683          	ld	a3,-40(s0)
    80017db4:	97b6                	add	a5,a5,a3
    80017db6:	0007c783          	lbu	a5,0(a5)
    80017dba:	2781                	sext.w	a5,a5
    80017dbc:	40f707bb          	subw	a5,a4,a5
    80017dc0:	2781                	sext.w	a5,a5
}
    80017dc2:	853e                	mv	a0,a5
    80017dc4:	6426                	ld	s0,72(sp)
    80017dc6:	6161                	addi	sp,sp,80
    80017dc8:	8082                	ret

0000000080017dca <atoi>:

int atoi(const char *st)
{
    80017dca:	7139                	addi	sp,sp,-64
    80017dcc:	fc22                	sd	s0,56(sp)
    80017dce:	0080                	addi	s0,sp,64
    80017dd0:	fca43423          	sd	a0,-56(s0)
    int r = 0;
    80017dd4:	fe042623          	sw	zero,-20(s0)
    int p = 1;
    80017dd8:	4785                	li	a5,1
    80017dda:	fef42423          	sw	a5,-24(s0)
    int i;
    int l = 0;
    80017dde:	fe042023          	sw	zero,-32(s0)
    int n = 0;
    80017de2:	fc042e23          	sw	zero,-36(s0)

    if (st[0] == '-') {
    80017de6:	fc843783          	ld	a5,-56(s0)
    80017dea:	0007c783          	lbu	a5,0(a5)
    80017dee:	873e                	mv	a4,a5
    80017df0:	02d00793          	li	a5,45
    80017df4:	02f71063          	bne	a4,a5,80017e14 <atoi+0x4a>
        st++;
    80017df8:	fc843783          	ld	a5,-56(s0)
    80017dfc:	0785                	addi	a5,a5,1
    80017dfe:	fcf43423          	sd	a5,-56(s0)
        n = 1;
    80017e02:	4785                	li	a5,1
    80017e04:	fcf42e23          	sw	a5,-36(s0)
    }

    while (st[l] >= '0' && st[l] <= '9')
    80017e08:	a031                	j	80017e14 <atoi+0x4a>
        l++;
    80017e0a:	fe042783          	lw	a5,-32(s0)
    80017e0e:	2785                	addiw	a5,a5,1
    80017e10:	fef42023          	sw	a5,-32(s0)
    while (st[l] >= '0' && st[l] <= '9')
    80017e14:	fe042783          	lw	a5,-32(s0)
    80017e18:	fc843703          	ld	a4,-56(s0)
    80017e1c:	97ba                	add	a5,a5,a4
    80017e1e:	0007c783          	lbu	a5,0(a5)
    80017e22:	873e                	mv	a4,a5
    80017e24:	02f00793          	li	a5,47
    80017e28:	00e7fe63          	bgeu	a5,a4,80017e44 <atoi+0x7a>
    80017e2c:	fe042783          	lw	a5,-32(s0)
    80017e30:	fc843703          	ld	a4,-56(s0)
    80017e34:	97ba                	add	a5,a5,a4
    80017e36:	0007c783          	lbu	a5,0(a5)
    80017e3a:	873e                	mv	a4,a5
    80017e3c:	03900793          	li	a5,57
    80017e40:	fce7f5e3          	bgeu	a5,a4,80017e0a <atoi+0x40>

    for (i = l - 1; i >= 0; i--) {
    80017e44:	fe042783          	lw	a5,-32(s0)
    80017e48:	37fd                	addiw	a5,a5,-1
    80017e4a:	fef42223          	sw	a5,-28(s0)
    80017e4e:	a0a9                	j	80017e98 <atoi+0xce>
        r += p * (st[i] - '0');
    80017e50:	fe442783          	lw	a5,-28(s0)
    80017e54:	fc843703          	ld	a4,-56(s0)
    80017e58:	97ba                	add	a5,a5,a4
    80017e5a:	0007c783          	lbu	a5,0(a5)
    80017e5e:	2781                	sext.w	a5,a5
    80017e60:	fd07879b          	addiw	a5,a5,-48
    80017e64:	2781                	sext.w	a5,a5
    80017e66:	fe842703          	lw	a4,-24(s0)
    80017e6a:	02f707bb          	mulw	a5,a4,a5
    80017e6e:	2781                	sext.w	a5,a5
    80017e70:	fec42703          	lw	a4,-20(s0)
    80017e74:	9fb9                	addw	a5,a5,a4
    80017e76:	fef42623          	sw	a5,-20(s0)
        p *= 10;
    80017e7a:	fe842703          	lw	a4,-24(s0)
    80017e7e:	87ba                	mv	a5,a4
    80017e80:	0027979b          	slliw	a5,a5,0x2
    80017e84:	9fb9                	addw	a5,a5,a4
    80017e86:	0017979b          	slliw	a5,a5,0x1
    80017e8a:	fef42423          	sw	a5,-24(s0)
    for (i = l - 1; i >= 0; i--) {
    80017e8e:	fe442783          	lw	a5,-28(s0)
    80017e92:	37fd                	addiw	a5,a5,-1
    80017e94:	fef42223          	sw	a5,-28(s0)
    80017e98:	fe442783          	lw	a5,-28(s0)
    80017e9c:	2781                	sext.w	a5,a5
    80017e9e:	fa07d9e3          	bgez	a5,80017e50 <atoi+0x86>
    }

    return (n ? -r : r);
    80017ea2:	fdc42783          	lw	a5,-36(s0)
    80017ea6:	2781                	sext.w	a5,a5
    80017ea8:	c799                	beqz	a5,80017eb6 <atoi+0xec>
    80017eaa:	fec42783          	lw	a5,-20(s0)
    80017eae:	40f007bb          	negw	a5,a5
    80017eb2:	2781                	sext.w	a5,a5
    80017eb4:	a019                	j	80017eba <atoi+0xf0>
    80017eb6:	fec42783          	lw	a5,-20(s0)
}
    80017eba:	853e                	mv	a0,a5
    80017ebc:	7462                	ld	s0,56(sp)
    80017ebe:	6121                	addi	sp,sp,64
    80017ec0:	8082                	ret

0000000080017ec2 <strcmp>:

int strcmp(const char *l, const char *r)
{
    80017ec2:	7139                	addi	sp,sp,-64
    80017ec4:	fc22                	sd	s0,56(sp)
    80017ec6:	0080                	addi	s0,sp,64
    80017ec8:	fca43423          	sd	a0,-56(s0)
    80017ecc:	fcb43023          	sd	a1,-64(s0)
    const unsigned char *s1 = (const unsigned char *)l;
    80017ed0:	fc843783          	ld	a5,-56(s0)
    80017ed4:	fef43423          	sd	a5,-24(s0)
    const unsigned char *s2 = (const unsigned char *)r;
    80017ed8:	fc043783          	ld	a5,-64(s0)
    80017edc:	fef43023          	sd	a5,-32(s0)
    unsigned int c1, c2;

    do {
        c1 = (unsigned char)*s1++;
    80017ee0:	fe843783          	ld	a5,-24(s0)
    80017ee4:	00178713          	addi	a4,a5,1
    80017ee8:	fee43423          	sd	a4,-24(s0)
    80017eec:	0007c783          	lbu	a5,0(a5)
    80017ef0:	fcf42e23          	sw	a5,-36(s0)
        c2 = (unsigned char)*s2++;
    80017ef4:	fe043783          	ld	a5,-32(s0)
    80017ef8:	00178713          	addi	a4,a5,1
    80017efc:	fee43023          	sd	a4,-32(s0)
    80017f00:	0007c783          	lbu	a5,0(a5)
    80017f04:	fcf42c23          	sw	a5,-40(s0)
        if (c1 == '\0')
    80017f08:	fdc42783          	lw	a5,-36(s0)
    80017f0c:	2781                	sext.w	a5,a5
    80017f0e:	eb91                	bnez	a5,80017f22 <strcmp+0x60>
            return c1 - c2;
    80017f10:	fdc42703          	lw	a4,-36(s0)
    80017f14:	fd842783          	lw	a5,-40(s0)
    80017f18:	40f707bb          	subw	a5,a4,a5
    80017f1c:	2781                	sext.w	a5,a5
    80017f1e:	2781                	sext.w	a5,a5
    80017f20:	a00d                	j	80017f42 <strcmp+0x80>
    } while (c1 == c2);
    80017f22:	fdc42703          	lw	a4,-36(s0)
    80017f26:	fd842783          	lw	a5,-40(s0)
    80017f2a:	2701                	sext.w	a4,a4
    80017f2c:	2781                	sext.w	a5,a5
    80017f2e:	faf709e3          	beq	a4,a5,80017ee0 <strcmp+0x1e>

    return c1 - c2;
    80017f32:	fdc42703          	lw	a4,-36(s0)
    80017f36:	fd842783          	lw	a5,-40(s0)
    80017f3a:	40f707bb          	subw	a5,a4,a5
    80017f3e:	2781                	sext.w	a5,a5
    80017f40:	2781                	sext.w	a5,a5
}
    80017f42:	853e                	mv	a0,a5
    80017f44:	7462                	ld	s0,56(sp)
    80017f46:	6121                	addi	sp,sp,64
    80017f48:	8082                	ret

0000000080017f4a <strncmp>:

int strncmp(const char *left, const char *right, int n)
{
    80017f4a:	7139                	addi	sp,sp,-64
    80017f4c:	fc22                	sd	s0,56(sp)
    80017f4e:	0080                	addi	s0,sp,64
    80017f50:	fca43c23          	sd	a0,-40(s0)
    80017f54:	fcb43823          	sd	a1,-48(s0)
    80017f58:	87b2                	mv	a5,a2
    80017f5a:	fcf42623          	sw	a5,-52(s0)
    unsigned int c1 = '\0';
    80017f5e:	fe042623          	sw	zero,-20(s0)
    unsigned int c2 = '\0';
    80017f62:	fe042423          	sw	zero,-24(s0)

    if (n >= 4) {
    80017f66:	fcc42783          	lw	a5,-52(s0)
    80017f6a:	0007871b          	sext.w	a4,a5
    80017f6e:	478d                	li	a5,3
    80017f70:	1ce7da63          	bge	a5,a4,80018144 <strncmp+0x1fa>
        int n4 = n >> 2;
    80017f74:	fcc42783          	lw	a5,-52(s0)
    80017f78:	4027d79b          	sraiw	a5,a5,0x2
    80017f7c:	fef42223          	sw	a5,-28(s0)
        do {
            c1 = (unsigned char)*left++;
    80017f80:	fd843783          	ld	a5,-40(s0)
    80017f84:	00178713          	addi	a4,a5,1
    80017f88:	fce43c23          	sd	a4,-40(s0)
    80017f8c:	0007c783          	lbu	a5,0(a5)
    80017f90:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80017f94:	fd043783          	ld	a5,-48(s0)
    80017f98:	00178713          	addi	a4,a5,1
    80017f9c:	fce43823          	sd	a4,-48(s0)
    80017fa0:	0007c783          	lbu	a5,0(a5)
    80017fa4:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80017fa8:	fec42783          	lw	a5,-20(s0)
    80017fac:	2781                	sext.w	a5,a5
    80017fae:	cb89                	beqz	a5,80017fc0 <strncmp+0x76>
    80017fb0:	fec42703          	lw	a4,-20(s0)
    80017fb4:	fe842783          	lw	a5,-24(s0)
    80017fb8:	2701                	sext.w	a4,a4
    80017fba:	2781                	sext.w	a5,a5
    80017fbc:	00f70b63          	beq	a4,a5,80017fd2 <strncmp+0x88>
                return c1 - c2;
    80017fc0:	fec42703          	lw	a4,-20(s0)
    80017fc4:	fe842783          	lw	a5,-24(s0)
    80017fc8:	40f707bb          	subw	a5,a4,a5
    80017fcc:	2781                	sext.w	a5,a5
    80017fce:	2781                	sext.w	a5,a5
    80017fd0:	a279                	j	8001815e <strncmp+0x214>
            }

            c1 = (unsigned char)*left++;
    80017fd2:	fd843783          	ld	a5,-40(s0)
    80017fd6:	00178713          	addi	a4,a5,1
    80017fda:	fce43c23          	sd	a4,-40(s0)
    80017fde:	0007c783          	lbu	a5,0(a5)
    80017fe2:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80017fe6:	fd043783          	ld	a5,-48(s0)
    80017fea:	00178713          	addi	a4,a5,1
    80017fee:	fce43823          	sd	a4,-48(s0)
    80017ff2:	0007c783          	lbu	a5,0(a5)
    80017ff6:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80017ffa:	fec42783          	lw	a5,-20(s0)
    80017ffe:	2781                	sext.w	a5,a5
    80018000:	cb89                	beqz	a5,80018012 <strncmp+0xc8>
    80018002:	fec42703          	lw	a4,-20(s0)
    80018006:	fe842783          	lw	a5,-24(s0)
    8001800a:	2701                	sext.w	a4,a4
    8001800c:	2781                	sext.w	a5,a5
    8001800e:	00f70b63          	beq	a4,a5,80018024 <strncmp+0xda>
                return c1 - c2;
    80018012:	fec42703          	lw	a4,-20(s0)
    80018016:	fe842783          	lw	a5,-24(s0)
    8001801a:	40f707bb          	subw	a5,a4,a5
    8001801e:	2781                	sext.w	a5,a5
    80018020:	2781                	sext.w	a5,a5
    80018022:	aa35                	j	8001815e <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    80018024:	fd843783          	ld	a5,-40(s0)
    80018028:	00178713          	addi	a4,a5,1
    8001802c:	fce43c23          	sd	a4,-40(s0)
    80018030:	0007c783          	lbu	a5,0(a5)
    80018034:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80018038:	fd043783          	ld	a5,-48(s0)
    8001803c:	00178713          	addi	a4,a5,1
    80018040:	fce43823          	sd	a4,-48(s0)
    80018044:	0007c783          	lbu	a5,0(a5)
    80018048:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001804c:	fec42783          	lw	a5,-20(s0)
    80018050:	2781                	sext.w	a5,a5
    80018052:	cb89                	beqz	a5,80018064 <strncmp+0x11a>
    80018054:	fec42703          	lw	a4,-20(s0)
    80018058:	fe842783          	lw	a5,-24(s0)
    8001805c:	2701                	sext.w	a4,a4
    8001805e:	2781                	sext.w	a5,a5
    80018060:	00f70b63          	beq	a4,a5,80018076 <strncmp+0x12c>
                return c1 - c2;
    80018064:	fec42703          	lw	a4,-20(s0)
    80018068:	fe842783          	lw	a5,-24(s0)
    8001806c:	40f707bb          	subw	a5,a4,a5
    80018070:	2781                	sext.w	a5,a5
    80018072:	2781                	sext.w	a5,a5
    80018074:	a0ed                	j	8001815e <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    80018076:	fd843783          	ld	a5,-40(s0)
    8001807a:	00178713          	addi	a4,a5,1
    8001807e:	fce43c23          	sd	a4,-40(s0)
    80018082:	0007c783          	lbu	a5,0(a5)
    80018086:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8001808a:	fd043783          	ld	a5,-48(s0)
    8001808e:	00178713          	addi	a4,a5,1
    80018092:	fce43823          	sd	a4,-48(s0)
    80018096:	0007c783          	lbu	a5,0(a5)
    8001809a:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    8001809e:	fec42783          	lw	a5,-20(s0)
    800180a2:	2781                	sext.w	a5,a5
    800180a4:	cb89                	beqz	a5,800180b6 <strncmp+0x16c>
    800180a6:	fec42703          	lw	a4,-20(s0)
    800180aa:	fe842783          	lw	a5,-24(s0)
    800180ae:	2701                	sext.w	a4,a4
    800180b0:	2781                	sext.w	a5,a5
    800180b2:	00f70b63          	beq	a4,a5,800180c8 <strncmp+0x17e>
                return c1 - c2;
    800180b6:	fec42703          	lw	a4,-20(s0)
    800180ba:	fe842783          	lw	a5,-24(s0)
    800180be:	40f707bb          	subw	a5,a4,a5
    800180c2:	2781                	sext.w	a5,a5
    800180c4:	2781                	sext.w	a5,a5
    800180c6:	a861                	j	8001815e <strncmp+0x214>
            }
        } while (--n4 > 0);
    800180c8:	fe442783          	lw	a5,-28(s0)
    800180cc:	37fd                	addiw	a5,a5,-1
    800180ce:	fef42223          	sw	a5,-28(s0)
    800180d2:	fe442783          	lw	a5,-28(s0)
    800180d6:	2781                	sext.w	a5,a5
    800180d8:	eaf044e3          	bgtz	a5,80017f80 <strncmp+0x36>
        n &= 3;
    800180dc:	fcc42783          	lw	a5,-52(s0)
    800180e0:	8b8d                	andi	a5,a5,3
    800180e2:	fcf42623          	sw	a5,-52(s0)
    }

    while (n > 0) {
    800180e6:	a8b9                	j	80018144 <strncmp+0x1fa>
        c1 = (unsigned char)*left++;
    800180e8:	fd843783          	ld	a5,-40(s0)
    800180ec:	00178713          	addi	a4,a5,1
    800180f0:	fce43c23          	sd	a4,-40(s0)
    800180f4:	0007c783          	lbu	a5,0(a5)
    800180f8:	fef42623          	sw	a5,-20(s0)
        c2 = (unsigned char)*right++;
    800180fc:	fd043783          	ld	a5,-48(s0)
    80018100:	00178713          	addi	a4,a5,1
    80018104:	fce43823          	sd	a4,-48(s0)
    80018108:	0007c783          	lbu	a5,0(a5)
    8001810c:	fef42423          	sw	a5,-24(s0)
        if (c1 == '\0' || c1 != c2)
    80018110:	fec42783          	lw	a5,-20(s0)
    80018114:	2781                	sext.w	a5,a5
    80018116:	cb89                	beqz	a5,80018128 <strncmp+0x1de>
    80018118:	fec42703          	lw	a4,-20(s0)
    8001811c:	fe842783          	lw	a5,-24(s0)
    80018120:	2701                	sext.w	a4,a4
    80018122:	2781                	sext.w	a5,a5
    80018124:	00f70b63          	beq	a4,a5,8001813a <strncmp+0x1f0>
            return c1 - c2;
    80018128:	fec42703          	lw	a4,-20(s0)
    8001812c:	fe842783          	lw	a5,-24(s0)
    80018130:	40f707bb          	subw	a5,a4,a5
    80018134:	2781                	sext.w	a5,a5
    80018136:	2781                	sext.w	a5,a5
    80018138:	a01d                	j	8001815e <strncmp+0x214>
        n--;
    8001813a:	fcc42783          	lw	a5,-52(s0)
    8001813e:	37fd                	addiw	a5,a5,-1
    80018140:	fcf42623          	sw	a5,-52(s0)
    while (n > 0) {
    80018144:	fcc42783          	lw	a5,-52(s0)
    80018148:	2781                	sext.w	a5,a5
    8001814a:	f8f04fe3          	bgtz	a5,800180e8 <strncmp+0x19e>
    }

    return c1 - c2;
    8001814e:	fec42703          	lw	a4,-20(s0)
    80018152:	fe842783          	lw	a5,-24(s0)
    80018156:	40f707bb          	subw	a5,a4,a5
    8001815a:	2781                	sext.w	a5,a5
    8001815c:	2781                	sext.w	a5,a5
}
    8001815e:	853e                	mv	a0,a5
    80018160:	7462                	ld	s0,56(sp)
    80018162:	6121                	addi	sp,sp,64
    80018164:	8082                	ret

0000000080018166 <strfindchr>:

int strfindchr(const char *r, char t)
{
    80018166:	7179                	addi	sp,sp,-48
    80018168:	f422                	sd	s0,40(sp)
    8001816a:	1800                	addi	s0,sp,48
    8001816c:	fca43c23          	sd	a0,-40(s0)
    80018170:	87ae                	mv	a5,a1
    80018172:	fcf40ba3          	sb	a5,-41(s0)
    int i = 0;
    80018176:	fe042623          	sw	zero,-20(s0)
    while (r[i] != t) {
    8001817a:	a005                	j	8001819a <strfindchr+0x34>
        if (r[i] == '\0') {
    8001817c:	fec42783          	lw	a5,-20(s0)
    80018180:	fd843703          	ld	a4,-40(s0)
    80018184:	97ba                	add	a5,a5,a4
    80018186:	0007c783          	lbu	a5,0(a5)
    8001818a:	e399                	bnez	a5,80018190 <strfindchr+0x2a>
            return -1;
    8001818c:	57fd                	li	a5,-1
    8001818e:	a02d                	j	800181b8 <strfindchr+0x52>
        }
        i++;
    80018190:	fec42783          	lw	a5,-20(s0)
    80018194:	2785                	addiw	a5,a5,1
    80018196:	fef42623          	sw	a5,-20(s0)
    while (r[i] != t) {
    8001819a:	fec42783          	lw	a5,-20(s0)
    8001819e:	fd843703          	ld	a4,-40(s0)
    800181a2:	97ba                	add	a5,a5,a4
    800181a4:	0007c703          	lbu	a4,0(a5)
    800181a8:	fd744783          	lbu	a5,-41(s0)
    800181ac:	0ff7f793          	andi	a5,a5,255
    800181b0:	fce796e3          	bne	a5,a4,8001817c <strfindchr+0x16>
    }
    return i;
    800181b4:	fec42783          	lw	a5,-20(s0)
}
    800181b8:	853e                	mv	a0,a5
    800181ba:	7422                	ld	s0,40(sp)
    800181bc:	6145                	addi	sp,sp,48
    800181be:	8082                	ret

00000000800181c0 <strlen>:

int strlen(const char *s)
{
    800181c0:	7179                	addi	sp,sp,-48
    800181c2:	f422                	sd	s0,40(sp)
    800181c4:	1800                	addi	s0,sp,48
    800181c6:	fca43c23          	sd	a0,-40(s0)
    int len = 0;
    800181ca:	fe042623          	sw	zero,-20(s0)
    while (s[len] && ++len)
    800181ce:	0001                	nop
    800181d0:	fec42783          	lw	a5,-20(s0)
    800181d4:	fd843703          	ld	a4,-40(s0)
    800181d8:	97ba                	add	a5,a5,a4
    800181da:	0007c783          	lbu	a5,0(a5)
    800181de:	cb91                	beqz	a5,800181f2 <strlen+0x32>
    800181e0:	fec42783          	lw	a5,-20(s0)
    800181e4:	2785                	addiw	a5,a5,1
    800181e6:	fef42623          	sw	a5,-20(s0)
    800181ea:	fec42783          	lw	a5,-20(s0)
    800181ee:	2781                	sext.w	a5,a5
    800181f0:	f3e5                	bnez	a5,800181d0 <strlen+0x10>
        ;
    return len;
    800181f2:	fec42783          	lw	a5,-20(s0)
}
    800181f6:	853e                	mv	a0,a5
    800181f8:	7422                	ld	s0,40(sp)
    800181fa:	6145                	addi	sp,sp,48
    800181fc:	8082                	ret

00000000800181fe <strcpy>:

char *strcpy(char *dest, const char *s)
{
    800181fe:	7179                	addi	sp,sp,-48
    80018200:	f422                	sd	s0,40(sp)
    80018202:	1800                	addi	s0,sp,48
    80018204:	fca43c23          	sd	a0,-40(s0)
    80018208:	fcb43823          	sd	a1,-48(s0)
    char *o = dest;
    8001820c:	fd843783          	ld	a5,-40(s0)
    80018210:	fef43423          	sd	a5,-24(s0)
    while (*s) {
    80018214:	a00d                	j	80018236 <strcpy+0x38>
        *dest++ = *s++;
    80018216:	fd043703          	ld	a4,-48(s0)
    8001821a:	00170793          	addi	a5,a4,1
    8001821e:	fcf43823          	sd	a5,-48(s0)
    80018222:	fd843783          	ld	a5,-40(s0)
    80018226:	00178693          	addi	a3,a5,1
    8001822a:	fcd43c23          	sd	a3,-40(s0)
    8001822e:	00074703          	lbu	a4,0(a4)
    80018232:	00e78023          	sb	a4,0(a5)
    while (*s) {
    80018236:	fd043783          	ld	a5,-48(s0)
    8001823a:	0007c783          	lbu	a5,0(a5)
    8001823e:	ffe1                	bnez	a5,80018216 <strcpy+0x18>
    }
    *dest = '\0';
    80018240:	fd843783          	ld	a5,-40(s0)
    80018244:	00078023          	sb	zero,0(a5)
    return o;
    80018248:	fe843783          	ld	a5,-24(s0)
}
    8001824c:	853e                	mv	a0,a5
    8001824e:	7422                	ld	s0,40(sp)
    80018250:	6145                	addi	sp,sp,48
    80018252:	8082                	ret

0000000080018254 <strncpy>:

char *strncpy(char *dest, const char *s, int n)
{
    80018254:	7139                	addi	sp,sp,-64
    80018256:	fc22                	sd	s0,56(sp)
    80018258:	0080                	addi	s0,sp,64
    8001825a:	fca43c23          	sd	a0,-40(s0)
    8001825e:	fcb43823          	sd	a1,-48(s0)
    80018262:	87b2                	mv	a5,a2
    80018264:	fcf42623          	sw	a5,-52(s0)
    char *o = dest;
    80018268:	fd843783          	ld	a5,-40(s0)
    8001826c:	fef43423          	sd	a5,-24(s0)
    while (*s && n-- > 0) {
    80018270:	a00d                	j	80018292 <strncpy+0x3e>
        *dest++ = *s++;
    80018272:	fd043703          	ld	a4,-48(s0)
    80018276:	00170793          	addi	a5,a4,1
    8001827a:	fcf43823          	sd	a5,-48(s0)
    8001827e:	fd843783          	ld	a5,-40(s0)
    80018282:	00178693          	addi	a3,a5,1
    80018286:	fcd43c23          	sd	a3,-40(s0)
    8001828a:	00074703          	lbu	a4,0(a4)
    8001828e:	00e78023          	sb	a4,0(a5)
    while (*s && n-- > 0) {
    80018292:	fd043783          	ld	a5,-48(s0)
    80018296:	0007c783          	lbu	a5,0(a5)
    8001829a:	cb89                	beqz	a5,800182ac <strncpy+0x58>
    8001829c:	fcc42783          	lw	a5,-52(s0)
    800182a0:	fff7871b          	addiw	a4,a5,-1
    800182a4:	fce42623          	sw	a4,-52(s0)
    800182a8:	fcf045e3          	bgtz	a5,80018272 <strncpy+0x1e>
    }
    *dest = '\0';
    800182ac:	fd843783          	ld	a5,-40(s0)
    800182b0:	00078023          	sb	zero,0(a5)
    return o;
    800182b4:	fe843783          	ld	a5,-24(s0)
}
    800182b8:	853e                	mv	a0,a5
    800182ba:	7462                	ld	s0,56(sp)
    800182bc:	6121                	addi	sp,sp,64
    800182be:	8082                	ret

00000000800182c0 <strdup>:


char *strdup(const char *src)
{
    800182c0:	7179                	addi	sp,sp,-48
    800182c2:	f406                	sd	ra,40(sp)
    800182c4:	f022                	sd	s0,32(sp)
    800182c6:	1800                	addi	s0,sp,48
    800182c8:	fca43c23          	sd	a0,-40(s0)
    int len   = strlen(src);
    800182cc:	fd843503          	ld	a0,-40(s0)
    800182d0:	ef1ff0ef          	jal	ra,800181c0 <strlen>
    800182d4:	87aa                	mv	a5,a0
    800182d6:	fef42623          	sw	a5,-20(s0)
    char *ret = (char *)g_kmalloc(len + 1);
    800182da:	fec42783          	lw	a5,-20(s0)
    800182de:	2785                	addiw	a5,a5,1
    800182e0:	2781                	sext.w	a5,a5
    800182e2:	853e                	mv	a0,a5
    800182e4:	fd9fe0ef          	jal	ra,800172bc <g_kmalloc>
    800182e8:	fea43023          	sd	a0,-32(s0)
    if (!ret) {
    800182ec:	fe043783          	ld	a5,-32(s0)
    800182f0:	e399                	bnez	a5,800182f6 <strdup+0x36>
        return NULL;
    800182f2:	4781                	li	a5,0
    800182f4:	a801                	j	80018304 <strdup+0x44>
    }
    return strcpy(ret, src);
    800182f6:	fd843583          	ld	a1,-40(s0)
    800182fa:	fe043503          	ld	a0,-32(s0)
    800182fe:	f01ff0ef          	jal	ra,800181fe <strcpy>
    80018302:	87aa                	mv	a5,a0
}
    80018304:	853e                	mv	a0,a5
    80018306:	70a2                	ld	ra,40(sp)
    80018308:	7402                	ld	s0,32(sp)
    8001830a:	6145                	addi	sp,sp,48
    8001830c:	8082                	ret

000000008001830e <strstartswith>:

bool strstartswith(const char *src, const char *start)
{
    8001830e:	7179                	addi	sp,sp,-48
    80018310:	f406                	sd	ra,40(sp)
    80018312:	f022                	sd	s0,32(sp)
    80018314:	1800                	addi	s0,sp,48
    80018316:	fca43c23          	sd	a0,-40(s0)
    8001831a:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    8001831e:	fd843503          	ld	a0,-40(s0)
    80018322:	e9fff0ef          	jal	ra,800181c0 <strlen>
    80018326:	87aa                	mv	a5,a0
    80018328:	fef42423          	sw	a5,-24(s0)
    int start_len = strlen(start);
    8001832c:	fd043503          	ld	a0,-48(s0)
    80018330:	e91ff0ef          	jal	ra,800181c0 <strlen>
    80018334:	87aa                	mv	a5,a0
    80018336:	fef42223          	sw	a5,-28(s0)
    int i;
    
    if (src_len < start_len) {
    8001833a:	fe842703          	lw	a4,-24(s0)
    8001833e:	fe442783          	lw	a5,-28(s0)
    80018342:	2701                	sext.w	a4,a4
    80018344:	2781                	sext.w	a5,a5
    80018346:	00f75463          	bge	a4,a5,8001834e <strstartswith+0x40>
        return false;
    8001834a:	4781                	li	a5,0
    8001834c:	a0a9                	j	80018396 <strstartswith+0x88>
    }

    for (i = 0;i < start_len;i++) {
    8001834e:	fe042623          	sw	zero,-20(s0)
    80018352:	a80d                	j	80018384 <strstartswith+0x76>
        if (src[i] != start[i]) {
    80018354:	fec42783          	lw	a5,-20(s0)
    80018358:	fd843703          	ld	a4,-40(s0)
    8001835c:	97ba                	add	a5,a5,a4
    8001835e:	0007c683          	lbu	a3,0(a5)
    80018362:	fec42783          	lw	a5,-20(s0)
    80018366:	fd043703          	ld	a4,-48(s0)
    8001836a:	97ba                	add	a5,a5,a4
    8001836c:	0007c783          	lbu	a5,0(a5)
    80018370:	8736                	mv	a4,a3
    80018372:	00f70463          	beq	a4,a5,8001837a <strstartswith+0x6c>
            return false;
    80018376:	4781                	li	a5,0
    80018378:	a839                	j	80018396 <strstartswith+0x88>
    for (i = 0;i < start_len;i++) {
    8001837a:	fec42783          	lw	a5,-20(s0)
    8001837e:	2785                	addiw	a5,a5,1
    80018380:	fef42623          	sw	a5,-20(s0)
    80018384:	fec42703          	lw	a4,-20(s0)
    80018388:	fe442783          	lw	a5,-28(s0)
    8001838c:	2701                	sext.w	a4,a4
    8001838e:	2781                	sext.w	a5,a5
    80018390:	fcf742e3          	blt	a4,a5,80018354 <strstartswith+0x46>
        }
    }

    return true;
    80018394:	4785                	li	a5,1
}
    80018396:	853e                	mv	a0,a5
    80018398:	70a2                	ld	ra,40(sp)
    8001839a:	7402                	ld	s0,32(sp)
    8001839c:	6145                	addi	sp,sp,48
    8001839e:	8082                	ret

00000000800183a0 <strendswith>:

bool strendswith(const char *src, const char *end)
{
    800183a0:	7179                	addi	sp,sp,-48
    800183a2:	f406                	sd	ra,40(sp)
    800183a4:	f022                	sd	s0,32(sp)
    800183a6:	1800                	addi	s0,sp,48
    800183a8:	fca43c23          	sd	a0,-40(s0)
    800183ac:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    800183b0:	fd843503          	ld	a0,-40(s0)
    800183b4:	e0dff0ef          	jal	ra,800181c0 <strlen>
    800183b8:	87aa                	mv	a5,a0
    800183ba:	fef42423          	sw	a5,-24(s0)
    int end_len = strlen(end);
    800183be:	fd043503          	ld	a0,-48(s0)
    800183c2:	dffff0ef          	jal	ra,800181c0 <strlen>
    800183c6:	87aa                	mv	a5,a0
    800183c8:	fef42223          	sw	a5,-28(s0)
    int cmp = src_len - end_len;
    800183cc:	fe842703          	lw	a4,-24(s0)
    800183d0:	fe442783          	lw	a5,-28(s0)
    800183d4:	40f707bb          	subw	a5,a4,a5
    800183d8:	fef42023          	sw	a5,-32(s0)
    int i;
    
    if (src_len < end_len) {
    800183dc:	fe842703          	lw	a4,-24(s0)
    800183e0:	fe442783          	lw	a5,-28(s0)
    800183e4:	2701                	sext.w	a4,a4
    800183e6:	2781                	sext.w	a5,a5
    800183e8:	00f75463          	bge	a4,a5,800183f0 <strendswith+0x50>
        return false;
    800183ec:	4781                	li	a5,0
    800183ee:	a891                	j	80018442 <strendswith+0xa2>
    }

    for (i = 0;i < end_len;i++) {
    800183f0:	fe042623          	sw	zero,-20(s0)
    800183f4:	a835                	j	80018430 <strendswith+0x90>
        if (src[i + cmp] != end[i]) {
    800183f6:	fec42703          	lw	a4,-20(s0)
    800183fa:	fe042783          	lw	a5,-32(s0)
    800183fe:	9fb9                	addw	a5,a5,a4
    80018400:	2781                	sext.w	a5,a5
    80018402:	873e                	mv	a4,a5
    80018404:	fd843783          	ld	a5,-40(s0)
    80018408:	97ba                	add	a5,a5,a4
    8001840a:	0007c683          	lbu	a3,0(a5)
    8001840e:	fec42783          	lw	a5,-20(s0)
    80018412:	fd043703          	ld	a4,-48(s0)
    80018416:	97ba                	add	a5,a5,a4
    80018418:	0007c783          	lbu	a5,0(a5)
    8001841c:	8736                	mv	a4,a3
    8001841e:	00f70463          	beq	a4,a5,80018426 <strendswith+0x86>
            return false;
    80018422:	4781                	li	a5,0
    80018424:	a839                	j	80018442 <strendswith+0xa2>
    for (i = 0;i < end_len;i++) {
    80018426:	fec42783          	lw	a5,-20(s0)
    8001842a:	2785                	addiw	a5,a5,1
    8001842c:	fef42623          	sw	a5,-20(s0)
    80018430:	fec42703          	lw	a4,-20(s0)
    80018434:	fe442783          	lw	a5,-28(s0)
    80018438:	2701                	sext.w	a4,a4
    8001843a:	2781                	sext.w	a5,a5
    8001843c:	faf74de3          	blt	a4,a5,800183f6 <strendswith+0x56>
        }
    }

    return true;    
    80018440:	4785                	li	a5,1
}
    80018442:	853e                	mv	a0,a5
    80018444:	70a2                	ld	ra,40(sp)
    80018446:	7402                	ld	s0,32(sp)
    80018448:	6145                	addi	sp,sp,48
    8001844a:	8082                	ret

000000008001844c <vector_init>:
    uint32_t size;
    uint32_t capacity;
    uint64_t *values;
} Vector;

static Vector *vector_init(Vector *vec) {
    8001844c:	1101                	addi	sp,sp,-32
    8001844e:	ec22                	sd	s0,24(sp)
    80018450:	1000                	addi	s0,sp,32
    80018452:	fea43423          	sd	a0,-24(s0)
    if (vec == NULL) {
    80018456:	fe843783          	ld	a5,-24(s0)
    8001845a:	e399                	bnez	a5,80018460 <vector_init+0x14>
        return NULL;
    8001845c:	4781                	li	a5,0
    8001845e:	a839                	j	8001847c <vector_init+0x30>
    }
    vec->size = 0;
    80018460:	fe843783          	ld	a5,-24(s0)
    80018464:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    80018468:	fe843783          	ld	a5,-24(s0)
    8001846c:	0007a223          	sw	zero,4(a5)
    vec->values = NULL;
    80018470:	fe843783          	ld	a5,-24(s0)
    80018474:	0007b423          	sd	zero,8(a5)
    return vec;
    80018478:	fe843783          	ld	a5,-24(s0)
}
    8001847c:	853e                	mv	a0,a5
    8001847e:	6462                	ld	s0,24(sp)
    80018480:	6105                	addi	sp,sp,32
    80018482:	8082                	ret

0000000080018484 <vector_new>:

Vector *vector_new(void) {
    80018484:	1141                	addi	sp,sp,-16
    80018486:	e406                	sd	ra,8(sp)
    80018488:	e022                	sd	s0,0(sp)
    8001848a:	0800                	addi	s0,sp,16
    return vector_init((Vector *)g_kmalloc(sizeof(Vector)));
    8001848c:	4541                	li	a0,16
    8001848e:	e2ffe0ef          	jal	ra,800172bc <g_kmalloc>
    80018492:	87aa                	mv	a5,a0
    80018494:	853e                	mv	a0,a5
    80018496:	fb7ff0ef          	jal	ra,8001844c <vector_init>
    8001849a:	87aa                	mv	a5,a0
}
    8001849c:	853e                	mv	a0,a5
    8001849e:	60a2                	ld	ra,8(sp)
    800184a0:	6402                	ld	s0,0(sp)
    800184a2:	0141                	addi	sp,sp,16
    800184a4:	8082                	ret

00000000800184a6 <vector_init_with_capacity>:

static Vector *vector_init_with_capacity(Vector *vec, uint32_t capacity) {
    800184a6:	1101                	addi	sp,sp,-32
    800184a8:	ec06                	sd	ra,24(sp)
    800184aa:	e822                	sd	s0,16(sp)
    800184ac:	1000                	addi	s0,sp,32
    800184ae:	fea43423          	sd	a0,-24(s0)
    800184b2:	87ae                	mv	a5,a1
    800184b4:	fef42223          	sw	a5,-28(s0)
    if (vec == NULL) {
    800184b8:	fe843783          	ld	a5,-24(s0)
    800184bc:	e399                	bnez	a5,800184c2 <vector_init_with_capacity+0x1c>
        return NULL;
    800184be:	4781                	li	a5,0
    800184c0:	a035                	j	800184ec <vector_init_with_capacity+0x46>
    }
    vec->size = 0;
    800184c2:	fe843783          	ld	a5,-24(s0)
    800184c6:	0007a023          	sw	zero,0(a5)
    vec->capacity = capacity;
    800184ca:	fe843783          	ld	a5,-24(s0)
    800184ce:	fe442703          	lw	a4,-28(s0)
    800184d2:	c3d8                	sw	a4,4(a5)
    vec->values = (uint64_t *)g_kcalloc(capacity, sizeof(uint64_t));
    800184d4:	fe446783          	lwu	a5,-28(s0)
    800184d8:	45a1                	li	a1,8
    800184da:	853e                	mv	a0,a5
    800184dc:	e19fe0ef          	jal	ra,800172f4 <g_kcalloc>
    800184e0:	872a                	mv	a4,a0
    800184e2:	fe843783          	ld	a5,-24(s0)
    800184e6:	e798                	sd	a4,8(a5)
    return vec;
    800184e8:	fe843783          	ld	a5,-24(s0)
}
    800184ec:	853e                	mv	a0,a5
    800184ee:	60e2                	ld	ra,24(sp)
    800184f0:	6442                	ld	s0,16(sp)
    800184f2:	6105                	addi	sp,sp,32
    800184f4:	8082                	ret

00000000800184f6 <vector_new_with_capacity>:

Vector *vector_new_with_capacity(uint32_t capacity) {
    800184f6:	1101                	addi	sp,sp,-32
    800184f8:	ec06                	sd	ra,24(sp)
    800184fa:	e822                	sd	s0,16(sp)
    800184fc:	1000                	addi	s0,sp,32
    800184fe:	87aa                	mv	a5,a0
    80018500:	fef42623          	sw	a5,-20(s0)
    return vector_init_with_capacity((Vector *)g_kmalloc(sizeof(Vector)), capacity);
    80018504:	4541                	li	a0,16
    80018506:	db7fe0ef          	jal	ra,800172bc <g_kmalloc>
    8001850a:	872a                	mv	a4,a0
    8001850c:	fec42783          	lw	a5,-20(s0)
    80018510:	85be                	mv	a1,a5
    80018512:	853a                	mv	a0,a4
    80018514:	f93ff0ef          	jal	ra,800184a6 <vector_init_with_capacity>
    80018518:	87aa                	mv	a5,a0
}
    8001851a:	853e                	mv	a0,a5
    8001851c:	60e2                	ld	ra,24(sp)
    8001851e:	6442                	ld	s0,16(sp)
    80018520:	6105                	addi	sp,sp,32
    80018522:	8082                	ret

0000000080018524 <vector_push>:

void vector_push(Vector *vec, uint64_t value) {
    80018524:	1101                	addi	sp,sp,-32
    80018526:	ec06                	sd	ra,24(sp)
    80018528:	e822                	sd	s0,16(sp)
    8001852a:	1000                	addi	s0,sp,32
    8001852c:	fea43423          	sd	a0,-24(s0)
    80018530:	feb43023          	sd	a1,-32(s0)
    vector_insert(vec, vec->size, value);
    80018534:	fe843783          	ld	a5,-24(s0)
    80018538:	439c                	lw	a5,0(a5)
    8001853a:	fe043603          	ld	a2,-32(s0)
    8001853e:	85be                	mv	a1,a5
    80018540:	fe843503          	ld	a0,-24(s0)
    80018544:	00e000ef          	jal	ra,80018552 <vector_insert>
}
    80018548:	0001                	nop
    8001854a:	60e2                	ld	ra,24(sp)
    8001854c:	6442                	ld	s0,16(sp)
    8001854e:	6105                	addi	sp,sp,32
    80018550:	8082                	ret

0000000080018552 <vector_insert>:

void vector_insert(Vector *vec, uint32_t idx, uint64_t value) {
    80018552:	7139                	addi	sp,sp,-64
    80018554:	fc06                	sd	ra,56(sp)
    80018556:	f822                	sd	s0,48(sp)
    80018558:	0080                	addi	s0,sp,64
    8001855a:	fca43c23          	sd	a0,-40(s0)
    8001855e:	87ae                	mv	a5,a1
    80018560:	fcc43423          	sd	a2,-56(s0)
    80018564:	fcf42a23          	sw	a5,-44(s0)
    uint32_t i;
    vector_resize(vec, vec->size + 1);
    80018568:	fd843783          	ld	a5,-40(s0)
    8001856c:	439c                	lw	a5,0(a5)
    8001856e:	2785                	addiw	a5,a5,1
    80018570:	2781                	sext.w	a5,a5
    80018572:	85be                	mv	a1,a5
    80018574:	fd843503          	ld	a0,-40(s0)
    80018578:	214000ef          	jal	ra,8001878c <vector_resize>
    for (i = vec->size - 1;i > idx;i--) {
    8001857c:	fd843783          	ld	a5,-40(s0)
    80018580:	439c                	lw	a5,0(a5)
    80018582:	37fd                	addiw	a5,a5,-1
    80018584:	fef42623          	sw	a5,-20(s0)
    80018588:	a805                	j	800185b8 <vector_insert+0x66>
        vector_set(vec, i, vector_get_unchecked(vec, i - 1));
    8001858a:	fec42783          	lw	a5,-20(s0)
    8001858e:	37fd                	addiw	a5,a5,-1
    80018590:	2781                	sext.w	a5,a5
    80018592:	85be                	mv	a1,a5
    80018594:	fd843503          	ld	a0,-40(s0)
    80018598:	13a000ef          	jal	ra,800186d2 <vector_get_unchecked>
    8001859c:	872a                	mv	a4,a0
    8001859e:	fec42783          	lw	a5,-20(s0)
    800185a2:	863a                	mv	a2,a4
    800185a4:	85be                	mv	a1,a5
    800185a6:	fd843503          	ld	a0,-40(s0)
    800185aa:	094000ef          	jal	ra,8001863e <vector_set>
    for (i = vec->size - 1;i > idx;i--) {
    800185ae:	fec42783          	lw	a5,-20(s0)
    800185b2:	37fd                	addiw	a5,a5,-1
    800185b4:	fef42623          	sw	a5,-20(s0)
    800185b8:	fec42703          	lw	a4,-20(s0)
    800185bc:	fd442783          	lw	a5,-44(s0)
    800185c0:	2701                	sext.w	a4,a4
    800185c2:	2781                	sext.w	a5,a5
    800185c4:	fce7e3e3          	bltu	a5,a4,8001858a <vector_insert+0x38>
    }
    vector_set(vec, idx, value);
    800185c8:	fd442783          	lw	a5,-44(s0)
    800185cc:	fc843603          	ld	a2,-56(s0)
    800185d0:	85be                	mv	a1,a5
    800185d2:	fd843503          	ld	a0,-40(s0)
    800185d6:	068000ef          	jal	ra,8001863e <vector_set>
}
    800185da:	0001                	nop
    800185dc:	70e2                	ld	ra,56(sp)
    800185de:	7442                	ld	s0,48(sp)
    800185e0:	6121                	addi	sp,sp,64
    800185e2:	8082                	ret

00000000800185e4 <vector_find>:

int vector_find(Vector *vec, uint64_t val) {
    800185e4:	7179                	addi	sp,sp,-48
    800185e6:	f422                	sd	s0,40(sp)
    800185e8:	1800                	addi	s0,sp,48
    800185ea:	fca43c23          	sd	a0,-40(s0)
    800185ee:	fcb43823          	sd	a1,-48(s0)
    int i;
    for (i = 0;i < (int)vec->size;i++) {
    800185f2:	fe042623          	sw	zero,-20(s0)
    800185f6:	a02d                	j	80018620 <vector_find+0x3c>
        if (vec->values[i] == val) {
    800185f8:	fd843783          	ld	a5,-40(s0)
    800185fc:	6798                	ld	a4,8(a5)
    800185fe:	fec42783          	lw	a5,-20(s0)
    80018602:	078e                	slli	a5,a5,0x3
    80018604:	97ba                	add	a5,a5,a4
    80018606:	639c                	ld	a5,0(a5)
    80018608:	fd043703          	ld	a4,-48(s0)
    8001860c:	00f71563          	bne	a4,a5,80018616 <vector_find+0x32>
            return i;
    80018610:	fec42783          	lw	a5,-20(s0)
    80018614:	a00d                	j	80018636 <vector_find+0x52>
    for (i = 0;i < (int)vec->size;i++) {
    80018616:	fec42783          	lw	a5,-20(s0)
    8001861a:	2785                	addiw	a5,a5,1
    8001861c:	fef42623          	sw	a5,-20(s0)
    80018620:	fd843783          	ld	a5,-40(s0)
    80018624:	439c                	lw	a5,0(a5)
    80018626:	0007871b          	sext.w	a4,a5
    8001862a:	fec42783          	lw	a5,-20(s0)
    8001862e:	2781                	sext.w	a5,a5
    80018630:	fce7c4e3          	blt	a5,a4,800185f8 <vector_find+0x14>
        }
    }
    return -1;
    80018634:	57fd                	li	a5,-1
}
    80018636:	853e                	mv	a0,a5
    80018638:	7422                	ld	s0,40(sp)
    8001863a:	6145                	addi	sp,sp,48
    8001863c:	8082                	ret

000000008001863e <vector_set>:

bool vector_set(Vector *vec, uint32_t idx, uint64_t val) {
    8001863e:	7179                	addi	sp,sp,-48
    80018640:	f422                	sd	s0,40(sp)
    80018642:	1800                	addi	s0,sp,48
    80018644:	fea43423          	sd	a0,-24(s0)
    80018648:	87ae                	mv	a5,a1
    8001864a:	fcc43c23          	sd	a2,-40(s0)
    8001864e:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80018652:	fe843783          	ld	a5,-24(s0)
    80018656:	4398                	lw	a4,0(a5)
    80018658:	fe442783          	lw	a5,-28(s0)
    8001865c:	2781                	sext.w	a5,a5
    8001865e:	00e7e463          	bltu	a5,a4,80018666 <vector_set+0x28>
        return false;
    80018662:	4781                	li	a5,0
    80018664:	a821                	j	8001867c <vector_set+0x3e>
    }
    vec->values[idx] = val;
    80018666:	fe843783          	ld	a5,-24(s0)
    8001866a:	6798                	ld	a4,8(a5)
    8001866c:	fe446783          	lwu	a5,-28(s0)
    80018670:	078e                	slli	a5,a5,0x3
    80018672:	97ba                	add	a5,a5,a4
    80018674:	fd843703          	ld	a4,-40(s0)
    80018678:	e398                	sd	a4,0(a5)
    return true;
    8001867a:	4785                	li	a5,1
}
    8001867c:	853e                	mv	a0,a5
    8001867e:	7422                	ld	s0,40(sp)
    80018680:	6145                	addi	sp,sp,48
    80018682:	8082                	ret

0000000080018684 <vector_get>:

bool vector_get(Vector *vec, uint32_t idx, uint64_t *val) {
    80018684:	7179                	addi	sp,sp,-48
    80018686:	f422                	sd	s0,40(sp)
    80018688:	1800                	addi	s0,sp,48
    8001868a:	fea43423          	sd	a0,-24(s0)
    8001868e:	87ae                	mv	a5,a1
    80018690:	fcc43c23          	sd	a2,-40(s0)
    80018694:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80018698:	fe843783          	ld	a5,-24(s0)
    8001869c:	4398                	lw	a4,0(a5)
    8001869e:	fe442783          	lw	a5,-28(s0)
    800186a2:	2781                	sext.w	a5,a5
    800186a4:	00e7e463          	bltu	a5,a4,800186ac <vector_get+0x28>
        return false;
    800186a8:	4781                	li	a5,0
    800186aa:	a005                	j	800186ca <vector_get+0x46>
    }
    if (val != NULL) {
    800186ac:	fd843783          	ld	a5,-40(s0)
    800186b0:	cf81                	beqz	a5,800186c8 <vector_get+0x44>
        *val = vec->values[idx];
    800186b2:	fe843783          	ld	a5,-24(s0)
    800186b6:	6798                	ld	a4,8(a5)
    800186b8:	fe446783          	lwu	a5,-28(s0)
    800186bc:	078e                	slli	a5,a5,0x3
    800186be:	97ba                	add	a5,a5,a4
    800186c0:	6398                	ld	a4,0(a5)
    800186c2:	fd843783          	ld	a5,-40(s0)
    800186c6:	e398                	sd	a4,0(a5)
    }
    return true;
    800186c8:	4785                	li	a5,1
}
    800186ca:	853e                	mv	a0,a5
    800186cc:	7422                	ld	s0,40(sp)
    800186ce:	6145                	addi	sp,sp,48
    800186d0:	8082                	ret

00000000800186d2 <vector_get_unchecked>:

uint64_t vector_get_unchecked(Vector *vec, uint32_t idx) {
    800186d2:	1101                	addi	sp,sp,-32
    800186d4:	ec22                	sd	s0,24(sp)
    800186d6:	1000                	addi	s0,sp,32
    800186d8:	fea43423          	sd	a0,-24(s0)
    800186dc:	87ae                	mv	a5,a1
    800186de:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    800186e2:	fe843783          	ld	a5,-24(s0)
    800186e6:	4398                	lw	a4,0(a5)
    800186e8:	fe442783          	lw	a5,-28(s0)
    800186ec:	2781                	sext.w	a5,a5
    800186ee:	00e7e463          	bltu	a5,a4,800186f6 <vector_get_unchecked+0x24>
        return 0;
    800186f2:	4781                	li	a5,0
    800186f4:	a809                	j	80018706 <vector_get_unchecked+0x34>
    }
    return vec->values[idx];
    800186f6:	fe843783          	ld	a5,-24(s0)
    800186fa:	6798                	ld	a4,8(a5)
    800186fc:	fe446783          	lwu	a5,-28(s0)
    80018700:	078e                	slli	a5,a5,0x3
    80018702:	97ba                	add	a5,a5,a4
    80018704:	639c                	ld	a5,0(a5)
}
    80018706:	853e                	mv	a0,a5
    80018708:	6462                	ld	s0,24(sp)
    8001870a:	6105                	addi	sp,sp,32
    8001870c:	8082                	ret

000000008001870e <vector_resize_with_default>:


void vector_resize_with_default(Vector *vec, uint32_t new_size, uint64_t def) {
    8001870e:	7139                	addi	sp,sp,-64
    80018710:	fc06                	sd	ra,56(sp)
    80018712:	f822                	sd	s0,48(sp)
    80018714:	0080                	addi	s0,sp,64
    80018716:	fca43c23          	sd	a0,-40(s0)
    8001871a:	87ae                	mv	a5,a1
    8001871c:	fcc43423          	sd	a2,-56(s0)
    80018720:	fcf42a23          	sw	a5,-44(s0)
    uint32_t old_size = vec->size;
    80018724:	fd843783          	ld	a5,-40(s0)
    80018728:	439c                	lw	a5,0(a5)
    8001872a:	fef42423          	sw	a5,-24(s0)
    vector_resize(vec, new_size);
    8001872e:	fd442783          	lw	a5,-44(s0)
    80018732:	85be                	mv	a1,a5
    80018734:	fd843503          	ld	a0,-40(s0)
    80018738:	054000ef          	jal	ra,8001878c <vector_resize>
    if (old_size < new_size) {
    8001873c:	fe842703          	lw	a4,-24(s0)
    80018740:	fd442783          	lw	a5,-44(s0)
    80018744:	2701                	sext.w	a4,a4
    80018746:	2781                	sext.w	a5,a5
    80018748:	02f77d63          	bgeu	a4,a5,80018782 <vector_resize_with_default+0x74>
        uint32_t i;
        for (i = old_size;i < new_size;i++) {
    8001874c:	fe842783          	lw	a5,-24(s0)
    80018750:	fef42623          	sw	a5,-20(s0)
    80018754:	a839                	j	80018772 <vector_resize_with_default+0x64>
            vector_set(vec, i, def);
    80018756:	fec42783          	lw	a5,-20(s0)
    8001875a:	fc843603          	ld	a2,-56(s0)
    8001875e:	85be                	mv	a1,a5
    80018760:	fd843503          	ld	a0,-40(s0)
    80018764:	edbff0ef          	jal	ra,8001863e <vector_set>
        for (i = old_size;i < new_size;i++) {
    80018768:	fec42783          	lw	a5,-20(s0)
    8001876c:	2785                	addiw	a5,a5,1
    8001876e:	fef42623          	sw	a5,-20(s0)
    80018772:	fec42703          	lw	a4,-20(s0)
    80018776:	fd442783          	lw	a5,-44(s0)
    8001877a:	2701                	sext.w	a4,a4
    8001877c:	2781                	sext.w	a5,a5
    8001877e:	fcf76ce3          	bltu	a4,a5,80018756 <vector_resize_with_default+0x48>
        }
    }
}
    80018782:	0001                	nop
    80018784:	70e2                	ld	ra,56(sp)
    80018786:	7442                	ld	s0,48(sp)
    80018788:	6121                	addi	sp,sp,64
    8001878a:	8082                	ret

000000008001878c <vector_resize>:

void vector_resize(Vector *vec, uint32_t new_size) {
    8001878c:	7179                	addi	sp,sp,-48
    8001878e:	f406                	sd	ra,40(sp)
    80018790:	f022                	sd	s0,32(sp)
    80018792:	1800                	addi	s0,sp,48
    80018794:	fca43c23          	sd	a0,-40(s0)
    80018798:	87ae                	mv	a5,a1
    8001879a:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_size > vec->capacity) {
    8001879e:	fd843783          	ld	a5,-40(s0)
    800187a2:	43d8                	lw	a4,4(a5)
    800187a4:	fd442783          	lw	a5,-44(s0)
    800187a8:	2781                	sext.w	a5,a5
    800187aa:	06f77963          	bgeu	a4,a5,8001881c <vector_resize+0x90>
        vals = (uint64_t *)g_kcalloc(new_size, sizeof(uint64_t));
    800187ae:	fd446783          	lwu	a5,-44(s0)
    800187b2:	45a1                	li	a1,8
    800187b4:	853e                	mv	a0,a5
    800187b6:	b3ffe0ef          	jal	ra,800172f4 <g_kcalloc>
    800187ba:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    800187be:	fe042623          	sw	zero,-20(s0)
    800187c2:	a02d                	j	800187ec <vector_resize+0x60>
            vals[i] = vec->values[i];
    800187c4:	fd843783          	ld	a5,-40(s0)
    800187c8:	6798                	ld	a4,8(a5)
    800187ca:	fec46783          	lwu	a5,-20(s0)
    800187ce:	078e                	slli	a5,a5,0x3
    800187d0:	973e                	add	a4,a4,a5
    800187d2:	fec46783          	lwu	a5,-20(s0)
    800187d6:	078e                	slli	a5,a5,0x3
    800187d8:	fe043683          	ld	a3,-32(s0)
    800187dc:	97b6                	add	a5,a5,a3
    800187de:	6318                	ld	a4,0(a4)
    800187e0:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    800187e2:	fec42783          	lw	a5,-20(s0)
    800187e6:	2785                	addiw	a5,a5,1
    800187e8:	fef42623          	sw	a5,-20(s0)
    800187ec:	fd843783          	ld	a5,-40(s0)
    800187f0:	4398                	lw	a4,0(a5)
    800187f2:	fec42783          	lw	a5,-20(s0)
    800187f6:	2781                	sext.w	a5,a5
    800187f8:	fce7e6e3          	bltu	a5,a4,800187c4 <vector_resize+0x38>
        }
        g_kfree(vec->values);
    800187fc:	fd843783          	ld	a5,-40(s0)
    80018800:	679c                	ld	a5,8(a5)
    80018802:	853e                	mv	a0,a5
    80018804:	b53fe0ef          	jal	ra,80017356 <g_kfree>
        vec->values = vals;
    80018808:	fd843783          	ld	a5,-40(s0)
    8001880c:	fe043703          	ld	a4,-32(s0)
    80018810:	e798                	sd	a4,8(a5)
        vec->capacity = new_size;
    80018812:	fd843783          	ld	a5,-40(s0)
    80018816:	fd442703          	lw	a4,-44(s0)
    8001881a:	c3d8                	sw	a4,4(a5)
    }        
    vec->size = new_size;    
    8001881c:	fd843783          	ld	a5,-40(s0)
    80018820:	fd442703          	lw	a4,-44(s0)
    80018824:	c398                	sw	a4,0(a5)
}
    80018826:	0001                	nop
    80018828:	70a2                	ld	ra,40(sp)
    8001882a:	7402                	ld	s0,32(sp)
    8001882c:	6145                	addi	sp,sp,48
    8001882e:	8082                	ret

0000000080018830 <vector_reserve>:

void vector_reserve(Vector *vec, uint32_t new_capacity) {
    80018830:	7179                	addi	sp,sp,-48
    80018832:	f406                	sd	ra,40(sp)
    80018834:	f022                	sd	s0,32(sp)
    80018836:	1800                	addi	s0,sp,48
    80018838:	fca43c23          	sd	a0,-40(s0)
    8001883c:	87ae                	mv	a5,a1
    8001883e:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_capacity > vec->capacity) {
    80018842:	fd843783          	ld	a5,-40(s0)
    80018846:	43d8                	lw	a4,4(a5)
    80018848:	fd442783          	lw	a5,-44(s0)
    8001884c:	2781                	sext.w	a5,a5
    8001884e:	06f77a63          	bgeu	a4,a5,800188c2 <vector_reserve+0x92>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    80018852:	fd446783          	lwu	a5,-44(s0)
    80018856:	45a1                	li	a1,8
    80018858:	853e                	mv	a0,a5
    8001885a:	a9bfe0ef          	jal	ra,800172f4 <g_kcalloc>
    8001885e:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    80018862:	fe042623          	sw	zero,-20(s0)
    80018866:	a02d                	j	80018890 <vector_reserve+0x60>
            vals[i] = vec->values[i];
    80018868:	fd843783          	ld	a5,-40(s0)
    8001886c:	6798                	ld	a4,8(a5)
    8001886e:	fec46783          	lwu	a5,-20(s0)
    80018872:	078e                	slli	a5,a5,0x3
    80018874:	973e                	add	a4,a4,a5
    80018876:	fec46783          	lwu	a5,-20(s0)
    8001887a:	078e                	slli	a5,a5,0x3
    8001887c:	fe043683          	ld	a3,-32(s0)
    80018880:	97b6                	add	a5,a5,a3
    80018882:	6318                	ld	a4,0(a4)
    80018884:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80018886:	fec42783          	lw	a5,-20(s0)
    8001888a:	2785                	addiw	a5,a5,1
    8001888c:	fef42623          	sw	a5,-20(s0)
    80018890:	fd843783          	ld	a5,-40(s0)
    80018894:	4398                	lw	a4,0(a5)
    80018896:	fec42783          	lw	a5,-20(s0)
    8001889a:	2781                	sext.w	a5,a5
    8001889c:	fce7e6e3          	bltu	a5,a4,80018868 <vector_reserve+0x38>
        }
        g_kfree(vec->values);
    800188a0:	fd843783          	ld	a5,-40(s0)
    800188a4:	679c                	ld	a5,8(a5)
    800188a6:	853e                	mv	a0,a5
    800188a8:	aaffe0ef          	jal	ra,80017356 <g_kfree>
        vec->values = vals;
    800188ac:	fd843783          	ld	a5,-40(s0)
    800188b0:	fe043703          	ld	a4,-32(s0)
    800188b4:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    800188b6:	fd843783          	ld	a5,-40(s0)
    800188ba:	fd442703          	lw	a4,-44(s0)
    800188be:	c3d8                	sw	a4,4(a5)
        }
        g_kfree(vec->values);
        vec->values = vals;
        vec->capacity = new_capacity;
    }
}
    800188c0:	a04d                	j	80018962 <vector_reserve+0x132>
    else if (new_capacity > 0 && new_capacity < vec->capacity) {
    800188c2:	fd442783          	lw	a5,-44(s0)
    800188c6:	2781                	sext.w	a5,a5
    800188c8:	cfc9                	beqz	a5,80018962 <vector_reserve+0x132>
    800188ca:	fd843783          	ld	a5,-40(s0)
    800188ce:	43d8                	lw	a4,4(a5)
    800188d0:	fd442783          	lw	a5,-44(s0)
    800188d4:	2781                	sext.w	a5,a5
    800188d6:	08e7f663          	bgeu	a5,a4,80018962 <vector_reserve+0x132>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    800188da:	fd446783          	lwu	a5,-44(s0)
    800188de:	45a1                	li	a1,8
    800188e0:	853e                	mv	a0,a5
    800188e2:	a13fe0ef          	jal	ra,800172f4 <g_kcalloc>
    800188e6:	fea43023          	sd	a0,-32(s0)
        if (new_capacity < vec->size) {
    800188ea:	fd843783          	ld	a5,-40(s0)
    800188ee:	4398                	lw	a4,0(a5)
    800188f0:	fd442783          	lw	a5,-44(s0)
    800188f4:	2781                	sext.w	a5,a5
    800188f6:	00e7f763          	bgeu	a5,a4,80018904 <vector_reserve+0xd4>
            vec->size = new_capacity;
    800188fa:	fd843783          	ld	a5,-40(s0)
    800188fe:	fd442703          	lw	a4,-44(s0)
    80018902:	c398                	sw	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80018904:	fe042623          	sw	zero,-20(s0)
    80018908:	a02d                	j	80018932 <vector_reserve+0x102>
            vals[i] = vec->values[i];
    8001890a:	fd843783          	ld	a5,-40(s0)
    8001890e:	6798                	ld	a4,8(a5)
    80018910:	fec46783          	lwu	a5,-20(s0)
    80018914:	078e                	slli	a5,a5,0x3
    80018916:	973e                	add	a4,a4,a5
    80018918:	fec46783          	lwu	a5,-20(s0)
    8001891c:	078e                	slli	a5,a5,0x3
    8001891e:	fe043683          	ld	a3,-32(s0)
    80018922:	97b6                	add	a5,a5,a3
    80018924:	6318                	ld	a4,0(a4)
    80018926:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80018928:	fec42783          	lw	a5,-20(s0)
    8001892c:	2785                	addiw	a5,a5,1
    8001892e:	fef42623          	sw	a5,-20(s0)
    80018932:	fd843783          	ld	a5,-40(s0)
    80018936:	4398                	lw	a4,0(a5)
    80018938:	fec42783          	lw	a5,-20(s0)
    8001893c:	2781                	sext.w	a5,a5
    8001893e:	fce7e6e3          	bltu	a5,a4,8001890a <vector_reserve+0xda>
        g_kfree(vec->values);
    80018942:	fd843783          	ld	a5,-40(s0)
    80018946:	679c                	ld	a5,8(a5)
    80018948:	853e                	mv	a0,a5
    8001894a:	a0dfe0ef          	jal	ra,80017356 <g_kfree>
        vec->values = vals;
    8001894e:	fd843783          	ld	a5,-40(s0)
    80018952:	fe043703          	ld	a4,-32(s0)
    80018956:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    80018958:	fd843783          	ld	a5,-40(s0)
    8001895c:	fd442703          	lw	a4,-44(s0)
    80018960:	c3d8                	sw	a4,4(a5)
}
    80018962:	0001                	nop
    80018964:	70a2                	ld	ra,40(sp)
    80018966:	7402                	ld	s0,32(sp)
    80018968:	6145                	addi	sp,sp,48
    8001896a:	8082                	ret

000000008001896c <vector_remove>:

bool vector_remove(Vector *vec, uint32_t idx) {
    8001896c:	1101                	addi	sp,sp,-32
    8001896e:	ec22                	sd	s0,24(sp)
    80018970:	1000                	addi	s0,sp,32
    80018972:	fea43423          	sd	a0,-24(s0)
    80018976:	87ae                	mv	a5,a1
    80018978:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    8001897c:	fe843783          	ld	a5,-24(s0)
    80018980:	4398                	lw	a4,0(a5)
    80018982:	fe442783          	lw	a5,-28(s0)
    80018986:	2781                	sext.w	a5,a5
    80018988:	00e7e463          	bltu	a5,a4,80018990 <vector_remove+0x24>
        return false;
    8001898c:	4781                	li	a5,0
    8001898e:	a8a9                	j	800189e8 <vector_remove+0x7c>
    }
    vec->size -= 1;
    80018990:	fe843783          	ld	a5,-24(s0)
    80018994:	439c                	lw	a5,0(a5)
    80018996:	37fd                	addiw	a5,a5,-1
    80018998:	0007871b          	sext.w	a4,a5
    8001899c:	fe843783          	ld	a5,-24(s0)
    800189a0:	c398                	sw	a4,0(a5)
    for (;idx < vec->size;idx++) {
    800189a2:	a815                	j	800189d6 <vector_remove+0x6a>
        vec->values[idx] = vec->values[idx + 1];
    800189a4:	fe843783          	ld	a5,-24(s0)
    800189a8:	6798                	ld	a4,8(a5)
    800189aa:	fe442783          	lw	a5,-28(s0)
    800189ae:	2785                	addiw	a5,a5,1
    800189b0:	2781                	sext.w	a5,a5
    800189b2:	1782                	slli	a5,a5,0x20
    800189b4:	9381                	srli	a5,a5,0x20
    800189b6:	078e                	slli	a5,a5,0x3
    800189b8:	973e                	add	a4,a4,a5
    800189ba:	fe843783          	ld	a5,-24(s0)
    800189be:	6794                	ld	a3,8(a5)
    800189c0:	fe446783          	lwu	a5,-28(s0)
    800189c4:	078e                	slli	a5,a5,0x3
    800189c6:	97b6                	add	a5,a5,a3
    800189c8:	6318                	ld	a4,0(a4)
    800189ca:	e398                	sd	a4,0(a5)
    for (;idx < vec->size;idx++) {
    800189cc:	fe442783          	lw	a5,-28(s0)
    800189d0:	2785                	addiw	a5,a5,1
    800189d2:	fef42223          	sw	a5,-28(s0)
    800189d6:	fe843783          	ld	a5,-24(s0)
    800189da:	4398                	lw	a4,0(a5)
    800189dc:	fe442783          	lw	a5,-28(s0)
    800189e0:	2781                	sext.w	a5,a5
    800189e2:	fce7e1e3          	bltu	a5,a4,800189a4 <vector_remove+0x38>
    }
    return true;
    800189e6:	4785                	li	a5,1
}
    800189e8:	853e                	mv	a0,a5
    800189ea:	6462                	ld	s0,24(sp)
    800189ec:	6105                	addi	sp,sp,32
    800189ee:	8082                	ret

00000000800189f0 <vector_remove_value>:

bool vector_remove_value(Vector *vec, uint64_t val) {
    800189f0:	7179                	addi	sp,sp,-48
    800189f2:	f406                	sd	ra,40(sp)
    800189f4:	f022                	sd	s0,32(sp)
    800189f6:	1800                	addi	s0,sp,48
    800189f8:	fca43c23          	sd	a0,-40(s0)
    800189fc:	fcb43823          	sd	a1,-48(s0)
    uint32_t i;
    for (i = 0;i < vec->size;i++) {
    80018a00:	fe042623          	sw	zero,-20(s0)
    80018a04:	a81d                	j	80018a3a <vector_remove_value+0x4a>
        if (vec->values[i] == val) {
    80018a06:	fd843783          	ld	a5,-40(s0)
    80018a0a:	6798                	ld	a4,8(a5)
    80018a0c:	fec46783          	lwu	a5,-20(s0)
    80018a10:	078e                	slli	a5,a5,0x3
    80018a12:	97ba                	add	a5,a5,a4
    80018a14:	639c                	ld	a5,0(a5)
    80018a16:	fd043703          	ld	a4,-48(s0)
    80018a1a:	00f71b63          	bne	a4,a5,80018a30 <vector_remove_value+0x40>
            vector_remove(vec, i);
    80018a1e:	fec42783          	lw	a5,-20(s0)
    80018a22:	85be                	mv	a1,a5
    80018a24:	fd843503          	ld	a0,-40(s0)
    80018a28:	f45ff0ef          	jal	ra,8001896c <vector_remove>
            return true;
    80018a2c:	4785                	li	a5,1
    80018a2e:	a839                	j	80018a4c <vector_remove_value+0x5c>
    for (i = 0;i < vec->size;i++) {
    80018a30:	fec42783          	lw	a5,-20(s0)
    80018a34:	2785                	addiw	a5,a5,1
    80018a36:	fef42623          	sw	a5,-20(s0)
    80018a3a:	fd843783          	ld	a5,-40(s0)
    80018a3e:	4398                	lw	a4,0(a5)
    80018a40:	fec42783          	lw	a5,-20(s0)
    80018a44:	2781                	sext.w	a5,a5
    80018a46:	fce7e0e3          	bltu	a5,a4,80018a06 <vector_remove_value+0x16>
        }
    }
    return false;
    80018a4a:	4781                	li	a5,0
}
    80018a4c:	853e                	mv	a0,a5
    80018a4e:	70a2                	ld	ra,40(sp)
    80018a50:	7402                	ld	s0,32(sp)
    80018a52:	6145                	addi	sp,sp,48
    80018a54:	8082                	ret

0000000080018a56 <vector_clear>:

void vector_clear(Vector *vec) {
    80018a56:	1101                	addi	sp,sp,-32
    80018a58:	ec06                	sd	ra,24(sp)
    80018a5a:	e822                	sd	s0,16(sp)
    80018a5c:	1000                	addi	s0,sp,32
    80018a5e:	fea43423          	sd	a0,-24(s0)
    vector_resize(vec, 0);
    80018a62:	4581                	li	a1,0
    80018a64:	fe843503          	ld	a0,-24(s0)
    80018a68:	d25ff0ef          	jal	ra,8001878c <vector_resize>
}
    80018a6c:	0001                	nop
    80018a6e:	60e2                	ld	ra,24(sp)
    80018a70:	6442                	ld	s0,16(sp)
    80018a72:	6105                	addi	sp,sp,32
    80018a74:	8082                	ret

0000000080018a76 <vector_binsearch_ascending>:

int vector_binsearch_ascending(struct Vector *vec, uint64_t key) {
    80018a76:	7179                	addi	sp,sp,-48
    80018a78:	f406                	sd	ra,40(sp)
    80018a7a:	f022                	sd	s0,32(sp)
    80018a7c:	1800                	addi	s0,sp,48
    80018a7e:	fca43c23          	sd	a0,-40(s0)
    80018a82:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    80018a86:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec);
    80018a8a:	fd843503          	ld	a0,-40(s0)
    80018a8e:	356000ef          	jal	ra,80018de4 <vector_size>
    80018a92:	87aa                	mv	a5,a0
    80018a94:	2781                	sext.w	a5,a5
    80018a96:	fef42423          	sw	a5,-24(s0)

    while (low < high) {
    80018a9a:	a0ad                	j	80018b04 <vector_binsearch_ascending+0x8e>
        int mid = (low + high) / 2;
    80018a9c:	fec42703          	lw	a4,-20(s0)
    80018aa0:	fe842783          	lw	a5,-24(s0)
    80018aa4:	9fb9                	addw	a5,a5,a4
    80018aa6:	2781                	sext.w	a5,a5
    80018aa8:	01f7d71b          	srliw	a4,a5,0x1f
    80018aac:	9fb9                	addw	a5,a5,a4
    80018aae:	4017d79b          	sraiw	a5,a5,0x1
    80018ab2:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) > key) {
    80018ab6:	fe442783          	lw	a5,-28(s0)
    80018aba:	85be                	mv	a1,a5
    80018abc:	fd843503          	ld	a0,-40(s0)
    80018ac0:	c13ff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018ac4:	872a                	mv	a4,a0
    80018ac6:	fd043783          	ld	a5,-48(s0)
    80018aca:	00e7f863          	bgeu	a5,a4,80018ada <vector_binsearch_ascending+0x64>
            high = mid - 1;
    80018ace:	fe442783          	lw	a5,-28(s0)
    80018ad2:	37fd                	addiw	a5,a5,-1
    80018ad4:	fef42423          	sw	a5,-24(s0)
    80018ad8:	a035                	j	80018b04 <vector_binsearch_ascending+0x8e>
        }
        else if (vector_get_unchecked(vec, mid) < key) {
    80018ada:	fe442783          	lw	a5,-28(s0)
    80018ade:	85be                	mv	a1,a5
    80018ae0:	fd843503          	ld	a0,-40(s0)
    80018ae4:	befff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018ae8:	872a                	mv	a4,a0
    80018aea:	fd043783          	ld	a5,-48(s0)
    80018aee:	00f77863          	bgeu	a4,a5,80018afe <vector_binsearch_ascending+0x88>
            low = mid + 1;
    80018af2:	fe442783          	lw	a5,-28(s0)
    80018af6:	2785                	addiw	a5,a5,1
    80018af8:	fef42623          	sw	a5,-20(s0)
    80018afc:	a021                	j	80018b04 <vector_binsearch_ascending+0x8e>
        }
        else {
            return mid;
    80018afe:	fe442783          	lw	a5,-28(s0)
    80018b02:	a811                	j	80018b16 <vector_binsearch_ascending+0xa0>
    while (low < high) {
    80018b04:	fec42703          	lw	a4,-20(s0)
    80018b08:	fe842783          	lw	a5,-24(s0)
    80018b0c:	2701                	sext.w	a4,a4
    80018b0e:	2781                	sext.w	a5,a5
    80018b10:	f8f746e3          	blt	a4,a5,80018a9c <vector_binsearch_ascending+0x26>
        }
    }
    return -1;
    80018b14:	57fd                	li	a5,-1
}
    80018b16:	853e                	mv	a0,a5
    80018b18:	70a2                	ld	ra,40(sp)
    80018b1a:	7402                	ld	s0,32(sp)
    80018b1c:	6145                	addi	sp,sp,48
    80018b1e:	8082                	ret

0000000080018b20 <vector_binsearch_descending>:

int vector_binsearch_descending(struct Vector *vec, uint64_t key) {
    80018b20:	7179                	addi	sp,sp,-48
    80018b22:	f406                	sd	ra,40(sp)
    80018b24:	f022                	sd	s0,32(sp)
    80018b26:	1800                	addi	s0,sp,48
    80018b28:	fca43c23          	sd	a0,-40(s0)
    80018b2c:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    80018b30:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec) - 1;
    80018b34:	fd843503          	ld	a0,-40(s0)
    80018b38:	2ac000ef          	jal	ra,80018de4 <vector_size>
    80018b3c:	87aa                	mv	a5,a0
    80018b3e:	2781                	sext.w	a5,a5
    80018b40:	37fd                	addiw	a5,a5,-1
    80018b42:	2781                	sext.w	a5,a5
    80018b44:	fef42423          	sw	a5,-24(s0)

    while (low <= high) {
    80018b48:	a0ad                	j	80018bb2 <vector_binsearch_descending+0x92>
        int mid = (low + high) / 2;
    80018b4a:	fec42703          	lw	a4,-20(s0)
    80018b4e:	fe842783          	lw	a5,-24(s0)
    80018b52:	9fb9                	addw	a5,a5,a4
    80018b54:	2781                	sext.w	a5,a5
    80018b56:	01f7d71b          	srliw	a4,a5,0x1f
    80018b5a:	9fb9                	addw	a5,a5,a4
    80018b5c:	4017d79b          	sraiw	a5,a5,0x1
    80018b60:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) < key) {
    80018b64:	fe442783          	lw	a5,-28(s0)
    80018b68:	85be                	mv	a1,a5
    80018b6a:	fd843503          	ld	a0,-40(s0)
    80018b6e:	b65ff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018b72:	872a                	mv	a4,a0
    80018b74:	fd043783          	ld	a5,-48(s0)
    80018b78:	00f77863          	bgeu	a4,a5,80018b88 <vector_binsearch_descending+0x68>
            high = mid - 1;
    80018b7c:	fe442783          	lw	a5,-28(s0)
    80018b80:	37fd                	addiw	a5,a5,-1
    80018b82:	fef42423          	sw	a5,-24(s0)
    80018b86:	a035                	j	80018bb2 <vector_binsearch_descending+0x92>
        }
        else if (vector_get_unchecked(vec, mid) > key) {
    80018b88:	fe442783          	lw	a5,-28(s0)
    80018b8c:	85be                	mv	a1,a5
    80018b8e:	fd843503          	ld	a0,-40(s0)
    80018b92:	b41ff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018b96:	872a                	mv	a4,a0
    80018b98:	fd043783          	ld	a5,-48(s0)
    80018b9c:	00e7f863          	bgeu	a5,a4,80018bac <vector_binsearch_descending+0x8c>
            low = mid + 1;
    80018ba0:	fe442783          	lw	a5,-28(s0)
    80018ba4:	2785                	addiw	a5,a5,1
    80018ba6:	fef42623          	sw	a5,-20(s0)
    80018baa:	a021                	j	80018bb2 <vector_binsearch_descending+0x92>
        }
        else {
            return mid;
    80018bac:	fe442783          	lw	a5,-28(s0)
    80018bb0:	a811                	j	80018bc4 <vector_binsearch_descending+0xa4>
    while (low <= high) {
    80018bb2:	fec42703          	lw	a4,-20(s0)
    80018bb6:	fe842783          	lw	a5,-24(s0)
    80018bba:	2701                	sext.w	a4,a4
    80018bbc:	2781                	sext.w	a5,a5
    80018bbe:	f8e7d6e3          	bge	a5,a4,80018b4a <vector_binsearch_descending+0x2a>
        }
    }
    return -1;
    80018bc2:	57fd                	li	a5,-1
}
    80018bc4:	853e                	mv	a0,a5
    80018bc6:	70a2                	ld	ra,40(sp)
    80018bc8:	7402                	ld	s0,32(sp)
    80018bca:	6145                	addi	sp,sp,48
    80018bcc:	8082                	ret

0000000080018bce <vector_sort>:

void vector_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80018bce:	1101                	addi	sp,sp,-32
    80018bd0:	ec06                	sd	ra,24(sp)
    80018bd2:	e822                	sd	s0,16(sp)
    80018bd4:	1000                	addi	s0,sp,32
    80018bd6:	fea43423          	sd	a0,-24(s0)
    80018bda:	feb43023          	sd	a1,-32(s0)
    vector_insertion_sort(vec, comp);
    80018bde:	fe043583          	ld	a1,-32(s0)
    80018be2:	fe843503          	ld	a0,-24(s0)
    80018be6:	10e000ef          	jal	ra,80018cf4 <vector_insertion_sort>
}
    80018bea:	0001                	nop
    80018bec:	60e2                	ld	ra,24(sp)
    80018bee:	6442                	ld	s0,16(sp)
    80018bf0:	6105                	addi	sp,sp,32
    80018bf2:	8082                	ret

0000000080018bf4 <vector_selection_sort>:

void vector_selection_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80018bf4:	715d                	addi	sp,sp,-80
    80018bf6:	e486                	sd	ra,72(sp)
    80018bf8:	e0a2                	sd	s0,64(sp)
    80018bfa:	fc26                	sd	s1,56(sp)
    80018bfc:	0880                	addi	s0,sp,80
    80018bfe:	faa43c23          	sd	a0,-72(s0)
    80018c02:	fab43823          	sd	a1,-80(s0)
    uint32_t i;
    uint32_t j;
    uint32_t min_idx;
    uint64_t tmp;

    for (i = 0;i < vector_size(vec);i++) {
    80018c06:	fc042e23          	sw	zero,-36(s0)
    80018c0a:	a0d1                	j	80018cce <vector_selection_sort+0xda>
        min_idx = i;
    80018c0c:	fdc42783          	lw	a5,-36(s0)
    80018c10:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    80018c14:	fdc42783          	lw	a5,-36(s0)
    80018c18:	2785                	addiw	a5,a5,1
    80018c1a:	fcf42c23          	sw	a5,-40(s0)
    80018c1e:	a0a9                	j	80018c68 <vector_selection_sort+0x74>
            if (!comp(vector_get_unchecked(vec, min_idx), vector_get_unchecked(vec, j))) {
    80018c20:	fd442783          	lw	a5,-44(s0)
    80018c24:	85be                	mv	a1,a5
    80018c26:	fb843503          	ld	a0,-72(s0)
    80018c2a:	aa9ff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018c2e:	84aa                	mv	s1,a0
    80018c30:	fd842783          	lw	a5,-40(s0)
    80018c34:	85be                	mv	a1,a5
    80018c36:	fb843503          	ld	a0,-72(s0)
    80018c3a:	a99ff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018c3e:	87aa                	mv	a5,a0
    80018c40:	fb043703          	ld	a4,-80(s0)
    80018c44:	85be                	mv	a1,a5
    80018c46:	8526                	mv	a0,s1
    80018c48:	9702                	jalr	a4
    80018c4a:	87aa                	mv	a5,a0
    80018c4c:	0017c793          	xori	a5,a5,1
    80018c50:	0ff7f793          	andi	a5,a5,255
    80018c54:	c789                	beqz	a5,80018c5e <vector_selection_sort+0x6a>
                min_idx = j;
    80018c56:	fd842783          	lw	a5,-40(s0)
    80018c5a:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    80018c5e:	fd842783          	lw	a5,-40(s0)
    80018c62:	2785                	addiw	a5,a5,1
    80018c64:	fcf42c23          	sw	a5,-40(s0)
    80018c68:	fb843503          	ld	a0,-72(s0)
    80018c6c:	178000ef          	jal	ra,80018de4 <vector_size>
    80018c70:	87aa                	mv	a5,a0
    80018c72:	0007871b          	sext.w	a4,a5
    80018c76:	fd842783          	lw	a5,-40(s0)
    80018c7a:	2781                	sext.w	a5,a5
    80018c7c:	fae7e2e3          	bltu	a5,a4,80018c20 <vector_selection_sort+0x2c>
            }
        }
        tmp = vector_get_unchecked(vec, i);
    80018c80:	fdc42783          	lw	a5,-36(s0)
    80018c84:	85be                	mv	a1,a5
    80018c86:	fb843503          	ld	a0,-72(s0)
    80018c8a:	a49ff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018c8e:	fca43423          	sd	a0,-56(s0)
        vector_set(vec, i, vector_get_unchecked(vec, min_idx));
    80018c92:	fd442783          	lw	a5,-44(s0)
    80018c96:	85be                	mv	a1,a5
    80018c98:	fb843503          	ld	a0,-72(s0)
    80018c9c:	a37ff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018ca0:	872a                	mv	a4,a0
    80018ca2:	fdc42783          	lw	a5,-36(s0)
    80018ca6:	863a                	mv	a2,a4
    80018ca8:	85be                	mv	a1,a5
    80018caa:	fb843503          	ld	a0,-72(s0)
    80018cae:	991ff0ef          	jal	ra,8001863e <vector_set>
        vector_set(vec, min_idx, tmp);
    80018cb2:	fd442783          	lw	a5,-44(s0)
    80018cb6:	fc843603          	ld	a2,-56(s0)
    80018cba:	85be                	mv	a1,a5
    80018cbc:	fb843503          	ld	a0,-72(s0)
    80018cc0:	97fff0ef          	jal	ra,8001863e <vector_set>
    for (i = 0;i < vector_size(vec);i++) {
    80018cc4:	fdc42783          	lw	a5,-36(s0)
    80018cc8:	2785                	addiw	a5,a5,1
    80018cca:	fcf42e23          	sw	a5,-36(s0)
    80018cce:	fb843503          	ld	a0,-72(s0)
    80018cd2:	112000ef          	jal	ra,80018de4 <vector_size>
    80018cd6:	87aa                	mv	a5,a0
    80018cd8:	0007871b          	sext.w	a4,a5
    80018cdc:	fdc42783          	lw	a5,-36(s0)
    80018ce0:	2781                	sext.w	a5,a5
    80018ce2:	f2e7e5e3          	bltu	a5,a4,80018c0c <vector_selection_sort+0x18>
    }
}
    80018ce6:	0001                	nop
    80018ce8:	0001                	nop
    80018cea:	60a6                	ld	ra,72(sp)
    80018cec:	6406                	ld	s0,64(sp)
    80018cee:	74e2                	ld	s1,56(sp)
    80018cf0:	6161                	addi	sp,sp,80
    80018cf2:	8082                	ret

0000000080018cf4 <vector_insertion_sort>:

void vector_insertion_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80018cf4:	715d                	addi	sp,sp,-80
    80018cf6:	e486                	sd	ra,72(sp)
    80018cf8:	e0a2                	sd	s0,64(sp)
    80018cfa:	fc26                	sd	s1,56(sp)
    80018cfc:	0880                	addi	s0,sp,80
    80018cfe:	faa43c23          	sd	a0,-72(s0)
    80018d02:	fab43823          	sd	a1,-80(s0)
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    80018d06:	4785                	li	a5,1
    80018d08:	fcf42e23          	sw	a5,-36(s0)
    80018d0c:	a84d                	j	80018dbe <vector_insertion_sort+0xca>
        uint32_t j = i;
    80018d0e:	fdc42783          	lw	a5,-36(s0)
    80018d12:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    80018d16:	a8b1                	j	80018d72 <vector_insertion_sort+0x7e>
            uint64_t left = vector_get_unchecked(vec, j - 1);
    80018d18:	fd842783          	lw	a5,-40(s0)
    80018d1c:	37fd                	addiw	a5,a5,-1
    80018d1e:	2781                	sext.w	a5,a5
    80018d20:	85be                	mv	a1,a5
    80018d22:	fb843503          	ld	a0,-72(s0)
    80018d26:	9adff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018d2a:	fca43823          	sd	a0,-48(s0)
            uint64_t right = vector_get_unchecked(vec, j);
    80018d2e:	fd842783          	lw	a5,-40(s0)
    80018d32:	85be                	mv	a1,a5
    80018d34:	fb843503          	ld	a0,-72(s0)
    80018d38:	99bff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018d3c:	fca43423          	sd	a0,-56(s0)

            vector_set(vec, j, left);
    80018d40:	fd842783          	lw	a5,-40(s0)
    80018d44:	fd043603          	ld	a2,-48(s0)
    80018d48:	85be                	mv	a1,a5
    80018d4a:	fb843503          	ld	a0,-72(s0)
    80018d4e:	8f1ff0ef          	jal	ra,8001863e <vector_set>
            vector_set(vec, j - 1, right);
    80018d52:	fd842783          	lw	a5,-40(s0)
    80018d56:	37fd                	addiw	a5,a5,-1
    80018d58:	2781                	sext.w	a5,a5
    80018d5a:	fc843603          	ld	a2,-56(s0)
    80018d5e:	85be                	mv	a1,a5
    80018d60:	fb843503          	ld	a0,-72(s0)
    80018d64:	8dbff0ef          	jal	ra,8001863e <vector_set>

            j -= 1;
    80018d68:	fd842783          	lw	a5,-40(s0)
    80018d6c:	37fd                	addiw	a5,a5,-1
    80018d6e:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    80018d72:	fd842783          	lw	a5,-40(s0)
    80018d76:	2781                	sext.w	a5,a5
    80018d78:	cf95                	beqz	a5,80018db4 <vector_insertion_sort+0xc0>
    80018d7a:	fd842783          	lw	a5,-40(s0)
    80018d7e:	37fd                	addiw	a5,a5,-1
    80018d80:	2781                	sext.w	a5,a5
    80018d82:	85be                	mv	a1,a5
    80018d84:	fb843503          	ld	a0,-72(s0)
    80018d88:	94bff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018d8c:	84aa                	mv	s1,a0
    80018d8e:	fd842783          	lw	a5,-40(s0)
    80018d92:	85be                	mv	a1,a5
    80018d94:	fb843503          	ld	a0,-72(s0)
    80018d98:	93bff0ef          	jal	ra,800186d2 <vector_get_unchecked>
    80018d9c:	87aa                	mv	a5,a0
    80018d9e:	fb043703          	ld	a4,-80(s0)
    80018da2:	85be                	mv	a1,a5
    80018da4:	8526                	mv	a0,s1
    80018da6:	9702                	jalr	a4
    80018da8:	87aa                	mv	a5,a0
    80018daa:	0017c793          	xori	a5,a5,1
    80018dae:	0ff7f793          	andi	a5,a5,255
    80018db2:	f3bd                	bnez	a5,80018d18 <vector_insertion_sort+0x24>
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    80018db4:	fdc42783          	lw	a5,-36(s0)
    80018db8:	2785                	addiw	a5,a5,1
    80018dba:	fcf42e23          	sw	a5,-36(s0)
    80018dbe:	fb843503          	ld	a0,-72(s0)
    80018dc2:	022000ef          	jal	ra,80018de4 <vector_size>
    80018dc6:	87aa                	mv	a5,a0
    80018dc8:	0007871b          	sext.w	a4,a5
    80018dcc:	fdc42783          	lw	a5,-36(s0)
    80018dd0:	2781                	sext.w	a5,a5
    80018dd2:	f2e7eee3          	bltu	a5,a4,80018d0e <vector_insertion_sort+0x1a>
        }
    }
}
    80018dd6:	0001                	nop
    80018dd8:	0001                	nop
    80018dda:	60a6                	ld	ra,72(sp)
    80018ddc:	6406                	ld	s0,64(sp)
    80018dde:	74e2                	ld	s1,56(sp)
    80018de0:	6161                	addi	sp,sp,80
    80018de2:	8082                	ret

0000000080018de4 <vector_size>:

uint32_t vector_size(Vector *vec) {
    80018de4:	1101                	addi	sp,sp,-32
    80018de6:	ec22                	sd	s0,24(sp)
    80018de8:	1000                	addi	s0,sp,32
    80018dea:	fea43423          	sd	a0,-24(s0)
    return vec->size;
    80018dee:	fe843783          	ld	a5,-24(s0)
    80018df2:	439c                	lw	a5,0(a5)
}
    80018df4:	853e                	mv	a0,a5
    80018df6:	6462                	ld	s0,24(sp)
    80018df8:	6105                	addi	sp,sp,32
    80018dfa:	8082                	ret

0000000080018dfc <vector_capacity>:

uint32_t vector_capacity(Vector *vec) {
    80018dfc:	1101                	addi	sp,sp,-32
    80018dfe:	ec22                	sd	s0,24(sp)
    80018e00:	1000                	addi	s0,sp,32
    80018e02:	fea43423          	sd	a0,-24(s0)
    return vec->capacity;
    80018e06:	fe843783          	ld	a5,-24(s0)
    80018e0a:	43dc                	lw	a5,4(a5)
}
    80018e0c:	853e                	mv	a0,a5
    80018e0e:	6462                	ld	s0,24(sp)
    80018e10:	6105                	addi	sp,sp,32
    80018e12:	8082                	ret

0000000080018e14 <vector_free>:

void vector_free(Vector *vec) {
    80018e14:	1101                	addi	sp,sp,-32
    80018e16:	ec06                	sd	ra,24(sp)
    80018e18:	e822                	sd	s0,16(sp)
    80018e1a:	1000                	addi	s0,sp,32
    80018e1c:	fea43423          	sd	a0,-24(s0)
    g_kfree(vec->values);
    80018e20:	fe843783          	ld	a5,-24(s0)
    80018e24:	679c                	ld	a5,8(a5)
    80018e26:	853e                	mv	a0,a5
    80018e28:	d2efe0ef          	jal	ra,80017356 <g_kfree>
    vec->size = 0;
    80018e2c:	fe843783          	ld	a5,-24(s0)
    80018e30:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    80018e34:	fe843783          	ld	a5,-24(s0)
    80018e38:	0007a223          	sw	zero,4(a5)
    g_kfree(vec);
    80018e3c:	fe843503          	ld	a0,-24(s0)
    80018e40:	d16fe0ef          	jal	ra,80017356 <g_kfree>
}
    80018e44:	0001                	nop
    80018e46:	60e2                	ld	ra,24(sp)
    80018e48:	6442                	ld	s0,16(sp)
    80018e4a:	6105                	addi	sp,sp,32
    80018e4c:	8082                	ret

0000000080018e4e <vector_sort_signed_long_comparator_ascending>:

VECTOR_COMPARATOR(vector_sort_signed_long_comparator_ascending) {
    80018e4e:	1101                	addi	sp,sp,-32
    80018e50:	ec22                	sd	s0,24(sp)
    80018e52:	1000                	addi	s0,sp,32
    80018e54:	fea43423          	sd	a0,-24(s0)
    80018e58:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    80018e5c:	fe843703          	ld	a4,-24(s0)
    80018e60:	fe043783          	ld	a5,-32(s0)
    80018e64:	00e7a7b3          	slt	a5,a5,a4
    80018e68:	0017c793          	xori	a5,a5,1
    80018e6c:	0ff7f793          	andi	a5,a5,255
}
    80018e70:	853e                	mv	a0,a5
    80018e72:	6462                	ld	s0,24(sp)
    80018e74:	6105                	addi	sp,sp,32
    80018e76:	8082                	ret

0000000080018e78 <vector_sort_signed_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_signed_long_comparator_descending) {
    80018e78:	1101                	addi	sp,sp,-32
    80018e7a:	ec22                	sd	s0,24(sp)
    80018e7c:	1000                	addi	s0,sp,32
    80018e7e:	fea43423          	sd	a0,-24(s0)
    80018e82:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    80018e86:	fe843703          	ld	a4,-24(s0)
    80018e8a:	fe043783          	ld	a5,-32(s0)
    80018e8e:	00f727b3          	slt	a5,a4,a5
    80018e92:	0017c793          	xori	a5,a5,1
    80018e96:	0ff7f793          	andi	a5,a5,255
}
    80018e9a:	853e                	mv	a0,a5
    80018e9c:	6462                	ld	s0,24(sp)
    80018e9e:	6105                	addi	sp,sp,32
    80018ea0:	8082                	ret

0000000080018ea2 <vector_sort_unsigned_long_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_ascending) {
    80018ea2:	1101                	addi	sp,sp,-32
    80018ea4:	ec22                	sd	s0,24(sp)
    80018ea6:	1000                	addi	s0,sp,32
    80018ea8:	fea43423          	sd	a0,-24(s0)
    80018eac:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    80018eb0:	fe843703          	ld	a4,-24(s0)
    80018eb4:	fe043783          	ld	a5,-32(s0)
    80018eb8:	00e7b7b3          	sltu	a5,a5,a4
    80018ebc:	0017c793          	xori	a5,a5,1
    80018ec0:	0ff7f793          	andi	a5,a5,255
}
    80018ec4:	853e                	mv	a0,a5
    80018ec6:	6462                	ld	s0,24(sp)
    80018ec8:	6105                	addi	sp,sp,32
    80018eca:	8082                	ret

0000000080018ecc <vector_sort_unsigned_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_descending) {
    80018ecc:	1101                	addi	sp,sp,-32
    80018ece:	ec22                	sd	s0,24(sp)
    80018ed0:	1000                	addi	s0,sp,32
    80018ed2:	fea43423          	sd	a0,-24(s0)
    80018ed6:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    80018eda:	fe843703          	ld	a4,-24(s0)
    80018ede:	fe043783          	ld	a5,-32(s0)
    80018ee2:	00f737b3          	sltu	a5,a4,a5
    80018ee6:	0017c793          	xori	a5,a5,1
    80018eea:	0ff7f793          	andi	a5,a5,255
}
    80018eee:	853e                	mv	a0,a5
    80018ef0:	6462                	ld	s0,24(sp)
    80018ef2:	6105                	addi	sp,sp,32
    80018ef4:	8082                	ret

0000000080018ef6 <vector_sort_string_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_ascending) {
    80018ef6:	1101                	addi	sp,sp,-32
    80018ef8:	ec06                	sd	ra,24(sp)
    80018efa:	e822                	sd	s0,16(sp)
    80018efc:	1000                	addi	s0,sp,32
    80018efe:	fea43423          	sd	a0,-24(s0)
    80018f02:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    80018f06:	fe843783          	ld	a5,-24(s0)
    80018f0a:	fe043703          	ld	a4,-32(s0)
    80018f0e:	85ba                	mv	a1,a4
    80018f10:	853e                	mv	a0,a5
    80018f12:	fb1fe0ef          	jal	ra,80017ec2 <strcmp>
    80018f16:	87aa                	mv	a5,a0
    80018f18:	0017a793          	slti	a5,a5,1
    80018f1c:	0ff7f793          	andi	a5,a5,255
}
    80018f20:	853e                	mv	a0,a5
    80018f22:	60e2                	ld	ra,24(sp)
    80018f24:	6442                	ld	s0,16(sp)
    80018f26:	6105                	addi	sp,sp,32
    80018f28:	8082                	ret

0000000080018f2a <vector_sort_string_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_descending) {
    80018f2a:	1101                	addi	sp,sp,-32
    80018f2c:	ec06                	sd	ra,24(sp)
    80018f2e:	e822                	sd	s0,16(sp)
    80018f30:	1000                	addi	s0,sp,32
    80018f32:	fea43423          	sd	a0,-24(s0)
    80018f36:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    80018f3a:	fe843783          	ld	a5,-24(s0)
    80018f3e:	fe043703          	ld	a4,-32(s0)
    80018f42:	85ba                	mv	a1,a4
    80018f44:	853e                	mv	a0,a5
    80018f46:	f7dfe0ef          	jal	ra,80017ec2 <strcmp>
    80018f4a:	87aa                	mv	a5,a0
    80018f4c:	fff7c793          	not	a5,a5
    80018f50:	01f7d79b          	srliw	a5,a5,0x1f
    80018f54:	0ff7f793          	andi	a5,a5,255
}
    80018f58:	853e                	mv	a0,a5
    80018f5a:	60e2                	ld	ra,24(sp)
    80018f5c:	6442                	ld	s0,16(sp)
    80018f5e:	6105                	addi	sp,sp,32
    80018f60:	8082                	ret
