
cosc562.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000080010000 <_memory_start>:
    80010000:	fe22                	sd	s0,312(sp)
    80010002:	f1ca                	sd	s2,224(sp)
    80010004:	0bee                	slli	s7,s7,0x1b
    80010006:	dead                	beqz	a3,8000ff80 <i+0x8000ff60>
    80010008:	dda0                	sw	s0,120(a1)
    8001000a:	8001                	c.srli64	s0
	...

0000000080010102 <copy_from>:
*/
unsigned long copy_from(void *dst, 
                        const struct page_table *from_table, 
                        const void *from, 
                        unsigned long size)
{
    80010102:	7119                	addi	sp,sp,-128
    80010104:	fc86                	sd	ra,120(sp)
    80010106:	f8a2                	sd	s0,112(sp)
    80010108:	0100                	addi	s0,sp,128
    8001010a:	f8a43c23          	sd	a0,-104(s0)
    8001010e:	f8b43823          	sd	a1,-112(s0)
    80010112:	f8c43423          	sd	a2,-120(s0)
    80010116:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    8001011a:	fe043423          	sd	zero,-24(s0)

    unsigned long src_start_addr = (unsigned long)from;
    8001011e:	f8843783          	ld	a5,-120(s0)
    80010122:	fcf43423          	sd	a5,-56(s0)
    unsigned long src_end_addr = (unsigned long)from+size;
    80010126:	f8843783          	ld	a5,-120(s0)
    8001012a:	f8043703          	ld	a4,-128(s0)
    8001012e:	97ba                	add	a5,a5,a4
    80010130:	fcf43023          	sd	a5,-64(s0)
    unsigned long src_first_page = ALIGN_DOWN_POT(src_start_addr, PAGE_SIZE_4K);
    80010134:	fc843703          	ld	a4,-56(s0)
    80010138:	77fd                	lui	a5,0xfffff
    8001013a:	8ff9                	and	a5,a5,a4
    8001013c:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    80010140:	fb843783          	ld	a5,-72(s0)
    80010144:	fef43023          	sd	a5,-32(s0)
    80010148:	a06d                	j	800101f2 <copy_from+0xf0>
        void *physical_address = (void*)mmu_translate(from_table, i);
    8001014a:	fe043583          	ld	a1,-32(s0)
    8001014e:	f9043503          	ld	a0,-112(s0)
    80010152:	203090ef          	jal	ra,80019b54 <mmu_translate>
    80010156:	87aa                	mv	a5,a0
    80010158:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    8001015c:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == src_start_addr;
    80010160:	fe043703          	ld	a4,-32(s0)
    80010164:	fc843783          	ld	a5,-56(s0)
    80010168:	40f707b3          	sub	a5,a4,a5
    8001016c:	0017b793          	seqz	a5,a5
    80010170:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    80010174:	faf44783          	lbu	a5,-81(s0)
    80010178:	0ff7f793          	andi	a5,a5,255
    8001017c:	cb81                	beqz	a5,8001018c <copy_from+0x8a>
            offset = src_start_addr % PAGE_SIZE_4K;
    8001017e:	fc843703          	ld	a4,-56(s0)
    80010182:	6785                	lui	a5,0x1
    80010184:	17fd                	addi	a5,a5,-1
    80010186:	8ff9                	and	a5,a5,a4
    80010188:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    8001018c:	6785                	lui	a5,0x1
    8001018e:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > src_end_addr) {
    80010192:	fe043703          	ld	a4,-32(s0)
    80010196:	6785                	lui	a5,0x1
    80010198:	97ba                	add	a5,a5,a4
    8001019a:	fc043703          	ld	a4,-64(s0)
    8001019e:	00f77a63          	bgeu	a4,a5,800101b2 <copy_from+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = src_end_addr - i;
    800101a2:	fc043703          	ld	a4,-64(s0)
    800101a6:	fe043783          	ld	a5,-32(s0)
    800101aa:	40f707b3          	sub	a5,a4,a5
    800101ae:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(dst + bytes_copied, physical_address + offset, bytes_to_copy_from_page);
    800101b2:	f9843703          	ld	a4,-104(s0)
    800101b6:	fe843783          	ld	a5,-24(s0)
    800101ba:	00f706b3          	add	a3,a4,a5
    800101be:	fb043703          	ld	a4,-80(s0)
    800101c2:	fd843783          	ld	a5,-40(s0)
    800101c6:	97ba                	add	a5,a5,a4
    800101c8:	fd043703          	ld	a4,-48(s0)
    800101cc:	2701                	sext.w	a4,a4
    800101ce:	863a                	mv	a2,a4
    800101d0:	85be                	mv	a1,a5
    800101d2:	8536                	mv	a0,a3
    800101d4:	49b0f0ef          	jal	ra,8001fe6e <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800101d8:	fe843703          	ld	a4,-24(s0)
    800101dc:	fd043783          	ld	a5,-48(s0)
    800101e0:	97ba                	add	a5,a5,a4
    800101e2:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    800101e6:	fe043703          	ld	a4,-32(s0)
    800101ea:	6785                	lui	a5,0x1
    800101ec:	97ba                	add	a5,a5,a4
    800101ee:	fef43023          	sd	a5,-32(s0)
    800101f2:	fe043703          	ld	a4,-32(s0)
    800101f6:	fc043783          	ld	a5,-64(s0)
    800101fa:	f4f768e3          	bltu	a4,a5,8001014a <copy_from+0x48>
    }

    return bytes_copied;
    800101fe:	fe843783          	ld	a5,-24(s0)
}
    80010202:	853e                	mv	a0,a5
    80010204:	70e6                	ld	ra,120(sp)
    80010206:	7446                	ld	s0,112(sp)
    80010208:	6109                	addi	sp,sp,128
    8001020a:	8082                	ret

000000008001020c <copy_to>:
*/
unsigned long copy_to(void *to, 
                      const struct page_table *to_table, 
                      const void *src, 
                      unsigned long size)
{
    8001020c:	7119                	addi	sp,sp,-128
    8001020e:	fc86                	sd	ra,120(sp)
    80010210:	f8a2                	sd	s0,112(sp)
    80010212:	0100                	addi	s0,sp,128
    80010214:	f8a43c23          	sd	a0,-104(s0)
    80010218:	f8b43823          	sd	a1,-112(s0)
    8001021c:	f8c43423          	sd	a2,-120(s0)
    80010220:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    80010224:	fe043423          	sd	zero,-24(s0)

    unsigned long dst_start_addr = (unsigned long)to;
    80010228:	f9843783          	ld	a5,-104(s0)
    8001022c:	fcf43423          	sd	a5,-56(s0)
    unsigned long dst_end_addr = (unsigned long)to+size;
    80010230:	f9843783          	ld	a5,-104(s0)
    80010234:	f8043703          	ld	a4,-128(s0)
    80010238:	97ba                	add	a5,a5,a4
    8001023a:	fcf43023          	sd	a5,-64(s0)
    unsigned long dst_first_page = ALIGN_DOWN_POT(dst_start_addr, PAGE_SIZE_4K);
    8001023e:	fc843703          	ld	a4,-56(s0)
    80010242:	77fd                	lui	a5,0xfffff
    80010244:	8ff9                	and	a5,a5,a4
    80010246:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    8001024a:	fb843783          	ld	a5,-72(s0)
    8001024e:	fef43023          	sd	a5,-32(s0)
    80010252:	a06d                	j	800102fc <copy_to+0xf0>
        void *physical_address = (void*)mmu_translate(to_table, i);
    80010254:	fe043583          	ld	a1,-32(s0)
    80010258:	f9043503          	ld	a0,-112(s0)
    8001025c:	0f9090ef          	jal	ra,80019b54 <mmu_translate>
    80010260:	87aa                	mv	a5,a0
    80010262:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    80010266:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == dst_start_addr;
    8001026a:	fe043703          	ld	a4,-32(s0)
    8001026e:	fc843783          	ld	a5,-56(s0)
    80010272:	40f707b3          	sub	a5,a4,a5
    80010276:	0017b793          	seqz	a5,a5
    8001027a:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    8001027e:	faf44783          	lbu	a5,-81(s0)
    80010282:	0ff7f793          	andi	a5,a5,255
    80010286:	cb81                	beqz	a5,80010296 <copy_to+0x8a>
            offset = dst_start_addr % PAGE_SIZE_4K;
    80010288:	fc843703          	ld	a4,-56(s0)
    8001028c:	6785                	lui	a5,0x1
    8001028e:	17fd                	addi	a5,a5,-1
    80010290:	8ff9                	and	a5,a5,a4
    80010292:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    80010296:	6785                	lui	a5,0x1
    80010298:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > dst_end_addr) {
    8001029c:	fe043703          	ld	a4,-32(s0)
    800102a0:	6785                	lui	a5,0x1
    800102a2:	97ba                	add	a5,a5,a4
    800102a4:	fc043703          	ld	a4,-64(s0)
    800102a8:	00f77a63          	bgeu	a4,a5,800102bc <copy_to+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = dst_end_addr - i;
    800102ac:	fc043703          	ld	a4,-64(s0)
    800102b0:	fe043783          	ld	a5,-32(s0)
    800102b4:	40f707b3          	sub	a5,a4,a5
    800102b8:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(physical_address + offset, src + bytes_copied, bytes_to_copy_from_page);
    800102bc:	fb043703          	ld	a4,-80(s0)
    800102c0:	fd843783          	ld	a5,-40(s0)
    800102c4:	00f706b3          	add	a3,a4,a5
    800102c8:	f8843703          	ld	a4,-120(s0)
    800102cc:	fe843783          	ld	a5,-24(s0)
    800102d0:	97ba                	add	a5,a5,a4
    800102d2:	fd043703          	ld	a4,-48(s0)
    800102d6:	2701                	sext.w	a4,a4
    800102d8:	863a                	mv	a2,a4
    800102da:	85be                	mv	a1,a5
    800102dc:	8536                	mv	a0,a3
    800102de:	3910f0ef          	jal	ra,8001fe6e <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800102e2:	fe843703          	ld	a4,-24(s0)
    800102e6:	fd043783          	ld	a5,-48(s0)
    800102ea:	97ba                	add	a5,a5,a4
    800102ec:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    800102f0:	fe043703          	ld	a4,-32(s0)
    800102f4:	6785                	lui	a5,0x1
    800102f6:	97ba                	add	a5,a5,a4
    800102f8:	fef43023          	sd	a5,-32(s0)
    800102fc:	fe043703          	ld	a4,-32(s0)
    80010300:	fc043783          	ld	a5,-64(s0)
    80010304:	f4f768e3          	bltu	a4,a5,80010254 <copy_to+0x48>
    }

    return bytes_copied;
    80010308:	fe843783          	ld	a5,-24(s0)
    8001030c:	853e                	mv	a0,a5
    8001030e:	70e6                	ld	ra,120(sp)
    80010310:	7446                	ld	s0,112(sp)
    80010312:	6109                	addi	sp,sp,128
    80010314:	8082                	ret

0000000080010316 <syscall_exit>:
    (void)hart;         \
    (void)epc;          \
    (void)scratch

SYSCALL(exit)
{
    80010316:	7179                	addi	sp,sp,-48
    80010318:	f422                	sd	s0,40(sp)
    8001031a:	1800                	addi	s0,sp,48
    8001031c:	87aa                	mv	a5,a0
    8001031e:	feb43023          	sd	a1,-32(s0)
    80010322:	fcc43c23          	sd	a2,-40(s0)
    80010326:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Kill the current process on this HART and schedule the next
    // one.
}
    8001032a:	0001                	nop
    8001032c:	7422                	ld	s0,40(sp)
    8001032e:	6145                	addi	sp,sp,48
    80010330:	8082                	ret

0000000080010332 <syscall_putchar>:

SYSCALL(putchar)
{
    80010332:	7179                	addi	sp,sp,-48
    80010334:	f406                	sd	ra,40(sp)
    80010336:	f022                	sd	s0,32(sp)
    80010338:	1800                	addi	s0,sp,48
    8001033a:	87aa                	mv	a5,a0
    8001033c:	feb43023          	sd	a1,-32(s0)
    80010340:	fcc43c23          	sd	a2,-40(s0)
    80010344:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    sbi_putchar(XREG(A0));
    80010348:	fd843783          	ld	a5,-40(s0)
    8001034c:	05078793          	addi	a5,a5,80 # 1050 <i+0x1030>
    80010350:	639c                	ld	a5,0(a5)
    80010352:	0ff7f793          	andi	a5,a5,255
    80010356:	853e                	mv	a0,a5
    80010358:	06e090ef          	jal	ra,800193c6 <sbi_putchar>
}
    8001035c:	0001                	nop
    8001035e:	70a2                	ld	ra,40(sp)
    80010360:	7402                	ld	s0,32(sp)
    80010362:	6145                	addi	sp,sp,48
    80010364:	8082                	ret

0000000080010366 <syscall_getchar>:

SYSCALL(getchar)
{
    80010366:	7179                	addi	sp,sp,-48
    80010368:	f406                	sd	ra,40(sp)
    8001036a:	f022                	sd	s0,32(sp)
    8001036c:	1800                	addi	s0,sp,48
    8001036e:	87aa                	mv	a5,a0
    80010370:	feb43023          	sd	a1,-32(s0)
    80010374:	fcc43c23          	sd	a2,-40(s0)
    80010378:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    XREG(A0) = sbi_getchar();
    8001037c:	06c090ef          	jal	ra,800193e8 <sbi_getchar>
    80010380:	87aa                	mv	a5,a0
    80010382:	873e                	mv	a4,a5
    80010384:	fd843783          	ld	a5,-40(s0)
    80010388:	05078793          	addi	a5,a5,80
    8001038c:	e398                	sd	a4,0(a5)
}
    8001038e:	0001                	nop
    80010390:	70a2                	ld	ra,40(sp)
    80010392:	7402                	ld	s0,32(sp)
    80010394:	6145                	addi	sp,sp,48
    80010396:	8082                	ret

0000000080010398 <syscall_yield>:

SYSCALL(yield)
{
    80010398:	7179                	addi	sp,sp,-48
    8001039a:	f422                	sd	s0,40(sp)
    8001039c:	1800                	addi	s0,sp,48
    8001039e:	87aa                	mv	a5,a0
    800103a0:	feb43023          	sd	a1,-32(s0)
    800103a4:	fcc43c23          	sd	a2,-40(s0)
    800103a8:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // sched_invoke(hart);
}
    800103ac:	0001                	nop
    800103ae:	7422                	ld	s0,40(sp)
    800103b0:	6145                	addi	sp,sp,48
    800103b2:	8082                	ret

00000000800103b4 <syscall_sleep>:

SYSCALL(sleep)
{
    800103b4:	7179                	addi	sp,sp,-48
    800103b6:	f422                	sd	s0,40(sp)
    800103b8:	1800                	addi	s0,sp,48
    800103ba:	87aa                	mv	a5,a0
    800103bc:	feb43023          	sd	a1,-32(s0)
    800103c0:	fcc43c23          	sd	a2,-40(s0)
    800103c4:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Sleep the process. VIRT_TIMER_FREQ is 10MHz, divided by 1000, we get 10KHz
    //     p->sleep_until = sbi_get_time() + XREG(A0) * VIRT_TIMER_FREQ / 1000;
    //     p->state = PS_SLEEPING;
}
    800103c8:	0001                	nop
    800103ca:	7422                	ld	s0,40(sp)
    800103cc:	6145                	addi	sp,sp,48
    800103ce:	8082                	ret

00000000800103d0 <syscall_events>:

SYSCALL(events)
{
    800103d0:	7179                	addi	sp,sp,-48
    800103d2:	f422                	sd	s0,40(sp)
    800103d4:	1800                	addi	s0,sp,48
    800103d6:	87aa                	mv	a5,a0
    800103d8:	feb43023          	sd	a1,-32(s0)
    800103dc:	fcc43c23          	sd	a2,-40(s0)
    800103e0:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    
}
    800103e4:	0001                	nop
    800103e6:	7422                	ld	s0,40(sp)
    800103e8:	6145                	addi	sp,sp,48
    800103ea:	8082                	ret

00000000800103ec <syscall_handle>:

static const int NUM_SYSCALLS = sizeof(SYSCALLS) / sizeof(SYSCALLS[0]);

// We get here from the trap.c if this is an ECALL from U-MODE
void syscall_handle(int hart, uint64_t epc, int64_t *scratch)
{
    800103ec:	7179                	addi	sp,sp,-48
    800103ee:	f406                	sd	ra,40(sp)
    800103f0:	f022                	sd	s0,32(sp)
    800103f2:	1800                	addi	s0,sp,48
    800103f4:	87aa                	mv	a5,a0
    800103f6:	feb43023          	sd	a1,-32(s0)
    800103fa:	fcc43c23          	sd	a2,-40(s0)
    800103fe:	fef42623          	sw	a5,-20(s0)
    // Sched invoke will save sepc, so we want it to resume
    // 4 bytes ahead, which will be the next instruction.
    CSR_WRITE("sepc", epc + 4);
    80010402:	fe043783          	ld	a5,-32(s0)
    80010406:	0791                	addi	a5,a5,4
    80010408:	14179073          	csrw	sepc,a5

    if (XREG(A7) >= NUM_SYSCALLS || SYSCALLS[XREG(A7)] == NULL) {
    8001040c:	fd843783          	ld	a5,-40(s0)
    80010410:	08878793          	addi	a5,a5,136
    80010414:	639c                	ld	a5,0(a5)
    80010416:	4719                	li	a4,6
    80010418:	00e7df63          	bge	a5,a4,80010436 <syscall_handle+0x4a>
    8001041c:	fd843783          	ld	a5,-40(s0)
    80010420:	08878793          	addi	a5,a5,136
    80010424:	639c                	ld	a5,0(a5)
    80010426:	00014717          	auipc	a4,0x14
    8001042a:	bda70713          	addi	a4,a4,-1062 # 80024000 <SYSCALLS>
    8001042e:	078e                	slli	a5,a5,0x3
    80010430:	97ba                	add	a5,a5,a4
    80010432:	639c                	ld	a5,0(a5)
    80010434:	eb81                	bnez	a5,80010444 <syscall_handle+0x58>
        // Invalid syscall
        XREG(A0) = -EINVAL;
    80010436:	fd843783          	ld	a5,-40(s0)
    8001043a:	05078793          	addi	a5,a5,80
    8001043e:	5729                	li	a4,-22
    80010440:	e398                	sd	a4,0(a5)
    80010442:	a035                	j	8001046e <syscall_handle+0x82>
    }
    else {
        SYSCALL_EXEC(XREG(A7));
    80010444:	fd843783          	ld	a5,-40(s0)
    80010448:	08878793          	addi	a5,a5,136
    8001044c:	639c                	ld	a5,0(a5)
    8001044e:	00014717          	auipc	a4,0x14
    80010452:	bb270713          	addi	a4,a4,-1102 # 80024000 <SYSCALLS>
    80010456:	078e                	slli	a5,a5,0x3
    80010458:	97ba                	add	a5,a5,a4
    8001045a:	6398                	ld	a4,0(a5)
    8001045c:	fec42783          	lw	a5,-20(s0)
    80010460:	fd843603          	ld	a2,-40(s0)
    80010464:	fe043583          	ld	a1,-32(s0)
    80010468:	853e                	mv	a0,a5
    8001046a:	9702                	jalr	a4
    }
}
    8001046c:	0001                	nop
    8001046e:	0001                	nop
    80010470:	70a2                	ld	ra,40(sp)
    80010472:	7402                	ld	s0,32(sp)
    80010474:	6145                	addi	sp,sp,48
    80010476:	8082                	ret

0000000080010478 <_putchar>:
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#include "sbi.h"
void _putchar(char c) { sbi_putchar(c); }
    80010478:	1101                	addi	sp,sp,-32
    8001047a:	ec06                	sd	ra,24(sp)
    8001047c:	e822                	sd	s0,16(sp)
    8001047e:	1000                	addi	s0,sp,32
    80010480:	87aa                	mv	a5,a0
    80010482:	fef407a3          	sb	a5,-17(s0)
    80010486:	fef44783          	lbu	a5,-17(s0)
    8001048a:	853e                	mv	a0,a5
    8001048c:	73b080ef          	jal	ra,800193c6 <sbi_putchar>
    80010490:	0001                	nop
    80010492:	60e2                	ld	ra,24(sp)
    80010494:	6442                	ld	s0,16(sp)
    80010496:	6105                	addi	sp,sp,32
    80010498:	8082                	ret

000000008001049a <_out_buffer>:
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx,
                               size_t maxlen)
{
    8001049a:	7179                	addi	sp,sp,-48
    8001049c:	f422                	sd	s0,40(sp)
    8001049e:	1800                	addi	s0,sp,48
    800104a0:	87aa                	mv	a5,a0
    800104a2:	feb43023          	sd	a1,-32(s0)
    800104a6:	fcc43c23          	sd	a2,-40(s0)
    800104aa:	fcd43823          	sd	a3,-48(s0)
    800104ae:	fef407a3          	sb	a5,-17(s0)
    if (idx < maxlen) {
    800104b2:	fd843703          	ld	a4,-40(s0)
    800104b6:	fd043783          	ld	a5,-48(s0)
    800104ba:	00f77b63          	bgeu	a4,a5,800104d0 <_out_buffer+0x36>
        ((char *)buffer)[idx] = character;
    800104be:	fe043703          	ld	a4,-32(s0)
    800104c2:	fd843783          	ld	a5,-40(s0)
    800104c6:	97ba                	add	a5,a5,a4
    800104c8:	fef44703          	lbu	a4,-17(s0)
    800104cc:	00e78023          	sb	a4,0(a5)
    }
}
    800104d0:	0001                	nop
    800104d2:	7422                	ld	s0,40(sp)
    800104d4:	6145                	addi	sp,sp,48
    800104d6:	8082                	ret

00000000800104d8 <_out_null>:

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800104d8:	7179                	addi	sp,sp,-48
    800104da:	f422                	sd	s0,40(sp)
    800104dc:	1800                	addi	s0,sp,48
    800104de:	87aa                	mv	a5,a0
    800104e0:	feb43023          	sd	a1,-32(s0)
    800104e4:	fcc43c23          	sd	a2,-40(s0)
    800104e8:	fcd43823          	sd	a3,-48(s0)
    800104ec:	fef407a3          	sb	a5,-17(s0)
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}
    800104f0:	0001                	nop
    800104f2:	7422                	ld	s0,40(sp)
    800104f4:	6145                	addi	sp,sp,48
    800104f6:	8082                	ret

00000000800104f8 <_out_char>:

// internal _putchar wrapper
static inline void _out_char(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    800104f8:	7179                	addi	sp,sp,-48
    800104fa:	f406                	sd	ra,40(sp)
    800104fc:	f022                	sd	s0,32(sp)
    800104fe:	1800                	addi	s0,sp,48
    80010500:	87aa                	mv	a5,a0
    80010502:	feb43023          	sd	a1,-32(s0)
    80010506:	fcc43c23          	sd	a2,-40(s0)
    8001050a:	fcd43823          	sd	a3,-48(s0)
    8001050e:	fef407a3          	sb	a5,-17(s0)
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
    80010512:	fef44783          	lbu	a5,-17(s0)
    80010516:	0ff7f793          	andi	a5,a5,255
    8001051a:	c791                	beqz	a5,80010526 <_out_char+0x2e>
        _putchar(character);
    8001051c:	fef44783          	lbu	a5,-17(s0)
    80010520:	853e                	mv	a0,a5
    80010522:	f57ff0ef          	jal	ra,80010478 <_putchar>
    }
}
    80010526:	0001                	nop
    80010528:	70a2                	ld	ra,40(sp)
    8001052a:	7402                	ld	s0,32(sp)
    8001052c:	6145                	addi	sp,sp,48
    8001052e:	8082                	ret

0000000080010530 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx,
                            size_t maxlen)
{
    80010530:	7179                	addi	sp,sp,-48
    80010532:	f406                	sd	ra,40(sp)
    80010534:	f022                	sd	s0,32(sp)
    80010536:	1800                	addi	s0,sp,48
    80010538:	87aa                	mv	a5,a0
    8001053a:	feb43023          	sd	a1,-32(s0)
    8001053e:	fcc43c23          	sd	a2,-40(s0)
    80010542:	fcd43823          	sd	a3,-48(s0)
    80010546:	fef407a3          	sb	a5,-17(s0)
    (void)idx;
    (void)maxlen;
    if (character) {
    8001054a:	fef44783          	lbu	a5,-17(s0)
    8001054e:	0ff7f793          	andi	a5,a5,255
    80010552:	cf81                	beqz	a5,8001056a <_out_fct+0x3a>
        // buffer is the output fct pointer
        ((out_fct_wrap_type *)buffer)
            ->fct(character, ((out_fct_wrap_type *)buffer)->arg);
    80010554:	fe043783          	ld	a5,-32(s0)
    80010558:	6394                	ld	a3,0(a5)
        ((out_fct_wrap_type *)buffer)
    8001055a:	fe043783          	ld	a5,-32(s0)
    8001055e:	6798                	ld	a4,8(a5)
    80010560:	fef44783          	lbu	a5,-17(s0)
    80010564:	85ba                	mv	a1,a4
    80010566:	853e                	mv	a0,a5
    80010568:	9682                	jalr	a3
    }
}
    8001056a:	0001                	nop
    8001056c:	70a2                	ld	ra,40(sp)
    8001056e:	7402                	ld	s0,32(sp)
    80010570:	6145                	addi	sp,sp,48
    80010572:	8082                	ret

0000000080010574 <_strnlen_s>:

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize)
{
    80010574:	7179                	addi	sp,sp,-48
    80010576:	f422                	sd	s0,40(sp)
    80010578:	1800                	addi	s0,sp,48
    8001057a:	fca43c23          	sd	a0,-40(s0)
    8001057e:	fcb43823          	sd	a1,-48(s0)
    const char *s;
    for (s = str; *s && maxsize--; ++s)
    80010582:	fd843783          	ld	a5,-40(s0)
    80010586:	fef43423          	sd	a5,-24(s0)
    8001058a:	a031                	j	80010596 <_strnlen_s+0x22>
    8001058c:	fe843783          	ld	a5,-24(s0)
    80010590:	0785                	addi	a5,a5,1
    80010592:	fef43423          	sd	a5,-24(s0)
    80010596:	fe843783          	ld	a5,-24(s0)
    8001059a:	0007c783          	lbu	a5,0(a5)
    8001059e:	cb81                	beqz	a5,800105ae <_strnlen_s+0x3a>
    800105a0:	fd043783          	ld	a5,-48(s0)
    800105a4:	fff78713          	addi	a4,a5,-1
    800105a8:	fce43823          	sd	a4,-48(s0)
    800105ac:	f3e5                	bnez	a5,8001058c <_strnlen_s+0x18>
        ;
    return (unsigned int)(s - str);
    800105ae:	fe843703          	ld	a4,-24(s0)
    800105b2:	fd843783          	ld	a5,-40(s0)
    800105b6:	40f707b3          	sub	a5,a4,a5
    800105ba:	2781                	sext.w	a5,a5
}
    800105bc:	853e                	mv	a0,a5
    800105be:	7422                	ld	s0,40(sp)
    800105c0:	6145                	addi	sp,sp,48
    800105c2:	8082                	ret

00000000800105c4 <_is_digit>:

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) { return (ch >= '0') && (ch <= '9'); }
    800105c4:	1101                	addi	sp,sp,-32
    800105c6:	ec22                	sd	s0,24(sp)
    800105c8:	1000                	addi	s0,sp,32
    800105ca:	87aa                	mv	a5,a0
    800105cc:	fef407a3          	sb	a5,-17(s0)
    800105d0:	fef44783          	lbu	a5,-17(s0)
    800105d4:	0ff7f713          	andi	a4,a5,255
    800105d8:	02f00793          	li	a5,47
    800105dc:	00e7fc63          	bgeu	a5,a4,800105f4 <_is_digit+0x30>
    800105e0:	fef44783          	lbu	a5,-17(s0)
    800105e4:	0ff7f713          	andi	a4,a5,255
    800105e8:	03900793          	li	a5,57
    800105ec:	00e7e463          	bltu	a5,a4,800105f4 <_is_digit+0x30>
    800105f0:	4785                	li	a5,1
    800105f2:	a011                	j	800105f6 <_is_digit+0x32>
    800105f4:	4781                	li	a5,0
    800105f6:	8b85                	andi	a5,a5,1
    800105f8:	0ff7f793          	andi	a5,a5,255
    800105fc:	853e                	mv	a0,a5
    800105fe:	6462                	ld	s0,24(sp)
    80010600:	6105                	addi	sp,sp,32
    80010602:	8082                	ret

0000000080010604 <_atoi>:

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str)
{
    80010604:	7179                	addi	sp,sp,-48
    80010606:	f406                	sd	ra,40(sp)
    80010608:	f022                	sd	s0,32(sp)
    8001060a:	1800                	addi	s0,sp,48
    8001060c:	fca43c23          	sd	a0,-40(s0)
    unsigned int i = 0U;
    80010610:	fe042623          	sw	zero,-20(s0)
    while (_is_digit(**str)) {
    80010614:	a825                	j	8001064c <_atoi+0x48>
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
    80010616:	fec42703          	lw	a4,-20(s0)
    8001061a:	87ba                	mv	a5,a4
    8001061c:	0027979b          	slliw	a5,a5,0x2
    80010620:	9fb9                	addw	a5,a5,a4
    80010622:	0017979b          	slliw	a5,a5,0x1
    80010626:	0007871b          	sext.w	a4,a5
    8001062a:	fd843783          	ld	a5,-40(s0)
    8001062e:	639c                	ld	a5,0(a5)
    80010630:	00178613          	addi	a2,a5,1
    80010634:	fd843683          	ld	a3,-40(s0)
    80010638:	e290                	sd	a2,0(a3)
    8001063a:	0007c783          	lbu	a5,0(a5)
    8001063e:	2781                	sext.w	a5,a5
    80010640:	9fb9                	addw	a5,a5,a4
    80010642:	2781                	sext.w	a5,a5
    80010644:	fd07879b          	addiw	a5,a5,-48
    80010648:	fef42623          	sw	a5,-20(s0)
    while (_is_digit(**str)) {
    8001064c:	fd843783          	ld	a5,-40(s0)
    80010650:	639c                	ld	a5,0(a5)
    80010652:	0007c783          	lbu	a5,0(a5)
    80010656:	853e                	mv	a0,a5
    80010658:	f6dff0ef          	jal	ra,800105c4 <_is_digit>
    8001065c:	87aa                	mv	a5,a0
    8001065e:	ffc5                	bnez	a5,80010616 <_atoi+0x12>
    }
    return i;
    80010660:	fec42783          	lw	a5,-20(s0)
}
    80010664:	853e                	mv	a0,a5
    80010666:	70a2                	ld	ra,40(sp)
    80010668:	7402                	ld	s0,32(sp)
    8001066a:	6145                	addi	sp,sp,48
    8001066c:	8082                	ret

000000008001066e <_out_rev>:

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx,
                       size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags)
{
    8001066e:	711d                	addi	sp,sp,-96
    80010670:	ec86                	sd	ra,88(sp)
    80010672:	e8a2                	sd	s0,80(sp)
    80010674:	1080                	addi	s0,sp,96
    80010676:	fca43c23          	sd	a0,-40(s0)
    8001067a:	fcb43823          	sd	a1,-48(s0)
    8001067e:	fcc43423          	sd	a2,-56(s0)
    80010682:	fcd43023          	sd	a3,-64(s0)
    80010686:	fae43c23          	sd	a4,-72(s0)
    8001068a:	faf43823          	sd	a5,-80(s0)
    8001068e:	87c2                	mv	a5,a6
    80010690:	8746                	mv	a4,a7
    80010692:	faf42623          	sw	a5,-84(s0)
    80010696:	87ba                	mv	a5,a4
    80010698:	faf42423          	sw	a5,-88(s0)
    const size_t start_idx = idx;
    8001069c:	fc843783          	ld	a5,-56(s0)
    800106a0:	fef43023          	sd	a5,-32(s0)

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    800106a4:	fa842783          	lw	a5,-88(s0)
    800106a8:	8b89                	andi	a5,a5,2
    800106aa:	2781                	sext.w	a5,a5
    800106ac:	e3c9                	bnez	a5,8001072e <_out_rev+0xc0>
    800106ae:	fa842783          	lw	a5,-88(s0)
    800106b2:	8b85                	andi	a5,a5,1
    800106b4:	2781                	sext.w	a5,a5
    800106b6:	efa5                	bnez	a5,8001072e <_out_rev+0xc0>
        for (size_t i = len; i < width; i++) {
    800106b8:	fb043783          	ld	a5,-80(s0)
    800106bc:	fef43423          	sd	a5,-24(s0)
    800106c0:	a035                	j	800106ec <_out_rev+0x7e>
            out(' ', buffer, idx++, maxlen);
    800106c2:	fc843783          	ld	a5,-56(s0)
    800106c6:	00178713          	addi	a4,a5,1
    800106ca:	fce43423          	sd	a4,-56(s0)
    800106ce:	fd843703          	ld	a4,-40(s0)
    800106d2:	fc043683          	ld	a3,-64(s0)
    800106d6:	863e                	mv	a2,a5
    800106d8:	fd043583          	ld	a1,-48(s0)
    800106dc:	02000513          	li	a0,32
    800106e0:	9702                	jalr	a4
        for (size_t i = len; i < width; i++) {
    800106e2:	fe843783          	ld	a5,-24(s0)
    800106e6:	0785                	addi	a5,a5,1
    800106e8:	fef43423          	sd	a5,-24(s0)
    800106ec:	fac46783          	lwu	a5,-84(s0)
    800106f0:	fe843703          	ld	a4,-24(s0)
    800106f4:	fcf767e3          	bltu	a4,a5,800106c2 <_out_rev+0x54>
        }
    }

    // reverse string
    while (len) {
    800106f8:	a81d                	j	8001072e <_out_rev+0xc0>
        out(buf[--len], buffer, idx++, maxlen);
    800106fa:	fb043783          	ld	a5,-80(s0)
    800106fe:	17fd                	addi	a5,a5,-1
    80010700:	faf43823          	sd	a5,-80(s0)
    80010704:	fb843703          	ld	a4,-72(s0)
    80010708:	fb043783          	ld	a5,-80(s0)
    8001070c:	97ba                	add	a5,a5,a4
    8001070e:	0007c503          	lbu	a0,0(a5)
    80010712:	fc843783          	ld	a5,-56(s0)
    80010716:	00178713          	addi	a4,a5,1
    8001071a:	fce43423          	sd	a4,-56(s0)
    8001071e:	fd843703          	ld	a4,-40(s0)
    80010722:	fc043683          	ld	a3,-64(s0)
    80010726:	863e                	mv	a2,a5
    80010728:	fd043583          	ld	a1,-48(s0)
    8001072c:	9702                	jalr	a4
    while (len) {
    8001072e:	fb043783          	ld	a5,-80(s0)
    80010732:	f7e1                	bnez	a5,800106fa <_out_rev+0x8c>
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
    80010734:	fa842783          	lw	a5,-88(s0)
    80010738:	8b89                	andi	a5,a5,2
    8001073a:	2781                	sext.w	a5,a5
    8001073c:	cb9d                	beqz	a5,80010772 <_out_rev+0x104>
        while (idx - start_idx < width) {
    8001073e:	a00d                	j	80010760 <_out_rev+0xf2>
            out(' ', buffer, idx++, maxlen);
    80010740:	fc843783          	ld	a5,-56(s0)
    80010744:	00178713          	addi	a4,a5,1
    80010748:	fce43423          	sd	a4,-56(s0)
    8001074c:	fd843703          	ld	a4,-40(s0)
    80010750:	fc043683          	ld	a3,-64(s0)
    80010754:	863e                	mv	a2,a5
    80010756:	fd043583          	ld	a1,-48(s0)
    8001075a:	02000513          	li	a0,32
    8001075e:	9702                	jalr	a4
        while (idx - start_idx < width) {
    80010760:	fc843703          	ld	a4,-56(s0)
    80010764:	fe043783          	ld	a5,-32(s0)
    80010768:	8f1d                	sub	a4,a4,a5
    8001076a:	fac46783          	lwu	a5,-84(s0)
    8001076e:	fcf769e3          	bltu	a4,a5,80010740 <_out_rev+0xd2>
        }
    }

    return idx;
    80010772:	fc843783          	ld	a5,-56(s0)
}
    80010776:	853e                	mv	a0,a5
    80010778:	60e6                	ld	ra,88(sp)
    8001077a:	6446                	ld	s0,80(sp)
    8001077c:	6125                	addi	sp,sp,96
    8001077e:	8082                	ret

0000000080010780 <_ntoa_format>:
// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx,
                           size_t maxlen, char *buf, size_t len, bool negative,
                           unsigned int base, unsigned int prec,
                           unsigned int width, unsigned int flags)
{
    80010780:	715d                	addi	sp,sp,-80
    80010782:	e486                	sd	ra,72(sp)
    80010784:	e0a2                	sd	s0,64(sp)
    80010786:	0880                	addi	s0,sp,80
    80010788:	fea43423          	sd	a0,-24(s0)
    8001078c:	feb43023          	sd	a1,-32(s0)
    80010790:	fcc43c23          	sd	a2,-40(s0)
    80010794:	fcd43823          	sd	a3,-48(s0)
    80010798:	fce43423          	sd	a4,-56(s0)
    8001079c:	fcf43023          	sd	a5,-64(s0)
    800107a0:	87c2                	mv	a5,a6
    800107a2:	8746                	mv	a4,a7
    800107a4:	faf40fa3          	sb	a5,-65(s0)
    800107a8:	87ba                	mv	a5,a4
    800107aa:	faf42c23          	sw	a5,-72(s0)
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
    800107ae:	481c                	lw	a5,16(s0)
    800107b0:	8b89                	andi	a5,a5,2
    800107b2:	2781                	sext.w	a5,a5
    800107b4:	ebd1                	bnez	a5,80010848 <_ntoa_format+0xc8>
        if (width && (flags & FLAGS_ZEROPAD) &&
    800107b6:	441c                	lw	a5,8(s0)
    800107b8:	2781                	sext.w	a5,a5
    800107ba:	cf9d                	beqz	a5,800107f8 <_ntoa_format+0x78>
    800107bc:	481c                	lw	a5,16(s0)
    800107be:	8b85                	andi	a5,a5,1
    800107c0:	2781                	sext.w	a5,a5
    800107c2:	cb9d                	beqz	a5,800107f8 <_ntoa_format+0x78>
    800107c4:	fbf44783          	lbu	a5,-65(s0)
    800107c8:	0ff7f793          	andi	a5,a5,255
    800107cc:	e789                	bnez	a5,800107d6 <_ntoa_format+0x56>
            (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    800107ce:	481c                	lw	a5,16(s0)
    800107d0:	8bb1                	andi	a5,a5,12
    800107d2:	2781                	sext.w	a5,a5
    800107d4:	c395                	beqz	a5,800107f8 <_ntoa_format+0x78>
            width--;
    800107d6:	441c                	lw	a5,8(s0)
    800107d8:	37fd                	addiw	a5,a5,-1
    800107da:	c41c                	sw	a5,8(s0)
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800107dc:	a831                	j	800107f8 <_ntoa_format+0x78>
            buf[len++] = '0';
    800107de:	fc043783          	ld	a5,-64(s0)
    800107e2:	00178713          	addi	a4,a5,1
    800107e6:	fce43023          	sd	a4,-64(s0)
    800107ea:	fc843703          	ld	a4,-56(s0)
    800107ee:	97ba                	add	a5,a5,a4
    800107f0:	03000713          	li	a4,48
    800107f4:	00e78023          	sb	a4,0(a5)
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800107f8:	00046783          	lwu	a5,0(s0)
    800107fc:	fc043703          	ld	a4,-64(s0)
    80010800:	02f77563          	bgeu	a4,a5,8001082a <_ntoa_format+0xaa>
    80010804:	fc043703          	ld	a4,-64(s0)
    80010808:	47fd                	li	a5,31
    8001080a:	fce7fae3          	bgeu	a5,a4,800107de <_ntoa_format+0x5e>
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    8001080e:	a831                	j	8001082a <_ntoa_format+0xaa>
               (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
    80010810:	fc043783          	ld	a5,-64(s0)
    80010814:	00178713          	addi	a4,a5,1
    80010818:	fce43023          	sd	a4,-64(s0)
    8001081c:	fc843703          	ld	a4,-56(s0)
    80010820:	97ba                	add	a5,a5,a4
    80010822:	03000713          	li	a4,48
    80010826:	00e78023          	sb	a4,0(a5)
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    8001082a:	481c                	lw	a5,16(s0)
    8001082c:	8b85                	andi	a5,a5,1
    8001082e:	2781                	sext.w	a5,a5
    80010830:	cf81                	beqz	a5,80010848 <_ntoa_format+0xc8>
    80010832:	00846783          	lwu	a5,8(s0)
    80010836:	fc043703          	ld	a4,-64(s0)
    8001083a:	00f77763          	bgeu	a4,a5,80010848 <_ntoa_format+0xc8>
    8001083e:	fc043703          	ld	a4,-64(s0)
    80010842:	47fd                	li	a5,31
    80010844:	fce7f6e3          	bgeu	a5,a4,80010810 <_ntoa_format+0x90>
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
    80010848:	481c                	lw	a5,16(s0)
    8001084a:	8bc1                	andi	a5,a5,16
    8001084c:	2781                	sext.w	a5,a5
    8001084e:	12078363          	beqz	a5,80010974 <_ntoa_format+0x1f4>
        if (!(flags & FLAGS_PRECISION) && len &&
    80010852:	481c                	lw	a5,16(s0)
    80010854:	4007f793          	andi	a5,a5,1024
    80010858:	2781                	sext.w	a5,a5
    8001085a:	e7a1                	bnez	a5,800108a2 <_ntoa_format+0x122>
    8001085c:	fc043783          	ld	a5,-64(s0)
    80010860:	c3a9                	beqz	a5,800108a2 <_ntoa_format+0x122>
            ((len == prec) || (len == width))) {
    80010862:	00046783          	lwu	a5,0(s0)
        if (!(flags & FLAGS_PRECISION) && len &&
    80010866:	fc043703          	ld	a4,-64(s0)
    8001086a:	00f70863          	beq	a4,a5,8001087a <_ntoa_format+0xfa>
            ((len == prec) || (len == width))) {
    8001086e:	00846783          	lwu	a5,8(s0)
    80010872:	fc043703          	ld	a4,-64(s0)
    80010876:	02f71663          	bne	a4,a5,800108a2 <_ntoa_format+0x122>
            len--;
    8001087a:	fc043783          	ld	a5,-64(s0)
    8001087e:	17fd                	addi	a5,a5,-1
    80010880:	fcf43023          	sd	a5,-64(s0)
            if (len && (base == 16U)) {
    80010884:	fc043783          	ld	a5,-64(s0)
    80010888:	cf89                	beqz	a5,800108a2 <_ntoa_format+0x122>
    8001088a:	fb842783          	lw	a5,-72(s0)
    8001088e:	0007871b          	sext.w	a4,a5
    80010892:	47c1                	li	a5,16
    80010894:	00f71763          	bne	a4,a5,800108a2 <_ntoa_format+0x122>
                len--;
    80010898:	fc043783          	ld	a5,-64(s0)
    8001089c:	17fd                	addi	a5,a5,-1
    8001089e:	fcf43023          	sd	a5,-64(s0)
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) &&
    800108a2:	fb842783          	lw	a5,-72(s0)
    800108a6:	0007871b          	sext.w	a4,a5
    800108aa:	47c1                	li	a5,16
    800108ac:	02f71a63          	bne	a4,a5,800108e0 <_ntoa_format+0x160>
    800108b0:	481c                	lw	a5,16(s0)
    800108b2:	0207f793          	andi	a5,a5,32
    800108b6:	2781                	sext.w	a5,a5
    800108b8:	e785                	bnez	a5,800108e0 <_ntoa_format+0x160>
    800108ba:	fc043703          	ld	a4,-64(s0)
    800108be:	47fd                	li	a5,31
    800108c0:	02e7e063          	bltu	a5,a4,800108e0 <_ntoa_format+0x160>
            (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'x';
    800108c4:	fc043783          	ld	a5,-64(s0)
    800108c8:	00178713          	addi	a4,a5,1
    800108cc:	fce43023          	sd	a4,-64(s0)
    800108d0:	fc843703          	ld	a4,-56(s0)
    800108d4:	97ba                	add	a5,a5,a4
    800108d6:	07800713          	li	a4,120
    800108da:	00e78023          	sb	a4,0(a5)
    800108de:	a88d                	j	80010950 <_ntoa_format+0x1d0>
        }
        else if ((base == 16U) && (flags & FLAGS_UPPERCASE) &&
    800108e0:	fb842783          	lw	a5,-72(s0)
    800108e4:	0007871b          	sext.w	a4,a5
    800108e8:	47c1                	li	a5,16
    800108ea:	02f71a63          	bne	a4,a5,8001091e <_ntoa_format+0x19e>
    800108ee:	481c                	lw	a5,16(s0)
    800108f0:	0207f793          	andi	a5,a5,32
    800108f4:	2781                	sext.w	a5,a5
    800108f6:	c785                	beqz	a5,8001091e <_ntoa_format+0x19e>
    800108f8:	fc043703          	ld	a4,-64(s0)
    800108fc:	47fd                	li	a5,31
    800108fe:	02e7e063          	bltu	a5,a4,8001091e <_ntoa_format+0x19e>
                 (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'X';
    80010902:	fc043783          	ld	a5,-64(s0)
    80010906:	00178713          	addi	a4,a5,1
    8001090a:	fce43023          	sd	a4,-64(s0)
    8001090e:	fc843703          	ld	a4,-56(s0)
    80010912:	97ba                	add	a5,a5,a4
    80010914:	05800713          	li	a4,88
    80010918:	00e78023          	sb	a4,0(a5)
    8001091c:	a815                	j	80010950 <_ntoa_format+0x1d0>
        }
        else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    8001091e:	fb842783          	lw	a5,-72(s0)
    80010922:	0007871b          	sext.w	a4,a5
    80010926:	4789                	li	a5,2
    80010928:	02f71463          	bne	a4,a5,80010950 <_ntoa_format+0x1d0>
    8001092c:	fc043703          	ld	a4,-64(s0)
    80010930:	47fd                	li	a5,31
    80010932:	00e7ef63          	bltu	a5,a4,80010950 <_ntoa_format+0x1d0>
            buf[len++] = 'b';
    80010936:	fc043783          	ld	a5,-64(s0)
    8001093a:	00178713          	addi	a4,a5,1
    8001093e:	fce43023          	sd	a4,-64(s0)
    80010942:	fc843703          	ld	a4,-56(s0)
    80010946:	97ba                	add	a5,a5,a4
    80010948:	06200713          	li	a4,98
    8001094c:	00e78023          	sb	a4,0(a5)
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80010950:	fc043703          	ld	a4,-64(s0)
    80010954:	47fd                	li	a5,31
    80010956:	00e7ef63          	bltu	a5,a4,80010974 <_ntoa_format+0x1f4>
            buf[len++] = '0';
    8001095a:	fc043783          	ld	a5,-64(s0)
    8001095e:	00178713          	addi	a4,a5,1
    80010962:	fce43023          	sd	a4,-64(s0)
    80010966:	fc843703          	ld	a4,-56(s0)
    8001096a:	97ba                	add	a5,a5,a4
    8001096c:	03000713          	li	a4,48
    80010970:	00e78023          	sb	a4,0(a5)
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80010974:	fc043703          	ld	a4,-64(s0)
    80010978:	47fd                	li	a5,31
    8001097a:	06e7e863          	bltu	a5,a4,800109ea <_ntoa_format+0x26a>
        if (negative) {
    8001097e:	fbf44783          	lbu	a5,-65(s0)
    80010982:	0ff7f793          	andi	a5,a5,255
    80010986:	cf99                	beqz	a5,800109a4 <_ntoa_format+0x224>
            buf[len++] = '-';
    80010988:	fc043783          	ld	a5,-64(s0)
    8001098c:	00178713          	addi	a4,a5,1
    80010990:	fce43023          	sd	a4,-64(s0)
    80010994:	fc843703          	ld	a4,-56(s0)
    80010998:	97ba                	add	a5,a5,a4
    8001099a:	02d00713          	li	a4,45
    8001099e:	00e78023          	sb	a4,0(a5)
    800109a2:	a0a1                	j	800109ea <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_PLUS) {
    800109a4:	481c                	lw	a5,16(s0)
    800109a6:	8b91                	andi	a5,a5,4
    800109a8:	2781                	sext.w	a5,a5
    800109aa:	cf99                	beqz	a5,800109c8 <_ntoa_format+0x248>
            buf[len++] = '+';  // ignore the space if the '+' exists
    800109ac:	fc043783          	ld	a5,-64(s0)
    800109b0:	00178713          	addi	a4,a5,1
    800109b4:	fce43023          	sd	a4,-64(s0)
    800109b8:	fc843703          	ld	a4,-56(s0)
    800109bc:	97ba                	add	a5,a5,a4
    800109be:	02b00713          	li	a4,43
    800109c2:	00e78023          	sb	a4,0(a5)
    800109c6:	a015                	j	800109ea <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_SPACE) {
    800109c8:	481c                	lw	a5,16(s0)
    800109ca:	8ba1                	andi	a5,a5,8
    800109cc:	2781                	sext.w	a5,a5
    800109ce:	cf91                	beqz	a5,800109ea <_ntoa_format+0x26a>
            buf[len++] = ' ';
    800109d0:	fc043783          	ld	a5,-64(s0)
    800109d4:	00178713          	addi	a4,a5,1
    800109d8:	fce43023          	sd	a4,-64(s0)
    800109dc:	fc843703          	ld	a4,-56(s0)
    800109e0:	97ba                	add	a5,a5,a4
    800109e2:	02000713          	li	a4,32
    800109e6:	00e78023          	sb	a4,0(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    800109ea:	4818                	lw	a4,16(s0)
    800109ec:	441c                	lw	a5,8(s0)
    800109ee:	88ba                	mv	a7,a4
    800109f0:	883e                	mv	a6,a5
    800109f2:	fc043783          	ld	a5,-64(s0)
    800109f6:	fc843703          	ld	a4,-56(s0)
    800109fa:	fd043683          	ld	a3,-48(s0)
    800109fe:	fd843603          	ld	a2,-40(s0)
    80010a02:	fe043583          	ld	a1,-32(s0)
    80010a06:	fe843503          	ld	a0,-24(s0)
    80010a0a:	c65ff0ef          	jal	ra,8001066e <_out_rev>
    80010a0e:	87aa                	mv	a5,a0
}
    80010a10:	853e                	mv	a0,a5
    80010a12:	60a6                	ld	ra,72(sp)
    80010a14:	6406                	ld	s0,64(sp)
    80010a16:	6161                	addi	sp,sp,80
    80010a18:	8082                	ret

0000000080010a1a <_ntoa_long>:
// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
                         size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec,
                         unsigned int width, unsigned int flags)
{
    80010a1a:	7135                	addi	sp,sp,-160
    80010a1c:	ed06                	sd	ra,152(sp)
    80010a1e:	e922                	sd	s0,144(sp)
    80010a20:	1100                	addi	s0,sp,160
    80010a22:	faa43c23          	sd	a0,-72(s0)
    80010a26:	fab43823          	sd	a1,-80(s0)
    80010a2a:	fac43423          	sd	a2,-88(s0)
    80010a2e:	fad43023          	sd	a3,-96(s0)
    80010a32:	f8e43c23          	sd	a4,-104(s0)
    80010a36:	f9043423          	sd	a6,-120(s0)
    80010a3a:	8746                	mv	a4,a7
    80010a3c:	f8f40ba3          	sb	a5,-105(s0)
    80010a40:	87ba                	mv	a5,a4
    80010a42:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80010a46:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80010a4a:	f9843783          	ld	a5,-104(s0)
    80010a4e:	e781                	bnez	a5,80010a56 <_ntoa_long+0x3c>
        flags &= ~FLAGS_HASH;
    80010a50:	441c                	lw	a5,8(s0)
    80010a52:	9bbd                	andi	a5,a5,-17
    80010a54:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80010a56:	441c                	lw	a5,8(s0)
    80010a58:	4007f793          	andi	a5,a5,1024
    80010a5c:	2781                	sext.w	a5,a5
    80010a5e:	c781                	beqz	a5,80010a66 <_ntoa_long+0x4c>
    80010a60:	f9843783          	ld	a5,-104(s0)
    80010a64:	c7c1                	beqz	a5,80010aec <_ntoa_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80010a66:	f9843703          	ld	a4,-104(s0)
    80010a6a:	f8843783          	ld	a5,-120(s0)
    80010a6e:	02f777b3          	remu	a5,a4,a5
    80010a72:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80010a76:	fe744783          	lbu	a5,-25(s0)
    80010a7a:	0ff7f713          	andi	a4,a5,255
    80010a7e:	47a5                	li	a5,9
    80010a80:	00e7e963          	bltu	a5,a4,80010a92 <_ntoa_long+0x78>
    80010a84:	fe744783          	lbu	a5,-25(s0)
    80010a88:	0307879b          	addiw	a5,a5,48
    80010a8c:	0ff7f793          	andi	a5,a5,255
    80010a90:	a01d                	j	80010ab6 <_ntoa_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80010a92:	441c                	lw	a5,8(s0)
    80010a94:	0207f793          	andi	a5,a5,32
    80010a98:	2781                	sext.w	a5,a5
    80010a9a:	c781                	beqz	a5,80010aa2 <_ntoa_long+0x88>
    80010a9c:	04100793          	li	a5,65
    80010aa0:	a019                	j	80010aa6 <_ntoa_long+0x8c>
    80010aa2:	06100793          	li	a5,97
    80010aa6:	fe744703          	lbu	a4,-25(s0)
    80010aaa:	9fb9                	addw	a5,a5,a4
    80010aac:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80010ab0:	37d9                	addiw	a5,a5,-10
    80010ab2:	0ff7f793          	andi	a5,a5,255
    80010ab6:	fe843703          	ld	a4,-24(s0)
    80010aba:	00170693          	addi	a3,a4,1
    80010abe:	fed43423          	sd	a3,-24(s0)
    80010ac2:	ff040693          	addi	a3,s0,-16
    80010ac6:	9736                	add	a4,a4,a3
    80010ac8:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010acc:	f9843703          	ld	a4,-104(s0)
    80010ad0:	f8843783          	ld	a5,-120(s0)
    80010ad4:	02f757b3          	divu	a5,a4,a5
    80010ad8:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010adc:	f9843783          	ld	a5,-104(s0)
    80010ae0:	c791                	beqz	a5,80010aec <_ntoa_long+0xd2>
    80010ae2:	fe843703          	ld	a4,-24(s0)
    80010ae6:	47fd                	li	a5,31
    80010ae8:	f6e7ffe3          	bgeu	a5,a4,80010a66 <_ntoa_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010aec:	f8843783          	ld	a5,-120(s0)
    80010af0:	0007861b          	sext.w	a2,a5
    80010af4:	f9744683          	lbu	a3,-105(s0)
    80010af8:	fc040713          	addi	a4,s0,-64
    80010afc:	441c                	lw	a5,8(s0)
    80010afe:	e83e                	sd	a5,16(sp)
    80010b00:	401c                	lw	a5,0(s0)
    80010b02:	e43e                	sd	a5,8(sp)
    80010b04:	f9042783          	lw	a5,-112(s0)
    80010b08:	e03e                	sd	a5,0(sp)
    80010b0a:	88b2                	mv	a7,a2
    80010b0c:	8836                	mv	a6,a3
    80010b0e:	fe843783          	ld	a5,-24(s0)
    80010b12:	fa043683          	ld	a3,-96(s0)
    80010b16:	fa843603          	ld	a2,-88(s0)
    80010b1a:	fb043583          	ld	a1,-80(s0)
    80010b1e:	fb843503          	ld	a0,-72(s0)
    80010b22:	c5fff0ef          	jal	ra,80010780 <_ntoa_format>
    80010b26:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010b28:	853e                	mv	a0,a5
    80010b2a:	60ea                	ld	ra,152(sp)
    80010b2c:	644a                	ld	s0,144(sp)
    80010b2e:	610d                	addi	sp,sp,160
    80010b30:	8082                	ret

0000000080010b32 <_ntoa_long_long>:
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
                              size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base,
                              unsigned int prec, unsigned int width,
                              unsigned int flags)
{
    80010b32:	7135                	addi	sp,sp,-160
    80010b34:	ed06                	sd	ra,152(sp)
    80010b36:	e922                	sd	s0,144(sp)
    80010b38:	1100                	addi	s0,sp,160
    80010b3a:	faa43c23          	sd	a0,-72(s0)
    80010b3e:	fab43823          	sd	a1,-80(s0)
    80010b42:	fac43423          	sd	a2,-88(s0)
    80010b46:	fad43023          	sd	a3,-96(s0)
    80010b4a:	f8e43c23          	sd	a4,-104(s0)
    80010b4e:	f9043423          	sd	a6,-120(s0)
    80010b52:	8746                	mv	a4,a7
    80010b54:	f8f40ba3          	sb	a5,-105(s0)
    80010b58:	87ba                	mv	a5,a4
    80010b5a:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80010b5e:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80010b62:	f9843783          	ld	a5,-104(s0)
    80010b66:	e781                	bnez	a5,80010b6e <_ntoa_long_long+0x3c>
        flags &= ~FLAGS_HASH;
    80010b68:	441c                	lw	a5,8(s0)
    80010b6a:	9bbd                	andi	a5,a5,-17
    80010b6c:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    80010b6e:	441c                	lw	a5,8(s0)
    80010b70:	4007f793          	andi	a5,a5,1024
    80010b74:	2781                	sext.w	a5,a5
    80010b76:	c781                	beqz	a5,80010b7e <_ntoa_long_long+0x4c>
    80010b78:	f9843783          	ld	a5,-104(s0)
    80010b7c:	c7c1                	beqz	a5,80010c04 <_ntoa_long_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80010b7e:	f9843703          	ld	a4,-104(s0)
    80010b82:	f8843783          	ld	a5,-120(s0)
    80010b86:	02f777b3          	remu	a5,a4,a5
    80010b8a:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80010b8e:	fe744783          	lbu	a5,-25(s0)
    80010b92:	0ff7f713          	andi	a4,a5,255
    80010b96:	47a5                	li	a5,9
    80010b98:	00e7e963          	bltu	a5,a4,80010baa <_ntoa_long_long+0x78>
    80010b9c:	fe744783          	lbu	a5,-25(s0)
    80010ba0:	0307879b          	addiw	a5,a5,48
    80010ba4:	0ff7f793          	andi	a5,a5,255
    80010ba8:	a01d                	j	80010bce <_ntoa_long_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80010baa:	441c                	lw	a5,8(s0)
    80010bac:	0207f793          	andi	a5,a5,32
    80010bb0:	2781                	sext.w	a5,a5
    80010bb2:	c781                	beqz	a5,80010bba <_ntoa_long_long+0x88>
    80010bb4:	04100793          	li	a5,65
    80010bb8:	a019                	j	80010bbe <_ntoa_long_long+0x8c>
    80010bba:	06100793          	li	a5,97
    80010bbe:	fe744703          	lbu	a4,-25(s0)
    80010bc2:	9fb9                	addw	a5,a5,a4
    80010bc4:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80010bc8:	37d9                	addiw	a5,a5,-10
    80010bca:	0ff7f793          	andi	a5,a5,255
    80010bce:	fe843703          	ld	a4,-24(s0)
    80010bd2:	00170693          	addi	a3,a4,1
    80010bd6:	fed43423          	sd	a3,-24(s0)
    80010bda:	ff040693          	addi	a3,s0,-16
    80010bde:	9736                	add	a4,a4,a3
    80010be0:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010be4:	f9843703          	ld	a4,-104(s0)
    80010be8:	f8843783          	ld	a5,-120(s0)
    80010bec:	02f757b3          	divu	a5,a4,a5
    80010bf0:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010bf4:	f9843783          	ld	a5,-104(s0)
    80010bf8:	c791                	beqz	a5,80010c04 <_ntoa_long_long+0xd2>
    80010bfa:	fe843703          	ld	a4,-24(s0)
    80010bfe:	47fd                	li	a5,31
    80010c00:	f6e7ffe3          	bgeu	a5,a4,80010b7e <_ntoa_long_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010c04:	f8843783          	ld	a5,-120(s0)
    80010c08:	0007861b          	sext.w	a2,a5
    80010c0c:	f9744683          	lbu	a3,-105(s0)
    80010c10:	fc040713          	addi	a4,s0,-64
    80010c14:	441c                	lw	a5,8(s0)
    80010c16:	e83e                	sd	a5,16(sp)
    80010c18:	401c                	lw	a5,0(s0)
    80010c1a:	e43e                	sd	a5,8(sp)
    80010c1c:	f9042783          	lw	a5,-112(s0)
    80010c20:	e03e                	sd	a5,0(sp)
    80010c22:	88b2                	mv	a7,a2
    80010c24:	8836                	mv	a6,a3
    80010c26:	fe843783          	ld	a5,-24(s0)
    80010c2a:	fa043683          	ld	a3,-96(s0)
    80010c2e:	fa843603          	ld	a2,-88(s0)
    80010c32:	fb043583          	ld	a1,-80(s0)
    80010c36:	fb843503          	ld	a0,-72(s0)
    80010c3a:	b47ff0ef          	jal	ra,80010780 <_ntoa_format>
    80010c3e:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010c40:	853e                	mv	a0,a5
    80010c42:	60ea                	ld	ra,152(sp)
    80010c44:	644a                	ld	s0,144(sp)
    80010c46:	610d                	addi	sp,sp,160
    80010c48:	8082                	ret

0000000080010c4a <_ftoa>:

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80010c4a:	7135                	addi	sp,sp,-160
    80010c4c:	ed06                	sd	ra,152(sp)
    80010c4e:	e922                	sd	s0,144(sp)
    80010c50:	1100                	addi	s0,sp,160
    80010c52:	f8a43c23          	sd	a0,-104(s0)
    80010c56:	f8b43823          	sd	a1,-112(s0)
    80010c5a:	f8c43423          	sd	a2,-120(s0)
    80010c5e:	f8d43023          	sd	a3,-128(s0)
    80010c62:	f6a43c27          	fsd	fa0,-136(s0)
    80010c66:	863a                	mv	a2,a4
    80010c68:	86be                	mv	a3,a5
    80010c6a:	8742                	mv	a4,a6
    80010c6c:	87b2                	mv	a5,a2
    80010c6e:	f6f42a23          	sw	a5,-140(s0)
    80010c72:	87b6                	mv	a5,a3
    80010c74:	f6f42823          	sw	a5,-144(s0)
    80010c78:	87ba                	mv	a5,a4
    80010c7a:	f6f42623          	sw	a5,-148(s0)
    char buf[PRINTF_FTOA_BUFFER_SIZE];
    size_t len                  = 0U;
    80010c7e:	fe043423          	sd	zero,-24(s0)
    double diff                 = 0.0;
    80010c82:	fc043423          	sd	zero,-56(s0)
    static const double pow10[] = {1,         10,        100,     1000,
                                   10000,     100000,    1000000, 10000000,
                                   100000000, 1000000000};

    // test for special values
    if (value != value)
    80010c86:	f7843707          	fld	fa4,-136(s0)
    80010c8a:	f7843787          	fld	fa5,-136(s0)
    80010c8e:	a2f727d3          	feq.d	a5,fa4,fa5
    80010c92:	eb85                	bnez	a5,80010cc2 <_ftoa+0x78>
        return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
    80010c94:	f6c42703          	lw	a4,-148(s0)
    80010c98:	f7042783          	lw	a5,-144(s0)
    80010c9c:	88ba                	mv	a7,a4
    80010c9e:	883e                	mv	a6,a5
    80010ca0:	478d                	li	a5,3
    80010ca2:	00013717          	auipc	a4,0x13
    80010ca6:	38e70713          	addi	a4,a4,910 # 80024030 <SYSCALLS+0x30>
    80010caa:	f8043683          	ld	a3,-128(s0)
    80010cae:	f8843603          	ld	a2,-120(s0)
    80010cb2:	f9043583          	ld	a1,-112(s0)
    80010cb6:	f9843503          	ld	a0,-104(s0)
    80010cba:	9b5ff0ef          	jal	ra,8001066e <_out_rev>
    80010cbe:	87aa                	mv	a5,a0
    80010cc0:	a1f1                	j	8001118c <_ftoa+0x542>
    if (value < -DBL_MAX)
    80010cc2:	f7843707          	fld	fa4,-136(s0)
    80010cc6:	00013797          	auipc	a5,0x13
    80010cca:	5ba78793          	addi	a5,a5,1466 # 80024280 <pow10.0+0x50>
    80010cce:	239c                	fld	fa5,0(a5)
    80010cd0:	a2f717d3          	flt.d	a5,fa4,fa5
    80010cd4:	cb85                	beqz	a5,80010d04 <_ftoa+0xba>
        return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    80010cd6:	f6c42703          	lw	a4,-148(s0)
    80010cda:	f7042783          	lw	a5,-144(s0)
    80010cde:	88ba                	mv	a7,a4
    80010ce0:	883e                	mv	a6,a5
    80010ce2:	4791                	li	a5,4
    80010ce4:	00013717          	auipc	a4,0x13
    80010ce8:	35470713          	addi	a4,a4,852 # 80024038 <SYSCALLS+0x38>
    80010cec:	f8043683          	ld	a3,-128(s0)
    80010cf0:	f8843603          	ld	a2,-120(s0)
    80010cf4:	f9043583          	ld	a1,-112(s0)
    80010cf8:	f9843503          	ld	a0,-104(s0)
    80010cfc:	973ff0ef          	jal	ra,8001066e <_out_rev>
    80010d00:	87aa                	mv	a5,a0
    80010d02:	a169                	j	8001118c <_ftoa+0x542>
    if (value > DBL_MAX)
    80010d04:	f7843707          	fld	fa4,-136(s0)
    80010d08:	00013797          	auipc	a5,0x13
    80010d0c:	58078793          	addi	a5,a5,1408 # 80024288 <pow10.0+0x58>
    80010d10:	239c                	fld	fa5,0(a5)
    80010d12:	a2e797d3          	flt.d	a5,fa5,fa4
    80010d16:	cba9                	beqz	a5,80010d68 <_ftoa+0x11e>
        return _out_rev(out, buffer, idx, maxlen,
                        (flags & FLAGS_PLUS) ? "fni+" : "fni",
    80010d18:	f6c42783          	lw	a5,-148(s0)
    80010d1c:	8b91                	andi	a5,a5,4
    80010d1e:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010d20:	c791                	beqz	a5,80010d2c <_ftoa+0xe2>
    80010d22:	00013717          	auipc	a4,0x13
    80010d26:	31e70713          	addi	a4,a4,798 # 80024040 <SYSCALLS+0x40>
    80010d2a:	a029                	j	80010d34 <_ftoa+0xea>
    80010d2c:	00013717          	auipc	a4,0x13
    80010d30:	31c70713          	addi	a4,a4,796 # 80024048 <SYSCALLS+0x48>
                        (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
    80010d34:	f6c42783          	lw	a5,-148(s0)
    80010d38:	8b91                	andi	a5,a5,4
    80010d3a:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010d3c:	c399                	beqz	a5,80010d42 <_ftoa+0xf8>
    80010d3e:	4791                	li	a5,4
    80010d40:	a011                	j	80010d44 <_ftoa+0xfa>
    80010d42:	478d                	li	a5,3
    80010d44:	f6c42603          	lw	a2,-148(s0)
    80010d48:	f7042683          	lw	a3,-144(s0)
    80010d4c:	88b2                	mv	a7,a2
    80010d4e:	8836                	mv	a6,a3
    80010d50:	f8043683          	ld	a3,-128(s0)
    80010d54:	f8843603          	ld	a2,-120(s0)
    80010d58:	f9043583          	ld	a1,-112(s0)
    80010d5c:	f9843503          	ld	a0,-104(s0)
    80010d60:	90fff0ef          	jal	ra,8001066e <_out_rev>
    80010d64:	87aa                	mv	a5,a0
    80010d66:	a11d                	j	8001118c <_ftoa+0x542>

    // test for very large values
    // standard printf behavior is to print EVERY whole number digit -- which
    // could be 100s of characters overflowing your buffers == bad
    if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
    80010d68:	f7843707          	fld	fa4,-136(s0)
    80010d6c:	00013797          	auipc	a5,0x13
    80010d70:	52478793          	addi	a5,a5,1316 # 80024290 <pow10.0+0x60>
    80010d74:	239c                	fld	fa5,0(a5)
    80010d76:	a2e797d3          	flt.d	a5,fa5,fa4
    80010d7a:	eb99                	bnez	a5,80010d90 <_ftoa+0x146>
    80010d7c:	f7843707          	fld	fa4,-136(s0)
    80010d80:	00013797          	auipc	a5,0x13
    80010d84:	51878793          	addi	a5,a5,1304 # 80024298 <pow10.0+0x68>
    80010d88:	239c                	fld	fa5,0(a5)
    80010d8a:	a2f717d3          	flt.d	a5,fa4,fa5
    80010d8e:	c795                	beqz	a5,80010dba <_ftoa+0x170>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80010d90:	f6c42683          	lw	a3,-148(s0)
    80010d94:	f7042783          	lw	a5,-144(s0)
    80010d98:	f7442703          	lw	a4,-140(s0)
    80010d9c:	8836                	mv	a6,a3
    80010d9e:	f7843507          	fld	fa0,-136(s0)
    80010da2:	f8043683          	ld	a3,-128(s0)
    80010da6:	f8843603          	ld	a2,-120(s0)
    80010daa:	f9043583          	ld	a1,-112(s0)
    80010dae:	f9843503          	ld	a0,-104(s0)
    80010db2:	3e4000ef          	jal	ra,80011196 <_etoa>
    80010db6:	87aa                	mv	a5,a0
    80010db8:	aed1                	j	8001118c <_ftoa+0x542>
        return 0U;
#endif
    }

    // test for negative
    bool negative = false;
    80010dba:	fe0403a3          	sb	zero,-25(s0)
    if (value < 0) {
    80010dbe:	f7843787          	fld	fa5,-136(s0)
    80010dc2:	f2000753          	fmv.d.x	fa4,zero
    80010dc6:	a2e797d3          	flt.d	a5,fa5,fa4
    80010dca:	cf81                	beqz	a5,80010de2 <_ftoa+0x198>
        negative = true;
    80010dcc:	4785                	li	a5,1
    80010dce:	fef403a3          	sb	a5,-25(s0)
        value    = 0 - value;
    80010dd2:	f2000753          	fmv.d.x	fa4,zero
    80010dd6:	f7843787          	fld	fa5,-136(s0)
    80010dda:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010dde:	f6f43c27          	fsd	fa5,-136(s0)
    }

    // set default precision, if not set explicitly
    if (!(flags & FLAGS_PRECISION)) {
    80010de2:	f6c42783          	lw	a5,-148(s0)
    80010de6:	4007f793          	andi	a5,a5,1024
    80010dea:	2781                	sext.w	a5,a5
    80010dec:	e79d                	bnez	a5,80010e1a <_ftoa+0x1d0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80010dee:	4799                	li	a5,6
    80010df0:	f6f42a23          	sw	a5,-140(s0)
    }
    // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010df4:	a01d                	j	80010e1a <_ftoa+0x1d0>
        buf[len++] = '0';
    80010df6:	fe843783          	ld	a5,-24(s0)
    80010dfa:	00178713          	addi	a4,a5,1
    80010dfe:	fee43423          	sd	a4,-24(s0)
    80010e02:	ff040713          	addi	a4,s0,-16
    80010e06:	97ba                	add	a5,a5,a4
    80010e08:	03000713          	li	a4,48
    80010e0c:	fae78823          	sb	a4,-80(a5)
        prec--;
    80010e10:	f7442783          	lw	a5,-140(s0)
    80010e14:	37fd                	addiw	a5,a5,-1
    80010e16:	f6f42a23          	sw	a5,-140(s0)
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010e1a:	fe843703          	ld	a4,-24(s0)
    80010e1e:	47fd                	li	a5,31
    80010e20:	00e7e963          	bltu	a5,a4,80010e32 <_ftoa+0x1e8>
    80010e24:	f7442783          	lw	a5,-140(s0)
    80010e28:	0007871b          	sext.w	a4,a5
    80010e2c:	47a5                	li	a5,9
    80010e2e:	fce7e4e3          	bltu	a5,a4,80010df6 <_ftoa+0x1ac>
    }

    int whole          = (int)value;
    80010e32:	f7843787          	fld	fa5,-136(s0)
    80010e36:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80010e3a:	fef42023          	sw	a5,-32(s0)
    double tmp         = (value - whole) * pow10[prec];
    80010e3e:	fe042783          	lw	a5,-32(s0)
    80010e42:	d20787d3          	fcvt.d.w	fa5,a5
    80010e46:	f7843707          	fld	fa4,-136(s0)
    80010e4a:	0af77753          	fsub.d	fa4,fa4,fa5
    80010e4e:	00013717          	auipc	a4,0x13
    80010e52:	3e270713          	addi	a4,a4,994 # 80024230 <pow10.0>
    80010e56:	f7446783          	lwu	a5,-140(s0)
    80010e5a:	078e                	slli	a5,a5,0x3
    80010e5c:	97ba                	add	a5,a5,a4
    80010e5e:	239c                	fld	fa5,0(a5)
    80010e60:	12f777d3          	fmul.d	fa5,fa4,fa5
    80010e64:	fcf43027          	fsd	fa5,-64(s0)
    unsigned long frac = (unsigned long)tmp;
    80010e68:	fc043787          	fld	fa5,-64(s0)
    80010e6c:	c23797d3          	fcvt.lu.d	a5,fa5,rtz
    80010e70:	fcf43c23          	sd	a5,-40(s0)
    diff               = tmp - frac;
    80010e74:	fd843783          	ld	a5,-40(s0)
    80010e78:	d237f7d3          	fcvt.d.lu	fa5,a5
    80010e7c:	fc043707          	fld	fa4,-64(s0)
    80010e80:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010e84:	fcf43427          	fsd	fa5,-56(s0)

    if (diff > 0.5) {
    80010e88:	fc843707          	fld	fa4,-56(s0)
    80010e8c:	00013797          	auipc	a5,0x13
    80010e90:	41478793          	addi	a5,a5,1044 # 800242a0 <pow10.0+0x70>
    80010e94:	239c                	fld	fa5,0(a5)
    80010e96:	a2e797d3          	flt.d	a5,fa5,fa4
    80010e9a:	cf95                	beqz	a5,80010ed6 <_ftoa+0x28c>
        ++frac;
    80010e9c:	fd843783          	ld	a5,-40(s0)
    80010ea0:	0785                	addi	a5,a5,1
    80010ea2:	fcf43c23          	sd	a5,-40(s0)
        // handle rollover, e.g. case 0.99 with prec 1 is 1.0
        if (frac >= pow10[prec]) {
    80010ea6:	fd843783          	ld	a5,-40(s0)
    80010eaa:	d237f753          	fcvt.d.lu	fa4,a5
    80010eae:	00013717          	auipc	a4,0x13
    80010eb2:	38270713          	addi	a4,a4,898 # 80024230 <pow10.0>
    80010eb6:	f7446783          	lwu	a5,-140(s0)
    80010eba:	078e                	slli	a5,a5,0x3
    80010ebc:	97ba                	add	a5,a5,a4
    80010ebe:	239c                	fld	fa5,0(a5)
    80010ec0:	a2e787d3          	fle.d	a5,fa5,fa4
    80010ec4:	cf9d                	beqz	a5,80010f02 <_ftoa+0x2b8>
            frac = 0;
    80010ec6:	fc043c23          	sd	zero,-40(s0)
            ++whole;
    80010eca:	fe042783          	lw	a5,-32(s0)
    80010ece:	2785                	addiw	a5,a5,1
    80010ed0:	fef42023          	sw	a5,-32(s0)
    80010ed4:	a03d                	j	80010f02 <_ftoa+0x2b8>
        }
    }
    else if (diff < 0.5) {
    80010ed6:	fc843707          	fld	fa4,-56(s0)
    80010eda:	00013797          	auipc	a5,0x13
    80010ede:	3c678793          	addi	a5,a5,966 # 800242a0 <pow10.0+0x70>
    80010ee2:	239c                	fld	fa5,0(a5)
    80010ee4:	a2f717d3          	flt.d	a5,fa4,fa5
    80010ee8:	ef89                	bnez	a5,80010f02 <_ftoa+0x2b8>
    }
    else if ((frac == 0U) || (frac & 1U)) {
    80010eea:	fd843783          	ld	a5,-40(s0)
    80010eee:	c789                	beqz	a5,80010ef8 <_ftoa+0x2ae>
    80010ef0:	fd843783          	ld	a5,-40(s0)
    80010ef4:	8b85                	andi	a5,a5,1
    80010ef6:	c791                	beqz	a5,80010f02 <_ftoa+0x2b8>
        // if halfway, round up if odd OR if last digit is 0
        ++frac;
    80010ef8:	fd843783          	ld	a5,-40(s0)
    80010efc:	0785                	addi	a5,a5,1
    80010efe:	fcf43c23          	sd	a5,-40(s0)
    }

    if (prec == 0U) {
    80010f02:	f7442783          	lw	a5,-140(s0)
    80010f06:	2781                	sext.w	a5,a5
    80010f08:	e3bd                	bnez	a5,80010f6e <_ftoa+0x324>
        diff = value - (double)whole;
    80010f0a:	fe042783          	lw	a5,-32(s0)
    80010f0e:	d20787d3          	fcvt.d.w	fa5,a5
    80010f12:	f7843707          	fld	fa4,-136(s0)
    80010f16:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010f1a:	fcf43427          	fsd	fa5,-56(s0)
        if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    80010f1e:	fc843707          	fld	fa4,-56(s0)
    80010f22:	00013797          	auipc	a5,0x13
    80010f26:	37e78793          	addi	a5,a5,894 # 800242a0 <pow10.0+0x70>
    80010f2a:	239c                	fld	fa5,0(a5)
    80010f2c:	a2f717d3          	flt.d	a5,fa4,fa5
    80010f30:	00f037b3          	snez	a5,a5
    80010f34:	0ff7f793          	andi	a5,a5,255
    80010f38:	0017c793          	xori	a5,a5,1
    80010f3c:	0ff7f793          	andi	a5,a5,255
    80010f40:	eb99                	bnez	a5,80010f56 <_ftoa+0x30c>
    80010f42:	fc843707          	fld	fa4,-56(s0)
    80010f46:	00013797          	auipc	a5,0x13
    80010f4a:	35a78793          	addi	a5,a5,858 # 800242a0 <pow10.0+0x70>
    80010f4e:	239c                	fld	fa5,0(a5)
    80010f50:	a2e797d3          	flt.d	a5,fa5,fa4
    80010f54:	cbf1                	beqz	a5,80011028 <_ftoa+0x3de>
    80010f56:	fe042783          	lw	a5,-32(s0)
    80010f5a:	8b85                	andi	a5,a5,1
    80010f5c:	2781                	sext.w	a5,a5
    80010f5e:	10078863          	beqz	a5,8001106e <_ftoa+0x424>
            // exactly 0.5 and ODD, then round up
            // 1.5 -> 2, but 2.5 -> 2
            ++whole;
    80010f62:	fe042783          	lw	a5,-32(s0)
    80010f66:	2785                	addiw	a5,a5,1
    80010f68:	fef42023          	sw	a5,-32(s0)
    80010f6c:	a209                	j	8001106e <_ftoa+0x424>
        }
    }
    else {
        unsigned int count = prec;
    80010f6e:	f7442783          	lw	a5,-140(s0)
    80010f72:	fcf42a23          	sw	a5,-44(s0)
        // now do fractional part, as an unsigned number
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010f76:	a0b1                	j	80010fc2 <_ftoa+0x378>
            --count;
    80010f78:	fd442783          	lw	a5,-44(s0)
    80010f7c:	37fd                	addiw	a5,a5,-1
    80010f7e:	fcf42a23          	sw	a5,-44(s0)
            buf[len++] = (char)(48U + (frac % 10U));
    80010f82:	fd843703          	ld	a4,-40(s0)
    80010f86:	47a9                	li	a5,10
    80010f88:	02f777b3          	remu	a5,a4,a5
    80010f8c:	0ff7f713          	andi	a4,a5,255
    80010f90:	fe843783          	ld	a5,-24(s0)
    80010f94:	00178693          	addi	a3,a5,1
    80010f98:	fed43423          	sd	a3,-24(s0)
    80010f9c:	0307071b          	addiw	a4,a4,48
    80010fa0:	0ff77713          	andi	a4,a4,255
    80010fa4:	ff040693          	addi	a3,s0,-16
    80010fa8:	97b6                	add	a5,a5,a3
    80010faa:	fae78823          	sb	a4,-80(a5)
            if (!(frac /= 10U)) {
    80010fae:	fd843703          	ld	a4,-40(s0)
    80010fb2:	47a9                	li	a5,10
    80010fb4:	02f757b3          	divu	a5,a4,a5
    80010fb8:	fcf43c23          	sd	a5,-40(s0)
    80010fbc:	fd843783          	ld	a5,-40(s0)
    80010fc0:	c799                	beqz	a5,80010fce <_ftoa+0x384>
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010fc2:	fe843703          	ld	a4,-24(s0)
    80010fc6:	47fd                	li	a5,31
    80010fc8:	fae7f8e3          	bgeu	a5,a4,80010f78 <_ftoa+0x32e>
    80010fcc:	a005                	j	80010fec <_ftoa+0x3a2>
                break;
    80010fce:	0001                	nop
            }
        }
        // add extra 0s
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010fd0:	a831                	j	80010fec <_ftoa+0x3a2>
            buf[len++] = '0';
    80010fd2:	fe843783          	ld	a5,-24(s0)
    80010fd6:	00178713          	addi	a4,a5,1
    80010fda:	fee43423          	sd	a4,-24(s0)
    80010fde:	ff040713          	addi	a4,s0,-16
    80010fe2:	97ba                	add	a5,a5,a4
    80010fe4:	03000713          	li	a4,48
    80010fe8:	fae78823          	sb	a4,-80(a5)
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010fec:	fe843703          	ld	a4,-24(s0)
    80010ff0:	47fd                	li	a5,31
    80010ff2:	00e7e963          	bltu	a5,a4,80011004 <_ftoa+0x3ba>
    80010ff6:	fd442783          	lw	a5,-44(s0)
    80010ffa:	fff7871b          	addiw	a4,a5,-1
    80010ffe:	fce42a23          	sw	a4,-44(s0)
    80011002:	fbe1                	bnez	a5,80010fd2 <_ftoa+0x388>
        }
        if (len < PRINTF_FTOA_BUFFER_SIZE) {
    80011004:	fe843703          	ld	a4,-24(s0)
    80011008:	47fd                	li	a5,31
    8001100a:	06e7e263          	bltu	a5,a4,8001106e <_ftoa+0x424>
            // add decimal
            buf[len++] = '.';
    8001100e:	fe843783          	ld	a5,-24(s0)
    80011012:	00178713          	addi	a4,a5,1
    80011016:	fee43423          	sd	a4,-24(s0)
    8001101a:	ff040713          	addi	a4,s0,-16
    8001101e:	97ba                	add	a5,a5,a4
    80011020:	02e00713          	li	a4,46
    80011024:	fae78823          	sb	a4,-80(a5)
        }
    }

    // do whole part, number is reversed
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80011028:	a099                	j	8001106e <_ftoa+0x424>
        buf[len++] = (char)(48 + (whole % 10));
    8001102a:	fe042703          	lw	a4,-32(s0)
    8001102e:	47a9                	li	a5,10
    80011030:	02f767bb          	remw	a5,a4,a5
    80011034:	2781                	sext.w	a5,a5
    80011036:	0ff7f713          	andi	a4,a5,255
    8001103a:	fe843783          	ld	a5,-24(s0)
    8001103e:	00178693          	addi	a3,a5,1
    80011042:	fed43423          	sd	a3,-24(s0)
    80011046:	0307071b          	addiw	a4,a4,48
    8001104a:	0ff77713          	andi	a4,a4,255
    8001104e:	ff040693          	addi	a3,s0,-16
    80011052:	97b6                	add	a5,a5,a3
    80011054:	fae78823          	sb	a4,-80(a5)
        if (!(whole /= 10)) {
    80011058:	fe042703          	lw	a4,-32(s0)
    8001105c:	47a9                	li	a5,10
    8001105e:	02f747bb          	divw	a5,a4,a5
    80011062:	fef42023          	sw	a5,-32(s0)
    80011066:	fe042783          	lw	a5,-32(s0)
    8001106a:	2781                	sext.w	a5,a5
    8001106c:	c799                	beqz	a5,8001107a <_ftoa+0x430>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    8001106e:	fe843703          	ld	a4,-24(s0)
    80011072:	47fd                	li	a5,31
    80011074:	fae7fbe3          	bgeu	a5,a4,8001102a <_ftoa+0x3e0>
    80011078:	a011                	j	8001107c <_ftoa+0x432>
            break;
    8001107a:	0001                	nop
        }
    }

    // pad leading zeros
    if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    8001107c:	f6c42783          	lw	a5,-148(s0)
    80011080:	8b89                	andi	a5,a5,2
    80011082:	2781                	sext.w	a5,a5
    80011084:	e3b5                	bnez	a5,800110e8 <_ftoa+0x49e>
    80011086:	f6c42783          	lw	a5,-148(s0)
    8001108a:	8b85                	andi	a5,a5,1
    8001108c:	2781                	sext.w	a5,a5
    8001108e:	cfa9                	beqz	a5,800110e8 <_ftoa+0x49e>
        if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80011090:	f7042783          	lw	a5,-144(s0)
    80011094:	2781                	sext.w	a5,a5
    80011096:	cf95                	beqz	a5,800110d2 <_ftoa+0x488>
    80011098:	fe744783          	lbu	a5,-25(s0)
    8001109c:	0ff7f793          	andi	a5,a5,255
    800110a0:	e791                	bnez	a5,800110ac <_ftoa+0x462>
    800110a2:	f6c42783          	lw	a5,-148(s0)
    800110a6:	8bb1                	andi	a5,a5,12
    800110a8:	2781                	sext.w	a5,a5
    800110aa:	c785                	beqz	a5,800110d2 <_ftoa+0x488>
            width--;
    800110ac:	f7042783          	lw	a5,-144(s0)
    800110b0:	37fd                	addiw	a5,a5,-1
    800110b2:	f6f42823          	sw	a5,-144(s0)
        }
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800110b6:	a831                	j	800110d2 <_ftoa+0x488>
            buf[len++] = '0';
    800110b8:	fe843783          	ld	a5,-24(s0)
    800110bc:	00178713          	addi	a4,a5,1
    800110c0:	fee43423          	sd	a4,-24(s0)
    800110c4:	ff040713          	addi	a4,s0,-16
    800110c8:	97ba                	add	a5,a5,a4
    800110ca:	03000713          	li	a4,48
    800110ce:	fae78823          	sb	a4,-80(a5)
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    800110d2:	f7046783          	lwu	a5,-144(s0)
    800110d6:	fe843703          	ld	a4,-24(s0)
    800110da:	00f77763          	bgeu	a4,a5,800110e8 <_ftoa+0x49e>
    800110de:	fe843703          	ld	a4,-24(s0)
    800110e2:	47fd                	li	a5,31
    800110e4:	fce7fae3          	bgeu	a5,a4,800110b8 <_ftoa+0x46e>
        }
    }

    if (len < PRINTF_FTOA_BUFFER_SIZE) {
    800110e8:	fe843703          	ld	a4,-24(s0)
    800110ec:	47fd                	li	a5,31
    800110ee:	06e7ea63          	bltu	a5,a4,80011162 <_ftoa+0x518>
        if (negative) {
    800110f2:	fe744783          	lbu	a5,-25(s0)
    800110f6:	0ff7f793          	andi	a5,a5,255
    800110fa:	cf99                	beqz	a5,80011118 <_ftoa+0x4ce>
            buf[len++] = '-';
    800110fc:	fe843783          	ld	a5,-24(s0)
    80011100:	00178713          	addi	a4,a5,1
    80011104:	fee43423          	sd	a4,-24(s0)
    80011108:	ff040713          	addi	a4,s0,-16
    8001110c:	97ba                	add	a5,a5,a4
    8001110e:	02d00713          	li	a4,45
    80011112:	fae78823          	sb	a4,-80(a5)
    80011116:	a0b1                	j	80011162 <_ftoa+0x518>
        }
        else if (flags & FLAGS_PLUS) {
    80011118:	f6c42783          	lw	a5,-148(s0)
    8001111c:	8b91                	andi	a5,a5,4
    8001111e:	2781                	sext.w	a5,a5
    80011120:	cf99                	beqz	a5,8001113e <_ftoa+0x4f4>
            buf[len++] = '+';  // ignore the space if the '+' exists
    80011122:	fe843783          	ld	a5,-24(s0)
    80011126:	00178713          	addi	a4,a5,1
    8001112a:	fee43423          	sd	a4,-24(s0)
    8001112e:	ff040713          	addi	a4,s0,-16
    80011132:	97ba                	add	a5,a5,a4
    80011134:	02b00713          	li	a4,43
    80011138:	fae78823          	sb	a4,-80(a5)
    8001113c:	a01d                	j	80011162 <_ftoa+0x518>
        }
        else if (flags & FLAGS_SPACE) {
    8001113e:	f6c42783          	lw	a5,-148(s0)
    80011142:	8ba1                	andi	a5,a5,8
    80011144:	2781                	sext.w	a5,a5
    80011146:	cf91                	beqz	a5,80011162 <_ftoa+0x518>
            buf[len++] = ' ';
    80011148:	fe843783          	ld	a5,-24(s0)
    8001114c:	00178713          	addi	a4,a5,1
    80011150:	fee43423          	sd	a4,-24(s0)
    80011154:	ff040713          	addi	a4,s0,-16
    80011158:	97ba                	add	a5,a5,a4
    8001115a:	02000713          	li	a4,32
    8001115e:	fae78823          	sb	a4,-80(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    80011162:	f6c42683          	lw	a3,-148(s0)
    80011166:	f7042783          	lw	a5,-144(s0)
    8001116a:	fa040713          	addi	a4,s0,-96
    8001116e:	88b6                	mv	a7,a3
    80011170:	883e                	mv	a6,a5
    80011172:	fe843783          	ld	a5,-24(s0)
    80011176:	f8043683          	ld	a3,-128(s0)
    8001117a:	f8843603          	ld	a2,-120(s0)
    8001117e:	f9043583          	ld	a1,-112(s0)
    80011182:	f9843503          	ld	a0,-104(s0)
    80011186:	ce8ff0ef          	jal	ra,8001066e <_out_rev>
    8001118a:	87aa                	mv	a5,a0
}
    8001118c:	853e                	mv	a0,a5
    8001118e:	60ea                	ld	ra,152(sp)
    80011190:	644a                	ld	s0,144(sp)
    80011192:	610d                	addi	sp,sp,160
    80011194:	8082                	ret

0000000080011196 <_etoa>:
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80011196:	7135                	addi	sp,sp,-160
    80011198:	ed06                	sd	ra,152(sp)
    8001119a:	e922                	sd	s0,144(sp)
    8001119c:	1100                	addi	s0,sp,160
    8001119e:	faa43423          	sd	a0,-88(s0)
    800111a2:	fab43023          	sd	a1,-96(s0)
    800111a6:	f8c43c23          	sd	a2,-104(s0)
    800111aa:	f8d43823          	sd	a3,-112(s0)
    800111ae:	f8a43427          	fsd	fa0,-120(s0)
    800111b2:	863a                	mv	a2,a4
    800111b4:	86be                	mv	a3,a5
    800111b6:	8742                	mv	a4,a6
    800111b8:	87b2                	mv	a5,a2
    800111ba:	f8f42223          	sw	a5,-124(s0)
    800111be:	87b6                	mv	a5,a3
    800111c0:	f8f42023          	sw	a5,-128(s0)
    800111c4:	87ba                	mv	a5,a4
    800111c6:	f6f42e23          	sw	a5,-132(s0)
    // check for NaN and special values
    if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    800111ca:	f8843707          	fld	fa4,-120(s0)
    800111ce:	f8843787          	fld	fa5,-120(s0)
    800111d2:	a2f727d3          	feq.d	a5,fa4,fa5
    800111d6:	c78d                	beqz	a5,80011200 <_etoa+0x6a>
    800111d8:	f8843707          	fld	fa4,-120(s0)
    800111dc:	00013797          	auipc	a5,0x13
    800111e0:	0ac78793          	addi	a5,a5,172 # 80024288 <pow10.0+0x58>
    800111e4:	239c                	fld	fa5,0(a5)
    800111e6:	a2e797d3          	flt.d	a5,fa5,fa4
    800111ea:	eb99                	bnez	a5,80011200 <_etoa+0x6a>
    800111ec:	f8843707          	fld	fa4,-120(s0)
    800111f0:	00013797          	auipc	a5,0x13
    800111f4:	09078793          	addi	a5,a5,144 # 80024280 <pow10.0+0x50>
    800111f8:	239c                	fld	fa5,0(a5)
    800111fa:	a2f717d3          	flt.d	a5,fa4,fa5
    800111fe:	c795                	beqz	a5,8001122a <_etoa+0x94>
        return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80011200:	f7c42683          	lw	a3,-132(s0)
    80011204:	f8042783          	lw	a5,-128(s0)
    80011208:	f8442703          	lw	a4,-124(s0)
    8001120c:	8836                	mv	a6,a3
    8001120e:	f8843507          	fld	fa0,-120(s0)
    80011212:	f9043683          	ld	a3,-112(s0)
    80011216:	f9843603          	ld	a2,-104(s0)
    8001121a:	fa043583          	ld	a1,-96(s0)
    8001121e:	fa843503          	ld	a0,-88(s0)
    80011222:	a29ff0ef          	jal	ra,80010c4a <_ftoa>
    80011226:	87aa                	mv	a5,a0
    80011228:	a11d                	j	8001164e <_etoa+0x4b8>
    }

    // determine the sign
    const bool negative = value < 0;
    8001122a:	f8843787          	fld	fa5,-120(s0)
    8001122e:	f2000753          	fmv.d.x	fa4,zero
    80011232:	a2e797d3          	flt.d	a5,fa5,fa4
    80011236:	00f037b3          	snez	a5,a5
    8001123a:	fef401a3          	sb	a5,-29(s0)
    if (negative) {
    8001123e:	fe344783          	lbu	a5,-29(s0)
    80011242:	0ff7f793          	andi	a5,a5,255
    80011246:	c799                	beqz	a5,80011254 <_etoa+0xbe>
        value = -value;
    80011248:	f8843787          	fld	fa5,-120(s0)
    8001124c:	22f797d3          	fneg.d	fa5,fa5
    80011250:	f8f43427          	fsd	fa5,-120(s0)
    }

    // default precision
    if (!(flags & FLAGS_PRECISION)) {
    80011254:	f7c42783          	lw	a5,-132(s0)
    80011258:	4007f793          	andi	a5,a5,1024
    8001125c:	2781                	sext.w	a5,a5
    8001125e:	e781                	bnez	a5,80011266 <_etoa+0xd0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80011260:	4799                	li	a5,6
    80011262:	f8f42223          	sw	a5,-124(s0)
    union {
        uint64_t U;
        double F;
    } conv;

    conv.F   = value;
    80011266:	f8843787          	fld	fa5,-120(s0)
    8001126a:	faf43c27          	fsd	fa5,-72(s0)
    int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;  // effectively log2
    8001126e:	fb843783          	ld	a5,-72(s0)
    80011272:	93d1                	srli	a5,a5,0x34
    80011274:	2781                	sext.w	a5,a5
    80011276:	7ff7f793          	andi	a5,a5,2047
    8001127a:	2781                	sext.w	a5,a5
    8001127c:	c017879b          	addiw	a5,a5,-1023
    80011280:	fcf42e23          	sw	a5,-36(s0)
    conv.U   = (conv.U & ((1ULL << 52U) - 1U)) |
    80011284:	fb843703          	ld	a4,-72(s0)
    80011288:	57fd                	li	a5,-1
    8001128a:	83b1                	srli	a5,a5,0xc
    8001128c:	8f7d                	and	a4,a4,a5
    8001128e:	3ff00793          	li	a5,1023
    80011292:	17d2                	slli	a5,a5,0x34
    80011294:	8fd9                	or	a5,a5,a4
    80011296:	faf43c23          	sd	a5,-72(s0)
             (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    // now approximate log10 from the log2 integer part and an expansion of ln
    // around 1.5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    8001129a:	fdc42783          	lw	a5,-36(s0)
    8001129e:	d2078753          	fcvt.d.w	fa4,a5
    800112a2:	00013797          	auipc	a5,0x13
    800112a6:	00678793          	addi	a5,a5,6 # 800242a8 <pow10.0+0x78>
    800112aa:	239c                	fld	fa5,0(a5)
    800112ac:	12f77753          	fmul.d	fa4,fa4,fa5
    800112b0:	00013797          	auipc	a5,0x13
    800112b4:	00078793          	mv	a5,a5
    800112b8:	239c                	fld	fa5,0(a5)
    800112ba:	02f77753          	fadd.d	fa4,fa4,fa5
                       (conv.F - 1.5) * 0.289529654602168);
    800112be:	fb843687          	fld	fa3,-72(s0)
    800112c2:	00013797          	auipc	a5,0x13
    800112c6:	ff678793          	addi	a5,a5,-10 # 800242b8 <pow10.0+0x88>
    800112ca:	239c                	fld	fa5,0(a5)
    800112cc:	0af6f6d3          	fsub.d	fa3,fa3,fa5
    800112d0:	00013797          	auipc	a5,0x13
    800112d4:	ff078793          	addi	a5,a5,-16 # 800242c0 <pow10.0+0x90>
    800112d8:	239c                	fld	fa5,0(a5)
    800112da:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    800112de:	02f777d3          	fadd.d	fa5,fa4,fa5
    800112e2:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    800112e6:	fef42623          	sw	a5,-20(s0)
    // now we want to compute 10^expval but we want to be sure it won't overflow
    exp2            = (int)(expval * 3.321928094887362 + 0.5);
    800112ea:	fec42783          	lw	a5,-20(s0)
    800112ee:	d2078753          	fcvt.d.w	fa4,a5
    800112f2:	00013797          	auipc	a5,0x13
    800112f6:	fd678793          	addi	a5,a5,-42 # 800242c8 <pow10.0+0x98>
    800112fa:	239c                	fld	fa5,0(a5)
    800112fc:	12f77753          	fmul.d	fa4,fa4,fa5
    80011300:	00013797          	auipc	a5,0x13
    80011304:	fa078793          	addi	a5,a5,-96 # 800242a0 <pow10.0+0x70>
    80011308:	239c                	fld	fa5,0(a5)
    8001130a:	02f777d3          	fadd.d	fa5,fa4,fa5
    8001130e:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80011312:	fcf42e23          	sw	a5,-36(s0)
    const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    80011316:	fec42783          	lw	a5,-20(s0)
    8001131a:	d2078753          	fcvt.d.w	fa4,a5
    8001131e:	00013797          	auipc	a5,0x13
    80011322:	fb278793          	addi	a5,a5,-78 # 800242d0 <pow10.0+0xa0>
    80011326:	239c                	fld	fa5,0(a5)
    80011328:	12f77753          	fmul.d	fa4,fa4,fa5
    8001132c:	fdc42783          	lw	a5,-36(s0)
    80011330:	d20786d3          	fcvt.d.w	fa3,a5
    80011334:	00013797          	auipc	a5,0x13
    80011338:	fa478793          	addi	a5,a5,-92 # 800242d8 <pow10.0+0xa8>
    8001133c:	239c                	fld	fa5,0(a5)
    8001133e:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    80011342:	0af777d3          	fsub.d	fa5,fa4,fa5
    80011346:	fcf43827          	fsd	fa5,-48(s0)
    const double z2 = z * z;
    8001134a:	fd043787          	fld	fa5,-48(s0)
    8001134e:	12f7f7d3          	fmul.d	fa5,fa5,fa5
    80011352:	fcf43427          	fsd	fa5,-56(s0)
    conv.U          = (uint64_t)(exp2 + 1023) << 52U;
    80011356:	fdc42783          	lw	a5,-36(s0)
    8001135a:	3ff7879b          	addiw	a5,a5,1023
    8001135e:	2781                	sext.w	a5,a5
    80011360:	17d2                	slli	a5,a5,0x34
    80011362:	faf43c23          	sd	a5,-72(s0)
    // compute exp(z) using continued fractions, see
    // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    80011366:	fb843707          	fld	fa4,-72(s0)
    8001136a:	fd043787          	fld	fa5,-48(s0)
    8001136e:	02f7f6d3          	fadd.d	fa3,fa5,fa5
    80011372:	00013797          	auipc	a5,0x13
    80011376:	f6e78793          	addi	a5,a5,-146 # 800242e0 <pow10.0+0xb0>
    8001137a:	2390                	fld	fa2,0(a5)
    8001137c:	fd043787          	fld	fa5,-48(s0)
    80011380:	0af67653          	fsub.d	fa2,fa2,fa5
    80011384:	fc843587          	fld	fa1,-56(s0)
    80011388:	00013797          	auipc	a5,0x13
    8001138c:	f6078793          	addi	a5,a5,-160 # 800242e8 <pow10.0+0xb8>
    80011390:	239c                	fld	fa5,0(a5)
    80011392:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    80011396:	00013797          	auipc	a5,0x13
    8001139a:	f5a78793          	addi	a5,a5,-166 # 800242f0 <pow10.0+0xc0>
    8001139e:	239c                	fld	fa5,0(a5)
    800113a0:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800113a4:	fc843587          	fld	fa1,-56(s0)
    800113a8:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    800113ac:	00013797          	auipc	a5,0x13
    800113b0:	f4c78793          	addi	a5,a5,-180 # 800242f8 <pow10.0+0xc8>
    800113b4:	239c                	fld	fa5,0(a5)
    800113b6:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800113ba:	fc843587          	fld	fa1,-56(s0)
    800113be:	1af5f7d3          	fdiv.d	fa5,fa1,fa5
    800113c2:	02f677d3          	fadd.d	fa5,fa2,fa5
    800113c6:	1af6f6d3          	fdiv.d	fa3,fa3,fa5
    800113ca:	00013797          	auipc	a5,0x13
    800113ce:	f3678793          	addi	a5,a5,-202 # 80024300 <pow10.0+0xd0>
    800113d2:	239c                	fld	fa5,0(a5)
    800113d4:	02f6f7d3          	fadd.d	fa5,fa3,fa5
    800113d8:	12f777d3          	fmul.d	fa5,fa4,fa5
    800113dc:	faf43c27          	fsd	fa5,-72(s0)
    // correct for rounding errors
    if (value < conv.F) {
    800113e0:	fb843787          	fld	fa5,-72(s0)
    800113e4:	f8843707          	fld	fa4,-120(s0)
    800113e8:	a2f717d3          	flt.d	a5,fa4,fa5
    800113ec:	c38d                	beqz	a5,8001140e <_etoa+0x278>
        expval--;
    800113ee:	fec42783          	lw	a5,-20(s0)
    800113f2:	37fd                	addiw	a5,a5,-1
    800113f4:	fef42623          	sw	a5,-20(s0)
        conv.F /= 10;
    800113f8:	fb843707          	fld	fa4,-72(s0)
    800113fc:	00013797          	auipc	a5,0x13
    80011400:	ef478793          	addi	a5,a5,-268 # 800242f0 <pow10.0+0xc0>
    80011404:	239c                	fld	fa5,0(a5)
    80011406:	1af777d3          	fdiv.d	fa5,fa4,fa5
    8001140a:	faf43c27          	fsd	fa5,-72(s0)
    }

    // the exponent format is "%+03d" and largest value is "307", so set aside
    // 4-5 characters
    unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    8001140e:	fec42783          	lw	a5,-20(s0)
    80011412:	0007871b          	sext.w	a4,a5
    80011416:	06300793          	li	a5,99
    8001141a:	00e7cc63          	blt	a5,a4,80011432 <_etoa+0x29c>
    8001141e:	fec42783          	lw	a5,-20(s0)
    80011422:	0007871b          	sext.w	a4,a5
    80011426:	f9d00793          	li	a5,-99
    8001142a:	00f74463          	blt	a4,a5,80011432 <_etoa+0x29c>
    8001142e:	4791                	li	a5,4
    80011430:	a011                	j	80011434 <_etoa+0x29e>
    80011432:	4795                	li	a5,5
    80011434:	fef42423          	sw	a5,-24(s0)

    // in "%g" mode, "prec" is the number of *significant figures* not decimals
    if (flags & FLAGS_ADAPT_EXP) {
    80011438:	f7c42703          	lw	a4,-132(s0)
    8001143c:	6785                	lui	a5,0x1
    8001143e:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80011442:	8ff9                	and	a5,a5,a4
    80011444:	2781                	sext.w	a5,a5
    80011446:	c7c1                	beqz	a5,800114ce <_etoa+0x338>
        // do we want to fall-back to "%f" mode?
        if ((value >= 1e-4) && (value < 1e6)) {
    80011448:	f8843707          	fld	fa4,-120(s0)
    8001144c:	00013797          	auipc	a5,0x13
    80011450:	ebc78793          	addi	a5,a5,-324 # 80024308 <pow10.0+0xd8>
    80011454:	239c                	fld	fa5,0(a5)
    80011456:	a2e787d3          	fle.d	a5,fa5,fa4
    8001145a:	cbb9                	beqz	a5,800114b0 <_etoa+0x31a>
    8001145c:	f8843707          	fld	fa4,-120(s0)
    80011460:	00013797          	auipc	a5,0x13
    80011464:	eb078793          	addi	a5,a5,-336 # 80024310 <pow10.0+0xe0>
    80011468:	239c                	fld	fa5,0(a5)
    8001146a:	a2f717d3          	flt.d	a5,fa4,fa5
    8001146e:	c3a9                	beqz	a5,800114b0 <_etoa+0x31a>
            if ((int)prec > expval) {
    80011470:	f8442703          	lw	a4,-124(s0)
    80011474:	fec42783          	lw	a5,-20(s0)
    80011478:	2781                	sext.w	a5,a5
    8001147a:	00e7de63          	bge	a5,a4,80011496 <_etoa+0x300>
                prec = (unsigned)((int)prec - expval - 1);
    8001147e:	f8442703          	lw	a4,-124(s0)
    80011482:	fec42783          	lw	a5,-20(s0)
    80011486:	40f707bb          	subw	a5,a4,a5
    8001148a:	2781                	sext.w	a5,a5
    8001148c:	37fd                	addiw	a5,a5,-1
    8001148e:	2781                	sext.w	a5,a5
    80011490:	f8f42223          	sw	a5,-124(s0)
    80011494:	a019                	j	8001149a <_etoa+0x304>
            }
            else {
                prec = 0;
    80011496:	f8042223          	sw	zero,-124(s0)
            }
            flags |= FLAGS_PRECISION;  // make sure _ftoa respects precision
    8001149a:	f7c42783          	lw	a5,-132(s0)
    8001149e:	4007e793          	ori	a5,a5,1024
    800114a2:	f6f42e23          	sw	a5,-132(s0)
            // no characters in exponent
            minwidth = 0U;
    800114a6:	fe042423          	sw	zero,-24(s0)
            expval   = 0;
    800114aa:	fe042623          	sw	zero,-20(s0)
    800114ae:	a005                	j	800114ce <_etoa+0x338>
        }
        else {
            // we use one sigfig for the whole part
            if ((prec > 0) && (flags & FLAGS_PRECISION)) {
    800114b0:	f8442783          	lw	a5,-124(s0)
    800114b4:	2781                	sext.w	a5,a5
    800114b6:	cf81                	beqz	a5,800114ce <_etoa+0x338>
    800114b8:	f7c42783          	lw	a5,-132(s0)
    800114bc:	4007f793          	andi	a5,a5,1024
    800114c0:	2781                	sext.w	a5,a5
    800114c2:	c791                	beqz	a5,800114ce <_etoa+0x338>
                --prec;
    800114c4:	f8442783          	lw	a5,-124(s0)
    800114c8:	37fd                	addiw	a5,a5,-1
    800114ca:	f8f42223          	sw	a5,-124(s0)
            }
        }
    }

    // will everything fit?
    unsigned int fwidth = width;
    800114ce:	f8042783          	lw	a5,-128(s0)
    800114d2:	fef42223          	sw	a5,-28(s0)
    if (width > minwidth) {
    800114d6:	f8042703          	lw	a4,-128(s0)
    800114da:	fe842783          	lw	a5,-24(s0)
    800114de:	2701                	sext.w	a4,a4
    800114e0:	2781                	sext.w	a5,a5
    800114e2:	00e7fb63          	bgeu	a5,a4,800114f8 <_etoa+0x362>
        // we didn't fall-back so subtract the characters required for the
        // exponent
        fwidth -= minwidth;
    800114e6:	fe442703          	lw	a4,-28(s0)
    800114ea:	fe842783          	lw	a5,-24(s0)
    800114ee:	40f707bb          	subw	a5,a4,a5
    800114f2:	fef42223          	sw	a5,-28(s0)
    800114f6:	a019                	j	800114fc <_etoa+0x366>
    }
    else {
        // not enough characters, so go back to default sizing
        fwidth = 0U;
    800114f8:	fe042223          	sw	zero,-28(s0)
    }
    if ((flags & FLAGS_LEFT) && minwidth) {
    800114fc:	f7c42783          	lw	a5,-132(s0)
    80011500:	8b89                	andi	a5,a5,2
    80011502:	2781                	sext.w	a5,a5
    80011504:	c799                	beqz	a5,80011512 <_etoa+0x37c>
    80011506:	fe842783          	lw	a5,-24(s0)
    8001150a:	2781                	sext.w	a5,a5
    8001150c:	c399                	beqz	a5,80011512 <_etoa+0x37c>
        // if we're padding on the right, DON'T pad the floating part
        fwidth = 0U;
    8001150e:	fe042223          	sw	zero,-28(s0)
    }

    // rescale the float value
    if (expval) {
    80011512:	fec42783          	lw	a5,-20(s0)
    80011516:	2781                	sext.w	a5,a5
    80011518:	cb89                	beqz	a5,8001152a <_etoa+0x394>
        value /= conv.F;
    8001151a:	fb843787          	fld	fa5,-72(s0)
    8001151e:	f8843707          	fld	fa4,-120(s0)
    80011522:	1af777d3          	fdiv.d	fa5,fa4,fa5
    80011526:	f8f43427          	fsd	fa5,-120(s0)
    }

    // output the floating part
    const size_t start_idx = idx;
    8001152a:	f9843783          	ld	a5,-104(s0)
    8001152e:	fcf43023          	sd	a5,-64(s0)
    idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec,
    80011532:	fe344783          	lbu	a5,-29(s0)
    80011536:	0ff7f793          	andi	a5,a5,255
    8001153a:	c791                	beqz	a5,80011546 <_etoa+0x3b0>
    8001153c:	f8843787          	fld	fa5,-120(s0)
    80011540:	22f797d3          	fneg.d	fa5,fa5
    80011544:	a019                	j	8001154a <_etoa+0x3b4>
    80011546:	f8843787          	fld	fa5,-120(s0)
    8001154a:	f7c42703          	lw	a4,-132(s0)
    8001154e:	77fd                	lui	a5,0xfffff
    80011550:	7ff78793          	addi	a5,a5,2047 # fffffffffffff7ff <_heap_end+0xffffffff77fef7ff>
    80011554:	8ff9                	and	a5,a5,a4
    80011556:	0007869b          	sext.w	a3,a5
    8001155a:	fe442783          	lw	a5,-28(s0)
    8001155e:	f8442703          	lw	a4,-124(s0)
    80011562:	8836                	mv	a6,a3
    80011564:	22f78553          	fmv.d	fa0,fa5
    80011568:	f9043683          	ld	a3,-112(s0)
    8001156c:	f9843603          	ld	a2,-104(s0)
    80011570:	fa043583          	ld	a1,-96(s0)
    80011574:	fa843503          	ld	a0,-88(s0)
    80011578:	ed2ff0ef          	jal	ra,80010c4a <_ftoa>
    8001157c:	f8a43c23          	sd	a0,-104(s0)
                fwidth, flags & ~FLAGS_ADAPT_EXP);

    // output the exponent part
    if (minwidth) {
    80011580:	fe842783          	lw	a5,-24(s0)
    80011584:	2781                	sext.w	a5,a5
    80011586:	c3f1                	beqz	a5,8001164a <_etoa+0x4b4>
        // output the exponential symbol
        out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    80011588:	f7c42783          	lw	a5,-132(s0)
    8001158c:	0207f793          	andi	a5,a5,32
    80011590:	2781                	sext.w	a5,a5
    80011592:	c781                	beqz	a5,8001159a <_etoa+0x404>
    80011594:	04500793          	li	a5,69
    80011598:	a019                	j	8001159e <_etoa+0x408>
    8001159a:	06500793          	li	a5,101
    8001159e:	f9843703          	ld	a4,-104(s0)
    800115a2:	00170693          	addi	a3,a4,1
    800115a6:	f8d43c23          	sd	a3,-104(s0)
    800115aa:	fa843803          	ld	a6,-88(s0)
    800115ae:	f9043683          	ld	a3,-112(s0)
    800115b2:	863a                	mv	a2,a4
    800115b4:	fa043583          	ld	a1,-96(s0)
    800115b8:	853e                	mv	a0,a5
    800115ba:	9802                	jalr	a6
        // output the exponent value
        idx = _ntoa_long(out, buffer, idx, maxlen,
                         (expval < 0) ? -expval : expval, expval < 0, 10, 0,
    800115bc:	fec42783          	lw	a5,-20(s0)
    800115c0:	41f7d79b          	sraiw	a5,a5,0x1f
    800115c4:	fec42703          	lw	a4,-20(s0)
    800115c8:	8f3d                	xor	a4,a4,a5
    800115ca:	40f707bb          	subw	a5,a4,a5
    800115ce:	2781                	sext.w	a5,a5
        idx = _ntoa_long(out, buffer, idx, maxlen,
    800115d0:	863e                	mv	a2,a5
    800115d2:	fec42783          	lw	a5,-20(s0)
    800115d6:	01f7d79b          	srliw	a5,a5,0x1f
    800115da:	0ff7f693          	andi	a3,a5,255
    800115de:	fe842783          	lw	a5,-24(s0)
    800115e2:	37fd                	addiw	a5,a5,-1
    800115e4:	2781                	sext.w	a5,a5
    800115e6:	4715                	li	a4,5
    800115e8:	e43a                	sd	a4,8(sp)
    800115ea:	e03e                	sd	a5,0(sp)
    800115ec:	4881                	li	a7,0
    800115ee:	4829                	li	a6,10
    800115f0:	87b6                	mv	a5,a3
    800115f2:	8732                	mv	a4,a2
    800115f4:	f9043683          	ld	a3,-112(s0)
    800115f8:	f9843603          	ld	a2,-104(s0)
    800115fc:	fa043583          	ld	a1,-96(s0)
    80011600:	fa843503          	ld	a0,-88(s0)
    80011604:	c16ff0ef          	jal	ra,80010a1a <_ntoa_long>
    80011608:	f8a43c23          	sd	a0,-104(s0)
                         minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
        // might need to right-pad spaces
        if (flags & FLAGS_LEFT) {
    8001160c:	f7c42783          	lw	a5,-132(s0)
    80011610:	8b89                	andi	a5,a5,2
    80011612:	2781                	sext.w	a5,a5
    80011614:	cb9d                	beqz	a5,8001164a <_etoa+0x4b4>
            while (idx - start_idx < width)
    80011616:	a00d                	j	80011638 <_etoa+0x4a2>
                out(' ', buffer, idx++, maxlen);
    80011618:	f9843783          	ld	a5,-104(s0)
    8001161c:	00178713          	addi	a4,a5,1
    80011620:	f8e43c23          	sd	a4,-104(s0)
    80011624:	fa843703          	ld	a4,-88(s0)
    80011628:	f9043683          	ld	a3,-112(s0)
    8001162c:	863e                	mv	a2,a5
    8001162e:	fa043583          	ld	a1,-96(s0)
    80011632:	02000513          	li	a0,32
    80011636:	9702                	jalr	a4
            while (idx - start_idx < width)
    80011638:	f9843703          	ld	a4,-104(s0)
    8001163c:	fc043783          	ld	a5,-64(s0)
    80011640:	8f1d                	sub	a4,a4,a5
    80011642:	f8046783          	lwu	a5,-128(s0)
    80011646:	fcf769e3          	bltu	a4,a5,80011618 <_etoa+0x482>
        }
    }
    return idx;
    8001164a:	f9843783          	ld	a5,-104(s0)
}
    8001164e:	853e                	mv	a0,a5
    80011650:	60ea                	ld	ra,152(sp)
    80011652:	644a                	ld	s0,144(sp)
    80011654:	610d                	addi	sp,sp,160
    80011656:	8082                	ret

0000000080011658 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
                      const char *format, va_list va)
{
    80011658:	7135                	addi	sp,sp,-160
    8001165a:	ed06                	sd	ra,152(sp)
    8001165c:	e922                	sd	s0,144(sp)
    8001165e:	1100                	addi	s0,sp,160
    80011660:	f8a43c23          	sd	a0,-104(s0)
    80011664:	f8b43823          	sd	a1,-112(s0)
    80011668:	f8c43423          	sd	a2,-120(s0)
    8001166c:	f8d43023          	sd	a3,-128(s0)
    80011670:	f6e43c23          	sd	a4,-136(s0)
    unsigned int flags, width, precision, n;
    size_t idx = 0U;
    80011674:	fc043c23          	sd	zero,-40(s0)

    if (!buffer) {
    80011678:	f9043783          	ld	a5,-112(s0)
    8001167c:	380792e3          	bnez	a5,80012200 <_vsnprintf+0xba8>
        // use null output function
        out = _out_null;
    80011680:	fffff797          	auipc	a5,0xfffff
    80011684:	e5878793          	addi	a5,a5,-424 # 800104d8 <_out_null>
    80011688:	f8f43c23          	sd	a5,-104(s0)
    }

    while (*format) {
    8001168c:	3750006f          	j	80012200 <_vsnprintf+0xba8>
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
    80011690:	f8043783          	ld	a5,-128(s0)
    80011694:	0007c783          	lbu	a5,0(a5)
    80011698:	873e                	mv	a4,a5
    8001169a:	02500793          	li	a5,37
    8001169e:	02f70b63          	beq	a4,a5,800116d4 <_vsnprintf+0x7c>
            // no
            out(*format, buffer, idx++, maxlen);
    800116a2:	f8043783          	ld	a5,-128(s0)
    800116a6:	0007c503          	lbu	a0,0(a5)
    800116aa:	fd843783          	ld	a5,-40(s0)
    800116ae:	00178713          	addi	a4,a5,1
    800116b2:	fce43c23          	sd	a4,-40(s0)
    800116b6:	f9843703          	ld	a4,-104(s0)
    800116ba:	f8843683          	ld	a3,-120(s0)
    800116be:	863e                	mv	a2,a5
    800116c0:	f9043583          	ld	a1,-112(s0)
    800116c4:	9702                	jalr	a4
            format++;
    800116c6:	f8043783          	ld	a5,-128(s0)
    800116ca:	0785                	addi	a5,a5,1
    800116cc:	f8f43023          	sd	a5,-128(s0)
            continue;
    800116d0:	3310006f          	j	80012200 <_vsnprintf+0xba8>
        }
        else {
            // yes, evaluate it
            format++;
    800116d4:	f8043783          	ld	a5,-128(s0)
    800116d8:	0785                	addi	a5,a5,1
    800116da:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate flags
        flags = 0U;
    800116de:	fe042623          	sw	zero,-20(s0)
        do {
            switch (*format) {
    800116e2:	f8043783          	ld	a5,-128(s0)
    800116e6:	0007c783          	lbu	a5,0(a5)
    800116ea:	2781                	sext.w	a5,a5
    800116ec:	fe07869b          	addiw	a3,a5,-32
    800116f0:	0006871b          	sext.w	a4,a3
    800116f4:	47c1                	li	a5,16
    800116f6:	0ce7e063          	bltu	a5,a4,800117b6 <_vsnprintf+0x15e>
    800116fa:	02069793          	slli	a5,a3,0x20
    800116fe:	9381                	srli	a5,a5,0x20
    80011700:	00279713          	slli	a4,a5,0x2
    80011704:	00013797          	auipc	a5,0x13
    80011708:	94878793          	addi	a5,a5,-1720 # 8002404c <SYSCALLS+0x4c>
    8001170c:	97ba                	add	a5,a5,a4
    8001170e:	439c                	lw	a5,0(a5)
    80011710:	0007871b          	sext.w	a4,a5
    80011714:	00013797          	auipc	a5,0x13
    80011718:	93878793          	addi	a5,a5,-1736 # 8002404c <SYSCALLS+0x4c>
    8001171c:	97ba                	add	a5,a5,a4
    8001171e:	8782                	jr	a5
                case '0':
                    flags |= FLAGS_ZEROPAD;
    80011720:	fec42783          	lw	a5,-20(s0)
    80011724:	0017e793          	ori	a5,a5,1
    80011728:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001172c:	f8043783          	ld	a5,-128(s0)
    80011730:	0785                	addi	a5,a5,1
    80011732:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011736:	4785                	li	a5,1
    80011738:	fef42023          	sw	a5,-32(s0)
                    break;
    8001173c:	a041                	j	800117bc <_vsnprintf+0x164>
                case '-':
                    flags |= FLAGS_LEFT;
    8001173e:	fec42783          	lw	a5,-20(s0)
    80011742:	0027e793          	ori	a5,a5,2
    80011746:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001174a:	f8043783          	ld	a5,-128(s0)
    8001174e:	0785                	addi	a5,a5,1
    80011750:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011754:	4785                	li	a5,1
    80011756:	fef42023          	sw	a5,-32(s0)
                    break;
    8001175a:	a08d                	j	800117bc <_vsnprintf+0x164>
                case '+':
                    flags |= FLAGS_PLUS;
    8001175c:	fec42783          	lw	a5,-20(s0)
    80011760:	0047e793          	ori	a5,a5,4
    80011764:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011768:	f8043783          	ld	a5,-128(s0)
    8001176c:	0785                	addi	a5,a5,1
    8001176e:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011772:	4785                	li	a5,1
    80011774:	fef42023          	sw	a5,-32(s0)
                    break;
    80011778:	a091                	j	800117bc <_vsnprintf+0x164>
                case ' ':
                    flags |= FLAGS_SPACE;
    8001177a:	fec42783          	lw	a5,-20(s0)
    8001177e:	0087e793          	ori	a5,a5,8
    80011782:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011786:	f8043783          	ld	a5,-128(s0)
    8001178a:	0785                	addi	a5,a5,1
    8001178c:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80011790:	4785                	li	a5,1
    80011792:	fef42023          	sw	a5,-32(s0)
                    break;
    80011796:	a01d                	j	800117bc <_vsnprintf+0x164>
                case '#':
                    flags |= FLAGS_HASH;
    80011798:	fec42783          	lw	a5,-20(s0)
    8001179c:	0107e793          	ori	a5,a5,16
    800117a0:	fef42623          	sw	a5,-20(s0)
                    format++;
    800117a4:	f8043783          	ld	a5,-128(s0)
    800117a8:	0785                	addi	a5,a5,1
    800117aa:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    800117ae:	4785                	li	a5,1
    800117b0:	fef42023          	sw	a5,-32(s0)
                    break;
    800117b4:	a021                	j	800117bc <_vsnprintf+0x164>
                default:
                    n = 0U;
    800117b6:	fe042023          	sw	zero,-32(s0)
                    break;
    800117ba:	0001                	nop
            }
        } while (n);
    800117bc:	fe042783          	lw	a5,-32(s0)
    800117c0:	2781                	sext.w	a5,a5
    800117c2:	f385                	bnez	a5,800116e2 <_vsnprintf+0x8a>

        // evaluate width field
        width = 0U;
    800117c4:	fe042423          	sw	zero,-24(s0)
        if (_is_digit(*format)) {
    800117c8:	f8043783          	ld	a5,-128(s0)
    800117cc:	0007c783          	lbu	a5,0(a5)
    800117d0:	853e                	mv	a0,a5
    800117d2:	df3fe0ef          	jal	ra,800105c4 <_is_digit>
    800117d6:	87aa                	mv	a5,a0
    800117d8:	cb91                	beqz	a5,800117ec <_vsnprintf+0x194>
            width = _atoi(&format);
    800117da:	f8040793          	addi	a5,s0,-128
    800117de:	853e                	mv	a0,a5
    800117e0:	e25fe0ef          	jal	ra,80010604 <_atoi>
    800117e4:	87aa                	mv	a5,a0
    800117e6:	fef42423          	sw	a5,-24(s0)
    800117ea:	a8b9                	j	80011848 <_vsnprintf+0x1f0>
        }
        else if (*format == '*') {
    800117ec:	f8043783          	ld	a5,-128(s0)
    800117f0:	0007c783          	lbu	a5,0(a5)
    800117f4:	873e                	mv	a4,a5
    800117f6:	02a00793          	li	a5,42
    800117fa:	04f71763          	bne	a4,a5,80011848 <_vsnprintf+0x1f0>
            const int w = va_arg(va, int);
    800117fe:	f7843783          	ld	a5,-136(s0)
    80011802:	00878713          	addi	a4,a5,8
    80011806:	f6e43c23          	sd	a4,-136(s0)
    8001180a:	439c                	lw	a5,0(a5)
    8001180c:	fcf42023          	sw	a5,-64(s0)
            if (w < 0) {
    80011810:	fc042783          	lw	a5,-64(s0)
    80011814:	2781                	sext.w	a5,a5
    80011816:	0207d063          	bgez	a5,80011836 <_vsnprintf+0x1de>
                flags |= FLAGS_LEFT;  // reverse padding
    8001181a:	fec42783          	lw	a5,-20(s0)
    8001181e:	0027e793          	ori	a5,a5,2
    80011822:	fef42623          	sw	a5,-20(s0)
                width = (unsigned int)-w;
    80011826:	fc042783          	lw	a5,-64(s0)
    8001182a:	40f007bb          	negw	a5,a5
    8001182e:	2781                	sext.w	a5,a5
    80011830:	fef42423          	sw	a5,-24(s0)
    80011834:	a029                	j	8001183e <_vsnprintf+0x1e6>
            }
            else {
                width = (unsigned int)w;
    80011836:	fc042783          	lw	a5,-64(s0)
    8001183a:	fef42423          	sw	a5,-24(s0)
            }
            format++;
    8001183e:	f8043783          	ld	a5,-128(s0)
    80011842:	0785                	addi	a5,a5,1
    80011844:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate precision field
        precision = 0U;
    80011848:	fe042223          	sw	zero,-28(s0)
        if (*format == '.') {
    8001184c:	f8043783          	ld	a5,-128(s0)
    80011850:	0007c783          	lbu	a5,0(a5)
    80011854:	873e                	mv	a4,a5
    80011856:	02e00793          	li	a5,46
    8001185a:	08f71063          	bne	a4,a5,800118da <_vsnprintf+0x282>
            flags |= FLAGS_PRECISION;
    8001185e:	fec42783          	lw	a5,-20(s0)
    80011862:	4007e793          	ori	a5,a5,1024
    80011866:	fef42623          	sw	a5,-20(s0)
            format++;
    8001186a:	f8043783          	ld	a5,-128(s0)
    8001186e:	0785                	addi	a5,a5,1
    80011870:	f8f43023          	sd	a5,-128(s0)
            if (_is_digit(*format)) {
    80011874:	f8043783          	ld	a5,-128(s0)
    80011878:	0007c783          	lbu	a5,0(a5)
    8001187c:	853e                	mv	a0,a5
    8001187e:	d47fe0ef          	jal	ra,800105c4 <_is_digit>
    80011882:	87aa                	mv	a5,a0
    80011884:	cb91                	beqz	a5,80011898 <_vsnprintf+0x240>
                precision = _atoi(&format);
    80011886:	f8040793          	addi	a5,s0,-128
    8001188a:	853e                	mv	a0,a5
    8001188c:	d79fe0ef          	jal	ra,80010604 <_atoi>
    80011890:	87aa                	mv	a5,a0
    80011892:	fef42223          	sw	a5,-28(s0)
    80011896:	a091                	j	800118da <_vsnprintf+0x282>
            }
            else if (*format == '*') {
    80011898:	f8043783          	ld	a5,-128(s0)
    8001189c:	0007c783          	lbu	a5,0(a5)
    800118a0:	873e                	mv	a4,a5
    800118a2:	02a00793          	li	a5,42
    800118a6:	02f71a63          	bne	a4,a5,800118da <_vsnprintf+0x282>
                const int prec = (int)va_arg(va, int);
    800118aa:	f7843783          	ld	a5,-136(s0)
    800118ae:	00878713          	addi	a4,a5,8
    800118b2:	f6e43c23          	sd	a4,-136(s0)
    800118b6:	439c                	lw	a5,0(a5)
    800118b8:	faf42e23          	sw	a5,-68(s0)
                precision      = prec > 0 ? (unsigned int)prec : 0U;
    800118bc:	fbc42783          	lw	a5,-68(s0)
    800118c0:	0007871b          	sext.w	a4,a5
    800118c4:	00075363          	bgez	a4,800118ca <_vsnprintf+0x272>
    800118c8:	4781                	li	a5,0
    800118ca:	2781                	sext.w	a5,a5
    800118cc:	fef42223          	sw	a5,-28(s0)
                format++;
    800118d0:	f8043783          	ld	a5,-128(s0)
    800118d4:	0785                	addi	a5,a5,1
    800118d6:	f8f43023          	sd	a5,-128(s0)
            }
        }

        // evaluate length field
        switch (*format) {
    800118da:	f8043783          	ld	a5,-128(s0)
    800118de:	0007c783          	lbu	a5,0(a5)
    800118e2:	2781                	sext.w	a5,a5
    800118e4:	f987869b          	addiw	a3,a5,-104
    800118e8:	0006871b          	sext.w	a4,a3
    800118ec:	47c9                	li	a5,18
    800118ee:	0ee7e963          	bltu	a5,a4,800119e0 <_vsnprintf+0x388>
    800118f2:	02069793          	slli	a5,a3,0x20
    800118f6:	9381                	srli	a5,a5,0x20
    800118f8:	00279713          	slli	a4,a5,0x2
    800118fc:	00012797          	auipc	a5,0x12
    80011900:	79478793          	addi	a5,a5,1940 # 80024090 <SYSCALLS+0x90>
    80011904:	97ba                	add	a5,a5,a4
    80011906:	439c                	lw	a5,0(a5)
    80011908:	0007871b          	sext.w	a4,a5
    8001190c:	00012797          	auipc	a5,0x12
    80011910:	78478793          	addi	a5,a5,1924 # 80024090 <SYSCALLS+0x90>
    80011914:	97ba                	add	a5,a5,a4
    80011916:	8782                	jr	a5
            case 'l':
                flags |= FLAGS_LONG;
    80011918:	fec42783          	lw	a5,-20(s0)
    8001191c:	1007e793          	ori	a5,a5,256
    80011920:	fef42623          	sw	a5,-20(s0)
                format++;
    80011924:	f8043783          	ld	a5,-128(s0)
    80011928:	0785                	addi	a5,a5,1
    8001192a:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'l') {
    8001192e:	f8043783          	ld	a5,-128(s0)
    80011932:	0007c783          	lbu	a5,0(a5)
    80011936:	873e                	mv	a4,a5
    80011938:	06c00793          	li	a5,108
    8001193c:	0af71463          	bne	a4,a5,800119e4 <_vsnprintf+0x38c>
                    flags |= FLAGS_LONG_LONG;
    80011940:	fec42783          	lw	a5,-20(s0)
    80011944:	2007e793          	ori	a5,a5,512
    80011948:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001194c:	f8043783          	ld	a5,-128(s0)
    80011950:	0785                	addi	a5,a5,1
    80011952:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80011956:	a079                	j	800119e4 <_vsnprintf+0x38c>
            case 'h':
                flags |= FLAGS_SHORT;
    80011958:	fec42783          	lw	a5,-20(s0)
    8001195c:	0807e793          	ori	a5,a5,128
    80011960:	fef42623          	sw	a5,-20(s0)
                format++;
    80011964:	f8043783          	ld	a5,-128(s0)
    80011968:	0785                	addi	a5,a5,1
    8001196a:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'h') {
    8001196e:	f8043783          	ld	a5,-128(s0)
    80011972:	0007c783          	lbu	a5,0(a5)
    80011976:	873e                	mv	a4,a5
    80011978:	06800793          	li	a5,104
    8001197c:	06f71663          	bne	a4,a5,800119e8 <_vsnprintf+0x390>
                    flags |= FLAGS_CHAR;
    80011980:	fec42783          	lw	a5,-20(s0)
    80011984:	0407e793          	ori	a5,a5,64
    80011988:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001198c:	f8043783          	ld	a5,-128(s0)
    80011990:	0785                	addi	a5,a5,1
    80011992:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80011996:	a889                	j	800119e8 <_vsnprintf+0x390>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
            case 't':
                flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG
    80011998:	fec42783          	lw	a5,-20(s0)
    8001199c:	1007e793          	ori	a5,a5,256
    800119a0:	fef42623          	sw	a5,-20(s0)
                                                            : FLAGS_LONG_LONG);
                format++;
    800119a4:	f8043783          	ld	a5,-128(s0)
    800119a8:	0785                	addi	a5,a5,1
    800119aa:	f8f43023          	sd	a5,-128(s0)
                break;
    800119ae:	a835                	j	800119ea <_vsnprintf+0x392>
#endif
            case 'j':
                flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG
    800119b0:	fec42783          	lw	a5,-20(s0)
    800119b4:	1007e793          	ori	a5,a5,256
    800119b8:	fef42623          	sw	a5,-20(s0)
                                                           : FLAGS_LONG_LONG);
                format++;
    800119bc:	f8043783          	ld	a5,-128(s0)
    800119c0:	0785                	addi	a5,a5,1
    800119c2:	f8f43023          	sd	a5,-128(s0)
                break;
    800119c6:	a015                	j	800119ea <_vsnprintf+0x392>
            case 'z':
                flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG
    800119c8:	fec42783          	lw	a5,-20(s0)
    800119cc:	1007e793          	ori	a5,a5,256
    800119d0:	fef42623          	sw	a5,-20(s0)
                                                         : FLAGS_LONG_LONG);
                format++;
    800119d4:	f8043783          	ld	a5,-128(s0)
    800119d8:	0785                	addi	a5,a5,1
    800119da:	f8f43023          	sd	a5,-128(s0)
                break;
    800119de:	a031                	j	800119ea <_vsnprintf+0x392>
            default:
                break;
    800119e0:	0001                	nop
    800119e2:	a021                	j	800119ea <_vsnprintf+0x392>
                break;
    800119e4:	0001                	nop
    800119e6:	a011                	j	800119ea <_vsnprintf+0x392>
                break;
    800119e8:	0001                	nop
        }

        // evaluate specifier
        switch (*format) {
    800119ea:	f8043783          	ld	a5,-128(s0)
    800119ee:	0007c783          	lbu	a5,0(a5)
    800119f2:	2781                	sext.w	a5,a5
    800119f4:	fdb7869b          	addiw	a3,a5,-37
    800119f8:	0006871b          	sext.w	a4,a3
    800119fc:	05300793          	li	a5,83
    80011a00:	7ce7e863          	bltu	a5,a4,800121d0 <_vsnprintf+0xb78>
    80011a04:	02069793          	slli	a5,a3,0x20
    80011a08:	9381                	srli	a5,a5,0x20
    80011a0a:	00279713          	slli	a4,a5,0x2
    80011a0e:	00012797          	auipc	a5,0x12
    80011a12:	6ce78793          	addi	a5,a5,1742 # 800240dc <SYSCALLS+0xdc>
    80011a16:	97ba                	add	a5,a5,a4
    80011a18:	439c                	lw	a5,0(a5)
    80011a1a:	0007871b          	sext.w	a4,a5
    80011a1e:	00012797          	auipc	a5,0x12
    80011a22:	6be78793          	addi	a5,a5,1726 # 800240dc <SYSCALLS+0xdc>
    80011a26:	97ba                	add	a5,a5,a4
    80011a28:	8782                	jr	a5
            case 'X':
            case 'o':
            case 'b': {
                // set the base
                unsigned int base;
                if (*format == 'x' || *format == 'X') {
    80011a2a:	f8043783          	ld	a5,-128(s0)
    80011a2e:	0007c783          	lbu	a5,0(a5)
    80011a32:	873e                	mv	a4,a5
    80011a34:	07800793          	li	a5,120
    80011a38:	00f70b63          	beq	a4,a5,80011a4e <_vsnprintf+0x3f6>
    80011a3c:	f8043783          	ld	a5,-128(s0)
    80011a40:	0007c783          	lbu	a5,0(a5)
    80011a44:	873e                	mv	a4,a5
    80011a46:	05800793          	li	a5,88
    80011a4a:	00f71663          	bne	a4,a5,80011a56 <_vsnprintf+0x3fe>
                    base = 16U;
    80011a4e:	47c1                	li	a5,16
    80011a50:	fcf42a23          	sw	a5,-44(s0)
    80011a54:	a099                	j	80011a9a <_vsnprintf+0x442>
                }
                else if (*format == 'o') {
    80011a56:	f8043783          	ld	a5,-128(s0)
    80011a5a:	0007c783          	lbu	a5,0(a5)
    80011a5e:	873e                	mv	a4,a5
    80011a60:	06f00793          	li	a5,111
    80011a64:	00f71663          	bne	a4,a5,80011a70 <_vsnprintf+0x418>
                    base = 8U;
    80011a68:	47a1                	li	a5,8
    80011a6a:	fcf42a23          	sw	a5,-44(s0)
    80011a6e:	a035                	j	80011a9a <_vsnprintf+0x442>
                }
                else if (*format == 'b') {
    80011a70:	f8043783          	ld	a5,-128(s0)
    80011a74:	0007c783          	lbu	a5,0(a5)
    80011a78:	873e                	mv	a4,a5
    80011a7a:	06200793          	li	a5,98
    80011a7e:	00f71663          	bne	a4,a5,80011a8a <_vsnprintf+0x432>
                    base = 2U;
    80011a82:	4789                	li	a5,2
    80011a84:	fcf42a23          	sw	a5,-44(s0)
    80011a88:	a809                	j	80011a9a <_vsnprintf+0x442>
                }
                else {
                    base = 10U;
    80011a8a:	47a9                	li	a5,10
    80011a8c:	fcf42a23          	sw	a5,-44(s0)
                    flags &= ~FLAGS_HASH;  // no hash for dec format
    80011a90:	fec42783          	lw	a5,-20(s0)
    80011a94:	9bbd                	andi	a5,a5,-17
    80011a96:	fef42623          	sw	a5,-20(s0)
                }
                // uppercase
                if (*format == 'X') {
    80011a9a:	f8043783          	ld	a5,-128(s0)
    80011a9e:	0007c783          	lbu	a5,0(a5)
    80011aa2:	873e                	mv	a4,a5
    80011aa4:	05800793          	li	a5,88
    80011aa8:	00f71863          	bne	a4,a5,80011ab8 <_vsnprintf+0x460>
                    flags |= FLAGS_UPPERCASE;
    80011aac:	fec42783          	lw	a5,-20(s0)
    80011ab0:	0207e793          	ori	a5,a5,32
    80011ab4:	fef42623          	sw	a5,-20(s0)
                }

                // no plus or space flag for u, x, X, o, b
                if ((*format != 'i') && (*format != 'd')) {
    80011ab8:	f8043783          	ld	a5,-128(s0)
    80011abc:	0007c783          	lbu	a5,0(a5)
    80011ac0:	873e                	mv	a4,a5
    80011ac2:	06900793          	li	a5,105
    80011ac6:	02f70063          	beq	a4,a5,80011ae6 <_vsnprintf+0x48e>
    80011aca:	f8043783          	ld	a5,-128(s0)
    80011ace:	0007c783          	lbu	a5,0(a5)
    80011ad2:	873e                	mv	a4,a5
    80011ad4:	06400793          	li	a5,100
    80011ad8:	00f70763          	beq	a4,a5,80011ae6 <_vsnprintf+0x48e>
                    flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    80011adc:	fec42783          	lw	a5,-20(s0)
    80011ae0:	9bcd                	andi	a5,a5,-13
    80011ae2:	fef42623          	sw	a5,-20(s0)
                }

                // ignore '0' flag when precision is given
                if (flags & FLAGS_PRECISION) {
    80011ae6:	fec42783          	lw	a5,-20(s0)
    80011aea:	4007f793          	andi	a5,a5,1024
    80011aee:	2781                	sext.w	a5,a5
    80011af0:	c791                	beqz	a5,80011afc <_vsnprintf+0x4a4>
                    flags &= ~FLAGS_ZEROPAD;
    80011af2:	fec42783          	lw	a5,-20(s0)
    80011af6:	9bf9                	andi	a5,a5,-2
    80011af8:	fef42623          	sw	a5,-20(s0)
                }

                // convert the integer
                if ((*format == 'i') || (*format == 'd')) {
    80011afc:	f8043783          	ld	a5,-128(s0)
    80011b00:	0007c783          	lbu	a5,0(a5)
    80011b04:	873e                	mv	a4,a5
    80011b06:	06900793          	li	a5,105
    80011b0a:	00f70b63          	beq	a4,a5,80011b20 <_vsnprintf+0x4c8>
    80011b0e:	f8043783          	ld	a5,-128(s0)
    80011b12:	0007c783          	lbu	a5,0(a5)
    80011b16:	873e                	mv	a4,a5
    80011b18:	06400793          	li	a5,100
    80011b1c:	18f71d63          	bne	a4,a5,80011cb6 <_vsnprintf+0x65e>
                    // signed
                    if (flags & FLAGS_LONG_LONG) {
    80011b20:	fec42783          	lw	a5,-20(s0)
    80011b24:	2007f793          	andi	a5,a5,512
    80011b28:	2781                	sext.w	a5,a5
    80011b2a:	c3bd                	beqz	a5,80011b90 <_vsnprintf+0x538>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        const long long value = va_arg(va, long long);
    80011b2c:	f7843783          	ld	a5,-136(s0)
    80011b30:	00878713          	addi	a4,a5,8
    80011b34:	f6e43c23          	sd	a4,-136(s0)
    80011b38:	639c                	ld	a5,0(a5)
    80011b3a:	faf43023          	sd	a5,-96(s0)
                        idx                   = _ntoa_long_long(
                                              out, buffer, idx, maxlen,
                                              (unsigned long long)(value > 0 ? value : 0 - value),
    80011b3e:	fa043783          	ld	a5,-96(s0)
    80011b42:	43f7d713          	srai	a4,a5,0x3f
    80011b46:	fa043783          	ld	a5,-96(s0)
    80011b4a:	8fb9                	xor	a5,a5,a4
    80011b4c:	8f99                	sub	a5,a5,a4
                        idx                   = _ntoa_long_long(
    80011b4e:	85be                	mv	a1,a5
    80011b50:	fa043783          	ld	a5,-96(s0)
    80011b54:	93fd                	srli	a5,a5,0x3f
    80011b56:	0ff7f713          	andi	a4,a5,255
    80011b5a:	fd446683          	lwu	a3,-44(s0)
    80011b5e:	fe442603          	lw	a2,-28(s0)
    80011b62:	fec42783          	lw	a5,-20(s0)
    80011b66:	e43e                	sd	a5,8(sp)
    80011b68:	fe842783          	lw	a5,-24(s0)
    80011b6c:	e03e                	sd	a5,0(sp)
    80011b6e:	88b2                	mv	a7,a2
    80011b70:	8836                	mv	a6,a3
    80011b72:	87ba                	mv	a5,a4
    80011b74:	872e                	mv	a4,a1
    80011b76:	f8843683          	ld	a3,-120(s0)
    80011b7a:	fd843603          	ld	a2,-40(s0)
    80011b7e:	f9043583          	ld	a1,-112(s0)
    80011b82:	f9843503          	ld	a0,-104(s0)
    80011b86:	fadfe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80011b8a:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011b8e:	ac89                	j	80011de0 <_vsnprintf+0x788>
                                              value < 0, base, precision, width, flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80011b90:	fec42783          	lw	a5,-20(s0)
    80011b94:	1007f793          	andi	a5,a5,256
    80011b98:	2781                	sext.w	a5,a5
    80011b9a:	c3bd                	beqz	a5,80011c00 <_vsnprintf+0x5a8>
                        const long value = va_arg(va, long);
    80011b9c:	f7843783          	ld	a5,-136(s0)
    80011ba0:	00878713          	addi	a4,a5,8
    80011ba4:	f6e43c23          	sd	a4,-136(s0)
    80011ba8:	639c                	ld	a5,0(a5)
    80011baa:	faf43423          	sd	a5,-88(s0)
                        idx              = _ntoa_long(
                                         out, buffer, idx, maxlen,
                                         (unsigned long)(value > 0 ? value : 0 - value),
    80011bae:	fa843783          	ld	a5,-88(s0)
    80011bb2:	43f7d713          	srai	a4,a5,0x3f
    80011bb6:	fa843783          	ld	a5,-88(s0)
    80011bba:	8fb9                	xor	a5,a5,a4
    80011bbc:	8f99                	sub	a5,a5,a4
                        idx              = _ntoa_long(
    80011bbe:	85be                	mv	a1,a5
    80011bc0:	fa843783          	ld	a5,-88(s0)
    80011bc4:	93fd                	srli	a5,a5,0x3f
    80011bc6:	0ff7f713          	andi	a4,a5,255
    80011bca:	fd446683          	lwu	a3,-44(s0)
    80011bce:	fe442603          	lw	a2,-28(s0)
    80011bd2:	fec42783          	lw	a5,-20(s0)
    80011bd6:	e43e                	sd	a5,8(sp)
    80011bd8:	fe842783          	lw	a5,-24(s0)
    80011bdc:	e03e                	sd	a5,0(sp)
    80011bde:	88b2                	mv	a7,a2
    80011be0:	8836                	mv	a6,a3
    80011be2:	87ba                	mv	a5,a4
    80011be4:	872e                	mv	a4,a1
    80011be6:	f8843683          	ld	a3,-120(s0)
    80011bea:	fd843603          	ld	a2,-40(s0)
    80011bee:	f9043583          	ld	a1,-112(s0)
    80011bf2:	f9843503          	ld	a0,-104(s0)
    80011bf6:	e25fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011bfa:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011bfe:	a2cd                	j	80011de0 <_vsnprintf+0x788>
                                         value < 0, base, precision, width, flags);
                    }
                    else {
                        const int value =
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011c00:	fec42783          	lw	a5,-20(s0)
    80011c04:	0407f793          	andi	a5,a5,64
    80011c08:	2781                	sext.w	a5,a5
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c0a:	cf81                	beqz	a5,80011c22 <_vsnprintf+0x5ca>
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011c0c:	f7843783          	ld	a5,-136(s0)
    80011c10:	00878713          	addi	a4,a5,8
    80011c14:	f6e43c23          	sd	a4,-136(s0)
    80011c18:	439c                	lw	a5,0(a5)
    80011c1a:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c1e:	2781                	sext.w	a5,a5
    80011c20:	a81d                	j	80011c56 <_vsnprintf+0x5fe>
    80011c22:	fec42783          	lw	a5,-20(s0)
    80011c26:	0807f793          	andi	a5,a5,128
    80011c2a:	2781                	sext.w	a5,a5
                                                    : va_arg(va, int);
    80011c2c:	cf91                	beqz	a5,80011c48 <_vsnprintf+0x5f0>
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011c2e:	f7843783          	ld	a5,-136(s0)
    80011c32:	00878713          	addi	a4,a5,8
    80011c36:	f6e43c23          	sd	a4,-136(s0)
    80011c3a:	439c                	lw	a5,0(a5)
    80011c3c:	0107979b          	slliw	a5,a5,0x10
    80011c40:	4107d79b          	sraiw	a5,a5,0x10
                                                    : va_arg(va, int);
    80011c44:	2781                	sext.w	a5,a5
    80011c46:	a801                	j	80011c56 <_vsnprintf+0x5fe>
    80011c48:	f7843783          	ld	a5,-136(s0)
    80011c4c:	00878713          	addi	a4,a5,8
    80011c50:	f6e43c23          	sd	a4,-136(s0)
    80011c54:	439c                	lw	a5,0(a5)
                        const int value =
    80011c56:	faf42823          	sw	a5,-80(s0)
                        idx = _ntoa_long(
                            out, buffer, idx, maxlen,
                            (unsigned int)(value > 0 ? value : 0 - value),
    80011c5a:	fb042783          	lw	a5,-80(s0)
    80011c5e:	41f7d79b          	sraiw	a5,a5,0x1f
    80011c62:	fb042703          	lw	a4,-80(s0)
    80011c66:	8f3d                	xor	a4,a4,a5
    80011c68:	40f707bb          	subw	a5,a4,a5
    80011c6c:	2781                	sext.w	a5,a5
    80011c6e:	2781                	sext.w	a5,a5
                        idx = _ntoa_long(
    80011c70:	02079713          	slli	a4,a5,0x20
    80011c74:	9301                	srli	a4,a4,0x20
    80011c76:	fb042783          	lw	a5,-80(s0)
    80011c7a:	01f7d79b          	srliw	a5,a5,0x1f
    80011c7e:	0ff7f693          	andi	a3,a5,255
    80011c82:	fd446603          	lwu	a2,-44(s0)
    80011c86:	fe442583          	lw	a1,-28(s0)
    80011c8a:	fec42783          	lw	a5,-20(s0)
    80011c8e:	e43e                	sd	a5,8(sp)
    80011c90:	fe842783          	lw	a5,-24(s0)
    80011c94:	e03e                	sd	a5,0(sp)
    80011c96:	88ae                	mv	a7,a1
    80011c98:	8832                	mv	a6,a2
    80011c9a:	87b6                	mv	a5,a3
    80011c9c:	f8843683          	ld	a3,-120(s0)
    80011ca0:	fd843603          	ld	a2,-40(s0)
    80011ca4:	f9043583          	ld	a1,-112(s0)
    80011ca8:	f9843503          	ld	a0,-104(s0)
    80011cac:	d6ffe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011cb0:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011cb4:	a235                	j	80011de0 <_vsnprintf+0x788>
                            value < 0, base, precision, width, flags);
                    }
                }
                else {
                    // unsigned
                    if (flags & FLAGS_LONG_LONG) {
    80011cb6:	fec42783          	lw	a5,-20(s0)
    80011cba:	2007f793          	andi	a5,a5,512
    80011cbe:	2781                	sext.w	a5,a5
    80011cc0:	c3b1                	beqz	a5,80011d04 <_vsnprintf+0x6ac>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80011cc2:	f7843783          	ld	a5,-136(s0)
    80011cc6:	00878713          	addi	a4,a5,8
    80011cca:	f6e43c23          	sd	a4,-136(s0)
    80011cce:	6398                	ld	a4,0(a5)
    80011cd0:	fd446683          	lwu	a3,-44(s0)
    80011cd4:	fe442603          	lw	a2,-28(s0)
    80011cd8:	fec42783          	lw	a5,-20(s0)
    80011cdc:	e43e                	sd	a5,8(sp)
    80011cde:	fe842783          	lw	a5,-24(s0)
    80011ce2:	e03e                	sd	a5,0(sp)
    80011ce4:	88b2                	mv	a7,a2
    80011ce6:	8836                	mv	a6,a3
    80011ce8:	4781                	li	a5,0
    80011cea:	f8843683          	ld	a3,-120(s0)
    80011cee:	fd843603          	ld	a2,-40(s0)
    80011cf2:	f9043583          	ld	a1,-112(s0)
    80011cf6:	f9843503          	ld	a0,-104(s0)
    80011cfa:	e39fe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80011cfe:	fca43c23          	sd	a0,-40(s0)
    80011d02:	a8f9                	j	80011de0 <_vsnprintf+0x788>
                                              va_arg(va, unsigned long long),
                                              false, base, precision, width,
                                              flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80011d04:	fec42783          	lw	a5,-20(s0)
    80011d08:	1007f793          	andi	a5,a5,256
    80011d0c:	2781                	sext.w	a5,a5
    80011d0e:	c3b1                	beqz	a5,80011d52 <_vsnprintf+0x6fa>
                        idx = _ntoa_long(out, buffer, idx, maxlen,
    80011d10:	f7843783          	ld	a5,-136(s0)
    80011d14:	00878713          	addi	a4,a5,8
    80011d18:	f6e43c23          	sd	a4,-136(s0)
    80011d1c:	6398                	ld	a4,0(a5)
    80011d1e:	fd446683          	lwu	a3,-44(s0)
    80011d22:	fe442603          	lw	a2,-28(s0)
    80011d26:	fec42783          	lw	a5,-20(s0)
    80011d2a:	e43e                	sd	a5,8(sp)
    80011d2c:	fe842783          	lw	a5,-24(s0)
    80011d30:	e03e                	sd	a5,0(sp)
    80011d32:	88b2                	mv	a7,a2
    80011d34:	8836                	mv	a6,a3
    80011d36:	4781                	li	a5,0
    80011d38:	f8843683          	ld	a3,-120(s0)
    80011d3c:	fd843603          	ld	a2,-40(s0)
    80011d40:	f9043583          	ld	a1,-112(s0)
    80011d44:	f9843503          	ld	a0,-104(s0)
    80011d48:	cd3fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011d4c:	fca43c23          	sd	a0,-40(s0)
    80011d50:	a841                	j	80011de0 <_vsnprintf+0x788>
                                         va_arg(va, unsigned long), false, base,
                                         precision, width, flags);
                    }
                    else {
                        const unsigned int value =
                            (flags & FLAGS_CHAR)
    80011d52:	fec42783          	lw	a5,-20(s0)
    80011d56:	0407f793          	andi	a5,a5,64
    80011d5a:	2781                	sext.w	a5,a5
                                ? (unsigned char)va_arg(va, unsigned int)
                            : (flags & FLAGS_SHORT)
    80011d5c:	cf81                	beqz	a5,80011d74 <_vsnprintf+0x71c>
                                ? (unsigned char)va_arg(va, unsigned int)
    80011d5e:	f7843783          	ld	a5,-136(s0)
    80011d62:	00878713          	addi	a4,a5,8
    80011d66:	f6e43c23          	sd	a4,-136(s0)
    80011d6a:	439c                	lw	a5,0(a5)
    80011d6c:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT)
    80011d70:	2781                	sext.w	a5,a5
    80011d72:	a815                	j	80011da6 <_vsnprintf+0x74e>
    80011d74:	fec42783          	lw	a5,-20(s0)
    80011d78:	0807f793          	andi	a5,a5,128
    80011d7c:	2781                	sext.w	a5,a5
                                ? (unsigned short int)va_arg(va, unsigned int)
                                : va_arg(va, unsigned int);
    80011d7e:	cf81                	beqz	a5,80011d96 <_vsnprintf+0x73e>
                                ? (unsigned short int)va_arg(va, unsigned int)
    80011d80:	f7843783          	ld	a5,-136(s0)
    80011d84:	00878713          	addi	a4,a5,8
    80011d88:	f6e43c23          	sd	a4,-136(s0)
    80011d8c:	439c                	lw	a5,0(a5)
    80011d8e:	17c2                	slli	a5,a5,0x30
    80011d90:	93c1                	srli	a5,a5,0x30
                                : va_arg(va, unsigned int);
    80011d92:	2781                	sext.w	a5,a5
    80011d94:	a801                	j	80011da4 <_vsnprintf+0x74c>
    80011d96:	f7843783          	ld	a5,-136(s0)
    80011d9a:	00878713          	addi	a4,a5,8
    80011d9e:	f6e43c23          	sd	a4,-136(s0)
    80011da2:	439c                	lw	a5,0(a5)
                            : (flags & FLAGS_SHORT)
    80011da4:	2781                	sext.w	a5,a5
                        const unsigned int value =
    80011da6:	faf42a23          	sw	a5,-76(s0)
                        idx = _ntoa_long(out, buffer, idx, maxlen, value, false,
    80011daa:	fb446703          	lwu	a4,-76(s0)
    80011dae:	fd446683          	lwu	a3,-44(s0)
    80011db2:	fe442603          	lw	a2,-28(s0)
    80011db6:	fec42783          	lw	a5,-20(s0)
    80011dba:	e43e                	sd	a5,8(sp)
    80011dbc:	fe842783          	lw	a5,-24(s0)
    80011dc0:	e03e                	sd	a5,0(sp)
    80011dc2:	88b2                	mv	a7,a2
    80011dc4:	8836                	mv	a6,a3
    80011dc6:	4781                	li	a5,0
    80011dc8:	f8843683          	ld	a3,-120(s0)
    80011dcc:	fd843603          	ld	a2,-40(s0)
    80011dd0:	f9043583          	ld	a1,-112(s0)
    80011dd4:	f9843503          	ld	a0,-104(s0)
    80011dd8:	c43fe0ef          	jal	ra,80010a1a <_ntoa_long>
    80011ddc:	fca43c23          	sd	a0,-40(s0)
                                         base, precision, width, flags);
                    }
                }
                format++;
    80011de0:	f8043783          	ld	a5,-128(s0)
    80011de4:	0785                	addi	a5,a5,1
    80011de6:	f8f43023          	sd	a5,-128(s0)
                break;
    80011dea:	a919                	j	80012200 <_vsnprintf+0xba8>
            }
#if defined(PRINTF_SUPPORT_FLOAT)
            case 'f':
            case 'F':
                if (*format == 'F')
    80011dec:	f8043783          	ld	a5,-128(s0)
    80011df0:	0007c783          	lbu	a5,0(a5)
    80011df4:	873e                	mv	a4,a5
    80011df6:	04600793          	li	a5,70
    80011dfa:	00f71863          	bne	a4,a5,80011e0a <_vsnprintf+0x7b2>
                    flags |= FLAGS_UPPERCASE;
    80011dfe:	fec42783          	lw	a5,-20(s0)
    80011e02:	0207e793          	ori	a5,a5,32
    80011e06:	fef42623          	sw	a5,-20(s0)
                idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011e0a:	f7843783          	ld	a5,-136(s0)
    80011e0e:	00878713          	addi	a4,a5,8
    80011e12:	f6e43c23          	sd	a4,-136(s0)
    80011e16:	239c                	fld	fa5,0(a5)
    80011e18:	fec42683          	lw	a3,-20(s0)
    80011e1c:	fe842783          	lw	a5,-24(s0)
    80011e20:	fe442703          	lw	a4,-28(s0)
    80011e24:	8836                	mv	a6,a3
    80011e26:	22f78553          	fmv.d	fa0,fa5
    80011e2a:	f8843683          	ld	a3,-120(s0)
    80011e2e:	fd843603          	ld	a2,-40(s0)
    80011e32:	f9043583          	ld	a1,-112(s0)
    80011e36:	f9843503          	ld	a0,-104(s0)
    80011e3a:	e11fe0ef          	jal	ra,80010c4a <_ftoa>
    80011e3e:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011e42:	f8043783          	ld	a5,-128(s0)
    80011e46:	0785                	addi	a5,a5,1
    80011e48:	f8f43023          	sd	a5,-128(s0)
                break;
    80011e4c:	ae55                	j	80012200 <_vsnprintf+0xba8>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
            case 'e':
            case 'E':
            case 'g':
            case 'G':
                if ((*format == 'g') || (*format == 'G'))
    80011e4e:	f8043783          	ld	a5,-128(s0)
    80011e52:	0007c783          	lbu	a5,0(a5)
    80011e56:	873e                	mv	a4,a5
    80011e58:	06700793          	li	a5,103
    80011e5c:	00f70b63          	beq	a4,a5,80011e72 <_vsnprintf+0x81a>
    80011e60:	f8043783          	ld	a5,-128(s0)
    80011e64:	0007c783          	lbu	a5,0(a5)
    80011e68:	873e                	mv	a4,a5
    80011e6a:	04700793          	li	a5,71
    80011e6e:	00f71a63          	bne	a4,a5,80011e82 <_vsnprintf+0x82a>
                    flags |= FLAGS_ADAPT_EXP;
    80011e72:	fec42703          	lw	a4,-20(s0)
    80011e76:	6785                	lui	a5,0x1
    80011e78:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80011e7c:	8fd9                	or	a5,a5,a4
    80011e7e:	fef42623          	sw	a5,-20(s0)
                if ((*format == 'E') || (*format == 'G'))
    80011e82:	f8043783          	ld	a5,-128(s0)
    80011e86:	0007c783          	lbu	a5,0(a5)
    80011e8a:	873e                	mv	a4,a5
    80011e8c:	04500793          	li	a5,69
    80011e90:	00f70b63          	beq	a4,a5,80011ea6 <_vsnprintf+0x84e>
    80011e94:	f8043783          	ld	a5,-128(s0)
    80011e98:	0007c783          	lbu	a5,0(a5)
    80011e9c:	873e                	mv	a4,a5
    80011e9e:	04700793          	li	a5,71
    80011ea2:	00f71863          	bne	a4,a5,80011eb2 <_vsnprintf+0x85a>
                    flags |= FLAGS_UPPERCASE;
    80011ea6:	fec42783          	lw	a5,-20(s0)
    80011eaa:	0207e793          	ori	a5,a5,32
    80011eae:	fef42623          	sw	a5,-20(s0)
                idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011eb2:	f7843783          	ld	a5,-136(s0)
    80011eb6:	00878713          	addi	a4,a5,8
    80011eba:	f6e43c23          	sd	a4,-136(s0)
    80011ebe:	239c                	fld	fa5,0(a5)
    80011ec0:	fec42683          	lw	a3,-20(s0)
    80011ec4:	fe842783          	lw	a5,-24(s0)
    80011ec8:	fe442703          	lw	a4,-28(s0)
    80011ecc:	8836                	mv	a6,a3
    80011ece:	22f78553          	fmv.d	fa0,fa5
    80011ed2:	f8843683          	ld	a3,-120(s0)
    80011ed6:	fd843603          	ld	a2,-40(s0)
    80011eda:	f9043583          	ld	a1,-112(s0)
    80011ede:	f9843503          	ld	a0,-104(s0)
    80011ee2:	ab4ff0ef          	jal	ra,80011196 <_etoa>
    80011ee6:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011eea:	f8043783          	ld	a5,-128(s0)
    80011eee:	0785                	addi	a5,a5,1
    80011ef0:	f8f43023          	sd	a5,-128(s0)
                break;
    80011ef4:	a631                	j	80012200 <_vsnprintf+0xba8>
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
            case 'c': {
                unsigned int l = 1U;
    80011ef6:	4785                	li	a5,1
    80011ef8:	fcf42823          	sw	a5,-48(s0)
                // pre padding
                if (!(flags & FLAGS_LEFT)) {
    80011efc:	fec42783          	lw	a5,-20(s0)
    80011f00:	8b89                	andi	a5,a5,2
    80011f02:	2781                	sext.w	a5,a5
    80011f04:	ef8d                	bnez	a5,80011f3e <_vsnprintf+0x8e6>
                    while (l++ < width) {
    80011f06:	a00d                	j	80011f28 <_vsnprintf+0x8d0>
                        out(' ', buffer, idx++, maxlen);
    80011f08:	fd843783          	ld	a5,-40(s0)
    80011f0c:	00178713          	addi	a4,a5,1
    80011f10:	fce43c23          	sd	a4,-40(s0)
    80011f14:	f9843703          	ld	a4,-104(s0)
    80011f18:	f8843683          	ld	a3,-120(s0)
    80011f1c:	863e                	mv	a2,a5
    80011f1e:	f9043583          	ld	a1,-112(s0)
    80011f22:	02000513          	li	a0,32
    80011f26:	9702                	jalr	a4
                    while (l++ < width) {
    80011f28:	fd042783          	lw	a5,-48(s0)
    80011f2c:	0017871b          	addiw	a4,a5,1
    80011f30:	fce42823          	sw	a4,-48(s0)
    80011f34:	fe842703          	lw	a4,-24(s0)
    80011f38:	2701                	sext.w	a4,a4
    80011f3a:	fce7e7e3          	bltu	a5,a4,80011f08 <_vsnprintf+0x8b0>
                    }
                }
                // char output
                out((char)va_arg(va, int), buffer, idx++, maxlen);
    80011f3e:	f7843783          	ld	a5,-136(s0)
    80011f42:	00878713          	addi	a4,a5,8
    80011f46:	f6e43c23          	sd	a4,-136(s0)
    80011f4a:	439c                	lw	a5,0(a5)
    80011f4c:	0ff7f513          	andi	a0,a5,255
    80011f50:	fd843783          	ld	a5,-40(s0)
    80011f54:	00178713          	addi	a4,a5,1
    80011f58:	fce43c23          	sd	a4,-40(s0)
    80011f5c:	f9843703          	ld	a4,-104(s0)
    80011f60:	f8843683          	ld	a3,-120(s0)
    80011f64:	863e                	mv	a2,a5
    80011f66:	f9043583          	ld	a1,-112(s0)
    80011f6a:	9702                	jalr	a4
                // post padding
                if (flags & FLAGS_LEFT) {
    80011f6c:	fec42783          	lw	a5,-20(s0)
    80011f70:	8b89                	andi	a5,a5,2
    80011f72:	2781                	sext.w	a5,a5
    80011f74:	cf8d                	beqz	a5,80011fae <_vsnprintf+0x956>
                    while (l++ < width) {
    80011f76:	a00d                	j	80011f98 <_vsnprintf+0x940>
                        out(' ', buffer, idx++, maxlen);
    80011f78:	fd843783          	ld	a5,-40(s0)
    80011f7c:	00178713          	addi	a4,a5,1
    80011f80:	fce43c23          	sd	a4,-40(s0)
    80011f84:	f9843703          	ld	a4,-104(s0)
    80011f88:	f8843683          	ld	a3,-120(s0)
    80011f8c:	863e                	mv	a2,a5
    80011f8e:	f9043583          	ld	a1,-112(s0)
    80011f92:	02000513          	li	a0,32
    80011f96:	9702                	jalr	a4
                    while (l++ < width) {
    80011f98:	fd042783          	lw	a5,-48(s0)
    80011f9c:	0017871b          	addiw	a4,a5,1
    80011fa0:	fce42823          	sw	a4,-48(s0)
    80011fa4:	fe842703          	lw	a4,-24(s0)
    80011fa8:	2701                	sext.w	a4,a4
    80011faa:	fce7e7e3          	bltu	a5,a4,80011f78 <_vsnprintf+0x920>
                    }
                }
                format++;
    80011fae:	f8043783          	ld	a5,-128(s0)
    80011fb2:	0785                	addi	a5,a5,1
    80011fb4:	f8f43023          	sd	a5,-128(s0)
                break;
    80011fb8:	a4a1                	j	80012200 <_vsnprintf+0xba8>
            }

            case 's': {
                const char *p = va_arg(va, char *);
    80011fba:	f7843783          	ld	a5,-136(s0)
    80011fbe:	00878713          	addi	a4,a5,8
    80011fc2:	f6e43c23          	sd	a4,-136(s0)
    80011fc6:	639c                	ld	a5,0(a5)
    80011fc8:	fcf43423          	sd	a5,-56(s0)
                unsigned int l =
                    _strnlen_s(p, precision ? precision : (size_t)-1);
    80011fcc:	fe442783          	lw	a5,-28(s0)
    80011fd0:	2781                	sext.w	a5,a5
    80011fd2:	c781                	beqz	a5,80011fda <_vsnprintf+0x982>
    80011fd4:	fe446783          	lwu	a5,-28(s0)
    80011fd8:	a011                	j	80011fdc <_vsnprintf+0x984>
    80011fda:	57fd                	li	a5,-1
    80011fdc:	85be                	mv	a1,a5
    80011fde:	fc843503          	ld	a0,-56(s0)
    80011fe2:	d92fe0ef          	jal	ra,80010574 <_strnlen_s>
    80011fe6:	87aa                	mv	a5,a0
    80011fe8:	fcf42223          	sw	a5,-60(s0)
                // pre padding
                if (flags & FLAGS_PRECISION) {
    80011fec:	fec42783          	lw	a5,-20(s0)
    80011ff0:	4007f793          	andi	a5,a5,1024
    80011ff4:	2781                	sext.w	a5,a5
    80011ff6:	cf91                	beqz	a5,80012012 <_vsnprintf+0x9ba>
                    l = (l < precision ? l : precision);
    80011ff8:	fc442603          	lw	a2,-60(s0)
    80011ffc:	fe442783          	lw	a5,-28(s0)
    80012000:	0007869b          	sext.w	a3,a5
    80012004:	0006071b          	sext.w	a4,a2
    80012008:	00d77363          	bgeu	a4,a3,8001200e <_vsnprintf+0x9b6>
    8001200c:	87b2                	mv	a5,a2
    8001200e:	fcf42223          	sw	a5,-60(s0)
                }
                if (!(flags & FLAGS_LEFT)) {
    80012012:	fec42783          	lw	a5,-20(s0)
    80012016:	8b89                	andi	a5,a5,2
    80012018:	2781                	sext.w	a5,a5
    8001201a:	e7a5                	bnez	a5,80012082 <_vsnprintf+0xa2a>
                    while (l++ < width) {
    8001201c:	a00d                	j	8001203e <_vsnprintf+0x9e6>
                        out(' ', buffer, idx++, maxlen);
    8001201e:	fd843783          	ld	a5,-40(s0)
    80012022:	00178713          	addi	a4,a5,1
    80012026:	fce43c23          	sd	a4,-40(s0)
    8001202a:	f9843703          	ld	a4,-104(s0)
    8001202e:	f8843683          	ld	a3,-120(s0)
    80012032:	863e                	mv	a2,a5
    80012034:	f9043583          	ld	a1,-112(s0)
    80012038:	02000513          	li	a0,32
    8001203c:	9702                	jalr	a4
                    while (l++ < width) {
    8001203e:	fc442783          	lw	a5,-60(s0)
    80012042:	0017871b          	addiw	a4,a5,1
    80012046:	fce42223          	sw	a4,-60(s0)
    8001204a:	fe842703          	lw	a4,-24(s0)
    8001204e:	2701                	sext.w	a4,a4
    80012050:	fce7e7e3          	bltu	a5,a4,8001201e <_vsnprintf+0x9c6>
                    }
                }
                // string output
                while ((*p != 0) &&
    80012054:	a03d                	j	80012082 <_vsnprintf+0xa2a>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
                    out(*(p++), buffer, idx++, maxlen);
    80012056:	fc843783          	ld	a5,-56(s0)
    8001205a:	00178713          	addi	a4,a5,1
    8001205e:	fce43423          	sd	a4,-56(s0)
    80012062:	0007c503          	lbu	a0,0(a5)
    80012066:	fd843783          	ld	a5,-40(s0)
    8001206a:	00178713          	addi	a4,a5,1
    8001206e:	fce43c23          	sd	a4,-40(s0)
    80012072:	f9843703          	ld	a4,-104(s0)
    80012076:	f8843683          	ld	a3,-120(s0)
    8001207a:	863e                	mv	a2,a5
    8001207c:	f9043583          	ld	a1,-112(s0)
    80012080:	9702                	jalr	a4
                while ((*p != 0) &&
    80012082:	fc843783          	ld	a5,-56(s0)
    80012086:	0007c783          	lbu	a5,0(a5)
    8001208a:	cf91                	beqz	a5,800120a6 <_vsnprintf+0xa4e>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    8001208c:	fec42783          	lw	a5,-20(s0)
    80012090:	4007f793          	andi	a5,a5,1024
    80012094:	2781                	sext.w	a5,a5
                while ((*p != 0) &&
    80012096:	d3e1                	beqz	a5,80012056 <_vsnprintf+0x9fe>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    80012098:	fe442783          	lw	a5,-28(s0)
    8001209c:	fff7871b          	addiw	a4,a5,-1
    800120a0:	fee42223          	sw	a4,-28(s0)
    800120a4:	fbcd                	bnez	a5,80012056 <_vsnprintf+0x9fe>
                }
                // post padding
                if (flags & FLAGS_LEFT) {
    800120a6:	fec42783          	lw	a5,-20(s0)
    800120aa:	8b89                	andi	a5,a5,2
    800120ac:	2781                	sext.w	a5,a5
    800120ae:	cf8d                	beqz	a5,800120e8 <_vsnprintf+0xa90>
                    while (l++ < width) {
    800120b0:	a00d                	j	800120d2 <_vsnprintf+0xa7a>
                        out(' ', buffer, idx++, maxlen);
    800120b2:	fd843783          	ld	a5,-40(s0)
    800120b6:	00178713          	addi	a4,a5,1
    800120ba:	fce43c23          	sd	a4,-40(s0)
    800120be:	f9843703          	ld	a4,-104(s0)
    800120c2:	f8843683          	ld	a3,-120(s0)
    800120c6:	863e                	mv	a2,a5
    800120c8:	f9043583          	ld	a1,-112(s0)
    800120cc:	02000513          	li	a0,32
    800120d0:	9702                	jalr	a4
                    while (l++ < width) {
    800120d2:	fc442783          	lw	a5,-60(s0)
    800120d6:	0017871b          	addiw	a4,a5,1
    800120da:	fce42223          	sw	a4,-60(s0)
    800120de:	fe842703          	lw	a4,-24(s0)
    800120e2:	2701                	sext.w	a4,a4
    800120e4:	fce7e7e3          	bltu	a5,a4,800120b2 <_vsnprintf+0xa5a>
                    }
                }
                format++;
    800120e8:	f8043783          	ld	a5,-128(s0)
    800120ec:	0785                	addi	a5,a5,1
    800120ee:	f8f43023          	sd	a5,-128(s0)
                break;
    800120f2:	a239                	j	80012200 <_vsnprintf+0xba8>
            }

            case 'p': {
                width = sizeof(void *) * 2U;
    800120f4:	47c1                	li	a5,16
    800120f6:	fef42423          	sw	a5,-24(s0)
                flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    800120fa:	fec42783          	lw	a5,-20(s0)
    800120fe:	0217e793          	ori	a5,a5,33
    80012102:	fef42623          	sw	a5,-20(s0)
#if defined(PRINTF_SUPPORT_LONG_LONG)
                const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
    80012106:	4785                	li	a5,1
    80012108:	faf40da3          	sb	a5,-69(s0)
                if (is_ll) {
    8001210c:	fbb44783          	lbu	a5,-69(s0)
    80012110:	0ff7f793          	andi	a5,a5,255
    80012114:	c3b1                	beqz	a5,80012158 <_vsnprintf+0xb00>
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
                                          (uintptr_t)va_arg(va, void *), false,
    80012116:	f7843783          	ld	a5,-136(s0)
    8001211a:	00878713          	addi	a4,a5,8
    8001211e:	f6e43c23          	sd	a4,-136(s0)
    80012122:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80012124:	86be                	mv	a3,a5
    80012126:	fe442703          	lw	a4,-28(s0)
    8001212a:	fec42783          	lw	a5,-20(s0)
    8001212e:	e43e                	sd	a5,8(sp)
    80012130:	fe842783          	lw	a5,-24(s0)
    80012134:	e03e                	sd	a5,0(sp)
    80012136:	88ba                	mv	a7,a4
    80012138:	4841                	li	a6,16
    8001213a:	4781                	li	a5,0
    8001213c:	8736                	mv	a4,a3
    8001213e:	f8843683          	ld	a3,-120(s0)
    80012142:	fd843603          	ld	a2,-40(s0)
    80012146:	f9043583          	ld	a1,-112(s0)
    8001214a:	f9843503          	ld	a0,-104(s0)
    8001214e:	9e5fe0ef          	jal	ra,80010b32 <_ntoa_long_long>
    80012152:	fca43c23          	sd	a0,-40(s0)
    80012156:	a089                	j	80012198 <_vsnprintf+0xb40>
                }
                else {
#endif
                    idx = _ntoa_long(
                        out, buffer, idx, maxlen,
                        (unsigned long)((uintptr_t)va_arg(va, void *)), false,
    80012158:	f7843783          	ld	a5,-136(s0)
    8001215c:	00878713          	addi	a4,a5,8
    80012160:	f6e43c23          	sd	a4,-136(s0)
    80012164:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long(
    80012166:	86be                	mv	a3,a5
    80012168:	fe442703          	lw	a4,-28(s0)
    8001216c:	fec42783          	lw	a5,-20(s0)
    80012170:	e43e                	sd	a5,8(sp)
    80012172:	fe842783          	lw	a5,-24(s0)
    80012176:	e03e                	sd	a5,0(sp)
    80012178:	88ba                	mv	a7,a4
    8001217a:	4841                	li	a6,16
    8001217c:	4781                	li	a5,0
    8001217e:	8736                	mv	a4,a3
    80012180:	f8843683          	ld	a3,-120(s0)
    80012184:	fd843603          	ld	a2,-40(s0)
    80012188:	f9043583          	ld	a1,-112(s0)
    8001218c:	f9843503          	ld	a0,-104(s0)
    80012190:	88bfe0ef          	jal	ra,80010a1a <_ntoa_long>
    80012194:	fca43c23          	sd	a0,-40(s0)
                        16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
                }
#endif
                format++;
    80012198:	f8043783          	ld	a5,-128(s0)
    8001219c:	0785                	addi	a5,a5,1
    8001219e:	f8f43023          	sd	a5,-128(s0)
                break;
    800121a2:	a8b9                	j	80012200 <_vsnprintf+0xba8>
            }

            case '%':
                out('%', buffer, idx++, maxlen);
    800121a4:	fd843783          	ld	a5,-40(s0)
    800121a8:	00178713          	addi	a4,a5,1
    800121ac:	fce43c23          	sd	a4,-40(s0)
    800121b0:	f9843703          	ld	a4,-104(s0)
    800121b4:	f8843683          	ld	a3,-120(s0)
    800121b8:	863e                	mv	a2,a5
    800121ba:	f9043583          	ld	a1,-112(s0)
    800121be:	02500513          	li	a0,37
    800121c2:	9702                	jalr	a4
                format++;
    800121c4:	f8043783          	ld	a5,-128(s0)
    800121c8:	0785                	addi	a5,a5,1
    800121ca:	f8f43023          	sd	a5,-128(s0)
                break;
    800121ce:	a80d                	j	80012200 <_vsnprintf+0xba8>

            default:
                out(*format, buffer, idx++, maxlen);
    800121d0:	f8043783          	ld	a5,-128(s0)
    800121d4:	0007c503          	lbu	a0,0(a5)
    800121d8:	fd843783          	ld	a5,-40(s0)
    800121dc:	00178713          	addi	a4,a5,1
    800121e0:	fce43c23          	sd	a4,-40(s0)
    800121e4:	f9843703          	ld	a4,-104(s0)
    800121e8:	f8843683          	ld	a3,-120(s0)
    800121ec:	863e                	mv	a2,a5
    800121ee:	f9043583          	ld	a1,-112(s0)
    800121f2:	9702                	jalr	a4
                format++;
    800121f4:	f8043783          	ld	a5,-128(s0)
    800121f8:	0785                	addi	a5,a5,1
    800121fa:	f8f43023          	sd	a5,-128(s0)
                break;
    800121fe:	0001                	nop
    while (*format) {
    80012200:	f8043783          	ld	a5,-128(s0)
    80012204:	0007c783          	lbu	a5,0(a5)
    80012208:	c8079463          	bnez	a5,80011690 <_vsnprintf+0x38>
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    8001220c:	fd843703          	ld	a4,-40(s0)
    80012210:	f8843783          	ld	a5,-120(s0)
    80012214:	00f76663          	bltu	a4,a5,80012220 <_vsnprintf+0xbc8>
    80012218:	f8843783          	ld	a5,-120(s0)
    8001221c:	17fd                	addi	a5,a5,-1
    8001221e:	a019                	j	80012224 <_vsnprintf+0xbcc>
    80012220:	fd843783          	ld	a5,-40(s0)
    80012224:	f9843703          	ld	a4,-104(s0)
    80012228:	f8843683          	ld	a3,-120(s0)
    8001222c:	863e                	mv	a2,a5
    8001222e:	f9043583          	ld	a1,-112(s0)
    80012232:	4501                	li	a0,0
    80012234:	9702                	jalr	a4

    // return written chars without terminating \0
    return (int)idx;
    80012236:	fd843783          	ld	a5,-40(s0)
    8001223a:	2781                	sext.w	a5,a5
}
    8001223c:	853e                	mv	a0,a5
    8001223e:	60ea                	ld	ra,152(sp)
    80012240:	644a                	ld	s0,144(sp)
    80012242:	610d                	addi	sp,sp,160
    80012244:	8082                	ret

0000000080012246 <printf>:

///////////////////////////////////////////////////////////////////////////////

int printf(const char *format, ...)
{
    80012246:	7119                	addi	sp,sp,-128
    80012248:	fc06                	sd	ra,56(sp)
    8001224a:	f822                	sd	s0,48(sp)
    8001224c:	0080                	addi	s0,sp,64
    8001224e:	fca43423          	sd	a0,-56(s0)
    80012252:	e40c                	sd	a1,8(s0)
    80012254:	e810                	sd	a2,16(s0)
    80012256:	ec14                	sd	a3,24(s0)
    80012258:	f018                	sd	a4,32(s0)
    8001225a:	f41c                	sd	a5,40(s0)
    8001225c:	03043823          	sd	a6,48(s0)
    80012260:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, format);
    80012264:	04040793          	addi	a5,s0,64
    80012268:	fcf43023          	sd	a5,-64(s0)
    8001226c:	fc043783          	ld	a5,-64(s0)
    80012270:	fc878793          	addi	a5,a5,-56
    80012274:	fef43023          	sd	a5,-32(s0)
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80012278:	fe043703          	ld	a4,-32(s0)
    8001227c:	fd840793          	addi	a5,s0,-40
    80012280:	fc843683          	ld	a3,-56(s0)
    80012284:	567d                	li	a2,-1
    80012286:	85be                	mv	a1,a5
    80012288:	ffffe517          	auipc	a0,0xffffe
    8001228c:	27050513          	addi	a0,a0,624 # 800104f8 <_out_char>
    80012290:	bc8ff0ef          	jal	ra,80011658 <_vsnprintf>
    80012294:	87aa                	mv	a5,a0
    80012296:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    8001229a:	fec42783          	lw	a5,-20(s0)
}
    8001229e:	853e                	mv	a0,a5
    800122a0:	70e2                	ld	ra,56(sp)
    800122a2:	7442                	ld	s0,48(sp)
    800122a4:	6109                	addi	sp,sp,128
    800122a6:	8082                	ret

00000000800122a8 <sprintf>:

int sprintf(char *buffer, const char *format, ...)
{
    800122a8:	7159                	addi	sp,sp,-112
    800122aa:	fc06                	sd	ra,56(sp)
    800122ac:	f822                	sd	s0,48(sp)
    800122ae:	0080                	addi	s0,sp,64
    800122b0:	fca43c23          	sd	a0,-40(s0)
    800122b4:	fcb43823          	sd	a1,-48(s0)
    800122b8:	e010                	sd	a2,0(s0)
    800122ba:	e414                	sd	a3,8(s0)
    800122bc:	e818                	sd	a4,16(s0)
    800122be:	ec1c                	sd	a5,24(s0)
    800122c0:	03043023          	sd	a6,32(s0)
    800122c4:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    800122c8:	03040793          	addi	a5,s0,48
    800122cc:	fcf43423          	sd	a5,-56(s0)
    800122d0:	fc843783          	ld	a5,-56(s0)
    800122d4:	fd078793          	addi	a5,a5,-48
    800122d8:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
    800122dc:	fe043783          	ld	a5,-32(s0)
    800122e0:	873e                	mv	a4,a5
    800122e2:	fd043683          	ld	a3,-48(s0)
    800122e6:	567d                	li	a2,-1
    800122e8:	fd843583          	ld	a1,-40(s0)
    800122ec:	ffffe517          	auipc	a0,0xffffe
    800122f0:	1ae50513          	addi	a0,a0,430 # 8001049a <_out_buffer>
    800122f4:	b64ff0ef          	jal	ra,80011658 <_vsnprintf>
    800122f8:	87aa                	mv	a5,a0
    800122fa:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    800122fe:	fec42783          	lw	a5,-20(s0)
}
    80012302:	853e                	mv	a0,a5
    80012304:	70e2                	ld	ra,56(sp)
    80012306:	7442                	ld	s0,48(sp)
    80012308:	6165                	addi	sp,sp,112
    8001230a:	8082                	ret

000000008001230c <snprintf>:

int snprintf(char *buffer, size_t count, const char *format, ...)
{
    8001230c:	7159                	addi	sp,sp,-112
    8001230e:	fc06                	sd	ra,56(sp)
    80012310:	f822                	sd	s0,48(sp)
    80012312:	0080                	addi	s0,sp,64
    80012314:	fca43c23          	sd	a0,-40(s0)
    80012318:	fcb43823          	sd	a1,-48(s0)
    8001231c:	fcc43423          	sd	a2,-56(s0)
    80012320:	e414                	sd	a3,8(s0)
    80012322:	e818                	sd	a4,16(s0)
    80012324:	ec1c                	sd	a5,24(s0)
    80012326:	03043023          	sd	a6,32(s0)
    8001232a:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    8001232e:	03040793          	addi	a5,s0,48
    80012332:	fcf43023          	sd	a5,-64(s0)
    80012336:	fc043783          	ld	a5,-64(s0)
    8001233a:	fd878793          	addi	a5,a5,-40
    8001233e:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    80012342:	fe043783          	ld	a5,-32(s0)
    80012346:	873e                	mv	a4,a5
    80012348:	fc843683          	ld	a3,-56(s0)
    8001234c:	fd043603          	ld	a2,-48(s0)
    80012350:	fd843583          	ld	a1,-40(s0)
    80012354:	ffffe517          	auipc	a0,0xffffe
    80012358:	14650513          	addi	a0,a0,326 # 8001049a <_out_buffer>
    8001235c:	afcff0ef          	jal	ra,80011658 <_vsnprintf>
    80012360:	87aa                	mv	a5,a0
    80012362:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80012366:	fec42783          	lw	a5,-20(s0)
}
    8001236a:	853e                	mv	a0,a5
    8001236c:	70e2                	ld	ra,56(sp)
    8001236e:	7442                	ld	s0,48(sp)
    80012370:	6165                	addi	sp,sp,112
    80012372:	8082                	ret

0000000080012374 <vprintf_>:

int vprintf_(const char *format, va_list va)
{
    80012374:	7179                	addi	sp,sp,-48
    80012376:	f406                	sd	ra,40(sp)
    80012378:	f022                	sd	s0,32(sp)
    8001237a:	1800                	addi	s0,sp,48
    8001237c:	fca43c23          	sd	a0,-40(s0)
    80012380:	fcb43823          	sd	a1,-48(s0)
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80012384:	fe840793          	addi	a5,s0,-24
    80012388:	fd043703          	ld	a4,-48(s0)
    8001238c:	fd843683          	ld	a3,-40(s0)
    80012390:	567d                	li	a2,-1
    80012392:	85be                	mv	a1,a5
    80012394:	ffffe517          	auipc	a0,0xffffe
    80012398:	16450513          	addi	a0,a0,356 # 800104f8 <_out_char>
    8001239c:	abcff0ef          	jal	ra,80011658 <_vsnprintf>
    800123a0:	87aa                	mv	a5,a0
}
    800123a2:	853e                	mv	a0,a5
    800123a4:	70a2                	ld	ra,40(sp)
    800123a6:	7402                	ld	s0,32(sp)
    800123a8:	6145                	addi	sp,sp,48
    800123aa:	8082                	ret

00000000800123ac <vsnprintf_>:

int vsnprintf_(char *buffer, size_t count, const char *format, va_list va)
{
    800123ac:	7179                	addi	sp,sp,-48
    800123ae:	f406                	sd	ra,40(sp)
    800123b0:	f022                	sd	s0,32(sp)
    800123b2:	1800                	addi	s0,sp,48
    800123b4:	fea43423          	sd	a0,-24(s0)
    800123b8:	feb43023          	sd	a1,-32(s0)
    800123bc:	fcc43c23          	sd	a2,-40(s0)
    800123c0:	fcd43823          	sd	a3,-48(s0)
    return _vsnprintf(_out_buffer, buffer, count, format, va);
    800123c4:	fd043703          	ld	a4,-48(s0)
    800123c8:	fd843683          	ld	a3,-40(s0)
    800123cc:	fe043603          	ld	a2,-32(s0)
    800123d0:	fe843583          	ld	a1,-24(s0)
    800123d4:	ffffe517          	auipc	a0,0xffffe
    800123d8:	0c650513          	addi	a0,a0,198 # 8001049a <_out_buffer>
    800123dc:	a7cff0ef          	jal	ra,80011658 <_vsnprintf>
    800123e0:	87aa                	mv	a5,a0
}
    800123e2:	853e                	mv	a0,a5
    800123e4:	70a2                	ld	ra,40(sp)
    800123e6:	7402                	ld	s0,32(sp)
    800123e8:	6145                	addi	sp,sp,48
    800123ea:	8082                	ret

00000000800123ec <fctprintf>:

int fctprintf(void (*out)(char character, void *arg), void *arg,
              const char *format, ...)
{
    800123ec:	7119                	addi	sp,sp,-128
    800123ee:	e486                	sd	ra,72(sp)
    800123f0:	e0a2                	sd	s0,64(sp)
    800123f2:	0880                	addi	s0,sp,80
    800123f4:	fca43423          	sd	a0,-56(s0)
    800123f8:	fcb43023          	sd	a1,-64(s0)
    800123fc:	fac43c23          	sd	a2,-72(s0)
    80012400:	e414                	sd	a3,8(s0)
    80012402:	e818                	sd	a4,16(s0)
    80012404:	ec1c                	sd	a5,24(s0)
    80012406:	03043023          	sd	a6,32(s0)
    8001240a:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    8001240e:	03040793          	addi	a5,s0,48
    80012412:	faf43823          	sd	a5,-80(s0)
    80012416:	fb043783          	ld	a5,-80(s0)
    8001241a:	fd878793          	addi	a5,a5,-40
    8001241e:	fef43023          	sd	a5,-32(s0)
    const out_fct_wrap_type out_fct_wrap = {out, arg};
    80012422:	fc843783          	ld	a5,-56(s0)
    80012426:	fcf43823          	sd	a5,-48(s0)
    8001242a:	fc043783          	ld	a5,-64(s0)
    8001242e:	fcf43c23          	sd	a5,-40(s0)
    const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap,
    80012432:	fe043703          	ld	a4,-32(s0)
    80012436:	fd040793          	addi	a5,s0,-48
    8001243a:	fb843683          	ld	a3,-72(s0)
    8001243e:	567d                	li	a2,-1
    80012440:	85be                	mv	a1,a5
    80012442:	ffffe517          	auipc	a0,0xffffe
    80012446:	0ee50513          	addi	a0,a0,238 # 80010530 <_out_fct>
    8001244a:	a0eff0ef          	jal	ra,80011658 <_vsnprintf>
    8001244e:	87aa                	mv	a5,a0
    80012450:	fef42623          	sw	a5,-20(s0)
                               (size_t)-1, format, va);
    va_end(va);
    return ret;
    80012454:	fec42783          	lw	a5,-20(s0)
}
    80012458:	853e                	mv	a0,a5
    8001245a:	60a6                	ld	ra,72(sp)
    8001245c:	6406                	ld	s0,64(sp)
    8001245e:	6109                	addi	sp,sp,128
    80012460:	8082                	ret

0000000080012462 <os_trap_handler>:
// From src/syscall.c
void syscall_handle(int hart, uint64_t epc, int64_t *scratch);

// Called from asm/spawn.S: _spawn_kthread
void os_trap_handler(void)
{
    80012462:	7139                	addi	sp,sp,-64
    80012464:	fc06                	sd	ra,56(sp)
    80012466:	f822                	sd	s0,48(sp)
    80012468:	0080                	addi	s0,sp,64
    unsigned long cause;
    long *scratch;
    unsigned long epc;
    unsigned long tval;
    unsigned long sie;
    CSR_READ(cause, "scause");
    8001246a:	142027f3          	csrr	a5,scause
    8001246e:	fef43423          	sd	a5,-24(s0)
    CSR_READ(scratch, "sscratch");
    80012472:	140027f3          	csrr	a5,sscratch
    80012476:	fef43023          	sd	a5,-32(s0)
    CSR_READ(epc, "sepc");
    8001247a:	141027f3          	csrr	a5,sepc
    8001247e:	fcf43c23          	sd	a5,-40(s0)
    CSR_READ(tval, "stval");
    80012482:	143027f3          	csrr	a5,stval
    80012486:	fcf43823          	sd	a5,-48(s0)
    CSR_READ(sie, "sie");
    8001248a:	104027f3          	csrr	a5,sie
    8001248e:	fcf43423          	sd	a5,-56(s0)
    // debugf("SPP: %lx\n", status & SSTATUS_SPP_BIT);

    // debugf("Scause: %lx\n", cause);
    // debugf("Sscratch: %lx\n", scratch);

    int hart = sbi_whoami();
    80012492:	0ca070ef          	jal	ra,8001955c <sbi_whoami>
    80012496:	87aa                	mv	a5,a0
    80012498:	fcf42223          	sw	a5,-60(s0)
    //                 "csrs sie, t1\n");


    debugf("Is async: %d\n", SCAUSE_IS_ASYNC(cause));

    if (SCAUSE_IS_ASYNC(cause)) {
    8001249c:	fe843783          	ld	a5,-24(s0)
    800124a0:	0407d963          	bgez	a5,800124f2 <os_trap_handler+0x90>
        debugf("Is async!\n");
        cause = SCAUSE_NUM(cause);
    800124a4:	fe843783          	ld	a5,-24(s0)
    800124a8:	0ff7f793          	andi	a5,a5,255
    800124ac:	fef43423          	sd	a5,-24(s0)
        switch (cause) {
    800124b0:	fe843703          	ld	a4,-24(s0)
    800124b4:	4795                	li	a5,5
    800124b6:	00f70863          	beq	a4,a5,800124c6 <os_trap_handler+0x64>
    800124ba:	fe843703          	ld	a4,-24(s0)
    800124be:	47a5                	li	a5,9
    800124c0:	00f70863          	beq	a4,a5,800124d0 <os_trap_handler+0x6e>
    800124c4:	a821                	j	800124dc <os_trap_handler+0x7a>
            case CAUSE_STIP:
                // Ack timer will reset the timer to INFINITE
                // In src/sbi.c
                debugf("HANDLING TIMER!!!!!!!!!!!!!!!\n");
                CSR_CLEAR("sip");
    800124c6:	14401073          	csrw	sip,zero
                sbi_ack_timer();
    800124ca:	05c070ef          	jal	ra,80019526 <sbi_ack_timer>
                // We typically invoke our scheduler if we get a timer
                // sched_invoke(hart);
                break;
    800124ce:	a211                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_SEIP:
                // Forward to src/plic.c
                debugf("Entering plic handle\n");
                plic_handle_irq(hart);
    800124d0:	fc442783          	lw	a5,-60(s0)
    800124d4:	853e                	mv	a0,a5
    800124d6:	33a070ef          	jal	ra,80019810 <plic_handle_irq>
                debugf("Left plic handle\n");
                
                // fatalf("Could not return from trap\n");
                break;
    800124da:	a8e5                	j	800125d2 <os_trap_handler+0x170>
            default:
                fatalf("Unhandled Asynchronous interrupt %ld\n", cause);
    800124dc:	fe843583          	ld	a1,-24(s0)
    800124e0:	00012517          	auipc	a0,0x12
    800124e4:	e3850513          	addi	a0,a0,-456 # 80024318 <pow10.0+0xe8>
    800124e8:	61d060ef          	jal	ra,80019304 <fatalf>
                WFI_LOOP();
    800124ec:	10500073          	wfi
    800124f0:	bff5                	j	800124ec <os_trap_handler+0x8a>
    800124f2:	fe843703          	ld	a4,-24(s0)
    800124f6:	47b5                	li	a5,13
    800124f8:	0ae7eb63          	bltu	a5,a4,800125ae <os_trap_handler+0x14c>
    800124fc:	fe843783          	ld	a5,-24(s0)
    80012500:	00279713          	slli	a4,a5,0x2
    80012504:	00012797          	auipc	a5,0x12
    80012508:	f4078793          	addi	a5,a5,-192 # 80024444 <pow10.0+0x214>
    8001250c:	97ba                	add	a5,a5,a4
    8001250e:	439c                	lw	a5,0(a5)
    80012510:	0007871b          	sext.w	a4,a5
    80012514:	00012797          	auipc	a5,0x12
    80012518:	f3078793          	addi	a5,a5,-208 # 80024444 <pow10.0+0x214>
    8001251c:	97ba                	add	a5,a5,a4
    8001251e:	8782                	jr	a5
    }
    else {
        debugf("Is sync!\n");
        switch (cause) {
            case CAUSE_ILLEGAL_INSTRUCTION:
                fatalf("Illegal instruction \"%x\" at %p\n", *((uint64_t*)epc), epc);
    80012520:	fd843783          	ld	a5,-40(s0)
    80012524:	639c                	ld	a5,0(a5)
    80012526:	fd843603          	ld	a2,-40(s0)
    8001252a:	85be                	mv	a1,a5
    8001252c:	00012517          	auipc	a0,0x12
    80012530:	e1450513          	addi	a0,a0,-492 # 80024340 <pow10.0+0x110>
    80012534:	5d1060ef          	jal	ra,80019304 <fatalf>
                CSR_WRITE("sepc", epc + 4);
    80012538:	fd843783          	ld	a5,-40(s0)
    8001253c:	0791                	addi	a5,a5,4
    8001253e:	14179073          	csrw	sepc,a5
                break;
    80012542:	a841                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_INSTRUCTION_ACCESS_FAULT:
                fatalf("Couldn't access instruction=%p at instruction %p\n", tval, epc);
    80012544:	fd843603          	ld	a2,-40(s0)
    80012548:	fd043583          	ld	a1,-48(s0)
    8001254c:	00012517          	auipc	a0,0x12
    80012550:	e1450513          	addi	a0,a0,-492 # 80024360 <pow10.0+0x130>
    80012554:	5b1060ef          	jal	ra,80019304 <fatalf>
                break;
    80012558:	a8ad                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_INSTRUCTION_PAGE_FAULT:
                fatalf("Instruction page fault at instruction %p accessing address %p\n", epc, tval);
    8001255a:	fd043603          	ld	a2,-48(s0)
    8001255e:	fd843583          	ld	a1,-40(s0)
    80012562:	00012517          	auipc	a0,0x12
    80012566:	e3650513          	addi	a0,a0,-458 # 80024398 <pow10.0+0x168>
    8001256a:	59b060ef          	jal	ra,80019304 <fatalf>
                break;
    8001256e:	a095                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_LOAD_PAGE_FAULT:
                fatalf("Load page fault at %p = %p", epc, tval);
    80012570:	fd043603          	ld	a2,-48(s0)
    80012574:	fd843583          	ld	a1,-40(s0)
    80012578:	00012517          	auipc	a0,0x12
    8001257c:	e6050513          	addi	a0,a0,-416 # 800243d8 <pow10.0+0x1a8>
    80012580:	585060ef          	jal	ra,80019304 <fatalf>
                break;
    80012584:	a0b9                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_ECALL_U_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                debugf("Handling syscall\n");
                syscall_handle(hart, epc, scratch);
    80012586:	fc442783          	lw	a5,-60(s0)
    8001258a:	fe043603          	ld	a2,-32(s0)
    8001258e:	fd843583          	ld	a1,-40(s0)
    80012592:	853e                	mv	a0,a5
    80012594:	e59fd0ef          	jal	ra,800103ec <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    80012598:	a82d                	j	800125d2 <os_trap_handler+0x170>
            case CAUSE_ECALL_S_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                debugf("Handling syscall\n");
                syscall_handle(hart, epc, scratch);
    8001259a:	fc442783          	lw	a5,-60(s0)
    8001259e:	fe043603          	ld	a2,-32(s0)
    800125a2:	fd843583          	ld	a1,-40(s0)
    800125a6:	853e                	mv	a0,a5
    800125a8:	e45fd0ef          	jal	ra,800103ec <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    800125ac:	a01d                	j	800125d2 <os_trap_handler+0x170>
            default:
                fatalf(
    800125ae:	fc442783          	lw	a5,-60(s0)
    800125b2:	873e                	mv	a4,a5
    800125b4:	fd043683          	ld	a3,-48(s0)
    800125b8:	fd843603          	ld	a2,-40(s0)
    800125bc:	fe843583          	ld	a1,-24(s0)
    800125c0:	00012517          	auipc	a0,0x12
    800125c4:	e3850513          	addi	a0,a0,-456 # 800243f8 <pow10.0+0x1c8>
    800125c8:	53d060ef          	jal	ra,80019304 <fatalf>
                    "Unhandled Synchronous interrupt %ld @ 0x%08lx [0x%08lx]. "
                    "Hanging hart %d\n",
                    cause, epc, tval, hart);
                WFI_LOOP();
    800125cc:	10500073          	wfi
    800125d0:	bff5                	j	800125cc <os_trap_handler+0x16a>
    // __asm__ volatile ("savegp");

    // SRET();
    debugf("Leaving OS trap handler\n");
    // fatalf("Could not return from trap\n");
    800125d2:	0001                	nop
    800125d4:	70e2                	ld	ra,56(sp)
    800125d6:	7442                	ld	s0,48(sp)
    800125d8:	6121                	addi	sp,sp,64
    800125da:	8082                	ret

00000000800125dc <rng_device_init>:

//use this like a queue
static Vector *rng_active_jobs;
static VirtioDevice *rng_device;

void rng_device_init() {
    800125dc:	1141                	addi	sp,sp,-16
    800125de:	e406                	sd	ra,8(sp)
    800125e0:	e022                	sd	s0,0(sp)
    800125e2:	0800                	addi	s0,sp,16
    rng_active_jobs = vector_new();
    800125e4:	1da0e0ef          	jal	ra,800207be <vector_new>
    800125e8:	872a                	mv	a4,a0
    800125ea:	00011797          	auipc	a5,0x11
    800125ee:	a3e78793          	addi	a5,a5,-1474 # 80023028 <rng_active_jobs>
    800125f2:	e398                	sd	a4,0(a5)
    rng_device = virtio_get_rng_device();
    800125f4:	1b0080ef          	jal	ra,8001a7a4 <virtio_get_rng_device>
    800125f8:	872a                	mv	a4,a0
    800125fa:	00011797          	auipc	a5,0x11
    800125fe:	a3678793          	addi	a5,a5,-1482 # 80023030 <rng_device>
    80012602:	e398                	sd	a4,0(a5)
    debugf("RNG init done for device at %p\n", rng_device->pcidev->ecam_header);
    80012604:	00011797          	auipc	a5,0x11
    80012608:	a2c78793          	addi	a5,a5,-1492 # 80023030 <rng_device>
    8001260c:	639c                	ld	a5,0(a5)
    8001260e:	63bc                	ld	a5,64(a5)
    80012610:	639c                	ld	a5,0(a5)
    80012612:	85be                	mv	a1,a5
    80012614:	00012517          	auipc	a0,0x12
    80012618:	e6c50513          	addi	a0,a0,-404 # 80024480 <pow10.0+0x250>
    8001261c:	38f060ef          	jal	ra,800191aa <debugf>
    virtio_set_device_name(rng_device, "RNG Device");
    80012620:	00011797          	auipc	a5,0x11
    80012624:	a1078793          	addi	a5,a5,-1520 # 80023030 <rng_device>
    80012628:	639c                	ld	a5,0(a5)
    8001262a:	00012597          	auipc	a1,0x12
    8001262e:	e7658593          	addi	a1,a1,-394 # 800244a0 <pow10.0+0x270>
    80012632:	853e                	mv	a0,a5
    80012634:	75e080ef          	jal	ra,8001ad92 <virtio_set_device_name>
    rng_device->ready = true;
    80012638:	00011797          	auipc	a5,0x11
    8001263c:	9f878793          	addi	a5,a5,-1544 # 80023030 <rng_device>
    80012640:	639c                	ld	a5,0(a5)
    80012642:	4705                	li	a4,1
    80012644:	08e78723          	sb	a4,142(a5)
}
    80012648:	0001                	nop
    8001264a:	60a2                	ld	ra,8(sp)
    8001264c:	6402                	ld	s0,0(sp)
    8001264e:	0141                	addi	sp,sp,16
    80012650:	8082                	ret

0000000080012652 <rng_fill>:


void rng_fill(void *virtual_buffer_address, uint16_t size) {
    80012652:	7179                	addi	sp,sp,-48
    80012654:	f406                	sd	ra,40(sp)
    80012656:	f022                	sd	s0,32(sp)
    80012658:	1800                	addi	s0,sp,48
    8001265a:	fca43c23          	sd	a0,-40(s0)
    8001265e:	87ae                	mv	a5,a1
    80012660:	fcf41b23          	sh	a5,-42(s0)
    if (!virtio_is_rng_device(rng_device)) {
    80012664:	00011797          	auipc	a5,0x11
    80012668:	9cc78793          	addi	a5,a5,-1588 # 80023030 <rng_device>
    8001266c:	639c                	ld	a5,0(a5)
    8001266e:	853e                	mv	a0,a5
    80012670:	787070ef          	jal	ra,8001a5f6 <virtio_is_rng_device>
    80012674:	87aa                	mv	a5,a0
    80012676:	0017c793          	xori	a5,a5,1
    8001267a:	0ff7f793          	andi	a5,a5,255
    8001267e:	c799                	beqz	a5,8001268c <rng_fill+0x3a>
        fatalf("[RNG] Incorrect device provided\n");
    80012680:	00012517          	auipc	a0,0x12
    80012684:	e3050513          	addi	a0,a0,-464 # 800244b0 <pow10.0+0x280>
    80012688:	47d060ef          	jal	ra,80019304 <fatalf>
    }

    if (!rng_device->ready) {
    8001268c:	00011797          	auipc	a5,0x11
    80012690:	9a478793          	addi	a5,a5,-1628 # 80023030 <rng_device>
    80012694:	639c                	ld	a5,0(a5)
    80012696:	08e7c783          	lbu	a5,142(a5)
    8001269a:	0017c793          	xori	a5,a5,1
    8001269e:	0ff7f793          	andi	a5,a5,255
    800126a2:	cb81                	beqz	a5,800126b2 <rng_fill+0x60>
        fatalf("RNG is not ready\n");
    800126a4:	00012517          	auipc	a0,0x12
    800126a8:	e3450513          	addi	a0,a0,-460 # 800244d8 <pow10.0+0x2a8>
    800126ac:	459060ef          	jal	ra,80019304 <fatalf>
    800126b0:	a089                	j	800126f2 <rng_fill+0xa0>
        return;
    }

    VirtioDescriptor desc;
    desc.addr = kernel_mmu_translate((uintptr_t)virtual_buffer_address);
    800126b2:	fd843783          	ld	a5,-40(s0)
    800126b6:	853e                	mv	a0,a5
    800126b8:	61a070ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    800126bc:	87aa                	mv	a5,a0
    800126be:	fef43023          	sd	a5,-32(s0)
    desc.len = size;
    800126c2:	fd645783          	lhu	a5,-42(s0)
    800126c6:	2781                	sext.w	a5,a5
    800126c8:	fef42423          	sw	a5,-24(s0)
    desc.flags = VIRTQ_DESC_F_WRITE;
    800126cc:	4789                	li	a5,2
    800126ce:	fef41623          	sh	a5,-20(s0)
    desc.next = 0;
    800126d2:	fe041723          	sh	zero,-18(s0)

    virtio_send_one_descriptor(rng_device, 0, desc, true);
    800126d6:	00011797          	auipc	a5,0x11
    800126da:	95a78793          	addi	a5,a5,-1702 # 80023030 <rng_device>
    800126de:	639c                	ld	a5,0(a5)
    800126e0:	4705                	li	a4,1
    800126e2:	fe043603          	ld	a2,-32(s0)
    800126e6:	fe843683          	ld	a3,-24(s0)
    800126ea:	4581                	li	a1,0
    800126ec:	853e                	mv	a0,a5
    800126ee:	08b080ef          	jal	ra,8001af78 <virtio_send_one_descriptor>
}
    800126f2:	70a2                	ld	ra,40(sp)
    800126f4:	7402                	ld	s0,32(sp)
    800126f6:	6145                	addi	sp,sp,48
    800126f8:	8082                	ret

00000000800126fa <pci_device_exists>:
// `irq_pci_devices` vector contains devices that share an IRQ number (32, 33, 34, and 35).
// These vectors contain the pointers to the devices in the ECAM address space.
static struct Vector *all_pci_devices, *irq_pci_devices[4];

static inline bool pci_device_exists(uint16_t vendor_id)
{
    800126fa:	1101                	addi	sp,sp,-32
    800126fc:	ec22                	sd	s0,24(sp)
    800126fe:	1000                	addi	s0,sp,32
    80012700:	87aa                	mv	a5,a0
    80012702:	fef41723          	sh	a5,-18(s0)
    return !((vendor_id == 0x0000) || (vendor_id == 0xFFFF));
    80012706:	fee45783          	lhu	a5,-18(s0)
    8001270a:	2781                	sext.w	a5,a5
    8001270c:	cb99                	beqz	a5,80012722 <pci_device_exists+0x28>
    8001270e:	fee45783          	lhu	a5,-18(s0)
    80012712:	0007871b          	sext.w	a4,a5
    80012716:	67c1                	lui	a5,0x10
    80012718:	17fd                	addi	a5,a5,-1
    8001271a:	00f70463          	beq	a4,a5,80012722 <pci_device_exists+0x28>
    8001271e:	4785                	li	a5,1
    80012720:	a011                	j	80012724 <pci_device_exists+0x2a>
    80012722:	4781                	li	a5,0
    80012724:	8b85                	andi	a5,a5,1
    80012726:	0ff7f793          	andi	a5,a5,255
}
    8001272a:	853e                	mv	a0,a5
    8001272c:	6462                	ld	s0,24(sp)
    8001272e:	6105                	addi	sp,sp,32
    80012730:	8082                	ret

0000000080012732 <pci_is_virtio_device>:

// Is this a virtio device?
bool pci_is_virtio_device(PCIDevice *dev) {
    80012732:	1101                	addi	sp,sp,-32
    80012734:	ec22                	sd	s0,24(sp)
    80012736:	1000                	addi	s0,sp,32
    80012738:	fea43423          	sd	a0,-24(s0)
    return dev->ecam_header->vendor_id == 0x1AF4;
    8001273c:	fe843783          	ld	a5,-24(s0)
    80012740:	639c                	ld	a5,0(a5)
    80012742:	0007d783          	lhu	a5,0(a5) # 10000 <i+0xffe0>
    80012746:	17c2                	slli	a5,a5,0x30
    80012748:	93c1                	srli	a5,a5,0x30
    8001274a:	0007871b          	sext.w	a4,a5
    8001274e:	6789                	lui	a5,0x2
    80012750:	af478793          	addi	a5,a5,-1292 # 1af4 <i+0x1ad4>
    80012754:	40f707b3          	sub	a5,a4,a5
    80012758:	0017b793          	seqz	a5,a5
    8001275c:	0ff7f793          	andi	a5,a5,255
}
    80012760:	853e                	mv	a0,a5
    80012762:	6462                	ld	s0,24(sp)
    80012764:	6105                	addi	sp,sp,32
    80012766:	8082                	ret

0000000080012768 <pci_find_saved_device>:

// Find the saved PCI device with the given vendor and device ID.
// This will retrieve the bookkeeping structure for the PCI device
// maintained by the OS.
PCIDevice *pci_find_saved_device(uint16_t vendor_id, uint16_t device_id) {
    80012768:	7179                	addi	sp,sp,-48
    8001276a:	f406                	sd	ra,40(sp)
    8001276c:	f022                	sd	s0,32(sp)
    8001276e:	1800                	addi	s0,sp,48
    80012770:	87aa                	mv	a5,a0
    80012772:	872e                	mv	a4,a1
    80012774:	fcf41f23          	sh	a5,-34(s0)
    80012778:	87ba                	mv	a5,a4
    8001277a:	fcf41e23          	sh	a5,-36(s0)
    // debugf("Searching for device with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    // Iterate through the devices
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    8001277e:	fe042623          	sw	zero,-20(s0)
    80012782:	a8a1                	j	800127da <pci_find_saved_device+0x72>
        // Check if the device has the given vendor and device ID
        PCIDevice *pcidev = pci_get_nth_saved_device(i);
    80012784:	fec42783          	lw	a5,-20(s0)
    80012788:	17c2                	slli	a5,a5,0x30
    8001278a:	93c1                	srli	a5,a5,0x30
    8001278c:	853e                	mv	a0,a5
    8001278e:	32e000ef          	jal	ra,80012abc <pci_get_nth_saved_device>
    80012792:	fea43023          	sd	a0,-32(s0)
        // debugf("Checking device with vendor ID: 0x%04x, device ID: 0x%04x\n", pcidev->ecam_header->vendor_id, pcidev->ecam_header->device_id);
        if (pcidev->ecam_header->vendor_id == vendor_id && pcidev->ecam_header->device_id == device_id) {
    80012796:	fe043783          	ld	a5,-32(s0)
    8001279a:	639c                	ld	a5,0(a5)
    8001279c:	0007d783          	lhu	a5,0(a5)
    800127a0:	17c2                	slli	a5,a5,0x30
    800127a2:	93c1                	srli	a5,a5,0x30
    800127a4:	fde45703          	lhu	a4,-34(s0)
    800127a8:	2701                	sext.w	a4,a4
    800127aa:	2781                	sext.w	a5,a5
    800127ac:	02f71263          	bne	a4,a5,800127d0 <pci_find_saved_device+0x68>
    800127b0:	fe043783          	ld	a5,-32(s0)
    800127b4:	639c                	ld	a5,0(a5)
    800127b6:	0027d783          	lhu	a5,2(a5)
    800127ba:	17c2                	slli	a5,a5,0x30
    800127bc:	93c1                	srli	a5,a5,0x30
    800127be:	fdc45703          	lhu	a4,-36(s0)
    800127c2:	2701                	sext.w	a4,a4
    800127c4:	2781                	sext.w	a5,a5
    800127c6:	00f71563          	bne	a4,a5,800127d0 <pci_find_saved_device+0x68>
            return pcidev;
    800127ca:	fe043783          	ld	a5,-32(s0)
    800127ce:	a03d                	j	800127fc <pci_find_saved_device+0x94>
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    800127d0:	fec42783          	lw	a5,-20(s0)
    800127d4:	2785                	addiw	a5,a5,1
    800127d6:	fef42623          	sw	a5,-20(s0)
    800127da:	00011797          	auipc	a5,0x11
    800127de:	85e78793          	addi	a5,a5,-1954 # 80023038 <all_pci_devices>
    800127e2:	639c                	ld	a5,0(a5)
    800127e4:	853e                	mv	a0,a5
    800127e6:	1390e0ef          	jal	ra,8002111e <vector_size>
    800127ea:	87aa                	mv	a5,a0
    800127ec:	0007871b          	sext.w	a4,a5
    800127f0:	fec42783          	lw	a5,-20(s0)
    800127f4:	2781                	sext.w	a5,a5
    800127f6:	f8e7e7e3          	bltu	a5,a4,80012784 <pci_find_saved_device+0x1c>
        }
    }
    // If we get here, we didn't find the device
    // debugf("No device found with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    return NULL;
    800127fa:	4781                	li	a5,0
}
    800127fc:	853e                	mv	a0,a5
    800127fe:	70a2                	ld	ra,40(sp)
    80012800:	7402                	ld	s0,32(sp)
    80012802:	6145                	addi	sp,sp,48
    80012804:	8082                	ret

0000000080012806 <pci_get_capability>:

// Get the nth PCI capability for the PCI device. This is used with `0x9` as the type
// to enumerate all of the several Virtio capabilities for a PCI device with the Virtio
// vendor ID.
volatile struct pci_cape *pci_get_capability(PCIDevice *device, uint8_t type, uint8_t nth) {
    80012806:	7139                	addi	sp,sp,-64
    80012808:	fc22                	sd	s0,56(sp)
    8001280a:	0080                	addi	s0,sp,64
    8001280c:	fca43423          	sd	a0,-56(s0)
    80012810:	87ae                	mv	a5,a1
    80012812:	8732                	mv	a4,a2
    80012814:	fcf403a3          	sb	a5,-57(s0)
    80012818:	87ba                	mv	a5,a4
    8001281a:	fcf40323          	sb	a5,-58(s0)
    // Get the header for the device
    volatile struct pci_ecam *header = device->ecam_header;
    8001281e:	fc843783          	ld	a5,-56(s0)
    80012822:	639c                	ld	a5,0(a5)
    80012824:	fef43023          	sd	a5,-32(s0)
    if (!(header->status_reg & (1 << 4))) {
    80012828:	fe043783          	ld	a5,-32(s0)
    8001282c:	0067d783          	lhu	a5,6(a5)
    80012830:	17c2                	slli	a5,a5,0x30
    80012832:	93c1                	srli	a5,a5,0x30
    80012834:	2781                	sext.w	a5,a5
    80012836:	8bc1                	andi	a5,a5,16
    80012838:	2781                	sext.w	a5,a5
    8001283a:	e399                	bnez	a5,80012840 <pci_get_capability+0x3a>
        debugf("Status reg bit 4 not set; no capabilities for device\n");
        return NULL;
    8001283c:	4781                	li	a5,0
    8001283e:	a055                	j	800128e2 <pci_get_capability+0xdc>
    }
    
    // Get the offset of the first capability
    uint8_t cap_pointer = header->type0.capes_pointer;
    80012840:	fe043783          	ld	a5,-32(s0)
    80012844:	0347c783          	lbu	a5,52(a5)
    80012848:	fef407a3          	sb	a5,-17(s0)
    // Count the number of capabilities we've seen
    uint8_t count = 0;
    8001284c:	fe040723          	sb	zero,-18(s0)
    
    // While the capability pointer is not zero
    while (cap_pointer) {
    80012850:	a059                	j	800128d6 <pci_get_capability+0xd0>
        // Get the capability at the offset
        volatile struct pci_cape* cape = (struct pci_cape*)((uintptr_t)header + cap_pointer);
    80012852:	fef44703          	lbu	a4,-17(s0)
    80012856:	fe043783          	ld	a5,-32(s0)
    8001285a:	97ba                	add	a5,a5,a4
    8001285c:	fcf43c23          	sd	a5,-40(s0)
        // If the capability ID matches the type we're looking for
        switch (cape->id) {
    80012860:	fd843783          	ld	a5,-40(s0)
    80012864:	0007c783          	lbu	a5,0(a5)
    80012868:	0ff7f793          	andi	a5,a5,255
    8001286c:	2781                	sext.w	a5,a5
    8001286e:	86be                	mv	a3,a5
    80012870:	4725                	li	a4,9
    80012872:	00e68e63          	beq	a3,a4,8001288e <pci_get_capability+0x88>
    80012876:	86be                	mv	a3,a5
    80012878:	4725                	li	a4,9
    8001287a:	00e6cc63          	blt	a3,a4,80012892 <pci_get_capability+0x8c>
    8001287e:	2781                	sext.w	a5,a5
    80012880:	37c1                	addiw	a5,a5,-16
    80012882:	2781                	sext.w	a5,a5
    80012884:	873e                	mv	a4,a5
    80012886:	4785                	li	a5,1
    80012888:	00e7e563          	bltu	a5,a4,80012892 <pci_get_capability+0x8c>
            {
            }
            case 0x11: /* MSI-x */
            {
            }
            break;
    8001288c:	a021                	j	80012894 <pci_get_capability+0x8e>
            break;
    8001288e:	0001                	nop
    80012890:	a011                	j	80012894 <pci_get_capability+0x8e>
            default:
                debugf("Unknown capability ID 0x%02x (next: 0x%02x)\n", cape->id, cape->next);
            break;
    80012892:	0001                	nop
        }

        if (cape->id == type) {
    80012894:	fd843783          	ld	a5,-40(s0)
    80012898:	0007c783          	lbu	a5,0(a5)
    8001289c:	0ff7f713          	andi	a4,a5,255
    800128a0:	fc744783          	lbu	a5,-57(s0)
    800128a4:	0ff7f793          	andi	a5,a5,255
    800128a8:	02e79163          	bne	a5,a4,800128ca <pci_get_capability+0xc4>
            // If we've seen the nth capability, return it
            if (count++ == nth) {
    800128ac:	fee44783          	lbu	a5,-18(s0)
    800128b0:	0017871b          	addiw	a4,a5,1
    800128b4:	fee40723          	sb	a4,-18(s0)
    800128b8:	fc644703          	lbu	a4,-58(s0)
    800128bc:	0ff77713          	andi	a4,a4,255
    800128c0:	00f71563          	bne	a4,a5,800128ca <pci_get_capability+0xc4>
                return cape;
    800128c4:	fd843783          	ld	a5,-40(s0)
    800128c8:	a829                	j	800128e2 <pci_get_capability+0xdc>
            }
        }
        // Otherwise, continue to the next capability
        cap_pointer = cape->next; 
    800128ca:	fd843783          	ld	a5,-40(s0)
    800128ce:	0017c783          	lbu	a5,1(a5)
    800128d2:	fef407a3          	sb	a5,-17(s0)
    while (cap_pointer) {
    800128d6:	fef44783          	lbu	a5,-17(s0)
    800128da:	0ff7f793          	andi	a5,a5,255
    800128de:	fbb5                	bnez	a5,80012852 <pci_get_capability+0x4c>
    }
    return NULL;
    800128e0:	4781                	li	a5,0
}
    800128e2:	853e                	mv	a0,a5
    800128e4:	7462                	ld	s0,56(sp)
    800128e6:	6121                	addi	sp,sp,64
    800128e8:	8082                	ret

00000000800128ea <pci_get_virtio_capability>:
// For the common configuration capability, use `VIRTIO_PCI_CAP_COMMON_CFG`.
// For the notify capability, use `VIRTIO_PCI_CAP_NOTIFY_CFG`.
// For the ISR capability, use `VIRTIO_PCI_CAP_ISR_CFG`.
// For the device configuration capability, use `VIRTIO_PCI_CAP_DEVICE_CFG`.
// For the PCI configuration access capability, use `VIRTIO_PCI_CAP_PCI_CFG`.
volatile struct VirtioCapability *pci_get_virtio_capability(PCIDevice *device, uint8_t virtio_cap_type) {
    800128ea:	7139                	addi	sp,sp,-64
    800128ec:	fc06                	sd	ra,56(sp)
    800128ee:	f822                	sd	s0,48(sp)
    800128f0:	0080                	addi	s0,sp,64
    800128f2:	fca43423          	sd	a0,-56(s0)
    800128f6:	87ae                	mv	a5,a1
    800128f8:	fcf403a3          	sb	a5,-57(s0)
    // Iterate through the first 10 capabilities
    for (uint8_t i=0; i<10; i++) {
    800128fc:	fe0407a3          	sb	zero,-17(s0)
    80012900:	a0b1                	j	8001294c <pci_get_virtio_capability+0x62>
        // Get the capability
        volatile struct pci_cape *cape = pci_get_capability(device, 0x09, i);
    80012902:	fef44783          	lbu	a5,-17(s0)
    80012906:	863e                	mv	a2,a5
    80012908:	45a5                	li	a1,9
    8001290a:	fc843503          	ld	a0,-56(s0)
    8001290e:	ef9ff0ef          	jal	ra,80012806 <pci_get_capability>
    80012912:	fea43023          	sd	a0,-32(s0)
        volatile struct VirtioCapability *virtio_cap = (struct VirtioCapability *)cape;
    80012916:	fe043783          	ld	a5,-32(s0)
    8001291a:	fcf43c23          	sd	a5,-40(s0)
        // If the capability isnt NULL and the type matches, return it
        if (virtio_cap && virtio_cap->type == virtio_cap_type) {
    8001291e:	fd843783          	ld	a5,-40(s0)
    80012922:	c385                	beqz	a5,80012942 <pci_get_virtio_capability+0x58>
    80012924:	fd843783          	ld	a5,-40(s0)
    80012928:	0037c783          	lbu	a5,3(a5)
    8001292c:	0ff7f713          	andi	a4,a5,255
    80012930:	fc744783          	lbu	a5,-57(s0)
    80012934:	0ff7f793          	andi	a5,a5,255
    80012938:	00e79563          	bne	a5,a4,80012942 <pci_get_virtio_capability+0x58>
            debugf("Got capability of type %x at %p\n", virtio_cap_type, virtio_cap);
            return virtio_cap;
    8001293c:	fd843783          	ld	a5,-40(s0)
    80012940:	a831                	j	8001295c <pci_get_virtio_capability+0x72>
    for (uint8_t i=0; i<10; i++) {
    80012942:	fef44783          	lbu	a5,-17(s0)
    80012946:	2785                	addiw	a5,a5,1
    80012948:	fef407a3          	sb	a5,-17(s0)
    8001294c:	fef44783          	lbu	a5,-17(s0)
    80012950:	0ff7f713          	andi	a4,a5,255
    80012954:	47a5                	li	a5,9
    80012956:	fae7f6e3          	bgeu	a5,a4,80012902 <pci_get_virtio_capability+0x18>
        }
    }
    // If we get here, we didn't find the capability
    debugf("No virtio capability found with type %d\n", virtio_cap_type);
    return NULL;
    8001295a:	4781                	li	a5,0
}
    8001295c:	853e                	mv	a0,a5
    8001295e:	70e2                	ld	ra,56(sp)
    80012960:	7442                	ld	s0,48(sp)
    80012962:	6121                	addi	sp,sp,64
    80012964:	8082                	ret

0000000080012966 <pci_count_saved_devices>:

// Return the number of bookkeeping PCI devices saved by the OS.
uint64_t pci_count_saved_devices(void) {
    80012966:	1141                	addi	sp,sp,-16
    80012968:	e406                	sd	ra,8(sp)
    8001296a:	e022                	sd	s0,0(sp)
    8001296c:	0800                	addi	s0,sp,16
    return vector_size(all_pci_devices);
    8001296e:	00010797          	auipc	a5,0x10
    80012972:	6ca78793          	addi	a5,a5,1738 # 80023038 <all_pci_devices>
    80012976:	639c                	ld	a5,0(a5)
    80012978:	853e                	mv	a0,a5
    8001297a:	7a40e0ef          	jal	ra,8002111e <vector_size>
    8001297e:	87aa                	mv	a5,a0
    80012980:	2781                	sext.w	a5,a5
    80012982:	1782                	slli	a5,a5,0x20
    80012984:	9381                	srli	a5,a5,0x20
}
    80012986:	853e                	mv	a0,a5
    80012988:	60a2                	ld	ra,8(sp)
    8001298a:	6402                	ld	s0,0(sp)
    8001298c:	0141                	addi	sp,sp,16
    8001298e:	8082                	ret

0000000080012990 <pci_count_irq_listeners>:

// Count how many devices are listening for the given IRQ.
uint64_t pci_count_irq_listeners(uint8_t irq) {
    80012990:	7179                	addi	sp,sp,-48
    80012992:	f406                	sd	ra,40(sp)
    80012994:	f022                	sd	s0,32(sp)
    80012996:	1800                	addi	s0,sp,48
    80012998:	87aa                	mv	a5,a0
    8001299a:	fcf40fa3          	sb	a5,-33(s0)
    uint32_t vector_idx = irq - 32;
    8001299e:	fdf44783          	lbu	a5,-33(s0)
    800129a2:	2781                	sext.w	a5,a5
    800129a4:	3781                	addiw	a5,a5,-32
    800129a6:	2781                	sext.w	a5,a5
    800129a8:	fef42623          	sw	a5,-20(s0)
    return vector_size(irq_pci_devices[vector_idx]);
    800129ac:	00010717          	auipc	a4,0x10
    800129b0:	69470713          	addi	a4,a4,1684 # 80023040 <irq_pci_devices>
    800129b4:	fec46783          	lwu	a5,-20(s0)
    800129b8:	078e                	slli	a5,a5,0x3
    800129ba:	97ba                	add	a5,a5,a4
    800129bc:	639c                	ld	a5,0(a5)
    800129be:	853e                	mv	a0,a5
    800129c0:	75e0e0ef          	jal	ra,8002111e <vector_size>
    800129c4:	87aa                	mv	a5,a0
    800129c6:	2781                	sext.w	a5,a5
    800129c8:	1782                	slli	a5,a5,0x20
    800129ca:	9381                	srli	a5,a5,0x20
}
    800129cc:	853e                	mv	a0,a5
    800129ce:	70a2                	ld	ra,40(sp)
    800129d0:	7402                	ld	s0,32(sp)
    800129d2:	6145                	addi	sp,sp,48
    800129d4:	8082                	ret

00000000800129d6 <pci_get_bus_number>:

// Get the bus number for the given PCI device.
uint8_t pci_get_bus_number(PCIDevice *dev) {
    800129d6:	1101                	addi	sp,sp,-32
    800129d8:	ec22                	sd	s0,24(sp)
    800129da:	1000                	addi	s0,sp,32
    800129dc:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 20) & 0xF;
    800129e0:	fe843783          	ld	a5,-24(s0)
    800129e4:	639c                	ld	a5,0(a5)
    800129e6:	83d1                	srli	a5,a5,0x14
    800129e8:	0ff7f793          	andi	a5,a5,255
    800129ec:	8bbd                	andi	a5,a5,15
    800129ee:	0ff7f793          	andi	a5,a5,255
}
    800129f2:	853e                	mv	a0,a5
    800129f4:	6462                	ld	s0,24(sp)
    800129f6:	6105                	addi	sp,sp,32
    800129f8:	8082                	ret

00000000800129fa <pci_get_slot_number>:

// Get the slot number for the given PCI device.
uint8_t pci_get_slot_number(PCIDevice *dev) {
    800129fa:	1101                	addi	sp,sp,-32
    800129fc:	ec22                	sd	s0,24(sp)
    800129fe:	1000                	addi	s0,sp,32
    80012a00:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 15) & 0x1F;
    80012a04:	fe843783          	ld	a5,-24(s0)
    80012a08:	639c                	ld	a5,0(a5)
    80012a0a:	83bd                	srli	a5,a5,0xf
    80012a0c:	0ff7f793          	andi	a5,a5,255
    80012a10:	8bfd                	andi	a5,a5,31
    80012a12:	0ff7f793          	andi	a5,a5,255
}
    80012a16:	853e                	mv	a0,a5
    80012a18:	6462                	ld	s0,24(sp)
    80012a1a:	6105                	addi	sp,sp,32
    80012a1c:	8082                	ret

0000000080012a1e <pci_save_device>:

// Save the PCI device for bookkeeping. This will save some
// information about the device for quick access later.
PCIDevice *pci_save_device(PCIDevice device) {
    80012a1e:	7179                	addi	sp,sp,-48
    80012a20:	f406                	sd	ra,40(sp)
    80012a22:	f022                	sd	s0,32(sp)
    80012a24:	ec26                	sd	s1,24(sp)
    80012a26:	1800                	addi	s0,sp,48
    80012a28:	84aa                	mv	s1,a0
    // Allocate some memory for the device's bookkeeping structure
    PCIDevice *pcidev = (PCIDevice *)kzalloc(sizeof(PCIDevice));
    80012a2a:	03800593          	li	a1,56
    80012a2e:	4505                	li	a0,1
    80012a30:	286010ef          	jal	ra,80013cb6 <kcalloc>
    80012a34:	fca43c23          	sd	a0,-40(s0)
    // Record the device's ECAM header
    memcpy(pcidev, &device, sizeof(PCIDevice));
    80012a38:	03800613          	li	a2,56
    80012a3c:	85a6                	mv	a1,s1
    80012a3e:	fd843503          	ld	a0,-40(s0)
    80012a42:	42c0d0ef          	jal	ra,8001fe6e <memcpy>
    // Store the device in the all devices vector
    vector_push_ptr(all_pci_devices, pcidev);
    80012a46:	00010797          	auipc	a5,0x10
    80012a4a:	5f278793          	addi	a5,a5,1522 # 80023038 <all_pci_devices>
    80012a4e:	639c                	ld	a5,0(a5)
    80012a50:	fd843703          	ld	a4,-40(s0)
    80012a54:	85ba                	mv	a1,a4
    80012a56:	853e                	mv	a0,a5
    80012a58:	6070d0ef          	jal	ra,8002085e <vector_push>
    // Store the device in the appropriate IRQ vector
    uint8_t bus = pci_get_bus_number(pcidev);
    80012a5c:	fd843503          	ld	a0,-40(s0)
    80012a60:	f77ff0ef          	jal	ra,800129d6 <pci_get_bus_number>
    80012a64:	87aa                	mv	a5,a0
    80012a66:	fcf40ba3          	sb	a5,-41(s0)
    uint8_t slot = pci_get_slot_number(pcidev);
    80012a6a:	fd843503          	ld	a0,-40(s0)
    80012a6e:	f8dff0ef          	jal	ra,800129fa <pci_get_slot_number>
    80012a72:	87aa                	mv	a5,a0
    80012a74:	fcf40b23          	sb	a5,-42(s0)
    debugf("Saving device with vendor ID: 0x%04x, device ID: 0x%04x, class code: 0x%04x\n", device.ecam_header->vendor_id, device.ecam_header->device_id, device.ecam_header->class_code);
    debugf("  Bus: %d, slot: %d\n", bus, slot);
    uint32_t vector_idx = (bus + slot) % 4;
    80012a78:	fd744703          	lbu	a4,-41(s0)
    80012a7c:	fd644783          	lbu	a5,-42(s0)
    80012a80:	9fb9                	addw	a5,a5,a4
    80012a82:	0ff7f793          	andi	a5,a5,255
    80012a86:	2781                	sext.w	a5,a5
    80012a88:	8b8d                	andi	a5,a5,3
    80012a8a:	fcf42823          	sw	a5,-48(s0)
    vector_push_ptr(irq_pci_devices[vector_idx], pcidev);
    80012a8e:	00010717          	auipc	a4,0x10
    80012a92:	5b270713          	addi	a4,a4,1458 # 80023040 <irq_pci_devices>
    80012a96:	fd046783          	lwu	a5,-48(s0)
    80012a9a:	078e                	slli	a5,a5,0x3
    80012a9c:	97ba                	add	a5,a5,a4
    80012a9e:	639c                	ld	a5,0(a5)
    80012aa0:	fd843703          	ld	a4,-40(s0)
    80012aa4:	85ba                	mv	a1,a4
    80012aa6:	853e                	mv	a0,a5
    80012aa8:	5b70d0ef          	jal	ra,8002085e <vector_push>
    // Return the device's bookkeeping structure in memory
    return pcidev;
    80012aac:	fd843783          	ld	a5,-40(s0)
}
    80012ab0:	853e                	mv	a0,a5
    80012ab2:	70a2                	ld	ra,40(sp)
    80012ab4:	7402                	ld	s0,32(sp)
    80012ab6:	64e2                	ld	s1,24(sp)
    80012ab8:	6145                	addi	sp,sp,48
    80012aba:	8082                	ret

0000000080012abc <pci_get_nth_saved_device>:

// Get the nth saved PCI device structure kept by the OS.
PCIDevice *pci_get_nth_saved_device(uint16_t n) {
    80012abc:	7179                	addi	sp,sp,-48
    80012abe:	f406                	sd	ra,40(sp)
    80012ac0:	f022                	sd	s0,32(sp)
    80012ac2:	1800                	addi	s0,sp,48
    80012ac4:	87aa                	mv	a5,a0
    80012ac6:	fcf41f23          	sh	a5,-34(s0)
    PCIDevice *pcidev;
    vector_get_ptr(all_pci_devices, n, &pcidev);
    80012aca:	00010797          	auipc	a5,0x10
    80012ace:	56e78793          	addi	a5,a5,1390 # 80023038 <all_pci_devices>
    80012ad2:	639c                	ld	a5,0(a5)
    80012ad4:	fde45703          	lhu	a4,-34(s0)
    80012ad8:	2701                	sext.w	a4,a4
    80012ada:	fe840693          	addi	a3,s0,-24
    80012ade:	8636                	mv	a2,a3
    80012ae0:	85ba                	mv	a1,a4
    80012ae2:	853e                	mv	a0,a5
    80012ae4:	6db0d0ef          	jal	ra,800209be <vector_get>
    return pcidev;
    80012ae8:	fe843783          	ld	a5,-24(s0)
}
    80012aec:	853e                	mv	a0,a5
    80012aee:	70a2                	ld	ra,40(sp)
    80012af0:	7402                	ld	s0,32(sp)
    80012af2:	6145                	addi	sp,sp,48
    80012af4:	8082                	ret

0000000080012af6 <pci_find_device_by_irq>:

// Get the device responsible for a given IRQ.
PCIDevice *pci_find_device_by_irq(uint8_t irq) {
    80012af6:	7139                	addi	sp,sp,-64
    80012af8:	fc06                	sd	ra,56(sp)
    80012afa:	f822                	sd	s0,48(sp)
    80012afc:	0080                	addi	s0,sp,64
    80012afe:	87aa                	mv	a5,a0
    80012b00:	fcf407a3          	sb	a5,-49(s0)
    uint32_t vector_idx = irq - 32;
    80012b04:	fcf44783          	lbu	a5,-49(s0)
    80012b08:	2781                	sext.w	a5,a5
    80012b0a:	3781                	addiw	a5,a5,-32
    80012b0c:	2781                	sext.w	a5,a5
    80012b0e:	fef42423          	sw	a5,-24(s0)
    debugf("Finding device with IRQ %d\n", irq);

    // Check all devices in the vector
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    80012b12:	fe042623          	sw	zero,-20(s0)
    80012b16:	a875                	j	80012bd2 <pci_find_device_by_irq+0xdc>
        // Get the nth PCI device listening for the IRQ
        PCIDevice *device = NULL;
    80012b18:	fc043823          	sd	zero,-48(s0)
        vector_get_ptr(irq_pci_devices[vector_idx], i, &device);
    80012b1c:	00010717          	auipc	a4,0x10
    80012b20:	52470713          	addi	a4,a4,1316 # 80023040 <irq_pci_devices>
    80012b24:	fe846783          	lwu	a5,-24(s0)
    80012b28:	078e                	slli	a5,a5,0x3
    80012b2a:	97ba                	add	a5,a5,a4
    80012b2c:	639c                	ld	a5,0(a5)
    80012b2e:	fd040693          	addi	a3,s0,-48
    80012b32:	fec42703          	lw	a4,-20(s0)
    80012b36:	8636                	mv	a2,a3
    80012b38:	85ba                	mv	a1,a4
    80012b3a:	853e                	mv	a0,a5
    80012b3c:	6830d0ef          	jal	ra,800209be <vector_get>
        debugf("Device: %p\n", device->ecam_header);
        // If the device is a Virtio device, check the Virtio ISR status
        if (!pci_is_virtio_device(device)) {
    80012b40:	fd043783          	ld	a5,-48(s0)
    80012b44:	853e                	mv	a0,a5
    80012b46:	bedff0ef          	jal	ra,80012732 <pci_is_virtio_device>
    80012b4a:	87aa                	mv	a5,a0
    80012b4c:	0017c793          	xori	a5,a5,1
    80012b50:	0ff7f793          	andi	a5,a5,255
    80012b54:	e7bd                	bnez	a5,80012bc2 <pci_find_device_by_irq+0xcc>
            debugf("%p not a virtio device\n", device);
            continue;
        }
        
        // Confirm that the device exists
        if (!pci_device_exists(device->ecam_header->vendor_id)) {
    80012b56:	fd043783          	ld	a5,-48(s0)
    80012b5a:	639c                	ld	a5,0(a5)
    80012b5c:	0007d783          	lhu	a5,0(a5)
    80012b60:	17c2                	slli	a5,a5,0x30
    80012b62:	93c1                	srli	a5,a5,0x30
    80012b64:	853e                	mv	a0,a5
    80012b66:	b95ff0ef          	jal	ra,800126fa <pci_device_exists>
    80012b6a:	87aa                	mv	a5,a0
    80012b6c:	0017c793          	xori	a5,a5,1
    80012b70:	0ff7f793          	andi	a5,a5,255
    80012b74:	eba9                	bnez	a5,80012bc6 <pci_find_device_by_irq+0xd0>
            debugf("%p device doesn't exist\n", device);
            continue;
        }

        // Get the Virtio ISR status
        volatile struct VirtioPciIsrCfg *isr = pci_get_virtio_isr_status(device);
    80012b76:	fd043783          	ld	a5,-48(s0)
    80012b7a:	853e                	mv	a0,a5
    80012b7c:	19e000ef          	jal	ra,80012d1a <pci_get_virtio_isr_status>
    80012b80:	fea43023          	sd	a0,-32(s0)
        int result = isr->isr_cap;
    80012b84:	fe043783          	ld	a5,-32(s0)
    80012b88:	439c                	lw	a5,0(a5)
    80012b8a:	2781                	sext.w	a5,a5
    80012b8c:	fcf42e23          	sw	a5,-36(s0)
        debugf("ISR at %p=0x%x\n", isr, result);
        if (result) {
    80012b90:	fdc42783          	lw	a5,-36(s0)
    80012b94:	2781                	sext.w	a5,a5
    80012b96:	c781                	beqz	a5,80012b9e <pci_find_device_by_irq+0xa8>
            debugf("IRQ device responsible: %p\n", device);
            return device;
    80012b98:	fd043783          	ld	a5,-48(s0)
    80012b9c:	a085                	j	80012bfc <pci_find_device_by_irq+0x106>
        }

        // Check if the device's configuration has changed
        if (isr->isr_cap) {
    80012b9e:	fe043783          	ld	a5,-32(s0)
    80012ba2:	439c                	lw	a5,0(a5)
    80012ba4:	2781                	sext.w	a5,a5
    80012ba6:	c781                	beqz	a5,80012bae <pci_find_device_by_irq+0xb8>
            debugf("Device configuration interrupt from device 0x%04x\n", device->ecam_header->device_id);
            return device;
    80012ba8:	fd043783          	ld	a5,-48(s0)
    80012bac:	a881                	j	80012bfc <pci_find_device_by_irq+0x106>
        }

        // Check if the device's queue has an interrupt
        if (isr->queue_interrupt) {
    80012bae:	fe043783          	ld	a5,-32(s0)
    80012bb2:	439c                	lw	a5,0(a5)
    80012bb4:	8b85                	andi	a5,a5,1
    80012bb6:	0ff7f793          	andi	a5,a5,255
    80012bba:	c799                	beqz	a5,80012bc8 <pci_find_device_by_irq+0xd2>
            debugf("Device queue interrupt from device 0x%04x\n", device->ecam_header->device_id);
            return device;
    80012bbc:	fd043783          	ld	a5,-48(s0)
    80012bc0:	a835                	j	80012bfc <pci_find_device_by_irq+0x106>
            continue;
    80012bc2:	0001                	nop
    80012bc4:	a011                	j	80012bc8 <pci_find_device_by_irq+0xd2>
            continue;
    80012bc6:	0001                	nop
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    80012bc8:	fec42783          	lw	a5,-20(s0)
    80012bcc:	2785                	addiw	a5,a5,1
    80012bce:	fef42623          	sw	a5,-20(s0)
    80012bd2:	00010717          	auipc	a4,0x10
    80012bd6:	46e70713          	addi	a4,a4,1134 # 80023040 <irq_pci_devices>
    80012bda:	fe846783          	lwu	a5,-24(s0)
    80012bde:	078e                	slli	a5,a5,0x3
    80012be0:	97ba                	add	a5,a5,a4
    80012be2:	639c                	ld	a5,0(a5)
    80012be4:	853e                	mv	a0,a5
    80012be6:	5380e0ef          	jal	ra,8002111e <vector_size>
    80012bea:	87aa                	mv	a5,a0
    80012bec:	0007871b          	sext.w	a4,a5
    80012bf0:	fec42783          	lw	a5,-20(s0)
    80012bf4:	2781                	sext.w	a5,a5
    80012bf6:	f2e7e1e3          	bltu	a5,a4,80012b18 <pci_find_device_by_irq+0x22>
        }
    }
    debugf("No device found with IRQ %d\n", irq);
    return NULL;
    80012bfa:	4781                	li	a5,0
}
    80012bfc:	853e                	mv	a0,a5
    80012bfe:	70e2                	ld	ra,56(sp)
    80012c00:	7442                	ld	s0,48(sp)
    80012c02:	6121                	addi	sp,sp,64
    80012c04:	8082                	ret

0000000080012c06 <pci_get_device_specific_config>:


// Get the common configuration capability for the given virtio device.
volatile void *pci_get_device_specific_config(PCIDevice *device) {
    80012c06:	7179                	addi	sp,sp,-48
    80012c08:	f406                	sd	ra,40(sp)
    80012c0a:	f022                	sd	s0,32(sp)
    80012c0c:	1800                	addi	s0,sp,48
    80012c0e:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_DEVICE_CFG);
    80012c12:	4591                	li	a1,4
    80012c14:	fd843503          	ld	a0,-40(s0)
    80012c18:	cd3ff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012c1c:	fea43423          	sd	a0,-24(s0)
    debugf("Getting device specific config from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uint64_t)vio_cap->offset);
    return (volatile void*)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    80012c20:	fd843783          	ld	a5,-40(s0)
    80012c24:	6398                	ld	a4,0(a5)
    80012c26:	fe843783          	ld	a5,-24(s0)
    80012c2a:	0047c783          	lbu	a5,4(a5)
    80012c2e:	0ff7f793          	andi	a5,a5,255
    80012c32:	2781                	sext.w	a5,a5
    80012c34:	0791                	addi	a5,a5,4
    80012c36:	078a                	slli	a5,a5,0x2
    80012c38:	97ba                	add	a5,a5,a4
    80012c3a:	439c                	lw	a5,0(a5)
    80012c3c:	2781                	sext.w	a5,a5
    80012c3e:	1782                	slli	a5,a5,0x20
    80012c40:	9381                	srli	a5,a5,0x20
    80012c42:	ff07f713          	andi	a4,a5,-16
    80012c46:	fe843783          	ld	a5,-24(s0)
    80012c4a:	479c                	lw	a5,8(a5)
    80012c4c:	2781                	sext.w	a5,a5
    80012c4e:	1782                	slli	a5,a5,0x20
    80012c50:	9381                	srli	a5,a5,0x20
    80012c52:	97ba                	add	a5,a5,a4
}
    80012c54:	853e                	mv	a0,a5
    80012c56:	70a2                	ld	ra,40(sp)
    80012c58:	7402                	ld	s0,32(sp)
    80012c5a:	6145                	addi	sp,sp,48
    80012c5c:	8082                	ret

0000000080012c5e <pci_get_virtio_common_config>:

// Get the common configuration capability for the given virtio device.
volatile struct VirtioPciCommonCfg *pci_get_virtio_common_config(PCIDevice *device) {
    80012c5e:	7179                	addi	sp,sp,-48
    80012c60:	f406                	sd	ra,40(sp)
    80012c62:	f022                	sd	s0,32(sp)
    80012c64:	1800                	addi	s0,sp,48
    80012c66:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_COMMON_CFG);
    80012c6a:	4585                	li	a1,1
    80012c6c:	fd843503          	ld	a0,-40(s0)
    80012c70:	c7bff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012c74:	fea43423          	sd	a0,-24(s0)
    debugf("Getting common capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset);
    return (volatile struct VirtioPciCommonCfg *)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    80012c78:	fd843783          	ld	a5,-40(s0)
    80012c7c:	6398                	ld	a4,0(a5)
    80012c7e:	fe843783          	ld	a5,-24(s0)
    80012c82:	0047c783          	lbu	a5,4(a5)
    80012c86:	0ff7f793          	andi	a5,a5,255
    80012c8a:	2781                	sext.w	a5,a5
    80012c8c:	0791                	addi	a5,a5,4
    80012c8e:	078a                	slli	a5,a5,0x2
    80012c90:	97ba                	add	a5,a5,a4
    80012c92:	439c                	lw	a5,0(a5)
    80012c94:	2781                	sext.w	a5,a5
    80012c96:	1782                	slli	a5,a5,0x20
    80012c98:	9381                	srli	a5,a5,0x20
    80012c9a:	ff07f713          	andi	a4,a5,-16
    80012c9e:	fe843783          	ld	a5,-24(s0)
    80012ca2:	479c                	lw	a5,8(a5)
    80012ca4:	2781                	sext.w	a5,a5
    80012ca6:	1782                	slli	a5,a5,0x20
    80012ca8:	9381                	srli	a5,a5,0x20
    80012caa:	97ba                	add	a5,a5,a4
}
    80012cac:	853e                	mv	a0,a5
    80012cae:	70a2                	ld	ra,40(sp)
    80012cb0:	7402                	ld	s0,32(sp)
    80012cb2:	6145                	addi	sp,sp,48
    80012cb4:	8082                	ret

0000000080012cb6 <pci_get_virtio_notify_capability>:

// Get the notify capability for the given virtio device.
volatile struct VirtioPciNotifyCfg *pci_get_virtio_notify_capability(PCIDevice *device) {
    80012cb6:	7179                	addi	sp,sp,-48
    80012cb8:	f406                	sd	ra,40(sp)
    80012cba:	f022                	sd	s0,32(sp)
    80012cbc:	1800                	addi	s0,sp,48
    80012cbe:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_NOTIFY_CFG);
    80012cc2:	4589                	li	a1,2
    80012cc4:	fd843503          	ld	a0,-40(s0)
    80012cc8:	c23ff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012ccc:	fea43423          	sd	a0,-24(s0)
    debugf("Cap at %p\n", vio_cap);
    debugf("Getting notify capability from bar #%d = %p + 0x%x (len=%d) %d\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset, vio_cap->len, sizeof(VirtioPciNotifyCfg));
    return (volatile struct VirtioPciNotifyCfg*)vio_cap;
    80012cd0:	fe843783          	ld	a5,-24(s0)
}
    80012cd4:	853e                	mv	a0,a5
    80012cd6:	70a2                	ld	ra,40(sp)
    80012cd8:	7402                	ld	s0,32(sp)
    80012cda:	6145                	addi	sp,sp,48
    80012cdc:	8082                	ret

0000000080012cde <pci_get_device_bar>:

volatile uint8_t *pci_get_device_bar(PCIDevice *device, uint8_t bar_num) {
    80012cde:	1101                	addi	sp,sp,-32
    80012ce0:	ec22                	sd	s0,24(sp)
    80012ce2:	1000                	addi	s0,sp,32
    80012ce4:	fea43423          	sd	a0,-24(s0)
    80012ce8:	87ae                	mv	a5,a1
    80012cea:	fef403a3          	sb	a5,-25(s0)
    return (volatile uint8_t*)(uintptr_t)(device->ecam_header->type0.bar[bar_num] & ~0xf);
    80012cee:	fe843783          	ld	a5,-24(s0)
    80012cf2:	6398                	ld	a4,0(a5)
    80012cf4:	fe744783          	lbu	a5,-25(s0)
    80012cf8:	2781                	sext.w	a5,a5
    80012cfa:	0791                	addi	a5,a5,4
    80012cfc:	078a                	slli	a5,a5,0x2
    80012cfe:	97ba                	add	a5,a5,a4
    80012d00:	439c                	lw	a5,0(a5)
    80012d02:	2781                	sext.w	a5,a5
    80012d04:	02079713          	slli	a4,a5,0x20
    80012d08:	9301                	srli	a4,a4,0x20
    80012d0a:	4785                	li	a5,1
    80012d0c:	1782                	slli	a5,a5,0x20
    80012d0e:	17c1                	addi	a5,a5,-16
    80012d10:	8ff9                	and	a5,a5,a4
}
    80012d12:	853e                	mv	a0,a5
    80012d14:	6462                	ld	s0,24(sp)
    80012d16:	6105                	addi	sp,sp,32
    80012d18:	8082                	ret

0000000080012d1a <pci_get_virtio_isr_status>:


// Get the ISR capability for the given virtio device.
volatile struct VirtioPciIsrCfg *pci_get_virtio_isr_status(PCIDevice *device) {
    80012d1a:	7179                	addi	sp,sp,-48
    80012d1c:	f406                	sd	ra,40(sp)
    80012d1e:	f022                	sd	s0,32(sp)
    80012d20:	1800                	addi	s0,sp,48
    80012d22:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_ISR_CFG);
    80012d26:	458d                	li	a1,3
    80012d28:	fd843503          	ld	a0,-40(s0)
    80012d2c:	bbfff0ef          	jal	ra,800128ea <pci_get_virtio_capability>
    80012d30:	fea43423          	sd	a0,-24(s0)
    debugf("Getting ISR capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset);
    return (volatile struct VirtioPciIsrCfg *)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    80012d34:	fd843783          	ld	a5,-40(s0)
    80012d38:	6398                	ld	a4,0(a5)
    80012d3a:	fe843783          	ld	a5,-24(s0)
    80012d3e:	0047c783          	lbu	a5,4(a5)
    80012d42:	0ff7f793          	andi	a5,a5,255
    80012d46:	2781                	sext.w	a5,a5
    80012d48:	0791                	addi	a5,a5,4
    80012d4a:	078a                	slli	a5,a5,0x2
    80012d4c:	97ba                	add	a5,a5,a4
    80012d4e:	439c                	lw	a5,0(a5)
    80012d50:	2781                	sext.w	a5,a5
    80012d52:	1782                	slli	a5,a5,0x20
    80012d54:	9381                	srli	a5,a5,0x20
    80012d56:	ff07f713          	andi	a4,a5,-16
    80012d5a:	fe843783          	ld	a5,-24(s0)
    80012d5e:	479c                	lw	a5,8(a5)
    80012d60:	2781                	sext.w	a5,a5
    80012d62:	1782                	slli	a5,a5,0x20
    80012d64:	9381                	srli	a5,a5,0x20
    80012d66:	97ba                	add	a5,a5,a4
}
    80012d68:	853e                	mv	a0,a5
    80012d6a:	70a2                	ld	ra,40(sp)
    80012d6c:	7402                	ld	s0,32(sp)
    80012d6e:	6145                	addi	sp,sp,48
    80012d70:	8082                	ret

0000000080012d72 <pci_get_ecam>:

static volatile struct pci_ecam *pci_get_ecam(uint8_t bus,
                                              uint8_t device,
                                              uint8_t function,
                                              uint16_t reg) 
{
    80012d72:	715d                	addi	sp,sp,-80
    80012d74:	e486                	sd	ra,72(sp)
    80012d76:	e0a2                	sd	s0,64(sp)
    80012d78:	0880                	addi	s0,sp,80
    80012d7a:	87aa                	mv	a5,a0
    80012d7c:	8736                	mv	a4,a3
    80012d7e:	faf40fa3          	sb	a5,-65(s0)
    80012d82:	87ae                	mv	a5,a1
    80012d84:	faf40f23          	sb	a5,-66(s0)
    80012d88:	87b2                	mv	a5,a2
    80012d8a:	faf40ea3          	sb	a5,-67(s0)
    80012d8e:	87ba                	mv	a5,a4
    80012d90:	faf41d23          	sh	a5,-70(s0)
    // Since we're shifting, we need to make sure we
    // have enough space to shift into.
    uint64_t bus64 = bus & 0xff;
    80012d94:	fbf44783          	lbu	a5,-65(s0)
    80012d98:	fef43423          	sd	a5,-24(s0)
    uint64_t device64 = device & 0x1f;
    80012d9c:	fbe44783          	lbu	a5,-66(s0)
    80012da0:	8bfd                	andi	a5,a5,31
    80012da2:	fef43023          	sd	a5,-32(s0)
    uint64_t function64 = function & 0x7;
    80012da6:	fbd44783          	lbu	a5,-67(s0)
    80012daa:	8b9d                	andi	a5,a5,7
    80012dac:	fcf43c23          	sd	a5,-40(s0)
    uint64_t reg64 = reg & 0x3ff; 
    80012db0:	fba45783          	lhu	a5,-70(s0)
    80012db4:	3ff7f793          	andi	a5,a5,1023
    80012db8:	fcf43823          	sd	a5,-48(s0)
    
    // Finally, put the address together
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    80012dbc:	fe843783          	ld	a5,-24(s0)
    80012dc0:	01479713          	slli	a4,a5,0x14
                     (device64 << 15) |   // device number A[19:15]
    80012dc4:	fe043783          	ld	a5,-32(s0)
    80012dc8:	07be                	slli	a5,a5,0xf
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    80012dca:	8f5d                	or	a4,a4,a5
                     (function64 << 12) | // function number A[14:12]
    80012dcc:	fd843783          	ld	a5,-40(s0)
    80012dd0:	07b2                	slli	a5,a5,0xc
                     (device64 << 15) |   // device number A[19:15]
    80012dd2:	8f5d                	or	a4,a4,a5
                     (reg64 << 2));       // register number A[11:2]
    80012dd4:	fd043783          	ld	a5,-48(s0)
    80012dd8:	078a                	slli	a5,a5,0x2
                     (function64 << 12) | // function number A[14:12]
    80012dda:	8f5d                	or	a4,a4,a5
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
    80012ddc:	300007b7          	lui	a5,0x30000
    80012de0:	8fd9                	or	a5,a5,a4
    80012de2:	fcf43423          	sd	a5,-56(s0)
        
    if (addr < PCIE_ECAM_BASE || addr > PCIE_ECAM_END) {
    80012de6:	fc843703          	ld	a4,-56(s0)
    80012dea:	300007b7          	lui	a5,0x30000
    80012dee:	00f76863          	bltu	a4,a5,80012dfe <pci_get_ecam+0x8c>
    80012df2:	fc843703          	ld	a4,-56(s0)
    80012df6:	400007b7          	lui	a5,0x40000
    80012dfa:	00f76c63          	bltu	a4,a5,80012e12 <pci_get_ecam+0xa0>
        fatalf("pci_get_ecam: PCI address (0x%08x) out of bounds!\n", addr);
    80012dfe:	fc843583          	ld	a1,-56(s0)
    80012e02:	00011517          	auipc	a0,0x11
    80012e06:	6ee50513          	addi	a0,a0,1774 # 800244f0 <pow10.0+0x2c0>
    80012e0a:	4fa060ef          	jal	ra,80019304 <fatalf>
        return 0; 
    80012e0e:	4781                	li	a5,0
    80012e10:	a019                	j	80012e16 <pci_get_ecam+0xa4>
    }
    return (struct pci_ecam *)addr;
    80012e12:	fc843783          	ld	a5,-56(s0)
}
    80012e16:	853e                	mv	a0,a5
    80012e18:	60a6                	ld	ra,72(sp)
    80012e1a:	6406                	ld	s0,64(sp)
    80012e1c:	6161                	addi	sp,sp,80
    80012e1e:	8082                	ret

0000000080012e20 <pci_enumerate_bus>:

static uint64_t next_mmio_address;
static uint8_t subordinate = 1;

static void pci_enumerate_bus() 
{
    80012e20:	1101                	addi	sp,sp,-32
    80012e22:	ec06                	sd	ra,24(sp)
    80012e24:	e822                	sd	s0,16(sp)
    80012e26:	1000                	addi	s0,sp,32
    for (int bus = 0; bus < 256; bus++) {
    80012e28:	fe042623          	sw	zero,-20(s0)
    80012e2c:	a0f9                	j	80012efa <pci_enumerate_bus+0xda>
        for (int device = 0; device < 32; device++) {
    80012e2e:	fe042423          	sw	zero,-24(s0)
    80012e32:	a845                	j	80012ee2 <pci_enumerate_bus+0xc2>
            volatile struct pci_ecam *ecam = pci_get_ecam(bus, device, 0, 0);
    80012e34:	fec42783          	lw	a5,-20(s0)
    80012e38:	0ff7f793          	andi	a5,a5,255
    80012e3c:	fe842703          	lw	a4,-24(s0)
    80012e40:	0ff77713          	andi	a4,a4,255
    80012e44:	4681                	li	a3,0
    80012e46:	4601                	li	a2,0
    80012e48:	85ba                	mv	a1,a4
    80012e4a:	853e                	mv	a0,a5
    80012e4c:	f27ff0ef          	jal	ra,80012d72 <pci_get_ecam>
    80012e50:	fea43023          	sd	a0,-32(s0)

            if (!pci_device_exists(ecam->vendor_id)) {
    80012e54:	fe043783          	ld	a5,-32(s0)
    80012e58:	0007d783          	lhu	a5,0(a5) # 40000000 <i+0x3fffffe0>
    80012e5c:	17c2                	slli	a5,a5,0x30
    80012e5e:	93c1                	srli	a5,a5,0x30
    80012e60:	853e                	mv	a0,a5
    80012e62:	899ff0ef          	jal	ra,800126fa <pci_device_exists>
    80012e66:	87aa                	mv	a5,a0
    80012e68:	0017c793          	xori	a5,a5,1
    80012e6c:	0ff7f793          	andi	a5,a5,255
    80012e70:	e3bd                	bnez	a5,80012ed6 <pci_enumerate_bus+0xb6>
                // debugf("pci_enumerate_bus: No device found at bus %d, device %d\n", bus, device);
                continue;
            }

            if ((ecam->header_type & 0x7F) == 1) {
    80012e72:	fe043783          	ld	a5,-32(s0)
    80012e76:	00e7c783          	lbu	a5,14(a5)
    80012e7a:	0ff7f793          	andi	a5,a5,255
    80012e7e:	2781                	sext.w	a5,a5
    80012e80:	07f7f793          	andi	a5,a5,127
    80012e84:	2781                	sext.w	a5,a5
    80012e86:	873e                	mv	a4,a5
    80012e88:	4785                	li	a5,1
    80012e8a:	00f71c63          	bne	a4,a5,80012ea2 <pci_enumerate_bus+0x82>
                // debugf("pci_enumerate_bus: Found bridge at bus %d, device %d, \n", bus, device);
                pci_configure_bridge(ecam, bus);
    80012e8e:	fec42783          	lw	a5,-20(s0)
    80012e92:	0ff7f793          	andi	a5,a5,255
    80012e96:	85be                	mv	a1,a5
    80012e98:	fe043503          	ld	a0,-32(s0)
    80012e9c:	07a000ef          	jal	ra,80012f16 <pci_configure_bridge>
    80012ea0:	a825                	j	80012ed8 <pci_enumerate_bus+0xb8>
            } else if ((ecam->header_type & 0x7F) == 0) {
    80012ea2:	fe043783          	ld	a5,-32(s0)
    80012ea6:	00e7c783          	lbu	a5,14(a5)
    80012eaa:	0ff7f793          	andi	a5,a5,255
    80012eae:	2781                	sext.w	a5,a5
    80012eb0:	07f7f793          	andi	a5,a5,127
    80012eb4:	2781                	sext.w	a5,a5
    80012eb6:	e38d                	bnez	a5,80012ed8 <pci_enumerate_bus+0xb8>
                // debugf("pci_enumerate_bus: Found device at bus %d, device %d, \n", bus, device);
                pci_configure_device(ecam, bus, device);
    80012eb8:	fec42783          	lw	a5,-20(s0)
    80012ebc:	0ff7f793          	andi	a5,a5,255
    80012ec0:	fe842703          	lw	a4,-24(s0)
    80012ec4:	0ff77713          	andi	a4,a4,255
    80012ec8:	863a                	mv	a2,a4
    80012eca:	85be                	mv	a1,a5
    80012ecc:	fe043503          	ld	a0,-32(s0)
    80012ed0:	190000ef          	jal	ra,80013060 <pci_configure_device>
    80012ed4:	a011                	j	80012ed8 <pci_enumerate_bus+0xb8>
                continue;
    80012ed6:	0001                	nop
        for (int device = 0; device < 32; device++) {
    80012ed8:	fe842783          	lw	a5,-24(s0)
    80012edc:	2785                	addiw	a5,a5,1
    80012ede:	fef42423          	sw	a5,-24(s0)
    80012ee2:	fe842783          	lw	a5,-24(s0)
    80012ee6:	0007871b          	sext.w	a4,a5
    80012eea:	47fd                	li	a5,31
    80012eec:	f4e7d4e3          	bge	a5,a4,80012e34 <pci_enumerate_bus+0x14>
    for (int bus = 0; bus < 256; bus++) {
    80012ef0:	fec42783          	lw	a5,-20(s0)
    80012ef4:	2785                	addiw	a5,a5,1
    80012ef6:	fef42623          	sw	a5,-20(s0)
    80012efa:	fec42783          	lw	a5,-20(s0)
    80012efe:	0007871b          	sext.w	a4,a5
    80012f02:	0ff00793          	li	a5,255
    80012f06:	f2e7d4e3          	bge	a5,a4,80012e2e <pci_enumerate_bus+0xe>
                // PCIDevice *device = pci_find_saved_device(ecam->vendor_id, ecam->device_id);
                // print_vendor_specific_capabilities(device);
            }
        }
    }
}
    80012f0a:	0001                	nop
    80012f0c:	0001                	nop
    80012f0e:	60e2                	ld	ra,24(sp)
    80012f10:	6442                	ld	s0,16(sp)
    80012f12:	6105                	addi	sp,sp,32
    80012f14:	8082                	ret

0000000080012f16 <pci_configure_bridge>:


static void pci_configure_bridge(volatile struct pci_ecam *bridge, uint8_t bus_no)
{
    80012f16:	7179                	addi	sp,sp,-48
    80012f18:	f422                	sd	s0,40(sp)
    80012f1a:	1800                	addi	s0,sp,48
    80012f1c:	fca43c23          	sd	a0,-40(s0)
    80012f20:	87ae                	mv	a5,a1
    80012f22:	fcf40ba3          	sb	a5,-41(s0)
    next_mmio_address += 0x01000000;
    */

    // Make sure to set the bus master (2) and memory space (1) bits and clear
    // I/O space bit (0) before configuring the bridges
    bridge->command_reg |= COMMAND_REG_BUSMASTER;
    80012f26:	fd843783          	ld	a5,-40(s0)
    80012f2a:	0047d783          	lhu	a5,4(a5)
    80012f2e:	17c2                	slli	a5,a5,0x30
    80012f30:	93c1                	srli	a5,a5,0x30
    80012f32:	0047e793          	ori	a5,a5,4
    80012f36:	03079713          	slli	a4,a5,0x30
    80012f3a:	9341                	srli	a4,a4,0x30
    80012f3c:	fd843783          	ld	a5,-40(s0)
    80012f40:	00e79223          	sh	a4,4(a5)
    bridge->command_reg |= COMMAND_REG_MMIO;
    80012f44:	fd843783          	ld	a5,-40(s0)
    80012f48:	0047d783          	lhu	a5,4(a5)
    80012f4c:	17c2                	slli	a5,a5,0x30
    80012f4e:	93c1                	srli	a5,a5,0x30
    80012f50:	0027e793          	ori	a5,a5,2
    80012f54:	03079713          	slli	a4,a5,0x30
    80012f58:	9341                	srli	a4,a4,0x30
    80012f5a:	fd843783          	ld	a5,-40(s0)
    80012f5e:	00e79223          	sh	a4,4(a5)
    bridge->command_reg &= ~COMMAND_REG_PIO;
    80012f62:	fd843783          	ld	a5,-40(s0)
    80012f66:	0047d783          	lhu	a5,4(a5)
    80012f6a:	17c2                	slli	a5,a5,0x30
    80012f6c:	93c1                	srli	a5,a5,0x30
    80012f6e:	9bf9                	andi	a5,a5,-2
    80012f70:	03079713          	slli	a4,a5,0x30
    80012f74:	9341                	srli	a4,a4,0x30
    80012f76:	fd843783          	ld	a5,-40(s0)
    80012f7a:	00e79223          	sh	a4,4(a5)

    uint64_t addrst = 0x40000000 | ((uint64_t)subordinate << 20);
    80012f7e:	00014797          	auipc	a5,0x14
    80012f82:	08278793          	addi	a5,a5,130 # 80027000 <subordinate>
    80012f86:	0007c783          	lbu	a5,0(a5)
    80012f8a:	01479713          	slli	a4,a5,0x14
    80012f8e:	400007b7          	lui	a5,0x40000
    80012f92:	8fd9                	or	a5,a5,a4
    80012f94:	fef43423          	sd	a5,-24(s0)
    uint64_t addred = addrst + ((1 << 20) - 1);
    80012f98:	fe843703          	ld	a4,-24(s0)
    80012f9c:	001007b7          	lui	a5,0x100
    80012fa0:	17fd                	addi	a5,a5,-1
    80012fa2:	97ba                	add	a5,a5,a4
    80012fa4:	fef43023          	sd	a5,-32(s0)
    next_mmio_address = addrst;
    80012fa8:	00010797          	auipc	a5,0x10
    80012fac:	0b878793          	addi	a5,a5,184 # 80023060 <next_mmio_address>
    80012fb0:	fe843703          	ld	a4,-24(s0)
    80012fb4:	e398                	sd	a4,0(a5)
    
    bridge->type1.memory_base = addrst >> 16;
    80012fb6:	fe843783          	ld	a5,-24(s0)
    80012fba:	83c1                	srli	a5,a5,0x10
    80012fbc:	03079713          	slli	a4,a5,0x30
    80012fc0:	9341                	srli	a4,a4,0x30
    80012fc2:	fd843783          	ld	a5,-40(s0)
    80012fc6:	02e79023          	sh	a4,32(a5)
    bridge->type1.memory_limit = addred >> 16;
    80012fca:	fe043783          	ld	a5,-32(s0)
    80012fce:	83c1                	srli	a5,a5,0x10
    80012fd0:	03079713          	slli	a4,a5,0x30
    80012fd4:	9341                	srli	a4,a4,0x30
    80012fd6:	fd843783          	ld	a5,-40(s0)
    80012fda:	02e79123          	sh	a4,34(a5)
    bridge->type1.prefetch_memory_base = addrst >> 16;
    80012fde:	fe843783          	ld	a5,-24(s0)
    80012fe2:	83c1                	srli	a5,a5,0x10
    80012fe4:	03079713          	slli	a4,a5,0x30
    80012fe8:	9341                	srli	a4,a4,0x30
    80012fea:	fd843783          	ld	a5,-40(s0)
    80012fee:	02e79223          	sh	a4,36(a5)
    bridge->type1.prefetch_memory_limit = addred >> 16;
    80012ff2:	fe043783          	ld	a5,-32(s0)
    80012ff6:	83c1                	srli	a5,a5,0x10
    80012ff8:	03079713          	slli	a4,a5,0x30
    80012ffc:	9341                	srli	a4,a4,0x30
    80012ffe:	fd843783          	ld	a5,-40(s0)
    80013002:	02e79323          	sh	a4,38(a5)
    bridge->type1.primary_bus_no = bus_no;
    80013006:	fd843783          	ld	a5,-40(s0)
    8001300a:	fd744703          	lbu	a4,-41(s0)
    8001300e:	00e78c23          	sb	a4,24(a5)
    bridge->type1.secondary_bus_no = subordinate;
    80013012:	00014797          	auipc	a5,0x14
    80013016:	fee78793          	addi	a5,a5,-18 # 80027000 <subordinate>
    8001301a:	0007c703          	lbu	a4,0(a5)
    8001301e:	fd843783          	ld	a5,-40(s0)
    80013022:	00e78ca3          	sb	a4,25(a5)
    bridge->type1.subordinate_bus_no = subordinate;
    80013026:	00014797          	auipc	a5,0x14
    8001302a:	fda78793          	addi	a5,a5,-38 # 80027000 <subordinate>
    8001302e:	0007c703          	lbu	a4,0(a5)
    80013032:	fd843783          	ld	a5,-40(s0)
    80013036:	00e78d23          	sb	a4,26(a5)
    subordinate += 1;
    8001303a:	00014797          	auipc	a5,0x14
    8001303e:	fc678793          	addi	a5,a5,-58 # 80027000 <subordinate>
    80013042:	0007c783          	lbu	a5,0(a5)
    80013046:	2785                	addiw	a5,a5,1
    80013048:	0ff7f713          	andi	a4,a5,255
    8001304c:	00014797          	auipc	a5,0x14
    80013050:	fb478793          	addi	a5,a5,-76 # 80027000 <subordinate>
    80013054:	00e78023          	sb	a4,0(a5)
}
    80013058:	0001                	nop
    8001305a:	7422                	ld	s0,40(sp)
    8001305c:	6145                	addi	sp,sp,48
    8001305e:	8082                	ret

0000000080013060 <pci_configure_device>:

static void pci_configure_device(volatile struct pci_ecam *device, uint8_t bus_no, uint8_t device_no)
{
    80013060:	7171                	addi	sp,sp,-176
    80013062:	f506                	sd	ra,168(sp)
    80013064:	f122                	sd	s0,160(sp)
    80013066:	1900                	addi	s0,sp,176
    80013068:	f8a43c23          	sd	a0,-104(s0)
    8001306c:	87ae                	mv	a5,a1
    8001306e:	8732                	mv	a4,a2
    80013070:	f8f40ba3          	sb	a5,-105(s0)
    80013074:	87ba                	mv	a5,a4
    80013076:	f8f40b23          	sb	a5,-106(s0)
    // vector_push(irq_pci_devices[vector_idx], (uint64_t)device);

    debugf("pci_configure_device: At bus %d, device %d = (%p)\n", bus_no, device_no, device);

    // Disable the device before modifying the BAR
    device->command_reg &= ~COMMAND_REG_MMIO; // Clear memory space bit
    8001307a:	f9843783          	ld	a5,-104(s0)
    8001307e:	0047d783          	lhu	a5,4(a5)
    80013082:	17c2                	slli	a5,a5,0x30
    80013084:	93c1                	srli	a5,a5,0x30
    80013086:	9bf5                	andi	a5,a5,-3
    80013088:	03079713          	slli	a4,a5,0x30
    8001308c:	9341                	srli	a4,a4,0x30
    8001308e:	f9843783          	ld	a5,-104(s0)
    80013092:	00e79223          	sh	a4,4(a5)
    device->command_reg &= ~COMMAND_REG_PIO; // Clear I/O space bit
    80013096:	f9843783          	ld	a5,-104(s0)
    8001309a:	0047d783          	lhu	a5,4(a5)
    8001309e:	17c2                	slli	a5,a5,0x30
    800130a0:	93c1                	srli	a5,a5,0x30
    800130a2:	9bf9                	andi	a5,a5,-2
    800130a4:	03079713          	slli	a4,a5,0x30
    800130a8:	9341                	srli	a4,a4,0x30
    800130aa:	f9843783          	ld	a5,-104(s0)
    800130ae:	00e79223          	sh	a4,4(a5)

    uint32_t addr = PCIE_MMIO_BASE + (bus_no << 20) + (device_no << 16);
    800130b2:	f9744783          	lbu	a5,-105(s0)
    800130b6:	2781                	sext.w	a5,a5
    800130b8:	0147979b          	slliw	a5,a5,0x14
    800130bc:	0007871b          	sext.w	a4,a5
    800130c0:	400007b7          	lui	a5,0x40000
    800130c4:	9fb9                	addw	a5,a5,a4
    800130c6:	0007871b          	sext.w	a4,a5
    800130ca:	f9644783          	lbu	a5,-106(s0)
    800130ce:	2781                	sext.w	a5,a5
    800130d0:	0107979b          	slliw	a5,a5,0x10
    800130d4:	2781                	sext.w	a5,a5
    800130d6:	9fb9                	addw	a5,a5,a4
    800130d8:	2781                	sext.w	a5,a5
    800130da:	fef42623          	sw	a5,-20(s0)
    PCIDevice pcidev;
    pcidev.ecam_header = device;
    800130de:	f9843783          	ld	a5,-104(s0)
    800130e2:	faf43023          	sd	a5,-96(s0)
    
    for (int i = 0; i < 6; i++) {
    800130e6:	fe042423          	sw	zero,-24(s0)
    800130ea:	aa5d                	j	800132a0 <pci_configure_device+0x240>
        device->type0.bar[i] = -1U;
    800130ec:	f9843703          	ld	a4,-104(s0)
    800130f0:	fe842783          	lw	a5,-24(s0)
    800130f4:	0791                	addi	a5,a5,4
    800130f6:	078a                	slli	a5,a5,0x2
    800130f8:	97ba                	add	a5,a5,a4
    800130fa:	577d                	li	a4,-1
    800130fc:	c398                	sw	a4,0(a5)
        pcidev.bars[i] = NULL;
    800130fe:	fe842783          	lw	a5,-24(s0)
    80013102:	078e                	slli	a5,a5,0x3
    80013104:	ff040713          	addi	a4,s0,-16
    80013108:	97ba                	add	a5,a5,a4
    8001310a:	fa07bc23          	sd	zero,-72(a5) # 3fffffb8 <i+0x3fffff98>
        
        // BAR not writable
        if (device->type0.bar[i] == 0) {
    8001310e:	f9843703          	ld	a4,-104(s0)
    80013112:	fe842783          	lw	a5,-24(s0)
    80013116:	0791                	addi	a5,a5,4
    80013118:	078a                	slli	a5,a5,0x2
    8001311a:	97ba                	add	a5,a5,a4
    8001311c:	439c                	lw	a5,0(a5)
    8001311e:	2781                	sext.w	a5,a5
    80013120:	16078a63          	beqz	a5,80013294 <pci_configure_device+0x234>
            continue;
        }

        uint64_t size;

        if ((device->type0.bar[i] & 0x6) == 0x4) {
    80013124:	f9843703          	ld	a4,-104(s0)
    80013128:	fe842783          	lw	a5,-24(s0)
    8001312c:	0791                	addi	a5,a5,4
    8001312e:	078a                	slli	a5,a5,0x2
    80013130:	97ba                	add	a5,a5,a4
    80013132:	439c                	lw	a5,0(a5)
    80013134:	2781                	sext.w	a5,a5
    80013136:	8b99                	andi	a5,a5,6
    80013138:	2781                	sext.w	a5,a5
    8001313a:	873e                	mv	a4,a5
    8001313c:	4791                	li	a5,4
    8001313e:	0ef71763          	bne	a4,a5,8001322c <pci_configure_device+0x1cc>
            debugf("  BAR[%d] is 64-bit\n", i);
            device->type0.bar[i+1] = -1U;
    80013142:	fe842783          	lw	a5,-24(s0)
    80013146:	2785                	addiw	a5,a5,1
    80013148:	2781                	sext.w	a5,a5
    8001314a:	f9843703          	ld	a4,-104(s0)
    8001314e:	0791                	addi	a5,a5,4
    80013150:	078a                	slli	a5,a5,0x2
    80013152:	97ba                	add	a5,a5,a4
    80013154:	577d                	li	a4,-1
    80013156:	c398                	sw	a4,0(a5)
            uint64_t bar_value = (uint64_t) device->type0.bar[i+1] << 32 | device->type0.bar[i];
    80013158:	fe842783          	lw	a5,-24(s0)
    8001315c:	2785                	addiw	a5,a5,1
    8001315e:	2781                	sext.w	a5,a5
    80013160:	f9843703          	ld	a4,-104(s0)
    80013164:	0791                	addi	a5,a5,4
    80013166:	078a                	slli	a5,a5,0x2
    80013168:	97ba                	add	a5,a5,a4
    8001316a:	439c                	lw	a5,0(a5)
    8001316c:	2781                	sext.w	a5,a5
    8001316e:	1782                	slli	a5,a5,0x20
    80013170:	9381                	srli	a5,a5,0x20
    80013172:	02079713          	slli	a4,a5,0x20
    80013176:	f9843683          	ld	a3,-104(s0)
    8001317a:	fe842783          	lw	a5,-24(s0)
    8001317e:	0791                	addi	a5,a5,4
    80013180:	078a                	slli	a5,a5,0x2
    80013182:	97b6                	add	a5,a5,a3
    80013184:	439c                	lw	a5,0(a5)
    80013186:	2781                	sext.w	a5,a5
    80013188:	1782                	slli	a5,a5,0x20
    8001318a:	9381                	srli	a5,a5,0x20
    8001318c:	8fd9                	or	a5,a5,a4
    8001318e:	fcf43c23          	sd	a5,-40(s0)
            size = ~(bar_value & ~0xF) + 1;
    80013192:	fd843783          	ld	a5,-40(s0)
    80013196:	9bc1                	andi	a5,a5,-16
    80013198:	40f007b3          	neg	a5,a5
    8001319c:	fef43023          	sd	a5,-32(s0)
            addr += size;
    800131a0:	fe043783          	ld	a5,-32(s0)
    800131a4:	2781                	sext.w	a5,a5
    800131a6:	fec42703          	lw	a4,-20(s0)
    800131aa:	9fb9                	addw	a5,a5,a4
    800131ac:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    800131b0:	f9843703          	ld	a4,-104(s0)
    800131b4:	fe842783          	lw	a5,-24(s0)
    800131b8:	0791                	addi	a5,a5,4
    800131ba:	078a                	slli	a5,a5,0x2
    800131bc:	97ba                	add	a5,a5,a4
    800131be:	fec42703          	lw	a4,-20(s0)
    800131c2:	c398                	sw	a4,0(a5)
            device->type0.bar[i+1] = 0;
    800131c4:	fe842783          	lw	a5,-24(s0)
    800131c8:	2785                	addiw	a5,a5,1
    800131ca:	2781                	sext.w	a5,a5
    800131cc:	f9843703          	ld	a4,-104(s0)
    800131d0:	0791                	addi	a5,a5,4
    800131d2:	078a                	slli	a5,a5,0x2
    800131d4:	97ba                	add	a5,a5,a4
    800131d6:	0007a023          	sw	zero,0(a5)
            pcidev.bars[i] = (volatile void*)(uint64_t)(device->type0.bar[i] & ~0xf);
    800131da:	f9843703          	ld	a4,-104(s0)
    800131de:	fe842783          	lw	a5,-24(s0)
    800131e2:	0791                	addi	a5,a5,4
    800131e4:	078a                	slli	a5,a5,0x2
    800131e6:	97ba                	add	a5,a5,a4
    800131e8:	439c                	lw	a5,0(a5)
    800131ea:	2781                	sext.w	a5,a5
    800131ec:	02079713          	slli	a4,a5,0x20
    800131f0:	9301                	srli	a4,a4,0x20
    800131f2:	4785                	li	a5,1
    800131f4:	1782                	slli	a5,a5,0x20
    800131f6:	17c1                	addi	a5,a5,-16
    800131f8:	8ff9                	and	a5,a5,a4
    800131fa:	873e                	mv	a4,a5
    800131fc:	fe842783          	lw	a5,-24(s0)
    80013200:	078e                	slli	a5,a5,0x3
    80013202:	ff040693          	addi	a3,s0,-16
    80013206:	97b6                	add	a5,a5,a3
    80013208:	fae7bc23          	sd	a4,-72(a5)
            pcidev.bars[i+1] = 0;
    8001320c:	fe842783          	lw	a5,-24(s0)
    80013210:	2785                	addiw	a5,a5,1
    80013212:	2781                	sext.w	a5,a5
    80013214:	078e                	slli	a5,a5,0x3
    80013216:	ff040713          	addi	a4,s0,-16
    8001321a:	97ba                	add	a5,a5,a4
    8001321c:	fa07bc23          	sd	zero,-72(a5)
            // pcidev.bars[i+1] = 0;
            debugf("    device->type0.bar[i] == 0x%08x\n", device->type0.bar[i]);
            debugf("    device->type0.bar[i+1] == 0x%08x\n", device->type0.bar[i+1]);
            debugf("    bar_value == 0x%016llx\n", bar_value);
            debugf("    size == %016llx\n", size);
            ++i;
    80013220:	fe842783          	lw	a5,-24(s0)
    80013224:	2785                	addiw	a5,a5,1
    80013226:	fef42423          	sw	a5,-24(s0)
    8001322a:	a0b5                	j	80013296 <pci_configure_device+0x236>
        } else {
            debugf("  BAR[%d] is 32-bit\n", i);
            size = ~(device->type0.bar[i] & ~0xF) + 1;
    8001322c:	f9843703          	ld	a4,-104(s0)
    80013230:	fe842783          	lw	a5,-24(s0)
    80013234:	0791                	addi	a5,a5,4
    80013236:	078a                	slli	a5,a5,0x2
    80013238:	97ba                	add	a5,a5,a4
    8001323a:	439c                	lw	a5,0(a5)
    8001323c:	2781                	sext.w	a5,a5
    8001323e:	9bc1                	andi	a5,a5,-16
    80013240:	2781                	sext.w	a5,a5
    80013242:	40f007bb          	negw	a5,a5
    80013246:	2781                	sext.w	a5,a5
    80013248:	1782                	slli	a5,a5,0x20
    8001324a:	9381                	srli	a5,a5,0x20
    8001324c:	fef43023          	sd	a5,-32(s0)
            debugf("    size == %016llx\n", size);
            addr += size;
    80013250:	fe043783          	ld	a5,-32(s0)
    80013254:	2781                	sext.w	a5,a5
    80013256:	fec42703          	lw	a4,-20(s0)
    8001325a:	9fb9                	addw	a5,a5,a4
    8001325c:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    80013260:	f9843703          	ld	a4,-104(s0)
    80013264:	fe842783          	lw	a5,-24(s0)
    80013268:	0791                	addi	a5,a5,4
    8001326a:	078a                	slli	a5,a5,0x2
    8001326c:	97ba                	add	a5,a5,a4
    8001326e:	fec42703          	lw	a4,-20(s0)
    80013272:	c398                	sw	a4,0(a5)
            pcidev.bars[i] = (volatile void*)(uint64_t)(addr & ~0xf);
    80013274:	fec46703          	lwu	a4,-20(s0)
    80013278:	4785                	li	a5,1
    8001327a:	1782                	slli	a5,a5,0x20
    8001327c:	17c1                	addi	a5,a5,-16
    8001327e:	8ff9                	and	a5,a5,a4
    80013280:	873e                	mv	a4,a5
    80013282:	fe842783          	lw	a5,-24(s0)
    80013286:	078e                	slli	a5,a5,0x3
    80013288:	ff040693          	addi	a3,s0,-16
    8001328c:	97b6                	add	a5,a5,a3
    8001328e:	fae7bc23          	sd	a4,-72(a5)
    80013292:	a011                	j	80013296 <pci_configure_device+0x236>
            continue;
    80013294:	0001                	nop
    for (int i = 0; i < 6; i++) {
    80013296:	fe842783          	lw	a5,-24(s0)
    8001329a:	2785                	addiw	a5,a5,1
    8001329c:	fef42423          	sw	a5,-24(s0)
    800132a0:	fe842783          	lw	a5,-24(s0)
    800132a4:	0007871b          	sext.w	a4,a5
    800132a8:	4795                	li	a5,5
    800132aa:	e4e7d1e3          	bge	a5,a4,800130ec <pci_configure_device+0x8c>
        }
    }

    // Re-enable the device after modifying the BAR
    device->command_reg |= COMMAND_REG_MMIO;
    800132ae:	f9843783          	ld	a5,-104(s0)
    800132b2:	0047d783          	lhu	a5,4(a5)
    800132b6:	17c2                	slli	a5,a5,0x30
    800132b8:	93c1                	srli	a5,a5,0x30
    800132ba:	0027e793          	ori	a5,a5,2
    800132be:	03079713          	slli	a4,a5,0x30
    800132c2:	9341                	srli	a4,a4,0x30
    800132c4:	f9843783          	ld	a5,-104(s0)
    800132c8:	00e79223          	sh	a4,4(a5)
    pcidev.ecam_header = device;
    800132cc:	f9843783          	ld	a5,-104(s0)
    800132d0:	faf43023          	sd	a5,-96(s0)
    pci_save_device(pcidev);
    800132d4:	fa043803          	ld	a6,-96(s0)
    800132d8:	fa843503          	ld	a0,-88(s0)
    800132dc:	fb043583          	ld	a1,-80(s0)
    800132e0:	fb843603          	ld	a2,-72(s0)
    800132e4:	fc043683          	ld	a3,-64(s0)
    800132e8:	fc843703          	ld	a4,-56(s0)
    800132ec:	fd043783          	ld	a5,-48(s0)
    800132f0:	f5043823          	sd	a6,-176(s0)
    800132f4:	f4a43c23          	sd	a0,-168(s0)
    800132f8:	f6b43023          	sd	a1,-160(s0)
    800132fc:	f6c43423          	sd	a2,-152(s0)
    80013300:	f6d43823          	sd	a3,-144(s0)
    80013304:	f6e43c23          	sd	a4,-136(s0)
    80013308:	f8f43023          	sd	a5,-128(s0)
    8001330c:	f5040793          	addi	a5,s0,-176
    80013310:	853e                	mv	a0,a5
    80013312:	f0cff0ef          	jal	ra,80012a1e <pci_save_device>
}
    80013316:	0001                	nop
    80013318:	70aa                	ld	ra,168(sp)
    8001331a:	740a                	ld	s0,160(sp)
    8001331c:	614d                	addi	sp,sp,176
    8001331e:	8082                	ret

0000000080013320 <print_vendor_specific_capabilities>:

void print_vendor_specific_capabilities(PCIDevice *pcidevice)
{
    80013320:	7179                	addi	sp,sp,-48
    80013322:	f406                	sd	ra,40(sp)
    80013324:	f022                	sd	s0,32(sp)
    80013326:	1800                	addi	s0,sp,48
    80013328:	fca43c23          	sd	a0,-40(s0)
    if (!pci_is_virtio_device(pcidevice)) return;
    8001332c:	fd843503          	ld	a0,-40(s0)
    80013330:	c02ff0ef          	jal	ra,80012732 <pci_is_virtio_device>
    80013334:	87aa                	mv	a5,a0
    80013336:	0017c793          	xori	a5,a5,1
    8001333a:	0ff7f793          	andi	a5,a5,255
    8001333e:	ef89                	bnez	a5,80013358 <print_vendor_specific_capabilities+0x38>
    volatile struct pci_ecam *header = pcidevice->ecam_header;
    80013340:	fd843783          	ld	a5,-40(s0)
    80013344:	639c                	ld	a5,0(a5)
    80013346:	fef43423          	sd	a5,-24(s0)

    uint8_t cap_pointer = header->type0.capes_pointer;
    8001334a:	fe843783          	ld	a5,-24(s0)
    8001334e:	0347c783          	lbu	a5,52(a5)
    80013352:	fef403a3          	sb	a5,-25(s0)
    80013356:	a011                	j	8001335a <print_vendor_specific_capabilities+0x3a>
    if (!pci_is_virtio_device(pcidevice)) return;
    80013358:	0001                	nop
        }

        cap_pointer = cape->next;  
    }
    */
}
    8001335a:	70a2                	ld	ra,40(sp)
    8001335c:	7402                	ld	s0,32(sp)
    8001335e:	6145                	addi	sp,sp,48
    80013360:	8082                	ret

0000000080013362 <pci_init>:

void pci_init(void)
{
    80013362:	1101                	addi	sp,sp,-32
    80013364:	ec06                	sd	ra,24(sp)
    80013366:	e822                	sd	s0,16(sp)
    80013368:	1000                	addi	s0,sp,32
    all_pci_devices = vector_new();
    8001336a:	4540d0ef          	jal	ra,800207be <vector_new>
    8001336e:	872a                	mv	a4,a0
    80013370:	00010797          	auipc	a5,0x10
    80013374:	cc878793          	addi	a5,a5,-824 # 80023038 <all_pci_devices>
    80013378:	e398                	sd	a4,0(a5)
    for (int i=0; i<4; i++) {
    8001337a:	fe042623          	sw	zero,-20(s0)
    8001337e:	a015                	j	800133a2 <pci_init+0x40>
        irq_pci_devices[i] = vector_new();
    80013380:	43e0d0ef          	jal	ra,800207be <vector_new>
    80013384:	86aa                	mv	a3,a0
    80013386:	00010717          	auipc	a4,0x10
    8001338a:	cba70713          	addi	a4,a4,-838 # 80023040 <irq_pci_devices>
    8001338e:	fec42783          	lw	a5,-20(s0)
    80013392:	078e                	slli	a5,a5,0x3
    80013394:	97ba                	add	a5,a5,a4
    80013396:	e394                	sd	a3,0(a5)
    for (int i=0; i<4; i++) {
    80013398:	fec42783          	lw	a5,-20(s0)
    8001339c:	2785                	addiw	a5,a5,1
    8001339e:	fef42623          	sw	a5,-20(s0)
    800133a2:	fec42783          	lw	a5,-20(s0)
    800133a6:	0007871b          	sext.w	a4,a5
    800133aa:	478d                	li	a5,3
    800133ac:	fce7dae3          	bge	a5,a4,80013380 <pci_init+0x1e>
    }

    pci_enumerate_bus();
    800133b0:	a71ff0ef          	jal	ra,80012e20 <pci_enumerate_bus>
    debugf("PCI devices: %d\n", pci_count_saved_devices());
    debugf("PCI devices sharing IRQ 32: %d\n", pci_count_irq_listeners(32));
    debugf("PCI devices sharing IRQ 33: %d\n", pci_count_irq_listeners(33));
    debugf("PCI devices sharing IRQ 34: %d\n", pci_count_irq_listeners(34));
    debugf("PCI devices sharing IRQ 35: %d\n", pci_count_irq_listeners(35));
}
    800133b4:	0001                	nop
    800133b6:	60e2                	ld	ra,24(sp)
    800133b8:	6442                	ld	s0,16(sp)
    800133ba:	6105                	addi	sp,sp,32
    800133bc:	8082                	ret

00000000800133be <pci_dispatch_irq>:
/**
 * @brief Dispatch an interrupt to the PCI subsystem
 * @param irq - the IRQ number that interrupted
 */
void pci_dispatch_irq(int irq)
{
    800133be:	7129                	addi	sp,sp,-320
    800133c0:	fe06                	sd	ra,312(sp)
    800133c2:	fa22                	sd	s0,304(sp)
    800133c4:	0280                	addi	s0,sp,320
    800133c6:	87aa                	mv	a5,a0
    800133c8:	ecf42623          	sw	a5,-308(s0)
    // device changed its configuration, and that was the reason
    // the interrupt occurred.

    // IRQ#=32+(bus+slot)mod4
    // uint32_t vector_idx = irq - 32;
    PCIDevice *pcidevice = pci_find_device_by_irq(irq);
    800133cc:	ecc42783          	lw	a5,-308(s0)
    800133d0:	0ff7f793          	andi	a5,a5,255
    800133d4:	853e                	mv	a0,a5
    800133d6:	f20ff0ef          	jal	ra,80012af6 <pci_find_device_by_irq>
    800133da:	fea43423          	sd	a0,-24(s0)
    if (pcidevice == NULL) {
    800133de:	fe843783          	ld	a5,-24(s0)
    800133e2:	eb99                	bnez	a5,800133f8 <pci_dispatch_irq+0x3a>
        warnf("No PCI device found with IRQ %d\n", irq);
    800133e4:	ecc42783          	lw	a5,-308(s0)
    800133e8:	85be                	mv	a1,a5
    800133ea:	00011517          	auipc	a0,0x11
    800133ee:	13e50513          	addi	a0,a0,318 # 80024528 <pow10.0+0x2f8>
    800133f2:	60f050ef          	jal	ra,80019200 <warnf>
        return;
    800133f6:	a0d5                	j	800134da <pci_dispatch_irq+0x11c>
    }
    debugf("PCI device with IRQ %d: 0x%04x\n", irq, pcidevice->ecam_header->device_id);
    // Is this a virtio device?
    if (pci_is_virtio_device(pcidevice)) { 
    800133f8:	fe843503          	ld	a0,-24(s0)
    800133fc:	b36ff0ef          	jal	ra,80012732 <pci_is_virtio_device>
    80013400:	87aa                	mv	a5,a0
    80013402:	0c078c63          	beqz	a5,800134da <pci_dispatch_irq+0x11c>
        // Access through ecam_header
        VirtioDevice *virtdevice = virtio_from_pci_device(pcidevice);
    80013406:	fe843503          	ld	a0,-24(s0)
    8001340a:	4fc070ef          	jal	ra,8001a906 <virtio_from_pci_device>
    8001340e:	fea43023          	sd	a0,-32(s0)
        debugf("Virtio device! %p\n", virtdevice->pcidev->ecam_header);

        if (virtio_is_rng_device(virtdevice)) {
    80013412:	fe043503          	ld	a0,-32(s0)
    80013416:	1e0070ef          	jal	ra,8001a5f6 <virtio_is_rng_device>
    8001341a:	87aa                	mv	a5,a0
    8001341c:	cb8d                	beqz	a5,8001344e <pci_dispatch_irq+0x90>
            debugf("RNG sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 1, true);
    8001341e:	ed840793          	addi	a5,s0,-296
    80013422:	4705                	li	a4,1
    80013424:	4685                	li	a3,1
    80013426:	863e                	mv	a2,a5
    80013428:	4581                	li	a1,0
    8001342a:	fe043503          	ld	a0,-32(s0)
    8001342e:	5b1070ef          	jal	ra,8001b1de <virtio_receive_descriptor_chain>
    80013432:	87aa                	mv	a5,a0
    80013434:	fcf41d23          	sh	a5,-38(s0)

            virtio_handle_interrupt(virtdevice, descriptors, received);
    80013438:	fda45703          	lhu	a4,-38(s0)
    8001343c:	ed840793          	addi	a5,s0,-296
    80013440:	863a                	mv	a2,a4
    80013442:	85be                	mv	a1,a5
    80013444:	fe043503          	ld	a0,-32(s0)
    80013448:	77d060ef          	jal	ra,8001a3c4 <virtio_handle_interrupt>
    8001344c:	a079                	j	800134da <pci_dispatch_irq+0x11c>
            debugf("Received %d descriptors\n", received);
        }

        else if (virtio_is_block_device(virtdevice)) {
    8001344e:	fe043503          	ld	a0,-32(s0)
    80013452:	1da070ef          	jal	ra,8001a62c <virtio_is_block_device>
    80013456:	87aa                	mv	a5,a0
    80013458:	cb8d                	beqz	a5,8001348a <pci_dispatch_irq+0xcc>
            debugf("Block device sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 3, true);
    8001345a:	ed840793          	addi	a5,s0,-296
    8001345e:	4705                	li	a4,1
    80013460:	468d                	li	a3,3
    80013462:	863e                	mv	a2,a5
    80013464:	4581                	li	a1,0
    80013466:	fe043503          	ld	a0,-32(s0)
    8001346a:	575070ef          	jal	ra,8001b1de <virtio_receive_descriptor_chain>
    8001346e:	87aa                	mv	a5,a0
    80013470:	fcf41e23          	sh	a5,-36(s0)
            virtio_handle_interrupt(virtdevice, descriptors, received);
    80013474:	fdc45703          	lhu	a4,-36(s0)
    80013478:	ed840793          	addi	a5,s0,-296
    8001347c:	863a                	mv	a2,a4
    8001347e:	85be                	mv	a1,a5
    80013480:	fe043503          	ld	a0,-32(s0)
    80013484:	741060ef          	jal	ra,8001a3c4 <virtio_handle_interrupt>
    80013488:	a889                	j	800134da <pci_dispatch_irq+0x11c>
            debugf("Received %d descriptors\n", received);
        }

        else if (virtio_is_input_device(virtdevice)) {
    8001348a:	fe043503          	ld	a0,-32(s0)
    8001348e:	1d4070ef          	jal	ra,8001a662 <virtio_is_input_device>
    80013492:	87aa                	mv	a5,a0
    80013494:	c791                	beqz	a5,800134a0 <pci_dispatch_irq+0xe2>
            debugf("input device sent interrupt!\n");
            input_device_isr(virtdevice);
    80013496:	fe043503          	ld	a0,-32(s0)
    8001349a:	2fd080ef          	jal	ra,8001bf96 <input_device_isr>
    8001349e:	a835                	j	800134da <pci_dispatch_irq+0x11c>
        //     VirtioDescriptor descriptors[16];
        //     uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 16, true);
        //     uint16_t received2 = virtio_receive_descriptor_chain(virtdevice, 1, descriptors, 16, true);
        //     debugf("Received %d descriptors\n", received);
        // }
        else if (virtio_is_gpu_device(virtdevice)) {
    800134a0:	fe043503          	ld	a0,-32(s0)
    800134a4:	1f4070ef          	jal	ra,8001a698 <virtio_is_gpu_device>
    800134a8:	87aa                	mv	a5,a0
    800134aa:	cb85                	beqz	a5,800134da <pci_dispatch_irq+0x11c>
            debugf("GPU device sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 3, true);
    800134ac:	ed840793          	addi	a5,s0,-296
    800134b0:	4705                	li	a4,1
    800134b2:	468d                	li	a3,3
    800134b4:	863e                	mv	a2,a5
    800134b6:	4581                	li	a1,0
    800134b8:	fe043503          	ld	a0,-32(s0)
    800134bc:	523070ef          	jal	ra,8001b1de <virtio_receive_descriptor_chain>
    800134c0:	87aa                	mv	a5,a0
    800134c2:	fcf41f23          	sh	a5,-34(s0)
            debugf("Received %d descriptors\n", received);
            virtio_handle_interrupt(virtdevice, descriptors, received);
    800134c6:	fde45703          	lhu	a4,-34(s0)
    800134ca:	ed840793          	addi	a5,s0,-296
    800134ce:	863a                	mv	a2,a4
    800134d0:	85be                	mv	a1,a5
    800134d2:	fe043503          	ld	a0,-32(s0)
    800134d6:	6ef060ef          	jal	ra,8001a3c4 <virtio_handle_interrupt>
            
        }
    }

    debugf("Leaving dispatch IRQ\n");
}
    800134da:	70f2                	ld	ra,312(sp)
    800134dc:	7452                	ld	s0,304(sp)
    800134de:	6131                	addi	sp,sp,320
    800134e0:	8082                	ret

00000000800134e2 <insert_block>:
 * into free list, sorted by addr.
 * If disabled, add block has new head of
 * the free list.
 */
static void insert_block(Block *block)
{
    800134e2:	7179                	addi	sp,sp,-48
    800134e4:	f422                	sd	s0,40(sp)
    800134e6:	1800                	addi	s0,sp,48
    800134e8:	fca43c23          	sd	a0,-40(s0)
    Block *ptr  = heap->free;
    800134ec:	00010797          	auipc	a5,0x10
    800134f0:	b7c78793          	addi	a5,a5,-1156 # 80023068 <heap>
    800134f4:	639c                	ld	a5,0(a5)
    800134f6:	639c                	ld	a5,0(a5)
    800134f8:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    800134fc:	fe043023          	sd	zero,-32(s0)
    while (ptr != NULL) {
    80013500:	a01d                	j	80013526 <insert_block+0x44>
        if ((size_t)block->addr <= (size_t)ptr->addr) {
    80013502:	fd843783          	ld	a5,-40(s0)
    80013506:	639c                	ld	a5,0(a5)
    80013508:	873e                	mv	a4,a5
    8001350a:	fe843783          	ld	a5,-24(s0)
    8001350e:	639c                	ld	a5,0(a5)
    80013510:	00e7ff63          	bgeu	a5,a4,8001352e <insert_block+0x4c>
            break;
        }
        prev = ptr;
    80013514:	fe843783          	ld	a5,-24(s0)
    80013518:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    8001351c:	fe843783          	ld	a5,-24(s0)
    80013520:	679c                	ld	a5,8(a5)
    80013522:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80013526:	fe843783          	ld	a5,-24(s0)
    8001352a:	ffe1                	bnez	a5,80013502 <insert_block+0x20>
    8001352c:	a011                	j	80013530 <insert_block+0x4e>
            break;
    8001352e:	0001                	nop
    }
    if (prev != NULL) {
    80013530:	fe043783          	ld	a5,-32(s0)
    80013534:	c799                	beqz	a5,80013542 <insert_block+0x60>
        prev->next = block;
    80013536:	fe043783          	ld	a5,-32(s0)
    8001353a:	fd843703          	ld	a4,-40(s0)
    8001353e:	e798                	sd	a4,8(a5)
    80013540:	a809                	j	80013552 <insert_block+0x70>
    }
    else {
        heap->free = block;
    80013542:	00010797          	auipc	a5,0x10
    80013546:	b2678793          	addi	a5,a5,-1242 # 80023068 <heap>
    8001354a:	639c                	ld	a5,0(a5)
    8001354c:	fd843703          	ld	a4,-40(s0)
    80013550:	e398                	sd	a4,0(a5)
    }
    block->next = ptr;
    80013552:	fd843783          	ld	a5,-40(s0)
    80013556:	fe843703          	ld	a4,-24(s0)
    8001355a:	e798                	sd	a4,8(a5)
}
    8001355c:	0001                	nop
    8001355e:	7422                	ld	s0,40(sp)
    80013560:	6145                	addi	sp,sp,48
    80013562:	8082                	ret

0000000080013564 <release_blocks>:

#ifndef TA_DISABLE_COMPACT
static void release_blocks(Block *scan, Block *to)
{
    80013564:	7179                	addi	sp,sp,-48
    80013566:	f422                	sd	s0,40(sp)
    80013568:	1800                	addi	s0,sp,48
    8001356a:	fca43c23          	sd	a0,-40(s0)
    8001356e:	fcb43823          	sd	a1,-48(s0)
    Block *scan_next;
    while (scan != to) {
    80013572:	a099                	j	800135b8 <release_blocks+0x54>
        scan_next   = scan->next;
    80013574:	fd843783          	ld	a5,-40(s0)
    80013578:	679c                	ld	a5,8(a5)
    8001357a:	fef43423          	sd	a5,-24(s0)
        scan->next  = heap->fresh;
    8001357e:	00010797          	auipc	a5,0x10
    80013582:	aea78793          	addi	a5,a5,-1302 # 80023068 <heap>
    80013586:	639c                	ld	a5,0(a5)
    80013588:	6b98                	ld	a4,16(a5)
    8001358a:	fd843783          	ld	a5,-40(s0)
    8001358e:	e798                	sd	a4,8(a5)
        heap->fresh = scan;
    80013590:	00010797          	auipc	a5,0x10
    80013594:	ad878793          	addi	a5,a5,-1320 # 80023068 <heap>
    80013598:	639c                	ld	a5,0(a5)
    8001359a:	fd843703          	ld	a4,-40(s0)
    8001359e:	eb98                	sd	a4,16(a5)
        scan->addr  = 0;
    800135a0:	fd843783          	ld	a5,-40(s0)
    800135a4:	0007b023          	sd	zero,0(a5)
        scan->size  = 0;
    800135a8:	fd843783          	ld	a5,-40(s0)
    800135ac:	0007b823          	sd	zero,16(a5)
        scan        = scan_next;
    800135b0:	fe843783          	ld	a5,-24(s0)
    800135b4:	fcf43c23          	sd	a5,-40(s0)
    while (scan != to) {
    800135b8:	fd843703          	ld	a4,-40(s0)
    800135bc:	fd043783          	ld	a5,-48(s0)
    800135c0:	faf71ae3          	bne	a4,a5,80013574 <release_blocks+0x10>
    }
}
    800135c4:	0001                	nop
    800135c6:	0001                	nop
    800135c8:	7422                	ld	s0,40(sp)
    800135ca:	6145                	addi	sp,sp,48
    800135cc:	8082                	ret

00000000800135ce <compact>:

static void compact()
{
    800135ce:	7139                	addi	sp,sp,-64
    800135d0:	fc06                	sd	ra,56(sp)
    800135d2:	f822                	sd	s0,48(sp)
    800135d4:	0080                	addi	s0,sp,64
    Block *ptr = heap->free;
    800135d6:	00010797          	auipc	a5,0x10
    800135da:	a9278793          	addi	a5,a5,-1390 # 80023068 <heap>
    800135de:	639c                	ld	a5,0(a5)
    800135e0:	639c                	ld	a5,0(a5)
    800135e2:	fef43423          	sd	a5,-24(s0)
    Block *prev;
    Block *scan;
    while (ptr != NULL) {
    800135e6:	a075                	j	80013692 <compact+0xc4>
        prev = ptr;
    800135e8:	fe843783          	ld	a5,-24(s0)
    800135ec:	fef43023          	sd	a5,-32(s0)
        scan = ptr->next;
    800135f0:	fe843783          	ld	a5,-24(s0)
    800135f4:	679c                	ld	a5,8(a5)
    800135f6:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    800135fa:	a811                	j	8001360e <compact+0x40>
            prev = scan;
    800135fc:	fd843783          	ld	a5,-40(s0)
    80013600:	fef43023          	sd	a5,-32(s0)
            scan = scan->next;
    80013604:	fd843783          	ld	a5,-40(s0)
    80013608:	679c                	ld	a5,8(a5)
    8001360a:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    8001360e:	fd843783          	ld	a5,-40(s0)
    80013612:	cf91                	beqz	a5,8001362e <compact+0x60>
    80013614:	fe043783          	ld	a5,-32(s0)
    80013618:	639c                	ld	a5,0(a5)
    8001361a:	873e                	mv	a4,a5
    8001361c:	fe043783          	ld	a5,-32(s0)
    80013620:	6b9c                	ld	a5,16(a5)
    80013622:	97ba                	add	a5,a5,a4
    80013624:	fd843703          	ld	a4,-40(s0)
    80013628:	6318                	ld	a4,0(a4)
    8001362a:	fce789e3          	beq	a5,a4,800135fc <compact+0x2e>
        }
        if (prev != ptr) {
    8001362e:	fe043703          	ld	a4,-32(s0)
    80013632:	fe843783          	ld	a5,-24(s0)
    80013636:	04f70963          	beq	a4,a5,80013688 <compact+0xba>
            size_t new_size = (size_t)prev->addr - (size_t)ptr->addr + prev->size;
    8001363a:	fe043783          	ld	a5,-32(s0)
    8001363e:	639c                	ld	a5,0(a5)
    80013640:	873e                	mv	a4,a5
    80013642:	fe843783          	ld	a5,-24(s0)
    80013646:	639c                	ld	a5,0(a5)
    80013648:	8f1d                	sub	a4,a4,a5
    8001364a:	fe043783          	ld	a5,-32(s0)
    8001364e:	6b9c                	ld	a5,16(a5)
    80013650:	97ba                	add	a5,a5,a4
    80013652:	fcf43823          	sd	a5,-48(s0)
            ptr->size       = new_size;
    80013656:	fe843783          	ld	a5,-24(s0)
    8001365a:	fd043703          	ld	a4,-48(s0)
    8001365e:	eb98                	sd	a4,16(a5)
            Block *next     = prev->next;
    80013660:	fe043783          	ld	a5,-32(s0)
    80013664:	679c                	ld	a5,8(a5)
    80013666:	fcf43423          	sd	a5,-56(s0)
            // make merged blocks available
            release_blocks(ptr->next, prev->next);
    8001366a:	fe843783          	ld	a5,-24(s0)
    8001366e:	6798                	ld	a4,8(a5)
    80013670:	fe043783          	ld	a5,-32(s0)
    80013674:	679c                	ld	a5,8(a5)
    80013676:	85be                	mv	a1,a5
    80013678:	853a                	mv	a0,a4
    8001367a:	eebff0ef          	jal	ra,80013564 <release_blocks>
            // relink
            ptr->next = next;
    8001367e:	fe843783          	ld	a5,-24(s0)
    80013682:	fc843703          	ld	a4,-56(s0)
    80013686:	e798                	sd	a4,8(a5)
        }
        ptr = ptr->next;
    80013688:	fe843783          	ld	a5,-24(s0)
    8001368c:	679c                	ld	a5,8(a5)
    8001368e:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80013692:	fe843783          	ld	a5,-24(s0)
    80013696:	fba9                	bnez	a5,800135e8 <compact+0x1a>
    }
}
    80013698:	0001                	nop
    8001369a:	0001                	nop
    8001369c:	70e2                	ld	ra,56(sp)
    8001369e:	7442                	ld	s0,48(sp)
    800136a0:	6121                	addi	sp,sp,64
    800136a2:	8082                	ret

00000000800136a4 <init>:
#endif

static bool init(const void *base, const void *limit, const size_t heap_blocks,
                 const size_t split_thresh, const size_t alignment)
{
    800136a4:	715d                	addi	sp,sp,-80
    800136a6:	e4a2                	sd	s0,72(sp)
    800136a8:	0880                	addi	s0,sp,80
    800136aa:	fca43c23          	sd	a0,-40(s0)
    800136ae:	fcb43823          	sd	a1,-48(s0)
    800136b2:	fcc43423          	sd	a2,-56(s0)
    800136b6:	fcd43023          	sd	a3,-64(s0)
    800136ba:	fae43c23          	sd	a4,-72(s0)
    heap              = (Heap *)base;
    800136be:	00010797          	auipc	a5,0x10
    800136c2:	9aa78793          	addi	a5,a5,-1622 # 80023068 <heap>
    800136c6:	fd843703          	ld	a4,-40(s0)
    800136ca:	e398                	sd	a4,0(a5)
    heap_limit        = limit;
    800136cc:	00010797          	auipc	a5,0x10
    800136d0:	9a478793          	addi	a5,a5,-1628 # 80023070 <heap_limit>
    800136d4:	fd043703          	ld	a4,-48(s0)
    800136d8:	e398                	sd	a4,0(a5)
    heap_split_thresh = split_thresh;
    800136da:	00010797          	auipc	a5,0x10
    800136de:	99e78793          	addi	a5,a5,-1634 # 80023078 <heap_split_thresh>
    800136e2:	fc043703          	ld	a4,-64(s0)
    800136e6:	e398                	sd	a4,0(a5)
    heap_alignment    = alignment;
    800136e8:	00010797          	auipc	a5,0x10
    800136ec:	99878793          	addi	a5,a5,-1640 # 80023080 <heap_alignment>
    800136f0:	fb843703          	ld	a4,-72(s0)
    800136f4:	e398                	sd	a4,0(a5)
    heap_max_blocks   = heap_blocks;
    800136f6:	00010797          	auipc	a5,0x10
    800136fa:	99278793          	addi	a5,a5,-1646 # 80023088 <heap_max_blocks>
    800136fe:	fc843703          	ld	a4,-56(s0)
    80013702:	e398                	sd	a4,0(a5)

    heap->free        = NULL;
    80013704:	00010797          	auipc	a5,0x10
    80013708:	96478793          	addi	a5,a5,-1692 # 80023068 <heap>
    8001370c:	639c                	ld	a5,0(a5)
    8001370e:	0007b023          	sd	zero,0(a5)
    heap->used        = NULL;
    80013712:	00010797          	auipc	a5,0x10
    80013716:	95678793          	addi	a5,a5,-1706 # 80023068 <heap>
    8001371a:	639c                	ld	a5,0(a5)
    8001371c:	0007b423          	sd	zero,8(a5)
    heap->fresh       = (Block *)(heap + 1);
    80013720:	00010797          	auipc	a5,0x10
    80013724:	94878793          	addi	a5,a5,-1720 # 80023068 <heap>
    80013728:	6398                	ld	a4,0(a5)
    8001372a:	00010797          	auipc	a5,0x10
    8001372e:	93e78793          	addi	a5,a5,-1730 # 80023068 <heap>
    80013732:	639c                	ld	a5,0(a5)
    80013734:	02070713          	addi	a4,a4,32
    80013738:	eb98                	sd	a4,16(a5)
    heap->top         = (size_t)(heap->fresh + heap_blocks);
    8001373a:	00010797          	auipc	a5,0x10
    8001373e:	92e78793          	addi	a5,a5,-1746 # 80023068 <heap>
    80013742:	639c                	ld	a5,0(a5)
    80013744:	6b94                	ld	a3,16(a5)
    80013746:	fc843703          	ld	a4,-56(s0)
    8001374a:	87ba                	mv	a5,a4
    8001374c:	0786                	slli	a5,a5,0x1
    8001374e:	97ba                	add	a5,a5,a4
    80013750:	078e                	slli	a5,a5,0x3
    80013752:	00f68733          	add	a4,a3,a5
    80013756:	00010797          	auipc	a5,0x10
    8001375a:	91278793          	addi	a5,a5,-1774 # 80023068 <heap>
    8001375e:	639c                	ld	a5,0(a5)
    80013760:	ef98                	sd	a4,24(a5)

    Block *block      = heap->fresh;
    80013762:	00010797          	auipc	a5,0x10
    80013766:	90678793          	addi	a5,a5,-1786 # 80023068 <heap>
    8001376a:	639c                	ld	a5,0(a5)
    8001376c:	6b9c                	ld	a5,16(a5)
    8001376e:	fef43423          	sd	a5,-24(s0)
    size_t i          = heap_max_blocks - 1;
    80013772:	00010797          	auipc	a5,0x10
    80013776:	91678793          	addi	a5,a5,-1770 # 80023088 <heap_max_blocks>
    8001377a:	639c                	ld	a5,0(a5)
    8001377c:	17fd                	addi	a5,a5,-1
    8001377e:	fef43023          	sd	a5,-32(s0)
    while (i--) {
    80013782:	a829                	j	8001379c <init+0xf8>
        block->next = block + 1;
    80013784:	fe843783          	ld	a5,-24(s0)
    80013788:	01878713          	addi	a4,a5,24
    8001378c:	fe843783          	ld	a5,-24(s0)
    80013790:	e798                	sd	a4,8(a5)
        block++;
    80013792:	fe843783          	ld	a5,-24(s0)
    80013796:	07e1                	addi	a5,a5,24
    80013798:	fef43423          	sd	a5,-24(s0)
    while (i--) {
    8001379c:	fe043783          	ld	a5,-32(s0)
    800137a0:	fff78713          	addi	a4,a5,-1
    800137a4:	fee43023          	sd	a4,-32(s0)
    800137a8:	fff1                	bnez	a5,80013784 <init+0xe0>
    }
    block->next = NULL;
    800137aa:	fe843783          	ld	a5,-24(s0)
    800137ae:	0007b423          	sd	zero,8(a5)
    return true;
    800137b2:	4785                	li	a5,1
}
    800137b4:	853e                	mv	a0,a5
    800137b6:	6426                	ld	s0,72(sp)
    800137b8:	6161                	addi	sp,sp,80
    800137ba:	8082                	ret

00000000800137bc <free>:

static bool free(const void *free)
{
    800137bc:	7179                	addi	sp,sp,-48
    800137be:	f406                	sd	ra,40(sp)
    800137c0:	f022                	sd	s0,32(sp)
    800137c2:	1800                	addi	s0,sp,48
    800137c4:	fca43c23          	sd	a0,-40(s0)
    Block *block = heap->used;
    800137c8:	00010797          	auipc	a5,0x10
    800137cc:	8a078793          	addi	a5,a5,-1888 # 80023068 <heap>
    800137d0:	639c                	ld	a5,0(a5)
    800137d2:	679c                	ld	a5,8(a5)
    800137d4:	fef43423          	sd	a5,-24(s0)
    Block *prev  = NULL;
    800137d8:	fe043023          	sd	zero,-32(s0)
    while (block != NULL) {
    800137dc:	a8a1                	j	80013834 <free+0x78>
        if (free == block->addr) {
    800137de:	fe843783          	ld	a5,-24(s0)
    800137e2:	639c                	ld	a5,0(a5)
    800137e4:	fd843703          	ld	a4,-40(s0)
    800137e8:	02f71d63          	bne	a4,a5,80013822 <free+0x66>
            if (prev) {
    800137ec:	fe043783          	ld	a5,-32(s0)
    800137f0:	cb81                	beqz	a5,80013800 <free+0x44>
                prev->next = block->next;
    800137f2:	fe843783          	ld	a5,-24(s0)
    800137f6:	6798                	ld	a4,8(a5)
    800137f8:	fe043783          	ld	a5,-32(s0)
    800137fc:	e798                	sd	a4,8(a5)
    800137fe:	a811                	j	80013812 <free+0x56>
            }
            else {
                heap->used = block->next;
    80013800:	00010797          	auipc	a5,0x10
    80013804:	86878793          	addi	a5,a5,-1944 # 80023068 <heap>
    80013808:	639c                	ld	a5,0(a5)
    8001380a:	fe843703          	ld	a4,-24(s0)
    8001380e:	6718                	ld	a4,8(a4)
    80013810:	e798                	sd	a4,8(a5)
            }
            insert_block(block);
    80013812:	fe843503          	ld	a0,-24(s0)
    80013816:	ccdff0ef          	jal	ra,800134e2 <insert_block>
            compact();
    8001381a:	db5ff0ef          	jal	ra,800135ce <compact>
            return true;
    8001381e:	4785                	li	a5,1
    80013820:	a831                	j	8001383c <free+0x80>
        }
        prev  = block;
    80013822:	fe843783          	ld	a5,-24(s0)
    80013826:	fef43023          	sd	a5,-32(s0)
        block = block->next;
    8001382a:	fe843783          	ld	a5,-24(s0)
    8001382e:	679c                	ld	a5,8(a5)
    80013830:	fef43423          	sd	a5,-24(s0)
    while (block != NULL) {
    80013834:	fe843783          	ld	a5,-24(s0)
    80013838:	f3dd                	bnez	a5,800137de <free+0x22>
    }
    return false;
    8001383a:	4781                	li	a5,0
}
    8001383c:	853e                	mv	a0,a5
    8001383e:	70a2                	ld	ra,40(sp)
    80013840:	7402                	ld	s0,32(sp)
    80013842:	6145                	addi	sp,sp,48
    80013844:	8082                	ret

0000000080013846 <alloc_block>:

static Block *alloc_block(size_t num)
{
    80013846:	711d                	addi	sp,sp,-96
    80013848:	ec86                	sd	ra,88(sp)
    8001384a:	e8a2                	sd	s0,80(sp)
    8001384c:	1080                	addi	s0,sp,96
    8001384e:	faa43423          	sd	a0,-88(s0)
    Block *ptr  = heap->free;
    80013852:	00010797          	auipc	a5,0x10
    80013856:	81678793          	addi	a5,a5,-2026 # 80023068 <heap>
    8001385a:	639c                	ld	a5,0(a5)
    8001385c:	639c                	ld	a5,0(a5)
    8001385e:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    80013862:	fe043023          	sd	zero,-32(s0)
    size_t top  = heap->top;
    80013866:	00010797          	auipc	a5,0x10
    8001386a:	80278793          	addi	a5,a5,-2046 # 80023068 <heap>
    8001386e:	639c                	ld	a5,0(a5)
    80013870:	6f9c                	ld	a5,24(a5)
    80013872:	fcf43c23          	sd	a5,-40(s0)
    num         = (num + heap_alignment - 1) & -heap_alignment;
    80013876:	00010797          	auipc	a5,0x10
    8001387a:	80a78793          	addi	a5,a5,-2038 # 80023080 <heap_alignment>
    8001387e:	6398                	ld	a4,0(a5)
    80013880:	fa843783          	ld	a5,-88(s0)
    80013884:	97ba                	add	a5,a5,a4
    80013886:	fff78713          	addi	a4,a5,-1
    8001388a:	0000f797          	auipc	a5,0xf
    8001388e:	7f678793          	addi	a5,a5,2038 # 80023080 <heap_alignment>
    80013892:	639c                	ld	a5,0(a5)
    80013894:	40f007b3          	neg	a5,a5
    80013898:	8ff9                	and	a5,a5,a4
    8001389a:	faf43423          	sd	a5,-88(s0)
    while (ptr != NULL) {
    8001389e:	a2bd                	j	80013a0c <alloc_block+0x1c6>
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    800138a0:	fe843783          	ld	a5,-24(s0)
    800138a4:	639c                	ld	a5,0(a5)
    800138a6:	873e                	mv	a4,a5
    800138a8:	fe843783          	ld	a5,-24(s0)
    800138ac:	6b9c                	ld	a5,16(a5)
    800138ae:	97ba                	add	a5,a5,a4
    800138b0:	fd843703          	ld	a4,-40(s0)
    800138b4:	02e7e263          	bltu	a5,a4,800138d8 <alloc_block+0x92>
                           ((size_t)ptr->addr + num <= (size_t)heap_limit);
    800138b8:	fe843783          	ld	a5,-24(s0)
    800138bc:	639c                	ld	a5,0(a5)
    800138be:	873e                	mv	a4,a5
    800138c0:	fa843783          	ld	a5,-88(s0)
    800138c4:	97ba                	add	a5,a5,a4
    800138c6:	0000f717          	auipc	a4,0xf
    800138ca:	7aa70713          	addi	a4,a4,1962 # 80023070 <heap_limit>
    800138ce:	6318                	ld	a4,0(a4)
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    800138d0:	00f76463          	bltu	a4,a5,800138d8 <alloc_block+0x92>
    800138d4:	4785                	li	a5,1
    800138d6:	a011                	j	800138da <alloc_block+0x94>
    800138d8:	4781                	li	a5,0
    800138da:	fcf42623          	sw	a5,-52(s0)
        if (is_top || ptr->size >= num) {
    800138de:	fcc42783          	lw	a5,-52(s0)
    800138e2:	2781                	sext.w	a5,a5
    800138e4:	eb81                	bnez	a5,800138f4 <alloc_block+0xae>
    800138e6:	fe843783          	ld	a5,-24(s0)
    800138ea:	6b9c                	ld	a5,16(a5)
    800138ec:	fa843703          	ld	a4,-88(s0)
    800138f0:	10e7e563          	bltu	a5,a4,800139fa <alloc_block+0x1b4>
            if (prev != NULL) {
    800138f4:	fe043783          	ld	a5,-32(s0)
    800138f8:	cb81                	beqz	a5,80013908 <alloc_block+0xc2>
                prev->next = ptr->next;
    800138fa:	fe843783          	ld	a5,-24(s0)
    800138fe:	6798                	ld	a4,8(a5)
    80013900:	fe043783          	ld	a5,-32(s0)
    80013904:	e798                	sd	a4,8(a5)
    80013906:	a811                	j	8001391a <alloc_block+0xd4>
            }
            else {
                heap->free = ptr->next;
    80013908:	0000f797          	auipc	a5,0xf
    8001390c:	76078793          	addi	a5,a5,1888 # 80023068 <heap>
    80013910:	639c                	ld	a5,0(a5)
    80013912:	fe843703          	ld	a4,-24(s0)
    80013916:	6718                	ld	a4,8(a4)
    80013918:	e398                	sd	a4,0(a5)
            }
            ptr->next  = heap->used;
    8001391a:	0000f797          	auipc	a5,0xf
    8001391e:	74e78793          	addi	a5,a5,1870 # 80023068 <heap>
    80013922:	639c                	ld	a5,0(a5)
    80013924:	6798                	ld	a4,8(a5)
    80013926:	fe843783          	ld	a5,-24(s0)
    8001392a:	e798                	sd	a4,8(a5)
            heap->used = ptr;
    8001392c:	0000f797          	auipc	a5,0xf
    80013930:	73c78793          	addi	a5,a5,1852 # 80023068 <heap>
    80013934:	639c                	ld	a5,0(a5)
    80013936:	fe843703          	ld	a4,-24(s0)
    8001393a:	e798                	sd	a4,8(a5)
            if (is_top) {
    8001393c:	fcc42783          	lw	a5,-52(s0)
    80013940:	2781                	sext.w	a5,a5
    80013942:	c785                	beqz	a5,8001396a <alloc_block+0x124>
                ptr->size = num;
    80013944:	fe843783          	ld	a5,-24(s0)
    80013948:	fa843703          	ld	a4,-88(s0)
    8001394c:	eb98                	sd	a4,16(a5)
                heap->top = (size_t)ptr->addr + num;
    8001394e:	fe843783          	ld	a5,-24(s0)
    80013952:	639c                	ld	a5,0(a5)
    80013954:	86be                	mv	a3,a5
    80013956:	0000f797          	auipc	a5,0xf
    8001395a:	71278793          	addi	a5,a5,1810 # 80023068 <heap>
    8001395e:	639c                	ld	a5,0(a5)
    80013960:	fa843703          	ld	a4,-88(s0)
    80013964:	9736                	add	a4,a4,a3
    80013966:	ef98                	sd	a4,24(a5)
    80013968:	a071                	j	800139f4 <alloc_block+0x1ae>
            }
            else if (heap->fresh != NULL) {
    8001396a:	0000f797          	auipc	a5,0xf
    8001396e:	6fe78793          	addi	a5,a5,1790 # 80023068 <heap>
    80013972:	639c                	ld	a5,0(a5)
    80013974:	6b9c                	ld	a5,16(a5)
    80013976:	cfbd                	beqz	a5,800139f4 <alloc_block+0x1ae>
                size_t excess = ptr->size - num;
    80013978:	fe843783          	ld	a5,-24(s0)
    8001397c:	6b98                	ld	a4,16(a5)
    8001397e:	fa843783          	ld	a5,-88(s0)
    80013982:	40f707b3          	sub	a5,a4,a5
    80013986:	fcf43023          	sd	a5,-64(s0)
                if (excess >= heap_split_thresh) {
    8001398a:	0000f797          	auipc	a5,0xf
    8001398e:	6ee78793          	addi	a5,a5,1774 # 80023078 <heap_split_thresh>
    80013992:	639c                	ld	a5,0(a5)
    80013994:	fc043703          	ld	a4,-64(s0)
    80013998:	04f76e63          	bltu	a4,a5,800139f4 <alloc_block+0x1ae>
                    ptr->size    = num;
    8001399c:	fe843783          	ld	a5,-24(s0)
    800139a0:	fa843703          	ld	a4,-88(s0)
    800139a4:	eb98                	sd	a4,16(a5)
                    Block *split = heap->fresh;
    800139a6:	0000f797          	auipc	a5,0xf
    800139aa:	6c278793          	addi	a5,a5,1730 # 80023068 <heap>
    800139ae:	639c                	ld	a5,0(a5)
    800139b0:	6b9c                	ld	a5,16(a5)
    800139b2:	faf43c23          	sd	a5,-72(s0)
                    heap->fresh  = split->next;
    800139b6:	0000f797          	auipc	a5,0xf
    800139ba:	6b278793          	addi	a5,a5,1714 # 80023068 <heap>
    800139be:	639c                	ld	a5,0(a5)
    800139c0:	fb843703          	ld	a4,-72(s0)
    800139c4:	6718                	ld	a4,8(a4)
    800139c6:	eb98                	sd	a4,16(a5)
                    split->addr  = (void *)((size_t)ptr->addr + num);
    800139c8:	fe843783          	ld	a5,-24(s0)
    800139cc:	639c                	ld	a5,0(a5)
    800139ce:	873e                	mv	a4,a5
    800139d0:	fa843783          	ld	a5,-88(s0)
    800139d4:	97ba                	add	a5,a5,a4
    800139d6:	873e                	mv	a4,a5
    800139d8:	fb843783          	ld	a5,-72(s0)
    800139dc:	e398                	sd	a4,0(a5)
                    split->size  = excess;
    800139de:	fb843783          	ld	a5,-72(s0)
    800139e2:	fc043703          	ld	a4,-64(s0)
    800139e6:	eb98                	sd	a4,16(a5)
                    insert_block(split);
    800139e8:	fb843503          	ld	a0,-72(s0)
    800139ec:	af7ff0ef          	jal	ra,800134e2 <insert_block>
                    compact();
    800139f0:	bdfff0ef          	jal	ra,800135ce <compact>
                }
            }
            return ptr;
    800139f4:	fe843783          	ld	a5,-24(s0)
    800139f8:	a875                	j	80013ab4 <alloc_block+0x26e>
        }
        prev = ptr;
    800139fa:	fe843783          	ld	a5,-24(s0)
    800139fe:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    80013a02:	fe843783          	ld	a5,-24(s0)
    80013a06:	679c                	ld	a5,8(a5)
    80013a08:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80013a0c:	fe843783          	ld	a5,-24(s0)
    80013a10:	e80798e3          	bnez	a5,800138a0 <alloc_block+0x5a>
    }
    // no matching free blocks
    // see if any other blocks available
    size_t new_top = top + num;
    80013a14:	fd843703          	ld	a4,-40(s0)
    80013a18:	fa843783          	ld	a5,-88(s0)
    80013a1c:	97ba                	add	a5,a5,a4
    80013a1e:	fcf43823          	sd	a5,-48(s0)
    if (heap->fresh != NULL && new_top <= (size_t)heap_limit) {
    80013a22:	0000f797          	auipc	a5,0xf
    80013a26:	64678793          	addi	a5,a5,1606 # 80023068 <heap>
    80013a2a:	639c                	ld	a5,0(a5)
    80013a2c:	6b9c                	ld	a5,16(a5)
    80013a2e:	c3d1                	beqz	a5,80013ab2 <alloc_block+0x26c>
    80013a30:	0000f797          	auipc	a5,0xf
    80013a34:	64078793          	addi	a5,a5,1600 # 80023070 <heap_limit>
    80013a38:	639c                	ld	a5,0(a5)
    80013a3a:	873e                	mv	a4,a5
    80013a3c:	fd043783          	ld	a5,-48(s0)
    80013a40:	06f76963          	bltu	a4,a5,80013ab2 <alloc_block+0x26c>
        ptr         = heap->fresh;
    80013a44:	0000f797          	auipc	a5,0xf
    80013a48:	62478793          	addi	a5,a5,1572 # 80023068 <heap>
    80013a4c:	639c                	ld	a5,0(a5)
    80013a4e:	6b9c                	ld	a5,16(a5)
    80013a50:	fef43423          	sd	a5,-24(s0)
        heap->fresh = ptr->next;
    80013a54:	0000f797          	auipc	a5,0xf
    80013a58:	61478793          	addi	a5,a5,1556 # 80023068 <heap>
    80013a5c:	639c                	ld	a5,0(a5)
    80013a5e:	fe843703          	ld	a4,-24(s0)
    80013a62:	6718                	ld	a4,8(a4)
    80013a64:	eb98                	sd	a4,16(a5)
        ptr->addr   = (void *)top;
    80013a66:	fd843703          	ld	a4,-40(s0)
    80013a6a:	fe843783          	ld	a5,-24(s0)
    80013a6e:	e398                	sd	a4,0(a5)
        ptr->next   = heap->used;
    80013a70:	0000f797          	auipc	a5,0xf
    80013a74:	5f878793          	addi	a5,a5,1528 # 80023068 <heap>
    80013a78:	639c                	ld	a5,0(a5)
    80013a7a:	6798                	ld	a4,8(a5)
    80013a7c:	fe843783          	ld	a5,-24(s0)
    80013a80:	e798                	sd	a4,8(a5)
        ptr->size   = num;
    80013a82:	fe843783          	ld	a5,-24(s0)
    80013a86:	fa843703          	ld	a4,-88(s0)
    80013a8a:	eb98                	sd	a4,16(a5)
        heap->used  = ptr;
    80013a8c:	0000f797          	auipc	a5,0xf
    80013a90:	5dc78793          	addi	a5,a5,1500 # 80023068 <heap>
    80013a94:	639c                	ld	a5,0(a5)
    80013a96:	fe843703          	ld	a4,-24(s0)
    80013a9a:	e798                	sd	a4,8(a5)
        heap->top   = new_top;
    80013a9c:	0000f797          	auipc	a5,0xf
    80013aa0:	5cc78793          	addi	a5,a5,1484 # 80023068 <heap>
    80013aa4:	639c                	ld	a5,0(a5)
    80013aa6:	fd043703          	ld	a4,-48(s0)
    80013aaa:	ef98                	sd	a4,24(a5)
        return ptr;
    80013aac:	fe843783          	ld	a5,-24(s0)
    80013ab0:	a011                	j	80013ab4 <alloc_block+0x26e>
    }
    return NULL;
    80013ab2:	4781                	li	a5,0
}
    80013ab4:	853e                	mv	a0,a5
    80013ab6:	60e6                	ld	ra,88(sp)
    80013ab8:	6446                	ld	s0,80(sp)
    80013aba:	6125                	addi	sp,sp,96
    80013abc:	8082                	ret

0000000080013abe <alloc>:

static void *alloc(size_t num)
{
    80013abe:	7179                	addi	sp,sp,-48
    80013ac0:	f406                	sd	ra,40(sp)
    80013ac2:	f022                	sd	s0,32(sp)
    80013ac4:	1800                	addi	s0,sp,48
    80013ac6:	fca43c23          	sd	a0,-40(s0)
    Block *block = alloc_block(num);
    80013aca:	fd843503          	ld	a0,-40(s0)
    80013ace:	d79ff0ef          	jal	ra,80013846 <alloc_block>
    80013ad2:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80013ad6:	fe843783          	ld	a5,-24(s0)
    80013ada:	c789                	beqz	a5,80013ae4 <alloc+0x26>
        return block->addr;
    80013adc:	fe843783          	ld	a5,-24(s0)
    80013ae0:	639c                	ld	a5,0(a5)
    80013ae2:	a011                	j	80013ae6 <alloc+0x28>
    }
    return NULL;
    80013ae4:	4781                	li	a5,0
}
    80013ae6:	853e                	mv	a0,a5
    80013ae8:	70a2                	ld	ra,40(sp)
    80013aea:	7402                	ld	s0,32(sp)
    80013aec:	6145                	addi	sp,sp,48
    80013aee:	8082                	ret

0000000080013af0 <calloc>:

static void *calloc(size_t num, size_t size)
{
    80013af0:	7179                	addi	sp,sp,-48
    80013af2:	f406                	sd	ra,40(sp)
    80013af4:	f022                	sd	s0,32(sp)
    80013af6:	1800                	addi	s0,sp,48
    80013af8:	fca43c23          	sd	a0,-40(s0)
    80013afc:	fcb43823          	sd	a1,-48(s0)
    num *= size;
    80013b00:	fd843703          	ld	a4,-40(s0)
    80013b04:	fd043783          	ld	a5,-48(s0)
    80013b08:	02f707b3          	mul	a5,a4,a5
    80013b0c:	fcf43c23          	sd	a5,-40(s0)
    Block *block = alloc_block(num);
    80013b10:	fd843503          	ld	a0,-40(s0)
    80013b14:	d33ff0ef          	jal	ra,80013846 <alloc_block>
    80013b18:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80013b1c:	fe843783          	ld	a5,-24(s0)
    80013b20:	c385                	beqz	a5,80013b40 <calloc+0x50>
        memset(block->addr, 0, num);
    80013b22:	fe843783          	ld	a5,-24(s0)
    80013b26:	639c                	ld	a5,0(a5)
    80013b28:	fd843703          	ld	a4,-40(s0)
    80013b2c:	2701                	sext.w	a4,a4
    80013b2e:	863a                	mv	a2,a4
    80013b30:	4581                	li	a1,0
    80013b32:	853e                	mv	a0,a5
    80013b34:	2380c0ef          	jal	ra,8001fd6c <memset>
        return block->addr;
    80013b38:	fe843783          	ld	a5,-24(s0)
    80013b3c:	639c                	ld	a5,0(a5)
    80013b3e:	a011                	j	80013b42 <calloc+0x52>
    }
    return NULL;
    80013b40:	4781                	li	a5,0
}
    80013b42:	853e                	mv	a0,a5
    80013b44:	70a2                	ld	ra,40(sp)
    80013b46:	7402                	ld	s0,32(sp)
    80013b48:	6145                	addi	sp,sp,48
    80013b4a:	8082                	ret

0000000080013b4c <count_blocks>:

static size_t count_blocks(Block *ptr)
{
    80013b4c:	7179                	addi	sp,sp,-48
    80013b4e:	f422                	sd	s0,40(sp)
    80013b50:	1800                	addi	s0,sp,48
    80013b52:	fca43c23          	sd	a0,-40(s0)
    size_t num = 0;
    80013b56:	fe043423          	sd	zero,-24(s0)
    while (ptr != NULL) {
    80013b5a:	a819                	j	80013b70 <count_blocks+0x24>
        num++;
    80013b5c:	fe843783          	ld	a5,-24(s0)
    80013b60:	0785                	addi	a5,a5,1
    80013b62:	fef43423          	sd	a5,-24(s0)
        ptr = ptr->next;
    80013b66:	fd843783          	ld	a5,-40(s0)
    80013b6a:	679c                	ld	a5,8(a5)
    80013b6c:	fcf43c23          	sd	a5,-40(s0)
    while (ptr != NULL) {
    80013b70:	fd843783          	ld	a5,-40(s0)
    80013b74:	f7e5                	bnez	a5,80013b5c <count_blocks+0x10>
    }
    return num;
    80013b76:	fe843783          	ld	a5,-24(s0)
}
    80013b7a:	853e                	mv	a0,a5
    80013b7c:	7422                	ld	s0,40(sp)
    80013b7e:	6145                	addi	sp,sp,48
    80013b80:	8082                	ret

0000000080013b82 <heap_num_free>:
static size_t heap_num_free()
{
    80013b82:	1141                	addi	sp,sp,-16
    80013b84:	e406                	sd	ra,8(sp)
    80013b86:	e022                	sd	s0,0(sp)
    80013b88:	0800                	addi	s0,sp,16
    return count_blocks(heap->free);
    80013b8a:	0000f797          	auipc	a5,0xf
    80013b8e:	4de78793          	addi	a5,a5,1246 # 80023068 <heap>
    80013b92:	639c                	ld	a5,0(a5)
    80013b94:	639c                	ld	a5,0(a5)
    80013b96:	853e                	mv	a0,a5
    80013b98:	fb5ff0ef          	jal	ra,80013b4c <count_blocks>
    80013b9c:	87aa                	mv	a5,a0
}
    80013b9e:	853e                	mv	a0,a5
    80013ba0:	60a2                	ld	ra,8(sp)
    80013ba2:	6402                	ld	s0,0(sp)
    80013ba4:	0141                	addi	sp,sp,16
    80013ba6:	8082                	ret

0000000080013ba8 <heap_num_used>:
static size_t heap_num_used()
{
    80013ba8:	1141                	addi	sp,sp,-16
    80013baa:	e406                	sd	ra,8(sp)
    80013bac:	e022                	sd	s0,0(sp)
    80013bae:	0800                	addi	s0,sp,16
    return count_blocks(heap->used);
    80013bb0:	0000f797          	auipc	a5,0xf
    80013bb4:	4b878793          	addi	a5,a5,1208 # 80023068 <heap>
    80013bb8:	639c                	ld	a5,0(a5)
    80013bba:	679c                	ld	a5,8(a5)
    80013bbc:	853e                	mv	a0,a5
    80013bbe:	f8fff0ef          	jal	ra,80013b4c <count_blocks>
    80013bc2:	87aa                	mv	a5,a0
}
    80013bc4:	853e                	mv	a0,a5
    80013bc6:	60a2                	ld	ra,8(sp)
    80013bc8:	6402                	ld	s0,0(sp)
    80013bca:	0141                	addi	sp,sp,16
    80013bcc:	8082                	ret

0000000080013bce <heap_num_fresh>:
static size_t heap_num_fresh()
{
    80013bce:	1141                	addi	sp,sp,-16
    80013bd0:	e406                	sd	ra,8(sp)
    80013bd2:	e022                	sd	s0,0(sp)
    80013bd4:	0800                	addi	s0,sp,16
    return count_blocks(heap->fresh);
    80013bd6:	0000f797          	auipc	a5,0xf
    80013bda:	49278793          	addi	a5,a5,1170 # 80023068 <heap>
    80013bde:	639c                	ld	a5,0(a5)
    80013be0:	6b9c                	ld	a5,16(a5)
    80013be2:	853e                	mv	a0,a5
    80013be4:	f69ff0ef          	jal	ra,80013b4c <count_blocks>
    80013be8:	87aa                	mv	a5,a0
}
    80013bea:	853e                	mv	a0,a5
    80013bec:	60a2                	ld	ra,8(sp)
    80013bee:	6402                	ld	s0,0(sp)
    80013bf0:	0141                	addi	sp,sp,16
    80013bf2:	8082                	ret

0000000080013bf4 <heap_check>:
static bool heap_check()
{
    80013bf4:	1101                	addi	sp,sp,-32
    80013bf6:	ec06                	sd	ra,24(sp)
    80013bf8:	e822                	sd	s0,16(sp)
    80013bfa:	e426                	sd	s1,8(sp)
    80013bfc:	1000                	addi	s0,sp,32
    return heap_max_blocks == heap_num_free() + heap_num_used() + heap_num_fresh();
    80013bfe:	f85ff0ef          	jal	ra,80013b82 <heap_num_free>
    80013c02:	84aa                	mv	s1,a0
    80013c04:	fa5ff0ef          	jal	ra,80013ba8 <heap_num_used>
    80013c08:	87aa                	mv	a5,a0
    80013c0a:	94be                	add	s1,s1,a5
    80013c0c:	fc3ff0ef          	jal	ra,80013bce <heap_num_fresh>
    80013c10:	87aa                	mv	a5,a0
    80013c12:	00f48733          	add	a4,s1,a5
    80013c16:	0000f797          	auipc	a5,0xf
    80013c1a:	47278793          	addi	a5,a5,1138 # 80023088 <heap_max_blocks>
    80013c1e:	639c                	ld	a5,0(a5)
    80013c20:	40f707b3          	sub	a5,a4,a5
    80013c24:	0017b793          	seqz	a5,a5
    80013c28:	0ff7f793          	andi	a5,a5,255
}
    80013c2c:	853e                	mv	a0,a5
    80013c2e:	60e2                	ld	ra,24(sp)
    80013c30:	6442                	ld	s0,16(sp)
    80013c32:	64a2                	ld	s1,8(sp)
    80013c34:	6105                	addi	sp,sp,32
    80013c36:	8082                	ret

0000000080013c38 <heap_print_stats>:

void heap_print_stats(void)
{
    80013c38:	7179                	addi	sp,sp,-48
    80013c3a:	f406                	sd	ra,40(sp)
    80013c3c:	f022                	sd	s0,32(sp)
    80013c3e:	ec26                	sd	s1,24(sp)
    80013c40:	e84a                	sd	s2,16(sp)
    80013c42:	e44e                	sd	s3,8(sp)
    80013c44:	1800                	addi	s0,sp,48
    debugf(
    80013c46:	f3dff0ef          	jal	ra,80013b82 <heap_num_free>
    80013c4a:	84aa                	mv	s1,a0
    80013c4c:	f5dff0ef          	jal	ra,80013ba8 <heap_num_used>
    80013c50:	892a                	mv	s2,a0
    80013c52:	f7dff0ef          	jal	ra,80013bce <heap_num_fresh>
    80013c56:	89aa                	mv	s3,a0
        "HEAP\n~~~~\nFree blocks:    %lu\nUsed blocks:    %lu\nFresh blocks:   %lu\nHeap "
        "check:     %s\n",
        heap_num_free(), heap_num_used(), heap_num_fresh(), heap_check() ? "good" : "bad");
    80013c58:	f9dff0ef          	jal	ra,80013bf4 <heap_check>
    80013c5c:	87aa                	mv	a5,a0
    debugf(
    80013c5e:	c791                	beqz	a5,80013c6a <heap_print_stats+0x32>
    80013c60:	00011797          	auipc	a5,0x11
    80013c64:	8f078793          	addi	a5,a5,-1808 # 80024550 <pow10.0+0x320>
    80013c68:	a029                	j	80013c72 <heap_print_stats+0x3a>
    80013c6a:	00011797          	auipc	a5,0x11
    80013c6e:	8ee78793          	addi	a5,a5,-1810 # 80024558 <pow10.0+0x328>
    80013c72:	873e                	mv	a4,a5
    80013c74:	86ce                	mv	a3,s3
    80013c76:	864a                	mv	a2,s2
    80013c78:	85a6                	mv	a1,s1
    80013c7a:	00011517          	auipc	a0,0x11
    80013c7e:	8e650513          	addi	a0,a0,-1818 # 80024560 <pow10.0+0x330>
    80013c82:	528050ef          	jal	ra,800191aa <debugf>
}
    80013c86:	0001                	nop
    80013c88:	70a2                	ld	ra,40(sp)
    80013c8a:	7402                	ld	s0,32(sp)
    80013c8c:	64e2                	ld	s1,24(sp)
    80013c8e:	6942                	ld	s2,16(sp)
    80013c90:	69a2                	ld	s3,8(sp)
    80013c92:	6145                	addi	sp,sp,48
    80013c94:	8082                	ret

0000000080013c96 <kmalloc>:
void *kmalloc(size_t sz)
{
    80013c96:	1101                	addi	sp,sp,-32
    80013c98:	ec06                	sd	ra,24(sp)
    80013c9a:	e822                	sd	s0,16(sp)
    80013c9c:	1000                	addi	s0,sp,32
    80013c9e:	fea43423          	sd	a0,-24(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kmalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return alloc(sz);
    80013ca2:	fe843503          	ld	a0,-24(s0)
    80013ca6:	e19ff0ef          	jal	ra,80013abe <alloc>
    80013caa:	87aa                	mv	a5,a0
}
    80013cac:	853e                	mv	a0,a5
    80013cae:	60e2                	ld	ra,24(sp)
    80013cb0:	6442                	ld	s0,16(sp)
    80013cb2:	6105                	addi	sp,sp,32
    80013cb4:	8082                	ret

0000000080013cb6 <kcalloc>:
void *kcalloc(size_t n, size_t sz)
{
    80013cb6:	1101                	addi	sp,sp,-32
    80013cb8:	ec06                	sd	ra,24(sp)
    80013cba:	e822                	sd	s0,16(sp)
    80013cbc:	1000                	addi	s0,sp,32
    80013cbe:	fea43423          	sd	a0,-24(s0)
    80013cc2:	feb43023          	sd	a1,-32(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kcalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return calloc(n, sz);
    80013cc6:	fe043583          	ld	a1,-32(s0)
    80013cca:	fe843503          	ld	a0,-24(s0)
    80013cce:	e23ff0ef          	jal	ra,80013af0 <calloc>
    80013cd2:	87aa                	mv	a5,a0
}
    80013cd4:	853e                	mv	a0,a5
    80013cd6:	60e2                	ld	ra,24(sp)
    80013cd8:	6442                	ld	s0,16(sp)
    80013cda:	6105                	addi	sp,sp,32
    80013cdc:	8082                	ret

0000000080013cde <kfree>:
void kfree(void *m)
{
    80013cde:	1101                	addi	sp,sp,-32
    80013ce0:	ec06                	sd	ra,24(sp)
    80013ce2:	e822                	sd	s0,16(sp)
    80013ce4:	1000                	addi	s0,sp,32
    80013ce6:	fea43423          	sd	a0,-24(s0)
    if (m != NULL) {
    80013cea:	fe843783          	ld	a5,-24(s0)
    80013cee:	c789                	beqz	a5,80013cf8 <kfree+0x1a>
        free(m);
    80013cf0:	fe843503          	ld	a0,-24(s0)
    80013cf4:	ac9ff0ef          	jal	ra,800137bc <free>
    }
#ifdef DEBUG_KMALLOC
    debugf("[kfree]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
}
    80013cf8:	0001                	nop
    80013cfa:	60e2                	ld	ra,24(sp)
    80013cfc:	6442                	ld	s0,16(sp)
    80013cfe:	6105                	addi	sp,sp,32
    80013d00:	8082                	ret

0000000080013d02 <heap_init>:

void heap_init(void)
{
    80013d02:	1101                	addi	sp,sp,-32
    80013d04:	ec06                	sd	ra,24(sp)
    80013d06:	e822                	sd	s0,16(sp)
    80013d08:	1000                	addi	s0,sp,32
#ifdef DEBUG_HEAP
    debugf("[heap_init]: Prior to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif
    void *start = page_znalloc(KERNEL_HEAP_PAGES);
    80013d0a:	6505                	lui	a0,0x1
    80013d0c:	5b7070ef          	jal	ra,8001bac2 <page_znalloc>
    80013d10:	fea43423          	sd	a0,-24(s0)
    debugf("[heap_init]: Heap start at 0x%08lx\n", start);
    debugf("[heap_init]: After to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif

    mmu_map_range(kernel_mmu_table, KERNEL_HEAP_START_VADDR, KERNEL_HEAP_END_VADDR, (uint64_t)start,
    80013d14:	0000f797          	auipc	a5,0xf
    80013d18:	2ec78793          	addi	a5,a5,748 # 80023000 <kernel_mmu_table>
    80013d1c:	6388                	ld	a0,0(a5)
    80013d1e:	fe843683          	ld	a3,-24(s0)
    80013d22:	4799                	li	a5,6
    80013d24:	4701                	li	a4,0
    80013d26:	00e08637          	lui	a2,0xe08
    80013d2a:	7f760613          	addi	a2,a2,2039 # e087f7 <i+0xe087d7>
    80013d2e:	0636                	slli	a2,a2,0xd
    80013d30:	00e085b7          	lui	a1,0xe08
    80013d34:	15dd                	addi	a1,a1,-9
    80013d36:	05b6                	slli	a1,a1,0xd
    80013d38:	7c7050ef          	jal	ra,80019cfe <mmu_map_range>
                  MMU_LEVEL_4K, PB_READ | PB_WRITE);
    init((void *)KERNEL_HEAP_START_VADDR, (void *)KERNEL_HEAP_END_VADDR, KERNEL_HEAP_PAGES / 4, 16,
    80013d3c:	4721                	li	a4,8
    80013d3e:	46c1                	li	a3,16
    80013d40:	40000613          	li	a2,1024
    80013d44:	00e087b7          	lui	a5,0xe08
    80013d48:	7f778793          	addi	a5,a5,2039 # e087f7 <i+0xe087d7>
    80013d4c:	00d79593          	slli	a1,a5,0xd
    80013d50:	00e087b7          	lui	a5,0xe08
    80013d54:	17dd                	addi	a5,a5,-9
    80013d56:	00d79513          	slli	a0,a5,0xd
    80013d5a:	94bff0ef          	jal	ra,800136a4 <init>
         8);

}
    80013d5e:	0001                	nop
    80013d60:	60e2                	ld	ra,24(sp)
    80013d62:	6442                	ld	s0,16(sp)
    80013d64:	6105                	addi	sp,sp,32
    80013d66:	8082                	ret

0000000080013d68 <mutex_trylock>:
#include <config.h>
#include <lock.h>
#include <compiler.h>

bool mutex_trylock(Mutex *mutex)
{
    80013d68:	7179                	addi	sp,sp,-48
    80013d6a:	f422                	sd	s0,40(sp)
    80013d6c:	1800                	addi	s0,sp,48
    80013d6e:	fca43c23          	sd	a0,-40(s0)
    int old;
    asm volatile("amoswap.w.aq %0, %1, (%2)" : "=r"(old) : "r"(MUTEX_LOCKED), "r"(mutex));
    80013d72:	4785                	li	a5,1
    80013d74:	fd843703          	ld	a4,-40(s0)
    80013d78:	0cf727af          	amoswap.w.aq	a5,a5,(a4)
    80013d7c:	fef42623          	sw	a5,-20(s0)
    // If old == MUTEX_LOCKED, that means the mutex was already
    // locked when we tried to lock it. That means we didn't acquire
    // it.
    return old != MUTEX_LOCKED;
    80013d80:	fec42783          	lw	a5,-20(s0)
    80013d84:	0007871b          	sext.w	a4,a5
    80013d88:	4785                	li	a5,1
    80013d8a:	40f707b3          	sub	a5,a4,a5
    80013d8e:	00f037b3          	snez	a5,a5
    80013d92:	0ff7f793          	andi	a5,a5,255
}
    80013d96:	853e                	mv	a0,a5
    80013d98:	7422                	ld	s0,40(sp)
    80013d9a:	6145                	addi	sp,sp,48
    80013d9c:	8082                	ret

0000000080013d9e <mutex_spinlock>:

void mutex_spinlock(Mutex *mutex)
{
    80013d9e:	1101                	addi	sp,sp,-32
    80013da0:	ec06                	sd	ra,24(sp)
    80013da2:	e822                	sd	s0,16(sp)
    80013da4:	1000                	addi	s0,sp,32
    80013da6:	fea43423          	sd	a0,-24(s0)
    while (!mutex_trylock(mutex))
    80013daa:	0001                	nop
    80013dac:	fe843503          	ld	a0,-24(s0)
    80013db0:	fb9ff0ef          	jal	ra,80013d68 <mutex_trylock>
    80013db4:	87aa                	mv	a5,a0
    80013db6:	0017c793          	xori	a5,a5,1
    80013dba:	0ff7f793          	andi	a5,a5,255
    80013dbe:	f7fd                	bnez	a5,80013dac <mutex_spinlock+0xe>
        ;
}
    80013dc0:	0001                	nop
    80013dc2:	0001                	nop
    80013dc4:	60e2                	ld	ra,24(sp)
    80013dc6:	6442                	ld	s0,16(sp)
    80013dc8:	6105                	addi	sp,sp,32
    80013dca:	8082                	ret

0000000080013dcc <mutex_unlock>:

void mutex_unlock(Mutex *mutex)
{
    80013dcc:	1101                	addi	sp,sp,-32
    80013dce:	ec22                	sd	s0,24(sp)
    80013dd0:	1000                	addi	s0,sp,32
    80013dd2:	fea43423          	sd	a0,-24(s0)
    asm volatile("amoswap.w.rl zero, zero, (%0)" : : "r"(mutex));
    80013dd6:	fe843783          	ld	a5,-24(s0)
    80013dda:	0a07a02f          	amoswap.w.rl	zero,zero,(a5)
}
    80013dde:	0001                	nop
    80013de0:	6462                	ld	s0,24(sp)
    80013de2:	6105                	addi	sp,sp,32
    80013de4:	8082                	ret

0000000080013de6 <debug_dir_entry>:
// static VirtioDevice *block_device;
static VirtioDevice *loaded_block_device;
static uint8_t *inode_bitmap;
static uint8_t *zone_bitmap;

void debug_dir_entry(DirEntry entry) {
    80013de6:	1101                	addi	sp,sp,-32
    80013de8:	ec22                	sd	s0,24(sp)
    80013dea:	1000                	addi	s0,sp,32
    debugf("Entry: %u `", entry.inode);
    for (uint8_t i=0; i<60; i++) {
    80013dec:	fe0407a3          	sb	zero,-17(s0)
    80013df0:	a031                	j	80013dfc <debug_dir_entry+0x16>
    80013df2:	fef44783          	lbu	a5,-17(s0)
    80013df6:	2785                	addiw	a5,a5,1
    80013df8:	fef407a3          	sb	a5,-17(s0)
    80013dfc:	fef44783          	lbu	a5,-17(s0)
    80013e00:	0ff7f713          	andi	a4,a5,255
    80013e04:	03b00793          	li	a5,59
    80013e08:	fee7f5e3          	bgeu	a5,a4,80013df2 <debug_dir_entry+0xc>
        #endif
    }
    #ifdef minix3_DEBUG
    infof("`\n");
    #endif
}
    80013e0c:	0001                	nop
    80013e0e:	0001                	nop
    80013e10:	6462                	ld	s0,24(sp)
    80013e12:	6105                	addi	sp,sp,32
    80013e14:	8082                	ret

0000000080013e16 <minix3_get_inode_from_path>:

// Return the inode number from path.
// If get_parent is true, return the inode number of the parent.
// If given path /dir0/dir1file, return inode of /dir0/dir1/
uint32_t minix3_get_inode_from_path(VirtioDevice *block_device, const char *path, bool get_parent) {
    80013e16:	711d                	addi	sp,sp,-96
    80013e18:	ec86                	sd	ra,88(sp)
    80013e1a:	e8a2                	sd	s0,80(sp)
    80013e1c:	1080                	addi	s0,sp,96
    80013e1e:	faa43c23          	sd	a0,-72(s0)
    80013e22:	fab43823          	sd	a1,-80(s0)
    80013e26:	87b2                	mv	a5,a2
    80013e28:	faf407a3          	sb	a5,-81(s0)
    // TODO: Add support for relative path.
    debugf("Getting inode from path %s\n", path);
    List *path_items = path_split(path);
    80013e2c:	fb043503          	ld	a0,-80(s0)
    80013e30:	2400b0ef          	jal	ra,8001f070 <path_split>
    80013e34:	fca43c23          	sd	a0,-40(s0)

    uint32_t parent = 1; // Root inode
    80013e38:	4785                	li	a5,1
    80013e3a:	fef42623          	sw	a5,-20(s0)

    uint32_t i = 0, num_items = list_size(path_items);
    80013e3e:	fe042423          	sw	zero,-24(s0)
    80013e42:	fd843503          	ld	a0,-40(s0)
    80013e46:	4080a0ef          	jal	ra,8001e24e <list_size>
    80013e4a:	87aa                	mv	a5,a0
    80013e4c:	fcf42a23          	sw	a5,-44(s0)
    ListElem *elem;
    list_for_each(path_items, elem) {
    80013e50:	fd843503          	ld	a0,-40(s0)
    80013e54:	5320a0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    80013e58:	fea43023          	sd	a0,-32(s0)
    80013e5c:	a861                	j	80013ef4 <minix3_get_inode_from_path+0xde>

        char *name = (char *)list_elem_value(elem);
    80013e5e:	fe043503          	ld	a0,-32(s0)
    80013e62:	5840a0ef          	jal	ra,8001e3e6 <list_elem_value>
    80013e66:	87aa                	mv	a5,a0
    80013e68:	fcf43423          	sd	a5,-56(s0)
        debugf("Getting inode from relative path %s, num_items = %u\n", name, num_items);
        if (strcmp(name, "/") == 0 || strcmp(name, "") == 0) {
    80013e6c:	00010597          	auipc	a1,0x10
    80013e70:	75458593          	addi	a1,a1,1876 # 800245c0 <pow10.0+0x390>
    80013e74:	fc843503          	ld	a0,-56(s0)
    80013e78:	3840c0ef          	jal	ra,800201fc <strcmp>
    80013e7c:	87aa                	mv	a5,a0
    80013e7e:	cb99                	beqz	a5,80013e94 <minix3_get_inode_from_path+0x7e>
    80013e80:	00010597          	auipc	a1,0x10
    80013e84:	74858593          	addi	a1,a1,1864 # 800245c8 <pow10.0+0x398>
    80013e88:	fc843503          	ld	a0,-56(s0)
    80013e8c:	3700c0ef          	jal	ra,800201fc <strcmp>
    80013e90:	87aa                	mv	a5,a0
    80013e92:	e781                	bnez	a5,80013e9a <minix3_get_inode_from_path+0x84>
            return parent;
    80013e94:	fec42783          	lw	a5,-20(s0)
    80013e98:	a885                	j	80013f08 <minix3_get_inode_from_path+0xf2>
        }
        debugf("i = %u, num_items = %u\n", i, num_items);
        if (get_parent && i == num_items - 1) {
    80013e9a:	faf44783          	lbu	a5,-81(s0)
    80013e9e:	0ff7f793          	andi	a5,a5,255
    80013ea2:	cf91                	beqz	a5,80013ebe <minix3_get_inode_from_path+0xa8>
    80013ea4:	fd442783          	lw	a5,-44(s0)
    80013ea8:	37fd                	addiw	a5,a5,-1
    80013eaa:	0007871b          	sext.w	a4,a5
    80013eae:	fe842783          	lw	a5,-24(s0)
    80013eb2:	2781                	sext.w	a5,a5
    80013eb4:	00e79563          	bne	a5,a4,80013ebe <minix3_get_inode_from_path+0xa8>
            debugf("Returning parent inode %u\n", parent);
            return parent;
    80013eb8:	fec42783          	lw	a5,-20(s0)
    80013ebc:	a0b1                	j	80013f08 <minix3_get_inode_from_path+0xf2>
        }
        uint32_t child = minix3_find_dir_entry(block_device, parent, name);
    80013ebe:	fec42783          	lw	a5,-20(s0)
    80013ec2:	fc843603          	ld	a2,-56(s0)
    80013ec6:	85be                	mv	a1,a5
    80013ec8:	fb843503          	ld	a0,-72(s0)
    80013ecc:	3cc030ef          	jal	ra,80017298 <minix3_find_dir_entry>
    80013ed0:	87aa                	mv	a5,a0
    80013ed2:	fcf42223          	sw	a5,-60(s0)
        parent = child;
    80013ed6:	fc442783          	lw	a5,-60(s0)
    80013eda:	fef42623          	sw	a5,-20(s0)
        debugf("Got child %u\n", child);
        i++;
    80013ede:	fe842783          	lw	a5,-24(s0)
    80013ee2:	2785                	addiw	a5,a5,1
    80013ee4:	fef42423          	sw	a5,-24(s0)
    list_for_each(path_items, elem) {
    80013ee8:	fe043503          	ld	a0,-32(s0)
    80013eec:	4e20a0ef          	jal	ra,8001e3ce <list_elem_prev>
    80013ef0:	fea43023          	sd	a0,-32(s0)
    80013ef4:	fe043583          	ld	a1,-32(s0)
    80013ef8:	fd843503          	ld	a0,-40(s0)
    80013efc:	3fc0a0ef          	jal	ra,8001e2f8 <list_elem_valid>
    80013f00:	87aa                	mv	a5,a0
    80013f02:	ffb1                	bnez	a5,80013e5e <minix3_get_inode_from_path+0x48>
    }

    return parent;
    80013f04:	fec42783          	lw	a5,-20(s0)
}
    80013f08:	853e                	mv	a0,a5
    80013f0a:	60e6                	ld	ra,88(sp)
    80013f0c:	6446                	ld	s0,80(sp)
    80013f0e:	6125                	addi	sp,sp,96
    80013f10:	8082                	ret

0000000080013f12 <minix3_get_min_inode>:

uint32_t minix3_get_min_inode(VirtioDevice *block_device) {
    80013f12:	1101                	addi	sp,sp,-32
    80013f14:	ec22                	sd	s0,24(sp)
    80013f16:	1000                	addi	s0,sp,32
    80013f18:	fea43423          	sd	a0,-24(s0)
    return 1;
    80013f1c:	4785                	li	a5,1
}
    80013f1e:	853e                	mv	a0,a5
    80013f20:	6462                	ld	s0,24(sp)
    80013f22:	6105                	addi	sp,sp,32
    80013f24:	8082                	ret

0000000080013f26 <minix3_get_max_inode>:

uint32_t minix3_get_max_inode(VirtioDevice *block_device) {
    80013f26:	715d                	addi	sp,sp,-80
    80013f28:	e486                	sd	ra,72(sp)
    80013f2a:	e0a2                	sd	s0,64(sp)
    80013f2c:	fc26                	sd	s1,56(sp)
    80013f2e:	0880                	addi	s0,sp,80
    80013f30:	faa43c23          	sd	a0,-72(s0)
    return minix3_get_block_size(block_device) * minix3_get_superblock(block_device).imap_blocks * 8;
    80013f34:	fb843503          	ld	a0,-72(s0)
    80013f38:	7ee000ef          	jal	ra,80014726 <minix3_get_block_size>
    80013f3c:	87aa                	mv	a5,a0
    80013f3e:	0007849b          	sext.w	s1,a5
    80013f42:	fc040793          	addi	a5,s0,-64
    80013f46:	fb843583          	ld	a1,-72(s0)
    80013f4a:	853e                	mv	a0,a5
    80013f4c:	72a000ef          	jal	ra,80014676 <minix3_get_superblock>
    80013f50:	fc645783          	lhu	a5,-58(s0)
    80013f54:	2781                	sext.w	a5,a5
    80013f56:	02f487bb          	mulw	a5,s1,a5
    80013f5a:	2781                	sext.w	a5,a5
    80013f5c:	0037979b          	slliw	a5,a5,0x3
    80013f60:	2781                	sext.w	a5,a5
    80013f62:	2781                	sext.w	a5,a5
}
    80013f64:	853e                	mv	a0,a5
    80013f66:	60a6                	ld	ra,72(sp)
    80013f68:	6406                	ld	s0,64(sp)
    80013f6a:	74e2                	ld	s1,56(sp)
    80013f6c:	6161                	addi	sp,sp,80
    80013f6e:	8082                	ret

0000000080013f70 <minix3_get_inode_byte_offset>:

uintptr_t minix3_get_inode_byte_offset(VirtioDevice *block_device, SuperBlock sb, uint32_t inode) {
    80013f70:	7179                	addi	sp,sp,-48
    80013f72:	f406                	sd	ra,40(sp)
    80013f74:	f022                	sd	s0,32(sp)
    80013f76:	ec26                	sd	s1,24(sp)
    80013f78:	1800                	addi	s0,sp,48
    80013f7a:	fca43c23          	sd	a0,-40(s0)
    80013f7e:	80ae                	mv	ra,a1
    80013f80:	87b2                	mv	a5,a2
    80013f82:	fcf42a23          	sw	a5,-44(s0)
    if (inode == INVALID_INODE) {
    80013f86:	fd442783          	lw	a5,-44(s0)
    80013f8a:	2781                	sext.w	a5,a5
    80013f8c:	ef81                	bnez	a5,80013fa4 <minix3_get_inode_byte_offset+0x34>
        fatalf("Invalid inode %u\n", inode);
    80013f8e:	fd442783          	lw	a5,-44(s0)
    80013f92:	85be                	mv	a1,a5
    80013f94:	00010517          	auipc	a0,0x10
    80013f98:	63c50513          	addi	a0,a0,1596 # 800245d0 <pow10.0+0x3a0>
    80013f9c:	368050ef          	jal	ra,80019304 <fatalf>
        return 0;
    80013fa0:	4781                	li	a5,0
    80013fa2:	a83d                	j	80013fe0 <minix3_get_inode_byte_offset+0x70>
    }
    return (FS_IMAP_IDX + sb.imap_blocks + sb.zmap_blocks) * minix3_get_block_size(block_device) + (inode - 1) * sizeof(Inode);
    80013fa4:	0060d783          	lhu	a5,6(ra)
    80013fa8:	2781                	sext.w	a5,a5
    80013faa:	2789                	addiw	a5,a5,2
    80013fac:	0007871b          	sext.w	a4,a5
    80013fb0:	0080d783          	lhu	a5,8(ra)
    80013fb4:	2781                	sext.w	a5,a5
    80013fb6:	9fb9                	addw	a5,a5,a4
    80013fb8:	0007849b          	sext.w	s1,a5
    80013fbc:	fd843503          	ld	a0,-40(s0)
    80013fc0:	766000ef          	jal	ra,80014726 <minix3_get_block_size>
    80013fc4:	87aa                	mv	a5,a0
    80013fc6:	2781                	sext.w	a5,a5
    80013fc8:	02f487bb          	mulw	a5,s1,a5
    80013fcc:	2781                	sext.w	a5,a5
    80013fce:	873e                	mv	a4,a5
    80013fd0:	fd442783          	lw	a5,-44(s0)
    80013fd4:	37fd                	addiw	a5,a5,-1
    80013fd6:	2781                	sext.w	a5,a5
    80013fd8:	1782                	slli	a5,a5,0x20
    80013fda:	9381                	srli	a5,a5,0x20
    80013fdc:	079a                	slli	a5,a5,0x6
    80013fde:	97ba                	add	a5,a5,a4
}
    80013fe0:	853e                	mv	a0,a5
    80013fe2:	70a2                	ld	ra,40(sp)
    80013fe4:	7402                	ld	s0,32(sp)
    80013fe6:	64e2                	ld	s1,24(sp)
    80013fe8:	6145                	addi	sp,sp,48
    80013fea:	8082                	ret

0000000080013fec <minix3_superblock_init>:
// uintptr_t minix3_get_inode_bitmap_byte_offset(SuperBlock sb, uint32_t inode) {
//     return FS_IMAP_IDX * minix3_get_block_size(block_device) + inode / 8;
// }


void minix3_superblock_init(VirtioDevice *block_device) {
    80013fec:	7119                	addi	sp,sp,-128
    80013fee:	fc86                	sd	ra,120(sp)
    80013ff0:	f8a2                	sd	s0,112(sp)
    80013ff2:	0100                	addi	s0,sp,128
    80013ff4:	faa43423          	sd	a0,-88(s0)
    // uint64_t sector_size = block_device_get_sector_size();
    // Initialize the superblock
    // uint64_t num_sectors = block_device_get_sector_count();
    uint64_t device_bytes = block_device_get_bytes(block_device);
    80013ff8:	fa843503          	ld	a0,-88(s0)
    80013ffc:	2c2080ef          	jal	ra,8001c2be <block_device_get_bytes>
    80014000:	fea43423          	sd	a0,-24(s0)
    uint64_t bytes_per_block = 1024;
    80014004:	40000793          	li	a5,1024
    80014008:	fef43023          	sd	a5,-32(s0)
    uint64_t num_blocks = device_bytes / bytes_per_block / 2;
    8001400c:	fe843703          	ld	a4,-24(s0)
    80014010:	fe043783          	ld	a5,-32(s0)
    80014014:	02f757b3          	divu	a5,a4,a5
    80014018:	8385                	srli	a5,a5,0x1
    8001401a:	fcf43c23          	sd	a5,-40(s0)
    SuperBlock superblock;
    superblock.magic = 0x4d5a;
    8001401e:	6795                	lui	a5,0x5
    80014020:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    80014024:	fcf41823          	sh	a5,-48(s0)
    superblock.log_zone_size = 0;
    80014028:	fc041223          	sh	zero,-60(s0)
    superblock.max_size = num_blocks * bytes_per_block;
    8001402c:	fd843783          	ld	a5,-40(s0)
    80014030:	0007871b          	sext.w	a4,a5
    80014034:	fe043783          	ld	a5,-32(s0)
    80014038:	2781                	sext.w	a5,a5
    8001403a:	02f707bb          	mulw	a5,a4,a5
    8001403e:	2781                	sext.w	a5,a5
    80014040:	fcf42423          	sw	a5,-56(s0)
    superblock.num_zones = num_blocks;
    80014044:	fd843783          	ld	a5,-40(s0)
    80014048:	2781                	sext.w	a5,a5
    8001404a:	fcf42623          	sw	a5,-52(s0)
    superblock.block_size = bytes_per_block;
    8001404e:	fe043783          	ld	a5,-32(s0)
    80014052:	17c2                	slli	a5,a5,0x30
    80014054:	93c1                	srli	a5,a5,0x30
    80014056:	fcf41a23          	sh	a5,-44(s0)
    superblock.disk_version = 0;
    8001405a:	fc040b23          	sb	zero,-42(s0)
    superblock.num_inodes = num_blocks / 8;
    8001405e:	fd843783          	ld	a5,-40(s0)
    80014062:	838d                	srli	a5,a5,0x3
    80014064:	2781                	sext.w	a5,a5
    80014066:	faf42c23          	sw	a5,-72(s0)
    superblock.imap_blocks = superblock.num_inodes / (bytes_per_block * 8);
    8001406a:	fb842783          	lw	a5,-72(s0)
    8001406e:	02079713          	slli	a4,a5,0x20
    80014072:	9301                	srli	a4,a4,0x20
    80014074:	fe043783          	ld	a5,-32(s0)
    80014078:	078e                	slli	a5,a5,0x3
    8001407a:	02f757b3          	divu	a5,a4,a5
    8001407e:	17c2                	slli	a5,a5,0x30
    80014080:	93c1                	srli	a5,a5,0x30
    80014082:	faf41f23          	sh	a5,-66(s0)
    superblock.zmap_blocks = superblock.num_zones / (bytes_per_block * 8);
    80014086:	fcc42783          	lw	a5,-52(s0)
    8001408a:	02079713          	slli	a4,a5,0x20
    8001408e:	9301                	srli	a4,a4,0x20
    80014090:	fe043783          	ld	a5,-32(s0)
    80014094:	078e                	slli	a5,a5,0x3
    80014096:	02f757b3          	divu	a5,a4,a5
    8001409a:	17c2                	slli	a5,a5,0x30
    8001409c:	93c1                	srli	a5,a5,0x30
    8001409e:	fcf41023          	sh	a5,-64(s0)
    superblock.first_data_zone = 0;
    800140a2:	fc041123          	sh	zero,-62(s0)
    minix3_put_superblock(block_device, superblock);
    800140a6:	fb843603          	ld	a2,-72(s0)
    800140aa:	fc043683          	ld	a3,-64(s0)
    800140ae:	fc843703          	ld	a4,-56(s0)
    800140b2:	fd043783          	ld	a5,-48(s0)
    800140b6:	f8c43023          	sd	a2,-128(s0)
    800140ba:	f8d43423          	sd	a3,-120(s0)
    800140be:	f8e43823          	sd	a4,-112(s0)
    800140c2:	f8f43c23          	sd	a5,-104(s0)
    800140c6:	f8040793          	addi	a5,s0,-128
    800140ca:	85be                	mv	a1,a5
    800140cc:	fa843503          	ld	a0,-88(s0)
    800140d0:	62c000ef          	jal	ra,800146fc <minix3_put_superblock>
}
    800140d4:	0001                	nop
    800140d6:	70e6                	ld	ra,120(sp)
    800140d8:	7446                	ld	s0,112(sp)
    800140da:	6109                	addi	sp,sp,128
    800140dc:	8082                	ret

00000000800140de <minix3_has_zone>:

bool minix3_has_zone(VirtioDevice *block_device, uint32_t zone) {
    800140de:	1101                	addi	sp,sp,-32
    800140e0:	ec22                	sd	s0,24(sp)
    800140e2:	1000                	addi	s0,sp,32
    800140e4:	fea43423          	sd	a0,-24(s0)
    800140e8:	87ae                	mv	a5,a1
    800140ea:	fef42223          	sw	a5,-28(s0)
    return inode_bitmap[zone / 8] & (1 << zone % 8);
    800140ee:	0000f797          	auipc	a5,0xf
    800140f2:	fca78793          	addi	a5,a5,-54 # 800230b8 <inode_bitmap>
    800140f6:	6398                	ld	a4,0(a5)
    800140f8:	fe442783          	lw	a5,-28(s0)
    800140fc:	0037d79b          	srliw	a5,a5,0x3
    80014100:	2781                	sext.w	a5,a5
    80014102:	1782                	slli	a5,a5,0x20
    80014104:	9381                	srli	a5,a5,0x20
    80014106:	97ba                	add	a5,a5,a4
    80014108:	0007c783          	lbu	a5,0(a5)
    8001410c:	0007871b          	sext.w	a4,a5
    80014110:	fe442783          	lw	a5,-28(s0)
    80014114:	8b9d                	andi	a5,a5,7
    80014116:	2781                	sext.w	a5,a5
    80014118:	4685                	li	a3,1
    8001411a:	00f697bb          	sllw	a5,a3,a5
    8001411e:	2781                	sext.w	a5,a5
    80014120:	8ff9                	and	a5,a5,a4
    80014122:	2781                	sext.w	a5,a5
    80014124:	00f037b3          	snez	a5,a5
    80014128:	0ff7f793          	andi	a5,a5,255
}
    8001412c:	853e                	mv	a0,a5
    8001412e:	6462                	ld	s0,24(sp)
    80014130:	6105                	addi	sp,sp,32
    80014132:	8082                	ret

0000000080014134 <minix3_take_zone>:

bool minix3_take_zone(VirtioDevice *block_device, uint32_t zone) {
    80014134:	1101                	addi	sp,sp,-32
    80014136:	ec06                	sd	ra,24(sp)
    80014138:	e822                	sd	s0,16(sp)
    8001413a:	1000                	addi	s0,sp,32
    8001413c:	fea43423          	sd	a0,-24(s0)
    80014140:	87ae                	mv	a5,a1
    80014142:	fef42223          	sw	a5,-28(s0)
    minix3_load_device(block_device);
    80014146:	fe843503          	ld	a0,-24(s0)
    8001414a:	7f8000ef          	jal	ra,80014942 <minix3_load_device>
    if (minix3_has_zone(block_device, zone)) {
    8001414e:	fe442783          	lw	a5,-28(s0)
    80014152:	85be                	mv	a1,a5
    80014154:	fe843503          	ld	a0,-24(s0)
    80014158:	f87ff0ef          	jal	ra,800140de <minix3_has_zone>
    8001415c:	87aa                	mv	a5,a0
    8001415e:	cf81                	beqz	a5,80014176 <minix3_take_zone+0x42>
        warnf("minix3_take_zone: zone %u is already taken\n", zone);
    80014160:	fe442783          	lw	a5,-28(s0)
    80014164:	85be                	mv	a1,a5
    80014166:	00010517          	auipc	a0,0x10
    8001416a:	48250513          	addi	a0,a0,1154 # 800245e8 <pow10.0+0x3b8>
    8001416e:	092050ef          	jal	ra,80019200 <warnf>
        return false;
    80014172:	4781                	li	a5,0
    80014174:	a8bd                	j	800141f2 <minix3_take_zone+0xbe>
    }

    zone_bitmap[zone / 8] |= (1 << zone % 8);
    80014176:	0000f797          	auipc	a5,0xf
    8001417a:	f4a78793          	addi	a5,a5,-182 # 800230c0 <zone_bitmap>
    8001417e:	6398                	ld	a4,0(a5)
    80014180:	fe442783          	lw	a5,-28(s0)
    80014184:	0037d79b          	srliw	a5,a5,0x3
    80014188:	0007861b          	sext.w	a2,a5
    8001418c:	02061793          	slli	a5,a2,0x20
    80014190:	9381                	srli	a5,a5,0x20
    80014192:	97ba                	add	a5,a5,a4
    80014194:	0007c783          	lbu	a5,0(a5)
    80014198:	0187971b          	slliw	a4,a5,0x18
    8001419c:	4187571b          	sraiw	a4,a4,0x18
    800141a0:	fe442783          	lw	a5,-28(s0)
    800141a4:	8b9d                	andi	a5,a5,7
    800141a6:	2781                	sext.w	a5,a5
    800141a8:	4685                	li	a3,1
    800141aa:	00f697bb          	sllw	a5,a3,a5
    800141ae:	2781                	sext.w	a5,a5
    800141b0:	0187979b          	slliw	a5,a5,0x18
    800141b4:	4187d79b          	sraiw	a5,a5,0x18
    800141b8:	8fd9                	or	a5,a5,a4
    800141ba:	0187969b          	slliw	a3,a5,0x18
    800141be:	4186d69b          	sraiw	a3,a3,0x18
    800141c2:	0000f797          	auipc	a5,0xf
    800141c6:	efe78793          	addi	a5,a5,-258 # 800230c0 <zone_bitmap>
    800141ca:	6398                	ld	a4,0(a5)
    800141cc:	02061793          	slli	a5,a2,0x20
    800141d0:	9381                	srli	a5,a5,0x20
    800141d2:	97ba                	add	a5,a5,a4
    800141d4:	0ff6f713          	andi	a4,a3,255
    800141d8:	00e78023          	sb	a4,0(a5)
    minix3_put_zone_bitmap(block_device, zone_bitmap);
    800141dc:	0000f797          	auipc	a5,0xf
    800141e0:	ee478793          	addi	a5,a5,-284 # 800230c0 <zone_bitmap>
    800141e4:	639c                	ld	a5,0(a5)
    800141e6:	85be                	mv	a1,a5
    800141e8:	fe843503          	ld	a0,-24(s0)
    800141ec:	70e000ef          	jal	ra,800148fa <minix3_put_zone_bitmap>
    // Inode inode_data = minix3_get_zone(block_device, zone);
    // inode_data.num_links = 1;
    // minix3_put_inode(block_device, inode, inode_data);

    return true;
    800141f0:	4785                	li	a5,1
}
    800141f2:	853e                	mv	a0,a5
    800141f4:	60e2                	ld	ra,24(sp)
    800141f6:	6442                	ld	s0,16(sp)
    800141f8:	6105                	addi	sp,sp,32
    800141fa:	8082                	ret

00000000800141fc <minix3_get_next_free_zone>:

uint32_t minix3_get_next_free_zone(VirtioDevice *block_device) {
    800141fc:	7139                	addi	sp,sp,-64
    800141fe:	fc06                	sd	ra,56(sp)
    80014200:	f822                	sd	s0,48(sp)
    80014202:	0080                	addi	s0,sp,64
    80014204:	fca43423          	sd	a0,-56(s0)
    size_t zone_bitmap_size = minix3_get_zone_size(block_device);
    80014208:	fc843503          	ld	a0,-56(s0)
    8001420c:	552000ef          	jal	ra,8001475e <minix3_get_zone_size>
    80014210:	87aa                	mv	a5,a0
    80014212:	fef43023          	sd	a5,-32(s0)
    for (int i = 0; i < zone_bitmap_size; i++) {
    80014216:	fe042623          	sw	zero,-20(s0)
    8001421a:	a8bd                	j	80014298 <minix3_get_next_free_zone+0x9c>
        if (zone_bitmap[i] != 0xFF) {
    8001421c:	0000f797          	auipc	a5,0xf
    80014220:	ea478793          	addi	a5,a5,-348 # 800230c0 <zone_bitmap>
    80014224:	6398                	ld	a4,0(a5)
    80014226:	fec42783          	lw	a5,-20(s0)
    8001422a:	97ba                	add	a5,a5,a4
    8001422c:	0007c783          	lbu	a5,0(a5)
    80014230:	873e                	mv	a4,a5
    80014232:	0ff00793          	li	a5,255
    80014236:	04f70c63          	beq	a4,a5,8001428e <minix3_get_next_free_zone+0x92>
            for (int j = 0; j < 8; j++) {
    8001423a:	fe042423          	sw	zero,-24(s0)
    8001423e:	a089                	j	80014280 <minix3_get_next_free_zone+0x84>
                uint32_t zone = 8 * i + j;
    80014240:	fec42783          	lw	a5,-20(s0)
    80014244:	0037979b          	slliw	a5,a5,0x3
    80014248:	2781                	sext.w	a5,a5
    8001424a:	fe842703          	lw	a4,-24(s0)
    8001424e:	9fb9                	addw	a5,a5,a4
    80014250:	2781                	sext.w	a5,a5
    80014252:	fcf42e23          	sw	a5,-36(s0)
                if (!minix3_has_zone(block_device, zone))
    80014256:	fdc42783          	lw	a5,-36(s0)
    8001425a:	85be                	mv	a1,a5
    8001425c:	fc843503          	ld	a0,-56(s0)
    80014260:	e7fff0ef          	jal	ra,800140de <minix3_has_zone>
    80014264:	87aa                	mv	a5,a0
    80014266:	0017c793          	xori	a5,a5,1
    8001426a:	0ff7f793          	andi	a5,a5,255
    8001426e:	c781                	beqz	a5,80014276 <minix3_get_next_free_zone+0x7a>
                    return zone;
    80014270:	fdc42783          	lw	a5,-36(s0)
    80014274:	a83d                	j	800142b2 <minix3_get_next_free_zone+0xb6>
            for (int j = 0; j < 8; j++) {
    80014276:	fe842783          	lw	a5,-24(s0)
    8001427a:	2785                	addiw	a5,a5,1
    8001427c:	fef42423          	sw	a5,-24(s0)
    80014280:	fe842783          	lw	a5,-24(s0)
    80014284:	0007871b          	sext.w	a4,a5
    80014288:	479d                	li	a5,7
    8001428a:	fae7dbe3          	bge	a5,a4,80014240 <minix3_get_next_free_zone+0x44>
    for (int i = 0; i < zone_bitmap_size; i++) {
    8001428e:	fec42783          	lw	a5,-20(s0)
    80014292:	2785                	addiw	a5,a5,1
    80014294:	fef42623          	sw	a5,-20(s0)
    80014298:	fec42783          	lw	a5,-20(s0)
    8001429c:	fe043703          	ld	a4,-32(s0)
    800142a0:	f6e7eee3          	bltu	a5,a4,8001421c <minix3_get_next_free_zone+0x20>
            }
        }
    }
    warnf("minix3_get_next_free_zone: Couldn't find free zone\n");
    800142a4:	00010517          	auipc	a0,0x10
    800142a8:	37450513          	addi	a0,a0,884 # 80024618 <pow10.0+0x3e8>
    800142ac:	755040ef          	jal	ra,80019200 <warnf>
    return 0;
    800142b0:	4781                	li	a5,0
}
    800142b2:	853e                	mv	a0,a5
    800142b4:	70e2                	ld	ra,56(sp)
    800142b6:	7442                	ld	s0,48(sp)
    800142b8:	6121                	addi	sp,sp,64
    800142ba:	8082                	ret

00000000800142bc <minix3_get_zone>:

void minix3_get_zone(VirtioDevice *block_device, uint32_t zone, uint8_t *data) {
    800142bc:	715d                	addi	sp,sp,-80
    800142be:	e486                	sd	ra,72(sp)
    800142c0:	e0a2                	sd	s0,64(sp)
    800142c2:	0880                	addi	s0,sp,80
    800142c4:	fca43423          	sd	a0,-56(s0)
    800142c8:	87ae                	mv	a5,a1
    800142ca:	fac43c23          	sd	a2,-72(s0)
    800142ce:	fcf42223          	sw	a5,-60(s0)
    SuperBlock sb = minix3_get_superblock(block_device);
    800142d2:	fd040793          	addi	a5,s0,-48
    800142d6:	fc843583          	ld	a1,-56(s0)
    800142da:	853e                	mv	a0,a5
    800142dc:	39a000ef          	jal	ra,80014676 <minix3_get_superblock>
    if (zone > sb.num_zones + sb.first_data_zone) {
    800142e0:	fe442703          	lw	a4,-28(s0)
    800142e4:	fda45783          	lhu	a5,-38(s0)
    800142e8:	2781                	sext.w	a5,a5
    800142ea:	9fb9                	addw	a5,a5,a4
    800142ec:	0007871b          	sext.w	a4,a5
    800142f0:	fc442783          	lw	a5,-60(s0)
    800142f4:	2781                	sext.w	a5,a5
    800142f6:	00f77f63          	bgeu	a4,a5,80014314 <minix3_get_zone+0x58>
        warnf("Zone %u (%x) is out of bounds\n", zone, zone);
    800142fa:	fc442703          	lw	a4,-60(s0)
    800142fe:	fc442783          	lw	a5,-60(s0)
    80014302:	863a                	mv	a2,a4
    80014304:	85be                	mv	a1,a5
    80014306:	00010517          	auipc	a0,0x10
    8001430a:	34a50513          	addi	a0,a0,842 # 80024650 <pow10.0+0x420>
    8001430e:	6f3040ef          	jal	ra,80019200 <warnf>
        return;
    80014312:	a0b9                	j	80014360 <minix3_get_zone+0xa4>
    }

    if (zone < sb.first_data_zone) {
    80014314:	fda45783          	lhu	a5,-38(s0)
    80014318:	0007871b          	sext.w	a4,a5
    8001431c:	fc442783          	lw	a5,-60(s0)
    80014320:	2781                	sext.w	a5,a5
    80014322:	02e7f663          	bgeu	a5,a4,8001434e <minix3_get_zone+0x92>
        warnf("Zone %u (%x) is before the first data zone %u (%x)\n", zone, zone, sb.first_data_zone, sb.first_data_zone);
    80014326:	fda45783          	lhu	a5,-38(s0)
    8001432a:	0007869b          	sext.w	a3,a5
    8001432e:	fda45783          	lhu	a5,-38(s0)
    80014332:	0007871b          	sext.w	a4,a5
    80014336:	fc442603          	lw	a2,-60(s0)
    8001433a:	fc442783          	lw	a5,-60(s0)
    8001433e:	85be                	mv	a1,a5
    80014340:	00010517          	auipc	a0,0x10
    80014344:	33050513          	addi	a0,a0,816 # 80024670 <pow10.0+0x440>
    80014348:	6b9040ef          	jal	ra,80019200 <warnf>
        return;
    8001434c:	a811                	j	80014360 <minix3_get_zone+0xa4>
    }
    
    // minix3_get_block(minix3_get_superblock().first_data_zone + zone, data);
    minix3_get_block(block_device, zone, data);
    8001434e:	fc442783          	lw	a5,-60(s0)
    80014352:	fb843603          	ld	a2,-72(s0)
    80014356:	85be                	mv	a1,a5
    80014358:	fc843503          	ld	a0,-56(s0)
    8001435c:	7a4000ef          	jal	ra,80014b00 <minix3_get_block>
}
    80014360:	60a6                	ld	ra,72(sp)
    80014362:	6406                	ld	s0,64(sp)
    80014364:	6161                	addi	sp,sp,80
    80014366:	8082                	ret

0000000080014368 <minix3_put_zone>:
void minix3_put_zone(VirtioDevice *block_device, uint32_t zone, uint8_t *data) {
    80014368:	715d                	addi	sp,sp,-80
    8001436a:	e486                	sd	ra,72(sp)
    8001436c:	e0a2                	sd	s0,64(sp)
    8001436e:	0880                	addi	s0,sp,80
    80014370:	fca43423          	sd	a0,-56(s0)
    80014374:	87ae                	mv	a5,a1
    80014376:	fac43c23          	sd	a2,-72(s0)
    8001437a:	fcf42223          	sw	a5,-60(s0)
    SuperBlock sb = minix3_get_superblock(block_device);
    8001437e:	fd040793          	addi	a5,s0,-48
    80014382:	fc843583          	ld	a1,-56(s0)
    80014386:	853e                	mv	a0,a5
    80014388:	2ee000ef          	jal	ra,80014676 <minix3_get_superblock>
    if (zone > sb.num_zones + sb.first_data_zone) {
    8001438c:	fe442703          	lw	a4,-28(s0)
    80014390:	fda45783          	lhu	a5,-38(s0)
    80014394:	2781                	sext.w	a5,a5
    80014396:	9fb9                	addw	a5,a5,a4
    80014398:	0007871b          	sext.w	a4,a5
    8001439c:	fc442783          	lw	a5,-60(s0)
    800143a0:	2781                	sext.w	a5,a5
    800143a2:	00f77f63          	bgeu	a4,a5,800143c0 <minix3_put_zone+0x58>
        warnf("Zone %u (%x) is out of bounds\n", zone, zone);
    800143a6:	fc442703          	lw	a4,-60(s0)
    800143aa:	fc442783          	lw	a5,-60(s0)
    800143ae:	863a                	mv	a2,a4
    800143b0:	85be                	mv	a1,a5
    800143b2:	00010517          	auipc	a0,0x10
    800143b6:	29e50513          	addi	a0,a0,670 # 80024650 <pow10.0+0x420>
    800143ba:	647040ef          	jal	ra,80019200 <warnf>
        return;
    800143be:	a0b9                	j	8001440c <minix3_put_zone+0xa4>
    }

    if (zone < sb.first_data_zone) {
    800143c0:	fda45783          	lhu	a5,-38(s0)
    800143c4:	0007871b          	sext.w	a4,a5
    800143c8:	fc442783          	lw	a5,-60(s0)
    800143cc:	2781                	sext.w	a5,a5
    800143ce:	02e7f663          	bgeu	a5,a4,800143fa <minix3_put_zone+0x92>
        warnf("Zone %u (%x) is before the first data zone %u (%x)\n", zone, zone, sb.first_data_zone, sb.first_data_zone);
    800143d2:	fda45783          	lhu	a5,-38(s0)
    800143d6:	0007869b          	sext.w	a3,a5
    800143da:	fda45783          	lhu	a5,-38(s0)
    800143de:	0007871b          	sext.w	a4,a5
    800143e2:	fc442603          	lw	a2,-60(s0)
    800143e6:	fc442783          	lw	a5,-60(s0)
    800143ea:	85be                	mv	a1,a5
    800143ec:	00010517          	auipc	a0,0x10
    800143f0:	28450513          	addi	a0,a0,644 # 80024670 <pow10.0+0x440>
    800143f4:	60d040ef          	jal	ra,80019200 <warnf>
        return;
    800143f8:	a811                	j	8001440c <minix3_put_zone+0xa4>
    }

    minix3_put_block(block_device, zone, data);
    800143fa:	fc442783          	lw	a5,-60(s0)
    800143fe:	fb843603          	ld	a2,-72(s0)
    80014402:	85be                	mv	a1,a5
    80014404:	fc843503          	ld	a0,-56(s0)
    80014408:	72c000ef          	jal	ra,80014b34 <minix3_put_block>
}
    8001440c:	60a6                	ld	ra,72(sp)
    8001440e:	6406                	ld	s0,64(sp)
    80014410:	6161                	addi	sp,sp,80
    80014412:	8082                	ret

0000000080014414 <minix3_get_file_size>:

uint64_t minix3_get_file_size(VirtioDevice *block_device, uint32_t inode) {
    80014414:	711d                	addi	sp,sp,-96
    80014416:	ec86                	sd	ra,88(sp)
    80014418:	e8a2                	sd	s0,80(sp)
    8001441a:	1080                	addi	s0,sp,96
    8001441c:	faa43423          	sd	a0,-88(s0)
    80014420:	87ae                	mv	a5,a1
    80014422:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    80014426:	fb040793          	addi	a5,s0,-80
    8001442a:	fa442703          	lw	a4,-92(s0)
    8001442e:	863a                	mv	a2,a4
    80014430:	fa843583          	ld	a1,-88(s0)
    80014434:	853e                	mv	a0,a5
    80014436:	1a9000ef          	jal	ra,80014dde <minix3_get_inode>
    if (S_ISREG(inode_data.mode)) {
    8001443a:	fb045783          	lhu	a5,-80(s0)
    8001443e:	0007871b          	sext.w	a4,a5
    80014442:	67bd                	lui	a5,0xf
    80014444:	8ff9                	and	a5,a5,a4
    80014446:	2781                	sext.w	a5,a5
    80014448:	873e                	mv	a4,a5
    8001444a:	67a1                	lui	a5,0x8
    8001444c:	00f71763          	bne	a4,a5,8001445a <minix3_get_file_size+0x46>
        return inode_data.size;
    80014450:	fb842783          	lw	a5,-72(s0)
    80014454:	1782                	slli	a5,a5,0x20
    80014456:	9381                	srli	a5,a5,0x20
    80014458:	a0b1                	j	800144a4 <minix3_get_file_size+0x90>
    } else if (S_ISDIR(inode_data.mode)) {
    8001445a:	fb045783          	lhu	a5,-80(s0)
    8001445e:	0007871b          	sext.w	a4,a5
    80014462:	67bd                	lui	a5,0xf
    80014464:	8ff9                	and	a5,a5,a4
    80014466:	2781                	sext.w	a5,a5
    80014468:	873e                	mv	a4,a5
    8001446a:	6791                	lui	a5,0x4
    8001446c:	00f71463          	bne	a4,a5,80014474 <minix3_get_file_size+0x60>
        return 0;
    80014470:	4781                	li	a5,0
    80014472:	a80d                	j	800144a4 <minix3_get_file_size+0x90>
    } else if (S_ISBLK(inode_data.mode)) {
    80014474:	fb045783          	lhu	a5,-80(s0)
    80014478:	0007871b          	sext.w	a4,a5
    8001447c:	67bd                	lui	a5,0xf
    8001447e:	8ff9                	and	a5,a5,a4
    80014480:	2781                	sext.w	a5,a5
    80014482:	873e                	mv	a4,a5
    80014484:	6799                	lui	a5,0x6
    80014486:	00f71463          	bne	a4,a5,8001448e <minix3_get_file_size+0x7a>
        return 0;
    8001448a:	4781                	li	a5,0
    8001448c:	a821                	j	800144a4 <minix3_get_file_size+0x90>
    } else {
        fatalf("Unknown inode type %x\n", inode_data.mode);
    8001448e:	fb045783          	lhu	a5,-80(s0)
    80014492:	2781                	sext.w	a5,a5
    80014494:	85be                	mv	a1,a5
    80014496:	00010517          	auipc	a0,0x10
    8001449a:	21250513          	addi	a0,a0,530 # 800246a8 <pow10.0+0x478>
    8001449e:	667040ef          	jal	ra,80019304 <fatalf>
        return 0;
    800144a2:	4781                	li	a5,0
    }
}
    800144a4:	853e                	mv	a0,a5
    800144a6:	60e6                	ld	ra,88(sp)
    800144a8:	6446                	ld	s0,80(sp)
    800144aa:	6125                	addi	sp,sp,96
    800144ac:	8082                	ret

00000000800144ae <debug_inode>:

void debug_inode(VirtioDevice *block_device, uint32_t i) {
    800144ae:	7159                	addi	sp,sp,-112
    800144b0:	f486                	sd	ra,104(sp)
    800144b2:	f0a2                	sd	s0,96(sp)
    800144b4:	1880                	addi	s0,sp,112
    800144b6:	f8a43c23          	sd	a0,-104(s0)
    800144ba:	87ae                	mv	a5,a1
    800144bc:	f8f42a23          	sw	a5,-108(s0)
    Inode inode = minix3_get_inode(block_device, i);
    800144c0:	fa840793          	addi	a5,s0,-88
    800144c4:	f9442703          	lw	a4,-108(s0)
    800144c8:	863a                	mv	a2,a4
    800144ca:	f9843583          	ld	a1,-104(s0)
    800144ce:	853e                	mv	a0,a5
    800144d0:	10f000ef          	jal	ra,80014dde <minix3_get_inode>
    debugf("   size: %d\n", inode.size);
    debugf("   atime: %d\n", inode.atime);
    debugf("   mtime: %d\n", inode.mtime);
    debugf("   ctime: %d\n", inode.ctime);
    debugf("   zones[]:\n");
    for (uint8_t j=0; j<10; j++) {
    800144d4:	fe0407a3          	sb	zero,-17(s0)
    800144d8:	a031                	j	800144e4 <debug_inode+0x36>
    800144da:	fef44783          	lbu	a5,-17(s0)
    800144de:	2785                	addiw	a5,a5,1
    800144e0:	fef407a3          	sb	a5,-17(s0)
    800144e4:	fef44783          	lbu	a5,-17(s0)
    800144e8:	0ff7f713          	andi	a4,a5,255
    800144ec:	47a5                	li	a5,9
    800144ee:	fee7f6e3          	bgeu	a5,a4,800144da <debug_inode+0x2c>
        debugf("   zones[%d] = %x (*1024 = %x)\n", j, inode.zones[j], inode.zones[j] * 1024);
    }
}
    800144f2:	0001                	nop
    800144f4:	0001                	nop
    800144f6:	70a6                	ld	ra,104(sp)
    800144f8:	7406                	ld	s0,96(sp)
    800144fa:	6165                	addi	sp,sp,112
    800144fc:	8082                	ret

00000000800144fe <minix3_init_callback>:
    uint32_t file_count;
    uint32_t dir_count;
} CallbackData;

// A callback function for counting up the files and printing them out
void minix3_init_callback(VirtioDevice *block_device, uint32_t inode, const char *path, char *name, void *data, uint32_t depth) {
    800144fe:	715d                	addi	sp,sp,-80
    80014500:	e486                	sd	ra,72(sp)
    80014502:	e0a2                	sd	s0,64(sp)
    80014504:	0880                	addi	s0,sp,80
    80014506:	fca43c23          	sd	a0,-40(s0)
    8001450a:	fcc43423          	sd	a2,-56(s0)
    8001450e:	fcd43023          	sd	a3,-64(s0)
    80014512:	fae43c23          	sd	a4,-72(s0)
    80014516:	873e                	mv	a4,a5
    80014518:	87ae                	mv	a5,a1
    8001451a:	fcf42a23          	sw	a5,-44(s0)
    8001451e:	87ba                	mv	a5,a4
    80014520:	fcf42823          	sw	a5,-48(s0)
    CallbackData *cb_data = (CallbackData *)data;
    80014524:	fb843783          	ld	a5,-72(s0)
    80014528:	fef43023          	sd	a5,-32(s0)

    for (uint32_t i=0; i<depth; i++) {
    8001452c:	fe042623          	sw	zero,-20(s0)
    80014530:	a821                	j	80014548 <minix3_init_callback+0x4a>
        infof("   ");
    80014532:	00010517          	auipc	a0,0x10
    80014536:	18e50513          	addi	a0,a0,398 # 800246c0 <pow10.0+0x490>
    8001453a:	575040ef          	jal	ra,800192ae <infof>
    for (uint32_t i=0; i<depth; i++) {
    8001453e:	fec42783          	lw	a5,-20(s0)
    80014542:	2785                	addiw	a5,a5,1
    80014544:	fef42623          	sw	a5,-20(s0)
    80014548:	fec42703          	lw	a4,-20(s0)
    8001454c:	fd042783          	lw	a5,-48(s0)
    80014550:	2701                	sext.w	a4,a4
    80014552:	2781                	sext.w	a5,a5
    80014554:	fcf76fe3          	bltu	a4,a5,80014532 <minix3_init_callback+0x34>
    }
    if (cb_data->mounted_path) {
    80014558:	fe043783          	ld	a5,-32(s0)
    8001455c:	639c                	ld	a5,0(a5)
    8001455e:	c385                	beqz	a5,8001457e <minix3_init_callback+0x80>
        infof("%s\n", cb_data->mounted_path);
    80014560:	fe043783          	ld	a5,-32(s0)
    80014564:	639c                	ld	a5,0(a5)
    80014566:	85be                	mv	a1,a5
    80014568:	00010517          	auipc	a0,0x10
    8001456c:	16050513          	addi	a0,a0,352 # 800246c8 <pow10.0+0x498>
    80014570:	53f040ef          	jal	ra,800192ae <infof>
        cb_data->mounted_path = NULL;
    80014574:	fe043783          	ld	a5,-32(s0)
    80014578:	0007b023          	sd	zero,0(a5) # 6000 <i+0x5fe0>
        return;
    8001457c:	a08d                	j	800145de <minix3_init_callback+0xe0>
    } else {
        infof("%s", name);
    8001457e:	fc043583          	ld	a1,-64(s0)
    80014582:	00010517          	auipc	a0,0x10
    80014586:	14e50513          	addi	a0,a0,334 # 800246d0 <pow10.0+0x4a0>
    8001458a:	525040ef          	jal	ra,800192ae <infof>
    }
    // infof("%s", name);
    // infof("name: %s", name);
    
    if (minix3_is_dir(block_device, inode)) {
    8001458e:	fd442783          	lw	a5,-44(s0)
    80014592:	85be                	mv	a1,a5
    80014594:	fd843503          	ld	a0,-40(s0)
    80014598:	379000ef          	jal	ra,80015110 <minix3_is_dir>
    8001459c:	87aa                	mv	a5,a0
    8001459e:	c38d                	beqz	a5,800145c0 <minix3_init_callback+0xc2>
        infof("/\n");
    800145a0:	00010517          	auipc	a0,0x10
    800145a4:	13850513          	addi	a0,a0,312 # 800246d8 <pow10.0+0x4a8>
    800145a8:	507040ef          	jal	ra,800192ae <infof>
        cb_data->dir_count++;
    800145ac:	fe043783          	ld	a5,-32(s0)
    800145b0:	47dc                	lw	a5,12(a5)
    800145b2:	2785                	addiw	a5,a5,1
    800145b4:	0007871b          	sext.w	a4,a5
    800145b8:	fe043783          	ld	a5,-32(s0)
    800145bc:	c7d8                	sw	a4,12(a5)
    800145be:	a005                	j	800145de <minix3_init_callback+0xe0>
    } else {
        infof("\n");
    800145c0:	00010517          	auipc	a0,0x10
    800145c4:	12050513          	addi	a0,a0,288 # 800246e0 <pow10.0+0x4b0>
    800145c8:	4e7040ef          	jal	ra,800192ae <infof>
        cb_data->file_count++;
    800145cc:	fe043783          	ld	a5,-32(s0)
    800145d0:	479c                	lw	a5,8(a5)
    800145d2:	2785                	addiw	a5,a5,1
    800145d4:	0007871b          	sext.w	a4,a5
    800145d8:	fe043783          	ld	a5,-32(s0)
    800145dc:	c798                	sw	a4,8(a5)

    // for (uint32_t i=0; i<depth; i++) {
    //     infof("   ");
    // }
    // infof("path: %s\n\n", path);
}
    800145de:	60a6                	ld	ra,72(sp)
    800145e0:	6406                	ld	s0,64(sp)
    800145e2:	6161                	addi	sp,sp,80
    800145e4:	8082                	ret

00000000800145e6 <minix3_init>:

void minix3_init(VirtioDevice *block_device, const char *path)
{
    800145e6:	715d                	addi	sp,sp,-80
    800145e8:	e486                	sd	ra,72(sp)
    800145ea:	e0a2                	sd	s0,64(sp)
    800145ec:	0880                	addi	s0,sp,80
    800145ee:	fca43c23          	sd	a0,-40(s0)
    800145f2:	fcb43823          	sd	a1,-48(s0)
    // Initialize the filesystem
    debugf("Initializing Minix3 filesystem on device %p at %s\n", block_device, path);
    minix3_get_superblock(block_device);
    800145f6:	fb040793          	addi	a5,s0,-80
    800145fa:	fd843583          	ld	a1,-40(s0)
    800145fe:	853e                	mv	a0,a5
    80014600:	076000ef          	jal	ra,80014676 <minix3_get_superblock>
    debugf("   num_zones: 0x%x (%d)\n", sb.num_zones, sb.num_zones);
    debugf("   magic: 0x%x\n", sb.magic);
    debugf("   block_size: %d\n", sb.block_size);
    debugf("   disk_version: %d\n", sb.disk_version);

    if (sb.magic != MINIX3_MAGIC) {
    80014604:	0000f797          	auipc	a5,0xf
    80014608:	a8c78793          	addi	a5,a5,-1396 # 80023090 <sb>
    8001460c:	0187d783          	lhu	a5,24(a5)
    80014610:	0007871b          	sext.w	a4,a5
    80014614:	6795                	lui	a5,0x5
    80014616:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    8001461a:	00f70c63          	beq	a4,a5,80014632 <minix3_init+0x4c>
        // We need to initialize the superblock
        warnf("Minix3 magic is not correct, initializing superblock ourselves...\n");
    8001461e:	00010517          	auipc	a0,0x10
    80014622:	0ca50513          	addi	a0,a0,202 # 800246e8 <pow10.0+0x4b8>
    80014626:	3db040ef          	jal	ra,80019200 <warnf>
        minix3_superblock_init(block_device);
    8001462a:	fd843503          	ld	a0,-40(s0)
    8001462e:	9bfff0ef          	jal	ra,80013fec <minix3_superblock_init>
    // // Copy the zone bitmap into memory
    // minix3_get_zone_bitmap(zone_bitmap);

    // inode_bitmap = (uint8_t *)kmalloc(minix3_get_inode_bitmap_size());
    // zone_bitmap = (uint8_t*)kmalloc(minix3_get_zone_bitmap_size(block_device));
    minix3_load_device(block_device);
    80014632:	fd843503          	ld	a0,-40(s0)
    80014636:	30c000ef          	jal	ra,80014942 <minix3_load_device>
    }
    */

    // const char *path = "/home/cosc562";

    CallbackData cb_data = {0};
    8001463a:	fe043023          	sd	zero,-32(s0)
    8001463e:	fe043423          	sd	zero,-24(s0)
    cb_data.mounted_path = path;
    80014642:	fd043783          	ld	a5,-48(s0)
    80014646:	fef43023          	sd	a5,-32(s0)
    // uint32_t inode = minix3_get_inode_from_path(block_device, path, false);
    // infof("%s has inode %u\n", path, inode);
    

    minix3_traverse(block_device, 1, "/", &cb_data, 0, 10, minix3_init_callback);
    8001464a:	fe040693          	addi	a3,s0,-32
    8001464e:	00000817          	auipc	a6,0x0
    80014652:	eb080813          	addi	a6,a6,-336 # 800144fe <minix3_init_callback>
    80014656:	47a9                	li	a5,10
    80014658:	4701                	li	a4,0
    8001465a:	00010617          	auipc	a2,0x10
    8001465e:	f6660613          	addi	a2,a2,-154 # 800245c0 <pow10.0+0x390>
    80014662:	4585                	li	a1,1
    80014664:	fd843503          	ld	a0,-40(s0)
    80014668:	5d7020ef          	jal	ra,8001743e <minix3_traverse>
    
    // infof("Files:\n");
    // CallbackData cb_data = {0};
    // minix3_traverse(block_device, 1, "/", &cb_data, 0, 10, callback);
    // infof("Found %u files and %u directories in /\n", cb_data.file_count, cb_data.dir_count);
}
    8001466c:	0001                	nop
    8001466e:	60a6                	ld	ra,72(sp)
    80014670:	6406                	ld	s0,64(sp)
    80014672:	6161                	addi	sp,sp,80
    80014674:	8082                	ret

0000000080014676 <minix3_get_superblock>:

SuperBlock minix3_get_superblock(VirtioDevice *block_device) {
    80014676:	1101                	addi	sp,sp,-32
    80014678:	ec06                	sd	ra,24(sp)
    8001467a:	e822                	sd	s0,16(sp)
    8001467c:	1000                	addi	s0,sp,32
    8001467e:	fea43423          	sd	a0,-24(s0)
    80014682:	feb43023          	sd	a1,-32(s0)
    // Get the superblock
    // SuperBlock superblock;
    // Superblock begins at bytes 1024
    if (sb.magic != MINIX3_MAGIC) {
    80014686:	0000f797          	auipc	a5,0xf
    8001468a:	a0a78793          	addi	a5,a5,-1526 # 80023090 <sb>
    8001468e:	0187d783          	lhu	a5,24(a5)
    80014692:	0007871b          	sext.w	a4,a5
    80014696:	6795                	lui	a5,0x5
    80014698:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    8001469c:	00f70e63          	beq	a4,a5,800146b8 <minix3_get_superblock+0x42>
        block_device_read_bytes(block_device, 1024, (uint8_t *)&sb, sizeof(SuperBlock));
    800146a0:	02000693          	li	a3,32
    800146a4:	0000f617          	auipc	a2,0xf
    800146a8:	9ec60613          	addi	a2,a2,-1556 # 80023090 <sb>
    800146ac:	40000593          	li	a1,1024
    800146b0:	fe043503          	ld	a0,-32(s0)
    800146b4:	707070ef          	jal	ra,8001c5ba <block_device_read_bytes>
    }
    return sb;
    800146b8:	fe843783          	ld	a5,-24(s0)
    800146bc:	0000f717          	auipc	a4,0xf
    800146c0:	9d470713          	addi	a4,a4,-1580 # 80023090 <sb>
    800146c4:	00072303          	lw	t1,0(a4)
    800146c8:	00472883          	lw	a7,4(a4)
    800146cc:	00872803          	lw	a6,8(a4)
    800146d0:	4748                	lw	a0,12(a4)
    800146d2:	4b0c                	lw	a1,16(a4)
    800146d4:	4b50                	lw	a2,20(a4)
    800146d6:	4f14                	lw	a3,24(a4)
    800146d8:	4f58                	lw	a4,28(a4)
    800146da:	0067a023          	sw	t1,0(a5)
    800146de:	0117a223          	sw	a7,4(a5)
    800146e2:	0107a423          	sw	a6,8(a5)
    800146e6:	c7c8                	sw	a0,12(a5)
    800146e8:	cb8c                	sw	a1,16(a5)
    800146ea:	cbd0                	sw	a2,20(a5)
    800146ec:	cf94                	sw	a3,24(a5)
    800146ee:	cfd8                	sw	a4,28(a5)
}
    800146f0:	fe843503          	ld	a0,-24(s0)
    800146f4:	60e2                	ld	ra,24(sp)
    800146f6:	6442                	ld	s0,16(sp)
    800146f8:	6105                	addi	sp,sp,32
    800146fa:	8082                	ret

00000000800146fc <minix3_put_superblock>:

void minix3_put_superblock(VirtioDevice *block_device, SuperBlock superblock) {
    800146fc:	1101                	addi	sp,sp,-32
    800146fe:	ec06                	sd	ra,24(sp)
    80014700:	e822                	sd	s0,16(sp)
    80014702:	1000                	addi	s0,sp,32
    80014704:	fea43423          	sd	a0,-24(s0)
    80014708:	80ae                	mv	ra,a1
    // Put the superblock
    block_device_write_bytes(block_device, 1024, (uint8_t *)&superblock, sizeof(SuperBlock));
    8001470a:	02000693          	li	a3,32
    8001470e:	8606                	mv	a2,ra
    80014710:	40000593          	li	a1,1024
    80014714:	fe843503          	ld	a0,-24(s0)
    80014718:	7a3070ef          	jal	ra,8001c6ba <block_device_write_bytes>
}
    8001471c:	0001                	nop
    8001471e:	60e2                	ld	ra,24(sp)
    80014720:	6442                	ld	s0,16(sp)
    80014722:	6105                	addi	sp,sp,32
    80014724:	8082                	ret

0000000080014726 <minix3_get_block_size>:


uint16_t minix3_get_block_size(VirtioDevice *block_device) {
    80014726:	7139                	addi	sp,sp,-64
    80014728:	fc06                	sd	ra,56(sp)
    8001472a:	f822                	sd	s0,48(sp)
    8001472c:	0080                	addi	s0,sp,64
    8001472e:	fca43423          	sd	a0,-56(s0)
    SuperBlock superblock = minix3_get_superblock(block_device);
    80014732:	fd040793          	addi	a5,s0,-48
    80014736:	fc843583          	ld	a1,-56(s0)
    8001473a:	853e                	mv	a0,a5
    8001473c:	f3bff0ef          	jal	ra,80014676 <minix3_get_superblock>
    return 1024 << superblock.log_zone_size;
    80014740:	fdc45783          	lhu	a5,-36(s0)
    80014744:	2781                	sext.w	a5,a5
    80014746:	40000713          	li	a4,1024
    8001474a:	00f717bb          	sllw	a5,a4,a5
    8001474e:	2781                	sext.w	a5,a5
    80014750:	17c2                	slli	a5,a5,0x30
    80014752:	93c1                	srli	a5,a5,0x30
}
    80014754:	853e                	mv	a0,a5
    80014756:	70e2                	ld	ra,56(sp)
    80014758:	7442                	ld	s0,48(sp)
    8001475a:	6121                	addi	sp,sp,64
    8001475c:	8082                	ret

000000008001475e <minix3_get_zone_size>:

uint16_t minix3_get_zone_size(VirtioDevice *block_device) {
    8001475e:	1101                	addi	sp,sp,-32
    80014760:	ec06                	sd	ra,24(sp)
    80014762:	e822                	sd	s0,16(sp)
    80014764:	1000                	addi	s0,sp,32
    80014766:	fea43423          	sd	a0,-24(s0)
    return minix3_get_block_size(block_device);
    8001476a:	fe843503          	ld	a0,-24(s0)
    8001476e:	fb9ff0ef          	jal	ra,80014726 <minix3_get_block_size>
    80014772:	87aa                	mv	a5,a0
}
    80014774:	853e                	mv	a0,a5
    80014776:	60e2                	ld	ra,24(sp)
    80014778:	6442                	ld	s0,16(sp)
    8001477a:	6105                	addi	sp,sp,32
    8001477c:	8082                	ret

000000008001477e <minix3_sectors_per_block>:

uint16_t minix3_sectors_per_block(VirtioDevice *block_device) {
    8001477e:	7179                	addi	sp,sp,-48
    80014780:	f406                	sd	ra,40(sp)
    80014782:	f022                	sd	s0,32(sp)
    80014784:	ec26                	sd	s1,24(sp)
    80014786:	1800                	addi	s0,sp,48
    80014788:	fca43c23          	sd	a0,-40(s0)
    return minix3_get_block_size(block_device) / block_device_get_sector_size(block_device);
    8001478c:	fd843503          	ld	a0,-40(s0)
    80014790:	f97ff0ef          	jal	ra,80014726 <minix3_get_block_size>
    80014794:	87aa                	mv	a5,a0
    80014796:	84be                	mv	s1,a5
    80014798:	fd843503          	ld	a0,-40(s0)
    8001479c:	2cd070ef          	jal	ra,8001c268 <block_device_get_sector_size>
    800147a0:	87aa                	mv	a5,a0
    800147a2:	02f4d7b3          	divu	a5,s1,a5
    800147a6:	17c2                	slli	a5,a5,0x30
    800147a8:	93c1                	srli	a5,a5,0x30
}
    800147aa:	853e                	mv	a0,a5
    800147ac:	70a2                	ld	ra,40(sp)
    800147ae:	7402                	ld	s0,32(sp)
    800147b0:	64e2                	ld	s1,24(sp)
    800147b2:	6145                	addi	sp,sp,48
    800147b4:	8082                	ret

00000000800147b6 <minix3_get_inode_bitmap_size>:

size_t minix3_get_inode_bitmap_size(VirtioDevice *block_device) {
    800147b6:	715d                	addi	sp,sp,-80
    800147b8:	e486                	sd	ra,72(sp)
    800147ba:	e0a2                	sd	s0,64(sp)
    800147bc:	fc26                	sd	s1,56(sp)
    800147be:	0880                	addi	s0,sp,80
    800147c0:	faa43c23          	sd	a0,-72(s0)
    return minix3_get_superblock(block_device).imap_blocks * minix3_get_block_size(block_device);
    800147c4:	fc040793          	addi	a5,s0,-64
    800147c8:	fb843583          	ld	a1,-72(s0)
    800147cc:	853e                	mv	a0,a5
    800147ce:	ea9ff0ef          	jal	ra,80014676 <minix3_get_superblock>
    800147d2:	fc645783          	lhu	a5,-58(s0)
    800147d6:	0007849b          	sext.w	s1,a5
    800147da:	fb843503          	ld	a0,-72(s0)
    800147de:	f49ff0ef          	jal	ra,80014726 <minix3_get_block_size>
    800147e2:	87aa                	mv	a5,a0
    800147e4:	2781                	sext.w	a5,a5
    800147e6:	02f487bb          	mulw	a5,s1,a5
    800147ea:	2781                	sext.w	a5,a5
}
    800147ec:	853e                	mv	a0,a5
    800147ee:	60a6                	ld	ra,72(sp)
    800147f0:	6406                	ld	s0,64(sp)
    800147f2:	74e2                	ld	s1,56(sp)
    800147f4:	6161                	addi	sp,sp,80
    800147f6:	8082                	ret

00000000800147f8 <minix3_get_zone_bitmap_size>:

size_t minix3_get_zone_bitmap_size(VirtioDevice *block_device) {
    800147f8:	715d                	addi	sp,sp,-80
    800147fa:	e486                	sd	ra,72(sp)
    800147fc:	e0a2                	sd	s0,64(sp)
    800147fe:	fc26                	sd	s1,56(sp)
    80014800:	0880                	addi	s0,sp,80
    80014802:	faa43c23          	sd	a0,-72(s0)
    return minix3_get_superblock(block_device).zmap_blocks * minix3_get_block_size(block_device);
    80014806:	fc040793          	addi	a5,s0,-64
    8001480a:	fb843583          	ld	a1,-72(s0)
    8001480e:	853e                	mv	a0,a5
    80014810:	e67ff0ef          	jal	ra,80014676 <minix3_get_superblock>
    80014814:	fc845783          	lhu	a5,-56(s0)
    80014818:	0007849b          	sext.w	s1,a5
    8001481c:	fb843503          	ld	a0,-72(s0)
    80014820:	f07ff0ef          	jal	ra,80014726 <minix3_get_block_size>
    80014824:	87aa                	mv	a5,a0
    80014826:	2781                	sext.w	a5,a5
    80014828:	02f487bb          	mulw	a5,s1,a5
    8001482c:	2781                	sext.w	a5,a5
}
    8001482e:	853e                	mv	a0,a5
    80014830:	60a6                	ld	ra,72(sp)
    80014832:	6406                	ld	s0,64(sp)
    80014834:	74e2                	ld	s1,56(sp)
    80014836:	6161                	addi	sp,sp,80
    80014838:	8082                	ret

000000008001483a <minix3_get_inode_bitmap>:

// Read the inode bitmap into the given buffer
void minix3_get_inode_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    8001483a:	7139                	addi	sp,sp,-64
    8001483c:	fc06                	sd	ra,56(sp)
    8001483e:	f822                	sd	s0,48(sp)
    80014840:	0080                	addi	s0,sp,64
    80014842:	fca43423          	sd	a0,-56(s0)
    80014846:	fcb43023          	sd	a1,-64(s0)
    debugf("Getting inode bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    8001484a:	fd040793          	addi	a5,s0,-48
    8001484e:	fc843583          	ld	a1,-56(s0)
    80014852:	853e                	mv	a0,a5
    80014854:	e23ff0ef          	jal	ra,80014676 <minix3_get_superblock>

    minix3_get_blocks(block_device, FS_IMAP_IDX, bitmap_buf, sb.imap_blocks);
    80014858:	fd645783          	lhu	a5,-42(s0)
    8001485c:	86be                	mv	a3,a5
    8001485e:	fc043603          	ld	a2,-64(s0)
    80014862:	4589                	li	a1,2
    80014864:	fc843503          	ld	a0,-56(s0)
    80014868:	1b4000ef          	jal	ra,80014a1c <minix3_get_blocks>
    // debugf("About to read inode byte at %u (%x)...\n", byte_offset, byte_offset);
    // block_device_read_bytes(byte_offset, &inode_byte, 1);
    // debugf("Inode byte: %x\n", inode_byte);
    // return inode_byte & (1 << inode % 8);
    // block_device_read_bytes(FS_IMAP_IDX * minix3_get_block_size(block_device), bitmap_buf, minix3_get_block_size(block_device) * sb.imap_blocks);
}
    8001486c:	0001                	nop
    8001486e:	70e2                	ld	ra,56(sp)
    80014870:	7442                	ld	s0,48(sp)
    80014872:	6121                	addi	sp,sp,64
    80014874:	8082                	ret

0000000080014876 <minix3_put_inode_bitmap>:
// Write the inode bitmap from the given buffer
void minix3_put_inode_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    80014876:	7139                	addi	sp,sp,-64
    80014878:	fc06                	sd	ra,56(sp)
    8001487a:	f822                	sd	s0,48(sp)
    8001487c:	0080                	addi	s0,sp,64
    8001487e:	fca43423          	sd	a0,-56(s0)
    80014882:	fcb43023          	sd	a1,-64(s0)
    debugf("Setting inode bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    80014886:	fd040793          	addi	a5,s0,-48
    8001488a:	fc843583          	ld	a1,-56(s0)
    8001488e:	853e                	mv	a0,a5
    80014890:	de7ff0ef          	jal	ra,80014676 <minix3_get_superblock>
    minix3_put_blocks(block_device, FS_IMAP_IDX, bitmap_buf, sb.imap_blocks);
    80014894:	fd645783          	lhu	a5,-42(s0)
    80014898:	86be                	mv	a3,a5
    8001489a:	fc043603          	ld	a2,-64(s0)
    8001489e:	4589                	li	a1,2
    800148a0:	fc843503          	ld	a0,-56(s0)
    800148a4:	1ea000ef          	jal	ra,80014a8e <minix3_put_blocks>
    // block_device_write_bytes(FS_IMAP_IDX * minix3_get_block_size(block_device), bitmap_buf, minix3_get_block_size(block_device) * sb.imap_blocks);
}
    800148a8:	0001                	nop
    800148aa:	70e2                	ld	ra,56(sp)
    800148ac:	7442                	ld	s0,48(sp)
    800148ae:	6121                	addi	sp,sp,64
    800148b0:	8082                	ret

00000000800148b2 <minix3_get_zone_bitmap>:
// Read the zone bitmap into the given buffer
void minix3_get_zone_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    800148b2:	7139                	addi	sp,sp,-64
    800148b4:	fc06                	sd	ra,56(sp)
    800148b6:	f822                	sd	s0,48(sp)
    800148b8:	0080                	addi	s0,sp,64
    800148ba:	fca43423          	sd	a0,-56(s0)
    800148be:	fcb43023          	sd	a1,-64(s0)
    debugf("Getting zone bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    800148c2:	fd040793          	addi	a5,s0,-48
    800148c6:	fc843583          	ld	a1,-56(s0)
    800148ca:	853e                	mv	a0,a5
    800148cc:	dabff0ef          	jal	ra,80014676 <minix3_get_superblock>
    minix3_get_blocks(block_device, FS_IMAP_IDX + sb.imap_blocks, bitmap_buf, sb.zmap_blocks);
    800148d0:	fd645783          	lhu	a5,-42(s0)
    800148d4:	2781                	sext.w	a5,a5
    800148d6:	2789                	addiw	a5,a5,2
    800148d8:	2781                	sext.w	a5,a5
    800148da:	2781                	sext.w	a5,a5
    800148dc:	fd845703          	lhu	a4,-40(s0)
    800148e0:	86ba                	mv	a3,a4
    800148e2:	fc043603          	ld	a2,-64(s0)
    800148e6:	85be                	mv	a1,a5
    800148e8:	fc843503          	ld	a0,-56(s0)
    800148ec:	130000ef          	jal	ra,80014a1c <minix3_get_blocks>
    // block_device_read_bytes((FS_IMAP_IDX + sb.imap_blocks) * minix3_get_block_size(block_device), bitmap_buf, minix3_get_block_size(block_device) * sb.zmap_blocks);
}
    800148f0:	0001                	nop
    800148f2:	70e2                	ld	ra,56(sp)
    800148f4:	7442                	ld	s0,48(sp)
    800148f6:	6121                	addi	sp,sp,64
    800148f8:	8082                	ret

00000000800148fa <minix3_put_zone_bitmap>:
// Write the zone bitmap from the given buffer
void minix3_put_zone_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    800148fa:	7139                	addi	sp,sp,-64
    800148fc:	fc06                	sd	ra,56(sp)
    800148fe:	f822                	sd	s0,48(sp)
    80014900:	0080                	addi	s0,sp,64
    80014902:	fca43423          	sd	a0,-56(s0)
    80014906:	fcb43023          	sd	a1,-64(s0)
    debugf("Setting zone bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    8001490a:	fd040793          	addi	a5,s0,-48
    8001490e:	fc843583          	ld	a1,-56(s0)
    80014912:	853e                	mv	a0,a5
    80014914:	d63ff0ef          	jal	ra,80014676 <minix3_get_superblock>
    minix3_put_blocks(block_device, FS_IMAP_IDX + sb.imap_blocks, bitmap_buf, sb.zmap_blocks);
    80014918:	fd645783          	lhu	a5,-42(s0)
    8001491c:	2781                	sext.w	a5,a5
    8001491e:	2789                	addiw	a5,a5,2
    80014920:	2781                	sext.w	a5,a5
    80014922:	2781                	sext.w	a5,a5
    80014924:	fd845703          	lhu	a4,-40(s0)
    80014928:	86ba                	mv	a3,a4
    8001492a:	fc043603          	ld	a2,-64(s0)
    8001492e:	85be                	mv	a1,a5
    80014930:	fc843503          	ld	a0,-56(s0)
    80014934:	15a000ef          	jal	ra,80014a8e <minix3_put_blocks>
}
    80014938:	0001                	nop
    8001493a:	70e2                	ld	ra,56(sp)
    8001493c:	7442                	ld	s0,48(sp)
    8001493e:	6121                	addi	sp,sp,64
    80014940:	8082                	ret

0000000080014942 <minix3_load_device>:

void minix3_load_device(VirtioDevice *block_device) {
    80014942:	1101                	addi	sp,sp,-32
    80014944:	ec06                	sd	ra,24(sp)
    80014946:	e822                	sd	s0,16(sp)
    80014948:	1000                	addi	s0,sp,32
    8001494a:	fea43423          	sd	a0,-24(s0)
    if (loaded_block_device == block_device) {
    8001494e:	0000e797          	auipc	a5,0xe
    80014952:	76278793          	addi	a5,a5,1890 # 800230b0 <loaded_block_device>
    80014956:	639c                	ld	a5,0(a5)
    80014958:	fe843703          	ld	a4,-24(s0)
    8001495c:	0af70b63          	beq	a4,a5,80014a12 <minix3_load_device+0xd0>
        return;
    } else {
        loaded_block_device = block_device;
    80014960:	0000e797          	auipc	a5,0xe
    80014964:	75078793          	addi	a5,a5,1872 # 800230b0 <loaded_block_device>
    80014968:	fe843703          	ld	a4,-24(s0)
    8001496c:	e398                	sd	a4,0(a5)
    }

    if (inode_bitmap && zone_bitmap) {
    8001496e:	0000e797          	auipc	a5,0xe
    80014972:	74a78793          	addi	a5,a5,1866 # 800230b8 <inode_bitmap>
    80014976:	639c                	ld	a5,0(a5)
    80014978:	cf85                	beqz	a5,800149b0 <minix3_load_device+0x6e>
    8001497a:	0000e797          	auipc	a5,0xe
    8001497e:	74678793          	addi	a5,a5,1862 # 800230c0 <zone_bitmap>
    80014982:	639c                	ld	a5,0(a5)
    80014984:	c795                	beqz	a5,800149b0 <minix3_load_device+0x6e>
        minix3_get_inode_bitmap(block_device, inode_bitmap);
    80014986:	0000e797          	auipc	a5,0xe
    8001498a:	73278793          	addi	a5,a5,1842 # 800230b8 <inode_bitmap>
    8001498e:	639c                	ld	a5,0(a5)
    80014990:	85be                	mv	a1,a5
    80014992:	fe843503          	ld	a0,-24(s0)
    80014996:	ea5ff0ef          	jal	ra,8001483a <minix3_get_inode_bitmap>
        minix3_get_zone_bitmap(block_device, zone_bitmap);
    8001499a:	0000e797          	auipc	a5,0xe
    8001499e:	72678793          	addi	a5,a5,1830 # 800230c0 <zone_bitmap>
    800149a2:	639c                	ld	a5,0(a5)
    800149a4:	85be                	mv	a1,a5
    800149a6:	fe843503          	ld	a0,-24(s0)
    800149aa:	f09ff0ef          	jal	ra,800148b2 <minix3_get_zone_bitmap>
    800149ae:	a09d                	j	80014a14 <minix3_load_device+0xd2>
    } else {
        inode_bitmap = (uint8_t *)kmalloc(minix3_get_inode_bitmap_size(block_device));
    800149b0:	fe843503          	ld	a0,-24(s0)
    800149b4:	e03ff0ef          	jal	ra,800147b6 <minix3_get_inode_bitmap_size>
    800149b8:	87aa                	mv	a5,a0
    800149ba:	853e                	mv	a0,a5
    800149bc:	adaff0ef          	jal	ra,80013c96 <kmalloc>
    800149c0:	872a                	mv	a4,a0
    800149c2:	0000e797          	auipc	a5,0xe
    800149c6:	6f678793          	addi	a5,a5,1782 # 800230b8 <inode_bitmap>
    800149ca:	e398                	sd	a4,0(a5)
        zone_bitmap = (uint8_t *)kmalloc(minix3_get_zone_bitmap_size(block_device));
    800149cc:	fe843503          	ld	a0,-24(s0)
    800149d0:	e29ff0ef          	jal	ra,800147f8 <minix3_get_zone_bitmap_size>
    800149d4:	87aa                	mv	a5,a0
    800149d6:	853e                	mv	a0,a5
    800149d8:	abeff0ef          	jal	ra,80013c96 <kmalloc>
    800149dc:	872a                	mv	a4,a0
    800149de:	0000e797          	auipc	a5,0xe
    800149e2:	6e278793          	addi	a5,a5,1762 # 800230c0 <zone_bitmap>
    800149e6:	e398                	sd	a4,0(a5)
        minix3_get_inode_bitmap(block_device, inode_bitmap);
    800149e8:	0000e797          	auipc	a5,0xe
    800149ec:	6d078793          	addi	a5,a5,1744 # 800230b8 <inode_bitmap>
    800149f0:	639c                	ld	a5,0(a5)
    800149f2:	85be                	mv	a1,a5
    800149f4:	fe843503          	ld	a0,-24(s0)
    800149f8:	e43ff0ef          	jal	ra,8001483a <minix3_get_inode_bitmap>
        minix3_get_zone_bitmap(block_device, zone_bitmap);
    800149fc:	0000e797          	auipc	a5,0xe
    80014a00:	6c478793          	addi	a5,a5,1732 # 800230c0 <zone_bitmap>
    80014a04:	639c                	ld	a5,0(a5)
    80014a06:	85be                	mv	a1,a5
    80014a08:	fe843503          	ld	a0,-24(s0)
    80014a0c:	ea7ff0ef          	jal	ra,800148b2 <minix3_get_zone_bitmap>
    80014a10:	a011                	j	80014a14 <minix3_load_device+0xd2>
        return;
    80014a12:	0001                	nop
    }
}
    80014a14:	60e2                	ld	ra,24(sp)
    80014a16:	6442                	ld	s0,16(sp)
    80014a18:	6105                	addi	sp,sp,32
    80014a1a:	8082                	ret

0000000080014a1c <minix3_get_blocks>:

void minix3_get_blocks(VirtioDevice *block_device, uint32_t start_block, uint8_t *data, uint16_t count) {
    80014a1c:	7139                	addi	sp,sp,-64
    80014a1e:	fc06                	sd	ra,56(sp)
    80014a20:	f822                	sd	s0,48(sp)
    80014a22:	f426                	sd	s1,40(sp)
    80014a24:	0080                	addi	s0,sp,64
    80014a26:	fca43c23          	sd	a0,-40(s0)
    80014a2a:	87ae                	mv	a5,a1
    80014a2c:	fcc43423          	sd	a2,-56(s0)
    80014a30:	8736                	mv	a4,a3
    80014a32:	fcf42a23          	sw	a5,-44(s0)
    80014a36:	87ba                	mv	a5,a4
    80014a38:	fcf41923          	sh	a5,-46(s0)
    // SuperBlock sb = minix3_get_superblock();
    block_device_read_bytes(block_device, start_block * minix3_get_block_size(block_device), data, minix3_get_block_size(block_device) * count);
    80014a3c:	fd843503          	ld	a0,-40(s0)
    80014a40:	ce7ff0ef          	jal	ra,80014726 <minix3_get_block_size>
    80014a44:	87aa                	mv	a5,a0
    80014a46:	2781                	sext.w	a5,a5
    80014a48:	fd442703          	lw	a4,-44(s0)
    80014a4c:	02f707bb          	mulw	a5,a4,a5
    80014a50:	2781                	sext.w	a5,a5
    80014a52:	02079493          	slli	s1,a5,0x20
    80014a56:	9081                	srli	s1,s1,0x20
    80014a58:	fd843503          	ld	a0,-40(s0)
    80014a5c:	ccbff0ef          	jal	ra,80014726 <minix3_get_block_size>
    80014a60:	87aa                	mv	a5,a0
    80014a62:	0007871b          	sext.w	a4,a5
    80014a66:	fd245783          	lhu	a5,-46(s0)
    80014a6a:	2781                	sext.w	a5,a5
    80014a6c:	02f707bb          	mulw	a5,a4,a5
    80014a70:	2781                	sext.w	a5,a5
    80014a72:	86be                	mv	a3,a5
    80014a74:	fc843603          	ld	a2,-56(s0)
    80014a78:	85a6                	mv	a1,s1
    80014a7a:	fd843503          	ld	a0,-40(s0)
    80014a7e:	33d070ef          	jal	ra,8001c5ba <block_device_read_bytes>
}
    80014a82:	0001                	nop
    80014a84:	70e2                	ld	ra,56(sp)
    80014a86:	7442                	ld	s0,48(sp)
    80014a88:	74a2                	ld	s1,40(sp)
    80014a8a:	6121                	addi	sp,sp,64
    80014a8c:	8082                	ret

0000000080014a8e <minix3_put_blocks>:
void minix3_put_blocks(VirtioDevice *block_device, uint32_t start_block, uint8_t *data, uint16_t count) {
    80014a8e:	7139                	addi	sp,sp,-64
    80014a90:	fc06                	sd	ra,56(sp)
    80014a92:	f822                	sd	s0,48(sp)
    80014a94:	f426                	sd	s1,40(sp)
    80014a96:	0080                	addi	s0,sp,64
    80014a98:	fca43c23          	sd	a0,-40(s0)
    80014a9c:	87ae                	mv	a5,a1
    80014a9e:	fcc43423          	sd	a2,-56(s0)
    80014aa2:	8736                	mv	a4,a3
    80014aa4:	fcf42a23          	sw	a5,-44(s0)
    80014aa8:	87ba                	mv	a5,a4
    80014aaa:	fcf41923          	sh	a5,-46(s0)
    // SuperBlock sb = minix3_get_superblock();
    block_device_write_bytes(block_device, start_block * minix3_get_block_size(block_device), data, minix3_get_block_size(block_device) * count);
    80014aae:	fd843503          	ld	a0,-40(s0)
    80014ab2:	c75ff0ef          	jal	ra,80014726 <minix3_get_block_size>
    80014ab6:	87aa                	mv	a5,a0
    80014ab8:	2781                	sext.w	a5,a5
    80014aba:	fd442703          	lw	a4,-44(s0)
    80014abe:	02f707bb          	mulw	a5,a4,a5
    80014ac2:	2781                	sext.w	a5,a5
    80014ac4:	02079493          	slli	s1,a5,0x20
    80014ac8:	9081                	srli	s1,s1,0x20
    80014aca:	fd843503          	ld	a0,-40(s0)
    80014ace:	c59ff0ef          	jal	ra,80014726 <minix3_get_block_size>
    80014ad2:	87aa                	mv	a5,a0
    80014ad4:	0007871b          	sext.w	a4,a5
    80014ad8:	fd245783          	lhu	a5,-46(s0)
    80014adc:	2781                	sext.w	a5,a5
    80014ade:	02f707bb          	mulw	a5,a4,a5
    80014ae2:	2781                	sext.w	a5,a5
    80014ae4:	86be                	mv	a3,a5
    80014ae6:	fc843603          	ld	a2,-56(s0)
    80014aea:	85a6                	mv	a1,s1
    80014aec:	fd843503          	ld	a0,-40(s0)
    80014af0:	3cb070ef          	jal	ra,8001c6ba <block_device_write_bytes>
}
    80014af4:	0001                	nop
    80014af6:	70e2                	ld	ra,56(sp)
    80014af8:	7442                	ld	s0,48(sp)
    80014afa:	74a2                	ld	s1,40(sp)
    80014afc:	6121                	addi	sp,sp,64
    80014afe:	8082                	ret

0000000080014b00 <minix3_get_block>:

void minix3_get_block(VirtioDevice *block_device, uint32_t block, uint8_t *data) {
    80014b00:	7179                	addi	sp,sp,-48
    80014b02:	f406                	sd	ra,40(sp)
    80014b04:	f022                	sd	s0,32(sp)
    80014b06:	1800                	addi	s0,sp,48
    80014b08:	fea43423          	sd	a0,-24(s0)
    80014b0c:	87ae                	mv	a5,a1
    80014b0e:	fcc43c23          	sd	a2,-40(s0)
    80014b12:	fef42223          	sw	a5,-28(s0)
    minix3_get_blocks(block_device, block, data, 1);
    80014b16:	fe442783          	lw	a5,-28(s0)
    80014b1a:	4685                	li	a3,1
    80014b1c:	fd843603          	ld	a2,-40(s0)
    80014b20:	85be                	mv	a1,a5
    80014b22:	fe843503          	ld	a0,-24(s0)
    80014b26:	ef7ff0ef          	jal	ra,80014a1c <minix3_get_blocks>
}
    80014b2a:	0001                	nop
    80014b2c:	70a2                	ld	ra,40(sp)
    80014b2e:	7402                	ld	s0,32(sp)
    80014b30:	6145                	addi	sp,sp,48
    80014b32:	8082                	ret

0000000080014b34 <minix3_put_block>:

void minix3_put_block(VirtioDevice *block_device, uint32_t block, uint8_t *data) {
    80014b34:	7179                	addi	sp,sp,-48
    80014b36:	f406                	sd	ra,40(sp)
    80014b38:	f022                	sd	s0,32(sp)
    80014b3a:	1800                	addi	s0,sp,48
    80014b3c:	fea43423          	sd	a0,-24(s0)
    80014b40:	87ae                	mv	a5,a1
    80014b42:	fcc43c23          	sd	a2,-40(s0)
    80014b46:	fef42223          	sw	a5,-28(s0)
    minix3_put_blocks(block_device, block, data, 1);
    80014b4a:	fe442783          	lw	a5,-28(s0)
    80014b4e:	4685                	li	a3,1
    80014b50:	fd843603          	ld	a2,-40(s0)
    80014b54:	85be                	mv	a1,a5
    80014b56:	fe843503          	ld	a0,-24(s0)
    80014b5a:	f35ff0ef          	jal	ra,80014a8e <minix3_put_blocks>
}
    80014b5e:	0001                	nop
    80014b60:	70a2                	ld	ra,40(sp)
    80014b62:	7402                	ld	s0,32(sp)
    80014b64:	6145                	addi	sp,sp,48
    80014b66:	8082                	ret

0000000080014b68 <minix3_has_inode>:

bool minix3_has_inode(VirtioDevice *block_device, uint32_t inode) {
    80014b68:	1101                	addi	sp,sp,-32
    80014b6a:	ec06                	sd	ra,24(sp)
    80014b6c:	e822                	sd	s0,16(sp)
    80014b6e:	1000                	addi	s0,sp,32
    80014b70:	fea43423          	sd	a0,-24(s0)
    80014b74:	87ae                	mv	a5,a1
    80014b76:	fef42223          	sw	a5,-28(s0)
    minix3_load_device(block_device);
    80014b7a:	fe843503          	ld	a0,-24(s0)
    80014b7e:	dc5ff0ef          	jal	ra,80014942 <minix3_load_device>

    if (inode == INVALID_INODE) {
    80014b82:	fe442783          	lw	a5,-28(s0)
    80014b86:	2781                	sext.w	a5,a5
    80014b88:	e399                	bnez	a5,80014b8e <minix3_has_inode+0x26>
        debugf("minix3_has_inode: Invalid inode %u\n", inode);
        return false;
    80014b8a:	4781                	li	a5,0
    80014b8c:	a081                	j	80014bcc <minix3_has_inode+0x64>
    }
    return inode_bitmap[inode / 8] & (1 << inode % 8);
    80014b8e:	0000e797          	auipc	a5,0xe
    80014b92:	52a78793          	addi	a5,a5,1322 # 800230b8 <inode_bitmap>
    80014b96:	6398                	ld	a4,0(a5)
    80014b98:	fe442783          	lw	a5,-28(s0)
    80014b9c:	0037d79b          	srliw	a5,a5,0x3
    80014ba0:	2781                	sext.w	a5,a5
    80014ba2:	1782                	slli	a5,a5,0x20
    80014ba4:	9381                	srli	a5,a5,0x20
    80014ba6:	97ba                	add	a5,a5,a4
    80014ba8:	0007c783          	lbu	a5,0(a5)
    80014bac:	0007871b          	sext.w	a4,a5
    80014bb0:	fe442783          	lw	a5,-28(s0)
    80014bb4:	8b9d                	andi	a5,a5,7
    80014bb6:	2781                	sext.w	a5,a5
    80014bb8:	4685                	li	a3,1
    80014bba:	00f697bb          	sllw	a5,a3,a5
    80014bbe:	2781                	sext.w	a5,a5
    80014bc0:	8ff9                	and	a5,a5,a4
    80014bc2:	2781                	sext.w	a5,a5
    80014bc4:	00f037b3          	snez	a5,a5
    80014bc8:	0ff7f793          	andi	a5,a5,255
}
    80014bcc:	853e                	mv	a0,a5
    80014bce:	60e2                	ld	ra,24(sp)
    80014bd0:	6442                	ld	s0,16(sp)
    80014bd2:	6105                	addi	sp,sp,32
    80014bd4:	8082                	ret

0000000080014bd6 <minix3_take_inode>:

// Mark the inode taken in the inode map.
bool minix3_take_inode(VirtioDevice *block_device, uint32_t inode) {
    80014bd6:	7135                	addi	sp,sp,-160
    80014bd8:	ed06                	sd	ra,152(sp)
    80014bda:	e922                	sd	s0,144(sp)
    80014bdc:	1100                	addi	s0,sp,160
    80014bde:	faa43423          	sd	a0,-88(s0)
    80014be2:	87ae                	mv	a5,a1
    80014be4:	faf42223          	sw	a5,-92(s0)
    minix3_load_device(block_device);
    80014be8:	fa843503          	ld	a0,-88(s0)
    80014bec:	d57ff0ef          	jal	ra,80014942 <minix3_load_device>
    if (inode == INVALID_INODE) {
    80014bf0:	fa442783          	lw	a5,-92(s0)
    80014bf4:	2781                	sext.w	a5,a5
    80014bf6:	e399                	bnez	a5,80014bfc <minix3_take_inode+0x26>
        debugf("minix3_has_inode: Invalid inode %u\n", inode);
        return false;
    80014bf8:	4781                	li	a5,0
    80014bfa:	aa11                	j	80014d0e <minix3_take_inode+0x138>
    }
    if (minix3_has_inode(block_device, inode)) {
    80014bfc:	fa442783          	lw	a5,-92(s0)
    80014c00:	85be                	mv	a1,a5
    80014c02:	fa843503          	ld	a0,-88(s0)
    80014c06:	f63ff0ef          	jal	ra,80014b68 <minix3_has_inode>
    80014c0a:	87aa                	mv	a5,a0
    80014c0c:	cf81                	beqz	a5,80014c24 <minix3_take_inode+0x4e>
        warnf("minix3_take_inode: Inode %u is already taken\n", inode);
    80014c0e:	fa442783          	lw	a5,-92(s0)
    80014c12:	85be                	mv	a1,a5
    80014c14:	00010517          	auipc	a0,0x10
    80014c18:	b1c50513          	addi	a0,a0,-1252 # 80024730 <pow10.0+0x500>
    80014c1c:	5e4040ef          	jal	ra,80019200 <warnf>
        return false;
    80014c20:	4781                	li	a5,0
    80014c22:	a0f5                	j	80014d0e <minix3_take_inode+0x138>
    }

    inode_bitmap[inode / 8] |= (1 << inode % 8);
    80014c24:	0000e797          	auipc	a5,0xe
    80014c28:	49478793          	addi	a5,a5,1172 # 800230b8 <inode_bitmap>
    80014c2c:	6398                	ld	a4,0(a5)
    80014c2e:	fa442783          	lw	a5,-92(s0)
    80014c32:	0037d79b          	srliw	a5,a5,0x3
    80014c36:	0007861b          	sext.w	a2,a5
    80014c3a:	02061793          	slli	a5,a2,0x20
    80014c3e:	9381                	srli	a5,a5,0x20
    80014c40:	97ba                	add	a5,a5,a4
    80014c42:	0007c783          	lbu	a5,0(a5)
    80014c46:	0187971b          	slliw	a4,a5,0x18
    80014c4a:	4187571b          	sraiw	a4,a4,0x18
    80014c4e:	fa442783          	lw	a5,-92(s0)
    80014c52:	8b9d                	andi	a5,a5,7
    80014c54:	2781                	sext.w	a5,a5
    80014c56:	4685                	li	a3,1
    80014c58:	00f697bb          	sllw	a5,a3,a5
    80014c5c:	2781                	sext.w	a5,a5
    80014c5e:	0187979b          	slliw	a5,a5,0x18
    80014c62:	4187d79b          	sraiw	a5,a5,0x18
    80014c66:	8fd9                	or	a5,a5,a4
    80014c68:	0187969b          	slliw	a3,a5,0x18
    80014c6c:	4186d69b          	sraiw	a3,a3,0x18
    80014c70:	0000e797          	auipc	a5,0xe
    80014c74:	44878793          	addi	a5,a5,1096 # 800230b8 <inode_bitmap>
    80014c78:	6398                	ld	a4,0(a5)
    80014c7a:	02061793          	slli	a5,a2,0x20
    80014c7e:	9381                	srli	a5,a5,0x20
    80014c80:	97ba                	add	a5,a5,a4
    80014c82:	0ff6f713          	andi	a4,a3,255
    80014c86:	00e78023          	sb	a4,0(a5)
    minix3_put_inode_bitmap(block_device, inode_bitmap);
    80014c8a:	0000e797          	auipc	a5,0xe
    80014c8e:	42e78793          	addi	a5,a5,1070 # 800230b8 <inode_bitmap>
    80014c92:	639c                	ld	a5,0(a5)
    80014c94:	85be                	mv	a1,a5
    80014c96:	fa843503          	ld	a0,-88(s0)
    80014c9a:	bddff0ef          	jal	ra,80014876 <minix3_put_inode_bitmap>
    Inode inode_data = minix3_get_inode(block_device, inode);
    80014c9e:	fb040793          	addi	a5,s0,-80
    80014ca2:	fa442703          	lw	a4,-92(s0)
    80014ca6:	863a                	mv	a2,a4
    80014ca8:	fa843583          	ld	a1,-88(s0)
    80014cac:	853e                	mv	a0,a5
    80014cae:	130000ef          	jal	ra,80014dde <minix3_get_inode>
    inode_data.num_links = 1;
    80014cb2:	4785                	li	a5,1
    80014cb4:	faf41923          	sh	a5,-78(s0)
    minix3_put_inode(block_device, inode, inode_data);
    80014cb8:	fb043883          	ld	a7,-80(s0)
    80014cbc:	fb843803          	ld	a6,-72(s0)
    80014cc0:	fc043503          	ld	a0,-64(s0)
    80014cc4:	fc843583          	ld	a1,-56(s0)
    80014cc8:	fd043603          	ld	a2,-48(s0)
    80014ccc:	fd843683          	ld	a3,-40(s0)
    80014cd0:	fe043703          	ld	a4,-32(s0)
    80014cd4:	fe843783          	ld	a5,-24(s0)
    80014cd8:	f7143023          	sd	a7,-160(s0)
    80014cdc:	f7043423          	sd	a6,-152(s0)
    80014ce0:	f6a43823          	sd	a0,-144(s0)
    80014ce4:	f6b43c23          	sd	a1,-136(s0)
    80014ce8:	f8c43023          	sd	a2,-128(s0)
    80014cec:	f8d43423          	sd	a3,-120(s0)
    80014cf0:	f8e43823          	sd	a4,-112(s0)
    80014cf4:	f8f43c23          	sd	a5,-104(s0)
    80014cf8:	f6040713          	addi	a4,s0,-160
    80014cfc:	fa442783          	lw	a5,-92(s0)
    80014d00:	863a                	mv	a2,a4
    80014d02:	85be                	mv	a1,a5
    80014d04:	fa843503          	ld	a0,-88(s0)
    80014d08:	222000ef          	jal	ra,80014f2a <minix3_put_inode>

    return true;
    80014d0c:	4785                	li	a5,1
}
    80014d0e:	853e                	mv	a0,a5
    80014d10:	60ea                	ld	ra,152(sp)
    80014d12:	644a                	ld	s0,144(sp)
    80014d14:	610d                	addi	sp,sp,160
    80014d16:	8082                	ret

0000000080014d18 <minix3_get_next_free_inode>:

uint32_t minix3_get_next_free_inode(VirtioDevice *block_device) {
    80014d18:	7139                	addi	sp,sp,-64
    80014d1a:	fc06                	sd	ra,56(sp)
    80014d1c:	f822                	sd	s0,48(sp)
    80014d1e:	0080                	addi	s0,sp,64
    80014d20:	fca43423          	sd	a0,-56(s0)
    debugf("Getting next free inode...\n");
    minix3_load_device(block_device);
    80014d24:	fc843503          	ld	a0,-56(s0)
    80014d28:	c1bff0ef          	jal	ra,80014942 <minix3_load_device>
    size_t inode_bitmap_size = minix3_get_inode_bitmap_size(block_device);
    80014d2c:	fc843503          	ld	a0,-56(s0)
    80014d30:	a87ff0ef          	jal	ra,800147b6 <minix3_get_inode_bitmap_size>
    80014d34:	fca43c23          	sd	a0,-40(s0)

    for (size_t i = 0; i < inode_bitmap_size; i++) {
    80014d38:	fe043423          	sd	zero,-24(s0)
    80014d3c:	a8bd                	j	80014dba <minix3_get_next_free_inode+0xa2>
        if (inode_bitmap[i] != 0xFF) {
    80014d3e:	0000e797          	auipc	a5,0xe
    80014d42:	37a78793          	addi	a5,a5,890 # 800230b8 <inode_bitmap>
    80014d46:	6398                	ld	a4,0(a5)
    80014d48:	fe843783          	ld	a5,-24(s0)
    80014d4c:	97ba                	add	a5,a5,a4
    80014d4e:	0007c783          	lbu	a5,0(a5)
    80014d52:	873e                	mv	a4,a5
    80014d54:	0ff00793          	li	a5,255
    80014d58:	04f70c63          	beq	a4,a5,80014db0 <minix3_get_next_free_inode+0x98>
            for (size_t j = 0; j < 8; j++) {
    80014d5c:	fe043023          	sd	zero,-32(s0)
    80014d60:	a099                	j	80014da6 <minix3_get_next_free_inode+0x8e>
                uint32_t inode = 8 * i + j;
    80014d62:	fe843783          	ld	a5,-24(s0)
    80014d66:	2781                	sext.w	a5,a5
    80014d68:	0037979b          	slliw	a5,a5,0x3
    80014d6c:	0007871b          	sext.w	a4,a5
    80014d70:	fe043783          	ld	a5,-32(s0)
    80014d74:	2781                	sext.w	a5,a5
    80014d76:	9fb9                	addw	a5,a5,a4
    80014d78:	fcf42a23          	sw	a5,-44(s0)
                if (!minix3_has_inode(block_device, inode)) {
    80014d7c:	fd442783          	lw	a5,-44(s0)
    80014d80:	85be                	mv	a1,a5
    80014d82:	fc843503          	ld	a0,-56(s0)
    80014d86:	de3ff0ef          	jal	ra,80014b68 <minix3_has_inode>
    80014d8a:	87aa                	mv	a5,a0
    80014d8c:	0017c793          	xori	a5,a5,1
    80014d90:	0ff7f793          	andi	a5,a5,255
    80014d94:	c781                	beqz	a5,80014d9c <minix3_get_next_free_inode+0x84>
                    return inode;
    80014d96:	fd442783          	lw	a5,-44(s0)
    80014d9a:	a82d                	j	80014dd4 <minix3_get_next_free_inode+0xbc>
            for (size_t j = 0; j < 8; j++) {
    80014d9c:	fe043783          	ld	a5,-32(s0)
    80014da0:	0785                	addi	a5,a5,1
    80014da2:	fef43023          	sd	a5,-32(s0)
    80014da6:	fe043703          	ld	a4,-32(s0)
    80014daa:	479d                	li	a5,7
    80014dac:	fae7fbe3          	bgeu	a5,a4,80014d62 <minix3_get_next_free_inode+0x4a>
    for (size_t i = 0; i < inode_bitmap_size; i++) {
    80014db0:	fe843783          	ld	a5,-24(s0)
    80014db4:	0785                	addi	a5,a5,1
    80014db6:	fef43423          	sd	a5,-24(s0)
    80014dba:	fe843703          	ld	a4,-24(s0)
    80014dbe:	fd843783          	ld	a5,-40(s0)
    80014dc2:	f6f76ee3          	bltu	a4,a5,80014d3e <minix3_get_next_free_inode+0x26>
                }
            }
        }
    }

    warnf("minix3_get_next_free_inode: Couldn't find free inode\n");
    80014dc6:	00010517          	auipc	a0,0x10
    80014dca:	99a50513          	addi	a0,a0,-1638 # 80024760 <pow10.0+0x530>
    80014dce:	432040ef          	jal	ra,80019200 <warnf>
    return 0;
    80014dd2:	4781                	li	a5,0
}
    80014dd4:	853e                	mv	a0,a5
    80014dd6:	70e2                	ld	ra,56(sp)
    80014dd8:	7442                	ld	s0,48(sp)
    80014dda:	6121                	addi	sp,sp,64
    80014ddc:	8082                	ret

0000000080014dde <minix3_get_inode>:

static uint32_t last_inode = 0; // Last inode number we looked up
static Inode last_inode_data; // Data of the last inode

Inode minix3_get_inode(VirtioDevice *block_device, uint32_t inode) {
    80014dde:	7111                	addi	sp,sp,-256
    80014de0:	fd86                	sd	ra,248(sp)
    80014de2:	f9a2                	sd	s0,240(sp)
    80014de4:	0200                	addi	s0,sp,256
    80014de6:	f2a43c23          	sd	a0,-200(s0)
    80014dea:	f2b43823          	sd	a1,-208(s0)
    80014dee:	87b2                	mv	a5,a2
    80014df0:	f2f42623          	sw	a5,-212(s0)
    minix3_load_device(block_device);
    80014df4:	f3043503          	ld	a0,-208(s0)
    80014df8:	b4bff0ef          	jal	ra,80014942 <minix3_load_device>
    if (inode == INVALID_INODE) {
    80014dfc:	f2c42783          	lw	a5,-212(s0)
    80014e00:	2781                	sext.w	a5,a5
    80014e02:	e78d                	bnez	a5,80014e2c <minix3_get_inode+0x4e>
        warnf("minix3_get_inode: Invalid inode %u\n", inode);
    80014e04:	f2c42783          	lw	a5,-212(s0)
    80014e08:	85be                	mv	a1,a5
    80014e0a:	00010517          	auipc	a0,0x10
    80014e0e:	98e50513          	addi	a0,a0,-1650 # 80024798 <pow10.0+0x568>
    80014e12:	3ee040ef          	jal	ra,80019200 <warnf>
        return (Inode){0};
    80014e16:	f3843783          	ld	a5,-200(s0)
    80014e1a:	873e                	mv	a4,a5
    80014e1c:	04000793          	li	a5,64
    80014e20:	863e                	mv	a2,a5
    80014e22:	4581                	li	a1,0
    80014e24:	853a                	mv	a0,a4
    80014e26:	7470a0ef          	jal	ra,8001fd6c <memset>
    // block_device_read_bytes(offset, (uint8_t*)&data, sizeof(Inode));
    block_device_read_bytes(block_device, offset, (uint8_t*)&data, sizeof(Inode));
    last_inode_data = data;
    last_inode = inode;
    return data;
}
    80014e2a:	a8d5                	j	80014f1e <minix3_get_inode+0x140>
    else if (inode == last_inode) {
    80014e2c:	0000e797          	auipc	a5,0xe
    80014e30:	29c78793          	addi	a5,a5,668 # 800230c8 <last_inode>
    80014e34:	4398                	lw	a4,0(a5)
    80014e36:	f2c42783          	lw	a5,-212(s0)
    80014e3a:	2781                	sext.w	a5,a5
    80014e3c:	02e79163          	bne	a5,a4,80014e5e <minix3_get_inode+0x80>
        return last_inode_data;
    80014e40:	f3843703          	ld	a4,-200(s0)
    80014e44:	0000e797          	auipc	a5,0xe
    80014e48:	28c78793          	addi	a5,a5,652 # 800230d0 <last_inode_data>
    80014e4c:	86be                	mv	a3,a5
    80014e4e:	04000793          	li	a5,64
    80014e52:	863e                	mv	a2,a5
    80014e54:	85b6                	mv	a1,a3
    80014e56:	853a                	mv	a0,a4
    80014e58:	0160b0ef          	jal	ra,8001fe6e <memcpy>
    80014e5c:	a0c9                	j	80014f1e <minix3_get_inode+0x140>
    SuperBlock sb = minix3_get_superblock(block_device);
    80014e5e:	fc840793          	addi	a5,s0,-56
    80014e62:	f3043583          	ld	a1,-208(s0)
    80014e66:	853e                	mv	a0,a5
    80014e68:	80fff0ef          	jal	ra,80014676 <minix3_get_superblock>
    uint64_t offset = minix3_get_inode_byte_offset(block_device, sb, inode);
    80014e6c:	fc843603          	ld	a2,-56(s0)
    80014e70:	fd043683          	ld	a3,-48(s0)
    80014e74:	fd843703          	ld	a4,-40(s0)
    80014e78:	fe043783          	ld	a5,-32(s0)
    80014e7c:	f0c43023          	sd	a2,-256(s0)
    80014e80:	f0d43423          	sd	a3,-248(s0)
    80014e84:	f0e43823          	sd	a4,-240(s0)
    80014e88:	f0f43c23          	sd	a5,-232(s0)
    80014e8c:	f2c42703          	lw	a4,-212(s0)
    80014e90:	f0040793          	addi	a5,s0,-256
    80014e94:	863a                	mv	a2,a4
    80014e96:	85be                	mv	a1,a5
    80014e98:	f3043503          	ld	a0,-208(s0)
    80014e9c:	8d4ff0ef          	jal	ra,80013f70 <minix3_get_inode_byte_offset>
    80014ea0:	fea43423          	sd	a0,-24(s0)
    block_device_read_bytes(block_device, offset, (uint8_t*)&data, sizeof(Inode));
    80014ea4:	f8840793          	addi	a5,s0,-120
    80014ea8:	04000693          	li	a3,64
    80014eac:	863e                	mv	a2,a5
    80014eae:	fe843583          	ld	a1,-24(s0)
    80014eb2:	f3043503          	ld	a0,-208(s0)
    80014eb6:	704070ef          	jal	ra,8001c5ba <block_device_read_bytes>
    last_inode_data = data;
    80014eba:	0000e797          	auipc	a5,0xe
    80014ebe:	21678793          	addi	a5,a5,534 # 800230d0 <last_inode_data>
    80014ec2:	f8843303          	ld	t1,-120(s0)
    80014ec6:	f9043883          	ld	a7,-112(s0)
    80014eca:	f9843803          	ld	a6,-104(s0)
    80014ece:	fa043503          	ld	a0,-96(s0)
    80014ed2:	fa843583          	ld	a1,-88(s0)
    80014ed6:	fb043603          	ld	a2,-80(s0)
    80014eda:	fb843683          	ld	a3,-72(s0)
    80014ede:	fc043703          	ld	a4,-64(s0)
    80014ee2:	0067b023          	sd	t1,0(a5)
    80014ee6:	0117b423          	sd	a7,8(a5)
    80014eea:	0107b823          	sd	a6,16(a5)
    80014eee:	ef88                	sd	a0,24(a5)
    80014ef0:	f38c                	sd	a1,32(a5)
    80014ef2:	f790                	sd	a2,40(a5)
    80014ef4:	fb94                	sd	a3,48(a5)
    80014ef6:	ff98                	sd	a4,56(a5)
    last_inode = inode;
    80014ef8:	0000e797          	auipc	a5,0xe
    80014efc:	1d078793          	addi	a5,a5,464 # 800230c8 <last_inode>
    80014f00:	f2c42703          	lw	a4,-212(s0)
    80014f04:	c398                	sw	a4,0(a5)
    return data;
    80014f06:	f3843783          	ld	a5,-200(s0)
    80014f0a:	86be                	mv	a3,a5
    80014f0c:	f8840793          	addi	a5,s0,-120
    80014f10:	04000713          	li	a4,64
    80014f14:	863a                	mv	a2,a4
    80014f16:	85be                	mv	a1,a5
    80014f18:	8536                	mv	a0,a3
    80014f1a:	7550a0ef          	jal	ra,8001fe6e <memcpy>
}
    80014f1e:	f3843503          	ld	a0,-200(s0)
    80014f22:	70ee                	ld	ra,248(sp)
    80014f24:	744e                	ld	s0,240(sp)
    80014f26:	6111                	addi	sp,sp,256
    80014f28:	8082                	ret

0000000080014f2a <minix3_put_inode>:

void minix3_put_inode(VirtioDevice *block_device, uint32_t inode, Inode data) {
    80014f2a:	7119                	addi	sp,sp,-128
    80014f2c:	fc86                	sd	ra,120(sp)
    80014f2e:	f8a2                	sd	s0,112(sp)
    80014f30:	f4a6                	sd	s1,104(sp)
    80014f32:	0100                	addi	s0,sp,128
    80014f34:	faa43423          	sd	a0,-88(s0)
    80014f38:	87ae                	mv	a5,a1
    80014f3a:	84b2                	mv	s1,a2
    80014f3c:	faf42223          	sw	a5,-92(s0)
    minix3_load_device(block_device);
    80014f40:	fa843503          	ld	a0,-88(s0)
    80014f44:	9ffff0ef          	jal	ra,80014942 <minix3_load_device>
    if (inode == INVALID_INODE) {
    80014f48:	fa442783          	lw	a5,-92(s0)
    80014f4c:	2781                	sext.w	a5,a5
    80014f4e:	eb99                	bnez	a5,80014f64 <minix3_put_inode+0x3a>
        warnf("minix3_put_inode: Invalid inode %u\n", inode);
    80014f50:	fa442783          	lw	a5,-92(s0)
    80014f54:	85be                	mv	a1,a5
    80014f56:	00010517          	auipc	a0,0x10
    80014f5a:	86a50513          	addi	a0,a0,-1942 # 800247c0 <pow10.0+0x590>
    80014f5e:	2a2040ef          	jal	ra,80019200 <warnf>
    80014f62:	a8a9                	j	80014fbc <minix3_put_inode+0x92>
        return;
    }
    SuperBlock sb = minix3_get_superblock(block_device);
    80014f64:	fb840793          	addi	a5,s0,-72
    80014f68:	fa843583          	ld	a1,-88(s0)
    80014f6c:	853e                	mv	a0,a5
    80014f6e:	f08ff0ef          	jal	ra,80014676 <minix3_get_superblock>
    uint64_t offset = minix3_get_inode_byte_offset(block_device, sb, inode);
    80014f72:	fb843603          	ld	a2,-72(s0)
    80014f76:	fc043683          	ld	a3,-64(s0)
    80014f7a:	fc843703          	ld	a4,-56(s0)
    80014f7e:	fd043783          	ld	a5,-48(s0)
    80014f82:	f8c43023          	sd	a2,-128(s0)
    80014f86:	f8d43423          	sd	a3,-120(s0)
    80014f8a:	f8e43823          	sd	a4,-112(s0)
    80014f8e:	f8f43c23          	sd	a5,-104(s0)
    80014f92:	fa442703          	lw	a4,-92(s0)
    80014f96:	f8040793          	addi	a5,s0,-128
    80014f9a:	863a                	mv	a2,a4
    80014f9c:	85be                	mv	a1,a5
    80014f9e:	fa843503          	ld	a0,-88(s0)
    80014fa2:	fcffe0ef          	jal	ra,80013f70 <minix3_get_inode_byte_offset>
    80014fa6:	fca43c23          	sd	a0,-40(s0)

    // debugf("Putting inode %u at offset %u (%x)...\n", inode, offset, offset);
    block_device_write_bytes(block_device, offset, (uint8_t*)&data, sizeof(Inode));
    80014faa:	04000693          	li	a3,64
    80014fae:	8626                	mv	a2,s1
    80014fb0:	fd843583          	ld	a1,-40(s0)
    80014fb4:	fa843503          	ld	a0,-88(s0)
    80014fb8:	702070ef          	jal	ra,8001c6ba <block_device_write_bytes>
}
    80014fbc:	70e6                	ld	ra,120(sp)
    80014fbe:	7446                	ld	s0,112(sp)
    80014fc0:	74a6                	ld	s1,104(sp)
    80014fc2:	6109                	addi	sp,sp,128
    80014fc4:	8082                	ret

0000000080014fc6 <minix3_alloc_inode>:

// Allocate a free inode.
// Return the allocated zero'd inode. 
uint32_t minix3_alloc_inode(VirtioDevice *block_device) {
    80014fc6:	7171                	addi	sp,sp,-176
    80014fc8:	f506                	sd	ra,168(sp)
    80014fca:	f122                	sd	s0,160(sp)
    80014fcc:	1900                	addi	s0,sp,176
    80014fce:	f8a43c23          	sd	a0,-104(s0)
    uint32_t free_inode = minix3_get_next_free_inode(block_device);
    80014fd2:	f9843503          	ld	a0,-104(s0)
    80014fd6:	d43ff0ef          	jal	ra,80014d18 <minix3_get_next_free_inode>
    80014fda:	87aa                	mv	a5,a0
    80014fdc:	fef42623          	sw	a5,-20(s0)
    if (!free_inode) {
    80014fe0:	fec42783          	lw	a5,-20(s0)
    80014fe4:	2781                	sext.w	a5,a5
    80014fe6:	eb89                	bnez	a5,80014ff8 <minix3_alloc_inode+0x32>
        warnf("minix3_alloc_inode: Couldn't find free inode\n");
    80014fe8:	00010517          	auipc	a0,0x10
    80014fec:	80050513          	addi	a0,a0,-2048 # 800247e8 <pow10.0+0x5b8>
    80014ff0:	210040ef          	jal	ra,80019200 <warnf>
        return 0;
    80014ff4:	4781                	li	a5,0
    80014ff6:	a045                	j	80015096 <minix3_alloc_inode+0xd0>
    } else {
        debugf("minix3_alloc_inode: Found free inode %u\n", free_inode);
    }
    if (!minix3_take_inode(block_device, free_inode)) {
    80014ff8:	fec42783          	lw	a5,-20(s0)
    80014ffc:	85be                	mv	a1,a5
    80014ffe:	f9843503          	ld	a0,-104(s0)
    80015002:	bd5ff0ef          	jal	ra,80014bd6 <minix3_take_inode>
    80015006:	87aa                	mv	a5,a0
    80015008:	0017c793          	xori	a5,a5,1
    8001500c:	0ff7f793          	andi	a5,a5,255
    80015010:	cf81                	beqz	a5,80015028 <minix3_alloc_inode+0x62>
        warnf("minix3_alloc_inode: Couldn't take inode %u\n", free_inode);
    80015012:	fec42783          	lw	a5,-20(s0)
    80015016:	85be                	mv	a1,a5
    80015018:	00010517          	auipc	a0,0x10
    8001501c:	80050513          	addi	a0,a0,-2048 # 80024818 <pow10.0+0x5e8>
    80015020:	1e0040ef          	jal	ra,80019200 <warnf>
        return 0;
    80015024:	4781                	li	a5,0
    80015026:	a885                	j	80015096 <minix3_alloc_inode+0xd0>
    }

    Inode data;
    memset(&data, 0, sizeof(data));
    80015028:	fa840793          	addi	a5,s0,-88
    8001502c:	04000613          	li	a2,64
    80015030:	4581                	li	a1,0
    80015032:	853e                	mv	a0,a5
    80015034:	5390a0ef          	jal	ra,8001fd6c <memset>
    data.num_links = 1;
    80015038:	4785                	li	a5,1
    8001503a:	faf41523          	sh	a5,-86(s0)
    minix3_put_inode(block_device, free_inode, data);
    8001503e:	fa843883          	ld	a7,-88(s0)
    80015042:	fb043803          	ld	a6,-80(s0)
    80015046:	fb843503          	ld	a0,-72(s0)
    8001504a:	fc043583          	ld	a1,-64(s0)
    8001504e:	fc843603          	ld	a2,-56(s0)
    80015052:	fd043683          	ld	a3,-48(s0)
    80015056:	fd843703          	ld	a4,-40(s0)
    8001505a:	fe043783          	ld	a5,-32(s0)
    8001505e:	f5143823          	sd	a7,-176(s0)
    80015062:	f5043c23          	sd	a6,-168(s0)
    80015066:	f6a43023          	sd	a0,-160(s0)
    8001506a:	f6b43423          	sd	a1,-152(s0)
    8001506e:	f6c43823          	sd	a2,-144(s0)
    80015072:	f6d43c23          	sd	a3,-136(s0)
    80015076:	f8e43023          	sd	a4,-128(s0)
    8001507a:	f8f43423          	sd	a5,-120(s0)
    8001507e:	f5040713          	addi	a4,s0,-176
    80015082:	fec42783          	lw	a5,-20(s0)
    80015086:	863a                	mv	a2,a4
    80015088:	85be                	mv	a1,a5
    8001508a:	f9843503          	ld	a0,-104(s0)
    8001508e:	e9dff0ef          	jal	ra,80014f2a <minix3_put_inode>
    // infof("minix3_alloc_inode %p\n", minix3_get_inode_byte_offset(sb, free_inode)); // TODO: REMOVE
    return free_inode;
    80015092:	fec42783          	lw	a5,-20(s0)
}
    80015096:	853e                	mv	a0,a5
    80015098:	70aa                	ld	ra,168(sp)
    8001509a:	740a                	ld	s0,160(sp)
    8001509c:	614d                	addi	sp,sp,176
    8001509e:	8082                	ret

00000000800150a0 <minix3_alloc_zone>:

uint32_t minix3_alloc_zone(VirtioDevice *block_device) {
    800150a0:	7179                	addi	sp,sp,-48
    800150a2:	f406                	sd	ra,40(sp)
    800150a4:	f022                	sd	s0,32(sp)
    800150a6:	1800                	addi	s0,sp,48
    800150a8:	fca43c23          	sd	a0,-40(s0)
    uint32_t free_zone = minix3_get_next_free_zone(block_device);
    800150ac:	fd843503          	ld	a0,-40(s0)
    800150b0:	94cff0ef          	jal	ra,800141fc <minix3_get_next_free_zone>
    800150b4:	87aa                	mv	a5,a0
    800150b6:	fef42623          	sw	a5,-20(s0)
    if (!free_zone) {
    800150ba:	fec42783          	lw	a5,-20(s0)
    800150be:	2781                	sext.w	a5,a5
    800150c0:	eb89                	bnez	a5,800150d2 <minix3_alloc_zone+0x32>
        warnf("minix3_alloc_zone: Couldn't find free zone\n");
    800150c2:	0000f517          	auipc	a0,0xf
    800150c6:	78650513          	addi	a0,a0,1926 # 80024848 <pow10.0+0x618>
    800150ca:	136040ef          	jal	ra,80019200 <warnf>
        return 0;
    800150ce:	4781                	li	a5,0
    800150d0:	a81d                	j	80015106 <minix3_alloc_zone+0x66>
    } else {
        debugf("minix3_alloc_zone: Found free zone %u\n", free_zone);
    }
    if (!minix3_take_zone(block_device, free_zone)) {
    800150d2:	fec42783          	lw	a5,-20(s0)
    800150d6:	85be                	mv	a1,a5
    800150d8:	fd843503          	ld	a0,-40(s0)
    800150dc:	858ff0ef          	jal	ra,80014134 <minix3_take_zone>
    800150e0:	87aa                	mv	a5,a0
    800150e2:	0017c793          	xori	a5,a5,1
    800150e6:	0ff7f793          	andi	a5,a5,255
    800150ea:	cf81                	beqz	a5,80015102 <minix3_alloc_zone+0x62>
        warnf("minix3_alloc_zone: Couldn't take zone %u\n", free_zone);
    800150ec:	fec42783          	lw	a5,-20(s0)
    800150f0:	85be                	mv	a1,a5
    800150f2:	0000f517          	auipc	a0,0xf
    800150f6:	78650513          	addi	a0,a0,1926 # 80024878 <pow10.0+0x648>
    800150fa:	106040ef          	jal	ra,80019200 <warnf>
        return 0;
    800150fe:	4781                	li	a5,0
    80015100:	a019                	j	80015106 <minix3_alloc_zone+0x66>
    }
    return free_zone;
    80015102:	fec42783          	lw	a5,-20(s0)
}
    80015106:	853e                	mv	a0,a5
    80015108:	70a2                	ld	ra,40(sp)
    8001510a:	7402                	ld	s0,32(sp)
    8001510c:	6145                	addi	sp,sp,48
    8001510e:	8082                	ret

0000000080015110 <minix3_is_dir>:

bool minix3_is_dir(VirtioDevice *block_device, uint32_t inode) {
    80015110:	711d                	addi	sp,sp,-96
    80015112:	ec86                	sd	ra,88(sp)
    80015114:	e8a2                	sd	s0,80(sp)
    80015116:	1080                	addi	s0,sp,96
    80015118:	faa43423          	sd	a0,-88(s0)
    8001511c:	87ae                	mv	a5,a1
    8001511e:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    80015122:	fb040793          	addi	a5,s0,-80
    80015126:	fa442703          	lw	a4,-92(s0)
    8001512a:	863a                	mv	a2,a4
    8001512c:	fa843583          	ld	a1,-88(s0)
    80015130:	853e                	mv	a0,a5
    80015132:	cadff0ef          	jal	ra,80014dde <minix3_get_inode>
    if (inode_data.num_links == 0) {
    80015136:	fb245783          	lhu	a5,-78(s0)
    8001513a:	eb91                	bnez	a5,8001514e <minix3_is_dir+0x3e>
        warnf("minix3_is_dir: Inode %u has no links\n", inode);
    8001513c:	fa442783          	lw	a5,-92(s0)
    80015140:	85be                	mv	a1,a5
    80015142:	0000f517          	auipc	a0,0xf
    80015146:	76650513          	addi	a0,a0,1894 # 800248a8 <pow10.0+0x678>
    8001514a:	0b6040ef          	jal	ra,80019200 <warnf>
    }
    return S_ISDIR(inode_data.mode) && inode_data.num_links > 0;
    8001514e:	fb045783          	lhu	a5,-80(s0)
    80015152:	0007871b          	sext.w	a4,a5
    80015156:	67bd                	lui	a5,0xf
    80015158:	8ff9                	and	a5,a5,a4
    8001515a:	2781                	sext.w	a5,a5
    8001515c:	873e                	mv	a4,a5
    8001515e:	6791                	lui	a5,0x4
    80015160:	00f71763          	bne	a4,a5,8001516e <minix3_is_dir+0x5e>
    80015164:	fb245783          	lhu	a5,-78(s0)
    80015168:	c399                	beqz	a5,8001516e <minix3_is_dir+0x5e>
    8001516a:	4785                	li	a5,1
    8001516c:	a011                	j	80015170 <minix3_is_dir+0x60>
    8001516e:	4781                	li	a5,0
    80015170:	8b85                	andi	a5,a5,1
    80015172:	0ff7f793          	andi	a5,a5,255
}
    80015176:	853e                	mv	a0,a5
    80015178:	60e6                	ld	ra,88(sp)
    8001517a:	6446                	ld	s0,80(sp)
    8001517c:	6125                	addi	sp,sp,96
    8001517e:	8082                	ret

0000000080015180 <minix3_is_file>:

bool minix3_is_file(VirtioDevice *block_device, uint32_t inode) {
    80015180:	711d                	addi	sp,sp,-96
    80015182:	ec86                	sd	ra,88(sp)
    80015184:	e8a2                	sd	s0,80(sp)
    80015186:	1080                	addi	s0,sp,96
    80015188:	faa43423          	sd	a0,-88(s0)
    8001518c:	87ae                	mv	a5,a1
    8001518e:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    80015192:	fb040793          	addi	a5,s0,-80
    80015196:	fa442703          	lw	a4,-92(s0)
    8001519a:	863a                	mv	a2,a4
    8001519c:	fa843583          	ld	a1,-88(s0)
    800151a0:	853e                	mv	a0,a5
    800151a2:	c3dff0ef          	jal	ra,80014dde <minix3_get_inode>
    if (inode_data.num_links == 0) {
    800151a6:	fb245783          	lhu	a5,-78(s0)
    800151aa:	eb91                	bnez	a5,800151be <minix3_is_file+0x3e>
        warnf("minix3_is_file: Inode %u has no links\n", inode);
    800151ac:	fa442783          	lw	a5,-92(s0)
    800151b0:	85be                	mv	a1,a5
    800151b2:	0000f517          	auipc	a0,0xf
    800151b6:	71e50513          	addi	a0,a0,1822 # 800248d0 <pow10.0+0x6a0>
    800151ba:	046040ef          	jal	ra,80019200 <warnf>
    }
    return S_ISREG(inode_data.mode) && inode_data.num_links > 0;
    800151be:	fb045783          	lhu	a5,-80(s0)
    800151c2:	0007871b          	sext.w	a4,a5
    800151c6:	67bd                	lui	a5,0xf
    800151c8:	8ff9                	and	a5,a5,a4
    800151ca:	2781                	sext.w	a5,a5
    800151cc:	873e                	mv	a4,a5
    800151ce:	67a1                	lui	a5,0x8
    800151d0:	00f71763          	bne	a4,a5,800151de <minix3_is_file+0x5e>
    800151d4:	fb245783          	lhu	a5,-78(s0)
    800151d8:	c399                	beqz	a5,800151de <minix3_is_file+0x5e>
    800151da:	4785                	li	a5,1
    800151dc:	a011                	j	800151e0 <minix3_is_file+0x60>
    800151de:	4781                	li	a5,0
    800151e0:	8b85                	andi	a5,a5,1
    800151e2:	0ff7f793          	andi	a5,a5,255
}
    800151e6:	853e                	mv	a0,a5
    800151e8:	60e6                	ld	ra,88(sp)
    800151ea:	6446                	ld	s0,80(sp)
    800151ec:	6125                	addi	sp,sp,96
    800151ee:	8082                	ret

00000000800151f0 <minix3_is_block_device>:

bool minix3_is_block_device(VirtioDevice *block_device, uint32_t inode) {
    800151f0:	711d                	addi	sp,sp,-96
    800151f2:	ec86                	sd	ra,88(sp)
    800151f4:	e8a2                	sd	s0,80(sp)
    800151f6:	1080                	addi	s0,sp,96
    800151f8:	faa43423          	sd	a0,-88(s0)
    800151fc:	87ae                	mv	a5,a1
    800151fe:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    80015202:	fb040793          	addi	a5,s0,-80
    80015206:	fa442703          	lw	a4,-92(s0)
    8001520a:	863a                	mv	a2,a4
    8001520c:	fa843583          	ld	a1,-88(s0)
    80015210:	853e                	mv	a0,a5
    80015212:	bcdff0ef          	jal	ra,80014dde <minix3_get_inode>
    if (inode_data.num_links == 0) {
    80015216:	fb245783          	lhu	a5,-78(s0)
    8001521a:	eb91                	bnez	a5,8001522e <minix3_is_block_device+0x3e>
        warnf("minix3_is_block_device: Inode %u has no links\n", inode);
    8001521c:	fa442783          	lw	a5,-92(s0)
    80015220:	85be                	mv	a1,a5
    80015222:	0000f517          	auipc	a0,0xf
    80015226:	6d650513          	addi	a0,a0,1750 # 800248f8 <pow10.0+0x6c8>
    8001522a:	7d7030ef          	jal	ra,80019200 <warnf>
    }
    return S_ISBLK(inode_data.mode) && inode_data.num_links > 0;
    8001522e:	fb045783          	lhu	a5,-80(s0)
    80015232:	0007871b          	sext.w	a4,a5
    80015236:	67bd                	lui	a5,0xf
    80015238:	8ff9                	and	a5,a5,a4
    8001523a:	2781                	sext.w	a5,a5
    8001523c:	873e                	mv	a4,a5
    8001523e:	6799                	lui	a5,0x6
    80015240:	00f71763          	bne	a4,a5,8001524e <minix3_is_block_device+0x5e>
    80015244:	fb245783          	lhu	a5,-78(s0)
    80015248:	c399                	beqz	a5,8001524e <minix3_is_block_device+0x5e>
    8001524a:	4785                	li	a5,1
    8001524c:	a011                	j	80015250 <minix3_is_block_device+0x60>
    8001524e:	4781                	li	a5,0
    80015250:	8b85                	andi	a5,a5,1
    80015252:	0ff7f793          	andi	a5,a5,255
}
    80015256:	853e                	mv	a0,a5
    80015258:	60e6                	ld	ra,88(sp)
    8001525a:	6446                	ld	s0,80(sp)
    8001525c:	6125                	addi	sp,sp,96
    8001525e:	8082                	ret

0000000080015260 <minix3_read_file>:

void minix3_read_file(VirtioDevice *block_device, uint32_t inode, uint8_t *data, uint32_t count) {
    80015260:	7179                	addi	sp,sp,-48
    80015262:	f406                	sd	ra,40(sp)
    80015264:	f022                	sd	s0,32(sp)
    80015266:	1800                	addi	s0,sp,48
    80015268:	fea43423          	sd	a0,-24(s0)
    8001526c:	87ae                	mv	a5,a1
    8001526e:	fcc43c23          	sd	a2,-40(s0)
    80015272:	8736                	mv	a4,a3
    80015274:	fef42223          	sw	a5,-28(s0)
    80015278:	87ba                	mv	a5,a4
    8001527a:	fef42023          	sw	a5,-32(s0)
    minix3_get_data(block_device, inode, data, 0, count);
    8001527e:	fe042703          	lw	a4,-32(s0)
    80015282:	fe442783          	lw	a5,-28(s0)
    80015286:	4681                	li	a3,0
    80015288:	fd843603          	ld	a2,-40(s0)
    8001528c:	85be                	mv	a1,a5
    8001528e:	fe843503          	ld	a0,-24(s0)
    80015292:	00e000ef          	jal	ra,800152a0 <minix3_get_data>
}
    80015296:	0001                	nop
    80015298:	70a2                	ld	ra,40(sp)
    8001529a:	7402                	ld	s0,32(sp)
    8001529c:	6145                	addi	sp,sp,48
    8001529e:	8082                	ret

00000000800152a0 <minix3_get_data>:

void minix3_get_data(VirtioDevice *block_device, uint32_t inode, uint8_t *data, uint32_t offset, uint32_t count) {
    800152a0:	cd010113          	addi	sp,sp,-816
    800152a4:	32113423          	sd	ra,808(sp)
    800152a8:	32813023          	sd	s0,800(sp)
    800152ac:	30913c23          	sd	s1,792(sp)
    800152b0:	31213823          	sd	s2,784(sp)
    800152b4:	31313423          	sd	s3,776(sp)
    800152b8:	31413023          	sd	s4,768(sp)
    800152bc:	2f513c23          	sd	s5,760(sp)
    800152c0:	2f613823          	sd	s6,752(sp)
    800152c4:	2f713423          	sd	s7,744(sp)
    800152c8:	2f813023          	sd	s8,736(sp)
    800152cc:	2d913c23          	sd	s9,728(sp)
    800152d0:	2da13823          	sd	s10,720(sp)
    800152d4:	2db13423          	sd	s11,712(sp)
    800152d8:	1e00                	addi	s0,sp,816
    800152da:	e6a43423          	sd	a0,-408(s0)
    800152de:	87ae                	mv	a5,a1
    800152e0:	e4c43c23          	sd	a2,-424(s0)
    800152e4:	e6f42223          	sw	a5,-412(s0)
    800152e8:	87b6                	mv	a5,a3
    800152ea:	e6f42023          	sw	a5,-416(s0)
    800152ee:	87ba                	mv	a5,a4
    800152f0:	e4f42a23          	sw	a5,-428(s0)
    800152f4:	878a                	mv	a5,sp
    800152f6:	ccf43c23          	sd	a5,-808(s0)
    debugf("minix3_get_data: Getting data from inode %u, offset %u, count %u\n", inode, offset, count);
    // First, get the inode
    Inode inode_data = minix3_get_inode(block_device, inode);
    800152fa:	e7840713          	addi	a4,s0,-392
    800152fe:	e6442783          	lw	a5,-412(s0)
    80015302:	863e                	mv	a2,a5
    80015304:	e6843583          	ld	a1,-408(s0)
    80015308:	853a                	mv	a0,a4
    8001530a:	ad5ff0ef          	jal	ra,80014dde <minix3_get_inode>
    

    uint8_t zone_data[minix3_get_zone_size(block_device)];
    8001530e:	e6843503          	ld	a0,-408(s0)
    80015312:	c4cff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015316:	87aa                	mv	a5,a0
    80015318:	873e                	mv	a4,a5
    8001531a:	87ba                	mv	a5,a4
    8001531c:	17fd                	addi	a5,a5,-1
    8001531e:	f6f43c23          	sd	a5,-136(s0)
    80015322:	e4e43023          	sd	a4,-448(s0)
    80015326:	e4043423          	sd	zero,-440(s0)
    8001532a:	e4043783          	ld	a5,-448(s0)
    8001532e:	93f5                	srli	a5,a5,0x3d
    80015330:	e4843683          	ld	a3,-440(s0)
    80015334:	068e                	slli	a3,a3,0x3
    80015336:	d6d43423          	sd	a3,-664(s0)
    8001533a:	d6843683          	ld	a3,-664(s0)
    8001533e:	8fd5                	or	a5,a5,a3
    80015340:	d6f43423          	sd	a5,-664(s0)
    80015344:	e4043783          	ld	a5,-448(s0)
    80015348:	078e                	slli	a5,a5,0x3
    8001534a:	d6f43023          	sd	a5,-672(s0)
    8001534e:	e2e43823          	sd	a4,-464(s0)
    80015352:	e2043c23          	sd	zero,-456(s0)
    80015356:	e3043783          	ld	a5,-464(s0)
    8001535a:	93f5                	srli	a5,a5,0x3d
    8001535c:	e3843683          	ld	a3,-456(s0)
    80015360:	00369993          	slli	s3,a3,0x3
    80015364:	0137e9b3          	or	s3,a5,s3
    80015368:	e3043783          	ld	a5,-464(s0)
    8001536c:	00379913          	slli	s2,a5,0x3
    80015370:	87ba                	mv	a5,a4
    80015372:	07bd                	addi	a5,a5,15
    80015374:	8391                	srli	a5,a5,0x4
    80015376:	0792                	slli	a5,a5,0x4
    80015378:	40f10133          	sub	sp,sp,a5
    8001537c:	878a                	mv	a5,sp
    8001537e:	00078793          	mv	a5,a5
    80015382:	f6f43823          	sd	a5,-144(s0)

    // The cursor is the current position in the data buffer
    uint32_t buffer_cursor = 0;
    80015386:	f8042223          	sw	zero,-124(s0)
    uint32_t file_cursor = 0;
    8001538a:	f8042423          	sw	zero,-120(s0)

    // Now, get the data
    // The first 7 zones are direct zones
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    8001538e:	f80406a3          	sb	zero,-115(s0)
    80015392:	aaf1                	j	8001556e <minix3_get_data+0x2ce>
        uint32_t zone = inode_data.zones[direct_zone];
    80015394:	f8d44783          	lbu	a5,-115(s0)
    80015398:	2781                	sext.w	a5,a5
    8001539a:	0791                	addi	a5,a5,4
    8001539c:	078a                	slli	a5,a5,0x2
    8001539e:	f9040713          	addi	a4,s0,-112
    800153a2:	97ba                	add	a5,a5,a4
    800153a4:	ef07a783          	lw	a5,-272(a5) # 5ef0 <i+0x5ed0>
    800153a8:	ecf42223          	sw	a5,-316(s0)
        if (zone == 0) {
    800153ac:	ec442783          	lw	a5,-316(s0)
    800153b0:	2781                	sext.w	a5,a5
    800153b2:	1a078863          	beqz	a5,80015562 <minix3_get_data+0x2c2>
            debugf("No direct zone %d\n", zone);
            continue;
        } else {
            debugf("Direct zone %d\n", zone);
        }
        memset(zone_data, 0, minix3_get_zone_size(block_device));
    800153b6:	e6843503          	ld	a0,-408(s0)
    800153ba:	ba4ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800153be:	87aa                	mv	a5,a0
    800153c0:	2781                	sext.w	a5,a5
    800153c2:	863e                	mv	a2,a5
    800153c4:	4581                	li	a1,0
    800153c6:	f7043503          	ld	a0,-144(s0)
    800153ca:	1a30a0ef          	jal	ra,8001fd6c <memset>

        if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    800153ce:	e6843503          	ld	a0,-408(s0)
    800153d2:	b8cff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800153d6:	87aa                	mv	a5,a0
    800153d8:	2781                	sext.w	a5,a5
    800153da:	f8842703          	lw	a4,-120(s0)
    800153de:	9fb9                	addw	a5,a5,a4
    800153e0:	0007871b          	sext.w	a4,a5
    800153e4:	e6042783          	lw	a5,-416(s0)
    800153e8:	2781                	sext.w	a5,a5
    800153ea:	00f77e63          	bgeu	a4,a5,80015406 <minix3_get_data+0x166>
            // We're not at the offset yet
            file_cursor += minix3_get_zone_size(block_device);
    800153ee:	e6843503          	ld	a0,-408(s0)
    800153f2:	b6cff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800153f6:	87aa                	mv	a5,a0
    800153f8:	2781                	sext.w	a5,a5
    800153fa:	f8842703          	lw	a4,-120(s0)
    800153fe:	9fb9                	addw	a5,a5,a4
    80015400:	f8f42423          	sw	a5,-120(s0)
            continue;
    80015404:	a285                	j	80015564 <minix3_get_data+0x2c4>
        } else if (file_cursor < offset) {
    80015406:	f8842703          	lw	a4,-120(s0)
    8001540a:	e6042783          	lw	a5,-416(s0)
    8001540e:	2701                	sext.w	a4,a4
    80015410:	2781                	sext.w	a5,a5
    80015412:	0af77b63          	bgeu	a4,a5,800154c8 <minix3_get_data+0x228>
            // We're in the middle of the offset
            // Read the zone into the buffer
            debugf("Reading first direct zone %d\n", zone);
            minix3_get_zone(block_device, zone, zone_data);
    80015416:	ec442783          	lw	a5,-316(s0)
    8001541a:	f7043603          	ld	a2,-144(s0)
    8001541e:	85be                	mv	a1,a5
    80015420:	e6843503          	ld	a0,-408(s0)
    80015424:	e99fe0ef          	jal	ra,800142bc <minix3_get_zone>
            // Copy the remaining data into the buffer
            size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80015428:	e6843503          	ld	a0,-408(s0)
    8001542c:	b32ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015430:	87aa                	mv	a5,a0
    80015432:	0007871b          	sext.w	a4,a5
    80015436:	f8842683          	lw	a3,-120(s0)
    8001543a:	e6042783          	lw	a5,-416(s0)
    8001543e:	40f687bb          	subw	a5,a3,a5
    80015442:	2781                	sext.w	a5,a5
    80015444:	9fb9                	addw	a5,a5,a4
    80015446:	0007871b          	sext.w	a4,a5
    8001544a:	e5442783          	lw	a5,-428(s0)
    8001544e:	2781                	sext.w	a5,a5
    80015450:	02e7e563          	bltu	a5,a4,8001547a <minix3_get_data+0x1da>
    80015454:	e6843503          	ld	a0,-408(s0)
    80015458:	b06ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001545c:	87aa                	mv	a5,a0
    8001545e:	0007871b          	sext.w	a4,a5
    80015462:	f8842683          	lw	a3,-120(s0)
    80015466:	e6042783          	lw	a5,-416(s0)
    8001546a:	40f687bb          	subw	a5,a3,a5
    8001546e:	2781                	sext.w	a5,a5
    80015470:	9fb9                	addw	a5,a5,a4
    80015472:	2781                	sext.w	a5,a5
    80015474:	1782                	slli	a5,a5,0x20
    80015476:	9381                	srli	a5,a5,0x20
    80015478:	a019                	j	8001547e <minix3_get_data+0x1de>
    8001547a:	e5446783          	lwu	a5,-428(s0)
    8001547e:	eaf43c23          	sd	a5,-328(s0)
            memcpy(data, zone_data + offset - file_cursor, remaining);
    80015482:	e6046703          	lwu	a4,-416(s0)
    80015486:	f8846783          	lwu	a5,-120(s0)
    8001548a:	40f707b3          	sub	a5,a4,a5
    8001548e:	f7043703          	ld	a4,-144(s0)
    80015492:	97ba                	add	a5,a5,a4
    80015494:	eb843703          	ld	a4,-328(s0)
    80015498:	2701                	sext.w	a4,a4
    8001549a:	863a                	mv	a2,a4
    8001549c:	85be                	mv	a1,a5
    8001549e:	e5843503          	ld	a0,-424(s0)
    800154a2:	1cd0a0ef          	jal	ra,8001fe6e <memcpy>
            buffer_cursor += remaining;
    800154a6:	eb843783          	ld	a5,-328(s0)
    800154aa:	2781                	sext.w	a5,a5
    800154ac:	f8442703          	lw	a4,-124(s0)
    800154b0:	9fb9                	addw	a5,a5,a4
    800154b2:	f8f42223          	sw	a5,-124(s0)
            file_cursor = offset + remaining;
    800154b6:	eb843783          	ld	a5,-328(s0)
    800154ba:	2781                	sext.w	a5,a5
    800154bc:	e6042703          	lw	a4,-416(s0)
    800154c0:	9fb9                	addw	a5,a5,a4
    800154c2:	f8f42423          	sw	a5,-120(s0)
            continue;
    800154c6:	a879                	j	80015564 <minix3_get_data+0x2c4>
        }

        // Read the zone into the buffer
        minix3_get_zone(block_device, zone, zone_data);
    800154c8:	ec442783          	lw	a5,-316(s0)
    800154cc:	f7043603          	ld	a2,-144(s0)
    800154d0:	85be                	mv	a1,a5
    800154d2:	e6843503          	ld	a0,-408(s0)
    800154d6:	de7fe0ef          	jal	ra,800142bc <minix3_get_zone>

        // If the cursor is past the amount of data we want, we're done
        if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    800154da:	e6843503          	ld	a0,-408(s0)
    800154de:	a80ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800154e2:	87aa                	mv	a5,a0
    800154e4:	2781                	sext.w	a5,a5
    800154e6:	f8442703          	lw	a4,-124(s0)
    800154ea:	9fb9                	addw	a5,a5,a4
    800154ec:	0007871b          	sext.w	a4,a5
    800154f0:	e5442783          	lw	a5,-428(s0)
    800154f4:	2781                	sext.w	a5,a5
    800154f6:	02e7f863          	bgeu	a5,a4,80015526 <minix3_get_data+0x286>
            debugf("Reading last direct zone %d\n", zone);
            // Copy the remaining data into the buffer
            memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    800154fa:	f8446783          	lwu	a5,-124(s0)
    800154fe:	e5843703          	ld	a4,-424(s0)
    80015502:	00f706b3          	add	a3,a4,a5
    80015506:	e5442703          	lw	a4,-428(s0)
    8001550a:	f8442783          	lw	a5,-124(s0)
    8001550e:	40f707bb          	subw	a5,a4,a5
    80015512:	2781                	sext.w	a5,a5
    80015514:	2781                	sext.w	a5,a5
    80015516:	863e                	mv	a2,a5
    80015518:	f7043583          	ld	a1,-144(s0)
    8001551c:	8536                	mv	a0,a3
    8001551e:	1510a0ef          	jal	ra,8001fe6e <memcpy>
            // We're done
            return;
    80015522:	32f0006f          	j	80016050 <minix3_get_data+0xdb0>
        } else {
            debugf("Reading direct zone %d\n", zone);
            // Copy the entire zone into the buffer
            memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    80015526:	f8446783          	lwu	a5,-124(s0)
    8001552a:	e5843703          	ld	a4,-424(s0)
    8001552e:	00f704b3          	add	s1,a4,a5
    80015532:	e6843503          	ld	a0,-408(s0)
    80015536:	a28ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001553a:	87aa                	mv	a5,a0
    8001553c:	2781                	sext.w	a5,a5
    8001553e:	863e                	mv	a2,a5
    80015540:	f7043583          	ld	a1,-144(s0)
    80015544:	8526                	mv	a0,s1
    80015546:	1290a0ef          	jal	ra,8001fe6e <memcpy>
        }
        buffer_cursor += minix3_get_zone_size(block_device);
    8001554a:	e6843503          	ld	a0,-408(s0)
    8001554e:	a10ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015552:	87aa                	mv	a5,a0
    80015554:	2781                	sext.w	a5,a5
    80015556:	f8442703          	lw	a4,-124(s0)
    8001555a:	9fb9                	addw	a5,a5,a4
    8001555c:	f8f42223          	sw	a5,-124(s0)
    80015560:	a011                	j	80015564 <minix3_get_data+0x2c4>
            continue;
    80015562:	0001                	nop
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80015564:	f8d44783          	lbu	a5,-115(s0)
    80015568:	2785                	addiw	a5,a5,1
    8001556a:	f8f406a3          	sb	a5,-115(s0)
    8001556e:	f8d44783          	lbu	a5,-115(s0)
    80015572:	0ff7f713          	andi	a4,a5,255
    80015576:	4799                	li	a5,6
    80015578:	e0e7fee3          	bgeu	a5,a4,80015394 <minix3_get_data+0xf4>
    }

    debugf("Done with direct zones\n");
    // The next zone is an indirect zone
    if (inode_data.zones[7] != 0) {
    8001557c:	eac42783          	lw	a5,-340(s0)
    80015580:	2a078563          	beqz	a5,8001582a <minix3_get_data+0x58a>
    80015584:	878a                	mv	a5,sp
    80015586:	893e                	mv	s2,a5
        debugf("Reading indirect zone %d\n", inode_data.zones[7]);
        uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80015588:	e6843503          	ld	a0,-408(s0)
    8001558c:	9d2ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015590:	87aa                	mv	a5,a0
    80015592:	0027d79b          	srliw	a5,a5,0x2
    80015596:	17c2                	slli	a5,a5,0x30
    80015598:	93c1                	srli	a5,a5,0x30
    8001559a:	873e                	mv	a4,a5
    8001559c:	177d                	addi	a4,a4,-1
    8001559e:	f6e43423          	sd	a4,-152(s0)
    800155a2:	e2f43023          	sd	a5,-480(s0)
    800155a6:	e2043423          	sd	zero,-472(s0)
    800155aa:	e2043703          	ld	a4,-480(s0)
    800155ae:	936d                	srli	a4,a4,0x3b
    800155b0:	e2843683          	ld	a3,-472(s0)
    800155b4:	0696                	slli	a3,a3,0x5
    800155b6:	d4d43c23          	sd	a3,-680(s0)
    800155ba:	d5843683          	ld	a3,-680(s0)
    800155be:	8f55                	or	a4,a4,a3
    800155c0:	d4e43c23          	sd	a4,-680(s0)
    800155c4:	e2043703          	ld	a4,-480(s0)
    800155c8:	0716                	slli	a4,a4,0x5
    800155ca:	d4e43823          	sd	a4,-688(s0)
    800155ce:	e0f43823          	sd	a5,-496(s0)
    800155d2:	e0043c23          	sd	zero,-488(s0)
    800155d6:	e1043703          	ld	a4,-496(s0)
    800155da:	936d                	srli	a4,a4,0x3b
    800155dc:	e1843683          	ld	a3,-488(s0)
    800155e0:	0696                	slli	a3,a3,0x5
    800155e2:	d4d43423          	sd	a3,-696(s0)
    800155e6:	d4843683          	ld	a3,-696(s0)
    800155ea:	8f55                	or	a4,a4,a3
    800155ec:	d4e43423          	sd	a4,-696(s0)
    800155f0:	e1043703          	ld	a4,-496(s0)
    800155f4:	0716                	slli	a4,a4,0x5
    800155f6:	d4e43023          	sd	a4,-704(s0)
    800155fa:	078a                	slli	a5,a5,0x2
    800155fc:	07bd                	addi	a5,a5,15
    800155fe:	8391                	srli	a5,a5,0x4
    80015600:	0792                	slli	a5,a5,0x4
    80015602:	40f10133          	sub	sp,sp,a5
    80015606:	878a                	mv	a5,sp
    80015608:	078d                	addi	a5,a5,3
    8001560a:	8389                	srli	a5,a5,0x2
    8001560c:	078a                	slli	a5,a5,0x2
    8001560e:	f6f43023          	sd	a5,-160(s0)
        minix3_get_zone(block_device, inode_data.zones[7], (uint8_t*)indirect_zones);
    80015612:	eac42783          	lw	a5,-340(s0)
    80015616:	f6043603          	ld	a2,-160(s0)
    8001561a:	85be                	mv	a1,a5
    8001561c:	e6843503          	ld	a0,-408(s0)
    80015620:	c9dfe0ef          	jal	ra,800142bc <minix3_get_zone>
        

        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80015624:	f8040723          	sb	zero,-114(s0)
    80015628:	aae9                	j	80015802 <minix3_get_data+0x562>
            uint32_t zone = indirect_zones[indirect_zone];
    8001562a:	f8e44783          	lbu	a5,-114(s0)
    8001562e:	2781                	sext.w	a5,a5
    80015630:	f6043703          	ld	a4,-160(s0)
    80015634:	078a                	slli	a5,a5,0x2
    80015636:	97ba                	add	a5,a5,a4
    80015638:	439c                	lw	a5,0(a5)
    8001563a:	f4f42e23          	sw	a5,-164(s0)
            debugf("Reading indirect zone %d\n", zone);
            if (zone == 0) continue;
    8001563e:	f5c42783          	lw	a5,-164(s0)
    80015642:	2781                	sext.w	a5,a5
    80015644:	1a078963          	beqz	a5,800157f6 <minix3_get_data+0x556>
            

            if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80015648:	e6843503          	ld	a0,-408(s0)
    8001564c:	912ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015650:	87aa                	mv	a5,a0
    80015652:	2781                	sext.w	a5,a5
    80015654:	f8842703          	lw	a4,-120(s0)
    80015658:	9fb9                	addw	a5,a5,a4
    8001565a:	0007871b          	sext.w	a4,a5
    8001565e:	e6042783          	lw	a5,-416(s0)
    80015662:	2781                	sext.w	a5,a5
    80015664:	00f77e63          	bgeu	a4,a5,80015680 <minix3_get_data+0x3e0>
                // We're not at the offset yet
                file_cursor += minix3_get_zone_size(block_device);
    80015668:	e6843503          	ld	a0,-408(s0)
    8001566c:	8f2ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015670:	87aa                	mv	a5,a0
    80015672:	2781                	sext.w	a5,a5
    80015674:	f8842703          	lw	a4,-120(s0)
    80015678:	9fb9                	addw	a5,a5,a4
    8001567a:	f8f42423          	sw	a5,-120(s0)
                continue;
    8001567e:	aaad                	j	800157f8 <minix3_get_data+0x558>
            } else if (file_cursor < offset) {
    80015680:	f8842703          	lw	a4,-120(s0)
    80015684:	e6042783          	lw	a5,-416(s0)
    80015688:	2701                	sext.w	a4,a4
    8001568a:	2781                	sext.w	a5,a5
    8001568c:	0af77b63          	bgeu	a4,a5,80015742 <minix3_get_data+0x4a2>
                // We're in the middle of the offset
                // Read the zone into the buffer
                minix3_get_zone(block_device, zone, zone_data);
    80015690:	f5c42783          	lw	a5,-164(s0)
    80015694:	f7043603          	ld	a2,-144(s0)
    80015698:	85be                	mv	a1,a5
    8001569a:	e6843503          	ld	a0,-408(s0)
    8001569e:	c1ffe0ef          	jal	ra,800142bc <minix3_get_zone>
                // Copy the remaining data into the buffer
                size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    800156a2:	e6843503          	ld	a0,-408(s0)
    800156a6:	8b8ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800156aa:	87aa                	mv	a5,a0
    800156ac:	0007871b          	sext.w	a4,a5
    800156b0:	f8842683          	lw	a3,-120(s0)
    800156b4:	e6042783          	lw	a5,-416(s0)
    800156b8:	40f687bb          	subw	a5,a3,a5
    800156bc:	2781                	sext.w	a5,a5
    800156be:	9fb9                	addw	a5,a5,a4
    800156c0:	0007871b          	sext.w	a4,a5
    800156c4:	e5442783          	lw	a5,-428(s0)
    800156c8:	2781                	sext.w	a5,a5
    800156ca:	02e7e563          	bltu	a5,a4,800156f4 <minix3_get_data+0x454>
    800156ce:	e6843503          	ld	a0,-408(s0)
    800156d2:	88cff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800156d6:	87aa                	mv	a5,a0
    800156d8:	0007871b          	sext.w	a4,a5
    800156dc:	f8842683          	lw	a3,-120(s0)
    800156e0:	e6042783          	lw	a5,-416(s0)
    800156e4:	40f687bb          	subw	a5,a3,a5
    800156e8:	2781                	sext.w	a5,a5
    800156ea:	9fb9                	addw	a5,a5,a4
    800156ec:	2781                	sext.w	a5,a5
    800156ee:	1782                	slli	a5,a5,0x20
    800156f0:	9381                	srli	a5,a5,0x20
    800156f2:	a019                	j	800156f8 <minix3_get_data+0x458>
    800156f4:	e5446783          	lwu	a5,-428(s0)
    800156f8:	f4f43823          	sd	a5,-176(s0)
                memcpy(data, zone_data + offset - file_cursor, remaining);
    800156fc:	e6046703          	lwu	a4,-416(s0)
    80015700:	f8846783          	lwu	a5,-120(s0)
    80015704:	40f707b3          	sub	a5,a4,a5
    80015708:	f7043703          	ld	a4,-144(s0)
    8001570c:	97ba                	add	a5,a5,a4
    8001570e:	f5043703          	ld	a4,-176(s0)
    80015712:	2701                	sext.w	a4,a4
    80015714:	863a                	mv	a2,a4
    80015716:	85be                	mv	a1,a5
    80015718:	e5843503          	ld	a0,-424(s0)
    8001571c:	7520a0ef          	jal	ra,8001fe6e <memcpy>
                buffer_cursor += remaining;
    80015720:	f5043783          	ld	a5,-176(s0)
    80015724:	2781                	sext.w	a5,a5
    80015726:	f8442703          	lw	a4,-124(s0)
    8001572a:	9fb9                	addw	a5,a5,a4
    8001572c:	f8f42223          	sw	a5,-124(s0)
                file_cursor = offset + remaining;
    80015730:	f5043783          	ld	a5,-176(s0)
    80015734:	2781                	sext.w	a5,a5
    80015736:	e6042703          	lw	a4,-416(s0)
    8001573a:	9fb9                	addw	a5,a5,a4
    8001573c:	f8f42423          	sw	a5,-120(s0)
                continue;
    80015740:	a865                	j	800157f8 <minix3_get_data+0x558>
            }
            
            memset(zone_data, 0, minix3_get_zone_size(block_device));
    80015742:	e6843503          	ld	a0,-408(s0)
    80015746:	818ff0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001574a:	87aa                	mv	a5,a0
    8001574c:	2781                	sext.w	a5,a5
    8001574e:	863e                	mv	a2,a5
    80015750:	4581                	li	a1,0
    80015752:	f7043503          	ld	a0,-144(s0)
    80015756:	6160a0ef          	jal	ra,8001fd6c <memset>

            // Read the zone into the buffer
            minix3_get_zone(block_device, zone, zone_data);
    8001575a:	f5c42783          	lw	a5,-164(s0)
    8001575e:	f7043603          	ld	a2,-144(s0)
    80015762:	85be                	mv	a1,a5
    80015764:	e6843503          	ld	a0,-408(s0)
    80015768:	b55fe0ef          	jal	ra,800142bc <minix3_get_zone>
            // If the cursor is past the amount of data we want, we're done
            if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    8001576c:	e6843503          	ld	a0,-408(s0)
    80015770:	feffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015774:	87aa                	mv	a5,a0
    80015776:	2781                	sext.w	a5,a5
    80015778:	f8442703          	lw	a4,-124(s0)
    8001577c:	9fb9                	addw	a5,a5,a4
    8001577e:	0007871b          	sext.w	a4,a5
    80015782:	e5442783          	lw	a5,-428(s0)
    80015786:	2781                	sext.w	a5,a5
    80015788:	02e7f963          	bgeu	a5,a4,800157ba <minix3_get_data+0x51a>
                // Copy the remaining data into the buffer
                memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    8001578c:	f8446783          	lwu	a5,-124(s0)
    80015790:	e5843703          	ld	a4,-424(s0)
    80015794:	00f706b3          	add	a3,a4,a5
    80015798:	e5442703          	lw	a4,-428(s0)
    8001579c:	f8442783          	lw	a5,-124(s0)
    800157a0:	40f707bb          	subw	a5,a4,a5
    800157a4:	2781                	sext.w	a5,a5
    800157a6:	2781                	sext.w	a5,a5
    800157a8:	863e                	mv	a2,a5
    800157aa:	f7043583          	ld	a1,-144(s0)
    800157ae:	8536                	mv	a0,a3
    800157b0:	6be0a0ef          	jal	ra,8001fe6e <memcpy>
    800157b4:	814a                	mv	sp,s2
    800157b6:	09b0006f          	j	80016050 <minix3_get_data+0xdb0>
                // We're done
                return;
            } else {
                // Copy the entire zone into the buffer
                memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    800157ba:	f8446783          	lwu	a5,-124(s0)
    800157be:	e5843703          	ld	a4,-424(s0)
    800157c2:	00f704b3          	add	s1,a4,a5
    800157c6:	e6843503          	ld	a0,-408(s0)
    800157ca:	f95fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800157ce:	87aa                	mv	a5,a0
    800157d0:	2781                	sext.w	a5,a5
    800157d2:	863e                	mv	a2,a5
    800157d4:	f7043583          	ld	a1,-144(s0)
    800157d8:	8526                	mv	a0,s1
    800157da:	6940a0ef          	jal	ra,8001fe6e <memcpy>
            }
            buffer_cursor += minix3_get_zone_size(block_device);
    800157de:	e6843503          	ld	a0,-408(s0)
    800157e2:	f7dfe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800157e6:	87aa                	mv	a5,a0
    800157e8:	2781                	sext.w	a5,a5
    800157ea:	f8442703          	lw	a4,-124(s0)
    800157ee:	9fb9                	addw	a5,a5,a4
    800157f0:	f8f42223          	sw	a5,-124(s0)
    800157f4:	a011                	j	800157f8 <minix3_get_data+0x558>
            if (zone == 0) continue;
    800157f6:	0001                	nop
        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    800157f8:	f8e44783          	lbu	a5,-114(s0)
    800157fc:	2785                	addiw	a5,a5,1
    800157fe:	f8f40723          	sb	a5,-114(s0)
    80015802:	f8e44783          	lbu	a5,-114(s0)
    80015806:	03079493          	slli	s1,a5,0x30
    8001580a:	90c1                	srli	s1,s1,0x30
    8001580c:	e6843503          	ld	a0,-408(s0)
    80015810:	f4ffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015814:	87aa                	mv	a5,a0
    80015816:	0027d79b          	srliw	a5,a5,0x2
    8001581a:	17c2                	slli	a5,a5,0x30
    8001581c:	93c1                	srli	a5,a5,0x30
    8001581e:	0004871b          	sext.w	a4,s1
    80015822:	2781                	sext.w	a5,a5
    80015824:	e0f763e3          	bltu	a4,a5,8001562a <minix3_get_data+0x38a>
    80015828:	814a                	mv	sp,s2
    } else {
        debugf("No indirect zone\n");
    }

    // The next zone is a double indirect zone
    if (inode_data.zones[8] != 0) {
    8001582a:	eb042783          	lw	a5,-336(s0)
    8001582e:	38078d63          	beqz	a5,80015bc8 <minix3_get_data+0x928>
    80015832:	878a                	mv	a5,sp
    80015834:	89be                	mv	s3,a5
        uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80015836:	e6843503          	ld	a0,-408(s0)
    8001583a:	f25fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001583e:	87aa                	mv	a5,a0
    80015840:	0027d79b          	srliw	a5,a5,0x2
    80015844:	17c2                	slli	a5,a5,0x30
    80015846:	93c1                	srli	a5,a5,0x30
    80015848:	873e                	mv	a4,a5
    8001584a:	177d                	addi	a4,a4,-1
    8001584c:	f4e43423          	sd	a4,-184(s0)
    80015850:	e0f43023          	sd	a5,-512(s0)
    80015854:	e0043423          	sd	zero,-504(s0)
    80015858:	e0043703          	ld	a4,-512(s0)
    8001585c:	936d                	srli	a4,a4,0x3b
    8001585e:	e0843683          	ld	a3,-504(s0)
    80015862:	0696                	slli	a3,a3,0x5
    80015864:	d2d43c23          	sd	a3,-712(s0)
    80015868:	d3843683          	ld	a3,-712(s0)
    8001586c:	8f55                	or	a4,a4,a3
    8001586e:	d2e43c23          	sd	a4,-712(s0)
    80015872:	e0043703          	ld	a4,-512(s0)
    80015876:	0716                	slli	a4,a4,0x5
    80015878:	d2e43823          	sd	a4,-720(s0)
    8001587c:	def43823          	sd	a5,-528(s0)
    80015880:	de043c23          	sd	zero,-520(s0)
    80015884:	df043703          	ld	a4,-528(s0)
    80015888:	936d                	srli	a4,a4,0x3b
    8001588a:	df843683          	ld	a3,-520(s0)
    8001588e:	0696                	slli	a3,a3,0x5
    80015890:	d2d43423          	sd	a3,-728(s0)
    80015894:	d2843683          	ld	a3,-728(s0)
    80015898:	8f55                	or	a4,a4,a3
    8001589a:	d2e43423          	sd	a4,-728(s0)
    8001589e:	df043703          	ld	a4,-528(s0)
    800158a2:	0716                	slli	a4,a4,0x5
    800158a4:	d2e43023          	sd	a4,-736(s0)
    800158a8:	078a                	slli	a5,a5,0x2
    800158aa:	07bd                	addi	a5,a5,15
    800158ac:	8391                	srli	a5,a5,0x4
    800158ae:	0792                	slli	a5,a5,0x4
    800158b0:	40f10133          	sub	sp,sp,a5
    800158b4:	878a                	mv	a5,sp
    800158b6:	078d                	addi	a5,a5,3
    800158b8:	8389                	srli	a5,a5,0x2
    800158ba:	078a                	slli	a5,a5,0x2
    800158bc:	f4f43023          	sd	a5,-192(s0)
        // We're done
        minix3_get_zone(block_device, inode_data.zones[8], (uint8_t*)double_indirect_zones);
    800158c0:	eb042783          	lw	a5,-336(s0)
    800158c4:	f4043603          	ld	a2,-192(s0)
    800158c8:	85be                	mv	a1,a5
    800158ca:	e6843503          	ld	a0,-408(s0)
    800158ce:	9effe0ef          	jal	ra,800142bc <minix3_get_zone>

        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    800158d2:	f80407a3          	sb	zero,-113(s0)
    800158d6:	a4e9                	j	80015ba0 <minix3_get_data+0x900>
    800158d8:	878a                	mv	a5,sp
    800158da:	84be                	mv	s1,a5
            uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    800158dc:	f8f44783          	lbu	a5,-113(s0)
    800158e0:	2781                	sext.w	a5,a5
    800158e2:	f4043703          	ld	a4,-192(s0)
    800158e6:	078a                	slli	a5,a5,0x2
    800158e8:	97ba                	add	a5,a5,a4
    800158ea:	439c                	lw	a5,0(a5)
    800158ec:	f2f42e23          	sw	a5,-196(s0)
            if (indirect_zone == 0) continue;
    800158f0:	f3c42783          	lw	a5,-196(s0)
    800158f4:	2781                	sext.w	a5,a5
    800158f6:	e399                	bnez	a5,800158fc <minix3_get_data+0x65c>
    800158f8:	8126                	mv	sp,s1
    800158fa:	ac71                	j	80015b96 <minix3_get_data+0x8f6>

            uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    800158fc:	e6843503          	ld	a0,-408(s0)
    80015900:	e5ffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015904:	87aa                	mv	a5,a0
    80015906:	0027d79b          	srliw	a5,a5,0x2
    8001590a:	17c2                	slli	a5,a5,0x30
    8001590c:	93c1                	srli	a5,a5,0x30
    8001590e:	873e                	mv	a4,a5
    80015910:	177d                	addi	a4,a4,-1
    80015912:	f2e43823          	sd	a4,-208(s0)
    80015916:	def43023          	sd	a5,-544(s0)
    8001591a:	de043423          	sd	zero,-536(s0)
    8001591e:	de043703          	ld	a4,-544(s0)
    80015922:	936d                	srli	a4,a4,0x3b
    80015924:	de843683          	ld	a3,-536(s0)
    80015928:	00569a93          	slli	s5,a3,0x5
    8001592c:	01576ab3          	or	s5,a4,s5
    80015930:	de043703          	ld	a4,-544(s0)
    80015934:	00571a13          	slli	s4,a4,0x5
    80015938:	dcf43823          	sd	a5,-560(s0)
    8001593c:	dc043c23          	sd	zero,-552(s0)
    80015940:	dd043703          	ld	a4,-560(s0)
    80015944:	936d                	srli	a4,a4,0x3b
    80015946:	dd843683          	ld	a3,-552(s0)
    8001594a:	0696                	slli	a3,a3,0x5
    8001594c:	d0d43c23          	sd	a3,-744(s0)
    80015950:	d1843683          	ld	a3,-744(s0)
    80015954:	8f55                	or	a4,a4,a3
    80015956:	d0e43c23          	sd	a4,-744(s0)
    8001595a:	dd043703          	ld	a4,-560(s0)
    8001595e:	0716                	slli	a4,a4,0x5
    80015960:	d0e43823          	sd	a4,-752(s0)
    80015964:	078a                	slli	a5,a5,0x2
    80015966:	07bd                	addi	a5,a5,15
    80015968:	8391                	srli	a5,a5,0x4
    8001596a:	0792                	slli	a5,a5,0x4
    8001596c:	40f10133          	sub	sp,sp,a5
    80015970:	878a                	mv	a5,sp
    80015972:	078d                	addi	a5,a5,3
    80015974:	8389                	srli	a5,a5,0x2
    80015976:	078a                	slli	a5,a5,0x2
    80015978:	f2f43423          	sd	a5,-216(s0)
            minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    8001597c:	f3c42783          	lw	a5,-196(s0)
    80015980:	f2843603          	ld	a2,-216(s0)
    80015984:	85be                	mv	a1,a5
    80015986:	e6843503          	ld	a0,-408(s0)
    8001598a:	933fe0ef          	jal	ra,800142bc <minix3_get_zone>

            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001598e:	f80401a3          	sb	zero,-125(s0)
    80015992:	aae9                	j	80015b6c <minix3_get_data+0x8cc>
                uint32_t zone = indirect_zones[indirect_zone];
    80015994:	f8344783          	lbu	a5,-125(s0)
    80015998:	2781                	sext.w	a5,a5
    8001599a:	f2843703          	ld	a4,-216(s0)
    8001599e:	078a                	slli	a5,a5,0x2
    800159a0:	97ba                	add	a5,a5,a4
    800159a2:	439c                	lw	a5,0(a5)
    800159a4:	f2f42223          	sw	a5,-220(s0)
                if (zone == 0) continue;
    800159a8:	f2442783          	lw	a5,-220(s0)
    800159ac:	2781                	sext.w	a5,a5
    800159ae:	1a078963          	beqz	a5,80015b60 <minix3_get_data+0x8c0>
                debugf("Reading double indirect zone %d\n", zone);

                if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    800159b2:	e6843503          	ld	a0,-408(s0)
    800159b6:	da9fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800159ba:	87aa                	mv	a5,a0
    800159bc:	2781                	sext.w	a5,a5
    800159be:	f8842703          	lw	a4,-120(s0)
    800159c2:	9fb9                	addw	a5,a5,a4
    800159c4:	0007871b          	sext.w	a4,a5
    800159c8:	e6042783          	lw	a5,-416(s0)
    800159cc:	2781                	sext.w	a5,a5
    800159ce:	00f77e63          	bgeu	a4,a5,800159ea <minix3_get_data+0x74a>
                    // We're not at the offset yet
                    file_cursor += minix3_get_zone_size(block_device);
    800159d2:	e6843503          	ld	a0,-408(s0)
    800159d6:	d89fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800159da:	87aa                	mv	a5,a0
    800159dc:	2781                	sext.w	a5,a5
    800159de:	f8842703          	lw	a4,-120(s0)
    800159e2:	9fb9                	addw	a5,a5,a4
    800159e4:	f8f42423          	sw	a5,-120(s0)
                    continue;
    800159e8:	aaad                	j	80015b62 <minix3_get_data+0x8c2>
                } else if (file_cursor < offset) {
    800159ea:	f8842703          	lw	a4,-120(s0)
    800159ee:	e6042783          	lw	a5,-416(s0)
    800159f2:	2701                	sext.w	a4,a4
    800159f4:	2781                	sext.w	a5,a5
    800159f6:	0af77b63          	bgeu	a4,a5,80015aac <minix3_get_data+0x80c>
                    // We're in the middle of the offset
                    // Read the zone into the buffer
                    minix3_get_zone(block_device, zone, zone_data);
    800159fa:	f2442783          	lw	a5,-220(s0)
    800159fe:	f7043603          	ld	a2,-144(s0)
    80015a02:	85be                	mv	a1,a5
    80015a04:	e6843503          	ld	a0,-408(s0)
    80015a08:	8b5fe0ef          	jal	ra,800142bc <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80015a0c:	e6843503          	ld	a0,-408(s0)
    80015a10:	d4ffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015a14:	87aa                	mv	a5,a0
    80015a16:	0007871b          	sext.w	a4,a5
    80015a1a:	f8842683          	lw	a3,-120(s0)
    80015a1e:	e6042783          	lw	a5,-416(s0)
    80015a22:	40f687bb          	subw	a5,a3,a5
    80015a26:	2781                	sext.w	a5,a5
    80015a28:	9fb9                	addw	a5,a5,a4
    80015a2a:	0007871b          	sext.w	a4,a5
    80015a2e:	e5442783          	lw	a5,-428(s0)
    80015a32:	2781                	sext.w	a5,a5
    80015a34:	02e7e563          	bltu	a5,a4,80015a5e <minix3_get_data+0x7be>
    80015a38:	e6843503          	ld	a0,-408(s0)
    80015a3c:	d23fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015a40:	87aa                	mv	a5,a0
    80015a42:	0007871b          	sext.w	a4,a5
    80015a46:	f8842683          	lw	a3,-120(s0)
    80015a4a:	e6042783          	lw	a5,-416(s0)
    80015a4e:	40f687bb          	subw	a5,a3,a5
    80015a52:	2781                	sext.w	a5,a5
    80015a54:	9fb9                	addw	a5,a5,a4
    80015a56:	2781                	sext.w	a5,a5
    80015a58:	1782                	slli	a5,a5,0x20
    80015a5a:	9381                	srli	a5,a5,0x20
    80015a5c:	a019                	j	80015a62 <minix3_get_data+0x7c2>
    80015a5e:	e5446783          	lwu	a5,-428(s0)
    80015a62:	f0f43c23          	sd	a5,-232(s0)
                    memcpy(data, zone_data + offset - file_cursor, remaining);
    80015a66:	e6046703          	lwu	a4,-416(s0)
    80015a6a:	f8846783          	lwu	a5,-120(s0)
    80015a6e:	40f707b3          	sub	a5,a4,a5
    80015a72:	f7043703          	ld	a4,-144(s0)
    80015a76:	97ba                	add	a5,a5,a4
    80015a78:	f1843703          	ld	a4,-232(s0)
    80015a7c:	2701                	sext.w	a4,a4
    80015a7e:	863a                	mv	a2,a4
    80015a80:	85be                	mv	a1,a5
    80015a82:	e5843503          	ld	a0,-424(s0)
    80015a86:	3e80a0ef          	jal	ra,8001fe6e <memcpy>
                    buffer_cursor += remaining;
    80015a8a:	f1843783          	ld	a5,-232(s0)
    80015a8e:	2781                	sext.w	a5,a5
    80015a90:	f8442703          	lw	a4,-124(s0)
    80015a94:	9fb9                	addw	a5,a5,a4
    80015a96:	f8f42223          	sw	a5,-124(s0)
                    file_cursor = offset + remaining;
    80015a9a:	f1843783          	ld	a5,-232(s0)
    80015a9e:	2781                	sext.w	a5,a5
    80015aa0:	e6042703          	lw	a4,-416(s0)
    80015aa4:	9fb9                	addw	a5,a5,a4
    80015aa6:	f8f42423          	sw	a5,-120(s0)
                    continue;
    80015aaa:	a865                	j	80015b62 <minix3_get_data+0x8c2>
                }
                
                // Read the zone into the buffer
                memset(zone_data, 0, minix3_get_zone_size(block_device));
    80015aac:	e6843503          	ld	a0,-408(s0)
    80015ab0:	caffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015ab4:	87aa                	mv	a5,a0
    80015ab6:	2781                	sext.w	a5,a5
    80015ab8:	863e                	mv	a2,a5
    80015aba:	4581                	li	a1,0
    80015abc:	f7043503          	ld	a0,-144(s0)
    80015ac0:	2ac0a0ef          	jal	ra,8001fd6c <memset>
                minix3_get_zone(block_device, zone, zone_data);
    80015ac4:	f2442783          	lw	a5,-220(s0)
    80015ac8:	f7043603          	ld	a2,-144(s0)
    80015acc:	85be                	mv	a1,a5
    80015ace:	e6843503          	ld	a0,-408(s0)
    80015ad2:	feafe0ef          	jal	ra,800142bc <minix3_get_zone>

                // If the cursor is past the amount of data we want, we're done
                if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80015ad6:	e6843503          	ld	a0,-408(s0)
    80015ada:	c85fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015ade:	87aa                	mv	a5,a0
    80015ae0:	2781                	sext.w	a5,a5
    80015ae2:	f8442703          	lw	a4,-124(s0)
    80015ae6:	9fb9                	addw	a5,a5,a4
    80015ae8:	0007871b          	sext.w	a4,a5
    80015aec:	e5442783          	lw	a5,-428(s0)
    80015af0:	2781                	sext.w	a5,a5
    80015af2:	02e7f963          	bgeu	a5,a4,80015b24 <minix3_get_data+0x884>
                    // Copy the remaining data into the buffer
                    memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    80015af6:	f8446783          	lwu	a5,-124(s0)
    80015afa:	e5843703          	ld	a4,-424(s0)
    80015afe:	00f706b3          	add	a3,a4,a5
    80015b02:	e5442703          	lw	a4,-428(s0)
    80015b06:	f8442783          	lw	a5,-124(s0)
    80015b0a:	40f707bb          	subw	a5,a4,a5
    80015b0e:	2781                	sext.w	a5,a5
    80015b10:	2781                	sext.w	a5,a5
    80015b12:	863e                	mv	a2,a5
    80015b14:	f7043583          	ld	a1,-144(s0)
    80015b18:	8536                	mv	a0,a3
    80015b1a:	3540a0ef          	jal	ra,8001fe6e <memcpy>
    80015b1e:	8126                	mv	sp,s1
    80015b20:	814e                	mv	sp,s3
    80015b22:	a33d                	j	80016050 <minix3_get_data+0xdb0>
                    // We're done
                    return;
                } else {
                    // Copy the entire zone into the buffer
                    memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    80015b24:	f8446783          	lwu	a5,-124(s0)
    80015b28:	e5843703          	ld	a4,-424(s0)
    80015b2c:	00f70933          	add	s2,a4,a5
    80015b30:	e6843503          	ld	a0,-408(s0)
    80015b34:	c2bfe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015b38:	87aa                	mv	a5,a0
    80015b3a:	2781                	sext.w	a5,a5
    80015b3c:	863e                	mv	a2,a5
    80015b3e:	f7043583          	ld	a1,-144(s0)
    80015b42:	854a                	mv	a0,s2
    80015b44:	32a0a0ef          	jal	ra,8001fe6e <memcpy>
                }
                buffer_cursor += minix3_get_zone_size(block_device);
    80015b48:	e6843503          	ld	a0,-408(s0)
    80015b4c:	c13fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015b50:	87aa                	mv	a5,a0
    80015b52:	2781                	sext.w	a5,a5
    80015b54:	f8442703          	lw	a4,-124(s0)
    80015b58:	9fb9                	addw	a5,a5,a4
    80015b5a:	f8f42223          	sw	a5,-124(s0)
    80015b5e:	a011                	j	80015b62 <minix3_get_data+0x8c2>
                if (zone == 0) continue;
    80015b60:	0001                	nop
            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80015b62:	f8344783          	lbu	a5,-125(s0)
    80015b66:	2785                	addiw	a5,a5,1
    80015b68:	f8f401a3          	sb	a5,-125(s0)
    80015b6c:	f8344783          	lbu	a5,-125(s0)
    80015b70:	03079913          	slli	s2,a5,0x30
    80015b74:	03095913          	srli	s2,s2,0x30
    80015b78:	e6843503          	ld	a0,-408(s0)
    80015b7c:	be3fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015b80:	87aa                	mv	a5,a0
    80015b82:	0027d79b          	srliw	a5,a5,0x2
    80015b86:	17c2                	slli	a5,a5,0x30
    80015b88:	93c1                	srli	a5,a5,0x30
    80015b8a:	0009071b          	sext.w	a4,s2
    80015b8e:	2781                	sext.w	a5,a5
    80015b90:	e0f762e3          	bltu	a4,a5,80015994 <minix3_get_data+0x6f4>
    80015b94:	8126                	mv	sp,s1
        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80015b96:	f8f44783          	lbu	a5,-113(s0)
    80015b9a:	2785                	addiw	a5,a5,1
    80015b9c:	f8f407a3          	sb	a5,-113(s0)
    80015ba0:	f8f44783          	lbu	a5,-113(s0)
    80015ba4:	03079493          	slli	s1,a5,0x30
    80015ba8:	90c1                	srli	s1,s1,0x30
    80015baa:	e6843503          	ld	a0,-408(s0)
    80015bae:	bb1fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015bb2:	87aa                	mv	a5,a0
    80015bb4:	0027d79b          	srliw	a5,a5,0x2
    80015bb8:	17c2                	slli	a5,a5,0x30
    80015bba:	93c1                	srli	a5,a5,0x30
    80015bbc:	0004871b          	sext.w	a4,s1
    80015bc0:	2781                	sext.w	a5,a5
    80015bc2:	d0f76be3          	bltu	a4,a5,800158d8 <minix3_get_data+0x638>
    80015bc6:	814e                	mv	sp,s3
    } else {
        debugf("No double indirect zone\n");
    }

    // The next zone is a triple indirect zone
    if (inode_data.zones[9] != 0) {
    80015bc8:	eb442783          	lw	a5,-332(s0)
    80015bcc:	48078163          	beqz	a5,8001604e <minix3_get_data+0xdae>
    80015bd0:	878a                	mv	a5,sp
    80015bd2:	8a3e                	mv	s4,a5
        uint32_t triple_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80015bd4:	e6843503          	ld	a0,-408(s0)
    80015bd8:	b87fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015bdc:	87aa                	mv	a5,a0
    80015bde:	0027d79b          	srliw	a5,a5,0x2
    80015be2:	17c2                	slli	a5,a5,0x30
    80015be4:	93c1                	srli	a5,a5,0x30
    80015be6:	873e                	mv	a4,a5
    80015be8:	177d                	addi	a4,a4,-1
    80015bea:	f0e43823          	sd	a4,-240(s0)
    80015bee:	dcf43023          	sd	a5,-576(s0)
    80015bf2:	dc043423          	sd	zero,-568(s0)
    80015bf6:	dc043703          	ld	a4,-576(s0)
    80015bfa:	936d                	srli	a4,a4,0x3b
    80015bfc:	dc843683          	ld	a3,-568(s0)
    80015c00:	0696                	slli	a3,a3,0x5
    80015c02:	d0d43423          	sd	a3,-760(s0)
    80015c06:	d0843683          	ld	a3,-760(s0)
    80015c0a:	8f55                	or	a4,a4,a3
    80015c0c:	d0e43423          	sd	a4,-760(s0)
    80015c10:	dc043703          	ld	a4,-576(s0)
    80015c14:	0716                	slli	a4,a4,0x5
    80015c16:	d0e43023          	sd	a4,-768(s0)
    80015c1a:	daf43823          	sd	a5,-592(s0)
    80015c1e:	da043c23          	sd	zero,-584(s0)
    80015c22:	db043703          	ld	a4,-592(s0)
    80015c26:	936d                	srli	a4,a4,0x3b
    80015c28:	db843683          	ld	a3,-584(s0)
    80015c2c:	0696                	slli	a3,a3,0x5
    80015c2e:	ced43c23          	sd	a3,-776(s0)
    80015c32:	cf843683          	ld	a3,-776(s0)
    80015c36:	8f55                	or	a4,a4,a3
    80015c38:	cee43c23          	sd	a4,-776(s0)
    80015c3c:	db043703          	ld	a4,-592(s0)
    80015c40:	0716                	slli	a4,a4,0x5
    80015c42:	cee43823          	sd	a4,-784(s0)
    80015c46:	078a                	slli	a5,a5,0x2
    80015c48:	07bd                	addi	a5,a5,15
    80015c4a:	8391                	srli	a5,a5,0x4
    80015c4c:	0792                	slli	a5,a5,0x4
    80015c4e:	40f10133          	sub	sp,sp,a5
    80015c52:	878a                	mv	a5,sp
    80015c54:	078d                	addi	a5,a5,3
    80015c56:	8389                	srli	a5,a5,0x2
    80015c58:	078a                	slli	a5,a5,0x2
    80015c5a:	f0f43423          	sd	a5,-248(s0)
        minix3_get_zone(block_device, inode_data.zones[9], (uint8_t*)triple_indirect_zones);
    80015c5e:	eb442783          	lw	a5,-332(s0)
    80015c62:	f0843603          	ld	a2,-248(s0)
    80015c66:	85be                	mv	a1,a5
    80015c68:	e6843503          	ld	a0,-408(s0)
    80015c6c:	e50fe0ef          	jal	ra,800142bc <minix3_get_zone>

        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    80015c70:	f8040123          	sb	zero,-126(s0)
    80015c74:	ae4d                	j	80016026 <minix3_get_data+0xd86>
    80015c76:	878a                	mv	a5,sp
    80015c78:	84be                	mv	s1,a5
            uint32_t double_indirect_zone = triple_indirect_zones[triple_indirect_zone];
    80015c7a:	f8244783          	lbu	a5,-126(s0)
    80015c7e:	2781                	sext.w	a5,a5
    80015c80:	f0843703          	ld	a4,-248(s0)
    80015c84:	078a                	slli	a5,a5,0x2
    80015c86:	97ba                	add	a5,a5,a4
    80015c88:	439c                	lw	a5,0(a5)
    80015c8a:	f0f42223          	sw	a5,-252(s0)
            if (double_indirect_zone == 0) continue;
    80015c8e:	f0442783          	lw	a5,-252(s0)
    80015c92:	2781                	sext.w	a5,a5
    80015c94:	e399                	bnez	a5,80015c9a <minix3_get_data+0x9fa>
    80015c96:	8126                	mv	sp,s1
    80015c98:	a651                	j	8001601c <minix3_get_data+0xd7c>
            uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80015c9a:	e6843503          	ld	a0,-408(s0)
    80015c9e:	ac1fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015ca2:	87aa                	mv	a5,a0
    80015ca4:	0027d79b          	srliw	a5,a5,0x2
    80015ca8:	17c2                	slli	a5,a5,0x30
    80015caa:	93c1                	srli	a5,a5,0x30
    80015cac:	873e                	mv	a4,a5
    80015cae:	177d                	addi	a4,a4,-1
    80015cb0:	eee43c23          	sd	a4,-264(s0)
    80015cb4:	daf43023          	sd	a5,-608(s0)
    80015cb8:	da043423          	sd	zero,-600(s0)
    80015cbc:	da043703          	ld	a4,-608(s0)
    80015cc0:	936d                	srli	a4,a4,0x3b
    80015cc2:	da843683          	ld	a3,-600(s0)
    80015cc6:	00569b93          	slli	s7,a3,0x5
    80015cca:	01776bb3          	or	s7,a4,s7
    80015cce:	da043703          	ld	a4,-608(s0)
    80015cd2:	00571b13          	slli	s6,a4,0x5
    80015cd6:	d8f43823          	sd	a5,-624(s0)
    80015cda:	d8043c23          	sd	zero,-616(s0)
    80015cde:	d9043703          	ld	a4,-624(s0)
    80015ce2:	936d                	srli	a4,a4,0x3b
    80015ce4:	d9843683          	ld	a3,-616(s0)
    80015ce8:	00569c93          	slli	s9,a3,0x5
    80015cec:	01976cb3          	or	s9,a4,s9
    80015cf0:	d9043703          	ld	a4,-624(s0)
    80015cf4:	00571c13          	slli	s8,a4,0x5
    80015cf8:	078a                	slli	a5,a5,0x2
    80015cfa:	07bd                	addi	a5,a5,15
    80015cfc:	8391                	srli	a5,a5,0x4
    80015cfe:	0792                	slli	a5,a5,0x4
    80015d00:	40f10133          	sub	sp,sp,a5
    80015d04:	878a                	mv	a5,sp
    80015d06:	078d                	addi	a5,a5,3
    80015d08:	8389                	srli	a5,a5,0x2
    80015d0a:	078a                	slli	a5,a5,0x2
    80015d0c:	eef43823          	sd	a5,-272(s0)
            minix3_get_zone(block_device, double_indirect_zone, (uint8_t*)double_indirect_zones);
    80015d10:	f0442783          	lw	a5,-252(s0)
    80015d14:	ef043603          	ld	a2,-272(s0)
    80015d18:	85be                	mv	a1,a5
    80015d1a:	e6843503          	ld	a0,-408(s0)
    80015d1e:	d9efe0ef          	jal	ra,800142bc <minix3_get_zone>

            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80015d22:	f80400a3          	sb	zero,-127(s0)
    80015d26:	a4f1                	j	80015ff2 <minix3_get_data+0xd52>
    80015d28:	878a                	mv	a5,sp
    80015d2a:	893e                	mv	s2,a5
                uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80015d2c:	f8144783          	lbu	a5,-127(s0)
    80015d30:	2781                	sext.w	a5,a5
    80015d32:	ef043703          	ld	a4,-272(s0)
    80015d36:	078a                	slli	a5,a5,0x2
    80015d38:	97ba                	add	a5,a5,a4
    80015d3a:	439c                	lw	a5,0(a5)
    80015d3c:	eef42623          	sw	a5,-276(s0)
                if (indirect_zone == 0) continue;
    80015d40:	eec42783          	lw	a5,-276(s0)
    80015d44:	2781                	sext.w	a5,a5
    80015d46:	e399                	bnez	a5,80015d4c <minix3_get_data+0xaac>
    80015d48:	814a                	mv	sp,s2
    80015d4a:	ac79                	j	80015fe8 <minix3_get_data+0xd48>
                uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80015d4c:	e6843503          	ld	a0,-408(s0)
    80015d50:	a0ffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015d54:	87aa                	mv	a5,a0
    80015d56:	0027d79b          	srliw	a5,a5,0x2
    80015d5a:	17c2                	slli	a5,a5,0x30
    80015d5c:	93c1                	srli	a5,a5,0x30
    80015d5e:	873e                	mv	a4,a5
    80015d60:	177d                	addi	a4,a4,-1
    80015d62:	eee43023          	sd	a4,-288(s0)
    80015d66:	d8f43023          	sd	a5,-640(s0)
    80015d6a:	d8043423          	sd	zero,-632(s0)
    80015d6e:	d8043703          	ld	a4,-640(s0)
    80015d72:	936d                	srli	a4,a4,0x3b
    80015d74:	d8843683          	ld	a3,-632(s0)
    80015d78:	00569d93          	slli	s11,a3,0x5
    80015d7c:	01b76db3          	or	s11,a4,s11
    80015d80:	d8043703          	ld	a4,-640(s0)
    80015d84:	00571d13          	slli	s10,a4,0x5
    80015d88:	d6f43823          	sd	a5,-656(s0)
    80015d8c:	d6043c23          	sd	zero,-648(s0)
    80015d90:	d7043703          	ld	a4,-656(s0)
    80015d94:	936d                	srli	a4,a4,0x3b
    80015d96:	d7843683          	ld	a3,-648(s0)
    80015d9a:	0696                	slli	a3,a3,0x5
    80015d9c:	ced43423          	sd	a3,-792(s0)
    80015da0:	ce843683          	ld	a3,-792(s0)
    80015da4:	8f55                	or	a4,a4,a3
    80015da6:	cee43423          	sd	a4,-792(s0)
    80015daa:	d7043703          	ld	a4,-656(s0)
    80015dae:	0716                	slli	a4,a4,0x5
    80015db0:	cee43023          	sd	a4,-800(s0)
    80015db4:	078a                	slli	a5,a5,0x2
    80015db6:	07bd                	addi	a5,a5,15
    80015db8:	8391                	srli	a5,a5,0x4
    80015dba:	0792                	slli	a5,a5,0x4
    80015dbc:	40f10133          	sub	sp,sp,a5
    80015dc0:	878a                	mv	a5,sp
    80015dc2:	078d                	addi	a5,a5,3
    80015dc4:	8389                	srli	a5,a5,0x2
    80015dc6:	078a                	slli	a5,a5,0x2
    80015dc8:	ecf43c23          	sd	a5,-296(s0)
                minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    80015dcc:	eec42783          	lw	a5,-276(s0)
    80015dd0:	ed843603          	ld	a2,-296(s0)
    80015dd4:	85be                	mv	a1,a5
    80015dd6:	e6843503          	ld	a0,-408(s0)
    80015dda:	ce2fe0ef          	jal	ra,800142bc <minix3_get_zone>

                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80015dde:	f8040023          	sb	zero,-128(s0)
    80015de2:	aaf1                	j	80015fbe <minix3_get_data+0xd1e>
                    uint32_t zone = indirect_zones[indirect_zone];
    80015de4:	f8044783          	lbu	a5,-128(s0)
    80015de8:	2781                	sext.w	a5,a5
    80015dea:	ed843703          	ld	a4,-296(s0)
    80015dee:	078a                	slli	a5,a5,0x2
    80015df0:	97ba                	add	a5,a5,a4
    80015df2:	439c                	lw	a5,0(a5)
    80015df4:	ecf42a23          	sw	a5,-300(s0)
                    if (zone == 0) continue;
    80015df8:	ed442783          	lw	a5,-300(s0)
    80015dfc:	2781                	sext.w	a5,a5
    80015dfe:	1a078a63          	beqz	a5,80015fb2 <minix3_get_data+0xd12>
                    debugf("Reading triple indirect zone %d\n", zone);
                    
                    if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80015e02:	e6843503          	ld	a0,-408(s0)
    80015e06:	959fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015e0a:	87aa                	mv	a5,a0
    80015e0c:	2781                	sext.w	a5,a5
    80015e0e:	f8842703          	lw	a4,-120(s0)
    80015e12:	9fb9                	addw	a5,a5,a4
    80015e14:	0007871b          	sext.w	a4,a5
    80015e18:	e6042783          	lw	a5,-416(s0)
    80015e1c:	2781                	sext.w	a5,a5
    80015e1e:	00f77e63          	bgeu	a4,a5,80015e3a <minix3_get_data+0xb9a>
                        // We're not at the offset yet
                        file_cursor += minix3_get_zone_size(block_device);
    80015e22:	e6843503          	ld	a0,-408(s0)
    80015e26:	939fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015e2a:	87aa                	mv	a5,a0
    80015e2c:	2781                	sext.w	a5,a5
    80015e2e:	f8842703          	lw	a4,-120(s0)
    80015e32:	9fb9                	addw	a5,a5,a4
    80015e34:	f8f42423          	sw	a5,-120(s0)
                        continue;
    80015e38:	aab5                	j	80015fb4 <minix3_get_data+0xd14>
                    } else if (file_cursor < offset) {
    80015e3a:	f8842703          	lw	a4,-120(s0)
    80015e3e:	e6042783          	lw	a5,-416(s0)
    80015e42:	2701                	sext.w	a4,a4
    80015e44:	2781                	sext.w	a5,a5
    80015e46:	0af77b63          	bgeu	a4,a5,80015efc <minix3_get_data+0xc5c>
                        // We're in the middle of the offset
                        // Read the zone into the buffer
                        minix3_get_zone(block_device, zone, zone_data);
    80015e4a:	ed442783          	lw	a5,-300(s0)
    80015e4e:	f7043603          	ld	a2,-144(s0)
    80015e52:	85be                	mv	a1,a5
    80015e54:	e6843503          	ld	a0,-408(s0)
    80015e58:	c64fe0ef          	jal	ra,800142bc <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80015e5c:	e6843503          	ld	a0,-408(s0)
    80015e60:	8fffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015e64:	87aa                	mv	a5,a0
    80015e66:	0007871b          	sext.w	a4,a5
    80015e6a:	f8842683          	lw	a3,-120(s0)
    80015e6e:	e6042783          	lw	a5,-416(s0)
    80015e72:	40f687bb          	subw	a5,a3,a5
    80015e76:	2781                	sext.w	a5,a5
    80015e78:	9fb9                	addw	a5,a5,a4
    80015e7a:	0007871b          	sext.w	a4,a5
    80015e7e:	e5442783          	lw	a5,-428(s0)
    80015e82:	2781                	sext.w	a5,a5
    80015e84:	02e7e563          	bltu	a5,a4,80015eae <minix3_get_data+0xc0e>
    80015e88:	e6843503          	ld	a0,-408(s0)
    80015e8c:	8d3fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015e90:	87aa                	mv	a5,a0
    80015e92:	0007871b          	sext.w	a4,a5
    80015e96:	f8842683          	lw	a3,-120(s0)
    80015e9a:	e6042783          	lw	a5,-416(s0)
    80015e9e:	40f687bb          	subw	a5,a3,a5
    80015ea2:	2781                	sext.w	a5,a5
    80015ea4:	9fb9                	addw	a5,a5,a4
    80015ea6:	2781                	sext.w	a5,a5
    80015ea8:	1782                	slli	a5,a5,0x20
    80015eaa:	9381                	srli	a5,a5,0x20
    80015eac:	a019                	j	80015eb2 <minix3_get_data+0xc12>
    80015eae:	e5446783          	lwu	a5,-428(s0)
    80015eb2:	ecf43423          	sd	a5,-312(s0)
                        memcpy(data, zone_data + offset - file_cursor, remaining);
    80015eb6:	e6046703          	lwu	a4,-416(s0)
    80015eba:	f8846783          	lwu	a5,-120(s0)
    80015ebe:	40f707b3          	sub	a5,a4,a5
    80015ec2:	f7043703          	ld	a4,-144(s0)
    80015ec6:	97ba                	add	a5,a5,a4
    80015ec8:	ec843703          	ld	a4,-312(s0)
    80015ecc:	2701                	sext.w	a4,a4
    80015ece:	863a                	mv	a2,a4
    80015ed0:	85be                	mv	a1,a5
    80015ed2:	e5843503          	ld	a0,-424(s0)
    80015ed6:	799090ef          	jal	ra,8001fe6e <memcpy>
                        buffer_cursor += remaining;
    80015eda:	ec843783          	ld	a5,-312(s0)
    80015ede:	2781                	sext.w	a5,a5
    80015ee0:	f8442703          	lw	a4,-124(s0)
    80015ee4:	9fb9                	addw	a5,a5,a4
    80015ee6:	f8f42223          	sw	a5,-124(s0)
                        file_cursor = offset + remaining;
    80015eea:	ec843783          	ld	a5,-312(s0)
    80015eee:	2781                	sext.w	a5,a5
    80015ef0:	e6042703          	lw	a4,-416(s0)
    80015ef4:	9fb9                	addw	a5,a5,a4
    80015ef6:	f8f42423          	sw	a5,-120(s0)
                        continue;
    80015efa:	a86d                	j	80015fb4 <minix3_get_data+0xd14>
                    }
                
                    
                    // Read the zone into the buffer
                    memset(zone_data, 0, minix3_get_zone_size(block_device));
    80015efc:	e6843503          	ld	a0,-408(s0)
    80015f00:	85ffe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015f04:	87aa                	mv	a5,a0
    80015f06:	2781                	sext.w	a5,a5
    80015f08:	863e                	mv	a2,a5
    80015f0a:	4581                	li	a1,0
    80015f0c:	f7043503          	ld	a0,-144(s0)
    80015f10:	65d090ef          	jal	ra,8001fd6c <memset>
                    minix3_get_zone(block_device, zone, zone_data);
    80015f14:	ed442783          	lw	a5,-300(s0)
    80015f18:	f7043603          	ld	a2,-144(s0)
    80015f1c:	85be                	mv	a1,a5
    80015f1e:	e6843503          	ld	a0,-408(s0)
    80015f22:	b9afe0ef          	jal	ra,800142bc <minix3_get_zone>

                    // If the cursor is past the amount of data we want, we're done
                    if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80015f26:	e6843503          	ld	a0,-408(s0)
    80015f2a:	835fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015f2e:	87aa                	mv	a5,a0
    80015f30:	2781                	sext.w	a5,a5
    80015f32:	f8442703          	lw	a4,-124(s0)
    80015f36:	9fb9                	addw	a5,a5,a4
    80015f38:	0007871b          	sext.w	a4,a5
    80015f3c:	e5442783          	lw	a5,-428(s0)
    80015f40:	2781                	sext.w	a5,a5
    80015f42:	02e7fa63          	bgeu	a5,a4,80015f76 <minix3_get_data+0xcd6>
                        // Copy the remaining data into the buffer
                        memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    80015f46:	f8446783          	lwu	a5,-124(s0)
    80015f4a:	e5843703          	ld	a4,-424(s0)
    80015f4e:	00f706b3          	add	a3,a4,a5
    80015f52:	e5442703          	lw	a4,-428(s0)
    80015f56:	f8442783          	lw	a5,-124(s0)
    80015f5a:	40f707bb          	subw	a5,a4,a5
    80015f5e:	2781                	sext.w	a5,a5
    80015f60:	2781                	sext.w	a5,a5
    80015f62:	863e                	mv	a2,a5
    80015f64:	f7043583          	ld	a1,-144(s0)
    80015f68:	8536                	mv	a0,a3
    80015f6a:	705090ef          	jal	ra,8001fe6e <memcpy>
    80015f6e:	814a                	mv	sp,s2
    80015f70:	8126                	mv	sp,s1
    80015f72:	8152                	mv	sp,s4
    80015f74:	a8f1                	j	80016050 <minix3_get_data+0xdb0>
                        // We're done
                        return;
                    } else {
                        // Copy the entire zone into the buffer
                        memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    80015f76:	f8446783          	lwu	a5,-124(s0)
    80015f7a:	e5843703          	ld	a4,-424(s0)
    80015f7e:	00f709b3          	add	s3,a4,a5
    80015f82:	e6843503          	ld	a0,-408(s0)
    80015f86:	fd8fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015f8a:	87aa                	mv	a5,a0
    80015f8c:	2781                	sext.w	a5,a5
    80015f8e:	863e                	mv	a2,a5
    80015f90:	f7043583          	ld	a1,-144(s0)
    80015f94:	854e                	mv	a0,s3
    80015f96:	6d9090ef          	jal	ra,8001fe6e <memcpy>
                    }
                    buffer_cursor += minix3_get_zone_size(block_device);
    80015f9a:	e6843503          	ld	a0,-408(s0)
    80015f9e:	fc0fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015fa2:	87aa                	mv	a5,a0
    80015fa4:	2781                	sext.w	a5,a5
    80015fa6:	f8442703          	lw	a4,-124(s0)
    80015faa:	9fb9                	addw	a5,a5,a4
    80015fac:	f8f42223          	sw	a5,-124(s0)
    80015fb0:	a011                	j	80015fb4 <minix3_get_data+0xd14>
                    if (zone == 0) continue;
    80015fb2:	0001                	nop
                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80015fb4:	f8044783          	lbu	a5,-128(s0)
    80015fb8:	2785                	addiw	a5,a5,1
    80015fba:	f8f40023          	sb	a5,-128(s0)
    80015fbe:	f8044783          	lbu	a5,-128(s0)
    80015fc2:	03079993          	slli	s3,a5,0x30
    80015fc6:	0309d993          	srli	s3,s3,0x30
    80015fca:	e6843503          	ld	a0,-408(s0)
    80015fce:	f90fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80015fd2:	87aa                	mv	a5,a0
    80015fd4:	0027d79b          	srliw	a5,a5,0x2
    80015fd8:	17c2                	slli	a5,a5,0x30
    80015fda:	93c1                	srli	a5,a5,0x30
    80015fdc:	0009871b          	sext.w	a4,s3
    80015fe0:	2781                	sext.w	a5,a5
    80015fe2:	e0f761e3          	bltu	a4,a5,80015de4 <minix3_get_data+0xb44>
    80015fe6:	814a                	mv	sp,s2
            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80015fe8:	f8144783          	lbu	a5,-127(s0)
    80015fec:	2785                	addiw	a5,a5,1
    80015fee:	f8f400a3          	sb	a5,-127(s0)
    80015ff2:	f8144783          	lbu	a5,-127(s0)
    80015ff6:	03079913          	slli	s2,a5,0x30
    80015ffa:	03095913          	srli	s2,s2,0x30
    80015ffe:	e6843503          	ld	a0,-408(s0)
    80016002:	f5cfe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016006:	87aa                	mv	a5,a0
    80016008:	0027d79b          	srliw	a5,a5,0x2
    8001600c:	17c2                	slli	a5,a5,0x30
    8001600e:	93c1                	srli	a5,a5,0x30
    80016010:	0009071b          	sext.w	a4,s2
    80016014:	2781                	sext.w	a5,a5
    80016016:	d0f769e3          	bltu	a4,a5,80015d28 <minix3_get_data+0xa88>
    8001601a:	8126                	mv	sp,s1
        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    8001601c:	f8244783          	lbu	a5,-126(s0)
    80016020:	2785                	addiw	a5,a5,1
    80016022:	f8f40123          	sb	a5,-126(s0)
    80016026:	f8244783          	lbu	a5,-126(s0)
    8001602a:	03079493          	slli	s1,a5,0x30
    8001602e:	90c1                	srli	s1,s1,0x30
    80016030:	e6843503          	ld	a0,-408(s0)
    80016034:	f2afe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016038:	87aa                	mv	a5,a0
    8001603a:	0027d79b          	srliw	a5,a5,0x2
    8001603e:	17c2                	slli	a5,a5,0x30
    80016040:	93c1                	srli	a5,a5,0x30
    80016042:	0004871b          	sext.w	a4,s1
    80016046:	2781                	sext.w	a5,a5
    80016048:	c2f767e3          	bltu	a4,a5,80015c76 <minix3_get_data+0x9d6>
    8001604c:	8152                	mv	sp,s4
    } else {
        debugf("No triple indirect zone\n");
    }

    // If we get here, we've read all the data we can
    return;
    8001604e:	0001                	nop
    80016050:	cd843103          	ld	sp,-808(s0)
}
    80016054:	cd040113          	addi	sp,s0,-816
    80016058:	32813083          	ld	ra,808(sp)
    8001605c:	32013403          	ld	s0,800(sp)
    80016060:	31813483          	ld	s1,792(sp)
    80016064:	31013903          	ld	s2,784(sp)
    80016068:	30813983          	ld	s3,776(sp)
    8001606c:	30013a03          	ld	s4,768(sp)
    80016070:	2f813a83          	ld	s5,760(sp)
    80016074:	2f013b03          	ld	s6,752(sp)
    80016078:	2e813b83          	ld	s7,744(sp)
    8001607c:	2e013c03          	ld	s8,736(sp)
    80016080:	2d813c83          	ld	s9,728(sp)
    80016084:	2d013d03          	ld	s10,720(sp)
    80016088:	2c813d83          	ld	s11,712(sp)
    8001608c:	33010113          	addi	sp,sp,816
    80016090:	8082                	ret

0000000080016092 <minix3_put_data>:
void minix3_put_data(VirtioDevice *block_device, uint32_t inode, uint8_t *data, uint32_t offset, uint32_t count) {
    80016092:	cd010113          	addi	sp,sp,-816
    80016096:	32113423          	sd	ra,808(sp)
    8001609a:	32813023          	sd	s0,800(sp)
    8001609e:	30913c23          	sd	s1,792(sp)
    800160a2:	31213823          	sd	s2,784(sp)
    800160a6:	31313423          	sd	s3,776(sp)
    800160aa:	31413023          	sd	s4,768(sp)
    800160ae:	2f513c23          	sd	s5,760(sp)
    800160b2:	2f613823          	sd	s6,752(sp)
    800160b6:	2f713423          	sd	s7,744(sp)
    800160ba:	2f813023          	sd	s8,736(sp)
    800160be:	2d913c23          	sd	s9,728(sp)
    800160c2:	2da13823          	sd	s10,720(sp)
    800160c6:	2db13423          	sd	s11,712(sp)
    800160ca:	1e00                	addi	s0,sp,816
    800160cc:	e6a43423          	sd	a0,-408(s0)
    800160d0:	87ae                	mv	a5,a1
    800160d2:	e4c43c23          	sd	a2,-424(s0)
    800160d6:	e6f42223          	sw	a5,-412(s0)
    800160da:	87b6                	mv	a5,a3
    800160dc:	e6f42023          	sw	a5,-416(s0)
    800160e0:	87ba                	mv	a5,a4
    800160e2:	e4f42a23          	sw	a5,-428(s0)
    800160e6:	878a                	mv	a5,sp
    800160e8:	ccf43c23          	sd	a5,-808(s0)
    // First, get the inode
    Inode inode_data = minix3_get_inode(block_device, inode);
    800160ec:	e7840713          	addi	a4,s0,-392
    800160f0:	e6442783          	lw	a5,-412(s0)
    800160f4:	863e                	mv	a2,a5
    800160f6:	e6843583          	ld	a1,-408(s0)
    800160fa:	853a                	mv	a0,a4
    800160fc:	ce3fe0ef          	jal	ra,80014dde <minix3_get_inode>

    uint8_t zone_data[minix3_get_zone_size(block_device)];
    80016100:	e6843503          	ld	a0,-408(s0)
    80016104:	e5afe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016108:	87aa                	mv	a5,a0
    8001610a:	873e                	mv	a4,a5
    8001610c:	87ba                	mv	a5,a4
    8001610e:	17fd                	addi	a5,a5,-1
    80016110:	f6f43c23          	sd	a5,-136(s0)
    80016114:	e4e43023          	sd	a4,-448(s0)
    80016118:	e4043423          	sd	zero,-440(s0)
    8001611c:	e4043783          	ld	a5,-448(s0)
    80016120:	93f5                	srli	a5,a5,0x3d
    80016122:	e4843683          	ld	a3,-440(s0)
    80016126:	068e                	slli	a3,a3,0x3
    80016128:	d6d43423          	sd	a3,-664(s0)
    8001612c:	d6843683          	ld	a3,-664(s0)
    80016130:	8fd5                	or	a5,a5,a3
    80016132:	d6f43423          	sd	a5,-664(s0)
    80016136:	e4043783          	ld	a5,-448(s0)
    8001613a:	078e                	slli	a5,a5,0x3
    8001613c:	d6f43023          	sd	a5,-672(s0)
    80016140:	e2e43823          	sd	a4,-464(s0)
    80016144:	e2043c23          	sd	zero,-456(s0)
    80016148:	e3043783          	ld	a5,-464(s0)
    8001614c:	93f5                	srli	a5,a5,0x3d
    8001614e:	e3843683          	ld	a3,-456(s0)
    80016152:	00369993          	slli	s3,a3,0x3
    80016156:	0137e9b3          	or	s3,a5,s3
    8001615a:	e3043783          	ld	a5,-464(s0)
    8001615e:	00379913          	slli	s2,a5,0x3
    80016162:	87ba                	mv	a5,a4
    80016164:	07bd                	addi	a5,a5,15
    80016166:	8391                	srli	a5,a5,0x4
    80016168:	0792                	slli	a5,a5,0x4
    8001616a:	40f10133          	sub	sp,sp,a5
    8001616e:	878a                	mv	a5,sp
    80016170:	00078793          	mv	a5,a5
    80016174:	f6f43823          	sd	a5,-144(s0)

    // The cursor is the current position in the data buffer
    uint32_t buffer_cursor = 0;
    80016178:	f8042223          	sw	zero,-124(s0)
    // The file cursor is the current position in the file
    uint32_t file_cursor = 0;
    8001617c:	f8042423          	sw	zero,-120(s0)

    // Now, get the data
    // The first 7 zones are direct zones
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80016180:	f80406a3          	sb	zero,-115(s0)
    80016184:	a425                	j	800163ac <minix3_put_data+0x31a>
        uint32_t zone = inode_data.zones[direct_zone];
    80016186:	f8d44783          	lbu	a5,-115(s0)
    8001618a:	2781                	sext.w	a5,a5
    8001618c:	0791                	addi	a5,a5,4
    8001618e:	078a                	slli	a5,a5,0x2
    80016190:	f9040713          	addi	a4,s0,-112
    80016194:	97ba                	add	a5,a5,a4
    80016196:	ef07a783          	lw	a5,-272(a5)
    8001619a:	ecf42223          	sw	a5,-316(s0)
        if (zone == 0) {
    8001619e:	ec442783          	lw	a5,-316(s0)
    800161a2:	2781                	sext.w	a5,a5
    800161a4:	1e078c63          	beqz	a5,8001639c <minix3_put_data+0x30a>
            debugf("No direct zone %d\n", zone);
            continue;
        }
        if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    800161a8:	e6843503          	ld	a0,-408(s0)
    800161ac:	db2fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800161b0:	87aa                	mv	a5,a0
    800161b2:	2781                	sext.w	a5,a5
    800161b4:	f8842703          	lw	a4,-120(s0)
    800161b8:	9fb9                	addw	a5,a5,a4
    800161ba:	0007871b          	sext.w	a4,a5
    800161be:	e6042783          	lw	a5,-416(s0)
    800161c2:	2781                	sext.w	a5,a5
    800161c4:	00f77e63          	bgeu	a4,a5,800161e0 <minix3_put_data+0x14e>
            // We're not at the offset yet
            file_cursor += minix3_get_zone_size(block_device);
    800161c8:	e6843503          	ld	a0,-408(s0)
    800161cc:	d92fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800161d0:	87aa                	mv	a5,a0
    800161d2:	2781                	sext.w	a5,a5
    800161d4:	f8842703          	lw	a4,-120(s0)
    800161d8:	9fb9                	addw	a5,a5,a4
    800161da:	f8f42423          	sw	a5,-120(s0)
            continue;
    800161de:	a2d1                	j	800163a2 <minix3_put_data+0x310>
        } else if (file_cursor < offset) {
    800161e0:	f8842703          	lw	a4,-120(s0)
    800161e4:	e6042783          	lw	a5,-416(s0)
    800161e8:	2701                	sext.w	a4,a4
    800161ea:	2781                	sext.w	a5,a5
    800161ec:	0cf77d63          	bgeu	a4,a5,800162c6 <minix3_put_data+0x234>
            // We're in the middle of the offset
            // Read the zone into the buffer
            debugf("Writing first direct zone %d\n", zone);
            minix3_get_zone(block_device, zone, zone_data);
    800161f0:	ec442783          	lw	a5,-316(s0)
    800161f4:	f7043603          	ld	a2,-144(s0)
    800161f8:	85be                	mv	a1,a5
    800161fa:	e6843503          	ld	a0,-408(s0)
    800161fe:	8befe0ef          	jal	ra,800142bc <minix3_get_zone>

            // Copy the remaining data into the buffer
            size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80016202:	e6843503          	ld	a0,-408(s0)
    80016206:	d58fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001620a:	87aa                	mv	a5,a0
    8001620c:	0007871b          	sext.w	a4,a5
    80016210:	f8842683          	lw	a3,-120(s0)
    80016214:	e6042783          	lw	a5,-416(s0)
    80016218:	40f687bb          	subw	a5,a3,a5
    8001621c:	2781                	sext.w	a5,a5
    8001621e:	9fb9                	addw	a5,a5,a4
    80016220:	0007871b          	sext.w	a4,a5
    80016224:	e5442783          	lw	a5,-428(s0)
    80016228:	2781                	sext.w	a5,a5
    8001622a:	02e7e563          	bltu	a5,a4,80016254 <minix3_put_data+0x1c2>
    8001622e:	e6843503          	ld	a0,-408(s0)
    80016232:	d2cfe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016236:	87aa                	mv	a5,a0
    80016238:	0007871b          	sext.w	a4,a5
    8001623c:	f8842683          	lw	a3,-120(s0)
    80016240:	e6042783          	lw	a5,-416(s0)
    80016244:	40f687bb          	subw	a5,a3,a5
    80016248:	2781                	sext.w	a5,a5
    8001624a:	9fb9                	addw	a5,a5,a4
    8001624c:	2781                	sext.w	a5,a5
    8001624e:	1782                	slli	a5,a5,0x20
    80016250:	9381                	srli	a5,a5,0x20
    80016252:	a019                	j	80016258 <minix3_put_data+0x1c6>
    80016254:	e5446783          	lwu	a5,-428(s0)
    80016258:	eaf43c23          	sd	a5,-328(s0)
            memcpy(zone_data + offset - file_cursor, data, remaining);
    8001625c:	e6046703          	lwu	a4,-416(s0)
    80016260:	f8846783          	lwu	a5,-120(s0)
    80016264:	40f707b3          	sub	a5,a4,a5
    80016268:	f7043703          	ld	a4,-144(s0)
    8001626c:	97ba                	add	a5,a5,a4
    8001626e:	eb843703          	ld	a4,-328(s0)
    80016272:	2701                	sext.w	a4,a4
    80016274:	863a                	mv	a2,a4
    80016276:	e5843583          	ld	a1,-424(s0)
    8001627a:	853e                	mv	a0,a5
    8001627c:	3f3090ef          	jal	ra,8001fe6e <memcpy>
            debugf("Wrote %u bytes to zone %u at offset %u (0x%x)\n", remaining, zone, offset, offset);
            minix3_put_zone(block_device, zone, zone_data);
    80016280:	ec442783          	lw	a5,-316(s0)
    80016284:	f7043603          	ld	a2,-144(s0)
    80016288:	85be                	mv	a1,a5
    8001628a:	e6843503          	ld	a0,-408(s0)
    8001628e:	8dafe0ef          	jal	ra,80014368 <minix3_put_zone>

            buffer_cursor += remaining;
    80016292:	eb843783          	ld	a5,-328(s0)
    80016296:	2781                	sext.w	a5,a5
    80016298:	f8442703          	lw	a4,-124(s0)
    8001629c:	9fb9                	addw	a5,a5,a4
    8001629e:	f8f42223          	sw	a5,-124(s0)
            file_cursor = offset + remaining;
    800162a2:	eb843783          	ld	a5,-328(s0)
    800162a6:	2781                	sext.w	a5,a5
    800162a8:	e6042703          	lw	a4,-416(s0)
    800162ac:	9fb9                	addw	a5,a5,a4
    800162ae:	f8f42423          	sw	a5,-120(s0)
            if (buffer_cursor >= count) {
    800162b2:	f8442703          	lw	a4,-124(s0)
    800162b6:	e5442783          	lw	a5,-428(s0)
    800162ba:	2701                	sext.w	a4,a4
    800162bc:	2781                	sext.w	a5,a5
    800162be:	0ef76163          	bltu	a4,a5,800163a0 <minix3_put_data+0x30e>
                // We're done
                return;
    800162c2:	4b70006f          	j	80016f78 <minix3_put_data+0xee6>
            }

            continue;
        }

        memset(zone_data, 0, minix3_get_zone_size(block_device));
    800162c6:	e6843503          	ld	a0,-408(s0)
    800162ca:	c94fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800162ce:	87aa                	mv	a5,a0
    800162d0:	2781                	sext.w	a5,a5
    800162d2:	863e                	mv	a2,a5
    800162d4:	4581                	li	a1,0
    800162d6:	f7043503          	ld	a0,-144(s0)
    800162da:	293090ef          	jal	ra,8001fd6c <memset>

        // Write the buffer into the zone
        if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    800162de:	e6843503          	ld	a0,-408(s0)
    800162e2:	c7cfe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800162e6:	87aa                	mv	a5,a0
    800162e8:	2781                	sext.w	a5,a5
    800162ea:	f8442703          	lw	a4,-124(s0)
    800162ee:	9fb9                	addw	a5,a5,a4
    800162f0:	0007871b          	sext.w	a4,a5
    800162f4:	e5442783          	lw	a5,-428(s0)
    800162f8:	2781                	sext.w	a5,a5
    800162fa:	04e7fa63          	bgeu	a5,a4,8001634e <minix3_put_data+0x2bc>
            minix3_get_zone(block_device, zone, zone_data);
    800162fe:	ec442783          	lw	a5,-316(s0)
    80016302:	f7043603          	ld	a2,-144(s0)
    80016306:	85be                	mv	a1,a5
    80016308:	e6843503          	ld	a0,-408(s0)
    8001630c:	fb1fd0ef          	jal	ra,800142bc <minix3_get_zone>
            debugf("Writing last direct zone %d\n", zone);
            // Copy the remaining data into the buffer
            memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    80016310:	f8446783          	lwu	a5,-124(s0)
    80016314:	e5843703          	ld	a4,-424(s0)
    80016318:	00f706b3          	add	a3,a4,a5
    8001631c:	e5442703          	lw	a4,-428(s0)
    80016320:	f8442783          	lw	a5,-124(s0)
    80016324:	40f707bb          	subw	a5,a4,a5
    80016328:	2781                	sext.w	a5,a5
    8001632a:	2781                	sext.w	a5,a5
    8001632c:	863e                	mv	a2,a5
    8001632e:	85b6                	mv	a1,a3
    80016330:	f7043503          	ld	a0,-144(s0)
    80016334:	33b090ef          	jal	ra,8001fe6e <memcpy>
            // We're done
            minix3_put_zone(block_device, zone, zone_data);
    80016338:	ec442783          	lw	a5,-316(s0)
    8001633c:	f7043603          	ld	a2,-144(s0)
    80016340:	85be                	mv	a1,a5
    80016342:	e6843503          	ld	a0,-408(s0)
    80016346:	822fe0ef          	jal	ra,80014368 <minix3_put_zone>
            return;
    8001634a:	42f0006f          	j	80016f78 <minix3_put_data+0xee6>
        } else {
            debugf("Writing direct zone %d\n", zone);
            // Copy the entire zone into the buffer
            memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    8001634e:	f8446783          	lwu	a5,-124(s0)
    80016352:	e5843703          	ld	a4,-424(s0)
    80016356:	00f704b3          	add	s1,a4,a5
    8001635a:	e6843503          	ld	a0,-408(s0)
    8001635e:	c00fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016362:	87aa                	mv	a5,a0
    80016364:	2781                	sext.w	a5,a5
    80016366:	863e                	mv	a2,a5
    80016368:	85a6                	mv	a1,s1
    8001636a:	f7043503          	ld	a0,-144(s0)
    8001636e:	301090ef          	jal	ra,8001fe6e <memcpy>
            minix3_put_zone(block_device, zone, zone_data);
    80016372:	ec442783          	lw	a5,-316(s0)
    80016376:	f7043603          	ld	a2,-144(s0)
    8001637a:	85be                	mv	a1,a5
    8001637c:	e6843503          	ld	a0,-408(s0)
    80016380:	fe9fd0ef          	jal	ra,80014368 <minix3_put_zone>
        }
        buffer_cursor += minix3_get_zone_size(block_device);
    80016384:	e6843503          	ld	a0,-408(s0)
    80016388:	bd6fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001638c:	87aa                	mv	a5,a0
    8001638e:	2781                	sext.w	a5,a5
    80016390:	f8442703          	lw	a4,-124(s0)
    80016394:	9fb9                	addw	a5,a5,a4
    80016396:	f8f42223          	sw	a5,-124(s0)
    8001639a:	a021                	j	800163a2 <minix3_put_data+0x310>
            continue;
    8001639c:	0001                	nop
    8001639e:	a011                	j	800163a2 <minix3_put_data+0x310>
            continue;
    800163a0:	0001                	nop
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    800163a2:	f8d44783          	lbu	a5,-115(s0)
    800163a6:	2785                	addiw	a5,a5,1
    800163a8:	f8f406a3          	sb	a5,-115(s0)
    800163ac:	f8d44783          	lbu	a5,-115(s0)
    800163b0:	0ff7f713          	andi	a4,a5,255
    800163b4:	4799                	li	a5,6
    800163b6:	dce7f8e3          	bgeu	a5,a4,80016186 <minix3_put_data+0xf4>
    }

    debugf("Done with direct zones\n");
    // The next zone is an indirect zone
    if (inode_data.zones[7] != 0) {
    800163ba:	eac42783          	lw	a5,-340(s0)
    800163be:	2e078c63          	beqz	a5,800166b6 <minix3_put_data+0x624>
    800163c2:	878a                	mv	a5,sp
    800163c4:	893e                	mv	s2,a5
        uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    800163c6:	e6843503          	ld	a0,-408(s0)
    800163ca:	b94fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800163ce:	87aa                	mv	a5,a0
    800163d0:	0027d79b          	srliw	a5,a5,0x2
    800163d4:	17c2                	slli	a5,a5,0x30
    800163d6:	93c1                	srli	a5,a5,0x30
    800163d8:	873e                	mv	a4,a5
    800163da:	177d                	addi	a4,a4,-1
    800163dc:	f6e43423          	sd	a4,-152(s0)
    800163e0:	e2f43023          	sd	a5,-480(s0)
    800163e4:	e2043423          	sd	zero,-472(s0)
    800163e8:	e2043703          	ld	a4,-480(s0)
    800163ec:	936d                	srli	a4,a4,0x3b
    800163ee:	e2843683          	ld	a3,-472(s0)
    800163f2:	0696                	slli	a3,a3,0x5
    800163f4:	d4d43c23          	sd	a3,-680(s0)
    800163f8:	d5843683          	ld	a3,-680(s0)
    800163fc:	8f55                	or	a4,a4,a3
    800163fe:	d4e43c23          	sd	a4,-680(s0)
    80016402:	e2043703          	ld	a4,-480(s0)
    80016406:	0716                	slli	a4,a4,0x5
    80016408:	d4e43823          	sd	a4,-688(s0)
    8001640c:	e0f43823          	sd	a5,-496(s0)
    80016410:	e0043c23          	sd	zero,-488(s0)
    80016414:	e1043703          	ld	a4,-496(s0)
    80016418:	936d                	srli	a4,a4,0x3b
    8001641a:	e1843683          	ld	a3,-488(s0)
    8001641e:	0696                	slli	a3,a3,0x5
    80016420:	d4d43423          	sd	a3,-696(s0)
    80016424:	d4843683          	ld	a3,-696(s0)
    80016428:	8f55                	or	a4,a4,a3
    8001642a:	d4e43423          	sd	a4,-696(s0)
    8001642e:	e1043703          	ld	a4,-496(s0)
    80016432:	0716                	slli	a4,a4,0x5
    80016434:	d4e43023          	sd	a4,-704(s0)
    80016438:	078a                	slli	a5,a5,0x2
    8001643a:	07bd                	addi	a5,a5,15
    8001643c:	8391                	srli	a5,a5,0x4
    8001643e:	0792                	slli	a5,a5,0x4
    80016440:	40f10133          	sub	sp,sp,a5
    80016444:	878a                	mv	a5,sp
    80016446:	078d                	addi	a5,a5,3
    80016448:	8389                	srli	a5,a5,0x2
    8001644a:	078a                	slli	a5,a5,0x2
    8001644c:	f6f43023          	sd	a5,-160(s0)
        minix3_get_zone(block_device, inode_data.zones[7], (uint8_t*)indirect_zones);
    80016450:	eac42783          	lw	a5,-340(s0)
    80016454:	f6043603          	ld	a2,-160(s0)
    80016458:	85be                	mv	a1,a5
    8001645a:	e6843503          	ld	a0,-408(s0)
    8001645e:	e5ffd0ef          	jal	ra,800142bc <minix3_get_zone>

        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80016462:	f8040723          	sb	zero,-114(s0)
    80016466:	a405                	j	80016686 <minix3_put_data+0x5f4>
            uint32_t zone = indirect_zones[indirect_zone];
    80016468:	f8e44783          	lbu	a5,-114(s0)
    8001646c:	2781                	sext.w	a5,a5
    8001646e:	f6043703          	ld	a4,-160(s0)
    80016472:	078a                	slli	a5,a5,0x2
    80016474:	97ba                	add	a5,a5,a4
    80016476:	439c                	lw	a5,0(a5)
    80016478:	f4f42e23          	sw	a5,-164(s0)
            if (zone == 0) continue;
    8001647c:	f5c42783          	lw	a5,-164(s0)
    80016480:	2781                	sext.w	a5,a5
    80016482:	1e078a63          	beqz	a5,80016676 <minix3_put_data+0x5e4>
            debugf("Writing indirect zone %d\n", zone);

            if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80016486:	e6843503          	ld	a0,-408(s0)
    8001648a:	ad4fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001648e:	87aa                	mv	a5,a0
    80016490:	2781                	sext.w	a5,a5
    80016492:	f8842703          	lw	a4,-120(s0)
    80016496:	9fb9                	addw	a5,a5,a4
    80016498:	0007871b          	sext.w	a4,a5
    8001649c:	e6042783          	lw	a5,-416(s0)
    800164a0:	2781                	sext.w	a5,a5
    800164a2:	00f77e63          	bgeu	a4,a5,800164be <minix3_put_data+0x42c>
                // We're not at the offset yet
                file_cursor += minix3_get_zone_size(block_device);
    800164a6:	e6843503          	ld	a0,-408(s0)
    800164aa:	ab4fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800164ae:	87aa                	mv	a5,a0
    800164b0:	2781                	sext.w	a5,a5
    800164b2:	f8842703          	lw	a4,-120(s0)
    800164b6:	9fb9                	addw	a5,a5,a4
    800164b8:	f8f42423          	sw	a5,-120(s0)
                continue;
    800164bc:	a2c1                	j	8001667c <minix3_put_data+0x5ea>
            } else if (file_cursor < offset) {
    800164be:	f8842703          	lw	a4,-120(s0)
    800164c2:	e6042783          	lw	a5,-416(s0)
    800164c6:	2701                	sext.w	a4,a4
    800164c8:	2781                	sext.w	a5,a5
    800164ca:	0cf77c63          	bgeu	a4,a5,800165a2 <minix3_put_data+0x510>
                // We're in the middle of the offset
                // Read the zone into the buffer
                minix3_get_zone(block_device, zone, zone_data);
    800164ce:	f5c42783          	lw	a5,-164(s0)
    800164d2:	f7043603          	ld	a2,-144(s0)
    800164d6:	85be                	mv	a1,a5
    800164d8:	e6843503          	ld	a0,-408(s0)
    800164dc:	de1fd0ef          	jal	ra,800142bc <minix3_get_zone>
                // Copy the remaining data into the buffer
                size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    800164e0:	e6843503          	ld	a0,-408(s0)
    800164e4:	a7afe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800164e8:	87aa                	mv	a5,a0
    800164ea:	0007871b          	sext.w	a4,a5
    800164ee:	f8842683          	lw	a3,-120(s0)
    800164f2:	e6042783          	lw	a5,-416(s0)
    800164f6:	40f687bb          	subw	a5,a3,a5
    800164fa:	2781                	sext.w	a5,a5
    800164fc:	9fb9                	addw	a5,a5,a4
    800164fe:	0007871b          	sext.w	a4,a5
    80016502:	e5442783          	lw	a5,-428(s0)
    80016506:	2781                	sext.w	a5,a5
    80016508:	02e7e563          	bltu	a5,a4,80016532 <minix3_put_data+0x4a0>
    8001650c:	e6843503          	ld	a0,-408(s0)
    80016510:	a4efe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016514:	87aa                	mv	a5,a0
    80016516:	0007871b          	sext.w	a4,a5
    8001651a:	f8842683          	lw	a3,-120(s0)
    8001651e:	e6042783          	lw	a5,-416(s0)
    80016522:	40f687bb          	subw	a5,a3,a5
    80016526:	2781                	sext.w	a5,a5
    80016528:	9fb9                	addw	a5,a5,a4
    8001652a:	2781                	sext.w	a5,a5
    8001652c:	1782                	slli	a5,a5,0x20
    8001652e:	9381                	srli	a5,a5,0x20
    80016530:	a019                	j	80016536 <minix3_put_data+0x4a4>
    80016532:	e5446783          	lwu	a5,-428(s0)
    80016536:	f4f43823          	sd	a5,-176(s0)
                memcpy(zone_data + offset - file_cursor, data, remaining);
    8001653a:	e6046703          	lwu	a4,-416(s0)
    8001653e:	f8846783          	lwu	a5,-120(s0)
    80016542:	40f707b3          	sub	a5,a4,a5
    80016546:	f7043703          	ld	a4,-144(s0)
    8001654a:	97ba                	add	a5,a5,a4
    8001654c:	f5043703          	ld	a4,-176(s0)
    80016550:	2701                	sext.w	a4,a4
    80016552:	863a                	mv	a2,a4
    80016554:	e5843583          	ld	a1,-424(s0)
    80016558:	853e                	mv	a0,a5
    8001655a:	115090ef          	jal	ra,8001fe6e <memcpy>
                minix3_put_zone(block_device, zone, zone_data);
    8001655e:	f5c42783          	lw	a5,-164(s0)
    80016562:	f7043603          	ld	a2,-144(s0)
    80016566:	85be                	mv	a1,a5
    80016568:	e6843503          	ld	a0,-408(s0)
    8001656c:	dfdfd0ef          	jal	ra,80014368 <minix3_put_zone>

                buffer_cursor += remaining;
    80016570:	f5043783          	ld	a5,-176(s0)
    80016574:	2781                	sext.w	a5,a5
    80016576:	f8442703          	lw	a4,-124(s0)
    8001657a:	9fb9                	addw	a5,a5,a4
    8001657c:	f8f42223          	sw	a5,-124(s0)
                file_cursor = offset + remaining;
    80016580:	f5043783          	ld	a5,-176(s0)
    80016584:	2781                	sext.w	a5,a5
    80016586:	e6042703          	lw	a4,-416(s0)
    8001658a:	9fb9                	addw	a5,a5,a4
    8001658c:	f8f42423          	sw	a5,-120(s0)
                if (buffer_cursor >= count) {
    80016590:	f8442703          	lw	a4,-124(s0)
    80016594:	e5442783          	lw	a5,-428(s0)
    80016598:	2701                	sext.w	a4,a4
    8001659a:	2781                	sext.w	a5,a5
    8001659c:	0cf76f63          	bltu	a4,a5,8001667a <minix3_put_data+0x5e8>
                    // We're done
                    return;
    800165a0:	aa01                	j	800166b0 <minix3_put_data+0x61e>
                }
                continue;
            }

            memset(zone_data, 0, minix3_get_zone_size(block_device));
    800165a2:	e6843503          	ld	a0,-408(s0)
    800165a6:	9b8fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800165aa:	87aa                	mv	a5,a0
    800165ac:	2781                	sext.w	a5,a5
    800165ae:	863e                	mv	a2,a5
    800165b0:	4581                	li	a1,0
    800165b2:	f7043503          	ld	a0,-144(s0)
    800165b6:	7b6090ef          	jal	ra,8001fd6c <memset>

            if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    800165ba:	e6843503          	ld	a0,-408(s0)
    800165be:	9a0fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800165c2:	87aa                	mv	a5,a0
    800165c4:	2781                	sext.w	a5,a5
    800165c6:	f8442703          	lw	a4,-124(s0)
    800165ca:	9fb9                	addw	a5,a5,a4
    800165cc:	0007871b          	sext.w	a4,a5
    800165d0:	e5442783          	lw	a5,-428(s0)
    800165d4:	2781                	sext.w	a5,a5
    800165d6:	04e7f963          	bgeu	a5,a4,80016628 <minix3_put_data+0x596>
                minix3_get_zone(block_device, zone, zone_data);
    800165da:	f5c42783          	lw	a5,-164(s0)
    800165de:	f7043603          	ld	a2,-144(s0)
    800165e2:	85be                	mv	a1,a5
    800165e4:	e6843503          	ld	a0,-408(s0)
    800165e8:	cd5fd0ef          	jal	ra,800142bc <minix3_get_zone>
                // Copy the remaining data into the buffer
                memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    800165ec:	f8446783          	lwu	a5,-124(s0)
    800165f0:	e5843703          	ld	a4,-424(s0)
    800165f4:	00f706b3          	add	a3,a4,a5
    800165f8:	e5442703          	lw	a4,-428(s0)
    800165fc:	f8442783          	lw	a5,-124(s0)
    80016600:	40f707bb          	subw	a5,a4,a5
    80016604:	2781                	sext.w	a5,a5
    80016606:	2781                	sext.w	a5,a5
    80016608:	863e                	mv	a2,a5
    8001660a:	85b6                	mv	a1,a3
    8001660c:	f7043503          	ld	a0,-144(s0)
    80016610:	05f090ef          	jal	ra,8001fe6e <memcpy>
                // We're done
                minix3_put_zone(block_device, zone, zone_data);
    80016614:	f5c42783          	lw	a5,-164(s0)
    80016618:	f7043603          	ld	a2,-144(s0)
    8001661c:	85be                	mv	a1,a5
    8001661e:	e6843503          	ld	a0,-408(s0)
    80016622:	d47fd0ef          	jal	ra,80014368 <minix3_put_zone>
                return;
    80016626:	a069                	j	800166b0 <minix3_put_data+0x61e>
            } else {
                // Copy the entire zone into the buffer
                memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    80016628:	f8446783          	lwu	a5,-124(s0)
    8001662c:	e5843703          	ld	a4,-424(s0)
    80016630:	00f704b3          	add	s1,a4,a5
    80016634:	e6843503          	ld	a0,-408(s0)
    80016638:	926fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001663c:	87aa                	mv	a5,a0
    8001663e:	2781                	sext.w	a5,a5
    80016640:	863e                	mv	a2,a5
    80016642:	85a6                	mv	a1,s1
    80016644:	f7043503          	ld	a0,-144(s0)
    80016648:	027090ef          	jal	ra,8001fe6e <memcpy>
                minix3_put_zone(block_device, zone, zone_data);
    8001664c:	f5c42783          	lw	a5,-164(s0)
    80016650:	f7043603          	ld	a2,-144(s0)
    80016654:	85be                	mv	a1,a5
    80016656:	e6843503          	ld	a0,-408(s0)
    8001665a:	d0ffd0ef          	jal	ra,80014368 <minix3_put_zone>
            }
            buffer_cursor += minix3_get_zone_size(block_device);
    8001665e:	e6843503          	ld	a0,-408(s0)
    80016662:	8fcfe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016666:	87aa                	mv	a5,a0
    80016668:	2781                	sext.w	a5,a5
    8001666a:	f8442703          	lw	a4,-124(s0)
    8001666e:	9fb9                	addw	a5,a5,a4
    80016670:	f8f42223          	sw	a5,-124(s0)
    80016674:	a021                	j	8001667c <minix3_put_data+0x5ea>
            if (zone == 0) continue;
    80016676:	0001                	nop
    80016678:	a011                	j	8001667c <minix3_put_data+0x5ea>
                continue;
    8001667a:	0001                	nop
        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001667c:	f8e44783          	lbu	a5,-114(s0)
    80016680:	2785                	addiw	a5,a5,1
    80016682:	f8f40723          	sb	a5,-114(s0)
    80016686:	f8e44783          	lbu	a5,-114(s0)
    8001668a:	03079493          	slli	s1,a5,0x30
    8001668e:	90c1                	srli	s1,s1,0x30
    80016690:	e6843503          	ld	a0,-408(s0)
    80016694:	8cafe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016698:	87aa                	mv	a5,a0
    8001669a:	0027d79b          	srliw	a5,a5,0x2
    8001669e:	17c2                	slli	a5,a5,0x30
    800166a0:	93c1                	srli	a5,a5,0x30
    800166a2:	0004871b          	sext.w	a4,s1
    800166a6:	2781                	sext.w	a5,a5
    800166a8:	dcf760e3          	bltu	a4,a5,80016468 <minix3_put_data+0x3d6>
    800166ac:	814a                	mv	sp,s2
    800166ae:	a021                	j	800166b6 <minix3_put_data+0x624>
    800166b0:	814a                	mv	sp,s2
    800166b2:	0c70006f          	j	80016f78 <minix3_put_data+0xee6>
        debugf("No indirect zone\n");
    }

    // The next zone is a double indirect zone
    // The next zone is a double indirect zone
    if (inode_data.zones[8] != 0) {
    800166b6:	eb042783          	lw	a5,-336(s0)
    800166ba:	3e078463          	beqz	a5,80016aa2 <minix3_put_data+0xa10>
    800166be:	878a                	mv	a5,sp
    800166c0:	89be                	mv	s3,a5
        uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    800166c2:	e6843503          	ld	a0,-408(s0)
    800166c6:	898fe0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800166ca:	87aa                	mv	a5,a0
    800166cc:	0027d79b          	srliw	a5,a5,0x2
    800166d0:	17c2                	slli	a5,a5,0x30
    800166d2:	93c1                	srli	a5,a5,0x30
    800166d4:	873e                	mv	a4,a5
    800166d6:	177d                	addi	a4,a4,-1
    800166d8:	f4e43423          	sd	a4,-184(s0)
    800166dc:	e0f43023          	sd	a5,-512(s0)
    800166e0:	e0043423          	sd	zero,-504(s0)
    800166e4:	e0043703          	ld	a4,-512(s0)
    800166e8:	936d                	srli	a4,a4,0x3b
    800166ea:	e0843683          	ld	a3,-504(s0)
    800166ee:	0696                	slli	a3,a3,0x5
    800166f0:	d2d43c23          	sd	a3,-712(s0)
    800166f4:	d3843683          	ld	a3,-712(s0)
    800166f8:	8f55                	or	a4,a4,a3
    800166fa:	d2e43c23          	sd	a4,-712(s0)
    800166fe:	e0043703          	ld	a4,-512(s0)
    80016702:	0716                	slli	a4,a4,0x5
    80016704:	d2e43823          	sd	a4,-720(s0)
    80016708:	def43823          	sd	a5,-528(s0)
    8001670c:	de043c23          	sd	zero,-520(s0)
    80016710:	df043703          	ld	a4,-528(s0)
    80016714:	936d                	srli	a4,a4,0x3b
    80016716:	df843683          	ld	a3,-520(s0)
    8001671a:	0696                	slli	a3,a3,0x5
    8001671c:	d2d43423          	sd	a3,-728(s0)
    80016720:	d2843683          	ld	a3,-728(s0)
    80016724:	8f55                	or	a4,a4,a3
    80016726:	d2e43423          	sd	a4,-728(s0)
    8001672a:	df043703          	ld	a4,-528(s0)
    8001672e:	0716                	slli	a4,a4,0x5
    80016730:	d2e43023          	sd	a4,-736(s0)
    80016734:	078a                	slli	a5,a5,0x2
    80016736:	07bd                	addi	a5,a5,15
    80016738:	8391                	srli	a5,a5,0x4
    8001673a:	0792                	slli	a5,a5,0x4
    8001673c:	40f10133          	sub	sp,sp,a5
    80016740:	878a                	mv	a5,sp
    80016742:	078d                	addi	a5,a5,3
    80016744:	8389                	srli	a5,a5,0x2
    80016746:	078a                	slli	a5,a5,0x2
    80016748:	f4f43023          	sd	a5,-192(s0)
        // We're done
        minix3_get_zone(block_device, inode_data.zones[8], (uint8_t*)double_indirect_zones);
    8001674c:	eb042783          	lw	a5,-336(s0)
    80016750:	f4043603          	ld	a2,-192(s0)
    80016754:	85be                	mv	a1,a5
    80016756:	e6843503          	ld	a0,-408(s0)
    8001675a:	b63fd0ef          	jal	ra,800142bc <minix3_get_zone>

        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    8001675e:	f80407a3          	sb	zero,-113(s0)
    80016762:	ae21                	j	80016a7a <minix3_put_data+0x9e8>
    80016764:	878a                	mv	a5,sp
    80016766:	84be                	mv	s1,a5
            uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80016768:	f8f44783          	lbu	a5,-113(s0)
    8001676c:	2781                	sext.w	a5,a5
    8001676e:	f4043703          	ld	a4,-192(s0)
    80016772:	078a                	slli	a5,a5,0x2
    80016774:	97ba                	add	a5,a5,a4
    80016776:	439c                	lw	a5,0(a5)
    80016778:	f2f42e23          	sw	a5,-196(s0)
            if (indirect_zone == 0) continue;
    8001677c:	f3c42783          	lw	a5,-196(s0)
    80016780:	2781                	sext.w	a5,a5
    80016782:	e399                	bnez	a5,80016788 <minix3_put_data+0x6f6>
    80016784:	8126                	mv	sp,s1
    80016786:	a4ed                	j	80016a70 <minix3_put_data+0x9de>

            uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80016788:	e6843503          	ld	a0,-408(s0)
    8001678c:	fd3fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016790:	87aa                	mv	a5,a0
    80016792:	0027d79b          	srliw	a5,a5,0x2
    80016796:	17c2                	slli	a5,a5,0x30
    80016798:	93c1                	srli	a5,a5,0x30
    8001679a:	873e                	mv	a4,a5
    8001679c:	177d                	addi	a4,a4,-1
    8001679e:	f2e43823          	sd	a4,-208(s0)
    800167a2:	def43023          	sd	a5,-544(s0)
    800167a6:	de043423          	sd	zero,-536(s0)
    800167aa:	de043703          	ld	a4,-544(s0)
    800167ae:	936d                	srli	a4,a4,0x3b
    800167b0:	de843683          	ld	a3,-536(s0)
    800167b4:	00569a93          	slli	s5,a3,0x5
    800167b8:	01576ab3          	or	s5,a4,s5
    800167bc:	de043703          	ld	a4,-544(s0)
    800167c0:	00571a13          	slli	s4,a4,0x5
    800167c4:	dcf43823          	sd	a5,-560(s0)
    800167c8:	dc043c23          	sd	zero,-552(s0)
    800167cc:	dd043703          	ld	a4,-560(s0)
    800167d0:	936d                	srli	a4,a4,0x3b
    800167d2:	dd843683          	ld	a3,-552(s0)
    800167d6:	0696                	slli	a3,a3,0x5
    800167d8:	d0d43c23          	sd	a3,-744(s0)
    800167dc:	d1843683          	ld	a3,-744(s0)
    800167e0:	8f55                	or	a4,a4,a3
    800167e2:	d0e43c23          	sd	a4,-744(s0)
    800167e6:	dd043703          	ld	a4,-560(s0)
    800167ea:	0716                	slli	a4,a4,0x5
    800167ec:	d0e43823          	sd	a4,-752(s0)
    800167f0:	078a                	slli	a5,a5,0x2
    800167f2:	07bd                	addi	a5,a5,15
    800167f4:	8391                	srli	a5,a5,0x4
    800167f6:	0792                	slli	a5,a5,0x4
    800167f8:	40f10133          	sub	sp,sp,a5
    800167fc:	878a                	mv	a5,sp
    800167fe:	078d                	addi	a5,a5,3
    80016800:	8389                	srli	a5,a5,0x2
    80016802:	078a                	slli	a5,a5,0x2
    80016804:	f2f43423          	sd	a5,-216(s0)
            minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    80016808:	f3c42783          	lw	a5,-196(s0)
    8001680c:	f2843603          	ld	a2,-216(s0)
    80016810:	85be                	mv	a1,a5
    80016812:	e6843503          	ld	a0,-408(s0)
    80016816:	aa7fd0ef          	jal	ra,800142bc <minix3_get_zone>

            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001681a:	f80401a3          	sb	zero,-125(s0)
    8001681e:	a405                	j	80016a3e <minix3_put_data+0x9ac>
                uint32_t zone = indirect_zones[indirect_zone];
    80016820:	f8344783          	lbu	a5,-125(s0)
    80016824:	2781                	sext.w	a5,a5
    80016826:	f2843703          	ld	a4,-216(s0)
    8001682a:	078a                	slli	a5,a5,0x2
    8001682c:	97ba                	add	a5,a5,a4
    8001682e:	439c                	lw	a5,0(a5)
    80016830:	f2f42223          	sw	a5,-220(s0)
                if (zone == 0) continue;
    80016834:	f2442783          	lw	a5,-220(s0)
    80016838:	2781                	sext.w	a5,a5
    8001683a:	1e078a63          	beqz	a5,80016a2e <minix3_put_data+0x99c>
                debugf("Writing double indirect zone %d\n", zone);

                if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    8001683e:	e6843503          	ld	a0,-408(s0)
    80016842:	f1dfd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016846:	87aa                	mv	a5,a0
    80016848:	2781                	sext.w	a5,a5
    8001684a:	f8842703          	lw	a4,-120(s0)
    8001684e:	9fb9                	addw	a5,a5,a4
    80016850:	0007871b          	sext.w	a4,a5
    80016854:	e6042783          	lw	a5,-416(s0)
    80016858:	2781                	sext.w	a5,a5
    8001685a:	00f77e63          	bgeu	a4,a5,80016876 <minix3_put_data+0x7e4>
                    // We're not at the offset yet
                    file_cursor += minix3_get_zone_size(block_device);
    8001685e:	e6843503          	ld	a0,-408(s0)
    80016862:	efdfd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016866:	87aa                	mv	a5,a0
    80016868:	2781                	sext.w	a5,a5
    8001686a:	f8842703          	lw	a4,-120(s0)
    8001686e:	9fb9                	addw	a5,a5,a4
    80016870:	f8f42423          	sw	a5,-120(s0)
                    continue;
    80016874:	a2c1                	j	80016a34 <minix3_put_data+0x9a2>
                } else if (file_cursor < offset) {
    80016876:	f8842703          	lw	a4,-120(s0)
    8001687a:	e6042783          	lw	a5,-416(s0)
    8001687e:	2701                	sext.w	a4,a4
    80016880:	2781                	sext.w	a5,a5
    80016882:	0cf77c63          	bgeu	a4,a5,8001695a <minix3_put_data+0x8c8>
                    // We're in the middle of the offset
                    // Read the zone into the buffer
                    minix3_get_zone(block_device, zone, zone_data);
    80016886:	f2442783          	lw	a5,-220(s0)
    8001688a:	f7043603          	ld	a2,-144(s0)
    8001688e:	85be                	mv	a1,a5
    80016890:	e6843503          	ld	a0,-408(s0)
    80016894:	a29fd0ef          	jal	ra,800142bc <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80016898:	e6843503          	ld	a0,-408(s0)
    8001689c:	ec3fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800168a0:	87aa                	mv	a5,a0
    800168a2:	0007871b          	sext.w	a4,a5
    800168a6:	f8842683          	lw	a3,-120(s0)
    800168aa:	e6042783          	lw	a5,-416(s0)
    800168ae:	40f687bb          	subw	a5,a3,a5
    800168b2:	2781                	sext.w	a5,a5
    800168b4:	9fb9                	addw	a5,a5,a4
    800168b6:	0007871b          	sext.w	a4,a5
    800168ba:	e5442783          	lw	a5,-428(s0)
    800168be:	2781                	sext.w	a5,a5
    800168c0:	02e7e563          	bltu	a5,a4,800168ea <minix3_put_data+0x858>
    800168c4:	e6843503          	ld	a0,-408(s0)
    800168c8:	e97fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800168cc:	87aa                	mv	a5,a0
    800168ce:	0007871b          	sext.w	a4,a5
    800168d2:	f8842683          	lw	a3,-120(s0)
    800168d6:	e6042783          	lw	a5,-416(s0)
    800168da:	40f687bb          	subw	a5,a3,a5
    800168de:	2781                	sext.w	a5,a5
    800168e0:	9fb9                	addw	a5,a5,a4
    800168e2:	2781                	sext.w	a5,a5
    800168e4:	1782                	slli	a5,a5,0x20
    800168e6:	9381                	srli	a5,a5,0x20
    800168e8:	a019                	j	800168ee <minix3_put_data+0x85c>
    800168ea:	e5446783          	lwu	a5,-428(s0)
    800168ee:	f0f43c23          	sd	a5,-232(s0)
                    memcpy(zone_data + offset - file_cursor, data, remaining);
    800168f2:	e6046703          	lwu	a4,-416(s0)
    800168f6:	f8846783          	lwu	a5,-120(s0)
    800168fa:	40f707b3          	sub	a5,a4,a5
    800168fe:	f7043703          	ld	a4,-144(s0)
    80016902:	97ba                	add	a5,a5,a4
    80016904:	f1843703          	ld	a4,-232(s0)
    80016908:	2701                	sext.w	a4,a4
    8001690a:	863a                	mv	a2,a4
    8001690c:	e5843583          	ld	a1,-424(s0)
    80016910:	853e                	mv	a0,a5
    80016912:	55c090ef          	jal	ra,8001fe6e <memcpy>
                    minix3_put_zone(block_device, zone, zone_data);
    80016916:	f2442783          	lw	a5,-220(s0)
    8001691a:	f7043603          	ld	a2,-144(s0)
    8001691e:	85be                	mv	a1,a5
    80016920:	e6843503          	ld	a0,-408(s0)
    80016924:	a45fd0ef          	jal	ra,80014368 <minix3_put_zone>

                    buffer_cursor += remaining;
    80016928:	f1843783          	ld	a5,-232(s0)
    8001692c:	2781                	sext.w	a5,a5
    8001692e:	f8442703          	lw	a4,-124(s0)
    80016932:	9fb9                	addw	a5,a5,a4
    80016934:	f8f42223          	sw	a5,-124(s0)
                    file_cursor = offset + remaining;
    80016938:	f1843783          	ld	a5,-232(s0)
    8001693c:	2781                	sext.w	a5,a5
    8001693e:	e6042703          	lw	a4,-416(s0)
    80016942:	9fb9                	addw	a5,a5,a4
    80016944:	f8f42423          	sw	a5,-120(s0)
                    if (buffer_cursor >= count) {
    80016948:	f8442703          	lw	a4,-124(s0)
    8001694c:	e5442783          	lw	a5,-428(s0)
    80016950:	2701                	sext.w	a4,a4
    80016952:	2781                	sext.w	a5,a5
    80016954:	0cf76f63          	bltu	a4,a5,80016a32 <minix3_put_data+0x9a0>
                        // We're done
                        return;
    80016958:	aa09                	j	80016a6a <minix3_put_data+0x9d8>
                    }
                    continue;
                }

                memset(zone_data, 0, minix3_get_zone_size(block_device));
    8001695a:	e6843503          	ld	a0,-408(s0)
    8001695e:	e01fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016962:	87aa                	mv	a5,a0
    80016964:	2781                	sext.w	a5,a5
    80016966:	863e                	mv	a2,a5
    80016968:	4581                	li	a1,0
    8001696a:	f7043503          	ld	a0,-144(s0)
    8001696e:	3fe090ef          	jal	ra,8001fd6c <memset>
                if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80016972:	e6843503          	ld	a0,-408(s0)
    80016976:	de9fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    8001697a:	87aa                	mv	a5,a0
    8001697c:	2781                	sext.w	a5,a5
    8001697e:	f8442703          	lw	a4,-124(s0)
    80016982:	9fb9                	addw	a5,a5,a4
    80016984:	0007871b          	sext.w	a4,a5
    80016988:	e5442783          	lw	a5,-428(s0)
    8001698c:	2781                	sext.w	a5,a5
    8001698e:	04e7f963          	bgeu	a5,a4,800169e0 <minix3_put_data+0x94e>
                    minix3_get_zone(block_device, zone, zone_data);
    80016992:	f2442783          	lw	a5,-220(s0)
    80016996:	f7043603          	ld	a2,-144(s0)
    8001699a:	85be                	mv	a1,a5
    8001699c:	e6843503          	ld	a0,-408(s0)
    800169a0:	91dfd0ef          	jal	ra,800142bc <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    800169a4:	f8446783          	lwu	a5,-124(s0)
    800169a8:	e5843703          	ld	a4,-424(s0)
    800169ac:	00f706b3          	add	a3,a4,a5
    800169b0:	e5442703          	lw	a4,-428(s0)
    800169b4:	f8442783          	lw	a5,-124(s0)
    800169b8:	40f707bb          	subw	a5,a4,a5
    800169bc:	2781                	sext.w	a5,a5
    800169be:	2781                	sext.w	a5,a5
    800169c0:	863e                	mv	a2,a5
    800169c2:	85b6                	mv	a1,a3
    800169c4:	f7043503          	ld	a0,-144(s0)
    800169c8:	4a6090ef          	jal	ra,8001fe6e <memcpy>
                    // We're done
                    minix3_put_zone(block_device, zone, zone_data);
    800169cc:	f2442783          	lw	a5,-220(s0)
    800169d0:	f7043603          	ld	a2,-144(s0)
    800169d4:	85be                	mv	a1,a5
    800169d6:	e6843503          	ld	a0,-408(s0)
    800169da:	98ffd0ef          	jal	ra,80014368 <minix3_put_zone>
                    return;
    800169de:	a071                	j	80016a6a <minix3_put_data+0x9d8>
                } else {
                    // Copy the entire zone into the buffer
                    memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    800169e0:	f8446783          	lwu	a5,-124(s0)
    800169e4:	e5843703          	ld	a4,-424(s0)
    800169e8:	00f70933          	add	s2,a4,a5
    800169ec:	e6843503          	ld	a0,-408(s0)
    800169f0:	d6ffd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    800169f4:	87aa                	mv	a5,a0
    800169f6:	2781                	sext.w	a5,a5
    800169f8:	863e                	mv	a2,a5
    800169fa:	85ca                	mv	a1,s2
    800169fc:	f7043503          	ld	a0,-144(s0)
    80016a00:	46e090ef          	jal	ra,8001fe6e <memcpy>
                    minix3_put_zone(block_device, zone, zone_data);
    80016a04:	f2442783          	lw	a5,-220(s0)
    80016a08:	f7043603          	ld	a2,-144(s0)
    80016a0c:	85be                	mv	a1,a5
    80016a0e:	e6843503          	ld	a0,-408(s0)
    80016a12:	957fd0ef          	jal	ra,80014368 <minix3_put_zone>
                }

                buffer_cursor += minix3_get_zone_size(block_device);
    80016a16:	e6843503          	ld	a0,-408(s0)
    80016a1a:	d45fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016a1e:	87aa                	mv	a5,a0
    80016a20:	2781                	sext.w	a5,a5
    80016a22:	f8442703          	lw	a4,-124(s0)
    80016a26:	9fb9                	addw	a5,a5,a4
    80016a28:	f8f42223          	sw	a5,-124(s0)
    80016a2c:	a021                	j	80016a34 <minix3_put_data+0x9a2>
                if (zone == 0) continue;
    80016a2e:	0001                	nop
    80016a30:	a011                	j	80016a34 <minix3_put_data+0x9a2>
                    continue;
    80016a32:	0001                	nop
            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80016a34:	f8344783          	lbu	a5,-125(s0)
    80016a38:	2785                	addiw	a5,a5,1
    80016a3a:	f8f401a3          	sb	a5,-125(s0)
    80016a3e:	f8344783          	lbu	a5,-125(s0)
    80016a42:	03079913          	slli	s2,a5,0x30
    80016a46:	03095913          	srli	s2,s2,0x30
    80016a4a:	e6843503          	ld	a0,-408(s0)
    80016a4e:	d11fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016a52:	87aa                	mv	a5,a0
    80016a54:	0027d79b          	srliw	a5,a5,0x2
    80016a58:	17c2                	slli	a5,a5,0x30
    80016a5a:	93c1                	srli	a5,a5,0x30
    80016a5c:	0009071b          	sext.w	a4,s2
    80016a60:	2781                	sext.w	a5,a5
    80016a62:	daf76fe3          	bltu	a4,a5,80016820 <minix3_put_data+0x78e>
    80016a66:	8126                	mv	sp,s1
    80016a68:	a021                	j	80016a70 <minix3_put_data+0x9de>
    80016a6a:	8126                	mv	sp,s1
    80016a6c:	814e                	mv	sp,s3
    80016a6e:	a329                	j	80016f78 <minix3_put_data+0xee6>
        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80016a70:	f8f44783          	lbu	a5,-113(s0)
    80016a74:	2785                	addiw	a5,a5,1
    80016a76:	f8f407a3          	sb	a5,-113(s0)
    80016a7a:	f8f44783          	lbu	a5,-113(s0)
    80016a7e:	03079493          	slli	s1,a5,0x30
    80016a82:	90c1                	srli	s1,s1,0x30
    80016a84:	e6843503          	ld	a0,-408(s0)
    80016a88:	cd7fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016a8c:	87aa                	mv	a5,a0
    80016a8e:	0027d79b          	srliw	a5,a5,0x2
    80016a92:	17c2                	slli	a5,a5,0x30
    80016a94:	93c1                	srli	a5,a5,0x30
    80016a96:	0004871b          	sext.w	a4,s1
    80016a9a:	2781                	sext.w	a5,a5
    80016a9c:	ccf764e3          	bltu	a4,a5,80016764 <minix3_put_data+0x6d2>
    80016aa0:	814e                	mv	sp,s3
    } else {
        debugf("No double indirect zone\n");
    }

    // The next zone is a triple indirect zone
    if (inode_data.zones[9] != 0) {
    80016aa2:	eb442783          	lw	a5,-332(s0)
    80016aa6:	4c078863          	beqz	a5,80016f76 <minix3_put_data+0xee4>
    80016aaa:	878a                	mv	a5,sp
    80016aac:	8a3e                	mv	s4,a5
        uint32_t triple_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80016aae:	e6843503          	ld	a0,-408(s0)
    80016ab2:	cadfd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016ab6:	87aa                	mv	a5,a0
    80016ab8:	0027d79b          	srliw	a5,a5,0x2
    80016abc:	17c2                	slli	a5,a5,0x30
    80016abe:	93c1                	srli	a5,a5,0x30
    80016ac0:	873e                	mv	a4,a5
    80016ac2:	177d                	addi	a4,a4,-1
    80016ac4:	f0e43823          	sd	a4,-240(s0)
    80016ac8:	dcf43023          	sd	a5,-576(s0)
    80016acc:	dc043423          	sd	zero,-568(s0)
    80016ad0:	dc043703          	ld	a4,-576(s0)
    80016ad4:	936d                	srli	a4,a4,0x3b
    80016ad6:	dc843683          	ld	a3,-568(s0)
    80016ada:	0696                	slli	a3,a3,0x5
    80016adc:	d0d43423          	sd	a3,-760(s0)
    80016ae0:	d0843683          	ld	a3,-760(s0)
    80016ae4:	8f55                	or	a4,a4,a3
    80016ae6:	d0e43423          	sd	a4,-760(s0)
    80016aea:	dc043703          	ld	a4,-576(s0)
    80016aee:	0716                	slli	a4,a4,0x5
    80016af0:	d0e43023          	sd	a4,-768(s0)
    80016af4:	daf43823          	sd	a5,-592(s0)
    80016af8:	da043c23          	sd	zero,-584(s0)
    80016afc:	db043703          	ld	a4,-592(s0)
    80016b00:	936d                	srli	a4,a4,0x3b
    80016b02:	db843683          	ld	a3,-584(s0)
    80016b06:	0696                	slli	a3,a3,0x5
    80016b08:	ced43c23          	sd	a3,-776(s0)
    80016b0c:	cf843683          	ld	a3,-776(s0)
    80016b10:	8f55                	or	a4,a4,a3
    80016b12:	cee43c23          	sd	a4,-776(s0)
    80016b16:	db043703          	ld	a4,-592(s0)
    80016b1a:	0716                	slli	a4,a4,0x5
    80016b1c:	cee43823          	sd	a4,-784(s0)
    80016b20:	078a                	slli	a5,a5,0x2
    80016b22:	07bd                	addi	a5,a5,15
    80016b24:	8391                	srli	a5,a5,0x4
    80016b26:	0792                	slli	a5,a5,0x4
    80016b28:	40f10133          	sub	sp,sp,a5
    80016b2c:	878a                	mv	a5,sp
    80016b2e:	078d                	addi	a5,a5,3
    80016b30:	8389                	srli	a5,a5,0x2
    80016b32:	078a                	slli	a5,a5,0x2
    80016b34:	f0f43423          	sd	a5,-248(s0)
        minix3_get_zone(block_device, inode_data.zones[9], (uint8_t*)triple_indirect_zones);
    80016b38:	eb442783          	lw	a5,-332(s0)
    80016b3c:	f0843603          	ld	a2,-248(s0)
    80016b40:	85be                	mv	a1,a5
    80016b42:	e6843503          	ld	a0,-408(s0)
    80016b46:	f76fd0ef          	jal	ra,800142bc <minix3_get_zone>

        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    80016b4a:	f8040123          	sb	zero,-126(s0)
    80016b4e:	a101                	j	80016f4e <minix3_put_data+0xebc>
    80016b50:	878a                	mv	a5,sp
    80016b52:	84be                	mv	s1,a5
            uint32_t double_indirect_zone = triple_indirect_zones[triple_indirect_zone];
    80016b54:	f8244783          	lbu	a5,-126(s0)
    80016b58:	2781                	sext.w	a5,a5
    80016b5a:	f0843703          	ld	a4,-248(s0)
    80016b5e:	078a                	slli	a5,a5,0x2
    80016b60:	97ba                	add	a5,a5,a4
    80016b62:	439c                	lw	a5,0(a5)
    80016b64:	f0f42223          	sw	a5,-252(s0)
            if (double_indirect_zone == 0) continue;
    80016b68:	f0442783          	lw	a5,-252(s0)
    80016b6c:	2781                	sext.w	a5,a5
    80016b6e:	e399                	bnez	a5,80016b74 <minix3_put_data+0xae2>
    80016b70:	8126                	mv	sp,s1
    80016b72:	aec9                	j	80016f44 <minix3_put_data+0xeb2>
            uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80016b74:	e6843503          	ld	a0,-408(s0)
    80016b78:	be7fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016b7c:	87aa                	mv	a5,a0
    80016b7e:	0027d79b          	srliw	a5,a5,0x2
    80016b82:	17c2                	slli	a5,a5,0x30
    80016b84:	93c1                	srli	a5,a5,0x30
    80016b86:	873e                	mv	a4,a5
    80016b88:	177d                	addi	a4,a4,-1
    80016b8a:	eee43c23          	sd	a4,-264(s0)
    80016b8e:	daf43023          	sd	a5,-608(s0)
    80016b92:	da043423          	sd	zero,-600(s0)
    80016b96:	da043703          	ld	a4,-608(s0)
    80016b9a:	936d                	srli	a4,a4,0x3b
    80016b9c:	da843683          	ld	a3,-600(s0)
    80016ba0:	00569b93          	slli	s7,a3,0x5
    80016ba4:	01776bb3          	or	s7,a4,s7
    80016ba8:	da043703          	ld	a4,-608(s0)
    80016bac:	00571b13          	slli	s6,a4,0x5
    80016bb0:	d8f43823          	sd	a5,-624(s0)
    80016bb4:	d8043c23          	sd	zero,-616(s0)
    80016bb8:	d9043703          	ld	a4,-624(s0)
    80016bbc:	936d                	srli	a4,a4,0x3b
    80016bbe:	d9843683          	ld	a3,-616(s0)
    80016bc2:	00569c93          	slli	s9,a3,0x5
    80016bc6:	01976cb3          	or	s9,a4,s9
    80016bca:	d9043703          	ld	a4,-624(s0)
    80016bce:	00571c13          	slli	s8,a4,0x5
    80016bd2:	078a                	slli	a5,a5,0x2
    80016bd4:	07bd                	addi	a5,a5,15
    80016bd6:	8391                	srli	a5,a5,0x4
    80016bd8:	0792                	slli	a5,a5,0x4
    80016bda:	40f10133          	sub	sp,sp,a5
    80016bde:	878a                	mv	a5,sp
    80016be0:	078d                	addi	a5,a5,3
    80016be2:	8389                	srli	a5,a5,0x2
    80016be4:	078a                	slli	a5,a5,0x2
    80016be6:	eef43823          	sd	a5,-272(s0)
            minix3_get_zone(block_device, double_indirect_zone, (uint8_t*)double_indirect_zones);
    80016bea:	f0442783          	lw	a5,-252(s0)
    80016bee:	ef043603          	ld	a2,-272(s0)
    80016bf2:	85be                	mv	a1,a5
    80016bf4:	e6843503          	ld	a0,-408(s0)
    80016bf8:	ec4fd0ef          	jal	ra,800142bc <minix3_get_zone>

            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80016bfc:	f80400a3          	sb	zero,-127(s0)
    80016c00:	ae29                	j	80016f1a <minix3_put_data+0xe88>
    80016c02:	878a                	mv	a5,sp
    80016c04:	893e                	mv	s2,a5
                uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80016c06:	f8144783          	lbu	a5,-127(s0)
    80016c0a:	2781                	sext.w	a5,a5
    80016c0c:	ef043703          	ld	a4,-272(s0)
    80016c10:	078a                	slli	a5,a5,0x2
    80016c12:	97ba                	add	a5,a5,a4
    80016c14:	439c                	lw	a5,0(a5)
    80016c16:	eef42623          	sw	a5,-276(s0)
                if (indirect_zone == 0) continue;
    80016c1a:	eec42783          	lw	a5,-276(s0)
    80016c1e:	2781                	sext.w	a5,a5
    80016c20:	e399                	bnez	a5,80016c26 <minix3_put_data+0xb94>
    80016c22:	814a                	mv	sp,s2
    80016c24:	a4f5                	j	80016f10 <minix3_put_data+0xe7e>
                uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80016c26:	e6843503          	ld	a0,-408(s0)
    80016c2a:	b35fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016c2e:	87aa                	mv	a5,a0
    80016c30:	0027d79b          	srliw	a5,a5,0x2
    80016c34:	17c2                	slli	a5,a5,0x30
    80016c36:	93c1                	srli	a5,a5,0x30
    80016c38:	873e                	mv	a4,a5
    80016c3a:	177d                	addi	a4,a4,-1
    80016c3c:	eee43023          	sd	a4,-288(s0)
    80016c40:	d8f43023          	sd	a5,-640(s0)
    80016c44:	d8043423          	sd	zero,-632(s0)
    80016c48:	d8043703          	ld	a4,-640(s0)
    80016c4c:	936d                	srli	a4,a4,0x3b
    80016c4e:	d8843683          	ld	a3,-632(s0)
    80016c52:	00569d93          	slli	s11,a3,0x5
    80016c56:	01b76db3          	or	s11,a4,s11
    80016c5a:	d8043703          	ld	a4,-640(s0)
    80016c5e:	00571d13          	slli	s10,a4,0x5
    80016c62:	d6f43823          	sd	a5,-656(s0)
    80016c66:	d6043c23          	sd	zero,-648(s0)
    80016c6a:	d7043703          	ld	a4,-656(s0)
    80016c6e:	936d                	srli	a4,a4,0x3b
    80016c70:	d7843683          	ld	a3,-648(s0)
    80016c74:	0696                	slli	a3,a3,0x5
    80016c76:	ced43423          	sd	a3,-792(s0)
    80016c7a:	ce843683          	ld	a3,-792(s0)
    80016c7e:	8f55                	or	a4,a4,a3
    80016c80:	cee43423          	sd	a4,-792(s0)
    80016c84:	d7043703          	ld	a4,-656(s0)
    80016c88:	0716                	slli	a4,a4,0x5
    80016c8a:	cee43023          	sd	a4,-800(s0)
    80016c8e:	078a                	slli	a5,a5,0x2
    80016c90:	07bd                	addi	a5,a5,15
    80016c92:	8391                	srli	a5,a5,0x4
    80016c94:	0792                	slli	a5,a5,0x4
    80016c96:	40f10133          	sub	sp,sp,a5
    80016c9a:	878a                	mv	a5,sp
    80016c9c:	078d                	addi	a5,a5,3
    80016c9e:	8389                	srli	a5,a5,0x2
    80016ca0:	078a                	slli	a5,a5,0x2
    80016ca2:	ecf43c23          	sd	a5,-296(s0)
                minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    80016ca6:	eec42783          	lw	a5,-276(s0)
    80016caa:	ed843603          	ld	a2,-296(s0)
    80016cae:	85be                	mv	a1,a5
    80016cb0:	e6843503          	ld	a0,-408(s0)
    80016cb4:	e08fd0ef          	jal	ra,800142bc <minix3_get_zone>

                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80016cb8:	f8040023          	sb	zero,-128(s0)
    80016cbc:	a405                	j	80016edc <minix3_put_data+0xe4a>
                    uint32_t zone = indirect_zones[indirect_zone];
    80016cbe:	f8044783          	lbu	a5,-128(s0)
    80016cc2:	2781                	sext.w	a5,a5
    80016cc4:	ed843703          	ld	a4,-296(s0)
    80016cc8:	078a                	slli	a5,a5,0x2
    80016cca:	97ba                	add	a5,a5,a4
    80016ccc:	439c                	lw	a5,0(a5)
    80016cce:	ecf42a23          	sw	a5,-300(s0)
                    if (zone == 0) continue;
    80016cd2:	ed442783          	lw	a5,-300(s0)
    80016cd6:	2781                	sext.w	a5,a5
    80016cd8:	1e078a63          	beqz	a5,80016ecc <minix3_put_data+0xe3a>
                    debugf("Writing triple indirect zone %d\n", zone);

                    if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80016cdc:	e6843503          	ld	a0,-408(s0)
    80016ce0:	a7ffd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016ce4:	87aa                	mv	a5,a0
    80016ce6:	2781                	sext.w	a5,a5
    80016ce8:	f8842703          	lw	a4,-120(s0)
    80016cec:	9fb9                	addw	a5,a5,a4
    80016cee:	0007871b          	sext.w	a4,a5
    80016cf2:	e6042783          	lw	a5,-416(s0)
    80016cf6:	2781                	sext.w	a5,a5
    80016cf8:	00f77e63          	bgeu	a4,a5,80016d14 <minix3_put_data+0xc82>
                        // We're not at the offset yet
                        file_cursor += minix3_get_zone_size(block_device);
    80016cfc:	e6843503          	ld	a0,-408(s0)
    80016d00:	a5ffd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016d04:	87aa                	mv	a5,a0
    80016d06:	2781                	sext.w	a5,a5
    80016d08:	f8842703          	lw	a4,-120(s0)
    80016d0c:	9fb9                	addw	a5,a5,a4
    80016d0e:	f8f42423          	sw	a5,-120(s0)
                        continue;
    80016d12:	a2c1                	j	80016ed2 <minix3_put_data+0xe40>
                    } else if (file_cursor < offset) {
    80016d14:	f8842703          	lw	a4,-120(s0)
    80016d18:	e6042783          	lw	a5,-416(s0)
    80016d1c:	2701                	sext.w	a4,a4
    80016d1e:	2781                	sext.w	a5,a5
    80016d20:	0cf77c63          	bgeu	a4,a5,80016df8 <minix3_put_data+0xd66>
                        // We're in the middle of the offset
                        // Read the zone into the buffer
                        minix3_get_zone(block_device, zone, zone_data);
    80016d24:	ed442783          	lw	a5,-300(s0)
    80016d28:	f7043603          	ld	a2,-144(s0)
    80016d2c:	85be                	mv	a1,a5
    80016d2e:	e6843503          	ld	a0,-408(s0)
    80016d32:	d8afd0ef          	jal	ra,800142bc <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80016d36:	e6843503          	ld	a0,-408(s0)
    80016d3a:	a25fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016d3e:	87aa                	mv	a5,a0
    80016d40:	0007871b          	sext.w	a4,a5
    80016d44:	f8842683          	lw	a3,-120(s0)
    80016d48:	e6042783          	lw	a5,-416(s0)
    80016d4c:	40f687bb          	subw	a5,a3,a5
    80016d50:	2781                	sext.w	a5,a5
    80016d52:	9fb9                	addw	a5,a5,a4
    80016d54:	0007871b          	sext.w	a4,a5
    80016d58:	e5442783          	lw	a5,-428(s0)
    80016d5c:	2781                	sext.w	a5,a5
    80016d5e:	02e7e563          	bltu	a5,a4,80016d88 <minix3_put_data+0xcf6>
    80016d62:	e6843503          	ld	a0,-408(s0)
    80016d66:	9f9fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016d6a:	87aa                	mv	a5,a0
    80016d6c:	0007871b          	sext.w	a4,a5
    80016d70:	f8842683          	lw	a3,-120(s0)
    80016d74:	e6042783          	lw	a5,-416(s0)
    80016d78:	40f687bb          	subw	a5,a3,a5
    80016d7c:	2781                	sext.w	a5,a5
    80016d7e:	9fb9                	addw	a5,a5,a4
    80016d80:	2781                	sext.w	a5,a5
    80016d82:	1782                	slli	a5,a5,0x20
    80016d84:	9381                	srli	a5,a5,0x20
    80016d86:	a019                	j	80016d8c <minix3_put_data+0xcfa>
    80016d88:	e5446783          	lwu	a5,-428(s0)
    80016d8c:	ecf43423          	sd	a5,-312(s0)
                        memcpy(zone_data + offset - file_cursor, data, remaining);
    80016d90:	e6046703          	lwu	a4,-416(s0)
    80016d94:	f8846783          	lwu	a5,-120(s0)
    80016d98:	40f707b3          	sub	a5,a4,a5
    80016d9c:	f7043703          	ld	a4,-144(s0)
    80016da0:	97ba                	add	a5,a5,a4
    80016da2:	ec843703          	ld	a4,-312(s0)
    80016da6:	2701                	sext.w	a4,a4
    80016da8:	863a                	mv	a2,a4
    80016daa:	e5843583          	ld	a1,-424(s0)
    80016dae:	853e                	mv	a0,a5
    80016db0:	0be090ef          	jal	ra,8001fe6e <memcpy>
                        minix3_put_zone(block_device, zone, zone_data);
    80016db4:	ed442783          	lw	a5,-300(s0)
    80016db8:	f7043603          	ld	a2,-144(s0)
    80016dbc:	85be                	mv	a1,a5
    80016dbe:	e6843503          	ld	a0,-408(s0)
    80016dc2:	da6fd0ef          	jal	ra,80014368 <minix3_put_zone>

                        buffer_cursor += remaining;
    80016dc6:	ec843783          	ld	a5,-312(s0)
    80016dca:	2781                	sext.w	a5,a5
    80016dcc:	f8442703          	lw	a4,-124(s0)
    80016dd0:	9fb9                	addw	a5,a5,a4
    80016dd2:	f8f42223          	sw	a5,-124(s0)
                        file_cursor = offset + remaining;
    80016dd6:	ec843783          	ld	a5,-312(s0)
    80016dda:	2781                	sext.w	a5,a5
    80016ddc:	e6042703          	lw	a4,-416(s0)
    80016de0:	9fb9                	addw	a5,a5,a4
    80016de2:	f8f42423          	sw	a5,-120(s0)
                        if (buffer_cursor >= count) {
    80016de6:	f8442703          	lw	a4,-124(s0)
    80016dea:	e5442783          	lw	a5,-428(s0)
    80016dee:	2701                	sext.w	a4,a4
    80016df0:	2781                	sext.w	a5,a5
    80016df2:	0cf76f63          	bltu	a4,a5,80016ed0 <minix3_put_data+0xe3e>
                            // We're done
                            return;
    80016df6:	aa09                	j	80016f08 <minix3_put_data+0xe76>
                        }
                        continue;
                    }

                    memset(zone_data, 0, minix3_get_zone_size(block_device));
    80016df8:	e6843503          	ld	a0,-408(s0)
    80016dfc:	963fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016e00:	87aa                	mv	a5,a0
    80016e02:	2781                	sext.w	a5,a5
    80016e04:	863e                	mv	a2,a5
    80016e06:	4581                	li	a1,0
    80016e08:	f7043503          	ld	a0,-144(s0)
    80016e0c:	761080ef          	jal	ra,8001fd6c <memset>

                    if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80016e10:	e6843503          	ld	a0,-408(s0)
    80016e14:	94bfd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016e18:	87aa                	mv	a5,a0
    80016e1a:	2781                	sext.w	a5,a5
    80016e1c:	f8442703          	lw	a4,-124(s0)
    80016e20:	9fb9                	addw	a5,a5,a4
    80016e22:	0007871b          	sext.w	a4,a5
    80016e26:	e5442783          	lw	a5,-428(s0)
    80016e2a:	2781                	sext.w	a5,a5
    80016e2c:	04e7f963          	bgeu	a5,a4,80016e7e <minix3_put_data+0xdec>
                        minix3_get_zone(block_device, zone, zone_data);
    80016e30:	ed442783          	lw	a5,-300(s0)
    80016e34:	f7043603          	ld	a2,-144(s0)
    80016e38:	85be                	mv	a1,a5
    80016e3a:	e6843503          	ld	a0,-408(s0)
    80016e3e:	c7efd0ef          	jal	ra,800142bc <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    80016e42:	f8446783          	lwu	a5,-124(s0)
    80016e46:	e5843703          	ld	a4,-424(s0)
    80016e4a:	00f706b3          	add	a3,a4,a5
    80016e4e:	e5442703          	lw	a4,-428(s0)
    80016e52:	f8442783          	lw	a5,-124(s0)
    80016e56:	40f707bb          	subw	a5,a4,a5
    80016e5a:	2781                	sext.w	a5,a5
    80016e5c:	2781                	sext.w	a5,a5
    80016e5e:	863e                	mv	a2,a5
    80016e60:	85b6                	mv	a1,a3
    80016e62:	f7043503          	ld	a0,-144(s0)
    80016e66:	008090ef          	jal	ra,8001fe6e <memcpy>
                        // We're done
                        minix3_put_zone(block_device, zone, zone_data);
    80016e6a:	ed442783          	lw	a5,-300(s0)
    80016e6e:	f7043603          	ld	a2,-144(s0)
    80016e72:	85be                	mv	a1,a5
    80016e74:	e6843503          	ld	a0,-408(s0)
    80016e78:	cf0fd0ef          	jal	ra,80014368 <minix3_put_zone>
                        return;
    80016e7c:	a071                	j	80016f08 <minix3_put_data+0xe76>
                    } else {
                        // Copy the entire zone into the buffer
                        memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    80016e7e:	f8446783          	lwu	a5,-124(s0)
    80016e82:	e5843703          	ld	a4,-424(s0)
    80016e86:	00f709b3          	add	s3,a4,a5
    80016e8a:	e6843503          	ld	a0,-408(s0)
    80016e8e:	8d1fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016e92:	87aa                	mv	a5,a0
    80016e94:	2781                	sext.w	a5,a5
    80016e96:	863e                	mv	a2,a5
    80016e98:	85ce                	mv	a1,s3
    80016e9a:	f7043503          	ld	a0,-144(s0)
    80016e9e:	7d1080ef          	jal	ra,8001fe6e <memcpy>
                        minix3_put_zone(block_device, zone, zone_data);
    80016ea2:	ed442783          	lw	a5,-300(s0)
    80016ea6:	f7043603          	ld	a2,-144(s0)
    80016eaa:	85be                	mv	a1,a5
    80016eac:	e6843503          	ld	a0,-408(s0)
    80016eb0:	cb8fd0ef          	jal	ra,80014368 <minix3_put_zone>
                    }
                    buffer_cursor += minix3_get_zone_size(block_device);
    80016eb4:	e6843503          	ld	a0,-408(s0)
    80016eb8:	8a7fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016ebc:	87aa                	mv	a5,a0
    80016ebe:	2781                	sext.w	a5,a5
    80016ec0:	f8442703          	lw	a4,-124(s0)
    80016ec4:	9fb9                	addw	a5,a5,a4
    80016ec6:	f8f42223          	sw	a5,-124(s0)
    80016eca:	a021                	j	80016ed2 <minix3_put_data+0xe40>
                    if (zone == 0) continue;
    80016ecc:	0001                	nop
    80016ece:	a011                	j	80016ed2 <minix3_put_data+0xe40>
                        continue;
    80016ed0:	0001                	nop
                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80016ed2:	f8044783          	lbu	a5,-128(s0)
    80016ed6:	2785                	addiw	a5,a5,1
    80016ed8:	f8f40023          	sb	a5,-128(s0)
    80016edc:	f8044783          	lbu	a5,-128(s0)
    80016ee0:	03079993          	slli	s3,a5,0x30
    80016ee4:	0309d993          	srli	s3,s3,0x30
    80016ee8:	e6843503          	ld	a0,-408(s0)
    80016eec:	873fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016ef0:	87aa                	mv	a5,a0
    80016ef2:	0027d79b          	srliw	a5,a5,0x2
    80016ef6:	17c2                	slli	a5,a5,0x30
    80016ef8:	93c1                	srli	a5,a5,0x30
    80016efa:	0009871b          	sext.w	a4,s3
    80016efe:	2781                	sext.w	a5,a5
    80016f00:	daf76fe3          	bltu	a4,a5,80016cbe <minix3_put_data+0xc2c>
    80016f04:	814a                	mv	sp,s2
    80016f06:	a029                	j	80016f10 <minix3_put_data+0xe7e>
    80016f08:	814a                	mv	sp,s2
    80016f0a:	8126                	mv	sp,s1
    80016f0c:	8152                	mv	sp,s4
    80016f0e:	a0ad                	j	80016f78 <minix3_put_data+0xee6>
            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80016f10:	f8144783          	lbu	a5,-127(s0)
    80016f14:	2785                	addiw	a5,a5,1
    80016f16:	f8f400a3          	sb	a5,-127(s0)
    80016f1a:	f8144783          	lbu	a5,-127(s0)
    80016f1e:	03079913          	slli	s2,a5,0x30
    80016f22:	03095913          	srli	s2,s2,0x30
    80016f26:	e6843503          	ld	a0,-408(s0)
    80016f2a:	835fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016f2e:	87aa                	mv	a5,a0
    80016f30:	0027d79b          	srliw	a5,a5,0x2
    80016f34:	17c2                	slli	a5,a5,0x30
    80016f36:	93c1                	srli	a5,a5,0x30
    80016f38:	0009071b          	sext.w	a4,s2
    80016f3c:	2781                	sext.w	a5,a5
    80016f3e:	ccf762e3          	bltu	a4,a5,80016c02 <minix3_put_data+0xb70>
    80016f42:	8126                	mv	sp,s1
        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    80016f44:	f8244783          	lbu	a5,-126(s0)
    80016f48:	2785                	addiw	a5,a5,1
    80016f4a:	f8f40123          	sb	a5,-126(s0)
    80016f4e:	f8244783          	lbu	a5,-126(s0)
    80016f52:	03079493          	slli	s1,a5,0x30
    80016f56:	90c1                	srli	s1,s1,0x30
    80016f58:	e6843503          	ld	a0,-408(s0)
    80016f5c:	803fd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80016f60:	87aa                	mv	a5,a0
    80016f62:	0027d79b          	srliw	a5,a5,0x2
    80016f66:	17c2                	slli	a5,a5,0x30
    80016f68:	93c1                	srli	a5,a5,0x30
    80016f6a:	0004871b          	sext.w	a4,s1
    80016f6e:	2781                	sext.w	a5,a5
    80016f70:	bef760e3          	bltu	a4,a5,80016b50 <minix3_put_data+0xabe>
    80016f74:	8152                	mv	sp,s4
        debugf("No triple indirect zone\n");
    }


    // If we get here, we've read all the data we can
    return;
    80016f76:	0001                	nop
    80016f78:	cd843103          	ld	sp,-808(s0)
}
    80016f7c:	cd040113          	addi	sp,s0,-816
    80016f80:	32813083          	ld	ra,808(sp)
    80016f84:	32013403          	ld	s0,800(sp)
    80016f88:	31813483          	ld	s1,792(sp)
    80016f8c:	31013903          	ld	s2,784(sp)
    80016f90:	30813983          	ld	s3,776(sp)
    80016f94:	30013a03          	ld	s4,768(sp)
    80016f98:	2f813a83          	ld	s5,760(sp)
    80016f9c:	2f013b03          	ld	s6,752(sp)
    80016fa0:	2e813b83          	ld	s7,744(sp)
    80016fa4:	2e013c03          	ld	s8,736(sp)
    80016fa8:	2d813c83          	ld	s9,728(sp)
    80016fac:	2d013d03          	ld	s10,720(sp)
    80016fb0:	2c813d83          	ld	s11,712(sp)
    80016fb4:	33010113          	addi	sp,sp,816
    80016fb8:	8082                	ret

0000000080016fba <minix3_find_next_free_dir_entry>:

// TODO: Figure out a better way to report error than return -1 since it can 
// be a valid dir entry number.
uint32_t minix3_find_next_free_dir_entry(VirtioDevice *block_device, uint32_t inode) {
    80016fba:	7171                	addi	sp,sp,-176
    80016fbc:	f506                	sd	ra,168(sp)
    80016fbe:	f122                	sd	s0,160(sp)
    80016fc0:	1900                	addi	s0,sp,176
    80016fc2:	f4a43c23          	sd	a0,-168(s0)
    80016fc6:	87ae                	mv	a5,a1
    80016fc8:	f4f42a23          	sw	a5,-172(s0)
    if (!minix3_is_dir(block_device, inode)) {
    80016fcc:	f5442783          	lw	a5,-172(s0)
    80016fd0:	85be                	mv	a1,a5
    80016fd2:	f5843503          	ld	a0,-168(s0)
    80016fd6:	93afe0ef          	jal	ra,80015110 <minix3_is_dir>
    80016fda:	87aa                	mv	a5,a0
    80016fdc:	0017c793          	xori	a5,a5,1
    80016fe0:	0ff7f793          	andi	a5,a5,255
    80016fe4:	cf99                	beqz	a5,80017002 <minix3_find_next_free_dir_entry+0x48>
        warnf("minix3_find_next_free_dir_entry: Inode %u (0x%x) not a directory\n", inode, inode);
    80016fe6:	f5442703          	lw	a4,-172(s0)
    80016fea:	f5442783          	lw	a5,-172(s0)
    80016fee:	863a                	mv	a2,a4
    80016ff0:	85be                	mv	a1,a5
    80016ff2:	0000e517          	auipc	a0,0xe
    80016ff6:	93650513          	addi	a0,a0,-1738 # 80024928 <pow10.0+0x6f8>
    80016ffa:	206020ef          	jal	ra,80019200 <warnf>
        return -1;
    80016ffe:	57fd                	li	a5,-1
    80017000:	a8ad                	j	8001707a <minix3_find_next_free_dir_entry+0xc0>
    }

    Inode data = minix3_get_inode(block_device, inode);
    80017002:	fa840793          	addi	a5,s0,-88
    80017006:	f5442703          	lw	a4,-172(s0)
    8001700a:	863a                	mv	a2,a4
    8001700c:	f5843583          	ld	a1,-168(s0)
    80017010:	853e                	mv	a0,a5
    80017012:	dcdfd0ef          	jal	ra,80014dde <minix3_get_inode>
    DirEntry entry;
    for (size_t i = 0; i < minix3_get_zone_size(block_device) / sizeof(DirEntry); i++) {
    80017016:	fe043423          	sd	zero,-24(s0)
    8001701a:	a81d                	j	80017050 <minix3_find_next_free_dir_entry+0x96>
        minix3_get_dir_entry(block_device, inode, i, &entry);
    8001701c:	fe843783          	ld	a5,-24(s0)
    80017020:	0007871b          	sext.w	a4,a5
    80017024:	f6840693          	addi	a3,s0,-152
    80017028:	f5442783          	lw	a5,-172(s0)
    8001702c:	863a                	mv	a2,a4
    8001702e:	85be                	mv	a1,a5
    80017030:	f5843503          	ld	a0,-168(s0)
    80017034:	050000ef          	jal	ra,80017084 <minix3_get_dir_entry>

        if (entry.inode == 0) {
    80017038:	f6842783          	lw	a5,-152(s0)
    8001703c:	e789                	bnez	a5,80017046 <minix3_find_next_free_dir_entry+0x8c>
            debugf("minix3_find_next_free_dir_entry: Found free entry %u\n", i);
            return i;
    8001703e:	fe843783          	ld	a5,-24(s0)
    80017042:	2781                	sext.w	a5,a5
    80017044:	a81d                	j	8001707a <minix3_find_next_free_dir_entry+0xc0>
    for (size_t i = 0; i < minix3_get_zone_size(block_device) / sizeof(DirEntry); i++) {
    80017046:	fe843783          	ld	a5,-24(s0)
    8001704a:	0785                	addi	a5,a5,1
    8001704c:	fef43423          	sd	a5,-24(s0)
    80017050:	f5843503          	ld	a0,-168(s0)
    80017054:	f0afd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80017058:	87aa                	mv	a5,a0
    8001705a:	0067d79b          	srliw	a5,a5,0x6
    8001705e:	17c2                	slli	a5,a5,0x30
    80017060:	93c1                	srli	a5,a5,0x30
    80017062:	873e                	mv	a4,a5
    80017064:	fe843783          	ld	a5,-24(s0)
    80017068:	fae7eae3          	bltu	a5,a4,8001701c <minix3_find_next_free_dir_entry+0x62>
        } else {
            debugf("minix3_find_next_free_dir_entry: Entry %u is %s\n", i, entry.name);
        }
    }
    warnf("minix3_find_next_free_dir_entry: Couldn't find a free directory entry\n");
    8001706c:	0000e517          	auipc	a0,0xe
    80017070:	90450513          	addi	a0,a0,-1788 # 80024970 <pow10.0+0x740>
    80017074:	18c020ef          	jal	ra,80019200 <warnf>
    return -1;
    80017078:	57fd                	li	a5,-1
}
    8001707a:	853e                	mv	a0,a5
    8001707c:	70aa                	ld	ra,168(sp)
    8001707e:	740a                	ld	s0,160(sp)
    80017080:	614d                	addi	sp,sp,176
    80017082:	8082                	ret

0000000080017084 <minix3_get_dir_entry>:

bool minix3_get_dir_entry(VirtioDevice *block_device, uint32_t inode, uint32_t entry, DirEntry *data) {
    80017084:	7131                	addi	sp,sp,-192
    80017086:	fd06                	sd	ra,184(sp)
    80017088:	f922                	sd	s0,176(sp)
    8001708a:	0180                	addi	s0,sp,192
    8001708c:	f4a43c23          	sd	a0,-168(s0)
    80017090:	87ae                	mv	a5,a1
    80017092:	8732                	mv	a4,a2
    80017094:	f4d43423          	sd	a3,-184(s0)
    80017098:	f4f42a23          	sw	a5,-172(s0)
    8001709c:	87ba                	mv	a5,a4
    8001709e:	f4f42823          	sw	a5,-176(s0)
    if (!minix3_is_dir(block_device, inode)) {
    800170a2:	f5442783          	lw	a5,-172(s0)
    800170a6:	85be                	mv	a1,a5
    800170a8:	f5843503          	ld	a0,-168(s0)
    800170ac:	864fe0ef          	jal	ra,80015110 <minix3_is_dir>
    800170b0:	87aa                	mv	a5,a0
    800170b2:	0017c793          	xori	a5,a5,1
    800170b6:	0ff7f793          	andi	a5,a5,255
    800170ba:	cf99                	beqz	a5,800170d8 <minix3_get_dir_entry+0x54>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    800170bc:	f5442703          	lw	a4,-172(s0)
    800170c0:	f5442783          	lw	a5,-172(s0)
    800170c4:	863a                	mv	a2,a4
    800170c6:	85be                	mv	a1,a5
    800170c8:	0000e517          	auipc	a0,0xe
    800170cc:	8f050513          	addi	a0,a0,-1808 # 800249b8 <pow10.0+0x788>
    800170d0:	130020ef          	jal	ra,80019200 <warnf>
        return false;
    800170d4:	4781                	li	a5,0
    800170d6:	a8a9                	j	80017130 <minix3_get_dir_entry+0xac>
    }
    Inode inode_data = minix3_get_inode(block_device, inode);
    800170d8:	fa840793          	addi	a5,s0,-88
    800170dc:	f5442703          	lw	a4,-172(s0)
    800170e0:	863a                	mv	a2,a4
    800170e2:	f5843583          	ld	a1,-168(s0)
    800170e6:	853e                	mv	a0,a5
    800170e8:	cf7fd0ef          	jal	ra,80014dde <minix3_get_inode>
    debugf("Getting entry %u from inode %u\n", entry, inode);
    DirEntry tmp;

    uint32_t offset = entry * sizeof(DirEntry);
    800170ec:	f5042783          	lw	a5,-176(s0)
    800170f0:	0067979b          	slliw	a5,a5,0x6
    800170f4:	fef42623          	sw	a5,-20(s0)
    minix3_get_data(block_device, inode, (uint8_t*)&tmp, offset, sizeof(DirEntry));
    800170f8:	fec42683          	lw	a3,-20(s0)
    800170fc:	f6840613          	addi	a2,s0,-152
    80017100:	f5442783          	lw	a5,-172(s0)
    80017104:	04000713          	li	a4,64
    80017108:	85be                	mv	a1,a5
    8001710a:	f5843503          	ld	a0,-168(s0)
    8001710e:	992fe0ef          	jal	ra,800152a0 <minix3_get_data>
    memcpy(data, &tmp, sizeof(DirEntry));
    80017112:	f6840793          	addi	a5,s0,-152
    80017116:	04000613          	li	a2,64
    8001711a:	85be                	mv	a1,a5
    8001711c:	f4843503          	ld	a0,-184(s0)
    80017120:	54f080ef          	jal	ra,8001fe6e <memcpy>
    debugf("Got entry %s at offset %u from inode %u\n", tmp.name, offset, inode);
    if (tmp.inode == 0) {
    80017124:	f6842783          	lw	a5,-152(s0)
    80017128:	e399                	bnez	a5,8001712e <minix3_get_dir_entry+0xaa>
        return false;
    8001712a:	4781                	li	a5,0
    8001712c:	a011                	j	80017130 <minix3_get_dir_entry+0xac>
    }

    return true;
    8001712e:	4785                	li	a5,1
}
    80017130:	853e                	mv	a0,a5
    80017132:	70ea                	ld	ra,184(sp)
    80017134:	744a                	ld	s0,176(sp)
    80017136:	6129                	addi	sp,sp,192
    80017138:	8082                	ret

000000008001713a <minix3_put_dir_entry>:

void minix3_put_dir_entry(VirtioDevice *block_device, uint32_t inode, uint32_t entry, DirEntry data) {
    8001713a:	7179                	addi	sp,sp,-48
    8001713c:	f406                	sd	ra,40(sp)
    8001713e:	f022                	sd	s0,32(sp)
    80017140:	ec26                	sd	s1,24(sp)
    80017142:	1800                	addi	s0,sp,48
    80017144:	fca43c23          	sd	a0,-40(s0)
    80017148:	87ae                	mv	a5,a1
    8001714a:	8732                	mv	a4,a2
    8001714c:	84b6                	mv	s1,a3
    8001714e:	fcf42a23          	sw	a5,-44(s0)
    80017152:	87ba                	mv	a5,a4
    80017154:	fcf42823          	sw	a5,-48(s0)
    if (!minix3_is_dir(block_device, inode)) {
    80017158:	fd442783          	lw	a5,-44(s0)
    8001715c:	85be                	mv	a1,a5
    8001715e:	fd843503          	ld	a0,-40(s0)
    80017162:	faffd0ef          	jal	ra,80015110 <minix3_is_dir>
    80017166:	87aa                	mv	a5,a0
    80017168:	0017c793          	xori	a5,a5,1
    8001716c:	0ff7f793          	andi	a5,a5,255
    80017170:	cf91                	beqz	a5,8001718c <minix3_put_dir_entry+0x52>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    80017172:	fd442703          	lw	a4,-44(s0)
    80017176:	fd442783          	lw	a5,-44(s0)
    8001717a:	863a                	mv	a2,a4
    8001717c:	85be                	mv	a1,a5
    8001717e:	0000e517          	auipc	a0,0xe
    80017182:	83a50513          	addi	a0,a0,-1990 # 800249b8 <pow10.0+0x788>
    80017186:	07a020ef          	jal	ra,80019200 <warnf>
        return;
    8001718a:	a00d                	j	800171ac <minix3_put_dir_entry+0x72>
    }
    // Inode inode_data = minix3_get_inode(block_device, inode);
    debugf("Putting entry %u to inode %u\n", entry, inode);

    minix3_put_data(block_device, inode, (uint8_t*)&data, entry * sizeof(DirEntry), sizeof(DirEntry));
    8001718c:	fd042783          	lw	a5,-48(s0)
    80017190:	0067979b          	slliw	a5,a5,0x6
    80017194:	0007869b          	sext.w	a3,a5
    80017198:	fd442783          	lw	a5,-44(s0)
    8001719c:	04000713          	li	a4,64
    800171a0:	8626                	mv	a2,s1
    800171a2:	85be                	mv	a1,a5
    800171a4:	fd843503          	ld	a0,-40(s0)
    800171a8:	eebfe0ef          	jal	ra,80016092 <minix3_put_data>
}
    800171ac:	70a2                	ld	ra,40(sp)
    800171ae:	7402                	ld	s0,32(sp)
    800171b0:	64e2                	ld	s1,24(sp)
    800171b2:	6145                	addi	sp,sp,48
    800171b4:	8082                	ret

00000000800171b6 <minix3_list_dir>:


// List all of the entries in the given directory to the given buffer.
uint32_t minix3_list_dir(VirtioDevice *block_device, uint32_t inode, DirEntry *entries, uint32_t max_entries) {
    800171b6:	7131                	addi	sp,sp,-192
    800171b8:	fd06                	sd	ra,184(sp)
    800171ba:	f922                	sd	s0,176(sp)
    800171bc:	0180                	addi	s0,sp,192
    800171be:	f4a43c23          	sd	a0,-168(s0)
    800171c2:	87ae                	mv	a5,a1
    800171c4:	f4c43423          	sd	a2,-184(s0)
    800171c8:	8736                	mv	a4,a3
    800171ca:	f4f42a23          	sw	a5,-172(s0)
    800171ce:	87ba                	mv	a5,a4
    800171d0:	f4f42823          	sw	a5,-176(s0)
    if (!minix3_is_dir(block_device, inode)) {
    800171d4:	f5442783          	lw	a5,-172(s0)
    800171d8:	85be                	mv	a1,a5
    800171da:	f5843503          	ld	a0,-168(s0)
    800171de:	f33fd0ef          	jal	ra,80015110 <minix3_is_dir>
    800171e2:	87aa                	mv	a5,a0
    800171e4:	0017c793          	xori	a5,a5,1
    800171e8:	0ff7f793          	andi	a5,a5,255
    800171ec:	cf99                	beqz	a5,8001720a <minix3_list_dir+0x54>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    800171ee:	f5442703          	lw	a4,-172(s0)
    800171f2:	f5442783          	lw	a5,-172(s0)
    800171f6:	863a                	mv	a2,a4
    800171f8:	85be                	mv	a1,a5
    800171fa:	0000d517          	auipc	a0,0xd
    800171fe:	7be50513          	addi	a0,a0,1982 # 800249b8 <pow10.0+0x788>
    80017202:	7ff010ef          	jal	ra,80019200 <warnf>
        return 0;
    80017206:	4781                	li	a5,0
    80017208:	a059                	j	8001728e <minix3_list_dir+0xd8>
    }
    Inode inode_data = minix3_get_inode(block_device, inode);
    8001720a:	fa840793          	addi	a5,s0,-88
    8001720e:	f5442703          	lw	a4,-172(s0)
    80017212:	863a                	mv	a2,a4
    80017214:	f5843583          	ld	a1,-168(s0)
    80017218:	853e                	mv	a0,a5
    8001721a:	bc5fd0ef          	jal	ra,80014dde <minix3_get_inode>
    debugf("Listing directory %u\n", inode);
    uint32_t entry = 0;
    8001721e:	fe042623          	sw	zero,-20(s0)
    DirEntry tmp;
    while (minix3_get_dir_entry(block_device, inode, entry, &tmp)) {
    80017222:	a0b1                	j	8001726e <minix3_list_dir+0xb8>
        debugf("Found entry %s at inode %u\n", tmp.name, tmp.inode);
        memcpy(entries + entry, &tmp, sizeof(DirEntry));
    80017224:	fec46783          	lwu	a5,-20(s0)
    80017228:	079a                	slli	a5,a5,0x6
    8001722a:	f4843703          	ld	a4,-184(s0)
    8001722e:	97ba                	add	a5,a5,a4
    80017230:	f6840713          	addi	a4,s0,-152
    80017234:	04000613          	li	a2,64
    80017238:	85ba                	mv	a1,a4
    8001723a:	853e                	mv	a0,a5
    8001723c:	433080ef          	jal	ra,8001fe6e <memcpy>
        entry++;
    80017240:	fec42783          	lw	a5,-20(s0)
    80017244:	2785                	addiw	a5,a5,1
    80017246:	fef42623          	sw	a5,-20(s0)
        if (entry >= max_entries) {
    8001724a:	fec42703          	lw	a4,-20(s0)
    8001724e:	f5042783          	lw	a5,-176(s0)
    80017252:	2701                	sext.w	a4,a4
    80017254:	2781                	sext.w	a5,a5
    80017256:	00f76c63          	bltu	a4,a5,8001726e <minix3_list_dir+0xb8>
            warnf("Too many entries in directory %u\n", inode);
    8001725a:	f5442783          	lw	a5,-172(s0)
    8001725e:	85be                	mv	a1,a5
    80017260:	0000d517          	auipc	a0,0xd
    80017264:	78050513          	addi	a0,a0,1920 # 800249e0 <pow10.0+0x7b0>
    80017268:	799010ef          	jal	ra,80019200 <warnf>
            break;
    8001726c:	a839                	j	8001728a <minix3_list_dir+0xd4>
    while (minix3_get_dir_entry(block_device, inode, entry, &tmp)) {
    8001726e:	f6840693          	addi	a3,s0,-152
    80017272:	fec42703          	lw	a4,-20(s0)
    80017276:	f5442783          	lw	a5,-172(s0)
    8001727a:	863a                	mv	a2,a4
    8001727c:	85be                	mv	a1,a5
    8001727e:	f5843503          	ld	a0,-168(s0)
    80017282:	e03ff0ef          	jal	ra,80017084 <minix3_get_dir_entry>
    80017286:	87aa                	mv	a5,a0
    80017288:	ffd1                	bnez	a5,80017224 <minix3_list_dir+0x6e>
        }
    }
    return entry;
    8001728a:	fec42783          	lw	a5,-20(s0)
}
    8001728e:	853e                	mv	a0,a5
    80017290:	70ea                	ld	ra,184(sp)
    80017292:	744a                	ld	s0,176(sp)
    80017294:	6129                	addi	sp,sp,192
    80017296:	8082                	ret

0000000080017298 <minix3_find_dir_entry>:
// Returns the inode number of the file with the given name in the given directory.
// If the file does not exist, return INVALID_INODE.
uint32_t minix3_find_dir_entry(VirtioDevice *block_device, uint32_t inode, const char *name) {
    80017298:	7139                	addi	sp,sp,-64
    8001729a:	fc06                	sd	ra,56(sp)
    8001729c:	f822                	sd	s0,48(sp)
    8001729e:	0080                	addi	s0,sp,64
    800172a0:	7379                	lui	t1,0xffffe
    800172a2:	911a                	add	sp,sp,t1
    800172a4:	77f9                	lui	a5,0xffffe
    800172a6:	ff040713          	addi	a4,s0,-16
    800172aa:	97ba                	add	a5,a5,a4
    800172ac:	fea7b423          	sd	a0,-24(a5) # ffffffffffffdfe8 <_heap_end+0xffffffff77fedfe8>
    800172b0:	872e                	mv	a4,a1
    800172b2:	77f9                	lui	a5,0xffffe
    800172b4:	ff040693          	addi	a3,s0,-16
    800172b8:	97b6                	add	a5,a5,a3
    800172ba:	fcc7bc23          	sd	a2,-40(a5) # ffffffffffffdfd8 <_heap_end+0xffffffff77fedfd8>
    800172be:	77f9                	lui	a5,0xffffe
    800172c0:	ff040693          	addi	a3,s0,-16
    800172c4:	97b6                	add	a5,a5,a3
    800172c6:	fee7a223          	sw	a4,-28(a5) # ffffffffffffdfe4 <_heap_end+0xffffffff77fedfe4>
    minix3_load_device(block_device);
    800172ca:	77f9                	lui	a5,0xffffe
    800172cc:	ff040713          	addi	a4,s0,-16
    800172d0:	97ba                	add	a5,a5,a4
    800172d2:	fe87b503          	ld	a0,-24(a5) # ffffffffffffdfe8 <_heap_end+0xffffffff77fedfe8>
    800172d6:	e6cfd0ef          	jal	ra,80014942 <minix3_load_device>
    
    DirEntry entries[128];
    uint32_t num_entries = minix3_list_dir(block_device, inode, entries, 128);
    800172da:	77f9                	lui	a5,0xffffe
    800172dc:	17e1                	addi	a5,a5,-8
    800172de:	ff040713          	addi	a4,s0,-16
    800172e2:	00f70633          	add	a2,a4,a5
    800172e6:	77f9                	lui	a5,0xffffe
    800172e8:	ff040713          	addi	a4,s0,-16
    800172ec:	97ba                	add	a5,a5,a4
    800172ee:	fe47a703          	lw	a4,-28(a5) # ffffffffffffdfe4 <_heap_end+0xffffffff77fedfe4>
    800172f2:	77f9                	lui	a5,0xffffe
    800172f4:	ff040693          	addi	a3,s0,-16
    800172f8:	97b6                	add	a5,a5,a3
    800172fa:	08000693          	li	a3,128
    800172fe:	85ba                	mv	a1,a4
    80017300:	fe87b503          	ld	a0,-24(a5) # ffffffffffffdfe8 <_heap_end+0xffffffff77fedfe8>
    80017304:	eb3ff0ef          	jal	ra,800171b6 <minix3_list_dir>
    80017308:	87aa                	mv	a5,a0
    8001730a:	fef42423          	sw	a5,-24(s0)

    for (uint32_t i=0; i<num_entries; i++) {
    8001730e:	fe042623          	sw	zero,-20(s0)
    80017312:	a0b9                	j	80017360 <minix3_find_dir_entry+0xc8>
        if (strcmp(entries[i].name, name) == 0) {
    80017314:	77f9                	lui	a5,0xffffe
    80017316:	17e1                	addi	a5,a5,-8
    80017318:	ff040713          	addi	a4,s0,-16
    8001731c:	973e                	add	a4,a4,a5
    8001731e:	fec46783          	lwu	a5,-20(s0)
    80017322:	079a                	slli	a5,a5,0x6
    80017324:	97ba                	add	a5,a5,a4
    80017326:	00478713          	addi	a4,a5,4 # ffffffffffffe004 <_heap_end+0xffffffff77fee004>
    8001732a:	77f9                	lui	a5,0xffffe
    8001732c:	ff040693          	addi	a3,s0,-16
    80017330:	97b6                	add	a5,a5,a3
    80017332:	fd87b583          	ld	a1,-40(a5) # ffffffffffffdfd8 <_heap_end+0xffffffff77fedfd8>
    80017336:	853a                	mv	a0,a4
    80017338:	6c5080ef          	jal	ra,800201fc <strcmp>
    8001733c:	87aa                	mv	a5,a0
    8001733e:	ef81                	bnez	a5,80017356 <minix3_find_dir_entry+0xbe>
            debugf("Found entry %s at inode %u\n", name, entries[i].inode);
            return entries[i].inode;
    80017340:	77f9                	lui	a5,0xffffe
    80017342:	ff040713          	addi	a4,s0,-16
    80017346:	973e                	add	a4,a4,a5
    80017348:	fec46783          	lwu	a5,-20(s0)
    8001734c:	079a                	slli	a5,a5,0x6
    8001734e:	97ba                	add	a5,a5,a4
    80017350:	ff87a783          	lw	a5,-8(a5) # ffffffffffffdff8 <_heap_end+0xffffffff77fedff8>
    80017354:	a091                	j	80017398 <minix3_find_dir_entry+0x100>
    for (uint32_t i=0; i<num_entries; i++) {
    80017356:	fec42783          	lw	a5,-20(s0)
    8001735a:	2785                	addiw	a5,a5,1
    8001735c:	fef42623          	sw	a5,-20(s0)
    80017360:	fec42703          	lw	a4,-20(s0)
    80017364:	fe842783          	lw	a5,-24(s0)
    80017368:	2701                	sext.w	a4,a4
    8001736a:	2781                	sext.w	a5,a5
    8001736c:	faf764e3          	bltu	a4,a5,80017314 <minix3_find_dir_entry+0x7c>
        }
    }
    warnf("Could not find entry %s in inode %u\n", name, inode);
    80017370:	77f9                	lui	a5,0xffffe
    80017372:	ff040713          	addi	a4,s0,-16
    80017376:	97ba                	add	a5,a5,a4
    80017378:	fe47a703          	lw	a4,-28(a5) # ffffffffffffdfe4 <_heap_end+0xffffffff77fedfe4>
    8001737c:	77f9                	lui	a5,0xffffe
    8001737e:	ff040693          	addi	a3,s0,-16
    80017382:	97b6                	add	a5,a5,a3
    80017384:	863a                	mv	a2,a4
    80017386:	fd87b583          	ld	a1,-40(a5) # ffffffffffffdfd8 <_heap_end+0xffffffff77fedfd8>
    8001738a:	0000d517          	auipc	a0,0xd
    8001738e:	67e50513          	addi	a0,a0,1662 # 80024a08 <pow10.0+0x7d8>
    80017392:	66f010ef          	jal	ra,80019200 <warnf>
    return INVALID_INODE;
    80017396:	4781                	li	a5,0
}
    80017398:	853e                	mv	a0,a5
    8001739a:	6309                	lui	t1,0x2
    8001739c:	911a                	add	sp,sp,t1
    8001739e:	70e2                	ld	ra,56(sp)
    800173a0:	7442                	ld	s0,48(sp)
    800173a2:	6121                	addi	sp,sp,64
    800173a4:	8082                	ret

00000000800173a6 <strcat>:

void strcat(char *dest, char *src) {
    800173a6:	7179                	addi	sp,sp,-48
    800173a8:	f422                	sd	s0,40(sp)
    800173aa:	1800                	addi	s0,sp,48
    800173ac:	fca43c23          	sd	a0,-40(s0)
    800173b0:	fcb43823          	sd	a1,-48(s0)
    uint32_t i, j;
    for (i=0; dest[i] != 0; i++) {
    800173b4:	fe042623          	sw	zero,-20(s0)
    800173b8:	a031                	j	800173c4 <strcat+0x1e>
    800173ba:	fec42783          	lw	a5,-20(s0)
    800173be:	2785                	addiw	a5,a5,1
    800173c0:	fef42623          	sw	a5,-20(s0)
    800173c4:	fec46783          	lwu	a5,-20(s0)
    800173c8:	fd843703          	ld	a4,-40(s0)
    800173cc:	97ba                	add	a5,a5,a4
    800173ce:	0007c783          	lbu	a5,0(a5)
    800173d2:	f7e5                	bnez	a5,800173ba <strcat+0x14>
    }
    for (j=0; src[j] != 0; j++) {
    800173d4:	fe042423          	sw	zero,-24(s0)
    800173d8:	a815                	j	8001740c <strcat+0x66>
        dest[i + j] = src[j];
    800173da:	fe846783          	lwu	a5,-24(s0)
    800173de:	fd043703          	ld	a4,-48(s0)
    800173e2:	973e                	add	a4,a4,a5
    800173e4:	fec42683          	lw	a3,-20(s0)
    800173e8:	fe842783          	lw	a5,-24(s0)
    800173ec:	9fb5                	addw	a5,a5,a3
    800173ee:	2781                	sext.w	a5,a5
    800173f0:	1782                	slli	a5,a5,0x20
    800173f2:	9381                	srli	a5,a5,0x20
    800173f4:	fd843683          	ld	a3,-40(s0)
    800173f8:	97b6                	add	a5,a5,a3
    800173fa:	00074703          	lbu	a4,0(a4)
    800173fe:	00e78023          	sb	a4,0(a5)
    for (j=0; src[j] != 0; j++) {
    80017402:	fe842783          	lw	a5,-24(s0)
    80017406:	2785                	addiw	a5,a5,1
    80017408:	fef42423          	sw	a5,-24(s0)
    8001740c:	fe846783          	lwu	a5,-24(s0)
    80017410:	fd043703          	ld	a4,-48(s0)
    80017414:	97ba                	add	a5,a5,a4
    80017416:	0007c783          	lbu	a5,0(a5)
    8001741a:	f3e1                	bnez	a5,800173da <strcat+0x34>
    }
    dest[i + j] = 0;
    8001741c:	fec42703          	lw	a4,-20(s0)
    80017420:	fe842783          	lw	a5,-24(s0)
    80017424:	9fb9                	addw	a5,a5,a4
    80017426:	2781                	sext.w	a5,a5
    80017428:	1782                	slli	a5,a5,0x20
    8001742a:	9381                	srli	a5,a5,0x20
    8001742c:	fd843703          	ld	a4,-40(s0)
    80017430:	97ba                	add	a5,a5,a4
    80017432:	00078023          	sb	zero,0(a5)
}
    80017436:	0001                	nop
    80017438:	7422                	ld	s0,40(sp)
    8001743a:	6145                	addi	sp,sp,48
    8001743c:	8082                	ret

000000008001743e <minix3_traverse>:

void minix3_traverse(VirtioDevice *block_device, uint32_t inode, char *root_path, void *data, uint32_t current_depth, uint32_t max_depth, void (*callback)(VirtioDevice *block_device, uint32_t inode, const char *path, char *name, void *data, uint32_t depth)) {
    8001743e:	7109                	addi	sp,sp,-384
    80017440:	fe86                	sd	ra,376(sp)
    80017442:	faa2                	sd	s0,368(sp)
    80017444:	f6a6                	sd	s1,360(sp)
    80017446:	f2ca                	sd	s2,352(sp)
    80017448:	eece                	sd	s3,344(sp)
    8001744a:	ead2                	sd	s4,336(sp)
    8001744c:	e6d6                	sd	s5,328(sp)
    8001744e:	e2da                	sd	s6,320(sp)
    80017450:	fe5e                	sd	s7,312(sp)
    80017452:	fa62                	sd	s8,304(sp)
    80017454:	f666                	sd	s9,296(sp)
    80017456:	0300                	addi	s0,sp,384
    80017458:	eaa43423          	sd	a0,-344(s0)
    8001745c:	e8c43c23          	sd	a2,-360(s0)
    80017460:	e8d43823          	sd	a3,-368(s0)
    80017464:	86ba                	mv	a3,a4
    80017466:	873e                	mv	a4,a5
    80017468:	e9043023          	sd	a6,-384(s0)
    8001746c:	87ae                	mv	a5,a1
    8001746e:	eaf42223          	sw	a5,-348(s0)
    80017472:	87b6                	mv	a5,a3
    80017474:	eaf42023          	sw	a5,-352(s0)
    80017478:	87ba                	mv	a5,a4
    8001747a:	e8f42623          	sw	a5,-372(s0)
    8001747e:	878a                	mv	a5,sp
    80017480:	84be                	mv	s1,a5
    debugf("Traversing %s: inode %u at depth %d\n", root_path, inode, current_depth);
    if (current_depth > max_depth) {
    80017482:	ea042703          	lw	a4,-352(s0)
    80017486:	e8c42783          	lw	a5,-372(s0)
    8001748a:	2701                	sext.w	a4,a4
    8001748c:	2781                	sext.w	a5,a5
    8001748e:	24e7ed63          	bltu	a5,a4,800176e8 <minix3_traverse+0x2aa>
        return;
    }
    if (!minix3_has_inode(block_device, inode)) {
    80017492:	ea442783          	lw	a5,-348(s0)
    80017496:	85be                	mv	a1,a5
    80017498:	ea843503          	ld	a0,-344(s0)
    8001749c:	eccfd0ef          	jal	ra,80014b68 <minix3_has_inode>
    800174a0:	87aa                	mv	a5,a0
    800174a2:	0017c793          	xori	a5,a5,1
    800174a6:	0ff7f793          	andi	a5,a5,255
    800174aa:	cb99                	beqz	a5,800174c0 <minix3_traverse+0x82>
        warnf("Inode %u does not exist\n", inode);
    800174ac:	ea442783          	lw	a5,-348(s0)
    800174b0:	85be                	mv	a1,a5
    800174b2:	0000d517          	auipc	a0,0xd
    800174b6:	57e50513          	addi	a0,a0,1406 # 80024a30 <pow10.0+0x800>
    800174ba:	547010ef          	jal	ra,80019200 <warnf>
        return;
    800174be:	a435                	j	800176ea <minix3_traverse+0x2ac>
    }
    debugf("Traversing inode %u at depth %d\n", inode, current_depth);
    char name[128];
    strncpy(name, path_file_name(root_path), sizeof(name));
    800174c0:	e9843503          	ld	a0,-360(s0)
    800174c4:	345070ef          	jal	ra,8001f008 <path_file_name>
    800174c8:	872a                	mv	a4,a0
    800174ca:	ef840793          	addi	a5,s0,-264
    800174ce:	08000613          	li	a2,128
    800174d2:	85ba                	mv	a1,a4
    800174d4:	853e                	mv	a0,a5
    800174d6:	0b8090ef          	jal	ra,8002058e <strncpy>
    if (minix3_is_dir(block_device, inode)) {
    800174da:	ea442783          	lw	a5,-348(s0)
    800174de:	85be                	mv	a1,a5
    800174e0:	ea843503          	ld	a0,-344(s0)
    800174e4:	c2dfd0ef          	jal	ra,80015110 <minix3_is_dir>
    800174e8:	87aa                	mv	a5,a0
    800174ea:	e38d                	bnez	a5,8001750c <minix3_traverse+0xce>
        debugf("Is a directory\n");
    } else {
        debugf("Not a directory\n");
        callback(block_device, inode, root_path, name, data, current_depth);
    800174ec:	ea042783          	lw	a5,-352(s0)
    800174f0:	ef840693          	addi	a3,s0,-264
    800174f4:	ea442583          	lw	a1,-348(s0)
    800174f8:	e8043803          	ld	a6,-384(s0)
    800174fc:	e9043703          	ld	a4,-368(s0)
    80017500:	e9843603          	ld	a2,-360(s0)
    80017504:	ea843503          	ld	a0,-344(s0)
    80017508:	9802                	jalr	a6
        return;
    8001750a:	a2c5                	j	800176ea <minix3_traverse+0x2ac>
    }

    Inode inode_data = minix3_get_inode(block_device, inode);
    8001750c:	eb840793          	addi	a5,s0,-328
    80017510:	ea442703          	lw	a4,-348(s0)
    80017514:	863a                	mv	a2,a4
    80017516:	ea843583          	ld	a1,-344(s0)
    8001751a:	853e                	mv	a0,a5
    8001751c:	8c3fd0ef          	jal	ra,80014dde <minix3_get_inode>
    debug_inode(block_device, inode);
    80017520:	ea442783          	lw	a5,-348(s0)
    80017524:	85be                	mv	a1,a5
    80017526:	ea843503          	ld	a0,-344(s0)
    8001752a:	f85fc0ef          	jal	ra,800144ae <debug_inode>
    uint32_t max_entries = minix3_get_zone_size(block_device) / sizeof(DirEntry);
    8001752e:	ea843503          	ld	a0,-344(s0)
    80017532:	a2cfd0ef          	jal	ra,8001475e <minix3_get_zone_size>
    80017536:	87aa                	mv	a5,a0
    80017538:	0067d79b          	srliw	a5,a5,0x6
    8001753c:	17c2                	slli	a5,a5,0x30
    8001753e:	93c1                	srli	a5,a5,0x30
    80017540:	f8f42c23          	sw	a5,-104(s0)
    debugf("Max entries: %u\n", max_entries);
    DirEntry entries[max_entries];
    80017544:	f9842783          	lw	a5,-104(s0)
    80017548:	02079713          	slli	a4,a5,0x20
    8001754c:	9301                	srli	a4,a4,0x20
    8001754e:	177d                	addi	a4,a4,-1
    80017550:	f8e43823          	sd	a4,-112(s0)
    80017554:	02079713          	slli	a4,a5,0x20
    80017558:	9301                	srli	a4,a4,0x20
    8001755a:	8c3a                	mv	s8,a4
    8001755c:	4c81                	li	s9,0
    8001755e:	037c5713          	srli	a4,s8,0x37
    80017562:	009c9a93          	slli	s5,s9,0x9
    80017566:	01576ab3          	or	s5,a4,s5
    8001756a:	009c1a13          	slli	s4,s8,0x9
    8001756e:	02079713          	slli	a4,a5,0x20
    80017572:	9301                	srli	a4,a4,0x20
    80017574:	8b3a                	mv	s6,a4
    80017576:	4b81                	li	s7,0
    80017578:	037b5713          	srli	a4,s6,0x37
    8001757c:	009b9993          	slli	s3,s7,0x9
    80017580:	013769b3          	or	s3,a4,s3
    80017584:	009b1913          	slli	s2,s6,0x9
    80017588:	1782                	slli	a5,a5,0x20
    8001758a:	9381                	srli	a5,a5,0x20
    8001758c:	079a                	slli	a5,a5,0x6
    8001758e:	07bd                	addi	a5,a5,15
    80017590:	8391                	srli	a5,a5,0x4
    80017592:	0792                	slli	a5,a5,0x4
    80017594:	40f10133          	sub	sp,sp,a5
    80017598:	878a                	mv	a5,sp
    8001759a:	078d                	addi	a5,a5,3
    8001759c:	8389                	srli	a5,a5,0x2
    8001759e:	078a                	slli	a5,a5,0x2
    800175a0:	f8f43423          	sd	a5,-120(s0)
    debugf("Allocated entries\n");
    uint32_t num_entries = minix3_list_dir(block_device, inode, entries, max_entries);
    800175a4:	f9842703          	lw	a4,-104(s0)
    800175a8:	ea442783          	lw	a5,-348(s0)
    800175ac:	86ba                	mv	a3,a4
    800175ae:	f8843603          	ld	a2,-120(s0)
    800175b2:	85be                	mv	a1,a5
    800175b4:	ea843503          	ld	a0,-344(s0)
    800175b8:	bffff0ef          	jal	ra,800171b6 <minix3_list_dir>
    800175bc:	87aa                	mv	a5,a0
    800175be:	f8f42223          	sw	a5,-124(s0)
    debugf("Found %u entries\n", num_entries);

    char *path = kmalloc(1024);
    800175c2:	40000513          	li	a0,1024
    800175c6:	ed0fc0ef          	jal	ra,80013c96 <kmalloc>
    800175ca:	f6a43c23          	sd	a0,-136(s0)
    callback(block_device, inode, root_path, name, data, current_depth);
    800175ce:	ea042783          	lw	a5,-352(s0)
    800175d2:	ef840693          	addi	a3,s0,-264
    800175d6:	ea442583          	lw	a1,-348(s0)
    800175da:	e8043803          	ld	a6,-384(s0)
    800175de:	e9043703          	ld	a4,-368(s0)
    800175e2:	e9843603          	ld	a2,-360(s0)
    800175e6:	ea843503          	ld	a0,-344(s0)
    800175ea:	9802                	jalr	a6
    for (uint32_t i=0; i<num_entries; i++) {
    800175ec:	f8042e23          	sw	zero,-100(s0)
    800175f0:	a8f9                	j	800176ce <minix3_traverse+0x290>
        if (entries[i].inode == INVALID_INODE) {
    800175f2:	f8843703          	ld	a4,-120(s0)
    800175f6:	f9c46783          	lwu	a5,-100(s0)
    800175fa:	079a                	slli	a5,a5,0x6
    800175fc:	97ba                	add	a5,a5,a4
    800175fe:	439c                	lw	a5,0(a5)
    80017600:	cfdd                	beqz	a5,800176be <minix3_traverse+0x280>
            continue;
        }
        strncpy(name, entries[i].name, sizeof(name));
    80017602:	f9c46783          	lwu	a5,-100(s0)
    80017606:	079a                	slli	a5,a5,0x6
    80017608:	f8843703          	ld	a4,-120(s0)
    8001760c:	97ba                	add	a5,a5,a4
    8001760e:	00478713          	addi	a4,a5,4
    80017612:	ef840793          	addi	a5,s0,-264
    80017616:	08000613          	li	a2,128
    8001761a:	85ba                	mv	a1,a4
    8001761c:	853e                	mv	a0,a5
    8001761e:	771080ef          	jal	ra,8002058e <strncpy>
        //         name[j] = 0;
        //         break;
        //     }
        //     name[j] = entries[i].name[j];
        // }
        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) {
    80017622:	ef840793          	addi	a5,s0,-264
    80017626:	0000d597          	auipc	a1,0xd
    8001762a:	42a58593          	addi	a1,a1,1066 # 80024a50 <pow10.0+0x820>
    8001762e:	853e                	mv	a0,a5
    80017630:	3cd080ef          	jal	ra,800201fc <strcmp>
    80017634:	87aa                	mv	a5,a0
    80017636:	c7d1                	beqz	a5,800176c2 <minix3_traverse+0x284>
    80017638:	ef840793          	addi	a5,s0,-264
    8001763c:	0000d597          	auipc	a1,0xd
    80017640:	41c58593          	addi	a1,a1,1052 # 80024a58 <pow10.0+0x828>
    80017644:	853e                	mv	a0,a5
    80017646:	3b7080ef          	jal	ra,800201fc <strcmp>
    8001764a:	87aa                	mv	a5,a0
    8001764c:	cbbd                	beqz	a5,800176c2 <minix3_traverse+0x284>
            continue;
        }

        strcpy(path, root_path);
    8001764e:	e9843583          	ld	a1,-360(s0)
    80017652:	f7843503          	ld	a0,-136(s0)
    80017656:	6e3080ef          	jal	ra,80020538 <strcpy>
        if (strcmp(path, "/") != 0) {
    8001765a:	0000d597          	auipc	a1,0xd
    8001765e:	f6658593          	addi	a1,a1,-154 # 800245c0 <pow10.0+0x390>
    80017662:	f7843503          	ld	a0,-136(s0)
    80017666:	397080ef          	jal	ra,800201fc <strcmp>
    8001766a:	87aa                	mv	a5,a0
    8001766c:	cb89                	beqz	a5,8001767e <minix3_traverse+0x240>
            strcat(path, "/");
    8001766e:	0000d597          	auipc	a1,0xd
    80017672:	f5258593          	addi	a1,a1,-174 # 800245c0 <pow10.0+0x390>
    80017676:	f7843503          	ld	a0,-136(s0)
    8001767a:	d2dff0ef          	jal	ra,800173a6 <strcat>
        }
        strcat(path, name);
    8001767e:	ef840793          	addi	a5,s0,-264
    80017682:	85be                	mv	a1,a5
    80017684:	f7843503          	ld	a0,-136(s0)
    80017688:	d1fff0ef          	jal	ra,800173a6 <strcat>

        minix3_traverse(block_device, entries[i].inode, path, data, current_depth + 1, max_depth, callback);
    8001768c:	f8843703          	ld	a4,-120(s0)
    80017690:	f9c46783          	lwu	a5,-100(s0)
    80017694:	079a                	slli	a5,a5,0x6
    80017696:	97ba                	add	a5,a5,a4
    80017698:	438c                	lw	a1,0(a5)
    8001769a:	ea042783          	lw	a5,-352(s0)
    8001769e:	2785                	addiw	a5,a5,1
    800176a0:	0007871b          	sext.w	a4,a5
    800176a4:	e8c42783          	lw	a5,-372(s0)
    800176a8:	e8043803          	ld	a6,-384(s0)
    800176ac:	e9043683          	ld	a3,-368(s0)
    800176b0:	f7843603          	ld	a2,-136(s0)
    800176b4:	ea843503          	ld	a0,-344(s0)
    800176b8:	d87ff0ef          	jal	ra,8001743e <minix3_traverse>
    800176bc:	a021                	j	800176c4 <minix3_traverse+0x286>
            continue;
    800176be:	0001                	nop
    800176c0:	a011                	j	800176c4 <minix3_traverse+0x286>
            continue;
    800176c2:	0001                	nop
    for (uint32_t i=0; i<num_entries; i++) {
    800176c4:	f9c42783          	lw	a5,-100(s0)
    800176c8:	2785                	addiw	a5,a5,1
    800176ca:	f8f42e23          	sw	a5,-100(s0)
    800176ce:	f9c42703          	lw	a4,-100(s0)
    800176d2:	f8442783          	lw	a5,-124(s0)
    800176d6:	2701                	sext.w	a4,a4
    800176d8:	2781                	sext.w	a5,a5
    800176da:	f0f76ce3          	bltu	a4,a5,800175f2 <minix3_traverse+0x1b4>
    }

    kfree(path);
    800176de:	f7843503          	ld	a0,-136(s0)
    800176e2:	dfcfc0ef          	jal	ra,80013cde <kfree>
    return;
    800176e6:	a011                	j	800176ea <minix3_traverse+0x2ac>
        return;
    800176e8:	0001                	nop
    800176ea:	8126                	mv	sp,s1
}
    800176ec:	e8040113          	addi	sp,s0,-384
    800176f0:	70f6                	ld	ra,376(sp)
    800176f2:	7456                	ld	s0,368(sp)
    800176f4:	74b6                	ld	s1,360(sp)
    800176f6:	7916                	ld	s2,352(sp)
    800176f8:	69f6                	ld	s3,344(sp)
    800176fa:	6a56                	ld	s4,336(sp)
    800176fc:	6ab6                	ld	s5,328(sp)
    800176fe:	6b16                	ld	s6,320(sp)
    80017700:	7bf2                	ld	s7,312(sp)
    80017702:	7c52                	ld	s8,304(sp)
    80017704:	7cb2                	ld	s9,296(sp)
    80017706:	6119                	addi	sp,sp,384
    80017708:	8082                	ret

000000008001770a <sched_init>:


static RBTree *sched_tree;

//initialize scheduler tree
void sched_init(){
    8001770a:	1141                	addi	sp,sp,-16
    8001770c:	e406                	sd	ra,8(sp)
    8001770e:	e022                	sd	s0,0(sp)
    80017710:	0800                	addi	s0,sp,16
    sched_tree = rb_new();
    80017712:	55a080ef          	jal	ra,8001fc6c <rb_new>
    80017716:	872a                	mv	a4,a0
    80017718:	0000c797          	auipc	a5,0xc
    8001771c:	9f878793          	addi	a5,a5,-1544 # 80023110 <sched_tree>
    80017720:	e398                	sd	a4,0(a5)
}
    80017722:	0001                	nop
    80017724:	60a2                	ld	ra,8(sp)
    80017726:	6402                	ld	s0,0(sp)
    80017728:	0141                	addi	sp,sp,16
    8001772a:	8082                	ret

000000008001772c <sched_add>:

//adds node to scheduler tree
void sched_add(struct process *p){
    8001772c:	7179                	addi	sp,sp,-48
    8001772e:	f406                	sd	ra,40(sp)
    80017730:	f022                	sd	s0,32(sp)
    80017732:	1800                	addi	s0,sp,48
    80017734:	fca43c23          	sd	a0,-40(s0)
    //ensure runtime is a unique key
    struct process *curr_process;
    while(rb_find(sched_tree, p->runtime, curr_process)){
    80017738:	a809                	j	8001774a <sched_add+0x1e>
        p->runtime++;
    8001773a:	fd843783          	ld	a5,-40(s0)
    8001773e:	6f9c                	ld	a5,24(a5)
    80017740:	00178713          	addi	a4,a5,1
    80017744:	fd843783          	ld	a5,-40(s0)
    80017748:	ef98                	sd	a4,24(a5)
    while(rb_find(sched_tree, p->runtime, curr_process)){
    8001774a:	0000c797          	auipc	a5,0xc
    8001774e:	9c678793          	addi	a5,a5,-1594 # 80023110 <sched_tree>
    80017752:	6398                	ld	a4,0(a5)
    80017754:	fd843783          	ld	a5,-40(s0)
    80017758:	6f9c                	ld	a5,24(a5)
    8001775a:	2781                	sext.w	a5,a5
    8001775c:	fe843603          	ld	a2,-24(s0)
    80017760:	85be                	mv	a1,a5
    80017762:	853a                	mv	a0,a4
    80017764:	524080ef          	jal	ra,8001fc88 <rb_find>
    80017768:	87aa                	mv	a5,a0
    8001776a:	fbe1                	bnez	a5,8001773a <sched_add+0xe>
    }
    rb_insert(sched_tree, p->runtime, p);
    8001776c:	0000c797          	auipc	a5,0xc
    80017770:	9a478793          	addi	a5,a5,-1628 # 80023110 <sched_tree>
    80017774:	6398                	ld	a4,0(a5)
    80017776:	fd843783          	ld	a5,-40(s0)
    8001777a:	6f9c                	ld	a5,24(a5)
    8001777c:	2781                	sext.w	a5,a5
    8001777e:	fd843683          	ld	a3,-40(s0)
    80017782:	8636                	mv	a2,a3
    80017784:	85be                	mv	a1,a5
    80017786:	853a                	mv	a0,a4
    80017788:	7d7070ef          	jal	ra,8001f75e <rb_insert>
}
    8001778c:	0001                	nop
    8001778e:	70a2                	ld	ra,40(sp)
    80017790:	7402                	ld	s0,32(sp)
    80017792:	6145                	addi	sp,sp,48
    80017794:	8082                	ret

0000000080017796 <sched_remove_process>:

//removes node from scheduler tree - used if process gets manually killed
void sched_remove_process(struct process *p){
    80017796:	1101                	addi	sp,sp,-32
    80017798:	ec06                	sd	ra,24(sp)
    8001779a:	e822                	sd	s0,16(sp)
    8001779c:	1000                	addi	s0,sp,32
    8001779e:	fea43423          	sd	a0,-24(s0)
    rb_delete(sched_tree, p->runtime);
    800177a2:	0000c797          	auipc	a5,0xc
    800177a6:	96e78793          	addi	a5,a5,-1682 # 80023110 <sched_tree>
    800177aa:	6398                	ld	a4,0(a5)
    800177ac:	fe843783          	ld	a5,-24(s0)
    800177b0:	6f9c                	ld	a5,24(a5)
    800177b2:	2781                	sext.w	a5,a5
    800177b4:	85be                	mv	a1,a5
    800177b6:	853a                	mv	a0,a4
    800177b8:	348080ef          	jal	ra,8001fb00 <rb_delete>
}
    800177bc:	0001                	nop
    800177be:	60e2                	ld	ra,24(sp)
    800177c0:	6442                	ld	s0,16(sp)
    800177c2:	6105                	addi	sp,sp,32
    800177c4:	8082                	ret

00000000800177c6 <sched_get_next>:

//get process with the lowest vruntime
struct process *sched_get_next(){
    800177c6:	1101                	addi	sp,sp,-32
    800177c8:	ec06                	sd	ra,24(sp)
    800177ca:	e822                	sd	s0,16(sp)
    800177cc:	1000                	addi	s0,sp,32
    struct process *min_process;
    rb_min_val_ptr(sched_tree, min_process);
    800177ce:	0000c797          	auipc	a5,0xc
    800177d2:	94278793          	addi	a5,a5,-1726 # 80023110 <sched_tree>
    800177d6:	639c                	ld	a5,0(a5)
    800177d8:	fe843583          	ld	a1,-24(s0)
    800177dc:	853e                	mv	a0,a5
    800177de:	41b070ef          	jal	ra,8001f3f8 <rb_min_val>
    return min_process;
    800177e2:	fe843783          	ld	a5,-24(s0)
}
    800177e6:	853e                	mv	a0,a5
    800177e8:	60e2                	ld	ra,24(sp)
    800177ea:	6442                	ld	s0,16(sp)
    800177ec:	6105                	addi	sp,sp,32
    800177ee:	8082                	ret

00000000800177f0 <gpu_test>:

static Vector *device_active_jobs;
static VirtioDevice *gpu_device;
static Console console; // NOTE: Figure how this is supposed to be interfaced, allocate appropriately

bool gpu_test() {
    800177f0:	1141                	addi	sp,sp,-16
    800177f2:	e406                	sd	ra,8(sp)
    800177f4:	e022                	sd	s0,0(sp)
    800177f6:	0800                	addi	s0,sp,16
    return gpu_init(gpu_device);
    800177f8:	0000c797          	auipc	a5,0xc
    800177fc:	92878793          	addi	a5,a5,-1752 # 80023120 <gpu_device>
    80017800:	639c                	ld	a5,0(a5)
    80017802:	853e                	mv	a0,a5
    80017804:	0aa000ef          	jal	ra,800178ae <gpu_init>
    80017808:	87aa                	mv	a5,a0
}
    8001780a:	853e                	mv	a0,a5
    8001780c:	60a2                	ld	ra,8(sp)
    8001780e:	6402                	ld	s0,0(sp)
    80017810:	0141                	addi	sp,sp,16
    80017812:	8082                	ret

0000000080017814 <gpu_device_init>:

void gpu_device_init() {
    80017814:	1101                	addi	sp,sp,-32
    80017816:	ec06                	sd	ra,24(sp)
    80017818:	e822                	sd	s0,16(sp)
    8001781a:	1000                	addi	s0,sp,32
    device_active_jobs = vector_new();
    8001781c:	7a3080ef          	jal	ra,800207be <vector_new>
    80017820:	872a                	mv	a4,a0
    80017822:	0000c797          	auipc	a5,0xc
    80017826:	8f678793          	addi	a5,a5,-1802 # 80023118 <device_active_jobs>
    8001782a:	e398                	sd	a4,0(a5)
    gpu_device = virtio_get_gpu_device();
    8001782c:	020030ef          	jal	ra,8001a84c <virtio_get_gpu_device>
    80017830:	872a                	mv	a4,a0
    80017832:	0000c797          	auipc	a5,0xc
    80017836:	8ee78793          	addi	a5,a5,-1810 # 80023120 <gpu_device>
    8001783a:	e398                	sd	a4,0(a5)
    // debugf("GPU device init done for device at %p\n", gpu_device->pcidev->ecam_header);
    virtio_set_device_name(gpu_device, "GPU Device");
    8001783c:	0000c797          	auipc	a5,0xc
    80017840:	8e478793          	addi	a5,a5,-1820 # 80023120 <gpu_device>
    80017844:	639c                	ld	a5,0(a5)
    80017846:	0000d597          	auipc	a1,0xd
    8001784a:	21a58593          	addi	a1,a1,538 # 80024a60 <pow10.0+0x830>
    8001784e:	853e                	mv	a0,a5
    80017850:	542030ef          	jal	ra,8001ad92 <virtio_set_device_name>
    gpu_device->ready = true;
    80017854:	0000c797          	auipc	a5,0xc
    80017858:	8cc78793          	addi	a5,a5,-1844 # 80023120 <gpu_device>
    8001785c:	639c                	ld	a5,0(a5)
    8001785e:	4705                	li	a4,1
    80017860:	08e78723          	sb	a4,142(a5)
    volatile VirtioGpuConfig *config = virtio_get_gpu_config(gpu_device);
    80017864:	0000c797          	auipc	a5,0xc
    80017868:	8bc78793          	addi	a5,a5,-1860 # 80023120 <gpu_device>
    8001786c:	639c                	ld	a5,0(a5)
    8001786e:	853e                	mv	a0,a5
    80017870:	541020ef          	jal	ra,8001a5b0 <virtio_get_gpu_config>
    80017874:	fea43423          	sd	a0,-24(s0)
    debugf("GPU device has %d events that needs to be read\n", config->events_read);
    80017878:	fe843783          	ld	a5,-24(s0)
    8001787c:	439c                	lw	a5,0(a5)
    8001787e:	2781                	sext.w	a5,a5
    80017880:	85be                	mv	a1,a5
    80017882:	0000d517          	auipc	a0,0xd
    80017886:	1ee50513          	addi	a0,a0,494 # 80024a70 <pow10.0+0x840>
    8001788a:	121010ef          	jal	ra,800191aa <debugf>
    debugf("GPU device has %d scanouts\n", config->num_scanouts);
    8001788e:	fe843783          	ld	a5,-24(s0)
    80017892:	479c                	lw	a5,8(a5)
    80017894:	2781                	sext.w	a5,a5
    80017896:	85be                	mv	a1,a5
    80017898:	0000d517          	auipc	a0,0xd
    8001789c:	20850513          	addi	a0,a0,520 # 80024aa0 <pow10.0+0x870>
    800178a0:	10b010ef          	jal	ra,800191aa <debugf>
}
    800178a4:	0001                	nop
    800178a6:	60e2                	ld	ra,24(sp)
    800178a8:	6442                	ld	s0,16(sp)
    800178aa:	6105                	addi	sp,sp,32
    800178ac:	8082                	ret

00000000800178ae <gpu_init>:

// TODO: Implement checking for error responses
bool gpu_init(VirtioDevice *gpu_device) {
    800178ae:	d1010113          	addi	sp,sp,-752
    800178b2:	2e113423          	sd	ra,744(sp)
    800178b6:	2e813023          	sd	s0,736(sp)
    800178ba:	1d80                	addi	s0,sp,752
    800178bc:	d0a43c23          	sd	a0,-744(s0)
    VirtioGpuDispInfoResp disp_info;
    gpu_get_display_info(gpu_device, &disp_info);
    800178c0:	e5840793          	addi	a5,s0,-424
    800178c4:	85be                	mv	a1,a5
    800178c6:	d1843503          	ld	a0,-744(s0)
    800178ca:	52c000ef          	jal	ra,80017df6 <gpu_get_display_info>
    
    // Allocate memory for frame buffer
    console.width = disp_info.displays[0].rect.width;
    800178ce:	e7842703          	lw	a4,-392(s0)
    800178d2:	0000c797          	auipc	a5,0xc
    800178d6:	85678793          	addi	a5,a5,-1962 # 80023128 <console>
    800178da:	c398                	sw	a4,0(a5)
    console.height = disp_info.displays[0].rect.height;
    800178dc:	e7c42703          	lw	a4,-388(s0)
    800178e0:	0000c797          	auipc	a5,0xc
    800178e4:	84878793          	addi	a5,a5,-1976 # 80023128 <console>
    800178e8:	c3d8                	sw	a4,4(a5)
    console.frame_buf = kcalloc(console.width * console.height, sizeof(Pixel));
    800178ea:	0000c797          	auipc	a5,0xc
    800178ee:	83e78793          	addi	a5,a5,-1986 # 80023128 <console>
    800178f2:	4398                	lw	a4,0(a5)
    800178f4:	0000c797          	auipc	a5,0xc
    800178f8:	83478793          	addi	a5,a5,-1996 # 80023128 <console>
    800178fc:	43dc                	lw	a5,4(a5)
    800178fe:	02f707bb          	mulw	a5,a4,a5
    80017902:	2781                	sext.w	a5,a5
    80017904:	1782                	slli	a5,a5,0x20
    80017906:	9381                	srli	a5,a5,0x20
    80017908:	4591                	li	a1,4
    8001790a:	853e                	mv	a0,a5
    8001790c:	baafc0ef          	jal	ra,80013cb6 <kcalloc>
    80017910:	872a                	mv	a4,a0
    80017912:	0000c797          	auipc	a5,0xc
    80017916:	81678793          	addi	a5,a5,-2026 # 80023128 <console>
    8001791a:	e798                	sd	a4,8(a5)
    debugf("gpu_init: Allocated frame buffer of (%d * %d) bytes at %p\n",
           sizeof(Pixel), console.width * console.height, console.frame_buf);
    8001791c:	0000c797          	auipc	a5,0xc
    80017920:	80c78793          	addi	a5,a5,-2036 # 80023128 <console>
    80017924:	4398                	lw	a4,0(a5)
    80017926:	0000c797          	auipc	a5,0xc
    8001792a:	80278793          	addi	a5,a5,-2046 # 80023128 <console>
    8001792e:	43dc                	lw	a5,4(a5)
    debugf("gpu_init: Allocated frame buffer of (%d * %d) bytes at %p\n",
    80017930:	02f707bb          	mulw	a5,a4,a5
    80017934:	0007871b          	sext.w	a4,a5
    80017938:	0000b797          	auipc	a5,0xb
    8001793c:	7f078793          	addi	a5,a5,2032 # 80023128 <console>
    80017940:	679c                	ld	a5,8(a5)
    80017942:	86be                	mv	a3,a5
    80017944:	863a                	mv	a2,a4
    80017946:	4591                	li	a1,4
    80017948:	0000d517          	auipc	a0,0xd
    8001794c:	17850513          	addi	a0,a0,376 # 80024ac0 <pow10.0+0x890>
    80017950:	05b010ef          	jal	ra,800191aa <debugf>

    VirtioGpuResCreate2d res2d;
    res2d.hdr.type = VIRTIO_GPU_CMD_RESOURCE_CREATE_2D;
    80017954:	10100793          	li	a5,257
    80017958:	e2f42823          	sw	a5,-464(s0)
    res2d.resource_id = 1; // Give an arbitrary unique number
    8001795c:	4785                	li	a5,1
    8001795e:	e4f42423          	sw	a5,-440(s0)
    res2d.format = R8G8B8A8_UNORM;
    80017962:	04300793          	li	a5,67
    80017966:	e4f42623          	sw	a5,-436(s0)
    res2d.width = console.width;
    8001796a:	0000b797          	auipc	a5,0xb
    8001796e:	7be78793          	addi	a5,a5,1982 # 80023128 <console>
    80017972:	439c                	lw	a5,0(a5)
    80017974:	e4f42823          	sw	a5,-432(s0)
    res2d.height = console.height;
    80017978:	0000b797          	auipc	a5,0xb
    8001797c:	7b078793          	addi	a5,a5,1968 # 80023128 <console>
    80017980:	43dc                	lw	a5,4(a5)
    80017982:	e4f42a23          	sw	a5,-428(s0)

    VirtioGpuCtrlHdr resp_hdr;
    resp_hdr.type = 0;
    80017986:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &res2d, sizeof(res2d), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    8001798a:	e1840793          	addi	a5,s0,-488
    8001798e:	e3040613          	addi	a2,s0,-464
    80017992:	48e1                	li	a7,24
    80017994:	883e                	mv	a6,a5
    80017996:	4781                	li	a5,0
    80017998:	4701                	li	a4,0
    8001799a:	02800693          	li	a3,40
    8001799e:	4581                	li	a1,0
    800179a0:	d1843503          	ld	a0,-744(s0)
    800179a4:	2f4000ef          	jal	ra,80017c98 <gpu_send_command>
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    800179a8:	e1842783          	lw	a5,-488(s0)
    800179ac:	873e                	mv	a4,a5
    800179ae:	6785                	lui	a5,0x1
    800179b0:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    800179b4:	00f71863          	bne	a4,a5,800179c4 <gpu_init+0x116>
        debugf("gpu_init: Create 2D resource OK\n");
    800179b8:	0000d517          	auipc	a0,0xd
    800179bc:	14850513          	addi	a0,a0,328 # 80024b00 <pow10.0+0x8d0>
    800179c0:	7ea010ef          	jal	ra,800191aa <debugf>
        // return false;
    }

    // Attach resource 2D
    VirtioGpuResourceAttachBacking attach_backing;
    attach_backing.hdr.type = VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING;
    800179c4:	10600793          	li	a5,262
    800179c8:	def42c23          	sw	a5,-520(s0)
    attach_backing.resource_id = 1;
    800179cc:	4785                	li	a5,1
    800179ce:	e0f42823          	sw	a5,-496(s0)
    attach_backing.nr_entries = 1;
    800179d2:	4785                	li	a5,1
    800179d4:	e0f42a23          	sw	a5,-492(s0)
    VirtioGpuMemEntry mem;
    // mem.addr = kernel_mmu_translate((uintptr_t)console.frame_buf
    mem.addr = kernel_mmu_translate((uintptr_t)console.frame_buf);
    800179d8:	0000b797          	auipc	a5,0xb
    800179dc:	75078793          	addi	a5,a5,1872 # 80023128 <console>
    800179e0:	679c                	ld	a5,8(a5)
    800179e2:	853e                	mv	a0,a5
    800179e4:	2ee020ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    800179e8:	87aa                	mv	a5,a0
    800179ea:	def43423          	sd	a5,-536(s0)
    mem.length = console.width * console.width * sizeof(Pixel);
    800179ee:	0000b797          	auipc	a5,0xb
    800179f2:	73a78793          	addi	a5,a5,1850 # 80023128 <console>
    800179f6:	4398                	lw	a4,0(a5)
    800179f8:	0000b797          	auipc	a5,0xb
    800179fc:	73078793          	addi	a5,a5,1840 # 80023128 <console>
    80017a00:	439c                	lw	a5,0(a5)
    80017a02:	02f707bb          	mulw	a5,a4,a5
    80017a06:	2781                	sext.w	a5,a5
    80017a08:	0027979b          	slliw	a5,a5,0x2
    80017a0c:	2781                	sext.w	a5,a5
    80017a0e:	def42823          	sw	a5,-528(s0)
    mem.padding = 0;
    80017a12:	de042a23          	sw	zero,-524(s0)
    resp_hdr.type = 0;
    80017a16:	e0042c23          	sw	zero,-488(s0)
    
    gpu_send_command(gpu_device, 0, &attach_backing, sizeof(attach_backing), &mem, sizeof(mem), &resp_hdr, sizeof(resp_hdr));
    80017a1a:	e1840793          	addi	a5,s0,-488
    80017a1e:	de840713          	addi	a4,s0,-536
    80017a22:	df840613          	addi	a2,s0,-520
    80017a26:	48e1                	li	a7,24
    80017a28:	883e                	mv	a6,a5
    80017a2a:	47c1                	li	a5,16
    80017a2c:	02000693          	li	a3,32
    80017a30:	4581                	li	a1,0
    80017a32:	d1843503          	ld	a0,-744(s0)
    80017a36:	262000ef          	jal	ra,80017c98 <gpu_send_command>

    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    80017a3a:	e1842783          	lw	a5,-488(s0)
    80017a3e:	873e                	mv	a4,a5
    80017a40:	6785                	lui	a5,0x1
    80017a42:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    80017a46:	00f71863          	bne	a4,a5,80017a56 <gpu_init+0x1a8>
        debugf("gpu_init: Attach backing OK\n");
    80017a4a:	0000d517          	auipc	a0,0xd
    80017a4e:	0de50513          	addi	a0,a0,222 # 80024b28 <pow10.0+0x8f8>
    80017a52:	758010ef          	jal	ra,800191aa <debugf>
        // debugf("gpu_init: Attach backing failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    VirtioGpuSetScanout scan;
    scan.hdr.type = VIRTIO_GPU_CMD_SET_SCANOUT;
    80017a56:	10300793          	li	a5,259
    80017a5a:	daf42c23          	sw	a5,-584(s0)
    scan.rect.x = 0;
    80017a5e:	dc042823          	sw	zero,-560(s0)
    scan.rect.y = 0;
    80017a62:	dc042a23          	sw	zero,-556(s0)
    scan.rect.width = console.width;
    80017a66:	0000b797          	auipc	a5,0xb
    80017a6a:	6c278793          	addi	a5,a5,1730 # 80023128 <console>
    80017a6e:	439c                	lw	a5,0(a5)
    80017a70:	dcf42c23          	sw	a5,-552(s0)
    scan.rect.height = console.height;
    80017a74:	0000b797          	auipc	a5,0xb
    80017a78:	6b478793          	addi	a5,a5,1716 # 80023128 <console>
    80017a7c:	43dc                	lw	a5,4(a5)
    80017a7e:	dcf42e23          	sw	a5,-548(s0)
    scan.resource_id = 1;
    80017a82:	4785                	li	a5,1
    80017a84:	def42223          	sw	a5,-540(s0)
    scan.scanout_id = 0;
    80017a88:	de042023          	sw	zero,-544(s0)
    resp_hdr.type = 0;
    80017a8c:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &scan, sizeof(scan), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    80017a90:	e1840793          	addi	a5,s0,-488
    80017a94:	db840613          	addi	a2,s0,-584
    80017a98:	48e1                	li	a7,24
    80017a9a:	883e                	mv	a6,a5
    80017a9c:	4781                	li	a5,0
    80017a9e:	4701                	li	a4,0
    80017aa0:	03000693          	li	a3,48
    80017aa4:	4581                	li	a1,0
    80017aa6:	d1843503          	ld	a0,-744(s0)
    80017aaa:	1ee000ef          	jal	ra,80017c98 <gpu_send_command>

    Rectangle r1 = {0, 0, console.width, console.height};
    80017aae:	da042423          	sw	zero,-600(s0)
    80017ab2:	da042623          	sw	zero,-596(s0)
    80017ab6:	0000b797          	auipc	a5,0xb
    80017aba:	67278793          	addi	a5,a5,1650 # 80023128 <console>
    80017abe:	439c                	lw	a5,0(a5)
    80017ac0:	daf42823          	sw	a5,-592(s0)
    80017ac4:	0000b797          	auipc	a5,0xb
    80017ac8:	66478793          	addi	a5,a5,1636 # 80023128 <console>
    80017acc:	43dc                	lw	a5,4(a5)
    80017ace:	daf42a23          	sw	a5,-588(s0)
    Rectangle r2 = {100, 100, console.width - 150, console.height - 150};
    80017ad2:	06400793          	li	a5,100
    80017ad6:	d8f42c23          	sw	a5,-616(s0)
    80017ada:	06400793          	li	a5,100
    80017ade:	d8f42e23          	sw	a5,-612(s0)
    80017ae2:	0000b797          	auipc	a5,0xb
    80017ae6:	64678793          	addi	a5,a5,1606 # 80023128 <console>
    80017aea:	439c                	lw	a5,0(a5)
    80017aec:	f6a7879b          	addiw	a5,a5,-150
    80017af0:	2781                	sext.w	a5,a5
    80017af2:	daf42023          	sw	a5,-608(s0)
    80017af6:	0000b797          	auipc	a5,0xb
    80017afa:	63278793          	addi	a5,a5,1586 # 80023128 <console>
    80017afe:	43dc                	lw	a5,4(a5)
    80017b00:	f6a7879b          	addiw	a5,a5,-150
    80017b04:	2781                	sext.w	a5,a5
    80017b06:	daf42223          	sw	a5,-604(s0)
    Pixel p1 = {255, 100, 50, 255};
    80017b0a:	0000f797          	auipc	a5,0xf
    80017b0e:	cfe78793          	addi	a5,a5,-770 # 80026808 <NUM_SYSCALLS+0x8>
    80017b12:	439c                	lw	a5,0(a5)
    80017b14:	d8f42823          	sw	a5,-624(s0)
    Pixel p2 = {88, 89, 91, 255};
    80017b18:	0000f797          	auipc	a5,0xf
    80017b1c:	cf878793          	addi	a5,a5,-776 # 80026810 <NUM_SYSCALLS+0x10>
    80017b20:	439c                	lw	a5,0(a5)
    80017b22:	d8f42423          	sw	a5,-632(s0)

    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    80017b26:	e1842783          	lw	a5,-488(s0)
    80017b2a:	873e                	mv	a4,a5
    80017b2c:	6785                	lui	a5,0x1
    80017b2e:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    80017b32:	00f71863          	bne	a4,a5,80017b42 <gpu_init+0x294>
        debugf("gpu_init: Set scanout OK\n");
    80017b36:	0000d517          	auipc	a0,0xd
    80017b3a:	01250513          	addi	a0,a0,18 # 80024b48 <pow10.0+0x918>
    80017b3e:	66c010ef          	jal	ra,800191aa <debugf>
    } else {
        // debugf("gpu_init: Set scanout failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    fill_rect(console.width, console.height, console.frame_buf, &r1, &p1);
    80017b42:	0000b797          	auipc	a5,0xb
    80017b46:	5e678793          	addi	a5,a5,1510 # 80023128 <console>
    80017b4a:	4388                	lw	a0,0(a5)
    80017b4c:	0000b797          	auipc	a5,0xb
    80017b50:	5dc78793          	addi	a5,a5,1500 # 80023128 <console>
    80017b54:	43cc                	lw	a1,4(a5)
    80017b56:	0000b797          	auipc	a5,0xb
    80017b5a:	5d278793          	addi	a5,a5,1490 # 80023128 <console>
    80017b5e:	679c                	ld	a5,8(a5)
    80017b60:	d9040713          	addi	a4,s0,-624
    80017b64:	da840693          	addi	a3,s0,-600
    80017b68:	863e                	mv	a2,a5
    80017b6a:	448000ef          	jal	ra,80017fb2 <fill_rect>
    stroke_rect(console.width, console.height, console.frame_buf, &r2, &p2, 10);
    80017b6e:	0000b797          	auipc	a5,0xb
    80017b72:	5ba78793          	addi	a5,a5,1466 # 80023128 <console>
    80017b76:	4388                	lw	a0,0(a5)
    80017b78:	0000b797          	auipc	a5,0xb
    80017b7c:	5b078793          	addi	a5,a5,1456 # 80023128 <console>
    80017b80:	43cc                	lw	a1,4(a5)
    80017b82:	0000b797          	auipc	a5,0xb
    80017b86:	5a678793          	addi	a5,a5,1446 # 80023128 <console>
    80017b8a:	6790                	ld	a2,8(a5)
    80017b8c:	d8840713          	addi	a4,s0,-632
    80017b90:	d9840693          	addi	a3,s0,-616
    80017b94:	47a9                	li	a5,10
    80017b96:	58c000ef          	jal	ra,80018122 <stroke_rect>

    VirtioGpuTransferToHost2d tx;
    tx.hdr.type = VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D;
    80017b9a:	10500793          	li	a5,261
    80017b9e:	d4f42823          	sw	a5,-688(s0)
    tx.rect.x = 0;
    80017ba2:	d6042423          	sw	zero,-664(s0)
    tx.rect.y = 0;
    80017ba6:	d6042623          	sw	zero,-660(s0)
    tx.rect.width = console.width;
    80017baa:	0000b797          	auipc	a5,0xb
    80017bae:	57e78793          	addi	a5,a5,1406 # 80023128 <console>
    80017bb2:	439c                	lw	a5,0(a5)
    80017bb4:	d6f42823          	sw	a5,-656(s0)
    tx.rect.height = console.height;
    80017bb8:	0000b797          	auipc	a5,0xb
    80017bbc:	57078793          	addi	a5,a5,1392 # 80023128 <console>
    80017bc0:	43dc                	lw	a5,4(a5)
    80017bc2:	d6f42a23          	sw	a5,-652(s0)
    tx.offset = 0;
    80017bc6:	d6043c23          	sd	zero,-648(s0)
    tx.resource_id = 1;
    80017bca:	4785                	li	a5,1
    80017bcc:	d8f42023          	sw	a5,-640(s0)
    tx.padding = 0;
    80017bd0:	d8042223          	sw	zero,-636(s0)
    resp_hdr.type = 0;
    80017bd4:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &tx, sizeof(tx), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    80017bd8:	e1840793          	addi	a5,s0,-488
    80017bdc:	d5040613          	addi	a2,s0,-688
    80017be0:	48e1                	li	a7,24
    80017be2:	883e                	mv	a6,a5
    80017be4:	4781                	li	a5,0
    80017be6:	4701                	li	a4,0
    80017be8:	03800693          	li	a3,56
    80017bec:	4581                	li	a1,0
    80017bee:	d1843503          	ld	a0,-744(s0)
    80017bf2:	0a6000ef          	jal	ra,80017c98 <gpu_send_command>
    
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    80017bf6:	e1842783          	lw	a5,-488(s0)
    80017bfa:	873e                	mv	a4,a5
    80017bfc:	6785                	lui	a5,0x1
    80017bfe:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    80017c02:	00f71863          	bne	a4,a5,80017c12 <gpu_init+0x364>
        debugf("gpu_init: Transfer OK\n");
    80017c06:	0000d517          	auipc	a0,0xd
    80017c0a:	f6250513          	addi	a0,a0,-158 # 80024b68 <pow10.0+0x938>
    80017c0e:	59c010ef          	jal	ra,800191aa <debugf>
        // debugf("gpu_init: Transfer failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    VirtioGpuResourceFlush flush;
    flush.hdr.type = VIRTIO_GPU_CMD_RESOURCE_FLUSH;
    80017c12:	10400793          	li	a5,260
    80017c16:	d2f42023          	sw	a5,-736(s0)
    flush.rect.x = 0;
    80017c1a:	d2042c23          	sw	zero,-712(s0)
    flush.rect.y = 0;
    80017c1e:	d2042e23          	sw	zero,-708(s0)
    flush.rect.width = console.width;
    80017c22:	0000b797          	auipc	a5,0xb
    80017c26:	50678793          	addi	a5,a5,1286 # 80023128 <console>
    80017c2a:	439c                	lw	a5,0(a5)
    80017c2c:	d4f42023          	sw	a5,-704(s0)
    flush.rect.height = console.height;
    80017c30:	0000b797          	auipc	a5,0xb
    80017c34:	4f878793          	addi	a5,a5,1272 # 80023128 <console>
    80017c38:	43dc                	lw	a5,4(a5)
    80017c3a:	d4f42223          	sw	a5,-700(s0)
    flush.resource_id = 1;
    80017c3e:	4785                	li	a5,1
    80017c40:	d4f42423          	sw	a5,-696(s0)
    flush.padding = 0;
    80017c44:	d4042623          	sw	zero,-692(s0)
    resp_hdr.type = 0;
    80017c48:	e0042c23          	sw	zero,-488(s0)
    gpu_send_command(gpu_device, 0, &flush, sizeof(flush), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    80017c4c:	e1840793          	addi	a5,s0,-488
    80017c50:	d2040613          	addi	a2,s0,-736
    80017c54:	48e1                	li	a7,24
    80017c56:	883e                	mv	a6,a5
    80017c58:	4781                	li	a5,0
    80017c5a:	4701                	li	a4,0
    80017c5c:	03000693          	li	a3,48
    80017c60:	4581                	li	a1,0
    80017c62:	d1843503          	ld	a0,-744(s0)
    80017c66:	032000ef          	jal	ra,80017c98 <gpu_send_command>
    
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    80017c6a:	e1842783          	lw	a5,-488(s0)
    80017c6e:	873e                	mv	a4,a5
    80017c70:	6785                	lui	a5,0x1
    80017c72:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    80017c76:	00f71863          	bne	a4,a5,80017c86 <gpu_init+0x3d8>
        debugf("gpu_init: Flush OK\n");
    80017c7a:	0000d517          	auipc	a0,0xd
    80017c7e:	f0650513          	addi	a0,a0,-250 # 80024b80 <pow10.0+0x950>
    80017c82:	528010ef          	jal	ra,800191aa <debugf>
    } else {
        // debugf("gpu_init: Flush failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    return true;
    80017c86:	4785                	li	a5,1
}
    80017c88:	853e                	mv	a0,a5
    80017c8a:	2e813083          	ld	ra,744(sp)
    80017c8e:	2e013403          	ld	s0,736(sp)
    80017c92:	2f010113          	addi	sp,sp,752
    80017c96:	8082                	ret

0000000080017c98 <gpu_send_command>:
                      void *cmd,
                      size_t cmd_size,
                      void *resp0,
                      size_t resp0_size,
                      void *resp1,
                      size_t resp1_size) {
    80017c98:	7115                	addi	sp,sp,-224
    80017c9a:	ed86                	sd	ra,216(sp)
    80017c9c:	e9a2                	sd	s0,208(sp)
    80017c9e:	1180                	addi	s0,sp,224
    80017ca0:	f4a43c23          	sd	a0,-168(s0)
    80017ca4:	f4c43423          	sd	a2,-184(s0)
    80017ca8:	f4d43023          	sd	a3,-192(s0)
    80017cac:	f2e43c23          	sd	a4,-200(s0)
    80017cb0:	f2f43823          	sd	a5,-208(s0)
    80017cb4:	f3043423          	sd	a6,-216(s0)
    80017cb8:	f3143023          	sd	a7,-224(s0)
    80017cbc:	87ae                	mv	a5,a1
    80017cbe:	f4f41b23          	sh	a5,-170(s0)
    VirtioDescriptor cmd_desc;
    cmd_desc.addr = kernel_mmu_translate((uintptr_t)cmd);
    80017cc2:	f4843783          	ld	a5,-184(s0)
    80017cc6:	853e                	mv	a0,a5
    80017cc8:	00a020ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    80017ccc:	87aa                	mv	a5,a0
    80017cce:	fcf43823          	sd	a5,-48(s0)
    cmd_desc.len = cmd_size;
    80017cd2:	f4043783          	ld	a5,-192(s0)
    80017cd6:	2781                	sext.w	a5,a5
    80017cd8:	fcf42c23          	sw	a5,-40(s0)
    cmd_desc.flags = VIRTQ_DESC_F_NEXT;
    80017cdc:	4785                	li	a5,1
    80017cde:	fcf41e23          	sh	a5,-36(s0)

    VirtioDescriptor resp0_desc;
    resp0_desc.addr = kernel_mmu_translate((uintptr_t)resp0);
    80017ce2:	f3843783          	ld	a5,-200(s0)
    80017ce6:	853e                	mv	a0,a5
    80017ce8:	7eb010ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    80017cec:	87aa                	mv	a5,a0
    80017cee:	fcf43023          	sd	a5,-64(s0)
    resp0_desc.len = resp0_size;
    80017cf2:	f3043783          	ld	a5,-208(s0)
    80017cf6:	2781                	sext.w	a5,a5
    80017cf8:	fcf42423          	sw	a5,-56(s0)
    resp0_desc.flags = VIRTQ_DESC_F_NEXT;
    80017cfc:	4785                	li	a5,1
    80017cfe:	fcf41623          	sh	a5,-52(s0)
    
    VirtioDescriptor resp1_desc;
    resp1_desc.addr = kernel_mmu_translate((uintptr_t)resp1);
    80017d02:	f2843783          	ld	a5,-216(s0)
    80017d06:	853e                	mv	a0,a5
    80017d08:	7cb010ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    80017d0c:	87aa                	mv	a5,a0
    80017d0e:	faf43823          	sd	a5,-80(s0)
    resp1_desc.len = resp1_size;
    80017d12:	f2043783          	ld	a5,-224(s0)
    80017d16:	2781                	sext.w	a5,a5
    80017d18:	faf42c23          	sw	a5,-72(s0)
    resp1_desc.flags = VIRTQ_DESC_F_WRITE;
    80017d1c:	4789                	li	a5,2
    80017d1e:	faf41e23          	sh	a5,-68(s0)

    VirtioDescriptor chain0[2] = {cmd_desc, resp1_desc};
    80017d22:	fd043783          	ld	a5,-48(s0)
    80017d26:	f8f43823          	sd	a5,-112(s0)
    80017d2a:	fd843783          	ld	a5,-40(s0)
    80017d2e:	f8f43c23          	sd	a5,-104(s0)
    80017d32:	fb043783          	ld	a5,-80(s0)
    80017d36:	faf43023          	sd	a5,-96(s0)
    80017d3a:	fb843783          	ld	a5,-72(s0)
    80017d3e:	faf43423          	sd	a5,-88(s0)
    VirtioDescriptor chain1[3] = {cmd_desc, resp0_desc, resp1_desc};
    80017d42:	fd043783          	ld	a5,-48(s0)
    80017d46:	f6f43023          	sd	a5,-160(s0)
    80017d4a:	fd843783          	ld	a5,-40(s0)
    80017d4e:	f6f43423          	sd	a5,-152(s0)
    80017d52:	fc043783          	ld	a5,-64(s0)
    80017d56:	f6f43823          	sd	a5,-144(s0)
    80017d5a:	fc843783          	ld	a5,-56(s0)
    80017d5e:	f6f43c23          	sd	a5,-136(s0)
    80017d62:	fb043783          	ld	a5,-80(s0)
    80017d66:	f8f43023          	sd	a5,-128(s0)
    80017d6a:	fb843783          	ld	a5,-72(s0)
    80017d6e:	f8f43423          	sd	a5,-120(s0)
    VirtioDescriptor *chain = resp0 == NULL ? chain0 : chain1;
    80017d72:	f3843783          	ld	a5,-200(s0)
    80017d76:	e781                	bnez	a5,80017d7e <gpu_send_command+0xe6>
    80017d78:	f9040793          	addi	a5,s0,-112
    80017d7c:	a019                	j	80017d82 <gpu_send_command+0xea>
    80017d7e:	f6040793          	addi	a5,s0,-160
    80017d82:	fef43423          	sd	a5,-24(s0)
    unsigned num_descriptors = resp0 == NULL ? 2 : 3;
    80017d86:	f3843783          	ld	a5,-200(s0)
    80017d8a:	e399                	bnez	a5,80017d90 <gpu_send_command+0xf8>
    80017d8c:	4789                	li	a5,2
    80017d8e:	a011                	j	80017d92 <gpu_send_command+0xfa>
    80017d90:	478d                	li	a5,3
    80017d92:	fef42223          	sw	a5,-28(s0)
    virtio_send_descriptor_chain(gpu_device, which_queue, chain, num_descriptors, true);
    80017d96:	fe442783          	lw	a5,-28(s0)
    80017d9a:	03079693          	slli	a3,a5,0x30
    80017d9e:	92c1                	srli	a3,a3,0x30
    80017da0:	f5645783          	lhu	a5,-170(s0)
    80017da4:	4705                	li	a4,1
    80017da6:	fe843603          	ld	a2,-24(s0)
    80017daa:	85be                	mv	a1,a5
    80017dac:	f5843503          	ld	a0,-168(s0)
    80017db0:	20a030ef          	jal	ra,8001afba <virtio_send_descriptor_chain>
    
    // Wait until device_idx catches up 
    while (gpu_device->device_idx != gpu_device->device->idx) {
    80017db4:	a039                	j	80017dc2 <gpu_send_command+0x12a>
        debugf("GPU WAITING\n");
    80017db6:	0000d517          	auipc	a0,0xd
    80017dba:	de250513          	addi	a0,a0,-542 # 80024b98 <pow10.0+0x968>
    80017dbe:	3ec010ef          	jal	ra,800191aa <debugf>
    while (gpu_device->device_idx != gpu_device->device->idx) {
    80017dc2:	f5843783          	ld	a5,-168(s0)
    80017dc6:	08c7d703          	lhu	a4,140(a5)
    80017dca:	f5843783          	ld	a5,-168(s0)
    80017dce:	7bbc                	ld	a5,112(a5)
    80017dd0:	0027d783          	lhu	a5,2(a5)
    80017dd4:	17c2                	slli	a5,a5,0x30
    80017dd6:	93c1                	srli	a5,a5,0x30
    80017dd8:	2701                	sext.w	a4,a4
    80017dda:	2781                	sext.w	a5,a5
    80017ddc:	fcf71de3          	bne	a4,a5,80017db6 <gpu_send_command+0x11e>
    }
    debugf("gpu_send_command: device_idx caught up\n");
    80017de0:	0000d517          	auipc	a0,0xd
    80017de4:	dc850513          	addi	a0,a0,-568 # 80024ba8 <pow10.0+0x978>
    80017de8:	3c2010ef          	jal	ra,800191aa <debugf>
}
    80017dec:	0001                	nop
    80017dee:	60ee                	ld	ra,216(sp)
    80017df0:	644e                	ld	s0,208(sp)
    80017df2:	612d                	addi	sp,sp,224
    80017df4:	8082                	ret

0000000080017df6 <gpu_get_display_info>:

// Get display info and set frame buffer's info.
// Return true if display is enabled. Return false if not.
bool gpu_get_display_info(VirtioDevice *gpu_device,
                          VirtioGpuDispInfoResp *disp_resp) {
    80017df6:	7119                	addi	sp,sp,-128
    80017df8:	fc86                	sd	ra,120(sp)
    80017dfa:	f8a2                	sd	s0,112(sp)
    80017dfc:	0100                	addi	s0,sp,128
    80017dfe:	f8a43423          	sd	a0,-120(s0)
    80017e02:	f8b43023          	sd	a1,-128(s0)
    VirtioGpuCtrlHdr hdr;
    hdr.type = VIRTIO_GPU_CMD_GET_DISPLAY_INFO;
    80017e06:	10000793          	li	a5,256
    80017e0a:	fcf42c23          	sw	a5,-40(s0)
    hdr.flags = 0;
    80017e0e:	fc042e23          	sw	zero,-36(s0)
    hdr.fence_id = 0;
    80017e12:	fe043023          	sd	zero,-32(s0)
    hdr.context_id = 0;
    80017e16:	fe042423          	sw	zero,-24(s0)
    hdr.padding = 0;
    80017e1a:	fe042623          	sw	zero,-20(s0)

    VirtioDescriptor hdr_desc;
    hdr_desc.addr = kernel_mmu_translate((uintptr_t)&hdr);
    80017e1e:	fd840793          	addi	a5,s0,-40
    80017e22:	853e                	mv	a0,a5
    80017e24:	6af010ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    80017e28:	87aa                	mv	a5,a0
    80017e2a:	fcf43423          	sd	a5,-56(s0)
    hdr_desc.len = sizeof(hdr);
    80017e2e:	47e1                	li	a5,24
    80017e30:	fcf42823          	sw	a5,-48(s0)
    hdr_desc.flags = VIRTQ_DESC_F_NEXT;
    80017e34:	4785                	li	a5,1
    80017e36:	fcf41a23          	sh	a5,-44(s0)

    VirtioDescriptor disp_resp_desc;
    disp_resp_desc.addr = kernel_mmu_translate((uintptr_t)disp_resp);
    80017e3a:	f8043783          	ld	a5,-128(s0)
    80017e3e:	853e                	mv	a0,a5
    80017e40:	693010ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    80017e44:	87aa                	mv	a5,a0
    80017e46:	faf43c23          	sd	a5,-72(s0)
    disp_resp_desc.len = sizeof(VirtioGpuDispInfoResp);
    80017e4a:	19800793          	li	a5,408
    80017e4e:	fcf42023          	sw	a5,-64(s0)
    disp_resp_desc.flags = VIRTQ_DESC_F_WRITE;
    80017e52:	4789                	li	a5,2
    80017e54:	fcf41223          	sh	a5,-60(s0)

    VirtioDescriptor chain[2] = {hdr_desc, disp_resp_desc};
    80017e58:	fc843783          	ld	a5,-56(s0)
    80017e5c:	f8f43c23          	sd	a5,-104(s0)
    80017e60:	fd043783          	ld	a5,-48(s0)
    80017e64:	faf43023          	sd	a5,-96(s0)
    80017e68:	fb843783          	ld	a5,-72(s0)
    80017e6c:	faf43423          	sd	a5,-88(s0)
    80017e70:	fc043783          	ld	a5,-64(s0)
    80017e74:	faf43823          	sd	a5,-80(s0)

    virtio_send_descriptor_chain(gpu_device, 0, chain, 2, true);
    80017e78:	f9840793          	addi	a5,s0,-104
    80017e7c:	4705                	li	a4,1
    80017e7e:	4689                	li	a3,2
    80017e80:	863e                	mv	a2,a5
    80017e82:	4581                	li	a1,0
    80017e84:	f8843503          	ld	a0,-120(s0)
    80017e88:	132030ef          	jal	ra,8001afba <virtio_send_descriptor_chain>

    debugf("Internal desc_idx: %d\n", gpu_device->desc_idx);
    80017e8c:	f8843783          	ld	a5,-120(s0)
    80017e90:	0887d783          	lhu	a5,136(a5)
    80017e94:	2781                	sext.w	a5,a5
    80017e96:	85be                	mv	a1,a5
    80017e98:	0000d517          	auipc	a0,0xd
    80017e9c:	d3850513          	addi	a0,a0,-712 # 80024bd0 <pow10.0+0x9a0>
    80017ea0:	30a010ef          	jal	ra,800191aa <debugf>
    debugf("Internal driver_idx: %d\n", gpu_device->driver_idx);
    80017ea4:	f8843783          	ld	a5,-120(s0)
    80017ea8:	08a7d783          	lhu	a5,138(a5)
    80017eac:	2781                	sext.w	a5,a5
    80017eae:	85be                	mv	a1,a5
    80017eb0:	0000d517          	auipc	a0,0xd
    80017eb4:	d3850513          	addi	a0,a0,-712 # 80024be8 <pow10.0+0x9b8>
    80017eb8:	2f2010ef          	jal	ra,800191aa <debugf>
    debugf("Internal device_idx: %d\n", gpu_device->device_idx);
    80017ebc:	f8843783          	ld	a5,-120(s0)
    80017ec0:	08c7d783          	lhu	a5,140(a5)
    80017ec4:	2781                	sext.w	a5,a5
    80017ec6:	85be                	mv	a1,a5
    80017ec8:	0000d517          	auipc	a0,0xd
    80017ecc:	d4050513          	addi	a0,a0,-704 # 80024c08 <pow10.0+0x9d8>
    80017ed0:	2da010ef          	jal	ra,800191aa <debugf>
    debugf("Driver ring index: %d\n", gpu_device->driver->idx);
    80017ed4:	f8843783          	ld	a5,-120(s0)
    80017ed8:	77bc                	ld	a5,104(a5)
    80017eda:	0027d783          	lhu	a5,2(a5)
    80017ede:	17c2                	slli	a5,a5,0x30
    80017ee0:	93c1                	srli	a5,a5,0x30
    80017ee2:	2781                	sext.w	a5,a5
    80017ee4:	85be                	mv	a1,a5
    80017ee6:	0000d517          	auipc	a0,0xd
    80017eea:	d4250513          	addi	a0,a0,-702 # 80024c28 <pow10.0+0x9f8>
    80017eee:	2bc010ef          	jal	ra,800191aa <debugf>
    debugf("Device ring index: %d\n", gpu_device->device->idx);
    80017ef2:	f8843783          	ld	a5,-120(s0)
    80017ef6:	7bbc                	ld	a5,112(a5)
    80017ef8:	0027d783          	lhu	a5,2(a5)
    80017efc:	17c2                	slli	a5,a5,0x30
    80017efe:	93c1                	srli	a5,a5,0x30
    80017f00:	2781                	sext.w	a5,a5
    80017f02:	85be                	mv	a1,a5
    80017f04:	0000d517          	auipc	a0,0xd
    80017f08:	d3c50513          	addi	a0,a0,-708 # 80024c40 <pow10.0+0xa10>
    80017f0c:	29e010ef          	jal	ra,800191aa <debugf>

    debugf("used element id: %d\n", gpu_device->device->ring[0].id);
    80017f10:	f8843783          	ld	a5,-120(s0)
    80017f14:	7bbc                	ld	a5,112(a5)
    80017f16:	43dc                	lw	a5,4(a5)
    80017f18:	2781                	sext.w	a5,a5
    80017f1a:	85be                	mv	a1,a5
    80017f1c:	0000d517          	auipc	a0,0xd
    80017f20:	d3c50513          	addi	a0,a0,-708 # 80024c58 <pow10.0+0xa28>
    80017f24:	286010ef          	jal	ra,800191aa <debugf>
    debugf("used element len: %d\n", gpu_device->device->ring[0].len);
    80017f28:	f8843783          	ld	a5,-120(s0)
    80017f2c:	7bbc                	ld	a5,112(a5)
    80017f2e:	479c                	lw	a5,8(a5)
    80017f30:	2781                	sext.w	a5,a5
    80017f32:	85be                	mv	a1,a5
    80017f34:	0000d517          	auipc	a0,0xd
    80017f38:	d3c50513          	addi	a0,a0,-708 # 80024c70 <pow10.0+0xa40>
    80017f3c:	26e010ef          	jal	ra,800191aa <debugf>
    debugf("used element id: %d\n", gpu_device->device->ring[1].id);
    80017f40:	f8843783          	ld	a5,-120(s0)
    80017f44:	7bbc                	ld	a5,112(a5)
    80017f46:	47dc                	lw	a5,12(a5)
    80017f48:	2781                	sext.w	a5,a5
    80017f4a:	85be                	mv	a1,a5
    80017f4c:	0000d517          	auipc	a0,0xd
    80017f50:	d0c50513          	addi	a0,a0,-756 # 80024c58 <pow10.0+0xa28>
    80017f54:	256010ef          	jal	ra,800191aa <debugf>
    debugf("used element len: %d\n", gpu_device->device->ring[1].len);
    80017f58:	f8843783          	ld	a5,-120(s0)
    80017f5c:	7bbc                	ld	a5,112(a5)
    80017f5e:	4b9c                	lw	a5,16(a5)
    80017f60:	2781                	sext.w	a5,a5
    80017f62:	85be                	mv	a1,a5
    80017f64:	0000d517          	auipc	a0,0xd
    80017f68:	d0c50513          	addi	a0,a0,-756 # 80024c70 <pow10.0+0xa40>
    80017f6c:	23e010ef          	jal	ra,800191aa <debugf>

    if (disp_resp->hdr.type == VIRTIO_GPU_RESP_OK_DISPLAY_INFO)
    80017f70:	f8043783          	ld	a5,-128(s0)
    80017f74:	439c                	lw	a5,0(a5)
    80017f76:	873e                	mv	a4,a5
    80017f78:	6785                	lui	a5,0x1
    80017f7a:	10178793          	addi	a5,a5,257 # 1101 <i+0x10e1>
    80017f7e:	00f71863          	bne	a4,a5,80017f8e <gpu_get_display_info+0x198>
        debugf("gpu_get_display_info: Received display info\n");
    80017f82:	0000d517          	auipc	a0,0xd
    80017f86:	d0650513          	addi	a0,a0,-762 # 80024c88 <pow10.0+0xa58>
    80017f8a:	220010ef          	jal	ra,800191aa <debugf>

    if (!disp_resp->displays[0].enabled)
    80017f8e:	f8043783          	ld	a5,-128(s0)
    80017f92:	579c                	lw	a5,40(a5)
    80017f94:	e399                	bnez	a5,80017f9a <gpu_get_display_info+0x1a4>
        return false;
    80017f96:	4781                	li	a5,0
    80017f98:	a801                	j	80017fa8 <gpu_get_display_info+0x1b2>
    debugf("gpu_get_display_info: Display 0 enabled\n");
    80017f9a:	0000d517          	auipc	a0,0xd
    80017f9e:	d1e50513          	addi	a0,a0,-738 # 80024cb8 <pow10.0+0xa88>
    80017fa2:	208010ef          	jal	ra,800191aa <debugf>

    return true;
    80017fa6:	4785                	li	a5,1
}
    80017fa8:	853e                	mv	a0,a5
    80017faa:	70e6                	ld	ra,120(sp)
    80017fac:	7446                	ld	s0,112(sp)
    80017fae:	6109                	addi	sp,sp,128
    80017fb0:	8082                	ret

0000000080017fb2 <fill_rect>:
void fill_rect(uint32_t screen_width,
               uint32_t screen_height,
               Pixel *frame_buf,
               const Rectangle *rect,
               const Pixel *fill_color)
               {
    80017fb2:	715d                	addi	sp,sp,-80
    80017fb4:	e4a2                	sd	s0,72(sp)
    80017fb6:	0880                	addi	s0,sp,80
    80017fb8:	87aa                	mv	a5,a0
    80017fba:	fcc43023          	sd	a2,-64(s0)
    80017fbe:	fad43c23          	sd	a3,-72(s0)
    80017fc2:	fae43823          	sd	a4,-80(s0)
    80017fc6:	fcf42623          	sw	a5,-52(s0)
    80017fca:	87ae                	mv	a5,a1
    80017fcc:	fcf42423          	sw	a5,-56(s0)
    uint32_t top = rect->y;
    80017fd0:	fb843783          	ld	a5,-72(s0)
    80017fd4:	43dc                	lw	a5,4(a5)
    80017fd6:	fcf42e23          	sw	a5,-36(s0)
    uint32_t bottom = rect->y + rect->height;
    80017fda:	fb843783          	ld	a5,-72(s0)
    80017fde:	43d8                	lw	a4,4(a5)
    80017fe0:	fb843783          	ld	a5,-72(s0)
    80017fe4:	47dc                	lw	a5,12(a5)
    80017fe6:	9fb9                	addw	a5,a5,a4
    80017fe8:	fef42623          	sw	a5,-20(s0)
    uint32_t left = rect->x;
    80017fec:	fb843783          	ld	a5,-72(s0)
    80017ff0:	439c                	lw	a5,0(a5)
    80017ff2:	fcf42c23          	sw	a5,-40(s0)
    uint32_t right = rect->x + rect->width;
    80017ff6:	fb843783          	ld	a5,-72(s0)
    80017ffa:	4398                	lw	a4,0(a5)
    80017ffc:	fb843783          	ld	a5,-72(s0)
    80018000:	479c                	lw	a5,8(a5)
    80018002:	9fb9                	addw	a5,a5,a4
    80018004:	fef42423          	sw	a5,-24(s0)
    uint32_t row;
    uint32_t col;
    uint32_t offset;

    if (bottom > screen_height) {
    80018008:	fec42703          	lw	a4,-20(s0)
    8001800c:	fc842783          	lw	a5,-56(s0)
    80018010:	2701                	sext.w	a4,a4
    80018012:	2781                	sext.w	a5,a5
    80018014:	00e7f663          	bgeu	a5,a4,80018020 <fill_rect+0x6e>
        bottom = screen_height;
    80018018:	fc842783          	lw	a5,-56(s0)
    8001801c:	fef42623          	sw	a5,-20(s0)
    }
    if (right > screen_width) {
    80018020:	fe842703          	lw	a4,-24(s0)
    80018024:	fcc42783          	lw	a5,-52(s0)
    80018028:	2701                	sext.w	a4,a4
    8001802a:	2781                	sext.w	a5,a5
    8001802c:	00e7f663          	bgeu	a5,a4,80018038 <fill_rect+0x86>
        right = screen_width;
    80018030:	fcc42783          	lw	a5,-52(s0)
    80018034:	fef42423          	sw	a5,-24(s0)
    }

    for (row = top; row < bottom; row++) {
    80018038:	fdc42783          	lw	a5,-36(s0)
    8001803c:	fef42223          	sw	a5,-28(s0)
    80018040:	a89d                	j	800180b6 <fill_rect+0x104>
        for (col = left;col < right;col++) {
    80018042:	fd842783          	lw	a5,-40(s0)
    80018046:	fef42023          	sw	a5,-32(s0)
    8001804a:	a889                	j	8001809c <fill_rect+0xea>
            frame_buf[row * screen_width + col] = *fill_color;
    8001804c:	fe442703          	lw	a4,-28(s0)
    80018050:	fcc42783          	lw	a5,-52(s0)
    80018054:	02f707bb          	mulw	a5,a4,a5
    80018058:	2781                	sext.w	a5,a5
    8001805a:	fe042703          	lw	a4,-32(s0)
    8001805e:	9fb9                	addw	a5,a5,a4
    80018060:	2781                	sext.w	a5,a5
    80018062:	1782                	slli	a5,a5,0x20
    80018064:	9381                	srli	a5,a5,0x20
    80018066:	078a                	slli	a5,a5,0x2
    80018068:	fc043703          	ld	a4,-64(s0)
    8001806c:	97ba                	add	a5,a5,a4
    8001806e:	fb043703          	ld	a4,-80(s0)
    80018072:	00074583          	lbu	a1,0(a4)
    80018076:	00174603          	lbu	a2,1(a4)
    8001807a:	00274683          	lbu	a3,2(a4)
    8001807e:	00374703          	lbu	a4,3(a4)
    80018082:	00b78023          	sb	a1,0(a5)
    80018086:	00c780a3          	sb	a2,1(a5)
    8001808a:	00d78123          	sb	a3,2(a5)
    8001808e:	00e781a3          	sb	a4,3(a5)
        for (col = left;col < right;col++) {
    80018092:	fe042783          	lw	a5,-32(s0)
    80018096:	2785                	addiw	a5,a5,1
    80018098:	fef42023          	sw	a5,-32(s0)
    8001809c:	fe042703          	lw	a4,-32(s0)
    800180a0:	fe842783          	lw	a5,-24(s0)
    800180a4:	2701                	sext.w	a4,a4
    800180a6:	2781                	sext.w	a5,a5
    800180a8:	faf762e3          	bltu	a4,a5,8001804c <fill_rect+0x9a>
    for (row = top; row < bottom; row++) {
    800180ac:	fe442783          	lw	a5,-28(s0)
    800180b0:	2785                	addiw	a5,a5,1
    800180b2:	fef42223          	sw	a5,-28(s0)
    800180b6:	fe442703          	lw	a4,-28(s0)
    800180ba:	fec42783          	lw	a5,-20(s0)
    800180be:	2701                	sext.w	a4,a4
    800180c0:	2781                	sext.w	a5,a5
    800180c2:	f8f760e3          	bltu	a4,a5,80018042 <fill_rect+0x90>
        }
   }
}
    800180c6:	0001                	nop
    800180c8:	0001                	nop
    800180ca:	6426                	ld	s0,72(sp)
    800180cc:	6161                	addi	sp,sp,80
    800180ce:	8082                	ret

00000000800180d0 <RVALS>:
static inline void RVALS(Rectangle *r,
                         uint32_t x,
                         uint32_t y,
                         uint32_t width,
                         uint32_t height)
{
    800180d0:	7179                	addi	sp,sp,-48
    800180d2:	f422                	sd	s0,40(sp)
    800180d4:	1800                	addi	s0,sp,48
    800180d6:	fea43423          	sd	a0,-24(s0)
    800180da:	87ae                	mv	a5,a1
    800180dc:	fef42223          	sw	a5,-28(s0)
    800180e0:	87b2                	mv	a5,a2
    800180e2:	fef42023          	sw	a5,-32(s0)
    800180e6:	87b6                	mv	a5,a3
    800180e8:	fcf42e23          	sw	a5,-36(s0)
    800180ec:	87ba                	mv	a5,a4
    800180ee:	fcf42c23          	sw	a5,-40(s0)
    r->x = x;
    800180f2:	fe843783          	ld	a5,-24(s0)
    800180f6:	fe442703          	lw	a4,-28(s0)
    800180fa:	c398                	sw	a4,0(a5)
    r->y = y;
    800180fc:	fe843783          	ld	a5,-24(s0)
    80018100:	fe042703          	lw	a4,-32(s0)
    80018104:	c3d8                	sw	a4,4(a5)
    r->width = width;
    80018106:	fe843783          	ld	a5,-24(s0)
    8001810a:	fdc42703          	lw	a4,-36(s0)
    8001810e:	c798                	sw	a4,8(a5)
    r->height = height;
    80018110:	fe843783          	ld	a5,-24(s0)
    80018114:	fd842703          	lw	a4,-40(s0)
    80018118:	c7d8                	sw	a4,12(a5)
}
    8001811a:	0001                	nop
    8001811c:	7422                	ld	s0,40(sp)
    8001811e:	6145                	addi	sp,sp,48
    80018120:	8082                	ret

0000000080018122 <stroke_rect>:
                 uint32_t screen_height,
                 Pixel *frame_buf,
                 const Rectangle *rect,
                 const Pixel *line_color,
                 uint32_t line_size)
{
    80018122:	715d                	addi	sp,sp,-80
    80018124:	e486                	sd	ra,72(sp)
    80018126:	e0a2                	sd	s0,64(sp)
    80018128:	0880                	addi	s0,sp,80
    8001812a:	fcc43823          	sd	a2,-48(s0)
    8001812e:	fcd43423          	sd	a3,-56(s0)
    80018132:	fce43023          	sd	a4,-64(s0)
    80018136:	873e                	mv	a4,a5
    80018138:	87aa                	mv	a5,a0
    8001813a:	fcf42e23          	sw	a5,-36(s0)
    8001813e:	87ae                	mv	a5,a1
    80018140:	fcf42c23          	sw	a5,-40(s0)
    80018144:	87ba                	mv	a5,a4
    80018146:	faf42e23          	sw	a5,-68(s0)
    struct Rectangle r;
    // Top
    RVALS(&r, rect->x, rect->y,
    8001814a:	fc843783          	ld	a5,-56(s0)
    8001814e:	438c                	lw	a1,0(a5)
    80018150:	fc843783          	ld	a5,-56(s0)
    80018154:	43d0                	lw	a2,4(a5)
    80018156:	fc843783          	ld	a5,-56(s0)
    8001815a:	4794                	lw	a3,8(a5)
    8001815c:	fbc42703          	lw	a4,-68(s0)
    80018160:	fe040793          	addi	a5,s0,-32
    80018164:	853e                	mv	a0,a5
    80018166:	f6bff0ef          	jal	ra,800180d0 <RVALS>
              rect->width, line_size);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    8001816a:	fe040693          	addi	a3,s0,-32
    8001816e:	fd842583          	lw	a1,-40(s0)
    80018172:	fdc42783          	lw	a5,-36(s0)
    80018176:	fc043703          	ld	a4,-64(s0)
    8001817a:	fd043603          	ld	a2,-48(s0)
    8001817e:	853e                	mv	a0,a5
    80018180:	e33ff0ef          	jal	ra,80017fb2 <fill_rect>

    // Bottom
    RVALS(&r, rect->x, rect->height + rect->y,
    80018184:	fc843783          	ld	a5,-56(s0)
    80018188:	438c                	lw	a1,0(a5)
    8001818a:	fc843783          	ld	a5,-56(s0)
    8001818e:	47d8                	lw	a4,12(a5)
    80018190:	fc843783          	ld	a5,-56(s0)
    80018194:	43dc                	lw	a5,4(a5)
    80018196:	9fb9                	addw	a5,a5,a4
    80018198:	0007861b          	sext.w	a2,a5
    8001819c:	fc843783          	ld	a5,-56(s0)
    800181a0:	4794                	lw	a3,8(a5)
    800181a2:	fbc42703          	lw	a4,-68(s0)
    800181a6:	fe040793          	addi	a5,s0,-32
    800181aa:	853e                	mv	a0,a5
    800181ac:	f25ff0ef          	jal	ra,800180d0 <RVALS>
              rect->width, line_size);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    800181b0:	fe040693          	addi	a3,s0,-32
    800181b4:	fd842583          	lw	a1,-40(s0)
    800181b8:	fdc42783          	lw	a5,-36(s0)
    800181bc:	fc043703          	ld	a4,-64(s0)
    800181c0:	fd043603          	ld	a2,-48(s0)
    800181c4:	853e                	mv	a0,a5
    800181c6:	dedff0ef          	jal	ra,80017fb2 <fill_rect>

    // Left
    RVALS(&r, rect->x, rect->y,
    800181ca:	fc843783          	ld	a5,-56(s0)
    800181ce:	438c                	lw	a1,0(a5)
    800181d0:	fc843783          	ld	a5,-56(s0)
    800181d4:	43d0                	lw	a2,4(a5)
    800181d6:	fc843783          	ld	a5,-56(s0)
    800181da:	47d8                	lw	a4,12(a5)
    800181dc:	fbc42683          	lw	a3,-68(s0)
    800181e0:	fe040793          	addi	a5,s0,-32
    800181e4:	853e                	mv	a0,a5
    800181e6:	eebff0ef          	jal	ra,800180d0 <RVALS>
              line_size, rect->height);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    800181ea:	fe040693          	addi	a3,s0,-32
    800181ee:	fd842583          	lw	a1,-40(s0)
    800181f2:	fdc42783          	lw	a5,-36(s0)
    800181f6:	fc043703          	ld	a4,-64(s0)
    800181fa:	fd043603          	ld	a2,-48(s0)
    800181fe:	853e                	mv	a0,a5
    80018200:	db3ff0ef          	jal	ra,80017fb2 <fill_rect>

    // Right
    RVALS(&r, rect->x + rect->width, rect->y,
    80018204:	fc843783          	ld	a5,-56(s0)
    80018208:	4398                	lw	a4,0(a5)
    8001820a:	fc843783          	ld	a5,-56(s0)
    8001820e:	479c                	lw	a5,8(a5)
    80018210:	9fb9                	addw	a5,a5,a4
    80018212:	0007859b          	sext.w	a1,a5
    80018216:	fc843783          	ld	a5,-56(s0)
    8001821a:	43d0                	lw	a2,4(a5)
              line_size, rect->height + line_size);
    8001821c:	fc843783          	ld	a5,-56(s0)
    80018220:	47dc                	lw	a5,12(a5)
    RVALS(&r, rect->x + rect->width, rect->y,
    80018222:	fbc42703          	lw	a4,-68(s0)
    80018226:	9fb9                	addw	a5,a5,a4
    80018228:	0007871b          	sext.w	a4,a5
    8001822c:	fbc42683          	lw	a3,-68(s0)
    80018230:	fe040793          	addi	a5,s0,-32
    80018234:	853e                	mv	a0,a5
    80018236:	e9bff0ef          	jal	ra,800180d0 <RVALS>
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    8001823a:	fe040693          	addi	a3,s0,-32
    8001823e:	fd842583          	lw	a1,-40(s0)
    80018242:	fdc42783          	lw	a5,-36(s0)
    80018246:	fc043703          	ld	a4,-64(s0)
    8001824a:	fd043603          	ld	a2,-48(s0)
    8001824e:	853e                	mv	a0,a5
    80018250:	d63ff0ef          	jal	ra,80017fb2 <fill_rect>
}
    80018254:	0001                	nop
    80018256:	60a6                	ld	ra,72(sp)
    80018258:	6406                	ld	s0,64(sp)
    8001825a:	6161                	addi	sp,sp,80
    8001825c:	8082                	ret

000000008001825e <gpu_get_resp_string>:

// Return the respective response message string
static char *gpu_get_resp_string(VirtioGpuCtrlType type) {
    8001825e:	1101                	addi	sp,sp,-32
    80018260:	ec22                	sd	s0,24(sp)
    80018262:	1000                	addi	s0,sp,32
    80018264:	87aa                	mv	a5,a0
    80018266:	fef42623          	sw	a5,-20(s0)
    switch (type) {
    8001826a:	fec42783          	lw	a5,-20(s0)
    8001826e:	0007871b          	sext.w	a4,a5
    80018272:	6785                	lui	a5,0x1
    80018274:	10478793          	addi	a5,a5,260 # 1104 <i+0x10e4>
    80018278:	08e7ea63          	bltu	a5,a4,8001830c <gpu_get_resp_string+0xae>
    8001827c:	fec42783          	lw	a5,-20(s0)
    80018280:	0007871b          	sext.w	a4,a5
    80018284:	6785                	lui	a5,0x1
    80018286:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    8001828a:	04f77263          	bgeu	a4,a5,800182ce <gpu_get_resp_string+0x70>
    8001828e:	aa09                	j	800183a0 <gpu_get_resp_string+0x142>
    80018290:	fec42703          	lw	a4,-20(s0)
    80018294:	77fd                	lui	a5,0xfffff
    80018296:	e007879b          	addiw	a5,a5,-512
    8001829a:	00f706bb          	addw	a3,a4,a5
    8001829e:	0006871b          	sext.w	a4,a3
    800182a2:	4795                	li	a5,5
    800182a4:	0ee7ee63          	bltu	a5,a4,800183a0 <gpu_get_resp_string+0x142>
    800182a8:	02069793          	slli	a5,a3,0x20
    800182ac:	9381                	srli	a5,a5,0x20
    800182ae:	00279713          	slli	a4,a5,0x2
    800182b2:	0000d797          	auipc	a5,0xd
    800182b6:	be678793          	addi	a5,a5,-1050 # 80024e98 <pow10.0+0xc68>
    800182ba:	97ba                	add	a5,a5,a4
    800182bc:	439c                	lw	a5,0(a5)
    800182be:	0007871b          	sext.w	a4,a5
    800182c2:	0000d797          	auipc	a5,0xd
    800182c6:	bd678793          	addi	a5,a5,-1066 # 80024e98 <pow10.0+0xc68>
    800182ca:	97ba                	add	a5,a5,a4
    800182cc:	8782                	jr	a5
    800182ce:	fec42703          	lw	a4,-20(s0)
    800182d2:	77fd                	lui	a5,0xfffff
    800182d4:	f007879b          	addiw	a5,a5,-256
    800182d8:	00f706bb          	addw	a3,a4,a5
    800182dc:	0006871b          	sext.w	a4,a3
    800182e0:	4791                	li	a5,4
    800182e2:	0ae7ef63          	bltu	a5,a4,800183a0 <gpu_get_resp_string+0x142>
    800182e6:	02069793          	slli	a5,a3,0x20
    800182ea:	9381                	srli	a5,a5,0x20
    800182ec:	00279713          	slli	a4,a5,0x2
    800182f0:	0000d797          	auipc	a5,0xd
    800182f4:	bc078793          	addi	a5,a5,-1088 # 80024eb0 <pow10.0+0xc80>
    800182f8:	97ba                	add	a5,a5,a4
    800182fa:	439c                	lw	a5,0(a5)
    800182fc:	0007871b          	sext.w	a4,a5
    80018300:	0000d797          	auipc	a5,0xd
    80018304:	bb078793          	addi	a5,a5,-1104 # 80024eb0 <pow10.0+0xc80>
    80018308:	97ba                	add	a5,a5,a4
    8001830a:	8782                	jr	a5
    8001830c:	fec42783          	lw	a5,-20(s0)
    80018310:	0007871b          	sext.w	a4,a5
    80018314:	6785                	lui	a5,0x1
    80018316:	20578793          	addi	a5,a5,517 # 1205 <i+0x11e5>
    8001831a:	08e7e363          	bltu	a5,a4,800183a0 <gpu_get_resp_string+0x142>
    8001831e:	fec42783          	lw	a5,-20(s0)
    80018322:	0007871b          	sext.w	a4,a5
    80018326:	6785                	lui	a5,0x1
    80018328:	20078793          	addi	a5,a5,512 # 1200 <i+0x11e0>
    8001832c:	f6f772e3          	bgeu	a4,a5,80018290 <gpu_get_resp_string+0x32>
    80018330:	a885                	j	800183a0 <gpu_get_resp_string+0x142>
        // Success responses
        case VIRTIO_GPU_RESP_OK_NODATA: return "VIRTIO_GPU_RESP_OK_NODATA";
    80018332:	0000d797          	auipc	a5,0xd
    80018336:	9b678793          	addi	a5,a5,-1610 # 80024ce8 <pow10.0+0xab8>
    8001833a:	a0bd                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_DISPLAY_INFO: return "VIRTIO_GPU_RESP_OK_DISPLAY_INFO";
    8001833c:	0000d797          	auipc	a5,0xd
    80018340:	9cc78793          	addi	a5,a5,-1588 # 80024d08 <pow10.0+0xad8>
    80018344:	a095                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_CAPSET_INFO: return "VIRTIO_GPU_RESP_OK_CAPSET_INFO";
    80018346:	0000d797          	auipc	a5,0xd
    8001834a:	9e278793          	addi	a5,a5,-1566 # 80024d28 <pow10.0+0xaf8>
    8001834e:	a8a9                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_CAPSET: return "VIRTIO_GPU_RESP_OK_CAPSET";
    80018350:	0000d797          	auipc	a5,0xd
    80018354:	9f878793          	addi	a5,a5,-1544 # 80024d48 <pow10.0+0xb18>
    80018358:	a881                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_EDID: return "VIRTIO_GPU_RESP_OK_EDID";
    8001835a:	0000d797          	auipc	a5,0xd
    8001835e:	a0e78793          	addi	a5,a5,-1522 # 80024d68 <pow10.0+0xb38>
    80018362:	a099                	j	800183a8 <gpu_get_resp_string+0x14a>
        // Error responses
        case VIRTIO_GPU_RESP_ERR_UNSPEC: return "VIRTIO_GPU_RESP_ERR_UNSPEC";
    80018364:	0000d797          	auipc	a5,0xd
    80018368:	a1c78793          	addi	a5,a5,-1508 # 80024d80 <pow10.0+0xb50>
    8001836c:	a835                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY: return "VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY";
    8001836e:	0000d797          	auipc	a5,0xd
    80018372:	a3278793          	addi	a5,a5,-1486 # 80024da0 <pow10.0+0xb70>
    80018376:	a80d                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID";
    80018378:	0000d797          	auipc	a5,0xd
    8001837c:	a5078793          	addi	a5,a5,-1456 # 80024dc8 <pow10.0+0xb98>
    80018380:	a025                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID";
    80018382:	0000d797          	auipc	a5,0xd
    80018386:	a6e78793          	addi	a5,a5,-1426 # 80024df0 <pow10.0+0xbc0>
    8001838a:	a839                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID";
    8001838c:	0000d797          	auipc	a5,0xd
    80018390:	a8c78793          	addi	a5,a5,-1396 # 80024e18 <pow10.0+0xbe8>
    80018394:	a811                	j	800183a8 <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER: return "VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER";
    80018396:	0000d797          	auipc	a5,0xd
    8001839a:	aaa78793          	addi	a5,a5,-1366 # 80024e40 <pow10.0+0xc10>
    8001839e:	a029                	j	800183a8 <gpu_get_resp_string+0x14a>
        default: return "Invalid type argument to gpu_get_resp_string"; break;
    800183a0:	0000d797          	auipc	a5,0xd
    800183a4:	ac878793          	addi	a5,a5,-1336 # 80024e68 <pow10.0+0xc38>
    }
}
    800183a8:	853e                	mv	a0,a5
    800183aa:	6462                	ld	s0,24(sp)
    800183ac:	6105                	addi	sp,sp,32
    800183ae:	8082                	ret

00000000800183b0 <init_systems>:
// the kernel.
// Defined in src/include/mmu.h
struct page_table *kernel_mmu_table;

static void init_systems(void)
{
    800183b0:	711d                	addi	sp,sp,-96
    800183b2:	ec86                	sd	ra,88(sp)
    800183b4:	e8a2                	sd	s0,80(sp)
    800183b6:	1080                	addi	s0,sp,96
    void plic_init(void);
    plic_init();
    800183b8:	4ae010ef          	jal	ra,80019866 <plic_init>
    debugf("plic_init() done\n");
    800183bc:	0000d517          	auipc	a0,0xd
    800183c0:	b0c50513          	addi	a0,a0,-1268 # 80024ec8 <pow10.0+0xc98>
    800183c4:	5e7000ef          	jal	ra,800191aa <debugf>
    void page_init(void);
    page_init();
    800183c8:	302030ef          	jal	ra,8001b6ca <page_init>
    debugf("page_init() done\n");
    800183cc:	0000d517          	auipc	a0,0xd
    800183d0:	b1450513          	addi	a0,a0,-1260 # 80024ee0 <pow10.0+0xcb0>
    800183d4:	5d7000ef          	jal	ra,800191aa <debugf>

#ifdef USE_MMU
    struct page_table *pt = mmu_table_create();
    800183d8:	4f8010ef          	jal	ra,800198d0 <mmu_table_create>
    800183dc:	fca43823          	sd	a0,-48(s0)
    kernel_mmu_table = pt;
    800183e0:	0000b797          	auipc	a5,0xb
    800183e4:	c2078793          	addi	a5,a5,-992 # 80023000 <kernel_mmu_table>
    800183e8:	fd043703          	ld	a4,-48(s0)
    800183ec:	e398                	sd	a4,0(a5)

    debugf("Kernel page table at %p\n", pt);
    800183ee:	fd043583          	ld	a1,-48(s0)
    800183f2:	0000d517          	auipc	a0,0xd
    800183f6:	b0650513          	addi	a0,a0,-1274 # 80024ef8 <pow10.0+0xcc8>
    800183fa:	5b1000ef          	jal	ra,800191aa <debugf>
    // Map memory segments for our kernel
    debugf("Mapping kernel segments\n");
    800183fe:	0000d517          	auipc	a0,0xd
    80018402:	b1a50513          	addi	a0,a0,-1254 # 80024f18 <pow10.0+0xce8>
    80018406:	5a5000ef          	jal	ra,800191aa <debugf>
    mmu_map_range(pt, sym_start(text), sym_end(heap), sym_start(text), MMU_LEVEL_1G,
    8001840a:	ffff8597          	auipc	a1,0xffff8
    8001840e:	bf658593          	addi	a1,a1,-1034 # 80010000 <_memory_start>
    80018412:	07ff8617          	auipc	a2,0x7ff8
    80018416:	bee60613          	addi	a2,a2,-1042 # 88010000 <_heap_end>
    8001841a:	ffff8697          	auipc	a3,0xffff8
    8001841e:	be668693          	addi	a3,a3,-1050 # 80010000 <_memory_start>
    80018422:	47b9                	li	a5,14
    80018424:	4709                	li	a4,2
    80018426:	fd043503          	ld	a0,-48(s0)
    8001842a:	0d5010ef          	jal	ra,80019cfe <mmu_map_range>
                  PB_READ | PB_WRITE | PB_EXECUTE);
    // PLIC
    debugf("Mapping PLIC\n");
    8001842e:	0000d517          	auipc	a0,0xd
    80018432:	b0a50513          	addi	a0,a0,-1270 # 80024f38 <pow10.0+0xd08>
    80018436:	575000ef          	jal	ra,800191aa <debugf>
    mmu_map_range(pt, 0x0C000000, 0x0C2FFFFF, 0x0C000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    8001843a:	4799                	li	a5,6
    8001843c:	4705                	li	a4,1
    8001843e:	0c0006b7          	lui	a3,0xc000
    80018442:	0c300637          	lui	a2,0xc300
    80018446:	167d                	addi	a2,a2,-1
    80018448:	0c0005b7          	lui	a1,0xc000
    8001844c:	fd043503          	ld	a0,-48(s0)
    80018450:	0af010ef          	jal	ra,80019cfe <mmu_map_range>
    // PCIe ECAM
    debugf("Mapping PCIe ECAM\n");
    80018454:	0000d517          	auipc	a0,0xd
    80018458:	af450513          	addi	a0,a0,-1292 # 80024f48 <pow10.0+0xd18>
    8001845c:	54f000ef          	jal	ra,800191aa <debugf>
    mmu_map_range(pt, 0x30000000, 0x3FFFFFFF, 0x30000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80018460:	4799                	li	a5,6
    80018462:	4705                	li	a4,1
    80018464:	300006b7          	lui	a3,0x30000
    80018468:	40000637          	lui	a2,0x40000
    8001846c:	167d                	addi	a2,a2,-1
    8001846e:	300005b7          	lui	a1,0x30000
    80018472:	fd043503          	ld	a0,-48(s0)
    80018476:	089010ef          	jal	ra,80019cfe <mmu_map_range>
    // PCIe MMIO
    debugf("Mapping PCIe MMIO\n");
    8001847a:	0000d517          	auipc	a0,0xd
    8001847e:	ae650513          	addi	a0,a0,-1306 # 80024f60 <pow10.0+0xd30>
    80018482:	529000ef          	jal	ra,800191aa <debugf>
    mmu_map_range(pt, 0x40000000, 0x5FFFFFFF, 0x40000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80018486:	4799                	li	a5,6
    80018488:	4705                	li	a4,1
    8001848a:	400006b7          	lui	a3,0x40000
    8001848e:	60000637          	lui	a2,0x60000
    80018492:	167d                	addi	a2,a2,-1
    80018494:	400005b7          	lui	a1,0x40000
    80018498:	fd043503          	ld	a0,-48(s0)
    8001849c:	063010ef          	jal	ra,80019cfe <mmu_map_range>
    //                    uint64_t start_virt, 
    //                    uint64_t end_virt, 
    //                    uint64_t start_phys)
    // debug_page_table(pt, MMU_LEVEL_1G);

    debugf("About to set SATP to %016lx\n", SATP_KERNEL);
    800184a0:	0000b797          	auipc	a5,0xb
    800184a4:	b6078793          	addi	a5,a5,-1184 # 80023000 <kernel_mmu_table>
    800184a8:	639c                	ld	a5,0(a5)
    800184aa:	00c7d713          	srli	a4,a5,0xc
    800184ae:	57fd                	li	a5,-1
    800184b0:	83d1                	srli	a5,a5,0x14
    800184b2:	8f7d                	and	a4,a4,a5
    800184b4:	8ffff7b7          	lui	a5,0x8ffff
    800184b8:	1782                	slli	a5,a5,0x20
    800184ba:	8fd9                	or	a5,a5,a4
    800184bc:	85be                	mv	a1,a5
    800184be:	0000d517          	auipc	a0,0xd
    800184c2:	aba50513          	addi	a0,a0,-1350 # 80024f78 <pow10.0+0xd48>
    800184c6:	4e5000ef          	jal	ra,800191aa <debugf>
    // TODO: turn on the MMU when you've written the src/mmu.c functions
    CSR_WRITE("satp", SATP_KERNEL); 
    800184ca:	0000b797          	auipc	a5,0xb
    800184ce:	b3678793          	addi	a5,a5,-1226 # 80023000 <kernel_mmu_table>
    800184d2:	639c                	ld	a5,0(a5)
    800184d4:	00c7d713          	srli	a4,a5,0xc
    800184d8:	57fd                	li	a5,-1
    800184da:	83d1                	srli	a5,a5,0x14
    800184dc:	8f7d                	and	a4,a4,a5
    800184de:	8ffff7b7          	lui	a5,0x8ffff
    800184e2:	1782                	slli	a5,a5,0x20
    800184e4:	8fd9                	or	a5,a5,a4
    800184e6:	18079073          	csrw	satp,a5
    SFENCE_ALL();
    800184ea:	12000073          	sfence.vma
    debugf("MMU enabled\n");
    800184ee:	0000d517          	auipc	a0,0xd
    800184f2:	aaa50513          	addi	a0,a0,-1366 # 80024f98 <pow10.0+0xd68>
    800184f6:	4b5000ef          	jal	ra,800191aa <debugf>
    void *kcalloc(uint64_t elem, uint64_t size);
    void kfree(void *ptr);
    void util_connect_galloc(void *(*malloc)(uint64_t size),
                             void *(*calloc)(uint64_t elem, uint64_t size),
                             void (*free)(void *ptr));
    util_connect_galloc(kmalloc, kcalloc, kfree);
    800184fa:	ffffb617          	auipc	a2,0xffffb
    800184fe:	7e460613          	addi	a2,a2,2020 # 80013cde <kfree>
    80018502:	ffffb597          	auipc	a1,0xffffb
    80018506:	7b458593          	addi	a1,a1,1972 # 80013cb6 <kcalloc>
    8001850a:	ffffb517          	auipc	a0,0xffffb
    8001850e:	78c50513          	addi	a0,a0,1932 # 80013c96 <kmalloc>
    80018512:	1b7050ef          	jal	ra,8001dec8 <util_connect_galloc>
    heap_init();
    80018516:	fecfb0ef          	jal	ra,80013d02 <heap_init>
    debugf("heap_init() done\n");
    8001851a:	0000d517          	auipc	a0,0xd
    8001851e:	a8e50513          	addi	a0,a0,-1394 # 80024fa8 <pow10.0+0xd78>
    80018522:	489000ef          	jal	ra,800191aa <debugf>

    // Call kmalloc() here to ensure it works.
    void *ptr = kmalloc(1024);
    80018526:	40000513          	li	a0,1024
    8001852a:	f6cfb0ef          	jal	ra,80013c96 <kmalloc>
    8001852e:	fca43423          	sd	a0,-56(s0)
    strcpy(ptr, "Hello, world!");
    80018532:	0000d597          	auipc	a1,0xd
    80018536:	a8e58593          	addi	a1,a1,-1394 # 80024fc0 <pow10.0+0xd90>
    8001853a:	fc843503          	ld	a0,-56(s0)
    8001853e:	7fb070ef          	jal	ra,80020538 <strcpy>
    debugf("kmalloc(1024) = %p\n", ptr);
    80018542:	fc843583          	ld	a1,-56(s0)
    80018546:	0000d517          	auipc	a0,0xd
    8001854a:	a8a50513          	addi	a0,a0,-1398 # 80024fd0 <pow10.0+0xda0>
    8001854e:	45d000ef          	jal	ra,800191aa <debugf>
    debugf("kmalloc(1024) = %s\n", ptr);
    80018552:	fc843583          	ld	a1,-56(s0)
    80018556:	0000d517          	auipc	a0,0xd
    8001855a:	a9250513          	addi	a0,a0,-1390 # 80024fe8 <pow10.0+0xdb8>
    8001855e:	44d000ef          	jal	ra,800191aa <debugf>
    kfree(ptr);
    80018562:	fc843503          	ld	a0,-56(s0)
    80018566:	f78fb0ef          	jal	ra,80013cde <kfree>
#endif
#ifdef USE_PCI
    pci_init();
    8001856a:	df9fa0ef          	jal	ra,80013362 <pci_init>
#endif
#ifdef USE_VIRTIO
    uint64_t stvec = trampoline_trap_start;
    8001856e:	0000e797          	auipc	a5,0xe
    80018572:	26b78793          	addi	a5,a5,619 # 800267d9 <trampoline_trap_start>
    80018576:	639c                	ld	a5,0(a5)
    80018578:	fcf43023          	sd	a5,-64(s0)
    // # 552  - stvec
    // # 560  - trap_satp
    // # 568  - trap_stack
    // trampoline_thread_start();

    stvec &= ~0x3;
    8001857c:	fc043783          	ld	a5,-64(s0)
    80018580:	9bf1                	andi	a5,a5,-4
    80018582:	fcf43023          	sd	a5,-64(s0)
    CSR_WRITE("stvec", trampoline_trap_start);
    80018586:	0000e797          	auipc	a5,0xe
    8001858a:	25378793          	addi	a5,a5,595 # 800267d9 <trampoline_trap_start>
    8001858e:	639c                	ld	a5,0(a5)
    80018590:	10579073          	csrw	stvec,a5
    debugf("STVEC: 0x%p, 0x%p\n", stvec, trampoline_trap_start);
    80018594:	0000e797          	auipc	a5,0xe
    80018598:	24578793          	addi	a5,a5,581 # 800267d9 <trampoline_trap_start>
    8001859c:	639c                	ld	a5,0(a5)
    8001859e:	863e                	mv	a2,a5
    800185a0:	fc043583          	ld	a1,-64(s0)
    800185a4:	0000d517          	auipc	a0,0xd
    800185a8:	a5c50513          	addi	a0,a0,-1444 # 80025000 <pow10.0+0xdd0>
    800185ac:	3ff000ef          	jal	ra,800191aa <debugf>

    Trapframe *sscratch = kzalloc(sizeof(Trapframe) * 0x1000);
    800185b0:	002405b7          	lui	a1,0x240
    800185b4:	4505                	li	a0,1
    800185b6:	f00fb0ef          	jal	ra,80013cb6 <kcalloc>
    800185ba:	faa43c23          	sd	a0,-72(s0)
    
    CSR_READ(sscratch->sepc, "sepc");
    800185be:	14102773          	csrr	a4,sepc
    800185c2:	fb843783          	ld	a5,-72(s0)
    800185c6:	20e7b023          	sd	a4,512(a5)
    CSR_READ(sscratch->sstatus, "sstatus");
    800185ca:	10002773          	csrr	a4,sstatus
    800185ce:	fb843783          	ld	a5,-72(s0)
    800185d2:	20e7b423          	sd	a4,520(a5)
    CSR_READ(sscratch->sie, "sie");
    800185d6:	10402773          	csrr	a4,sie
    800185da:	fb843783          	ld	a5,-72(s0)
    800185de:	20e7b823          	sd	a4,528(a5)
    CSR_READ(sscratch->satp, "satp");
    800185e2:	18002773          	csrr	a4,satp
    800185e6:	fb843783          	ld	a5,-72(s0)
    800185ea:	20e7bc23          	sd	a4,536(a5)
    CSR_READ(sscratch->stvec, "stvec");
    800185ee:	10502773          	csrr	a4,stvec
    800185f2:	fb843783          	ld	a5,-72(s0)
    800185f6:	22e7b423          	sd	a4,552(a5)
    CSR_READ(sscratch->trap_satp, "satp");
    800185fa:	18002773          	csrr	a4,satp
    800185fe:	fb843783          	ld	a5,-72(s0)
    80018602:	22e7b823          	sd	a4,560(a5)
    sscratch->trap_stack = (uint64_t)kmalloc(0x4000);
    80018606:	6511                	lui	a0,0x4
    80018608:	e8efb0ef          	jal	ra,80013c96 <kmalloc>
    8001860c:	87aa                	mv	a5,a0
    8001860e:	873e                	mv	a4,a5
    80018610:	fb843783          	ld	a5,-72(s0)
    80018614:	22e7bc23          	sd	a4,568(a5)
    CSR_WRITE("sscratch", sscratch);
    80018618:	fb843783          	ld	a5,-72(s0)
    8001861c:	14079073          	csrw	sscratch,a5

    virtio_init();
    80018620:	3bc020ef          	jal	ra,8001a9dc <virtio_init>
    uint8_t buffer[16] = {0};
    80018624:	fa043423          	sd	zero,-88(s0)
    80018628:	fa043823          	sd	zero,-80(s0)
    debugf("RNG State Before:");
    8001862c:	0000d517          	auipc	a0,0xd
    80018630:	9ec50513          	addi	a0,a0,-1556 # 80025018 <pow10.0+0xde8>
    80018634:	377000ef          	jal	ra,800191aa <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80018638:	fe043423          	sd	zero,-24(s0)
    8001863c:	a02d                	j	80018666 <init_systems+0x2b6>
        debugf(" %d ", buffer[i]);
    8001863e:	fe843783          	ld	a5,-24(s0)
    80018642:	ff040713          	addi	a4,s0,-16
    80018646:	97ba                	add	a5,a5,a4
    80018648:	fb87c783          	lbu	a5,-72(a5)
    8001864c:	2781                	sext.w	a5,a5
    8001864e:	85be                	mv	a1,a5
    80018650:	0000d517          	auipc	a0,0xd
    80018654:	9e050513          	addi	a0,a0,-1568 # 80025030 <pow10.0+0xe00>
    80018658:	353000ef          	jal	ra,800191aa <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    8001865c:	fe843783          	ld	a5,-24(s0)
    80018660:	0785                	addi	a5,a5,1
    80018662:	fef43423          	sd	a5,-24(s0)
    80018666:	fe843703          	ld	a4,-24(s0)
    8001866a:	47bd                	li	a5,15
    8001866c:	fce7f9e3          	bgeu	a5,a4,8001863e <init_systems+0x28e>
    }
    debugf("\n");
    80018670:	0000d517          	auipc	a0,0xd
    80018674:	9c850513          	addi	a0,a0,-1592 # 80025038 <pow10.0+0xe08>
    80018678:	333000ef          	jal	ra,800191aa <debugf>

    debugf("RNG init done; about to fill\n");
    8001867c:	0000d517          	auipc	a0,0xd
    80018680:	9c450513          	addi	a0,a0,-1596 # 80025040 <pow10.0+0xe10>
    80018684:	327000ef          	jal	ra,800191aa <debugf>
    rng_fill(buffer, 16);
    80018688:	fa840793          	addi	a5,s0,-88
    8001868c:	45c1                	li	a1,16
    8001868e:	853e                	mv	a0,a5
    80018690:	fc3f90ef          	jal	ra,80012652 <rng_fill>
    debugf("RNG State After:");
    80018694:	0000d517          	auipc	a0,0xd
    80018698:	9cc50513          	addi	a0,a0,-1588 # 80025060 <pow10.0+0xe30>
    8001869c:	30f000ef          	jal	ra,800191aa <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    800186a0:	fe043023          	sd	zero,-32(s0)
    800186a4:	a02d                	j	800186ce <init_systems+0x31e>
        debugf(" %d ", buffer[i]);
    800186a6:	fe043783          	ld	a5,-32(s0)
    800186aa:	ff040713          	addi	a4,s0,-16
    800186ae:	97ba                	add	a5,a5,a4
    800186b0:	fb87c783          	lbu	a5,-72(a5)
    800186b4:	2781                	sext.w	a5,a5
    800186b6:	85be                	mv	a1,a5
    800186b8:	0000d517          	auipc	a0,0xd
    800186bc:	97850513          	addi	a0,a0,-1672 # 80025030 <pow10.0+0xe00>
    800186c0:	2eb000ef          	jal	ra,800191aa <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    800186c4:	fe043783          	ld	a5,-32(s0)
    800186c8:	0785                	addi	a5,a5,1
    800186ca:	fef43023          	sd	a5,-32(s0)
    800186ce:	fe043703          	ld	a4,-32(s0)
    800186d2:	47bd                	li	a5,15
    800186d4:	fce7f9e3          	bgeu	a5,a4,800186a6 <init_systems+0x2f6>
    }
    
    rng_fill(buffer, 16);
    800186d8:	fa840793          	addi	a5,s0,-88
    800186dc:	45c1                	li	a1,16
    800186de:	853e                	mv	a0,a5
    800186e0:	f73f90ef          	jal	ra,80012652 <rng_fill>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    800186e4:	fc043c23          	sd	zero,-40(s0)
    800186e8:	a02d                	j	80018712 <init_systems+0x362>
        debugf(" %d ", buffer[i]);
    800186ea:	fd843783          	ld	a5,-40(s0)
    800186ee:	ff040713          	addi	a4,s0,-16
    800186f2:	97ba                	add	a5,a5,a4
    800186f4:	fb87c783          	lbu	a5,-72(a5)
    800186f8:	2781                	sext.w	a5,a5
    800186fa:	85be                	mv	a1,a5
    800186fc:	0000d517          	auipc	a0,0xd
    80018700:	93450513          	addi	a0,a0,-1740 # 80025030 <pow10.0+0xe00>
    80018704:	2a7000ef          	jal	ra,800191aa <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80018708:	fd843783          	ld	a5,-40(s0)
    8001870c:	0785                	addi	a5,a5,1
    8001870e:	fcf43c23          	sd	a5,-40(s0)
    80018712:	fd843703          	ld	a4,-40(s0)
    80018716:	47bd                	li	a5,15
    80018718:	fce7f9e3          	bgeu	a5,a4,800186ea <init_systems+0x33a>
            buf[i], buf[i+1], buf[i+2], buf[i+3],
            buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
    }
    */
    // TEST GPU
    debugf("GPU init %s\n", gpu_test() ? "successful" : "failed");
    8001871c:	8d4ff0ef          	jal	ra,800177f0 <gpu_test>
    80018720:	87aa                	mv	a5,a0
    80018722:	c791                	beqz	a5,8001872e <init_systems+0x37e>
    80018724:	0000d797          	auipc	a5,0xd
    80018728:	95478793          	addi	a5,a5,-1708 # 80025078 <pow10.0+0xe48>
    8001872c:	a029                	j	80018736 <init_systems+0x386>
    8001872e:	0000d797          	auipc	a5,0xd
    80018732:	95a78793          	addi	a5,a5,-1702 # 80025088 <pow10.0+0xe58>
    80018736:	85be                	mv	a1,a5
    80018738:	0000d517          	auipc	a0,0xd
    8001873c:	95850513          	addi	a0,a0,-1704 # 80025090 <pow10.0+0xe60>
    80018740:	26b000ef          	jal	ra,800191aa <debugf>
#endif
}
    80018744:	0001                	nop
    80018746:	60e6                	ld	ra,88(sp)
    80018748:	6446                	ld	s0,80(sp)
    8001874a:	6125                	addi	sp,sp,96
    8001874c:	8082                	ret

000000008001874e <main>:
static const char *hart_status_values[] = {"NOT PRESENT", "STOPPED", "STARTING", "RUNNING"};
#ifdef RUN_INTERNAL_CONSOLE
static void console(void);
#endif
void main(unsigned int hart)
{
    8001874e:	715d                	addi	sp,sp,-80
    80018750:	e486                	sd	ra,72(sp)
    80018752:	e0a2                	sd	s0,64(sp)
    80018754:	0880                	addi	s0,sp,80
    80018756:	87aa                	mv	a5,a0
    80018758:	faf42e23          	sw	a5,-68(s0)
    // Initialize the page allocator
    // Allocate and zero the kernel's page table.

    // Kind of neat to see our memory mappings to ensure they make sense.
    logf(LOG_INFO, "[[ MEMORY MAPPINGS ]]\n");
    8001875c:	0000d597          	auipc	a1,0xd
    80018760:	97458593          	addi	a1,a1,-1676 # 800250d0 <pow10.0+0xea0>
    80018764:	4511                	li	a0,4
    80018766:	1e7000ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  [TEXT]  : 0x%08lx -> 0x%08lx\n", sym_start(text), sym_end(text));
    8001876a:	ffff8797          	auipc	a5,0xffff8
    8001876e:	89678793          	addi	a5,a5,-1898 # 80010000 <_memory_start>
    80018772:	00009717          	auipc	a4,0x9
    80018776:	b2a70713          	addi	a4,a4,-1238 # 8002129c <_text_end>
    8001877a:	86ba                	mv	a3,a4
    8001877c:	863e                	mv	a2,a5
    8001877e:	0000d597          	auipc	a1,0xd
    80018782:	96a58593          	addi	a1,a1,-1686 # 800250e8 <pow10.0+0xeb8>
    80018786:	4511                	li	a0,4
    80018788:	1c5000ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  [BSS]   : 0x%08lx -> 0x%08lx\n", sym_start(bss), sym_end(bss));
    8001878c:	0000b797          	auipc	a5,0xb
    80018790:	87478793          	addi	a5,a5,-1932 # 80023000 <kernel_mmu_table>
    80018794:	0000b717          	auipc	a4,0xb
    80018798:	e2c70713          	addi	a4,a4,-468 # 800235c0 <_bss_end>
    8001879c:	86ba                	mv	a3,a4
    8001879e:	863e                	mv	a2,a5
    800187a0:	0000d597          	auipc	a1,0xd
    800187a4:	96858593          	addi	a1,a1,-1688 # 80025108 <pow10.0+0xed8>
    800187a8:	4511                	li	a0,4
    800187aa:	1a3000ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  [RODATA]: 0x%08lx -> 0x%08lx\n", sym_start(rodata), sym_end(rodata));
    800187ae:	0000c797          	auipc	a5,0xc
    800187b2:	85278793          	addi	a5,a5,-1966 # 80024000 <SYSCALLS>
    800187b6:	0000e717          	auipc	a4,0xe
    800187ba:	04a70713          	addi	a4,a4,74 # 80026800 <NUM_SYSCALLS>
    800187be:	86ba                	mv	a3,a4
    800187c0:	863e                	mv	a2,a5
    800187c2:	0000d597          	auipc	a1,0xd
    800187c6:	96658593          	addi	a1,a1,-1690 # 80025128 <pow10.0+0xef8>
    800187ca:	4511                	li	a0,4
    800187cc:	181000ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  [DATA]  : 0x%08lx -> 0x%08lx\n", sym_start(data), sym_end(data));
    800187d0:	0000f797          	auipc	a5,0xf
    800187d4:	83078793          	addi	a5,a5,-2000 # 80027000 <subordinate>
    800187d8:	0000f717          	auipc	a4,0xf
    800187dc:	85870713          	addi	a4,a4,-1960 # 80027030 <_data_end>
    800187e0:	86ba                	mv	a3,a4
    800187e2:	863e                	mv	a2,a5
    800187e4:	0000d597          	auipc	a1,0xd
    800187e8:	96458593          	addi	a1,a1,-1692 # 80025148 <pow10.0+0xf18>
    800187ec:	4511                	li	a0,4
    800187ee:	15f000ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  [STACK] : 0x%08lx -> 0x%08lx\n", sym_start(stack), sym_end(stack));
    800187f2:	00010797          	auipc	a5,0x10
    800187f6:	80e78793          	addi	a5,a5,-2034 # 80028000 <_stack_start>
    800187fa:	00018717          	auipc	a4,0x18
    800187fe:	80670713          	addi	a4,a4,-2042 # 80030000 <_heap_start>
    80018802:	86ba                	mv	a3,a4
    80018804:	863e                	mv	a2,a5
    80018806:	0000d597          	auipc	a1,0xd
    8001880a:	96258593          	addi	a1,a1,-1694 # 80025168 <pow10.0+0xf38>
    8001880e:	4511                	li	a0,4
    80018810:	13d000ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  [HEAP]  : 0x%08lx -> 0x%08lx\n", sym_start(heap), sym_end(heap));
    80018814:	00017797          	auipc	a5,0x17
    80018818:	7ec78793          	addi	a5,a5,2028 # 80030000 <_heap_start>
    8001881c:	07ff7717          	auipc	a4,0x7ff7
    80018820:	7e470713          	addi	a4,a4,2020 # 88010000 <_heap_end>
    80018824:	86ba                	mv	a3,a4
    80018826:	863e                	mv	a2,a5
    80018828:	0000d597          	auipc	a1,0xd
    8001882c:	96058593          	addi	a1,a1,-1696 # 80025188 <pow10.0+0xf58>
    80018830:	4511                	li	a0,4
    80018832:	11b000ef          	jal	ra,8001914c <logf>

    logf(LOG_INFO, "[[ HART MAPPINGS ]]\n");
    80018836:	0000d597          	auipc	a1,0xd
    8001883a:	97258593          	addi	a1,a1,-1678 # 800251a8 <pow10.0+0xf78>
    8001883e:	4511                	li	a0,4
    80018840:	10d000ef          	jal	ra,8001914c <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80018844:	fe042623          	sw	zero,-20(s0)
    80018848:	a8bd                	j	800188c6 <main+0x178>
        if (i == hart) {
    8001884a:	fec42703          	lw	a4,-20(s0)
    8001884e:	fbc42783          	lw	a5,-68(s0)
    80018852:	2701                	sext.w	a4,a4
    80018854:	2781                	sext.w	a5,a5
    80018856:	02f71b63          	bne	a4,a5,8001888c <main+0x13e>
            logf(LOG_INFO, "  [HART#%d]: %s (this HART).\n", i, hart_status_values[sbi_hart_get_status(i)]);
    8001885a:	fec42783          	lw	a5,-20(s0)
    8001885e:	853e                	mv	a0,a5
    80018860:	3a9000ef          	jal	ra,80019408 <sbi_hart_get_status>
    80018864:	87aa                	mv	a5,a0
    80018866:	0000e717          	auipc	a4,0xe
    8001886a:	7aa70713          	addi	a4,a4,1962 # 80027010 <hart_status_values>
    8001886e:	078e                	slli	a5,a5,0x3
    80018870:	97ba                	add	a5,a5,a4
    80018872:	6398                	ld	a4,0(a5)
    80018874:	fec42783          	lw	a5,-20(s0)
    80018878:	86ba                	mv	a3,a4
    8001887a:	863e                	mv	a2,a5
    8001887c:	0000d597          	auipc	a1,0xd
    80018880:	94458593          	addi	a1,a1,-1724 # 800251c0 <pow10.0+0xf90>
    80018884:	4511                	li	a0,4
    80018886:	0c7000ef          	jal	ra,8001914c <logf>
    8001888a:	a80d                	j	800188bc <main+0x16e>
        }
        else {
            logf(LOG_INFO, "  [HART#%d]: %s.\n", i, hart_status_values[sbi_hart_get_status(i)]);
    8001888c:	fec42783          	lw	a5,-20(s0)
    80018890:	853e                	mv	a0,a5
    80018892:	377000ef          	jal	ra,80019408 <sbi_hart_get_status>
    80018896:	87aa                	mv	a5,a0
    80018898:	0000e717          	auipc	a4,0xe
    8001889c:	77870713          	addi	a4,a4,1912 # 80027010 <hart_status_values>
    800188a0:	078e                	slli	a5,a5,0x3
    800188a2:	97ba                	add	a5,a5,a4
    800188a4:	6398                	ld	a4,0(a5)
    800188a6:	fec42783          	lw	a5,-20(s0)
    800188aa:	86ba                	mv	a3,a4
    800188ac:	863e                	mv	a2,a5
    800188ae:	0000d597          	auipc	a1,0xd
    800188b2:	93258593          	addi	a1,a1,-1742 # 800251e0 <pow10.0+0xfb0>
    800188b6:	4511                	li	a0,4
    800188b8:	095000ef          	jal	ra,8001914c <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800188bc:	fec42783          	lw	a5,-20(s0)
    800188c0:	2785                	addiw	a5,a5,1
    800188c2:	fef42623          	sw	a5,-20(s0)
    800188c6:	fec42783          	lw	a5,-20(s0)
    800188ca:	0007871b          	sext.w	a4,a5
    800188ce:	478d                	li	a5,3
    800188d0:	f6e7fde3          	bgeu	a5,a4,8001884a <main+0xfc>
        }
    }

    // Initialize all submodules here, including PCI, VirtIO, Heap, etc.
    // Many will require the MMU, so write those functions first.
    init_systems();
    800188d4:	addff0ef          	jal	ra,800183b0 <init_systems>

    // Now that all submodules are initialized, you need to schedule the init process
    // and the idle processes for each HART.
    logf(LOG_INFO, "Congratulations! You made it to the OS! Going back to sleep.\n");
    800188d8:	0000d597          	auipc	a1,0xd
    800188dc:	92058593          	addi	a1,a1,-1760 # 800251f8 <pow10.0+0xfc8>
    800188e0:	4511                	li	a0,4
    800188e2:	06b000ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, 
    800188e6:	0000d597          	auipc	a1,0xd
    800188ea:	95258593          	addi	a1,a1,-1710 # 80025238 <pow10.0+0x1008>
    800188ee:	4511                	li	a0,4
    800188f0:	05d000ef          	jal	ra,8001914c <logf>
        "The logf function in the OS uses sbi_putchar(), so this means ECALLs from S-mode are "
        "working!\n");
    logf(LOG_INFO, 
    800188f4:	0000d597          	auipc	a1,0xd
    800188f8:	9a458593          	addi	a1,a1,-1628 # 80025298 <pow10.0+0x1068>
    800188fc:	4511                	li	a0,4
    800188fe:	04f000ef          	jal	ra,8001914c <logf>
    // Below is just a little shell that demonstrates the sbi_getchar and
    // how the console works.

    // This is defined above main()
#ifdef RUN_INTERNAL_CONSOLE
    VirtioDevice *block_device = virtio_get_block_device(0);
    80018902:	4501                	li	a0,0
    80018904:	6bd010ef          	jal	ra,8001a7c0 <virtio_get_block_device>
    80018908:	fea43023          	sd	a0,-32(s0)
    // minix3_init(block_device, "/");
    vfs_init();
    8001890c:	464040ef          	jal	ra,8001cd70 <vfs_init>

    File *file = vfs_open("/dev/sda/root.txt", 0, O_RDONLY, VFS_TYPE_FILE);
    80018910:	4685                	li	a3,1
    80018912:	4601                	li	a2,0
    80018914:	4581                	li	a1,0
    80018916:	0000d517          	auipc	a0,0xd
    8001891a:	9e250513          	addi	a0,a0,-1566 # 800252f8 <pow10.0+0x10c8>
    8001891e:	19b040ef          	jal	ra,8001d2b8 <vfs_open>
    80018922:	fca43c23          	sd	a0,-40(s0)
    uint8_t *buffer = kzalloc(2048);
    80018926:	6785                	lui	a5,0x1
    80018928:	80078593          	addi	a1,a5,-2048 # 800 <i+0x7e0>
    8001892c:	4505                	li	a0,1
    8001892e:	b88fb0ef          	jal	ra,80013cb6 <kcalloc>
    80018932:	fca43823          	sd	a0,-48(s0)
    vfs_read(file, buffer, 1024);
    80018936:	40000613          	li	a2,1024
    8001893a:	fd043583          	ld	a1,-48(s0)
    8001893e:	fd843503          	ld	a0,-40(s0)
    80018942:	69f030ef          	jal	ra,8001c7e0 <vfs_read>
    logf(LOG_INFO, "Read from file /dev/sda/root.txt: %1024s\n", buffer);
    80018946:	fd043603          	ld	a2,-48(s0)
    8001894a:	0000d597          	auipc	a1,0xd
    8001894e:	9c658593          	addi	a1,a1,-1594 # 80025310 <pow10.0+0x10e0>
    80018952:	4511                	li	a0,4
    80018954:	7f8000ef          	jal	ra,8001914c <logf>
    // vfs_print_mounted_devices();


    File *file2 = vfs_open("/home/cosc562/subdir1/subdir2/subdir3/subdir4/subdir5/book1.txt", 0, O_RDONLY, VFS_TYPE_FILE);
    80018958:	4685                	li	a3,1
    8001895a:	4601                	li	a2,0
    8001895c:	4581                	li	a1,0
    8001895e:	0000d517          	auipc	a0,0xd
    80018962:	9e250513          	addi	a0,a0,-1566 # 80025340 <pow10.0+0x1110>
    80018966:	153040ef          	jal	ra,8001d2b8 <vfs_open>
    8001896a:	fca43423          	sd	a0,-56(s0)
    vfs_read(file2, buffer, 1024);
    8001896e:	40000613          	li	a2,1024
    80018972:	fd043583          	ld	a1,-48(s0)
    80018976:	fc843503          	ld	a0,-56(s0)
    8001897a:	667030ef          	jal	ra,8001c7e0 <vfs_read>
    logf(LOG_INFO, "Read 1024 bytes from file /home/cosc562/subdir1/subdir2/subdir3/subdir4/subdir5/book1.txt: %1024s\n", buffer);
    8001897e:	fd043603          	ld	a2,-48(s0)
    80018982:	0000d597          	auipc	a1,0xd
    80018986:	9fe58593          	addi	a1,a1,-1538 # 80025380 <pow10.0+0x1150>
    8001898a:	4511                	li	a0,4
    8001898c:	7c0000ef          	jal	ra,8001914c <logf>
    vfs_read(file2, buffer, 1024);
    80018990:	40000613          	li	a2,1024
    80018994:	fd043583          	ld	a1,-48(s0)
    80018998:	fc843503          	ld	a0,-56(s0)
    8001899c:	645030ef          	jal	ra,8001c7e0 <vfs_read>
    logf(LOG_INFO, "Read another 1024 bytes from file /home/cosc562/subdir1/subdir2/subdir3/subdir4/subdir5/book1.txt: %1024s\n", buffer);
    800189a0:	fd043603          	ld	a2,-48(s0)
    800189a4:	0000d597          	auipc	a1,0xd
    800189a8:	a4458593          	addi	a1,a1,-1468 # 800253e8 <pow10.0+0x11b8>
    800189ac:	4511                	li	a0,4
    800189ae:	79e000ef          	jal	ra,8001914c <logf>

    vfs_close(file);
    800189b2:	fd843503          	ld	a0,-40(s0)
    800189b6:	120050ef          	jal	ra,8001dad6 <vfs_close>
    vfs_close(file2);
    800189ba:	fc843503          	ld	a0,-56(s0)
    800189be:	118050ef          	jal	ra,8001dad6 <vfs_close>

    console();
    800189c2:	004000ef          	jal	ra,800189c6 <console>

00000000800189c6 <console>:
#endif
}

#ifdef RUN_INTERNAL_CONSOLE
ATTR_NORET static void console(void)
{
    800189c6:	7179                	addi	sp,sp,-48
    800189c8:	f406                	sd	ra,40(sp)
    800189ca:	f022                	sd	s0,32(sp)
    800189cc:	1800                	addi	s0,sp,48
    const int BUFFER_SIZE = 56;
    800189ce:	03800313          	li	t1,56
    800189d2:	fe642423          	sw	t1,-24(s0)
    int at                = 0;
    800189d6:	fe042623          	sw	zero,-20(s0)
    char input[BUFFER_SIZE];
    800189da:	fe842303          	lw	t1,-24(s0)
    800189de:	137d                	addi	t1,t1,-1
    800189e0:	fe643023          	sd	t1,-32(s0)
    800189e4:	fe842303          	lw	t1,-24(s0)
    800189e8:	881a                	mv	a6,t1
    800189ea:	4881                	li	a7,0
    800189ec:	03d85313          	srli	t1,a6,0x3d
    800189f0:	00389693          	slli	a3,a7,0x3
    800189f4:	00d366b3          	or	a3,t1,a3
    800189f8:	00381613          	slli	a2,a6,0x3
    800189fc:	fe842683          	lw	a3,-24(s0)
    80018a00:	8536                	mv	a0,a3
    80018a02:	4581                	li	a1,0
    80018a04:	03d55693          	srli	a3,a0,0x3d
    80018a08:	00359793          	slli	a5,a1,0x3
    80018a0c:	8fd5                	or	a5,a5,a3
    80018a0e:	00351713          	slli	a4,a0,0x3
    80018a12:	fe842783          	lw	a5,-24(s0)
    80018a16:	07bd                	addi	a5,a5,15
    80018a18:	8391                	srli	a5,a5,0x4
    80018a1a:	0792                	slli	a5,a5,0x4
    80018a1c:	40f10133          	sub	sp,sp,a5
    80018a20:	878a                	mv	a5,sp
    80018a22:	00078793          	mv	a5,a5
    80018a26:	fcf43c23          	sd	a5,-40(s0)
    logf(LOG_TEXT, "> ");
    80018a2a:	0000d597          	auipc	a1,0xd
    80018a2e:	a2e58593          	addi	a1,a1,-1490 # 80025458 <pow10.0+0x1228>
    80018a32:	02000513          	li	a0,32
    80018a36:	716000ef          	jal	ra,8001914c <logf>
    do {
        char c;
        // Recall that sbi_getchar() will return -1, 0xff, 255
        // if the receiver is empty.
        if ((c = sbi_getchar()) != 0xff) {
    80018a3a:	1af000ef          	jal	ra,800193e8 <sbi_getchar>
    80018a3e:	87aa                	mv	a5,a0
    80018a40:	fcf40ba3          	sb	a5,-41(s0)
    80018a44:	fd744783          	lbu	a5,-41(s0)
    80018a48:	0ff7f713          	andi	a4,a5,255
    80018a4c:	0ff00793          	li	a5,255
    80018a50:	22f70963          	beq	a4,a5,80018c82 <console+0x2bc>
            if (c == '\r' || c == '\n') {
    80018a54:	fd744783          	lbu	a5,-41(s0)
    80018a58:	0ff7f713          	andi	a4,a5,255
    80018a5c:	47b5                	li	a5,13
    80018a5e:	00f70963          	beq	a4,a5,80018a70 <console+0xaa>
    80018a62:	fd744783          	lbu	a5,-41(s0)
    80018a66:	0ff7f713          	andi	a4,a5,255
    80018a6a:	47a9                	li	a5,10
    80018a6c:	0ef71163          	bne	a4,a5,80018b4e <console+0x188>
                if (at > 0) {
    80018a70:	fec42783          	lw	a5,-20(s0)
    80018a74:	2781                	sext.w	a5,a5
    80018a76:	0cf05363          	blez	a5,80018b3c <console+0x176>
                    input[at] = '\0';
    80018a7a:	fd843703          	ld	a4,-40(s0)
    80018a7e:	fec42783          	lw	a5,-20(s0)
    80018a82:	97ba                	add	a5,a5,a4
    80018a84:	00078023          	sb	zero,0(a5)
                    if (!strcmp(input, "quit")) {
    80018a88:	0000d597          	auipc	a1,0xd
    80018a8c:	9d858593          	addi	a1,a1,-1576 # 80025460 <pow10.0+0x1230>
    80018a90:	fd843503          	ld	a0,-40(s0)
    80018a94:	768070ef          	jal	ra,800201fc <strcmp>
    80018a98:	87aa                	mv	a5,a0
    80018a9a:	ef81                	bnez	a5,80018ab2 <console+0xec>
                        logf(LOG_TEXT, "\nShutting down...\n\n");
    80018a9c:	0000d597          	auipc	a1,0xd
    80018aa0:	9cc58593          	addi	a1,a1,-1588 # 80025468 <pow10.0+0x1238>
    80018aa4:	02000513          	li	a0,32
    80018aa8:	6a4000ef          	jal	ra,8001914c <logf>
                        sbi_poweroff();
    80018aac:	1ed000ef          	jal	ra,80019498 <sbi_poweroff>
    80018ab0:	a061                	j	80018b38 <console+0x172>
                    }
                    else if (!strcmp(input, "fatal")) {
    80018ab2:	0000d597          	auipc	a1,0xd
    80018ab6:	9ce58593          	addi	a1,a1,-1586 # 80025480 <pow10.0+0x1250>
    80018aba:	fd843503          	ld	a0,-40(s0)
    80018abe:	73e070ef          	jal	ra,800201fc <strcmp>
    80018ac2:	87aa                	mv	a5,a0
    80018ac4:	eb9d                	bnez	a5,80018afa <console+0x134>
                        logf(LOG_TEXT, "\n");
    80018ac6:	0000c597          	auipc	a1,0xc
    80018aca:	57258593          	addi	a1,a1,1394 # 80025038 <pow10.0+0xe08>
    80018ace:	02000513          	li	a0,32
    80018ad2:	67a000ef          	jal	ra,8001914c <logf>
                        fatalf("Testing fatal error @ %lu.\nHanging HART...\n", sbi_rtc_get_time());
    80018ad6:	267000ef          	jal	ra,8001953c <sbi_rtc_get_time>
    80018ada:	87aa                	mv	a5,a0
    80018adc:	85be                	mv	a1,a5
    80018ade:	0000d517          	auipc	a0,0xd
    80018ae2:	9aa50513          	addi	a0,a0,-1622 # 80025488 <pow10.0+0x1258>
    80018ae6:	01f000ef          	jal	ra,80019304 <fatalf>
                        logf(LOG_ERROR, "If I get here, fatal didn't work :'(.\n");
    80018aea:	0000d597          	auipc	a1,0xd
    80018aee:	9ce58593          	addi	a1,a1,-1586 # 800254b8 <pow10.0+0x1288>
    80018af2:	4505                	li	a0,1
    80018af4:	658000ef          	jal	ra,8001914c <logf>
    80018af8:	a081                	j	80018b38 <console+0x172>
                    }
                    else if (!strcmp(input, "heap")) {
    80018afa:	0000d597          	auipc	a1,0xd
    80018afe:	9e658593          	addi	a1,a1,-1562 # 800254e0 <pow10.0+0x12b0>
    80018b02:	fd843503          	ld	a0,-40(s0)
    80018b06:	6f6070ef          	jal	ra,800201fc <strcmp>
    80018b0a:	87aa                	mv	a5,a0
    80018b0c:	ef81                	bnez	a5,80018b24 <console+0x15e>
                        logf(LOG_TEXT, "\n");
    80018b0e:	0000c597          	auipc	a1,0xc
    80018b12:	52a58593          	addi	a1,a1,1322 # 80025038 <pow10.0+0xe08>
    80018b16:	02000513          	li	a0,32
    80018b1a:	632000ef          	jal	ra,8001914c <logf>
                        void heap_print_stats(void);
                        heap_print_stats();
    80018b1e:	91afb0ef          	jal	ra,80013c38 <heap_print_stats>
    80018b22:	a819                	j	80018b38 <console+0x172>
                    }
                    else {
                        logf(LOG_TEXT, "\nUnknown command '%s'\n", input);
    80018b24:	fd843603          	ld	a2,-40(s0)
    80018b28:	0000d597          	auipc	a1,0xd
    80018b2c:	9c058593          	addi	a1,a1,-1600 # 800254e8 <pow10.0+0x12b8>
    80018b30:	02000513          	li	a0,32
    80018b34:	618000ef          	jal	ra,8001914c <logf>
                    }
                    at = 0;
    80018b38:	fe042623          	sw	zero,-20(s0)
                }
                logf(LOG_TEXT, "\n> ");
    80018b3c:	0000d597          	auipc	a1,0xd
    80018b40:	9c458593          	addi	a1,a1,-1596 # 80025500 <pow10.0+0x12d0>
    80018b44:	02000513          	li	a0,32
    80018b48:	604000ef          	jal	ra,8001914c <logf>
    80018b4c:	aa3d                	j	80018c8a <console+0x2c4>
            }
            else if (c == 127) {
    80018b4e:	fd744783          	lbu	a5,-41(s0)
    80018b52:	0ff7f713          	andi	a4,a5,255
    80018b56:	07f00793          	li	a5,127
    80018b5a:	02f71563          	bne	a4,a5,80018b84 <console+0x1be>
                // BACKSPACE
                if (at > 0) {
    80018b5e:	fec42783          	lw	a5,-20(s0)
    80018b62:	2781                	sext.w	a5,a5
    80018b64:	ecf05be3          	blez	a5,80018a3a <console+0x74>
                    logf(LOG_TEXT, "\b \b");
    80018b68:	0000d597          	auipc	a1,0xd
    80018b6c:	9a058593          	addi	a1,a1,-1632 # 80025508 <pow10.0+0x12d8>
    80018b70:	02000513          	li	a0,32
    80018b74:	5d8000ef          	jal	ra,8001914c <logf>
                    at -= 1;
    80018b78:	fec42783          	lw	a5,-20(s0)
    80018b7c:	37fd                	addiw	a5,a5,-1
    80018b7e:	fef42623          	sw	a5,-20(s0)
    80018b82:	bd65                	j	80018a3a <console+0x74>
                }
            }
            else if (c == 0x1B) {
    80018b84:	fd744783          	lbu	a5,-41(s0)
    80018b88:	0ff7f713          	andi	a4,a5,255
    80018b8c:	47ed                	li	a5,27
    80018b8e:	0af71663          	bne	a4,a5,80018c3a <console+0x274>
                // Escape sequence
                char esc1 = sbi_getchar();
    80018b92:	057000ef          	jal	ra,800193e8 <sbi_getchar>
    80018b96:	87aa                	mv	a5,a0
    80018b98:	fcf40b23          	sb	a5,-42(s0)
                char esc2 = sbi_getchar();
    80018b9c:	04d000ef          	jal	ra,800193e8 <sbi_getchar>
    80018ba0:	87aa                	mv	a5,a0
    80018ba2:	fcf40aa3          	sb	a5,-43(s0)
                if (esc1 == 0x5B) {
    80018ba6:	fd644783          	lbu	a5,-42(s0)
    80018baa:	0ff7f713          	andi	a4,a5,255
    80018bae:	05b00793          	li	a5,91
    80018bb2:	0cf71b63          	bne	a4,a5,80018c88 <console+0x2c2>
                    switch (esc2) {
    80018bb6:	fd544783          	lbu	a5,-43(s0)
    80018bba:	2781                	sext.w	a5,a5
    80018bbc:	86be                	mv	a3,a5
    80018bbe:	04400713          	li	a4,68
    80018bc2:	06e68463          	beq	a3,a4,80018c2a <console+0x264>
    80018bc6:	86be                	mv	a3,a5
    80018bc8:	04400713          	li	a4,68
    80018bcc:	e6d747e3          	blt	a4,a3,80018a3a <console+0x74>
    80018bd0:	86be                	mv	a3,a5
    80018bd2:	04300713          	li	a4,67
    80018bd6:	04e68263          	beq	a3,a4,80018c1a <console+0x254>
    80018bda:	86be                	mv	a3,a5
    80018bdc:	04300713          	li	a4,67
    80018be0:	e4d74de3          	blt	a4,a3,80018a3a <console+0x74>
    80018be4:	86be                	mv	a3,a5
    80018be6:	04100713          	li	a4,65
    80018bea:	00e68863          	beq	a3,a4,80018bfa <console+0x234>
    80018bee:	873e                	mv	a4,a5
    80018bf0:	04200793          	li	a5,66
    80018bf4:	00f70b63          	beq	a4,a5,80018c0a <console+0x244>
    80018bf8:	a849                	j	80018c8a <console+0x2c4>
                        case 0x41:
                            logf(LOG_INFO, "UP\n");
    80018bfa:	0000d597          	auipc	a1,0xd
    80018bfe:	91658593          	addi	a1,a1,-1770 # 80025510 <pow10.0+0x12e0>
    80018c02:	4511                	li	a0,4
    80018c04:	548000ef          	jal	ra,8001914c <logf>
                            break;
    80018c08:	a049                	j	80018c8a <console+0x2c4>
                        case 0x42:
                            logf(LOG_INFO, "DOWN\n");
    80018c0a:	0000d597          	auipc	a1,0xd
    80018c0e:	90e58593          	addi	a1,a1,-1778 # 80025518 <pow10.0+0x12e8>
    80018c12:	4511                	li	a0,4
    80018c14:	538000ef          	jal	ra,8001914c <logf>
                            break;
    80018c18:	a88d                	j	80018c8a <console+0x2c4>
                        case 0x43:
                            logf(LOG_INFO, "RIGHT\n");
    80018c1a:	0000d597          	auipc	a1,0xd
    80018c1e:	90658593          	addi	a1,a1,-1786 # 80025520 <pow10.0+0x12f0>
    80018c22:	4511                	li	a0,4
    80018c24:	528000ef          	jal	ra,8001914c <logf>
                            break;
    80018c28:	a08d                	j	80018c8a <console+0x2c4>
                        case 0x44:
                            logf(LOG_INFO, "LEFT\n");
    80018c2a:	0000d597          	auipc	a1,0xd
    80018c2e:	8fe58593          	addi	a1,a1,-1794 # 80025528 <pow10.0+0x12f8>
    80018c32:	4511                	li	a0,4
    80018c34:	518000ef          	jal	ra,8001914c <logf>
                            break;
    80018c38:	a889                	j	80018c8a <console+0x2c4>
                    }
                }
            }
            else {
                if (at < (BUFFER_SIZE - 1)) {
    80018c3a:	fe842783          	lw	a5,-24(s0)
    80018c3e:	37fd                	addiw	a5,a5,-1
    80018c40:	0007871b          	sext.w	a4,a5
    80018c44:	fec42783          	lw	a5,-20(s0)
    80018c48:	2781                	sext.w	a5,a5
    80018c4a:	dee7d8e3          	bge	a5,a4,80018a3a <console+0x74>
                    input[at++] = c;
    80018c4e:	fec42783          	lw	a5,-20(s0)
    80018c52:	0017871b          	addiw	a4,a5,1
    80018c56:	fee42623          	sw	a4,-20(s0)
    80018c5a:	fd843703          	ld	a4,-40(s0)
    80018c5e:	97ba                	add	a5,a5,a4
    80018c60:	fd744703          	lbu	a4,-41(s0)
    80018c64:	00e78023          	sb	a4,0(a5)
                    logf(LOG_TEXT, "%c", c);
    80018c68:	fd744783          	lbu	a5,-41(s0)
    80018c6c:	2781                	sext.w	a5,a5
    80018c6e:	863e                	mv	a2,a5
    80018c70:	0000d597          	auipc	a1,0xd
    80018c74:	8c058593          	addi	a1,a1,-1856 # 80025530 <pow10.0+0x1300>
    80018c78:	02000513          	li	a0,32
    80018c7c:	4d0000ef          	jal	ra,8001914c <logf>
    80018c80:	bb6d                	j	80018a3a <console+0x74>
            }
        }
        else {
            // We can WFI here since interrupts are enabled
            // for the UART.
            WFI();
    80018c82:	10500073          	wfi
    80018c86:	bb55                	j	80018a3a <console+0x74>
                }
    80018c88:	0001                	nop
    do {
    80018c8a:	bb45                	j	80018a3a <console+0x74>

0000000080018c8c <process_new>:
#define STACK_PAGES 2
#define STACK_SIZE  (STACK_PAGES * PAGE_SIZE)
#define STACK_TOP   0xfffffffc0ffee000UL

struct process *process_new(process_mode mode)
{
    80018c8c:	715d                	addi	sp,sp,-80
    80018c8e:	e486                	sd	ra,72(sp)
    80018c90:	e0a2                	sd	s0,64(sp)
    80018c92:	0880                	addi	s0,sp,80
    80018c94:	87aa                	mv	a5,a0
    80018c96:	faf42e23          	sw	a5,-68(s0)
    struct process *p       = (struct process *)kzalloc(sizeof(*p));
    80018c9a:	29000593          	li	a1,656
    80018c9e:	4505                	li	a0,1
    80018ca0:	816fb0ef          	jal	ra,80013cb6 <kcalloc>
    80018ca4:	fea43023          	sd	a0,-32(s0)

    p->hart                 = -1U;
    80018ca8:	fe043783          	ld	a5,-32(s0)
    80018cac:	577d                	li	a4,-1
    80018cae:	c3d8                	sw	a4,4(a5)
    p->ptable               = mmu_table_create();
    80018cb0:	421000ef          	jal	ra,800198d0 <mmu_table_create>
    80018cb4:	872a                	mv	a4,a0
    80018cb6:	fe043783          	ld	a5,-32(s0)
    80018cba:	26e7bc23          	sd	a4,632(a5)
    p->state                = PS_WAITING;
    80018cbe:	fe043783          	ld	a5,-32(s0)
    80018cc2:	4705                	li	a4,1
    80018cc4:	c7d8                	sw	a4,12(a5)
    // p->pid               = fill_in_with_unique_pid

    // Set the trap frame and create all necessary structures.
    // p->frame.sepc = filled_in_by_ELF_loader
    p->frame.sstatus        = SSTATUS_SPP_BOOL(mode) | SSTATUS_FS_INITIAL | SSTATUS_SPIE;
    80018cc6:	fbc42783          	lw	a5,-68(s0)
    80018cca:	2781                	sext.w	a5,a5
    80018ccc:	c789                	beqz	a5,80018cd6 <process_new+0x4a>
    80018cce:	6789                	lui	a5,0x2
    80018cd0:	12078793          	addi	a5,a5,288 # 2120 <i+0x2100>
    80018cd4:	a021                	j	80018cdc <process_new+0x50>
    80018cd6:	6789                	lui	a5,0x2
    80018cd8:	02078793          	addi	a5,a5,32 # 2020 <i+0x2000>
    80018cdc:	fe043703          	ld	a4,-32(s0)
    80018ce0:	24f73023          	sd	a5,576(a4)
    p->frame.sie            = SIE_SEIE | SIE_SSIE | SIE_STIE;
    80018ce4:	fe043783          	ld	a5,-32(s0)
    80018ce8:	22200713          	li	a4,546
    80018cec:	24e7b423          	sd	a4,584(a5)
    p->frame.satp           = SATP(p->ptable, p->pid);
    80018cf0:	fe043783          	ld	a5,-32(s0)
    80018cf4:	2787b783          	ld	a5,632(a5)
    80018cf8:	00c7d713          	srli	a4,a5,0xc
    80018cfc:	57fd                	li	a5,-1
    80018cfe:	83d1                	srli	a5,a5,0x14
    80018d00:	8f7d                	and	a4,a4,a5
    80018d02:	fe043783          	ld	a5,-32(s0)
    80018d06:	0007d783          	lhu	a5,0(a5)
    80018d0a:	17b2                	slli	a5,a5,0x2c
    80018d0c:	8f5d                	or	a4,a4,a5
    80018d0e:	57fd                	li	a5,-1
    80018d10:	17fe                	slli	a5,a5,0x3f
    80018d12:	8f5d                	or	a4,a4,a5
    80018d14:	fe043783          	ld	a5,-32(s0)
    80018d18:	24e7b823          	sd	a4,592(a5)
    p->frame.sscratch       = (unsigned long)&p->frame;
    80018d1c:	fe043783          	ld	a5,-32(s0)
    80018d20:	03878793          	addi	a5,a5,56
    80018d24:	873e                	mv	a4,a5
    80018d26:	fe043783          	ld	a5,-32(s0)
    80018d2a:	24e7bc23          	sd	a4,600(a5)
    p->frame.stvec          = trampoline_trap_start;
    80018d2e:	0000e797          	auipc	a5,0xe
    80018d32:	aab78793          	addi	a5,a5,-1365 # 800267d9 <trampoline_trap_start>
    80018d36:	6398                	ld	a4,0(a5)
    80018d38:	fe043783          	ld	a5,-32(s0)
    80018d3c:	26e7b023          	sd	a4,608(a5)
    p->frame.trap_satp      = SATP_KERNEL;
    80018d40:	0000a797          	auipc	a5,0xa
    80018d44:	2c078793          	addi	a5,a5,704 # 80023000 <kernel_mmu_table>
    80018d48:	639c                	ld	a5,0(a5)
    80018d4a:	00c7d713          	srli	a4,a5,0xc
    80018d4e:	57fd                	li	a5,-1
    80018d50:	83d1                	srli	a5,a5,0x14
    80018d52:	8f7d                	and	a4,a4,a5
    80018d54:	8ffff7b7          	lui	a5,0x8ffff
    80018d58:	1782                	slli	a5,a5,0x20
    80018d5a:	8f5d                	or	a4,a4,a5
    80018d5c:	fe043783          	ld	a5,-32(s0)
    80018d60:	26e7b423          	sd	a4,616(a5) # ffffffff8ffff268 <_heap_end+0xffffffff07fef268>
    // p->frame.trap_stack = filled_in_by_SCHEDULER

    p->fds = vector_new_with_capacity(5);
    80018d64:	4515                	li	a0,5
    80018d66:	2cb070ef          	jal	ra,80020830 <vector_new_with_capacity>
    80018d6a:	872a                	mv	a4,a0
    80018d6c:	fe043783          	ld	a5,-32(s0)
    80018d70:	28e7b423          	sd	a4,648(a5)
    p->pages = list_new();
    80018d74:	1c2050ef          	jal	ra,8001df36 <list_new>
    80018d78:	872a                	mv	a4,a0
    80018d7a:	fe043783          	ld	a5,-32(s0)
    80018d7e:	28e7b023          	sd	a4,640(a5)

    // We need to keep track of the stack itself in the kernel, so we can free it
    // later, but the user process will interact with the stack via the SP register.
    p->frame.xregs[XREG_SP] = STACK_TOP + STACK_SIZE;
    80018d82:	fe043783          	ld	a5,-32(s0)
    80018d86:	c0fff737          	lui	a4,0xc0fff
    80018d8a:	0712                	slli	a4,a4,0x4
    80018d8c:	e7b8                	sd	a4,72(a5)
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    80018d8e:	fe043423          	sd	zero,-24(s0)
    80018d92:	a085                	j	80018df2 <process_new+0x166>
        void *stack = page_zalloc();
    80018d94:	4505                	li	a0,1
    80018d96:	52d020ef          	jal	ra,8001bac2 <page_znalloc>
    80018d9a:	fca43423          	sd	a0,-56(s0)
        list_add_ptr(p->pages, stack);
    80018d9e:	fe043783          	ld	a5,-32(s0)
    80018da2:	2807b783          	ld	a5,640(a5)
    80018da6:	fc843703          	ld	a4,-56(s0)
    80018daa:	85ba                	mv	a1,a4
    80018dac:	853e                	mv	a0,a5
    80018dae:	1b8050ef          	jal	ra,8001df66 <list_add>
        mmu_map(p->ptable, STACK_TOP + PAGE_SIZE * i, (unsigned long)stack,
    80018db2:	fe043783          	ld	a5,-32(s0)
    80018db6:	2787b503          	ld	a0,632(a5)
    80018dba:	fe843783          	ld	a5,-24(s0)
    80018dbe:	00c79713          	slli	a4,a5,0xc
    80018dc2:	ffe087b7          	lui	a5,0xffe08
    80018dc6:	17dd                	addi	a5,a5,-9
    80018dc8:	07b6                	slli	a5,a5,0xd
    80018dca:	00f705b3          	add	a1,a4,a5
    80018dce:	fc843603          	ld	a2,-56(s0)
    80018dd2:	fbc42783          	lw	a5,-68(s0)
    80018dd6:	2781                	sext.w	a5,a5
    80018dd8:	e399                	bnez	a5,80018dde <process_new+0x152>
    80018dda:	47c1                	li	a5,16
    80018ddc:	a011                	j	80018de0 <process_new+0x154>
    80018dde:	4799                	li	a5,6
    80018de0:	873e                	mv	a4,a5
    80018de2:	4681                	li	a3,0
    80018de4:	347000ef          	jal	ra,8001992a <mmu_map>
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    80018de8:	fe843783          	ld	a5,-24(s0)
    80018dec:	0785                	addi	a5,a5,1
    80018dee:	fef43423          	sd	a5,-24(s0)
    80018df2:	fe843703          	ld	a4,-24(s0)
    80018df6:	4785                	li	a5,1
    80018df8:	f8e7fee3          	bgeu	a5,a4,80018d94 <process_new+0x108>
    }

    // We need to map certain kernel portions into the user's page table. Notice
    // that the PB_USER is NOT set, but it needs to be there because we need to execute
    // the trap/start instructions while using the user's page table until we change SATP.
    unsigned long trans_trampoline_start = mmu_translate(kernel_mmu_table, trampoline_thread_start);
    80018dfc:	0000a797          	auipc	a5,0xa
    80018e00:	20478793          	addi	a5,a5,516 # 80023000 <kernel_mmu_table>
    80018e04:	6398                	ld	a4,0(a5)
    80018e06:	0000e797          	auipc	a5,0xe
    80018e0a:	9bb78793          	addi	a5,a5,-1605 # 800267c1 <trampoline_thread_start>
    80018e0e:	639c                	ld	a5,0(a5)
    80018e10:	85be                	mv	a1,a5
    80018e12:	853a                	mv	a0,a4
    80018e14:	541000ef          	jal	ra,80019b54 <mmu_translate>
    80018e18:	fca43c23          	sd	a0,-40(s0)
    unsigned long trans_trampoline_trap  = mmu_translate(kernel_mmu_table, trampoline_trap_start);
    80018e1c:	0000a797          	auipc	a5,0xa
    80018e20:	1e478793          	addi	a5,a5,484 # 80023000 <kernel_mmu_table>
    80018e24:	6398                	ld	a4,0(a5)
    80018e26:	0000e797          	auipc	a5,0xe
    80018e2a:	9b378793          	addi	a5,a5,-1613 # 800267d9 <trampoline_trap_start>
    80018e2e:	639c                	ld	a5,0(a5)
    80018e30:	85be                	mv	a1,a5
    80018e32:	853a                	mv	a0,a4
    80018e34:	521000ef          	jal	ra,80019b54 <mmu_translate>
    80018e38:	fca43823          	sd	a0,-48(s0)
    mmu_map(p->ptable, trampoline_thread_start, trans_trampoline_start, MMU_LEVEL_4K,
    80018e3c:	fe043783          	ld	a5,-32(s0)
    80018e40:	2787b503          	ld	a0,632(a5)
    80018e44:	0000e797          	auipc	a5,0xe
    80018e48:	97d78793          	addi	a5,a5,-1667 # 800267c1 <trampoline_thread_start>
    80018e4c:	639c                	ld	a5,0(a5)
    80018e4e:	4729                	li	a4,10
    80018e50:	4681                	li	a3,0
    80018e52:	fd843603          	ld	a2,-40(s0)
    80018e56:	85be                	mv	a1,a5
    80018e58:	2d3000ef          	jal	ra,8001992a <mmu_map>
            PB_READ | PB_EXECUTE);
    mmu_map(p->ptable, trampoline_trap_start, trans_trampoline_trap, MMU_LEVEL_4K,
    80018e5c:	fe043783          	ld	a5,-32(s0)
    80018e60:	2787b503          	ld	a0,632(a5)
    80018e64:	0000e797          	auipc	a5,0xe
    80018e68:	97578793          	addi	a5,a5,-1675 # 800267d9 <trampoline_trap_start>
    80018e6c:	639c                	ld	a5,0(a5)
    80018e6e:	4729                	li	a4,10
    80018e70:	4681                	li	a3,0
    80018e72:	fd043603          	ld	a2,-48(s0)
    80018e76:	85be                	mv	a1,a5
    80018e78:	2b3000ef          	jal	ra,8001992a <mmu_map>
            PB_READ | PB_EXECUTE);

    SFENCE_ASID(p->pid);
    80018e7c:	fe043783          	ld	a5,-32(s0)
    80018e80:	0007d783          	lhu	a5,0(a5)
    80018e84:	12f00073          	sfence.vma	zero,a5

    return p;
    80018e88:	fe043783          	ld	a5,-32(s0)
}
    80018e8c:	853e                	mv	a0,a5
    80018e8e:	60a6                	ld	ra,72(sp)
    80018e90:	6406                	ld	s0,64(sp)
    80018e92:	6161                	addi	sp,sp,80
    80018e94:	8082                	ret

0000000080018e96 <process_free>:

int process_free(struct process *p)
{
    80018e96:	7179                	addi	sp,sp,-48
    80018e98:	f406                	sd	ra,40(sp)
    80018e9a:	f022                	sd	s0,32(sp)
    80018e9c:	1800                	addi	s0,sp,48
    80018e9e:	fca43c23          	sd	a0,-40(s0)
    struct ListElem *e;
    unsigned int i;

    if (!p || !ON_HART_NONE(p)) {
    80018ea2:	fd843783          	ld	a5,-40(s0)
    80018ea6:	cb81                	beqz	a5,80018eb6 <process_free+0x20>
    80018ea8:	fd843783          	ld	a5,-40(s0)
    80018eac:	43dc                	lw	a5,4(a5)
    80018eae:	873e                	mv	a4,a5
    80018eb0:	57fd                	li	a5,-1
    80018eb2:	00f70463          	beq	a4,a5,80018eba <process_free+0x24>
        // Process is invalid or running somewhere, or this is stale.
        return -1;
    80018eb6:	57fd                	li	a5,-1
    80018eb8:	a8d1                	j	80018f8c <process_free+0xf6>
    }

    // Free all resources allocated to the process.

    if (p->ptable) {
    80018eba:	fd843783          	ld	a5,-40(s0)
    80018ebe:	2787b783          	ld	a5,632(a5)
    80018ec2:	cf91                	beqz	a5,80018ede <process_free+0x48>
        mmu_free(p->ptable);
    80018ec4:	fd843783          	ld	a5,-40(s0)
    80018ec8:	2787b783          	ld	a5,632(a5)
    80018ecc:	853e                	mv	a0,a5
    80018ece:	401000ef          	jal	ra,80019ace <mmu_free>
        SFENCE_ASID(p->pid);
    80018ed2:	fd843783          	ld	a5,-40(s0)
    80018ed6:	0007d783          	lhu	a5,0(a5)
    80018eda:	12f00073          	sfence.vma	zero,a5
    }

    if (p->pages) {
    80018ede:	fd843783          	ld	a5,-40(s0)
    80018ee2:	2807b783          	ld	a5,640(a5)
    80018ee6:	cbb9                	beqz	a5,80018f3c <process_free+0xa6>
        list_for_each(p->pages, e) {
    80018ee8:	fd843783          	ld	a5,-40(s0)
    80018eec:	2807b783          	ld	a5,640(a5)
    80018ef0:	853e                	mv	a0,a5
    80018ef2:	494050ef          	jal	ra,8001e386 <list_elem_start_ascending>
    80018ef6:	fea43423          	sd	a0,-24(s0)
    80018efa:	a839                	j	80018f18 <process_free+0x82>
            page_free(list_elem_value_ptr(e));
    80018efc:	fe843503          	ld	a0,-24(s0)
    80018f00:	4e6050ef          	jal	ra,8001e3e6 <list_elem_value>
    80018f04:	87aa                	mv	a5,a0
    80018f06:	853e                	mv	a0,a5
    80018f08:	457020ef          	jal	ra,8001bb5e <page_free>
        list_for_each(p->pages, e) {
    80018f0c:	fe843503          	ld	a0,-24(s0)
    80018f10:	4be050ef          	jal	ra,8001e3ce <list_elem_prev>
    80018f14:	fea43423          	sd	a0,-24(s0)
    80018f18:	fd843783          	ld	a5,-40(s0)
    80018f1c:	2807b783          	ld	a5,640(a5)
    80018f20:	fe843583          	ld	a1,-24(s0)
    80018f24:	853e                	mv	a0,a5
    80018f26:	3d2050ef          	jal	ra,8001e2f8 <list_elem_valid>
    80018f2a:	87aa                	mv	a5,a0
    80018f2c:	fbe1                	bnez	a5,80018efc <process_free+0x66>
        }
        list_free(p->pages);
    80018f2e:	fd843783          	ld	a5,-40(s0)
    80018f32:	2807b783          	ld	a5,640(a5)
    80018f36:	853e                	mv	a0,a5
    80018f38:	368050ef          	jal	ra,8001e2a0 <list_free>
    }

    if (p->fds) {
    80018f3c:	fd843783          	ld	a5,-40(s0)
    80018f40:	2887b783          	ld	a5,648(a5)
    80018f44:	cf9d                	beqz	a5,80018f82 <process_free+0xec>
        for (i = 0;i < vector_size(p->fds);i += 1) {
    80018f46:	fe042223          	sw	zero,-28(s0)
    80018f4a:	a031                	j	80018f56 <process_free+0xc0>
    80018f4c:	fe442783          	lw	a5,-28(s0)
    80018f50:	2785                	addiw	a5,a5,1
    80018f52:	fef42223          	sw	a5,-28(s0)
    80018f56:	fd843783          	ld	a5,-40(s0)
    80018f5a:	2887b783          	ld	a5,648(a5)
    80018f5e:	853e                	mv	a0,a5
    80018f60:	1be080ef          	jal	ra,8002111e <vector_size>
    80018f64:	87aa                	mv	a5,a0
    80018f66:	0007871b          	sext.w	a4,a5
    80018f6a:	fe442783          	lw	a5,-28(s0)
    80018f6e:	2781                	sext.w	a5,a5
    80018f70:	fce7eee3          	bltu	a5,a4,80018f4c <process_free+0xb6>
            // Clean up any file descriptor stuff here.
        }
        vector_free(p->fds);
    80018f74:	fd843783          	ld	a5,-40(s0)
    80018f78:	2887b783          	ld	a5,648(a5)
    80018f7c:	853e                	mv	a0,a5
    80018f7e:	1d0080ef          	jal	ra,8002114e <vector_free>
    }
    

    kfree(p);
    80018f82:	fd843503          	ld	a0,-40(s0)
    80018f86:	d59fa0ef          	jal	ra,80013cde <kfree>

    return 0;
    80018f8a:	4781                	li	a5,0
}
    80018f8c:	853e                	mv	a0,a5
    80018f8e:	70a2                	ld	ra,40(sp)
    80018f90:	7402                	ld	s0,32(sp)
    80018f92:	6145                	addi	sp,sp,48
    80018f94:	8082                	ret

0000000080018f96 <process_run>:

bool process_run(struct process *p, unsigned int hart)
{
    80018f96:	7179                	addi	sp,sp,-48
    80018f98:	f406                	sd	ra,40(sp)
    80018f9a:	f022                	sd	s0,32(sp)
    80018f9c:	1800                	addi	s0,sp,48
    80018f9e:	fca43c23          	sd	a0,-40(s0)
    80018fa2:	87ae                	mv	a5,a1
    80018fa4:	fcf42a23          	sw	a5,-44(s0)
    void process_asm_run(void *frame_addr);
    unsigned int me = sbi_whoami();
    80018fa8:	5b4000ef          	jal	ra,8001955c <sbi_whoami>
    80018fac:	87aa                	mv	a5,a0
    80018fae:	fef42623          	sw	a5,-20(s0)

    if (me == hart) {
    80018fb2:	fec42703          	lw	a4,-20(s0)
    80018fb6:	fd442783          	lw	a5,-44(s0)
    80018fba:	2701                	sext.w	a4,a4
    80018fbc:	2781                	sext.w	a5,a5
    80018fbe:	00f71b63          	bne	a4,a5,80018fd4 <process_run+0x3e>
        process_asm_run(&p->frame);
    80018fc2:	fd843783          	ld	a5,-40(s0)
    80018fc6:	03878793          	addi	a5,a5,56
    80018fca:	853e                	mv	a0,a5
    80018fcc:	629040ef          	jal	ra,8001ddf4 <process_asm_run>
        // process_asm_run should not return, but if it does
        // something went wrong.
        return false;
    80018fd0:	4781                	li	a5,0
    80018fd2:	a815                	j	80019006 <process_run+0x70>
    }

    return sbi_hart_start(hart, trampoline_thread_start, (unsigned long)&p->frame, p->frame.satp);
    80018fd4:	0000d797          	auipc	a5,0xd
    80018fd8:	7ed78793          	addi	a5,a5,2029 # 800267c1 <trampoline_thread_start>
    80018fdc:	6398                	ld	a4,0(a5)
    80018fde:	fd843783          	ld	a5,-40(s0)
    80018fe2:	03878793          	addi	a5,a5,56
    80018fe6:	863e                	mv	a2,a5
    80018fe8:	fd843783          	ld	a5,-40(s0)
    80018fec:	2507b683          	ld	a3,592(a5)
    80018ff0:	fd442783          	lw	a5,-44(s0)
    80018ff4:	85ba                	mv	a1,a4
    80018ff6:	853e                	mv	a0,a5
    80018ff8:	43c000ef          	jal	ra,80019434 <sbi_hart_start>
    80018ffc:	87aa                	mv	a5,a0
    80018ffe:	00f037b3          	snez	a5,a5
    80019002:	0ff7f793          	andi	a5,a5,255
}
    80019006:	853e                	mv	a0,a5
    80019008:	70a2                	ld	ra,40(sp)
    8001900a:	7402                	ld	s0,32(sp)
    8001900c:	6145                	addi	sp,sp,48
    8001900e:	8082                	ret

0000000080019010 <lgprefix>:

static bool last_was_newline = true;

static int k_log_level = 0xFFF;

static const char *lgprefix(log_type lt) {
    80019010:	1101                	addi	sp,sp,-32
    80019012:	ec22                	sd	s0,24(sp)
    80019014:	1000                	addi	s0,sp,32
    80019016:	87aa                	mv	a5,a0
    80019018:	fef42623          	sw	a5,-20(s0)
    8001901c:	fec42783          	lw	a5,-20(s0)
    80019020:	0007871b          	sext.w	a4,a5
    80019024:	47c1                	li	a5,16
    80019026:	04e7ed63          	bltu	a5,a4,80019080 <lgprefix+0x70>
    8001902a:	fec46783          	lwu	a5,-20(s0)
    8001902e:	00279713          	slli	a4,a5,0x2
    80019032:	0000c797          	auipc	a5,0xc
    80019036:	55a78793          	addi	a5,a5,1370 # 8002558c <pow10.0+0x135c>
    8001903a:	97ba                	add	a5,a5,a4
    8001903c:	439c                	lw	a5,0(a5)
    8001903e:	0007871b          	sext.w	a4,a5
    80019042:	0000c797          	auipc	a5,0xc
    80019046:	54a78793          	addi	a5,a5,1354 # 8002558c <pow10.0+0x135c>
    8001904a:	97ba                	add	a5,a5,a4
    8001904c:	8782                	jr	a5
    switch (lt) {
        case LOG_DEBUG:
            return "[DEBUG]: ";
    8001904e:	0000c797          	auipc	a5,0xc
    80019052:	4ea78793          	addi	a5,a5,1258 # 80025538 <pow10.0+0x1308>
    80019056:	a80d                	j	80019088 <lgprefix+0x78>
        case LOG_INFO:
            return "[INFO]: ";
    80019058:	0000c797          	auipc	a5,0xc
    8001905c:	4f078793          	addi	a5,a5,1264 # 80025548 <pow10.0+0x1318>
    80019060:	a025                	j	80019088 <lgprefix+0x78>
        case LOG_WARN:
            return "[WARN]: ";
    80019062:	0000c797          	auipc	a5,0xc
    80019066:	4f678793          	addi	a5,a5,1270 # 80025558 <pow10.0+0x1328>
    8001906a:	a839                	j	80019088 <lgprefix+0x78>
        case LOG_ERROR:
            return "[ERROR]: ";
    8001906c:	0000c797          	auipc	a5,0xc
    80019070:	4fc78793          	addi	a5,a5,1276 # 80025568 <pow10.0+0x1338>
    80019074:	a811                	j	80019088 <lgprefix+0x78>
        case LOG_FATAL:
            return "[FATAL]: ";
    80019076:	0000c797          	auipc	a5,0xc
    8001907a:	50278793          	addi	a5,a5,1282 # 80025578 <pow10.0+0x1348>
    8001907e:	a029                	j	80019088 <lgprefix+0x78>
        default:
            return "";
    80019080:	0000c797          	auipc	a5,0xc
    80019084:	50878793          	addi	a5,a5,1288 # 80025588 <pow10.0+0x1358>
    }
}
    80019088:	853e                	mv	a0,a5
    8001908a:	6462                	ld	s0,24(sp)
    8001908c:	6105                	addi	sp,sp,32
    8001908e:	8082                	ret

0000000080019090 <vlogf>:

static int vlogf(log_type lt, const char *fmt, va_list args)
{
    80019090:	7139                	addi	sp,sp,-64
    80019092:	fc06                	sd	ra,56(sp)
    80019094:	f822                	sd	s0,48(sp)
    80019096:	0080                	addi	s0,sp,64
    80019098:	87aa                	mv	a5,a0
    8001909a:	fcb43823          	sd	a1,-48(s0)
    8001909e:	fcc43423          	sd	a2,-56(s0)
    800190a2:	fcf42e23          	sw	a5,-36(s0)
    if (!(lt & k_log_level)) {
    800190a6:	0000e797          	auipc	a5,0xe
    800190aa:	f6278793          	addi	a5,a5,-158 # 80027008 <k_log_level>
    800190ae:	439c                	lw	a5,0(a5)
    800190b0:	0007871b          	sext.w	a4,a5
    800190b4:	fdc42783          	lw	a5,-36(s0)
    800190b8:	8ff9                	and	a5,a5,a4
    800190ba:	2781                	sext.w	a5,a5
    800190bc:	e399                	bnez	a5,800190c2 <vlogf+0x32>
        return 0;
    800190be:	4781                	li	a5,0
    800190c0:	a049                	j	80019142 <vlogf+0xb2>
    }
    int printf(const char *fmt, ...);
    if (last_was_newline) {
    800190c2:	0000e797          	auipc	a5,0xe
    800190c6:	f4278793          	addi	a5,a5,-190 # 80027004 <last_was_newline>
    800190ca:	0007c783          	lbu	a5,0(a5)
    800190ce:	cf91                	beqz	a5,800190ea <vlogf+0x5a>
        printf("%s", lgprefix(lt));
    800190d0:	fdc42783          	lw	a5,-36(s0)
    800190d4:	853e                	mv	a0,a5
    800190d6:	f3bff0ef          	jal	ra,80019010 <lgprefix>
    800190da:	87aa                	mv	a5,a0
    800190dc:	85be                	mv	a1,a5
    800190de:	0000c517          	auipc	a0,0xc
    800190e2:	4f250513          	addi	a0,a0,1266 # 800255d0 <pow10.0+0x13a0>
    800190e6:	960f90ef          	jal	ra,80012246 <printf>
    }
    for (const char *p = fmt; *p != '\0'; p++) {
    800190ea:	fd043783          	ld	a5,-48(s0)
    800190ee:	fef43423          	sd	a5,-24(s0)
    800190f2:	a825                	j	8001912a <vlogf+0x9a>
        if (*p == '\n') {
    800190f4:	fe843783          	ld	a5,-24(s0)
    800190f8:	0007c783          	lbu	a5,0(a5)
    800190fc:	873e                	mv	a4,a5
    800190fe:	47a9                	li	a5,10
    80019100:	00f71a63          	bne	a4,a5,80019114 <vlogf+0x84>
            last_was_newline = true;
    80019104:	0000e797          	auipc	a5,0xe
    80019108:	f0078793          	addi	a5,a5,-256 # 80027004 <last_was_newline>
    8001910c:	4705                	li	a4,1
    8001910e:	00e78023          	sb	a4,0(a5)
    80019112:	a039                	j	80019120 <vlogf+0x90>
        } else {
            last_was_newline = false;
    80019114:	0000e797          	auipc	a5,0xe
    80019118:	ef078793          	addi	a5,a5,-272 # 80027004 <last_was_newline>
    8001911c:	00078023          	sb	zero,0(a5)
    for (const char *p = fmt; *p != '\0'; p++) {
    80019120:	fe843783          	ld	a5,-24(s0)
    80019124:	0785                	addi	a5,a5,1
    80019126:	fef43423          	sd	a5,-24(s0)
    8001912a:	fe843783          	ld	a5,-24(s0)
    8001912e:	0007c783          	lbu	a5,0(a5)
    80019132:	f3e9                	bnez	a5,800190f4 <vlogf+0x64>
        }
    }
    int vprintf_(const char *format, va_list va);
    return vprintf_(fmt, args);
    80019134:	fc843583          	ld	a1,-56(s0)
    80019138:	fd043503          	ld	a0,-48(s0)
    8001913c:	a38f90ef          	jal	ra,80012374 <vprintf_>
    80019140:	87aa                	mv	a5,a0
}
    80019142:	853e                	mv	a0,a5
    80019144:	70e2                	ld	ra,56(sp)
    80019146:	7442                	ld	s0,48(sp)
    80019148:	6121                	addi	sp,sp,64
    8001914a:	8082                	ret

000000008001914c <logf>:

int logf(log_type lt, const char *fmt, ...)
{
    8001914c:	7159                	addi	sp,sp,-112
    8001914e:	fc06                	sd	ra,56(sp)
    80019150:	f822                	sd	s0,48(sp)
    80019152:	0080                	addi	s0,sp,64
    80019154:	fcb43823          	sd	a1,-48(s0)
    80019158:	e010                	sd	a2,0(s0)
    8001915a:	e414                	sd	a3,8(s0)
    8001915c:	e818                	sd	a4,16(s0)
    8001915e:	ec1c                	sd	a5,24(s0)
    80019160:	03043023          	sd	a6,32(s0)
    80019164:	03143423          	sd	a7,40(s0)
    80019168:	87aa                	mv	a5,a0
    8001916a:	fcf42e23          	sw	a5,-36(s0)
    va_list va;
    va_start(va, fmt);
    8001916e:	03040793          	addi	a5,s0,48
    80019172:	fcf43423          	sd	a5,-56(s0)
    80019176:	fc843783          	ld	a5,-56(s0)
    8001917a:	fd078793          	addi	a5,a5,-48
    8001917e:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(lt, fmt, va);
    80019182:	fe043703          	ld	a4,-32(s0)
    80019186:	fdc42783          	lw	a5,-36(s0)
    8001918a:	863a                	mv	a2,a4
    8001918c:	fd043583          	ld	a1,-48(s0)
    80019190:	853e                	mv	a0,a5
    80019192:	effff0ef          	jal	ra,80019090 <vlogf>
    80019196:	87aa                	mv	a5,a0
    80019198:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001919c:	fec42783          	lw	a5,-20(s0)
}
    800191a0:	853e                	mv	a0,a5
    800191a2:	70e2                	ld	ra,56(sp)
    800191a4:	7442                	ld	s0,48(sp)
    800191a6:	6165                	addi	sp,sp,112
    800191a8:	8082                	ret

00000000800191aa <debugf>:

int debugf(const char *fmt, ...)
{
    800191aa:	7159                	addi	sp,sp,-112
    800191ac:	f406                	sd	ra,40(sp)
    800191ae:	f022                	sd	s0,32(sp)
    800191b0:	1800                	addi	s0,sp,48
    800191b2:	fca43c23          	sd	a0,-40(s0)
    800191b6:	e40c                	sd	a1,8(s0)
    800191b8:	e810                	sd	a2,16(s0)
    800191ba:	ec14                	sd	a3,24(s0)
    800191bc:	f018                	sd	a4,32(s0)
    800191be:	f41c                	sd	a5,40(s0)
    800191c0:	03043823          	sd	a6,48(s0)
    800191c4:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    800191c8:	04040793          	addi	a5,s0,64
    800191cc:	fcf43823          	sd	a5,-48(s0)
    800191d0:	fd043783          	ld	a5,-48(s0)
    800191d4:	fc878793          	addi	a5,a5,-56
    800191d8:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_DEBUG, fmt, va);
    800191dc:	fe043783          	ld	a5,-32(s0)
    800191e0:	863e                	mv	a2,a5
    800191e2:	fd843583          	ld	a1,-40(s0)
    800191e6:	4509                	li	a0,2
    800191e8:	ea9ff0ef          	jal	ra,80019090 <vlogf>
    800191ec:	87aa                	mv	a5,a0
    800191ee:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    800191f2:	fec42783          	lw	a5,-20(s0)
}
    800191f6:	853e                	mv	a0,a5
    800191f8:	70a2                	ld	ra,40(sp)
    800191fa:	7402                	ld	s0,32(sp)
    800191fc:	6165                	addi	sp,sp,112
    800191fe:	8082                	ret

0000000080019200 <warnf>:

int warnf(const char *fmt, ...)
{
    80019200:	7159                	addi	sp,sp,-112
    80019202:	f406                	sd	ra,40(sp)
    80019204:	f022                	sd	s0,32(sp)
    80019206:	1800                	addi	s0,sp,48
    80019208:	fca43c23          	sd	a0,-40(s0)
    8001920c:	e40c                	sd	a1,8(s0)
    8001920e:	e810                	sd	a2,16(s0)
    80019210:	ec14                	sd	a3,24(s0)
    80019212:	f018                	sd	a4,32(s0)
    80019214:	f41c                	sd	a5,40(s0)
    80019216:	03043823          	sd	a6,48(s0)
    8001921a:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001921e:	04040793          	addi	a5,s0,64
    80019222:	fcf43823          	sd	a5,-48(s0)
    80019226:	fd043783          	ld	a5,-48(s0)
    8001922a:	fc878793          	addi	a5,a5,-56
    8001922e:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_WARN, fmt, va);
    80019232:	fe043783          	ld	a5,-32(s0)
    80019236:	863e                	mv	a2,a5
    80019238:	fd843583          	ld	a1,-40(s0)
    8001923c:	4541                	li	a0,16
    8001923e:	e53ff0ef          	jal	ra,80019090 <vlogf>
    80019242:	87aa                	mv	a5,a0
    80019244:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    80019248:	fec42783          	lw	a5,-20(s0)
}
    8001924c:	853e                	mv	a0,a5
    8001924e:	70a2                	ld	ra,40(sp)
    80019250:	7402                	ld	s0,32(sp)
    80019252:	6165                	addi	sp,sp,112
    80019254:	8082                	ret

0000000080019256 <textf>:

int textf(const char *fmt, ...)
{
    80019256:	7159                	addi	sp,sp,-112
    80019258:	f406                	sd	ra,40(sp)
    8001925a:	f022                	sd	s0,32(sp)
    8001925c:	1800                	addi	s0,sp,48
    8001925e:	fca43c23          	sd	a0,-40(s0)
    80019262:	e40c                	sd	a1,8(s0)
    80019264:	e810                	sd	a2,16(s0)
    80019266:	ec14                	sd	a3,24(s0)
    80019268:	f018                	sd	a4,32(s0)
    8001926a:	f41c                	sd	a5,40(s0)
    8001926c:	03043823          	sd	a6,48(s0)
    80019270:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    80019274:	04040793          	addi	a5,s0,64
    80019278:	fcf43823          	sd	a5,-48(s0)
    8001927c:	fd043783          	ld	a5,-48(s0)
    80019280:	fc878793          	addi	a5,a5,-56
    80019284:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_TEXT, fmt, va);
    80019288:	fe043783          	ld	a5,-32(s0)
    8001928c:	863e                	mv	a2,a5
    8001928e:	fd843583          	ld	a1,-40(s0)
    80019292:	02000513          	li	a0,32
    80019296:	dfbff0ef          	jal	ra,80019090 <vlogf>
    8001929a:	87aa                	mv	a5,a0
    8001929c:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    800192a0:	fec42783          	lw	a5,-20(s0)
}
    800192a4:	853e                	mv	a0,a5
    800192a6:	70a2                	ld	ra,40(sp)
    800192a8:	7402                	ld	s0,32(sp)
    800192aa:	6165                	addi	sp,sp,112
    800192ac:	8082                	ret

00000000800192ae <infof>:

int infof(const char *fmt, ...)
{
    800192ae:	7159                	addi	sp,sp,-112
    800192b0:	f406                	sd	ra,40(sp)
    800192b2:	f022                	sd	s0,32(sp)
    800192b4:	1800                	addi	s0,sp,48
    800192b6:	fca43c23          	sd	a0,-40(s0)
    800192ba:	e40c                	sd	a1,8(s0)
    800192bc:	e810                	sd	a2,16(s0)
    800192be:	ec14                	sd	a3,24(s0)
    800192c0:	f018                	sd	a4,32(s0)
    800192c2:	f41c                	sd	a5,40(s0)
    800192c4:	03043823          	sd	a6,48(s0)
    800192c8:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    800192cc:	04040793          	addi	a5,s0,64
    800192d0:	fcf43823          	sd	a5,-48(s0)
    800192d4:	fd043783          	ld	a5,-48(s0)
    800192d8:	fc878793          	addi	a5,a5,-56
    800192dc:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_INFO, fmt, va);
    800192e0:	fe043783          	ld	a5,-32(s0)
    800192e4:	863e                	mv	a2,a5
    800192e6:	fd843583          	ld	a1,-40(s0)
    800192ea:	4511                	li	a0,4
    800192ec:	da5ff0ef          	jal	ra,80019090 <vlogf>
    800192f0:	87aa                	mv	a5,a0
    800192f2:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    800192f6:	fec42783          	lw	a5,-20(s0)
}
    800192fa:	853e                	mv	a0,a5
    800192fc:	70a2                	ld	ra,40(sp)
    800192fe:	7402                	ld	s0,32(sp)
    80019300:	6165                	addi	sp,sp,112
    80019302:	8082                	ret

0000000080019304 <fatalf>:

ATTR_NORET void fatalf(const char *fmt, ...)
{
    80019304:	7159                	addi	sp,sp,-112
    80019306:	f406                	sd	ra,40(sp)
    80019308:	f022                	sd	s0,32(sp)
    8001930a:	1800                	addi	s0,sp,48
    8001930c:	fca43c23          	sd	a0,-40(s0)
    80019310:	e40c                	sd	a1,8(s0)
    80019312:	e810                	sd	a2,16(s0)
    80019314:	ec14                	sd	a3,24(s0)
    80019316:	f018                	sd	a4,32(s0)
    80019318:	f41c                	sd	a5,40(s0)
    8001931a:	03043823          	sd	a6,48(s0)
    8001931e:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    80019322:	04040793          	addi	a5,s0,64
    80019326:	fcf43823          	sd	a5,-48(s0)
    8001932a:	fd043783          	ld	a5,-48(s0)
    8001932e:	fc878793          	addi	a5,a5,-56
    80019332:	fef43423          	sd	a5,-24(s0)
    vlogf(LOG_FATAL, fmt, va);
    80019336:	fe843783          	ld	a5,-24(s0)
    8001933a:	863e                	mv	a2,a5
    8001933c:	fd843583          	ld	a1,-40(s0)
    80019340:	4521                	li	a0,8
    80019342:	d4fff0ef          	jal	ra,80019090 <vlogf>
    va_end(va);

    CSR_CLEAR("sstatus");
    80019346:	10001073          	csrw	sstatus,zero
    WFI_LOOP();
    8001934a:	10500073          	wfi
    8001934e:	bff5                	j	8001934a <fatalf+0x46>

0000000080019350 <klogset>:
}

void klogset(log_type lt)
{
    80019350:	1101                	addi	sp,sp,-32
    80019352:	ec22                	sd	s0,24(sp)
    80019354:	1000                	addi	s0,sp,32
    80019356:	87aa                	mv	a5,a0
    80019358:	fef42623          	sw	a5,-20(s0)
    k_log_level |= lt;
    8001935c:	0000e797          	auipc	a5,0xe
    80019360:	cac78793          	addi	a5,a5,-852 # 80027008 <k_log_level>
    80019364:	439c                	lw	a5,0(a5)
    80019366:	0007871b          	sext.w	a4,a5
    8001936a:	fec42783          	lw	a5,-20(s0)
    8001936e:	8fd9                	or	a5,a5,a4
    80019370:	2781                	sext.w	a5,a5
    80019372:	0007871b          	sext.w	a4,a5
    80019376:	0000e797          	auipc	a5,0xe
    8001937a:	c9278793          	addi	a5,a5,-878 # 80027008 <k_log_level>
    8001937e:	c398                	sw	a4,0(a5)
}
    80019380:	0001                	nop
    80019382:	6462                	ld	s0,24(sp)
    80019384:	6105                	addi	sp,sp,32
    80019386:	8082                	ret

0000000080019388 <klogclear>:

void klogclear(log_type lt)
{
    80019388:	1101                	addi	sp,sp,-32
    8001938a:	ec22                	sd	s0,24(sp)
    8001938c:	1000                	addi	s0,sp,32
    8001938e:	87aa                	mv	a5,a0
    80019390:	fef42623          	sw	a5,-20(s0)
    k_log_level &= ~lt;
    80019394:	fec42783          	lw	a5,-20(s0)
    80019398:	fff7c793          	not	a5,a5
    8001939c:	0007871b          	sext.w	a4,a5
    800193a0:	0000e797          	auipc	a5,0xe
    800193a4:	c6878793          	addi	a5,a5,-920 # 80027008 <k_log_level>
    800193a8:	439c                	lw	a5,0(a5)
    800193aa:	2781                	sext.w	a5,a5
    800193ac:	8ff9                	and	a5,a5,a4
    800193ae:	2781                	sext.w	a5,a5
    800193b0:	0007871b          	sext.w	a4,a5
    800193b4:	0000e797          	auipc	a5,0xe
    800193b8:	c5478793          	addi	a5,a5,-940 # 80027008 <k_log_level>
    800193bc:	c398                	sw	a4,0(a5)
    800193be:	0001                	nop
    800193c0:	6462                	ld	s0,24(sp)
    800193c2:	6105                	addi	sp,sp,32
    800193c4:	8082                	ret

00000000800193c6 <sbi_putchar>:
#include <compiler.h>
#include <config.h>
#include <sbi.h>

void sbi_putchar(char c)
{
    800193c6:	1101                	addi	sp,sp,-32
    800193c8:	ec22                	sd	s0,24(sp)
    800193ca:	1000                	addi	s0,sp,32
    800193cc:	87aa                	mv	a5,a0
    800193ce:	fef407a3          	sb	a5,-17(s0)
    asm volatile("mv a7, %0\nmv a0, %1\necall" ::"r"(SBI_SVCALL_PUTCHAR), "r"(c) : "a7", "a0");
    800193d2:	47a5                	li	a5,9
    800193d4:	fef44703          	lbu	a4,-17(s0)
    800193d8:	88be                	mv	a7,a5
    800193da:	853a                	mv	a0,a4
    800193dc:	00000073          	ecall
}
    800193e0:	0001                	nop
    800193e2:	6462                	ld	s0,24(sp)
    800193e4:	6105                	addi	sp,sp,32
    800193e6:	8082                	ret

00000000800193e8 <sbi_getchar>:

char sbi_getchar(void)
{
    800193e8:	1101                	addi	sp,sp,-32
    800193ea:	ec22                	sd	s0,24(sp)
    800193ec:	1000                	addi	s0,sp,32
    char c;
    asm volatile("mv a7, %1\necall\nmv %0, a0\n" : "=r"(c) : "r"(SBI_SVCALL_GETCHAR) : "a7", "a0");
    800193ee:	47a9                	li	a5,10
    800193f0:	88be                	mv	a7,a5
    800193f2:	00000073          	ecall
    800193f6:	87aa                	mv	a5,a0
    800193f8:	fef407a3          	sb	a5,-17(s0)
    return c;
    800193fc:	fef44783          	lbu	a5,-17(s0)
}
    80019400:	853e                	mv	a0,a5
    80019402:	6462                	ld	s0,24(sp)
    80019404:	6105                	addi	sp,sp,32
    80019406:	8082                	ret

0000000080019408 <sbi_hart_get_status>:

int sbi_hart_get_status(unsigned int hart)
{
    80019408:	7179                	addi	sp,sp,-48
    8001940a:	f422                	sd	s0,40(sp)
    8001940c:	1800                	addi	s0,sp,48
    8001940e:	87aa                	mv	a5,a0
    80019410:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\necall\nmv %0, a0\n"
    80019414:	4785                	li	a5,1
    80019416:	fdc42703          	lw	a4,-36(s0)
    8001941a:	88be                	mv	a7,a5
    8001941c:	853a                	mv	a0,a4
    8001941e:	00000073          	ecall
    80019422:	87aa                	mv	a5,a0
    80019424:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_STATUS), "r"(hart)
                 : "a0", "a7");
    return stat;
    80019428:	fec42783          	lw	a5,-20(s0)
}
    8001942c:	853e                	mv	a0,a5
    8001942e:	7422                	ld	s0,40(sp)
    80019430:	6145                	addi	sp,sp,48
    80019432:	8082                	ret

0000000080019434 <sbi_hart_start>:

int sbi_hart_start(unsigned int hart, unsigned long target, unsigned long scratch, unsigned long satp)
{
    80019434:	7139                	addi	sp,sp,-64
    80019436:	fc22                	sd	s0,56(sp)
    80019438:	0080                	addi	s0,sp,64
    8001943a:	87aa                	mv	a5,a0
    8001943c:	fcb43823          	sd	a1,-48(s0)
    80019440:	fcc43423          	sd	a2,-56(s0)
    80019444:	fcd43023          	sd	a3,-64(s0)
    80019448:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\nmv a1, %3\nmv a2, %4\nmv a3, %5\necall\nmv %0, a0\n"
    8001944c:	4789                	li	a5,2
    8001944e:	fdc42703          	lw	a4,-36(s0)
    80019452:	fd043683          	ld	a3,-48(s0)
    80019456:	fc843803          	ld	a6,-56(s0)
    8001945a:	fc043303          	ld	t1,-64(s0)
    8001945e:	88be                	mv	a7,a5
    80019460:	853a                	mv	a0,a4
    80019462:	85b6                	mv	a1,a3
    80019464:	8642                	mv	a2,a6
    80019466:	869a                	mv	a3,t1
    80019468:	00000073          	ecall
    8001946c:	87aa                	mv	a5,a0
    8001946e:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_START), "r"(hart), "r"(target), "r"(scratch), "r"(satp)
                 : "a0", "a1", "a2", "a7");
    return stat;
    80019472:	fec42783          	lw	a5,-20(s0)
}
    80019476:	853e                	mv	a0,a5
    80019478:	7462                	ld	s0,56(sp)
    8001947a:	6121                	addi	sp,sp,64
    8001947c:	8082                	ret

000000008001947e <sbi_hart_stop>:

void sbi_hart_stop(void)
{
    8001947e:	1141                	addi	sp,sp,-16
    80019480:	e422                	sd	s0,8(sp)
    80019482:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall\nwfi" : : "r"(SBI_SVCALL_HART_STOP) : "a0", "a7");
    80019484:	478d                	li	a5,3
    80019486:	88be                	mv	a7,a5
    80019488:	00000073          	ecall
    8001948c:	10500073          	wfi
}
    80019490:	0001                	nop
    80019492:	6422                	ld	s0,8(sp)
    80019494:	0141                	addi	sp,sp,16
    80019496:	8082                	ret

0000000080019498 <sbi_poweroff>:

void sbi_poweroff(void)
{
    80019498:	1141                	addi	sp,sp,-16
    8001949a:	e422                	sd	s0,8(sp)
    8001949c:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" : : "r"(SBI_SVCALL_POWEROFF) : "a0", "a7");
    8001949e:	47b1                	li	a5,12
    800194a0:	88be                	mv	a7,a5
    800194a2:	00000073          	ecall
}
    800194a6:	0001                	nop
    800194a8:	6422                	ld	s0,8(sp)
    800194aa:	0141                	addi	sp,sp,16
    800194ac:	8082                	ret

00000000800194ae <sbi_get_time>:

unsigned long sbi_get_time(void)
{
    800194ae:	1101                	addi	sp,sp,-32
    800194b0:	ec22                	sd	s0,24(sp)
    800194b2:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_GET_TIME) : "a0", "a7");
    800194b4:	4791                	li	a5,4
    800194b6:	88be                	mv	a7,a5
    800194b8:	00000073          	ecall
    800194bc:	87aa                	mv	a5,a0
    800194be:	fef43423          	sd	a5,-24(s0)
    return ret;
    800194c2:	fe843783          	ld	a5,-24(s0)
}
    800194c6:	853e                	mv	a0,a5
    800194c8:	6462                	ld	s0,24(sp)
    800194ca:	6105                	addi	sp,sp,32
    800194cc:	8082                	ret

00000000800194ce <sbi_set_timer>:

void sbi_set_timer(unsigned int hart, unsigned long val)
{
    800194ce:	1101                	addi	sp,sp,-32
    800194d0:	ec22                	sd	s0,24(sp)
    800194d2:	1000                	addi	s0,sp,32
    800194d4:	87aa                	mv	a5,a0
    800194d6:	feb43023          	sd	a1,-32(s0)
    800194da:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_SET_TIMECMP), "r"(hart),
    800194de:	4795                	li	a5,5
    800194e0:	fec42703          	lw	a4,-20(s0)
    800194e4:	fe043683          	ld	a3,-32(s0)
    800194e8:	88be                	mv	a7,a5
    800194ea:	853a                	mv	a0,a4
    800194ec:	85b6                	mv	a1,a3
    800194ee:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    800194f2:	0001                	nop
    800194f4:	6462                	ld	s0,24(sp)
    800194f6:	6105                	addi	sp,sp,32
    800194f8:	8082                	ret

00000000800194fa <sbi_add_timer>:

void sbi_add_timer(unsigned int hart, unsigned long val)
{
    800194fa:	1101                	addi	sp,sp,-32
    800194fc:	ec22                	sd	s0,24(sp)
    800194fe:	1000                	addi	s0,sp,32
    80019500:	87aa                	mv	a5,a0
    80019502:	feb43023          	sd	a1,-32(s0)
    80019506:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_ADD_TIMECMP), "r"(hart),
    8001950a:	4799                	li	a5,6
    8001950c:	fec42703          	lw	a4,-20(s0)
    80019510:	fe043683          	ld	a3,-32(s0)
    80019514:	88be                	mv	a7,a5
    80019516:	853a                	mv	a0,a4
    80019518:	85b6                	mv	a1,a3
    8001951a:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    8001951e:	0001                	nop
    80019520:	6462                	ld	s0,24(sp)
    80019522:	6105                	addi	sp,sp,32
    80019524:	8082                	ret

0000000080019526 <sbi_ack_timer>:

void sbi_ack_timer(void)
{
    80019526:	1141                	addi	sp,sp,-16
    80019528:	e422                	sd	s0,8(sp)
    8001952a:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" ::"r"(SBI_SVCALL_ACK_TIMER) : "a7");
    8001952c:	479d                	li	a5,7
    8001952e:	88be                	mv	a7,a5
    80019530:	00000073          	ecall
}
    80019534:	0001                	nop
    80019536:	6422                	ld	s0,8(sp)
    80019538:	0141                	addi	sp,sp,16
    8001953a:	8082                	ret

000000008001953c <sbi_rtc_get_time>:

unsigned long sbi_rtc_get_time(void)
{
    8001953c:	1101                	addi	sp,sp,-32
    8001953e:	ec22                	sd	s0,24(sp)
    80019540:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0"
    80019542:	47a1                	li	a5,8
    80019544:	88be                	mv	a7,a5
    80019546:	00000073          	ecall
    8001954a:	87aa                	mv	a5,a0
    8001954c:	fef43423          	sd	a5,-24(s0)
                 : "=r"(ret)
                 : "r"(SBI_SVCALL_RTC_GET_TIME)
                 : "a0", "a7");
    return ret;
    80019550:	fe843783          	ld	a5,-24(s0)
}
    80019554:	853e                	mv	a0,a5
    80019556:	6462                	ld	s0,24(sp)
    80019558:	6105                	addi	sp,sp,32
    8001955a:	8082                	ret

000000008001955c <sbi_whoami>:

int sbi_whoami(void)
{
    8001955c:	1101                	addi	sp,sp,-32
    8001955e:	ec22                	sd	s0,24(sp)
    80019560:	1000                	addi	s0,sp,32
    int ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_WHOAMI) : "a0", "a7");
    80019562:	47ad                	li	a5,11
    80019564:	88be                	mv	a7,a5
    80019566:	00000073          	ecall
    8001956a:	87aa                	mv	a5,a0
    8001956c:	fef42623          	sw	a5,-20(s0)
    return ret;
    80019570:	fec42783          	lw	a5,-20(s0)
}
    80019574:	853e                	mv	a0,a5
    80019576:	6462                	ld	s0,24(sp)
    80019578:	6105                	addi	sp,sp,32
    8001957a:	8082                	ret

000000008001957c <sbi_num_harts>:

int sbi_num_harts(void)
{
    8001957c:	1101                	addi	sp,sp,-32
    8001957e:	ec06                	sd	ra,24(sp)
    80019580:	e822                	sd	s0,16(sp)
    80019582:	1000                	addi	s0,sp,32
    unsigned int i;
    int num_harts = 0;
    80019584:	fe042423          	sw	zero,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80019588:	fe042623          	sw	zero,-20(s0)
    8001958c:	a015                	j	800195b0 <sbi_num_harts+0x34>
        if (sbi_hart_get_status(i) != 0) {
    8001958e:	fec42783          	lw	a5,-20(s0)
    80019592:	853e                	mv	a0,a5
    80019594:	e75ff0ef          	jal	ra,80019408 <sbi_hart_get_status>
    80019598:	87aa                	mv	a5,a0
    8001959a:	c791                	beqz	a5,800195a6 <sbi_num_harts+0x2a>
            num_harts += 1;
    8001959c:	fe842783          	lw	a5,-24(s0)
    800195a0:	2785                	addiw	a5,a5,1
    800195a2:	fef42423          	sw	a5,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800195a6:	fec42783          	lw	a5,-20(s0)
    800195aa:	2785                	addiw	a5,a5,1
    800195ac:	fef42623          	sw	a5,-20(s0)
    800195b0:	fec42783          	lw	a5,-20(s0)
    800195b4:	0007871b          	sext.w	a4,a5
    800195b8:	478d                	li	a5,3
    800195ba:	fce7fae3          	bgeu	a5,a4,8001958e <sbi_num_harts+0x12>
        }
    }
    return num_harts;
    800195be:	fe842783          	lw	a5,-24(s0)
}
    800195c2:	853e                	mv	a0,a5
    800195c4:	60e2                	ld	ra,24(sp)
    800195c6:	6442                	ld	s0,16(sp)
    800195c8:	6105                	addi	sp,sp,32
    800195ca:	8082                	ret

00000000800195cc <plic_set_priority>:
#define PLIC_PCI_INTB 33
#define PLIC_PCI_INTC 34
#define PLIC_PCI_INTD 35

void plic_set_priority(int interrupt_id, char priority)
{
    800195cc:	7179                	addi	sp,sp,-48
    800195ce:	f422                	sd	s0,40(sp)
    800195d0:	1800                	addi	s0,sp,48
    800195d2:	87aa                	mv	a5,a0
    800195d4:	872e                	mv	a4,a1
    800195d6:	fcf42e23          	sw	a5,-36(s0)
    800195da:	87ba                	mv	a5,a4
    800195dc:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_PRIORITY(interrupt_id);
    800195e0:	fdc42783          	lw	a5,-36(s0)
    800195e4:	0027979b          	slliw	a5,a5,0x2
    800195e8:	2781                	sext.w	a5,a5
    800195ea:	873e                	mv	a4,a5
    800195ec:	0c0007b7          	lui	a5,0xc000
    800195f0:	97ba                	add	a5,a5,a4
    800195f2:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    800195f6:	fdb44783          	lbu	a5,-37(s0)
    800195fa:	2781                	sext.w	a5,a5
    800195fc:	8b9d                	andi	a5,a5,7
    800195fe:	0007871b          	sext.w	a4,a5
    80019602:	fe843783          	ld	a5,-24(s0)
    80019606:	c398                	sw	a4,0(a5)
}
    80019608:	0001                	nop
    8001960a:	7422                	ld	s0,40(sp)
    8001960c:	6145                	addi	sp,sp,48
    8001960e:	8082                	ret

0000000080019610 <plic_set_threshold>:
void plic_set_threshold(int hart, char priority)
{
    80019610:	7179                	addi	sp,sp,-48
    80019612:	f422                	sd	s0,40(sp)
    80019614:	1800                	addi	s0,sp,48
    80019616:	87aa                	mv	a5,a0
    80019618:	872e                	mv	a4,a1
    8001961a:	fcf42e23          	sw	a5,-36(s0)
    8001961e:	87ba                	mv	a5,a4
    80019620:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_THRESHOLD(hart, PLIC_MODE_SUPERVISOR);
    80019624:	fdc42783          	lw	a5,-36(s0)
    80019628:	0017979b          	slliw	a5,a5,0x1
    8001962c:	2781                	sext.w	a5,a5
    8001962e:	2785                	addiw	a5,a5,1
    80019630:	2781                	sext.w	a5,a5
    80019632:	00c7979b          	slliw	a5,a5,0xc
    80019636:	2781                	sext.w	a5,a5
    80019638:	873e                	mv	a4,a5
    8001963a:	0c2007b7          	lui	a5,0xc200
    8001963e:	97ba                	add	a5,a5,a4
    80019640:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    80019644:	fdb44783          	lbu	a5,-37(s0)
    80019648:	2781                	sext.w	a5,a5
    8001964a:	8b9d                	andi	a5,a5,7
    8001964c:	0007871b          	sext.w	a4,a5
    80019650:	fe843783          	ld	a5,-24(s0)
    80019654:	c398                	sw	a4,0(a5)
}
    80019656:	0001                	nop
    80019658:	7422                	ld	s0,40(sp)
    8001965a:	6145                	addi	sp,sp,48
    8001965c:	8082                	ret

000000008001965e <plic_enable>:
void plic_enable(int hart, int interrupt_id)
{
    8001965e:	7179                	addi	sp,sp,-48
    80019660:	f422                	sd	s0,40(sp)
    80019662:	1800                	addi	s0,sp,48
    80019664:	87aa                	mv	a5,a0
    80019666:	872e                	mv	a4,a1
    80019668:	fcf42e23          	sw	a5,-36(s0)
    8001966c:	87ba                	mv	a5,a4
    8001966e:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    80019672:	fdc42783          	lw	a5,-36(s0)
    80019676:	0017979b          	slliw	a5,a5,0x1
    8001967a:	2781                	sext.w	a5,a5
    8001967c:	2785                	addiw	a5,a5,1
    8001967e:	2781                	sext.w	a5,a5
    80019680:	0077979b          	slliw	a5,a5,0x7
    80019684:	2781                	sext.w	a5,a5
    80019686:	873e                	mv	a4,a5
    80019688:	0c0027b7          	lui	a5,0xc002
    8001968c:	97ba                	add	a5,a5,a4
    8001968e:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] |= 1UL << (interrupt_id % 32);
    80019692:	fd842783          	lw	a5,-40(s0)
    80019696:	41f7d71b          	sraiw	a4,a5,0x1f
    8001969a:	01b7571b          	srliw	a4,a4,0x1b
    8001969e:	9fb9                	addw	a5,a5,a4
    800196a0:	4057d79b          	sraiw	a5,a5,0x5
    800196a4:	0007869b          	sext.w	a3,a5
    800196a8:	87b6                	mv	a5,a3
    800196aa:	078a                	slli	a5,a5,0x2
    800196ac:	fe843703          	ld	a4,-24(s0)
    800196b0:	97ba                	add	a5,a5,a4
    800196b2:	438c                	lw	a1,0(a5)
    800196b4:	fd842703          	lw	a4,-40(s0)
    800196b8:	41f7579b          	sraiw	a5,a4,0x1f
    800196bc:	01b7d79b          	srliw	a5,a5,0x1b
    800196c0:	9f3d                	addw	a4,a4,a5
    800196c2:	8b7d                	andi	a4,a4,31
    800196c4:	40f707bb          	subw	a5,a4,a5
    800196c8:	2781                	sext.w	a5,a5
    800196ca:	873e                	mv	a4,a5
    800196cc:	4785                	li	a5,1
    800196ce:	00e797b3          	sll	a5,a5,a4
    800196d2:	0007861b          	sext.w	a2,a5
    800196d6:	87b6                	mv	a5,a3
    800196d8:	078a                	slli	a5,a5,0x2
    800196da:	fe843703          	ld	a4,-24(s0)
    800196de:	97ba                	add	a5,a5,a4
    800196e0:	86ae                	mv	a3,a1
    800196e2:	8732                	mv	a4,a2
    800196e4:	8f55                	or	a4,a4,a3
    800196e6:	2701                	sext.w	a4,a4
    800196e8:	c398                	sw	a4,0(a5)
}
    800196ea:	0001                	nop
    800196ec:	7422                	ld	s0,40(sp)
    800196ee:	6145                	addi	sp,sp,48
    800196f0:	8082                	ret

00000000800196f2 <plic_disable>:
void plic_disable(int hart, int interrupt_id)
{
    800196f2:	7179                	addi	sp,sp,-48
    800196f4:	f422                	sd	s0,40(sp)
    800196f6:	1800                	addi	s0,sp,48
    800196f8:	87aa                	mv	a5,a0
    800196fa:	872e                	mv	a4,a1
    800196fc:	fcf42e23          	sw	a5,-36(s0)
    80019700:	87ba                	mv	a5,a4
    80019702:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    80019706:	fdc42783          	lw	a5,-36(s0)
    8001970a:	0017979b          	slliw	a5,a5,0x1
    8001970e:	2781                	sext.w	a5,a5
    80019710:	2785                	addiw	a5,a5,1
    80019712:	2781                	sext.w	a5,a5
    80019714:	0077979b          	slliw	a5,a5,0x7
    80019718:	2781                	sext.w	a5,a5
    8001971a:	873e                	mv	a4,a5
    8001971c:	0c0027b7          	lui	a5,0xc002
    80019720:	97ba                	add	a5,a5,a4
    80019722:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] &= ~(1UL << (interrupt_id % 32));
    80019726:	fd842783          	lw	a5,-40(s0)
    8001972a:	41f7d71b          	sraiw	a4,a5,0x1f
    8001972e:	01b7571b          	srliw	a4,a4,0x1b
    80019732:	9fb9                	addw	a5,a5,a4
    80019734:	4057d79b          	sraiw	a5,a5,0x5
    80019738:	0007869b          	sext.w	a3,a5
    8001973c:	87b6                	mv	a5,a3
    8001973e:	078a                	slli	a5,a5,0x2
    80019740:	fe843703          	ld	a4,-24(s0)
    80019744:	97ba                	add	a5,a5,a4
    80019746:	438c                	lw	a1,0(a5)
    80019748:	fd842703          	lw	a4,-40(s0)
    8001974c:	41f7579b          	sraiw	a5,a4,0x1f
    80019750:	01b7d79b          	srliw	a5,a5,0x1b
    80019754:	9f3d                	addw	a4,a4,a5
    80019756:	8b7d                	andi	a4,a4,31
    80019758:	40f707bb          	subw	a5,a4,a5
    8001975c:	2781                	sext.w	a5,a5
    8001975e:	873e                	mv	a4,a5
    80019760:	4785                	li	a5,1
    80019762:	00e797b3          	sll	a5,a5,a4
    80019766:	2781                	sext.w	a5,a5
    80019768:	fff7c793          	not	a5,a5
    8001976c:	0007861b          	sext.w	a2,a5
    80019770:	87b6                	mv	a5,a3
    80019772:	078a                	slli	a5,a5,0x2
    80019774:	fe843703          	ld	a4,-24(s0)
    80019778:	97ba                	add	a5,a5,a4
    8001977a:	86ae                	mv	a3,a1
    8001977c:	8732                	mv	a4,a2
    8001977e:	8f75                	and	a4,a4,a3
    80019780:	2701                	sext.w	a4,a4
    80019782:	c398                	sw	a4,0(a5)
}
    80019784:	0001                	nop
    80019786:	7422                	ld	s0,40(sp)
    80019788:	6145                	addi	sp,sp,48
    8001978a:	8082                	ret

000000008001978c <plic_claim>:
uint32_t plic_claim(int hart)
{
    8001978c:	7179                	addi	sp,sp,-48
    8001978e:	f422                	sd	s0,40(sp)
    80019790:	1800                	addi	s0,sp,48
    80019792:	87aa                	mv	a5,a0
    80019794:	fcf42e23          	sw	a5,-36(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    80019798:	fdc42783          	lw	a5,-36(s0)
    8001979c:	0017979b          	slliw	a5,a5,0x1
    800197a0:	2781                	sext.w	a5,a5
    800197a2:	2785                	addiw	a5,a5,1
    800197a4:	2781                	sext.w	a5,a5
    800197a6:	00c7979b          	slliw	a5,a5,0xc
    800197aa:	2781                	sext.w	a5,a5
    800197ac:	873e                	mv	a4,a5
    800197ae:	0c2007b7          	lui	a5,0xc200
    800197b2:	0791                	addi	a5,a5,4
    800197b4:	97ba                	add	a5,a5,a4
    800197b6:	fef43423          	sd	a5,-24(s0)
    return *base;
    800197ba:	fe843783          	ld	a5,-24(s0)
    800197be:	439c                	lw	a5,0(a5)
}
    800197c0:	853e                	mv	a0,a5
    800197c2:	7422                	ld	s0,40(sp)
    800197c4:	6145                	addi	sp,sp,48
    800197c6:	8082                	ret

00000000800197c8 <plic_complete>:
void plic_complete(int hart, int id)
{
    800197c8:	7179                	addi	sp,sp,-48
    800197ca:	f422                	sd	s0,40(sp)
    800197cc:	1800                	addi	s0,sp,48
    800197ce:	87aa                	mv	a5,a0
    800197d0:	872e                	mv	a4,a1
    800197d2:	fcf42e23          	sw	a5,-36(s0)
    800197d6:	87ba                	mv	a5,a4
    800197d8:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    800197dc:	fdc42783          	lw	a5,-36(s0)
    800197e0:	0017979b          	slliw	a5,a5,0x1
    800197e4:	2781                	sext.w	a5,a5
    800197e6:	2785                	addiw	a5,a5,1
    800197e8:	2781                	sext.w	a5,a5
    800197ea:	00c7979b          	slliw	a5,a5,0xc
    800197ee:	2781                	sext.w	a5,a5
    800197f0:	873e                	mv	a4,a5
    800197f2:	0c2007b7          	lui	a5,0xc200
    800197f6:	0791                	addi	a5,a5,4
    800197f8:	97ba                	add	a5,a5,a4
    800197fa:	fef43423          	sd	a5,-24(s0)
    *base          = id;
    800197fe:	fd842703          	lw	a4,-40(s0)
    80019802:	fe843783          	ld	a5,-24(s0)
    80019806:	c398                	sw	a4,0(a5)
}
    80019808:	0001                	nop
    8001980a:	7422                	ld	s0,40(sp)
    8001980c:	6145                	addi	sp,sp,48
    8001980e:	8082                	ret

0000000080019810 <plic_handle_irq>:

void plic_handle_irq(int hart)
{
    80019810:	7179                	addi	sp,sp,-48
    80019812:	f406                	sd	ra,40(sp)
    80019814:	f022                	sd	s0,32(sp)
    80019816:	1800                	addi	s0,sp,48
    80019818:	87aa                	mv	a5,a0
    8001981a:	fcf42e23          	sw	a5,-36(s0)
    int irq = plic_claim(hart);
    8001981e:	fdc42783          	lw	a5,-36(s0)
    80019822:	853e                	mv	a0,a5
    80019824:	f69ff0ef          	jal	ra,8001978c <plic_claim>
    80019828:	87aa                	mv	a5,a0
    8001982a:	2781                	sext.w	a5,a5
    8001982c:	fef42623          	sw	a5,-20(s0)
    80019830:	fec42783          	lw	a5,-20(s0)
    80019834:	3781                	addiw	a5,a5,-32
    80019836:	2781                	sext.w	a5,a5

    switch (irq) {
    80019838:	873e                	mv	a4,a5
    8001983a:	478d                	li	a5,3
    8001983c:	00e7e863          	bltu	a5,a4,8001984c <plic_handle_irq+0x3c>
        // PCI devices 32-35
        case PLIC_PCI_INTA: [[fallthrough]]
        case PLIC_PCI_INTB: [[fallthrough]]
        case PLIC_PCI_INTC: [[fallthrough]]
        case PLIC_PCI_INTD:
            pci_dispatch_irq(irq);
    80019840:	fec42783          	lw	a5,-20(s0)
    80019844:	853e                	mv	a0,a5
    80019846:	b79f90ef          	jal	ra,800133be <pci_dispatch_irq>
            break;
    8001984a:	0001                	nop
    }
    plic_complete(hart, irq);
    8001984c:	fec42703          	lw	a4,-20(s0)
    80019850:	fdc42783          	lw	a5,-36(s0)
    80019854:	85ba                	mv	a1,a4
    80019856:	853e                	mv	a0,a5
    80019858:	f71ff0ef          	jal	ra,800197c8 <plic_complete>
}
    8001985c:	0001                	nop
    8001985e:	70a2                	ld	ra,40(sp)
    80019860:	7402                	ld	s0,32(sp)
    80019862:	6145                	addi	sp,sp,48
    80019864:	8082                	ret

0000000080019866 <plic_init>:

void plic_init(void)
{
    80019866:	1141                	addi	sp,sp,-16
    80019868:	e406                	sd	ra,8(sp)
    8001986a:	e022                	sd	s0,0(sp)
    8001986c:	0800                	addi	s0,sp,16
    plic_enable(0, PLIC_PCI_INTA);
    8001986e:	02000593          	li	a1,32
    80019872:	4501                	li	a0,0
    80019874:	debff0ef          	jal	ra,8001965e <plic_enable>
    plic_enable(0, PLIC_PCI_INTB);
    80019878:	02100593          	li	a1,33
    8001987c:	4501                	li	a0,0
    8001987e:	de1ff0ef          	jal	ra,8001965e <plic_enable>
    plic_enable(0, PLIC_PCI_INTC);
    80019882:	02200593          	li	a1,34
    80019886:	4501                	li	a0,0
    80019888:	dd7ff0ef          	jal	ra,8001965e <plic_enable>
    plic_enable(0, PLIC_PCI_INTD);
    8001988c:	02300593          	li	a1,35
    80019890:	4501                	li	a0,0
    80019892:	dcdff0ef          	jal	ra,8001965e <plic_enable>

    plic_set_threshold(0, 0);
    80019896:	4581                	li	a1,0
    80019898:	4501                	li	a0,0
    8001989a:	d77ff0ef          	jal	ra,80019610 <plic_set_threshold>

    plic_set_priority(PLIC_PCI_INTA, 7);
    8001989e:	459d                	li	a1,7
    800198a0:	02000513          	li	a0,32
    800198a4:	d29ff0ef          	jal	ra,800195cc <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTB, 7);
    800198a8:	459d                	li	a1,7
    800198aa:	02100513          	li	a0,33
    800198ae:	d1fff0ef          	jal	ra,800195cc <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTC, 7);
    800198b2:	459d                	li	a1,7
    800198b4:	02200513          	li	a0,34
    800198b8:	d15ff0ef          	jal	ra,800195cc <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTD, 7);
    800198bc:	459d                	li	a1,7
    800198be:	02300513          	li	a0,35
    800198c2:	d0bff0ef          	jal	ra,800195cc <plic_set_priority>
}
    800198c6:	0001                	nop
    800198c8:	60a2                	ld	ra,8(sp)
    800198ca:	6402                	ld	s0,0(sp)
    800198cc:	0141                	addi	sp,sp,16
    800198ce:	8082                	ret

00000000800198d0 <mmu_table_create>:
#define ADDR_1_BIT   21
#define ADDR_2_BIT   30


struct page_table *mmu_table_create(void)
{
    800198d0:	1141                	addi	sp,sp,-16
    800198d2:	e406                	sd	ra,8(sp)
    800198d4:	e022                	sd	s0,0(sp)
    800198d6:	0800                	addi	s0,sp,16
    return page_zalloc();
    800198d8:	4505                	li	a0,1
    800198da:	1e8020ef          	jal	ra,8001bac2 <page_znalloc>
    800198de:	87aa                	mv	a5,a0
}
    800198e0:	853e                	mv	a0,a5
    800198e2:	60a2                	ld	ra,8(sp)
    800198e4:	6402                	ld	s0,0(sp)
    800198e6:	0141                	addi	sp,sp,16
    800198e8:	8082                	ret

00000000800198ea <is_valid>:

// Check the valid bit of a page table entry.
static inline bool is_valid(unsigned long pte)
{
    800198ea:	1101                	addi	sp,sp,-32
    800198ec:	ec22                	sd	s0,24(sp)
    800198ee:	1000                	addi	s0,sp,32
    800198f0:	fea43423          	sd	a0,-24(s0)
    return pte & 1UL;
    800198f4:	fe843783          	ld	a5,-24(s0)
    800198f8:	8b85                	andi	a5,a5,1
    800198fa:	00f037b3          	snez	a5,a5
    800198fe:	0ff7f793          	andi	a5,a5,255
}
    80019902:	853e                	mv	a0,a5
    80019904:	6462                	ld	s0,24(sp)
    80019906:	6105                	addi	sp,sp,32
    80019908:	8082                	ret

000000008001990a <is_leaf>:

// Check if a page table entry is a leaf, return false if it's a branch.
static inline bool is_leaf(unsigned long pte)
{
    8001990a:	1101                	addi	sp,sp,-32
    8001990c:	ec22                	sd	s0,24(sp)
    8001990e:	1000                	addi	s0,sp,32
    80019910:	fea43423          	sd	a0,-24(s0)
    return (pte & 0xE) != 0;
    80019914:	fe843783          	ld	a5,-24(s0)
    80019918:	8bb9                	andi	a5,a5,14
    8001991a:	00f037b3          	snez	a5,a5
    8001991e:	0ff7f793          	andi	a5,a5,255
}
    80019922:	853e                	mv	a0,a5
    80019924:	6462                	ld	s0,24(sp)
    80019926:	6105                	addi	sp,sp,32
    80019928:	8082                	ret

000000008001992a <mmu_map>:

bool mmu_map(struct page_table *tab, uint64_t vaddr, uint64_t paddr, uint8_t lvl, uint64_t bits)
{
    8001992a:	7135                	addi	sp,sp,-160
    8001992c:	ed06                	sd	ra,152(sp)
    8001992e:	e922                	sd	s0,144(sp)
    80019930:	1100                	addi	s0,sp,160
    80019932:	f8a43423          	sd	a0,-120(s0)
    80019936:	f8b43023          	sd	a1,-128(s0)
    8001993a:	f6c43c23          	sd	a2,-136(s0)
    8001993e:	87b6                	mv	a5,a3
    80019940:	f6e43423          	sd	a4,-152(s0)
    80019944:	f6f40ba3          	sb	a5,-137(s0)
    if (tab == NULL || lvl > MMU_LEVEL_1G || (bits & 0xE) == 0) {
    80019948:	f8843783          	ld	a5,-120(s0)
    8001994c:	cf81                	beqz	a5,80019964 <mmu_map+0x3a>
    8001994e:	f7744783          	lbu	a5,-137(s0)
    80019952:	0ff7f713          	andi	a4,a5,255
    80019956:	4789                	li	a5,2
    80019958:	00e7e663          	bltu	a5,a4,80019964 <mmu_map+0x3a>
    8001995c:	f6843783          	ld	a5,-152(s0)
    80019960:	8bb9                	andi	a5,a5,14
    80019962:	e399                	bnez	a5,80019968 <mmu_map+0x3e>
        // debugf("mmu_map: invalid argument");
        return false;
    80019964:	4781                	li	a5,0
    80019966:	aab9                	j	80019ac4 <mmu_map+0x19a>

    // debugf("mmu_map: page table at 0x%08lx\n", tab);
    // debugf("mmu_map: vaddr == 0x%08lx\n", vaddr);
    // debugf("mmu_map: paddr == 0x%08lx\n", paddr);

    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80019968:	f8043783          	ld	a5,-128(s0)
    8001996c:	83b1                	srli	a5,a5,0xc
    8001996e:	1ff7f793          	andi	a5,a5,511
    80019972:	faf43823          	sd	a5,-80(s0)
    80019976:	f8043783          	ld	a5,-128(s0)
    8001997a:	83d5                	srli	a5,a5,0x15
    8001997c:	1ff7f793          	andi	a5,a5,511
    80019980:	faf43c23          	sd	a5,-72(s0)
                            (vaddr >> ADDR_2_BIT) & 0x1FF};
    80019984:	f8043783          	ld	a5,-128(s0)
    80019988:	83f9                	srli	a5,a5,0x1e
    8001998a:	1ff7f793          	andi	a5,a5,511
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    8001998e:	fcf43023          	sd	a5,-64(s0)
    // debugf("mmu_map: vpn = {%d, %d, %d}\n", vpn[0], vpn[1], vpn[2]);
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80019992:	f7843783          	ld	a5,-136(s0)
    80019996:	83b1                	srli	a5,a5,0xc
    80019998:	1ff7f793          	andi	a5,a5,511
    8001999c:	f8f43c23          	sd	a5,-104(s0)
    800199a0:	f7843783          	ld	a5,-136(s0)
    800199a4:	83d5                	srli	a5,a5,0x15
    800199a6:	1ff7f793          	andi	a5,a5,511
    800199aa:	faf43023          	sd	a5,-96(s0)
                            (paddr >> ADDR_2_BIT) & 0x3FFFFFF};
    800199ae:	f7843783          	ld	a5,-136(s0)
    800199b2:	01e7d713          	srli	a4,a5,0x1e
    800199b6:	040007b7          	lui	a5,0x4000
    800199ba:	17fd                	addi	a5,a5,-1
    800199bc:	8ff9                	and	a5,a5,a4
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    800199be:	faf43423          	sd	a5,-88(s0)

    int i;
    struct page_table *pt = tab;
    800199c2:	f8843783          	ld	a5,-120(s0)
    800199c6:	fef43023          	sd	a5,-32(s0)

    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    800199ca:	4789                	li	a5,2
    800199cc:	fef42623          	sw	a5,-20(s0)
    800199d0:	a871                	j	80019a6c <mmu_map+0x142>
        unsigned long pte = pt->entries[vpn[i]];
    800199d2:	fec42783          	lw	a5,-20(s0)
    800199d6:	078e                	slli	a5,a5,0x3
    800199d8:	ff040713          	addi	a4,s0,-16
    800199dc:	97ba                	add	a5,a5,a4
    800199de:	fc07b783          	ld	a5,-64(a5) # 3ffffc0 <i+0x3ffffa0>
    800199e2:	fe043703          	ld	a4,-32(s0)
    800199e6:	078e                	slli	a5,a5,0x3
    800199e8:	97ba                	add	a5,a5,a4
    800199ea:	639c                	ld	a5,0(a5)
    800199ec:	fcf43823          	sd	a5,-48(s0)

        if (!is_valid(pte)) {
    800199f0:	fd043503          	ld	a0,-48(s0)
    800199f4:	ef7ff0ef          	jal	ra,800198ea <is_valid>
    800199f8:	87aa                	mv	a5,a0
    800199fa:	0017c793          	xori	a5,a5,1
    800199fe:	0ff7f793          	andi	a5,a5,255
    80019a02:	cf8d                	beqz	a5,80019a3c <mmu_map+0x112>
            // debugf("mmu_map: entry %d in page table at 0x%08lx is invalid\n", vpn[i], pt);
            struct page_table *new_pt = mmu_table_create();
    80019a04:	ecdff0ef          	jal	ra,800198d0 <mmu_table_create>
    80019a08:	fca43423          	sd	a0,-56(s0)
            if (new_pt == NULL) {
    80019a0c:	fc843783          	ld	a5,-56(s0)
    80019a10:	e399                	bnez	a5,80019a16 <mmu_map+0xec>
                // debugf("mmu_map: mmu_table_create returned null");
                return false;
    80019a12:	4781                	li	a5,0
    80019a14:	a845                	j	80019ac4 <mmu_map+0x19a>
            }
            // debugf("mmu_map: create a new page table at 0x%08lx\n", new_pt);
            pt->entries[vpn[i]] = (unsigned long)new_pt >> 2 | PB_VALID;
    80019a16:	fc843783          	ld	a5,-56(s0)
    80019a1a:	0027d713          	srli	a4,a5,0x2
    80019a1e:	fec42783          	lw	a5,-20(s0)
    80019a22:	078e                	slli	a5,a5,0x3
    80019a24:	ff040693          	addi	a3,s0,-16
    80019a28:	97b6                	add	a5,a5,a3
    80019a2a:	fc07b783          	ld	a5,-64(a5)
    80019a2e:	00176713          	ori	a4,a4,1
    80019a32:	fe043683          	ld	a3,-32(s0)
    80019a36:	078e                	slli	a5,a5,0x3
    80019a38:	97b6                	add	a5,a5,a3
    80019a3a:	e398                	sd	a4,0(a5)
            // debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d branch to 0x%08lx\n", vpn[i], pt, i, new_pt);
        } else {
            // debugf("mmu_map: entry %d in page table at 0x%08lx is valid\n", vpn[i], pt);
        }
        pt = (struct page_table*)((pt->entries[vpn[i]] & ~0x3FF) << 2);
    80019a3c:	fec42783          	lw	a5,-20(s0)
    80019a40:	078e                	slli	a5,a5,0x3
    80019a42:	ff040713          	addi	a4,s0,-16
    80019a46:	97ba                	add	a5,a5,a4
    80019a48:	fc07b783          	ld	a5,-64(a5)
    80019a4c:	fe043703          	ld	a4,-32(s0)
    80019a50:	078e                	slli	a5,a5,0x3
    80019a52:	97ba                	add	a5,a5,a4
    80019a54:	639c                	ld	a5,0(a5)
    80019a56:	00279713          	slli	a4,a5,0x2
    80019a5a:	77fd                	lui	a5,0xfffff
    80019a5c:	8ff9                	and	a5,a5,a4
    80019a5e:	fef43023          	sd	a5,-32(s0)
    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    80019a62:	fec42783          	lw	a5,-20(s0)
    80019a66:	37fd                	addiw	a5,a5,-1
    80019a68:	fef42623          	sw	a5,-20(s0)
    80019a6c:	f7744783          	lbu	a5,-137(s0)
    80019a70:	0007871b          	sext.w	a4,a5
    80019a74:	fec42783          	lw	a5,-20(s0)
    80019a78:	2781                	sext.w	a5,a5
    80019a7a:	f4f74ce3          	blt	a4,a5,800199d2 <mmu_map+0xa8>
    }

    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80019a7e:	fa843783          	ld	a5,-88(s0)
    80019a82:	01c79713          	slli	a4,a5,0x1c
                             ppn[1] << PTE_PPN1_BIT |
    80019a86:	fa043783          	ld	a5,-96(s0)
    80019a8a:	07ce                	slli	a5,a5,0x13
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80019a8c:	8f5d                	or	a4,a4,a5
                             ppn[0] << PTE_PPN0_BIT;
    80019a8e:	f9843783          	ld	a5,-104(s0)
    80019a92:	07aa                	slli	a5,a5,0xa
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80019a94:	8fd9                	or	a5,a5,a4
    80019a96:	fcf43c23          	sd	a5,-40(s0)
    
    // debugf("mmu_map: ppn_leaf == 0x%x\n", (ppn_leaf << 2));
    pt->entries[vpn[i]] = ppn_leaf | bits | PB_VALID;
    80019a9a:	fd843703          	ld	a4,-40(s0)
    80019a9e:	f6843783          	ld	a5,-152(s0)
    80019aa2:	8f5d                	or	a4,a4,a5
    80019aa4:	fec42783          	lw	a5,-20(s0)
    80019aa8:	078e                	slli	a5,a5,0x3
    80019aaa:	ff040693          	addi	a3,s0,-16
    80019aae:	97b6                	add	a5,a5,a3
    80019ab0:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    80019ab4:	00176713          	ori	a4,a4,1
    80019ab8:	fe043683          	ld	a3,-32(s0)
    80019abc:	078e                	slli	a5,a5,0x3
    80019abe:	97b6                	add	a5,a5,a3
    80019ac0:	e398                	sd	a4,0(a5)

    // debugf("mmu_map: set bits of address 0x%08lx to 0x%08lx\n", &pt->entries[vpn[i]], ppn_leaf | bits | PB_VALID);

    // debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d leaf to 0x%08lx\n", vpn[i], pt, i, ppn_leaf << 2);
    return true;
    80019ac2:	4785                	li	a5,1
}
    80019ac4:	853e                	mv	a0,a5
    80019ac6:	60ea                	ld	ra,152(sp)
    80019ac8:	644a                	ld	s0,144(sp)
    80019aca:	610d                	addi	sp,sp,160
    80019acc:	8082                	ret

0000000080019ace <mmu_free>:

void mmu_free(struct page_table *tab) 
{ 
    80019ace:	7179                	addi	sp,sp,-48
    80019ad0:	f406                	sd	ra,40(sp)
    80019ad2:	f022                	sd	s0,32(sp)
    80019ad4:	1800                	addi	s0,sp,48
    80019ad6:	fca43c23          	sd	a0,-40(s0)
    uint64_t entry; 
    int i; 

    if (tab == NULL) { 
    80019ada:	fd843783          	ld	a5,-40(s0)
    80019ade:	c7b5                	beqz	a5,80019b4a <mmu_free+0x7c>
        return; 
    } 

    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    80019ae0:	fe042623          	sw	zero,-20(s0)
    80019ae4:	a0a1                	j	80019b2c <mmu_free+0x5e>
        entry = tab->entries[i]; 
    80019ae6:	fd843703          	ld	a4,-40(s0)
    80019aea:	fec42783          	lw	a5,-20(s0)
    80019aee:	078e                	slli	a5,a5,0x3
    80019af0:	97ba                	add	a5,a5,a4
    80019af2:	639c                	ld	a5,0(a5)
    80019af4:	fef43023          	sd	a5,-32(s0)
        if (entry & PB_VALID) {
    80019af8:	fe043783          	ld	a5,-32(s0)
    80019afc:	8b85                	andi	a5,a5,1
    80019afe:	cb91                	beqz	a5,80019b12 <mmu_free+0x44>
            mmu_free((struct page_table *)((entry & ~0x3FF) << 2)); // Recurse into the next level
    80019b00:	fe043783          	ld	a5,-32(s0)
    80019b04:	00279713          	slli	a4,a5,0x2
    80019b08:	77fd                	lui	a5,0xfffff
    80019b0a:	8ff9                	and	a5,a5,a4
    80019b0c:	853e                	mv	a0,a5
    80019b0e:	fc1ff0ef          	jal	ra,80019ace <mmu_free>
        }
        tab->entries[i] = 0; 
    80019b12:	fd843703          	ld	a4,-40(s0)
    80019b16:	fec42783          	lw	a5,-20(s0)
    80019b1a:	078e                	slli	a5,a5,0x3
    80019b1c:	97ba                	add	a5,a5,a4
    80019b1e:	0007b023          	sd	zero,0(a5) # fffffffffffff000 <_heap_end+0xffffffff77fef000>
    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    80019b22:	fec42783          	lw	a5,-20(s0)
    80019b26:	2785                	addiw	a5,a5,1
    80019b28:	fef42623          	sw	a5,-20(s0)
    80019b2c:	fec42783          	lw	a5,-20(s0)
    80019b30:	0007871b          	sext.w	a4,a5
    80019b34:	1ff00793          	li	a5,511
    80019b38:	fae7d7e3          	bge	a5,a4,80019ae6 <mmu_free+0x18>
    } 

    page_free(tab); 
    80019b3c:	fd843503          	ld	a0,-40(s0)
    80019b40:	01e020ef          	jal	ra,8001bb5e <page_free>
    SFENCE_ALL();
    80019b44:	12000073          	sfence.vma
    80019b48:	a011                	j	80019b4c <mmu_free+0x7e>
        return; 
    80019b4a:	0001                	nop
}
    80019b4c:	70a2                	ld	ra,40(sp)
    80019b4e:	7402                	ld	s0,32(sp)
    80019b50:	6145                	addi	sp,sp,48
    80019b52:	8082                	ret

0000000080019b54 <mmu_translate>:

uint64_t mmu_translate(const struct page_table *tab, uint64_t vaddr) 
{ 
    80019b54:	711d                	addi	sp,sp,-96
    80019b56:	ec86                	sd	ra,88(sp)
    80019b58:	e8a2                	sd	s0,80(sp)
    80019b5a:	1080                	addi	s0,sp,96
    80019b5c:	faa43423          	sd	a0,-88(s0)
    80019b60:	fab43023          	sd	a1,-96(s0)

    // debugf("mmu_translate: page table at 0x%016lx\n", tab);
    // debugf("mmu_translate: vaddr == 0x%016lx\n", vaddr);

    if (tab == NULL) { 
    80019b64:	fa843783          	ld	a5,-88(s0)
    80019b68:	e399                	bnez	a5,80019b6e <mmu_translate+0x1a>
        // debugf("mmu_translate: tab == NULL\n");
        return MMU_TRANSLATE_PAGE_FAULT; 
    80019b6a:	57fd                	li	a5,-1
    80019b6c:	aab1                	j	80019cc8 <mmu_translate+0x174>
    } 

    // Extract the virtual page numbers
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80019b6e:	fa043783          	ld	a5,-96(s0)
    80019b72:	83b1                	srli	a5,a5,0xc
    80019b74:	1ff7f793          	andi	a5,a5,511
    80019b78:	faf43823          	sd	a5,-80(s0)
                      (vaddr >> ADDR_1_BIT) & 0x1FF, 
    80019b7c:	fa043783          	ld	a5,-96(s0)
    80019b80:	83d5                	srli	a5,a5,0x15
    80019b82:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80019b86:	faf43c23          	sd	a5,-72(s0)
                      (vaddr >> ADDR_2_BIT) & 0x1FF};
    80019b8a:	fa043783          	ld	a5,-96(s0)
    80019b8e:	83f9                	srli	a5,a5,0x1e
    80019b90:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80019b94:	fcf43023          	sd	a5,-64(s0)
    // debugf("mmu_translate: vpn[0] == 0x%03lx\n", vpn[0]);
    // debugf("mmu_translate: vpn[1] == 0x%03lx\n", vpn[1]);
    // debugf("mmu_translate: vpn[2] == 0x%03lx\n", vpn[2]);

    uint64_t lvl = MMU_LEVEL_1G;
    80019b98:	4789                	li	a5,2
    80019b9a:	fef43423          	sd	a5,-24(s0)
    // Traverse the page table hierarchy using the virtual page numbers
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    80019b9e:	4789                	li	a5,2
    80019ba0:	fef42223          	sw	a5,-28(s0)
    80019ba4:	a075                	j	80019c50 <mmu_translate+0xfc>
        // Iterate through and print the page table entries
        // debugf("mmu_translate: tab->entries == 0x%08lx\n", tab->entries);
        for (int j = 0; j < (PAGE_SIZE / 8); j++) {
    80019ba6:	fe042023          	sw	zero,-32(s0)
    80019baa:	a031                	j	80019bb6 <mmu_translate+0x62>
    80019bac:	fe042783          	lw	a5,-32(s0)
    80019bb0:	2785                	addiw	a5,a5,1
    80019bb2:	fef42023          	sw	a5,-32(s0)
    80019bb6:	fe042783          	lw	a5,-32(s0)
    80019bba:	0007871b          	sext.w	a4,a5
    80019bbe:	1ff00793          	li	a5,511
    80019bc2:	fee7d5e3          	bge	a5,a4,80019bac <mmu_translate+0x58>
            if (tab->entries[j] & PB_VALID) {
                // debugf("mmu_translate: tab->entries[%x] == 0x%0lx\n", j, tab->entries[j]);
            }
        }

        if (!(tab->entries[vpn[i]] & PB_VALID)) {
    80019bc6:	fe442783          	lw	a5,-28(s0)
    80019bca:	078e                	slli	a5,a5,0x3
    80019bcc:	ff040713          	addi	a4,s0,-16
    80019bd0:	97ba                	add	a5,a5,a4
    80019bd2:	fc07b783          	ld	a5,-64(a5)
    80019bd6:	fa843703          	ld	a4,-88(s0)
    80019bda:	078e                	slli	a5,a5,0x3
    80019bdc:	97ba                	add	a5,a5,a4
    80019bde:	639c                	ld	a5,0(a5)
    80019be0:	8b85                	andi	a5,a5,1
    80019be2:	e399                	bnez	a5,80019be8 <mmu_translate+0x94>
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is invalid\n", vpn[i], tab);
            return MMU_TRANSLATE_PAGE_FAULT; // Entry is not valid
    80019be4:	57fd                	li	a5,-1
    80019be6:	a0cd                	j	80019cc8 <mmu_translate+0x174>
        } else if (!is_leaf(tab->entries[vpn[i]])) {
    80019be8:	fe442783          	lw	a5,-28(s0)
    80019bec:	078e                	slli	a5,a5,0x3
    80019bee:	ff040713          	addi	a4,s0,-16
    80019bf2:	97ba                	add	a5,a5,a4
    80019bf4:	fc07b783          	ld	a5,-64(a5)
    80019bf8:	fa843703          	ld	a4,-88(s0)
    80019bfc:	078e                	slli	a5,a5,0x3
    80019bfe:	97ba                	add	a5,a5,a4
    80019c00:	639c                	ld	a5,0(a5)
    80019c02:	853e                	mv	a0,a5
    80019c04:	d07ff0ef          	jal	ra,8001990a <is_leaf>
    80019c08:	87aa                	mv	a5,a0
    80019c0a:	0017c793          	xori	a5,a5,1
    80019c0e:	0ff7f793          	andi	a5,a5,255
    80019c12:	c78d                	beqz	a5,80019c3c <mmu_translate+0xe8>
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is a branch to 0x%08lx\n", vpn[i], tab, (tab->entries[vpn[i]] & ~0x3FF) << 2);
            tab = (struct page_table *)((tab->entries[vpn[i]] & ~0x3FF) << 2);
    80019c14:	fe442783          	lw	a5,-28(s0)
    80019c18:	078e                	slli	a5,a5,0x3
    80019c1a:	ff040713          	addi	a4,s0,-16
    80019c1e:	97ba                	add	a5,a5,a4
    80019c20:	fc07b783          	ld	a5,-64(a5)
    80019c24:	fa843703          	ld	a4,-88(s0)
    80019c28:	078e                	slli	a5,a5,0x3
    80019c2a:	97ba                	add	a5,a5,a4
    80019c2c:	639c                	ld	a5,0(a5)
    80019c2e:	00279713          	slli	a4,a5,0x2
    80019c32:	77fd                	lui	a5,0xfffff
    80019c34:	8ff9                	and	a5,a5,a4
    80019c36:	faf43423          	sd	a5,-88(s0)
    80019c3a:	a031                	j	80019c46 <mmu_translate+0xf2>
        } else {
            // debugf("mmu_translate: entry %x in page table at 0x%08lx is a leaf\n", vpn[i], tab);
            lvl = i;
    80019c3c:	fe442783          	lw	a5,-28(s0)
    80019c40:	fef43423          	sd	a5,-24(s0)
            break; // Entry is a leaf
    80019c44:	a819                	j	80019c5a <mmu_translate+0x106>
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    80019c46:	fe442783          	lw	a5,-28(s0)
    80019c4a:	37fd                	addiw	a5,a5,-1
    80019c4c:	fef42223          	sw	a5,-28(s0)
    80019c50:	fe442783          	lw	a5,-28(s0)
    80019c54:	2781                	sext.w	a5,a5
    80019c56:	f407d8e3          	bgez	a5,80019ba6 <mmu_translate+0x52>
        }
    }

    // debugf("mmu_translate: vaddr == 0x%08lx\n", vaddr);

    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    80019c5a:	fe843783          	ld	a5,-24(s0)
    80019c5e:	2781                	sext.w	a5,a5
    80019c60:	873e                	mv	a4,a5
    80019c62:	87ba                	mv	a5,a4
    80019c64:	0037979b          	slliw	a5,a5,0x3
    80019c68:	9fb9                	addw	a5,a5,a4
    80019c6a:	2781                	sext.w	a5,a5
    80019c6c:	27b1                	addiw	a5,a5,12
    80019c6e:	2781                	sext.w	a5,a5
    80019c70:	4705                	li	a4,1
    80019c72:	00f717bb          	sllw	a5,a4,a5
    80019c76:	2781                	sext.w	a5,a5
    80019c78:	37fd                	addiw	a5,a5,-1
    80019c7a:	2781                	sext.w	a5,a5
    80019c7c:	fcf43c23          	sd	a5,-40(s0)
    
    // Extract the physical address from the final page table entry
    uint64_t paddr = ((tab->entries[vpn[lvl]] & ~0x3FF) << 2) & ~page_mask;
    80019c80:	fe843783          	ld	a5,-24(s0)
    80019c84:	078e                	slli	a5,a5,0x3
    80019c86:	ff040713          	addi	a4,s0,-16
    80019c8a:	97ba                	add	a5,a5,a4
    80019c8c:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    80019c90:	fa843703          	ld	a4,-88(s0)
    80019c94:	078e                	slli	a5,a5,0x3
    80019c96:	97ba                	add	a5,a5,a4
    80019c98:	639c                	ld	a5,0(a5)
    80019c9a:	00279713          	slli	a4,a5,0x2
    80019c9e:	fd843783          	ld	a5,-40(s0)
    80019ca2:	fff7c793          	not	a5,a5
    80019ca6:	8f7d                	and	a4,a4,a5
    80019ca8:	77fd                	lui	a5,0xfffff
    80019caa:	8ff9                	and	a5,a5,a4
    80019cac:	fcf43823          	sd	a5,-48(s0)

    uint64_t result = paddr | (vaddr & page_mask);
    80019cb0:	fa043703          	ld	a4,-96(s0)
    80019cb4:	fd843783          	ld	a5,-40(s0)
    80019cb8:	8ff9                	and	a5,a5,a4
    80019cba:	fd043703          	ld	a4,-48(s0)
    80019cbe:	8fd9                	or	a5,a5,a4
    80019cc0:	fcf43423          	sd	a5,-56(s0)
    // debugf("mmu_translate: paddr == 0x%08lx\n", result);

    return result; // Combine with the offset within the page
    80019cc4:	fc843783          	ld	a5,-56(s0)
}
    80019cc8:	853e                	mv	a0,a5
    80019cca:	60e6                	ld	ra,88(sp)
    80019ccc:	6446                	ld	s0,80(sp)
    80019cce:	6125                	addi	sp,sp,96
    80019cd0:	8082                	ret

0000000080019cd2 <kernel_mmu_translate>:

uint64_t kernel_mmu_translate(uint64_t vaddr) 
{ 
    80019cd2:	1101                	addi	sp,sp,-32
    80019cd4:	ec06                	sd	ra,24(sp)
    80019cd6:	e822                	sd	s0,16(sp)
    80019cd8:	1000                	addi	s0,sp,32
    80019cda:	fea43423          	sd	a0,-24(s0)
    return mmu_translate(kernel_mmu_table, vaddr); 
    80019cde:	00009797          	auipc	a5,0x9
    80019ce2:	32278793          	addi	a5,a5,802 # 80023000 <kernel_mmu_table>
    80019ce6:	639c                	ld	a5,0(a5)
    80019ce8:	fe843583          	ld	a1,-24(s0)
    80019cec:	853e                	mv	a0,a5
    80019cee:	e67ff0ef          	jal	ra,80019b54 <mmu_translate>
    80019cf2:	87aa                	mv	a5,a0
}
    80019cf4:	853e                	mv	a0,a5
    80019cf6:	60e2                	ld	ra,24(sp)
    80019cf8:	6442                	ld	s0,16(sp)
    80019cfa:	6105                	addi	sp,sp,32
    80019cfc:	8082                	ret

0000000080019cfe <mmu_map_range>:
                       uint64_t start_virt, 
                       uint64_t end_virt, 
                       uint64_t start_phys,
                       uint8_t lvl, 
                       uint64_t bits)
{
    80019cfe:	711d                	addi	sp,sp,-96
    80019d00:	ec86                	sd	ra,88(sp)
    80019d02:	e8a2                	sd	s0,80(sp)
    80019d04:	1080                	addi	s0,sp,96
    80019d06:	fca43423          	sd	a0,-56(s0)
    80019d0a:	fcb43023          	sd	a1,-64(s0)
    80019d0e:	fac43c23          	sd	a2,-72(s0)
    80019d12:	fad43823          	sd	a3,-80(s0)
    80019d16:	faf43023          	sd	a5,-96(s0)
    80019d1a:	87ba                	mv	a5,a4
    80019d1c:	faf407a3          	sb	a5,-81(s0)
    // debugf("mmu_map_range: page table at 0x%08lx\n", tab);
    start_virt            = ALIGN_DOWN_POT(start_virt, PAGE_SIZE_AT_LVL(lvl));
    80019d20:	faf44783          	lbu	a5,-81(s0)
    80019d24:	2781                	sext.w	a5,a5
    80019d26:	873e                	mv	a4,a5
    80019d28:	87ba                	mv	a5,a4
    80019d2a:	0037979b          	slliw	a5,a5,0x3
    80019d2e:	9fb9                	addw	a5,a5,a4
    80019d30:	2781                	sext.w	a5,a5
    80019d32:	27b1                	addiw	a5,a5,12
    80019d34:	2781                	sext.w	a5,a5
    80019d36:	4705                	li	a4,1
    80019d38:	00f717bb          	sllw	a5,a4,a5
    80019d3c:	2781                	sext.w	a5,a5
    80019d3e:	40f007bb          	negw	a5,a5
    80019d42:	2781                	sext.w	a5,a5
    80019d44:	873e                	mv	a4,a5
    80019d46:	fc043783          	ld	a5,-64(s0)
    80019d4a:	8ff9                	and	a5,a5,a4
    80019d4c:	fcf43023          	sd	a5,-64(s0)
    start_phys            = ALIGN_DOWN_POT(start_phys, PAGE_SIZE_AT_LVL(lvl));
    80019d50:	faf44783          	lbu	a5,-81(s0)
    80019d54:	2781                	sext.w	a5,a5
    80019d56:	873e                	mv	a4,a5
    80019d58:	87ba                	mv	a5,a4
    80019d5a:	0037979b          	slliw	a5,a5,0x3
    80019d5e:	9fb9                	addw	a5,a5,a4
    80019d60:	2781                	sext.w	a5,a5
    80019d62:	27b1                	addiw	a5,a5,12
    80019d64:	2781                	sext.w	a5,a5
    80019d66:	4705                	li	a4,1
    80019d68:	00f717bb          	sllw	a5,a4,a5
    80019d6c:	2781                	sext.w	a5,a5
    80019d6e:	40f007bb          	negw	a5,a5
    80019d72:	2781                	sext.w	a5,a5
    80019d74:	873e                	mv	a4,a5
    80019d76:	fb043783          	ld	a5,-80(s0)
    80019d7a:	8ff9                	and	a5,a5,a4
    80019d7c:	faf43823          	sd	a5,-80(s0)
    end_virt              = ALIGN_UP_POT(end_virt, PAGE_SIZE_AT_LVL(lvl));
    80019d80:	faf44783          	lbu	a5,-81(s0)
    80019d84:	2781                	sext.w	a5,a5
    80019d86:	873e                	mv	a4,a5
    80019d88:	87ba                	mv	a5,a4
    80019d8a:	0037979b          	slliw	a5,a5,0x3
    80019d8e:	9fb9                	addw	a5,a5,a4
    80019d90:	2781                	sext.w	a5,a5
    80019d92:	27b1                	addiw	a5,a5,12
    80019d94:	2781                	sext.w	a5,a5
    80019d96:	4705                	li	a4,1
    80019d98:	00f717bb          	sllw	a5,a4,a5
    80019d9c:	2781                	sext.w	a5,a5
    80019d9e:	873e                	mv	a4,a5
    80019da0:	fb843783          	ld	a5,-72(s0)
    80019da4:	97ba                	add	a5,a5,a4
    80019da6:	fff78713          	addi	a4,a5,-1
    80019daa:	faf44783          	lbu	a5,-81(s0)
    80019dae:	2781                	sext.w	a5,a5
    80019db0:	86be                	mv	a3,a5
    80019db2:	87b6                	mv	a5,a3
    80019db4:	0037979b          	slliw	a5,a5,0x3
    80019db8:	9fb5                	addw	a5,a5,a3
    80019dba:	2781                	sext.w	a5,a5
    80019dbc:	27b1                	addiw	a5,a5,12
    80019dbe:	2781                	sext.w	a5,a5
    80019dc0:	4685                	li	a3,1
    80019dc2:	00f697bb          	sllw	a5,a3,a5
    80019dc6:	2781                	sext.w	a5,a5
    80019dc8:	40f007bb          	negw	a5,a5
    80019dcc:	2781                	sext.w	a5,a5
    80019dce:	8ff9                	and	a5,a5,a4
    80019dd0:	faf43c23          	sd	a5,-72(s0)
    uint64_t num_bytes    = end_virt - start_virt;
    80019dd4:	fb843703          	ld	a4,-72(s0)
    80019dd8:	fc043783          	ld	a5,-64(s0)
    80019ddc:	40f707b3          	sub	a5,a4,a5
    80019de0:	fcf43c23          	sd	a5,-40(s0)
    // debugf("mmu_map_range: start_virt = 0x%08lx\n", start_virt);
    // debugf("mmu_map_range: start_phys = 0x%08lx\n", start_phys);
    // debugf("mmu_map_range: mapping = %d bytes\n", num_bytes);
    uint64_t pages_mapped = 0;
    80019de4:	fe043423          	sd	zero,-24(s0)

    uint64_t i;
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80019de8:	fe043023          	sd	zero,-32(s0)
    80019dec:	a0ad                	j	80019e56 <mmu_map_range+0x158>
        // debugf("mmu_map_range: mapping %d bytes for page %d\n", PAGE_SIZE_AT_LVL(lvl), i / PAGE_SIZE_AT_LVL(lvl));
        if (!mmu_map(tab, start_virt + i, start_phys + i, lvl, bits)) {
    80019dee:	fc043703          	ld	a4,-64(s0)
    80019df2:	fe043783          	ld	a5,-32(s0)
    80019df6:	00f705b3          	add	a1,a4,a5
    80019dfa:	fb043703          	ld	a4,-80(s0)
    80019dfe:	fe043783          	ld	a5,-32(s0)
    80019e02:	97ba                	add	a5,a5,a4
    80019e04:	faf44683          	lbu	a3,-81(s0)
    80019e08:	fa043703          	ld	a4,-96(s0)
    80019e0c:	863e                	mv	a2,a5
    80019e0e:	fc843503          	ld	a0,-56(s0)
    80019e12:	b19ff0ef          	jal	ra,8001992a <mmu_map>
    80019e16:	87aa                	mv	a5,a0
    80019e18:	0017c793          	xori	a5,a5,1
    80019e1c:	0ff7f793          	andi	a5,a5,255
    80019e20:	e3b1                	bnez	a5,80019e64 <mmu_map_range+0x166>
            break;
        }
        pages_mapped += 1;
    80019e22:	fe843783          	ld	a5,-24(s0)
    80019e26:	0785                	addi	a5,a5,1
    80019e28:	fef43423          	sd	a5,-24(s0)
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80019e2c:	faf44783          	lbu	a5,-81(s0)
    80019e30:	2781                	sext.w	a5,a5
    80019e32:	873e                	mv	a4,a5
    80019e34:	87ba                	mv	a5,a4
    80019e36:	0037979b          	slliw	a5,a5,0x3
    80019e3a:	9fb9                	addw	a5,a5,a4
    80019e3c:	2781                	sext.w	a5,a5
    80019e3e:	27b1                	addiw	a5,a5,12
    80019e40:	2781                	sext.w	a5,a5
    80019e42:	4705                	li	a4,1
    80019e44:	00f717bb          	sllw	a5,a4,a5
    80019e48:	2781                	sext.w	a5,a5
    80019e4a:	873e                	mv	a4,a5
    80019e4c:	fe043783          	ld	a5,-32(s0)
    80019e50:	97ba                	add	a5,a5,a4
    80019e52:	fef43023          	sd	a5,-32(s0)
    80019e56:	fe043703          	ld	a4,-32(s0)
    80019e5a:	fd843783          	ld	a5,-40(s0)
    80019e5e:	f8f768e3          	bltu	a4,a5,80019dee <mmu_map_range+0xf0>
    80019e62:	a011                	j	80019e66 <mmu_map_range+0x168>
            break;
    80019e64:	0001                	nop
    }
    // debugf("mmu_map_range: mapped %d pages\n", pages_mapped);
    SFENCE_ALL();
    80019e66:	12000073          	sfence.vma
    return pages_mapped;
    80019e6a:	fe843783          	ld	a5,-24(s0)
} 
    80019e6e:	853e                	mv	a0,a5
    80019e70:	60e6                	ld	ra,88(sp)
    80019e72:	6446                	ld	s0,80(sp)
    80019e74:	6125                	addi	sp,sp,96
    80019e76:	8082                	ret

0000000080019e78 <debug_page_table>:

// This function performs some basic sanity checks on the page table.
// For each level of the page table, it prints out the entries that are valid.
void debug_page_table(struct page_table *tab, uint8_t lvl) {
    80019e78:	715d                	addi	sp,sp,-80
    80019e7a:	e486                	sd	ra,72(sp)
    80019e7c:	e0a2                	sd	s0,64(sp)
    80019e7e:	0880                	addi	s0,sp,80
    80019e80:	faa43c23          	sd	a0,-72(s0)
    80019e84:	87ae                	mv	a5,a1
    80019e86:	faf40ba3          	sb	a5,-73(s0)
    // debugf("debug_page_table: debugging page table at 0x%016lx\n", tab);
    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    80019e8a:	fb744783          	lbu	a5,-73(s0)
    80019e8e:	2781                	sext.w	a5,a5
    80019e90:	873e                	mv	a4,a5
    80019e92:	87ba                	mv	a5,a4
    80019e94:	0037979b          	slliw	a5,a5,0x3
    80019e98:	9fb9                	addw	a5,a5,a4
    80019e9a:	2781                	sext.w	a5,a5
    80019e9c:	27b1                	addiw	a5,a5,12
    80019e9e:	2781                	sext.w	a5,a5
    80019ea0:	4705                	li	a4,1
    80019ea2:	00f717bb          	sllw	a5,a4,a5
    80019ea6:	2781                	sext.w	a5,a5
    80019ea8:	37fd                	addiw	a5,a5,-1
    80019eaa:	2781                	sext.w	a5,a5
    80019eac:	fef43023          	sd	a5,-32(s0)

    for (uint64_t i=0; i < 512; i++) {
    80019eb0:	fe043423          	sd	zero,-24(s0)
    80019eb4:	a21d                	j	80019fda <debug_page_table+0x162>
        // Is the entry a leaf?
        bool is_leaf = (tab->entries[i] & 0xE) != 0;
    80019eb6:	fb843703          	ld	a4,-72(s0)
    80019eba:	fe843783          	ld	a5,-24(s0)
    80019ebe:	078e                	slli	a5,a5,0x3
    80019ec0:	97ba                	add	a5,a5,a4
    80019ec2:	639c                	ld	a5,0(a5)
    80019ec4:	8bb9                	andi	a5,a5,14
    80019ec6:	00f037b3          	snez	a5,a5
    80019eca:	fcf40fa3          	sb	a5,-33(s0)

        // Is the entry valid?
        bool is_valid = tab->entries[i] & PB_VALID;
    80019ece:	fb843703          	ld	a4,-72(s0)
    80019ed2:	fe843783          	ld	a5,-24(s0)
    80019ed6:	078e                	slli	a5,a5,0x3
    80019ed8:	97ba                	add	a5,a5,a4
    80019eda:	639c                	ld	a5,0(a5)
    80019edc:	8b85                	andi	a5,a5,1
    80019ede:	00f037b3          	snez	a5,a5
    80019ee2:	fcf40f23          	sb	a5,-34(s0)

        // Is the entry a branch?
        bool is_branch = is_valid && !is_leaf;
    80019ee6:	fde44783          	lbu	a5,-34(s0)
    80019eea:	0ff7f793          	andi	a5,a5,255
    80019eee:	cb91                	beqz	a5,80019f02 <debug_page_table+0x8a>
    80019ef0:	fdf44783          	lbu	a5,-33(s0)
    80019ef4:	0017c793          	xori	a5,a5,1
    80019ef8:	0ff7f793          	andi	a5,a5,255
    80019efc:	c399                	beqz	a5,80019f02 <debug_page_table+0x8a>
    80019efe:	4785                	li	a5,1
    80019f00:	a011                	j	80019f04 <debug_page_table+0x8c>
    80019f02:	4781                	li	a5,0
    80019f04:	fcf40ea3          	sb	a5,-35(s0)
    80019f08:	fdd44783          	lbu	a5,-35(s0)
    80019f0c:	8b85                	andi	a5,a5,1
    80019f0e:	fcf40ea3          	sb	a5,-35(s0)

        uint64_t paddr = ((tab->entries[i] & ~0x3FF) << 2) & ~page_mask;
    80019f12:	fb843703          	ld	a4,-72(s0)
    80019f16:	fe843783          	ld	a5,-24(s0)
    80019f1a:	078e                	slli	a5,a5,0x3
    80019f1c:	97ba                	add	a5,a5,a4
    80019f1e:	639c                	ld	a5,0(a5)
    80019f20:	00279713          	slli	a4,a5,0x2
    80019f24:	fe043783          	ld	a5,-32(s0)
    80019f28:	fff7c793          	not	a5,a5
    80019f2c:	8f7d                	and	a4,a4,a5
    80019f2e:	77fd                	lui	a5,0xfffff
    80019f30:	8ff9                	and	a5,a5,a4
    80019f32:	fcf43823          	sd	a5,-48(s0)
        if (paddr == (uint64_t)tab) {
    80019f36:	fb843783          	ld	a5,-72(s0)
    80019f3a:	fd043703          	ld	a4,-48(s0)
    80019f3e:	08f70663          	beq	a4,a5,80019fca <debug_page_table+0x152>
            continue;
        }

        uint64_t vaddr = paddr;
    80019f42:	fd043783          	ld	a5,-48(s0)
    80019f46:	fcf43423          	sd	a5,-56(s0)
        if (is_valid && is_leaf) {
    80019f4a:	fde44783          	lbu	a5,-34(s0)
    80019f4e:	0ff7f793          	andi	a5,a5,255
    80019f52:	cf9d                	beqz	a5,80019f90 <debug_page_table+0x118>
    80019f54:	fdf44783          	lbu	a5,-33(s0)
    80019f58:	0ff7f793          	andi	a5,a5,255
    80019f5c:	cb95                	beqz	a5,80019f90 <debug_page_table+0x118>
            // Confirm that we can translate the address
            uint64_t translated = mmu_translate(tab, vaddr);
    80019f5e:	fc843583          	ld	a1,-56(s0)
    80019f62:	fb843503          	ld	a0,-72(s0)
    80019f66:	befff0ef          	jal	ra,80019b54 <mmu_translate>
    80019f6a:	fca43023          	sd	a0,-64(s0)
            if (translated != paddr) {
    80019f6e:	fc043703          	ld	a4,-64(s0)
    80019f72:	fd043783          	ld	a5,-48(s0)
    80019f76:	04f70c63          	beq	a4,a5,80019fce <debug_page_table+0x156>
                // debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                // debugf("debug_page_table: expected 0x%08lx, got 0x%08lx\n", paddr, translated);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    80019f7a:	fb843603          	ld	a2,-72(s0)
    80019f7e:	fe843583          	ld	a1,-24(s0)
    80019f82:	0000b517          	auipc	a0,0xb
    80019f86:	65650513          	addi	a0,a0,1622 # 800255d8 <pow10.0+0x13a8>
    80019f8a:	b7aff0ef          	jal	ra,80019304 <fatalf>
        if (is_valid && is_leaf) {
    80019f8e:	a081                	j	80019fce <debug_page_table+0x156>
            } else {
                // debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
            }
        } else if (is_branch && lvl > MMU_LEVEL_4K) {
    80019f90:	fdd44783          	lbu	a5,-35(s0)
    80019f94:	0ff7f793          	andi	a5,a5,255
    80019f98:	c791                	beqz	a5,80019fa4 <debug_page_table+0x12c>
    80019f9a:	fb744783          	lbu	a5,-73(s0)
    80019f9e:	0ff7f793          	andi	a5,a5,255
    80019fa2:	e79d                	bnez	a5,80019fd0 <debug_page_table+0x158>
            // Recurse into the next level
            // debugf("debug_page_table: entry %d in page table at 0x%08lx is a branch to 0x%08lx\n", i, tab, (tab->entries[i] & ~0x3FF) << 2);
            // debug_page_table((struct page_table *)((tab->entries[i] & ~0x3FF) << 2), lvl - 1);
        } else {
            // Invalid entry, confirm that it's all zeroes
            if (tab->entries[i] != 0) {
    80019fa4:	fb843703          	ld	a4,-72(s0)
    80019fa8:	fe843783          	ld	a5,-24(s0)
    80019fac:	078e                	slli	a5,a5,0x3
    80019fae:	97ba                	add	a5,a5,a4
    80019fb0:	639c                	ld	a5,0(a5)
    80019fb2:	cf99                	beqz	a5,80019fd0 <debug_page_table+0x158>
                // debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                // debugf("debug_page_table: expected all zeroes, got 0x%08lx\n", tab->entries[i]);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    80019fb4:	fb843603          	ld	a2,-72(s0)
    80019fb8:	fe843583          	ld	a1,-24(s0)
    80019fbc:	0000b517          	auipc	a0,0xb
    80019fc0:	61c50513          	addi	a0,a0,1564 # 800255d8 <pow10.0+0x13a8>
    80019fc4:	b40ff0ef          	jal	ra,80019304 <fatalf>
    80019fc8:	a021                	j	80019fd0 <debug_page_table+0x158>
            continue;
    80019fca:	0001                	nop
    80019fcc:	a011                	j	80019fd0 <debug_page_table+0x158>
        if (is_valid && is_leaf) {
    80019fce:	0001                	nop
    for (uint64_t i=0; i < 512; i++) {
    80019fd0:	fe843783          	ld	a5,-24(s0)
    80019fd4:	0785                	addi	a5,a5,1
    80019fd6:	fef43423          	sd	a5,-24(s0)
    80019fda:	fe843703          	ld	a4,-24(s0)
    80019fde:	1ff00793          	li	a5,511
    80019fe2:	ece7fae3          	bgeu	a5,a4,80019eb6 <debug_page_table+0x3e>
            }
        }
    }

    // debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
}
    80019fe6:	0001                	nop
    80019fe8:	0001                	nop
    80019fea:	60a6                	ld	ra,72(sp)
    80019fec:	6406                	ld	s0,64(sp)
    80019fee:	6161                	addi	sp,sp,80
    80019ff0:	8082                	ret

0000000080019ff2 <virtio_create_job>:



static Vector *virtio_devices = NULL;

void virtio_create_job(VirtioDevice *dev, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job)) {
    80019ff2:	7179                	addi	sp,sp,-48
    80019ff4:	f406                	sd	ra,40(sp)
    80019ff6:	f022                	sd	s0,32(sp)
    80019ff8:	1800                	addi	s0,sp,48
    80019ffa:	fea43423          	sd	a0,-24(s0)
    80019ffe:	feb43023          	sd	a1,-32(s0)
    8001a002:	fcc43c23          	sd	a2,-40(s0)
    virtio_create_job_with_data(dev, pid_id, callback, NULL);
    8001a006:	4681                	li	a3,0
    8001a008:	fd843603          	ld	a2,-40(s0)
    8001a00c:	fe043583          	ld	a1,-32(s0)
    8001a010:	fe843503          	ld	a0,-24(s0)
    8001a014:	00e000ef          	jal	ra,8001a022 <virtio_create_job_with_data>
}
    8001a018:	0001                	nop
    8001a01a:	70a2                	ld	ra,40(sp)
    8001a01c:	7402                	ld	s0,32(sp)
    8001a01e:	6145                	addi	sp,sp,48
    8001a020:	8082                	ret

000000008001a022 <virtio_create_job_with_data>:

void virtio_create_job_with_data(VirtioDevice *dev, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job), void *data) {
    8001a022:	7171                	addi	sp,sp,-176
    8001a024:	f506                	sd	ra,168(sp)
    8001a026:	f122                	sd	s0,160(sp)
    8001a028:	1900                	addi	s0,sp,176
    8001a02a:	faa43423          	sd	a0,-88(s0)
    8001a02e:	fab43023          	sd	a1,-96(s0)
    8001a032:	f8c43c23          	sd	a2,-104(s0)
    8001a036:	f8d43823          	sd	a3,-112(s0)
    Job job = job_create(virtio_get_next_job_id(dev), pid_id, callback);
    8001a03a:	fa843503          	ld	a0,-88(s0)
    8001a03e:	46c000ef          	jal	ra,8001a4aa <virtio_get_next_job_id>
    8001a042:	872a                	mv	a4,a0
    8001a044:	fb840793          	addi	a5,s0,-72
    8001a048:	f9843683          	ld	a3,-104(s0)
    8001a04c:	fa043603          	ld	a2,-96(s0)
    8001a050:	85ba                	mv	a1,a4
    8001a052:	853e                	mv	a0,a5
    8001a054:	0d6000ef          	jal	ra,8001a12a <job_create>
    job.data = data;
    8001a058:	f9043783          	ld	a5,-112(s0)
    8001a05c:	fef43423          	sd	a5,-24(s0)
    virtio_add_job(dev, job);
    8001a060:	fb843803          	ld	a6,-72(s0)
    8001a064:	fc043503          	ld	a0,-64(s0)
    8001a068:	fc843583          	ld	a1,-56(s0)
    8001a06c:	fd043603          	ld	a2,-48(s0)
    8001a070:	fd843683          	ld	a3,-40(s0)
    8001a074:	fe043703          	ld	a4,-32(s0)
    8001a078:	fe843783          	ld	a5,-24(s0)
    8001a07c:	f5043823          	sd	a6,-176(s0)
    8001a080:	f4a43c23          	sd	a0,-168(s0)
    8001a084:	f6b43023          	sd	a1,-160(s0)
    8001a088:	f6c43423          	sd	a2,-152(s0)
    8001a08c:	f6d43823          	sd	a3,-144(s0)
    8001a090:	f6e43c23          	sd	a4,-136(s0)
    8001a094:	f8f43023          	sd	a5,-128(s0)
    8001a098:	f5040793          	addi	a5,s0,-176
    8001a09c:	85be                	mv	a1,a5
    8001a09e:	fa843503          	ld	a0,-88(s0)
    8001a0a2:	29c000ef          	jal	ra,8001a33e <virtio_add_job>
}
    8001a0a6:	0001                	nop
    8001a0a8:	70aa                	ld	ra,168(sp)
    8001a0aa:	740a                	ld	s0,160(sp)
    8001a0ac:	614d                	addi	sp,sp,176
    8001a0ae:	8082                	ret

000000008001a0b0 <virtio_get_job>:

Job *virtio_get_job(VirtioDevice *dev, uint64_t job_id) {
    8001a0b0:	7179                	addi	sp,sp,-48
    8001a0b2:	f406                	sd	ra,40(sp)
    8001a0b4:	f022                	sd	s0,32(sp)
    8001a0b6:	1800                	addi	s0,sp,48
    8001a0b8:	fca43c23          	sd	a0,-40(s0)
    8001a0bc:	fcb43823          	sd	a1,-48(s0)
    for (uint64_t i=0; i<vector_size(dev->jobs); i++) {
    8001a0c0:	fe043423          	sd	zero,-24(s0)
    8001a0c4:	a83d                	j	8001a102 <virtio_get_job+0x52>
        Job *job = NULL;
    8001a0c6:	fe043023          	sd	zero,-32(s0)
        vector_get_ptr(dev->jobs, i, &job);
    8001a0ca:	fd843783          	ld	a5,-40(s0)
    8001a0ce:	63dc                	ld	a5,128(a5)
    8001a0d0:	fe843703          	ld	a4,-24(s0)
    8001a0d4:	2701                	sext.w	a4,a4
    8001a0d6:	fe040693          	addi	a3,s0,-32
    8001a0da:	8636                	mv	a2,a3
    8001a0dc:	85ba                	mv	a1,a4
    8001a0de:	853e                	mv	a0,a5
    8001a0e0:	0df060ef          	jal	ra,800209be <vector_get>
        if (job->job_id == job_id) {
    8001a0e4:	fe043783          	ld	a5,-32(s0)
    8001a0e8:	639c                	ld	a5,0(a5)
    8001a0ea:	fd043703          	ld	a4,-48(s0)
    8001a0ee:	00f71563          	bne	a4,a5,8001a0f8 <virtio_get_job+0x48>
            return job;
    8001a0f2:	fe043783          	ld	a5,-32(s0)
    8001a0f6:	a02d                	j	8001a120 <virtio_get_job+0x70>
    for (uint64_t i=0; i<vector_size(dev->jobs); i++) {
    8001a0f8:	fe843783          	ld	a5,-24(s0)
    8001a0fc:	0785                	addi	a5,a5,1
    8001a0fe:	fef43423          	sd	a5,-24(s0)
    8001a102:	fd843783          	ld	a5,-40(s0)
    8001a106:	63dc                	ld	a5,128(a5)
    8001a108:	853e                	mv	a0,a5
    8001a10a:	014070ef          	jal	ra,8002111e <vector_size>
    8001a10e:	87aa                	mv	a5,a0
    8001a110:	2781                	sext.w	a5,a5
    8001a112:	1782                	slli	a5,a5,0x20
    8001a114:	9381                	srli	a5,a5,0x20
    8001a116:	fe843703          	ld	a4,-24(s0)
    8001a11a:	faf766e3          	bltu	a4,a5,8001a0c6 <virtio_get_job+0x16>
        }
    }
    debugf("No job found with ID %d\n", job_id);
    return NULL;
    8001a11e:	4781                	li	a5,0
}
    8001a120:	853e                	mv	a0,a5
    8001a122:	70a2                	ld	ra,40(sp)
    8001a124:	7402                	ld	s0,32(sp)
    8001a126:	6145                	addi	sp,sp,48
    8001a128:	8082                	ret

000000008001a12a <job_create>:

Job job_create(uint64_t job_id, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job)) {
    8001a12a:	7179                	addi	sp,sp,-48
    8001a12c:	f406                	sd	ra,40(sp)
    8001a12e:	f022                	sd	s0,32(sp)
    8001a130:	1800                	addi	s0,sp,48
    8001a132:	fea43423          	sd	a0,-24(s0)
    8001a136:	feb43023          	sd	a1,-32(s0)
    8001a13a:	fcc43c23          	sd	a2,-40(s0)
    8001a13e:	fcd43823          	sd	a3,-48(s0)
    return job_create_with_data(job_id, pid_id, callback, NULL);
    8001a142:	fe843783          	ld	a5,-24(s0)
    8001a146:	4701                	li	a4,0
    8001a148:	fd043683          	ld	a3,-48(s0)
    8001a14c:	fd843603          	ld	a2,-40(s0)
    8001a150:	fe043583          	ld	a1,-32(s0)
    8001a154:	853e                	mv	a0,a5
    8001a156:	010000ef          	jal	ra,8001a166 <job_create_with_data>
}
    8001a15a:	fe843503          	ld	a0,-24(s0)
    8001a15e:	70a2                	ld	ra,40(sp)
    8001a160:	7402                	ld	s0,32(sp)
    8001a162:	6145                	addi	sp,sp,48
    8001a164:	8082                	ret

000000008001a166 <job_create_with_data>:

Job job_create_with_data(uint64_t job_id, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job), void *data) {
    8001a166:	7119                	addi	sp,sp,-128
    8001a168:	fca2                	sd	s0,120(sp)
    8001a16a:	0100                	addi	s0,sp,128
    8001a16c:	faa43423          	sd	a0,-88(s0)
    8001a170:	fab43023          	sd	a1,-96(s0)
    8001a174:	f8c43c23          	sd	a2,-104(s0)
    8001a178:	f8d43823          	sd	a3,-112(s0)
    8001a17c:	f8e43423          	sd	a4,-120(s0)
    Job job;
    job.job_id = job_id;
    8001a180:	fa043783          	ld	a5,-96(s0)
    8001a184:	faf43c23          	sd	a5,-72(s0)
    job.pid_id = pid_id;
    8001a188:	f9843783          	ld	a5,-104(s0)
    8001a18c:	fcf43023          	sd	a5,-64(s0)
    job.callback = callback;
    8001a190:	f9043783          	ld	a5,-112(s0)
    8001a194:	fef43023          	sd	a5,-32(s0)
    job.done = false;
    8001a198:	fc040423          	sb	zero,-56(s0)
    job.data = data;
    8001a19c:	f8843783          	ld	a5,-120(s0)
    8001a1a0:	fef43423          	sd	a5,-24(s0)
    return job;
    8001a1a4:	fa843783          	ld	a5,-88(s0)
    8001a1a8:	fb843883          	ld	a7,-72(s0)
    8001a1ac:	fc043803          	ld	a6,-64(s0)
    8001a1b0:	fc843503          	ld	a0,-56(s0)
    8001a1b4:	fd043583          	ld	a1,-48(s0)
    8001a1b8:	fd843603          	ld	a2,-40(s0)
    8001a1bc:	fe043683          	ld	a3,-32(s0)
    8001a1c0:	fe843703          	ld	a4,-24(s0)
    8001a1c4:	0117b023          	sd	a7,0(a5) # fffffffffffff000 <_heap_end+0xffffffff77fef000>
    8001a1c8:	0107b423          	sd	a6,8(a5)
    8001a1cc:	eb88                	sd	a0,16(a5)
    8001a1ce:	ef8c                	sd	a1,24(a5)
    8001a1d0:	f390                	sd	a2,32(a5)
    8001a1d2:	f794                	sd	a3,40(a5)
    8001a1d4:	fb98                	sd	a4,48(a5)
}
    8001a1d6:	fa843503          	ld	a0,-88(s0)
    8001a1da:	7466                	ld	s0,120(sp)
    8001a1dc:	6109                	addi	sp,sp,128
    8001a1de:	8082                	ret

000000008001a1e0 <job_set_context>:

void job_set_context(Job *job, VirtioDescriptor *desc, uint16_t num_descriptors) {
    8001a1e0:	7179                	addi	sp,sp,-48
    8001a1e2:	f422                	sd	s0,40(sp)
    8001a1e4:	1800                	addi	s0,sp,48
    8001a1e6:	fea43423          	sd	a0,-24(s0)
    8001a1ea:	feb43023          	sd	a1,-32(s0)
    8001a1ee:	87b2                	mv	a5,a2
    8001a1f0:	fcf41f23          	sh	a5,-34(s0)
    if (job == NULL) {
    8001a1f4:	fe843783          	ld	a5,-24(s0)
    8001a1f8:	cf89                	beqz	a5,8001a212 <job_set_context+0x32>
        debugf("No job\n");
        return;
    }
    job->context.desc = desc;
    8001a1fa:	fe843783          	ld	a5,-24(s0)
    8001a1fe:	fe043703          	ld	a4,-32(s0)
    8001a202:	ef98                	sd	a4,24(a5)
    job->context.num_descriptors = num_descriptors;
    8001a204:	fe843783          	ld	a5,-24(s0)
    8001a208:	fde45703          	lhu	a4,-34(s0)
    8001a20c:	02e79023          	sh	a4,32(a5)
    8001a210:	a011                	j	8001a214 <job_set_context+0x34>
        return;
    8001a212:	0001                	nop
}
    8001a214:	7422                	ld	s0,40(sp)
    8001a216:	6145                	addi	sp,sp,48
    8001a218:	8082                	ret

000000008001a21a <job_destroy>:

void job_destroy(Job *job) {
    8001a21a:	1101                	addi	sp,sp,-32
    8001a21c:	ec06                	sd	ra,24(sp)
    8001a21e:	e822                	sd	s0,16(sp)
    8001a220:	1000                	addi	s0,sp,32
    8001a222:	fea43423          	sd	a0,-24(s0)
    if (job->data != NULL) {
    8001a226:	fe843783          	ld	a5,-24(s0)
    8001a22a:	7b9c                	ld	a5,48(a5)
    8001a22c:	c799                	beqz	a5,8001a23a <job_destroy+0x20>
        debugf("About to free non-nulled Job data\n");
        kfree(job->data);
    8001a22e:	fe843783          	ld	a5,-24(s0)
    8001a232:	7b9c                	ld	a5,48(a5)
    8001a234:	853e                	mv	a0,a5
    8001a236:	aa9f90ef          	jal	ra,80013cde <kfree>
    }

    if (job != NULL) {
    8001a23a:	fe843783          	ld	a5,-24(s0)
    8001a23e:	c789                	beqz	a5,8001a248 <job_destroy+0x2e>
        kfree(job);
    8001a240:	fe843503          	ld	a0,-24(s0)
    8001a244:	a9bf90ef          	jal	ra,80013cde <kfree>
    }
}
    8001a248:	0001                	nop
    8001a24a:	60e2                	ld	ra,24(sp)
    8001a24c:	6442                	ld	s0,16(sp)
    8001a24e:	6105                	addi	sp,sp,32
    8001a250:	8082                	ret

000000008001a252 <virtio_callback_and_free_job>:

void virtio_callback_and_free_job(VirtioDevice *dev, uint64_t job_id) {
    8001a252:	7179                	addi	sp,sp,-48
    8001a254:	f406                	sd	ra,40(sp)
    8001a256:	f022                	sd	s0,32(sp)
    8001a258:	1800                	addi	s0,sp,48
    8001a25a:	fca43c23          	sd	a0,-40(s0)
    8001a25e:	fcb43823          	sd	a1,-48(s0)
    Job *job = virtio_get_job(dev, job_id);
    8001a262:	fd043583          	ld	a1,-48(s0)
    8001a266:	fd843503          	ld	a0,-40(s0)
    8001a26a:	e47ff0ef          	jal	ra,8001a0b0 <virtio_get_job>
    8001a26e:	fea43423          	sd	a0,-24(s0)
    if (job == NULL) {
    8001a272:	fe843783          	ld	a5,-24(s0)
    8001a276:	c79d                	beqz	a5,8001a2a4 <virtio_callback_and_free_job+0x52>
        debugf("No job\n");
        return;
    }
    job->done = true;
    8001a278:	fe843783          	ld	a5,-24(s0)
    8001a27c:	4705                	li	a4,1
    8001a27e:	00e78823          	sb	a4,16(a5)
    if (job->callback != NULL) {
    8001a282:	fe843783          	ld	a5,-24(s0)
    8001a286:	779c                	ld	a5,40(a5)
    8001a288:	cb89                	beqz	a5,8001a29a <virtio_callback_and_free_job+0x48>
        job->callback(dev, job);
    8001a28a:	fe843783          	ld	a5,-24(s0)
    8001a28e:	779c                	ld	a5,40(a5)
    8001a290:	fe843583          	ld	a1,-24(s0)
    8001a294:	fd843503          	ld	a0,-40(s0)
    8001a298:	9782                	jalr	a5
    } else {
        debugf("No callback for job\n");
    }

    job_destroy(job);
    8001a29a:	fe843503          	ld	a0,-24(s0)
    8001a29e:	f7dff0ef          	jal	ra,8001a21a <job_destroy>
    8001a2a2:	a011                	j	8001a2a6 <virtio_callback_and_free_job+0x54>
        return;
    8001a2a4:	0001                	nop
}
    8001a2a6:	70a2                	ld	ra,40(sp)
    8001a2a8:	7402                	ld	s0,32(sp)
    8001a2aa:	6145                	addi	sp,sp,48
    8001a2ac:	8082                	ret

000000008001a2ae <virtio_is_device_available>:

bool virtio_is_device_available(VirtioDevice *dev) {
    8001a2ae:	1101                	addi	sp,sp,-32
    8001a2b0:	ec22                	sd	s0,24(sp)
    8001a2b2:	1000                	addi	s0,sp,32
    8001a2b4:	fea43423          	sd	a0,-24(s0)
    return dev->lock == MUTEX_UNLOCKED;
    8001a2b8:	fe843783          	ld	a5,-24(s0)
    8001a2bc:	0907a783          	lw	a5,144(a5)
    8001a2c0:	0017b793          	seqz	a5,a5
    8001a2c4:	0ff7f793          	andi	a5,a5,255
}
    8001a2c8:	853e                	mv	a0,a5
    8001a2ca:	6462                	ld	s0,24(sp)
    8001a2cc:	6105                	addi	sp,sp,32
    8001a2ce:	8082                	ret

000000008001a2d0 <virtio_acquire_device>:

void virtio_acquire_device(VirtioDevice *dev) {
    8001a2d0:	7179                	addi	sp,sp,-48
    8001a2d2:	f406                	sd	ra,40(sp)
    8001a2d4:	f022                	sd	s0,32(sp)
    8001a2d6:	1800                	addi	s0,sp,48
    8001a2d8:	fca43c23          	sd	a0,-40(s0)
    IRQ_OFF();
    8001a2dc:	100027f3          	csrr	a5,sstatus
    8001a2e0:	fef43423          	sd	a5,-24(s0)
    8001a2e4:	fe843783          	ld	a5,-24(s0)
    8001a2e8:	9bf5                	andi	a5,a5,-3
    8001a2ea:	10079073          	csrw	sstatus,a5
    debugf("Acquiring device %p\n", dev);
    mutex_spinlock(&dev->lock);
    8001a2ee:	fd843783          	ld	a5,-40(s0)
    8001a2f2:	09078793          	addi	a5,a5,144
    8001a2f6:	853e                	mv	a0,a5
    8001a2f8:	aa7f90ef          	jal	ra,80013d9e <mutex_spinlock>
}
    8001a2fc:	0001                	nop
    8001a2fe:	70a2                	ld	ra,40(sp)
    8001a300:	7402                	ld	s0,32(sp)
    8001a302:	6145                	addi	sp,sp,48
    8001a304:	8082                	ret

000000008001a306 <virtio_release_device>:

void virtio_release_device(VirtioDevice *dev) {
    8001a306:	7179                	addi	sp,sp,-48
    8001a308:	f406                	sd	ra,40(sp)
    8001a30a:	f022                	sd	s0,32(sp)
    8001a30c:	1800                	addi	s0,sp,48
    8001a30e:	fca43c23          	sd	a0,-40(s0)
    mutex_unlock(&dev->lock);
    8001a312:	fd843783          	ld	a5,-40(s0)
    8001a316:	09078793          	addi	a5,a5,144
    8001a31a:	853e                	mv	a0,a5
    8001a31c:	ab1f90ef          	jal	ra,80013dcc <mutex_unlock>
    debugf("Releasing device %p\n", dev);
    IRQ_ON();
    8001a320:	100027f3          	csrr	a5,sstatus
    8001a324:	fef43423          	sd	a5,-24(s0)
    8001a328:	fe843783          	ld	a5,-24(s0)
    8001a32c:	0027e793          	ori	a5,a5,2
    8001a330:	10079073          	csrw	sstatus,a5
}
    8001a334:	0001                	nop
    8001a336:	70a2                	ld	ra,40(sp)
    8001a338:	7402                	ld	s0,32(sp)
    8001a33a:	6145                	addi	sp,sp,48
    8001a33c:	8082                	ret

000000008001a33e <virtio_add_job>:

void virtio_add_job(VirtioDevice *dev, Job job) {
    8001a33e:	7139                	addi	sp,sp,-64
    8001a340:	fc06                	sd	ra,56(sp)
    8001a342:	f822                	sd	s0,48(sp)
    8001a344:	f426                	sd	s1,40(sp)
    8001a346:	0080                	addi	s0,sp,64
    8001a348:	fca43423          	sd	a0,-56(s0)
    8001a34c:	84ae                	mv	s1,a1
    Job *mem = (Job *)kzalloc(sizeof(Job));
    8001a34e:	03800593          	li	a1,56
    8001a352:	4505                	li	a0,1
    8001a354:	963f90ef          	jal	ra,80013cb6 <kcalloc>
    8001a358:	fca43c23          	sd	a0,-40(s0)
    memcpy(mem, &job, sizeof(Job));
    8001a35c:	03800613          	li	a2,56
    8001a360:	85a6                	mv	a1,s1
    8001a362:	fd843503          	ld	a0,-40(s0)
    8001a366:	309050ef          	jal	ra,8001fe6e <memcpy>
    vector_push_ptr(dev->jobs, mem);
    8001a36a:	fc843783          	ld	a5,-56(s0)
    8001a36e:	63dc                	ld	a5,128(a5)
    8001a370:	fd843703          	ld	a4,-40(s0)
    8001a374:	85ba                	mv	a1,a4
    8001a376:	853e                	mv	a0,a5
    8001a378:	4e6060ef          	jal	ra,8002085e <vector_push>
}
    8001a37c:	0001                	nop
    8001a37e:	70e2                	ld	ra,56(sp)
    8001a380:	7442                	ld	s0,48(sp)
    8001a382:	74a2                	ld	s1,40(sp)
    8001a384:	6121                	addi	sp,sp,64
    8001a386:	8082                	ret

000000008001a388 <virtio_debug_job>:
//         }
//     }
//     return NULL;
// }

void virtio_debug_job(VirtioDevice *dev, Job *job) {
    8001a388:	7179                	addi	sp,sp,-48
    8001a38a:	f422                	sd	s0,40(sp)
    8001a38c:	1800                	addi	s0,sp,48
    8001a38e:	fca43c23          	sd	a0,-40(s0)
    8001a392:	fcb43823          	sd	a1,-48(s0)
    debugf("Done %d\n", job->done);
    debugf("Data %p\n", job->data);
    debugf("Context\n");
    debugf("  Num descriptors %d\n", job->context.num_descriptors);
    debugf("  Descriptors\n");
    for (uint16_t i=0; i<job->context.num_descriptors; i++) {
    8001a396:	fe041723          	sh	zero,-18(s0)
    8001a39a:	a031                	j	8001a3a6 <virtio_debug_job+0x1e>
    8001a39c:	fee45783          	lhu	a5,-18(s0)
    8001a3a0:	2785                	addiw	a5,a5,1
    8001a3a2:	fef41723          	sh	a5,-18(s0)
    8001a3a6:	fd043783          	ld	a5,-48(s0)
    8001a3aa:	0207d783          	lhu	a5,32(a5)
    8001a3ae:	fee45703          	lhu	a4,-18(s0)
    8001a3b2:	2701                	sext.w	a4,a4
    8001a3b4:	2781                	sext.w	a5,a5
    8001a3b6:	fef763e3          	bltu	a4,a5,8001a39c <virtio_debug_job+0x14>
        debugf("      addr: %p\n", job->context.desc[i].addr);
        debugf("      len: %d\n", job->context.desc[i].len);
        debugf("      flags: %d\n", job->context.desc[i].flags);
        debugf("      next: %d\n", job->context.desc[i].next);
    }
}
    8001a3ba:	0001                	nop
    8001a3bc:	0001                	nop
    8001a3be:	7422                	ld	s0,40(sp)
    8001a3c0:	6145                	addi	sp,sp,48
    8001a3c2:	8082                	ret

000000008001a3c4 <virtio_handle_interrupt>:

void virtio_handle_interrupt(VirtioDevice *dev, VirtioDescriptor desc[], uint16_t num_descriptors) {
    8001a3c4:	7139                	addi	sp,sp,-64
    8001a3c6:	fc06                	sd	ra,56(sp)
    8001a3c8:	f822                	sd	s0,48(sp)
    8001a3ca:	0080                	addi	s0,sp,64
    8001a3cc:	fca43c23          	sd	a0,-40(s0)
    8001a3d0:	fcb43823          	sd	a1,-48(s0)
    8001a3d4:	87b2                	mv	a5,a2
    8001a3d6:	fcf41723          	sh	a5,-50(s0)
    uint64_t job_id = virtio_which_job_from_interrupt(dev);
    8001a3da:	fd843503          	ld	a0,-40(s0)
    8001a3de:	052000ef          	jal	ra,8001a430 <virtio_which_job_from_interrupt>
    8001a3e2:	fea43423          	sd	a0,-24(s0)
    if (job_id == -1ULL) {
    8001a3e6:	fe843703          	ld	a4,-24(s0)
    8001a3ea:	57fd                	li	a5,-1
    8001a3ec:	00f71963          	bne	a4,a5,8001a3fe <virtio_handle_interrupt+0x3a>
        warnf("No job found matching interrupt\n");
    8001a3f0:	0000b517          	auipc	a0,0xb
    8001a3f4:	23050513          	addi	a0,a0,560 # 80025620 <pow10.0+0x13f0>
    8001a3f8:	e09fe0ef          	jal	ra,80019200 <warnf>
        return;
    8001a3fc:	a035                	j	8001a428 <virtio_handle_interrupt+0x64>
    }

    job_set_context(virtio_get_job(dev, job_id), desc, num_descriptors);
    8001a3fe:	fe843583          	ld	a1,-24(s0)
    8001a402:	fd843503          	ld	a0,-40(s0)
    8001a406:	cabff0ef          	jal	ra,8001a0b0 <virtio_get_job>
    8001a40a:	872a                	mv	a4,a0
    8001a40c:	fce45783          	lhu	a5,-50(s0)
    8001a410:	863e                	mv	a2,a5
    8001a412:	fd043583          	ld	a1,-48(s0)
    8001a416:	853a                	mv	a0,a4
    8001a418:	dc9ff0ef          	jal	ra,8001a1e0 <job_set_context>

    virtio_complete_job(dev, job_id);
    8001a41c:	fe843583          	ld	a1,-24(s0)
    8001a420:	fd843503          	ld	a0,-40(s0)
    8001a424:	0a0000ef          	jal	ra,8001a4c4 <virtio_complete_job>
}
    8001a428:	70e2                	ld	ra,56(sp)
    8001a42a:	7442                	ld	s0,48(sp)
    8001a42c:	6121                	addi	sp,sp,64
    8001a42e:	8082                	ret

000000008001a430 <virtio_which_job_from_interrupt>:

uint64_t virtio_which_job_from_interrupt(VirtioDevice *dev) {
    8001a430:	1101                	addi	sp,sp,-32
    8001a432:	ec22                	sd	s0,24(sp)
    8001a434:	1000                	addi	s0,sp,32
    8001a436:	fea43423          	sd	a0,-24(s0)
    // Get the ID of the job from the descriptor
    return (uint64_t)dev->device_idx - 1;
    8001a43a:	fe843783          	ld	a5,-24(s0)
    8001a43e:	08c7d783          	lhu	a5,140(a5)
    8001a442:	17fd                	addi	a5,a5,-1
}
    8001a444:	853e                	mv	a0,a5
    8001a446:	6462                	ld	s0,24(sp)
    8001a448:	6105                	addi	sp,sp,32
    8001a44a:	8082                	ret

000000008001a44c <virtio_get_job_id_by_index>:

uint64_t virtio_get_job_id_by_index(VirtioDevice *dev, uint64_t index) {
    8001a44c:	7179                	addi	sp,sp,-48
    8001a44e:	f406                	sd	ra,40(sp)
    8001a450:	f022                	sd	s0,32(sp)
    8001a452:	1800                	addi	s0,sp,48
    8001a454:	fca43c23          	sd	a0,-40(s0)
    8001a458:	fcb43823          	sd	a1,-48(s0)
    Job *job = NULL;
    8001a45c:	fe043423          	sd	zero,-24(s0)
    if (index >= vector_size(dev->jobs)) {
    8001a460:	fd843783          	ld	a5,-40(s0)
    8001a464:	63dc                	ld	a5,128(a5)
    8001a466:	853e                	mv	a0,a5
    8001a468:	4b7060ef          	jal	ra,8002111e <vector_size>
    8001a46c:	87aa                	mv	a5,a0
    8001a46e:	2781                	sext.w	a5,a5
    8001a470:	1782                	slli	a5,a5,0x20
    8001a472:	9381                	srli	a5,a5,0x20
    8001a474:	fd043703          	ld	a4,-48(s0)
    8001a478:	00f76463          	bltu	a4,a5,8001a480 <virtio_get_job_id_by_index+0x34>
        return -1ULL;
    8001a47c:	57fd                	li	a5,-1
    8001a47e:	a00d                	j	8001a4a0 <virtio_get_job_id_by_index+0x54>
    }

    vector_get_ptr(dev->jobs, index, &job);
    8001a480:	fd843783          	ld	a5,-40(s0)
    8001a484:	63dc                	ld	a5,128(a5)
    8001a486:	fd043703          	ld	a4,-48(s0)
    8001a48a:	2701                	sext.w	a4,a4
    8001a48c:	fe840693          	addi	a3,s0,-24
    8001a490:	8636                	mv	a2,a3
    8001a492:	85ba                	mv	a1,a4
    8001a494:	853e                	mv	a0,a5
    8001a496:	528060ef          	jal	ra,800209be <vector_get>
    return job->job_id;
    8001a49a:	fe843783          	ld	a5,-24(s0)
    8001a49e:	639c                	ld	a5,0(a5)
}
    8001a4a0:	853e                	mv	a0,a5
    8001a4a2:	70a2                	ld	ra,40(sp)
    8001a4a4:	7402                	ld	s0,32(sp)
    8001a4a6:	6145                	addi	sp,sp,48
    8001a4a8:	8082                	ret

000000008001a4aa <virtio_get_next_job_id>:

uint64_t virtio_get_next_job_id(VirtioDevice *dev) {
    8001a4aa:	1101                	addi	sp,sp,-32
    8001a4ac:	ec22                	sd	s0,24(sp)
    8001a4ae:	1000                	addi	s0,sp,32
    8001a4b0:	fea43423          	sd	a0,-24(s0)
    return (uint64_t)dev->device_idx;
    8001a4b4:	fe843783          	ld	a5,-24(s0)
    8001a4b8:	08c7d783          	lhu	a5,140(a5)
}
    8001a4bc:	853e                	mv	a0,a5
    8001a4be:	6462                	ld	s0,24(sp)
    8001a4c0:	6105                	addi	sp,sp,32
    8001a4c2:	8082                	ret

000000008001a4c4 <virtio_complete_job>:

void virtio_complete_job(VirtioDevice *dev, uint64_t job_id) {
    8001a4c4:	7179                	addi	sp,sp,-48
    8001a4c6:	f406                	sd	ra,40(sp)
    8001a4c8:	f022                	sd	s0,32(sp)
    8001a4ca:	1800                	addi	s0,sp,48
    8001a4cc:	fca43c23          	sd	a0,-40(s0)
    8001a4d0:	fcb43823          	sd	a1,-48(s0)
    virtio_acquire_device(dev);
    8001a4d4:	fd843503          	ld	a0,-40(s0)
    8001a4d8:	df9ff0ef          	jal	ra,8001a2d0 <virtio_acquire_device>
    Job *job = virtio_get_job(dev, job_id);
    8001a4dc:	fd043583          	ld	a1,-48(s0)
    8001a4e0:	fd843503          	ld	a0,-40(s0)
    8001a4e4:	bcdff0ef          	jal	ra,8001a0b0 <virtio_get_job>
    8001a4e8:	fea43423          	sd	a0,-24(s0)
    if (job == NULL) {
    8001a4ec:	fe843783          	ld	a5,-24(s0)
    8001a4f0:	ef91                	bnez	a5,8001a50c <virtio_complete_job+0x48>
        warnf("No job found with ID %d\n", job_id);
    8001a4f2:	fd043583          	ld	a1,-48(s0)
    8001a4f6:	0000b517          	auipc	a0,0xb
    8001a4fa:	15250513          	addi	a0,a0,338 # 80025648 <pow10.0+0x1418>
    8001a4fe:	d03fe0ef          	jal	ra,80019200 <warnf>
        virtio_release_device(dev);
    8001a502:	fd843503          	ld	a0,-40(s0)
    8001a506:	e01ff0ef          	jal	ra,8001a306 <virtio_release_device>
        return;
    8001a50a:	a899                	j	8001a560 <virtio_complete_job+0x9c>
    }

    if (job->done) {
    8001a50c:	fe843783          	ld	a5,-24(s0)
    8001a510:	0107c783          	lbu	a5,16(a5)
    8001a514:	cf91                	beqz	a5,8001a530 <virtio_complete_job+0x6c>
        warnf("Job %d already done\n", job_id);
    8001a516:	fd043583          	ld	a1,-48(s0)
    8001a51a:	0000b517          	auipc	a0,0xb
    8001a51e:	14e50513          	addi	a0,a0,334 # 80025668 <pow10.0+0x1438>
    8001a522:	cdffe0ef          	jal	ra,80019200 <warnf>
        virtio_release_device(dev);
    8001a526:	fd843503          	ld	a0,-40(s0)
    8001a52a:	dddff0ef          	jal	ra,8001a306 <virtio_release_device>
        return;
    8001a52e:	a80d                	j	8001a560 <virtio_complete_job+0x9c>
    }
    virtio_callback_and_free_job(dev, job_id);
    8001a530:	fd043583          	ld	a1,-48(s0)
    8001a534:	fd843503          	ld	a0,-40(s0)
    8001a538:	d1bff0ef          	jal	ra,8001a252 <virtio_callback_and_free_job>
    if (job->done) {
    8001a53c:	fe843783          	ld	a5,-24(s0)
    8001a540:	0107c783          	lbu	a5,16(a5)
    8001a544:	cb91                	beqz	a5,8001a558 <virtio_complete_job+0x94>
        debugf("Job %d done\n", job_id);
        vector_remove_val_ptr(dev->jobs, job);
    8001a546:	fd843783          	ld	a5,-40(s0)
    8001a54a:	63dc                	ld	a5,128(a5)
    8001a54c:	fe843703          	ld	a4,-24(s0)
    8001a550:	85ba                	mv	a1,a4
    8001a552:	853e                	mv	a0,a5
    8001a554:	7d6060ef          	jal	ra,80020d2a <vector_remove_value>
    } else {
        debugf("Job %d not done\n", job_id);
    }

    virtio_release_device(dev);
    8001a558:	fd843503          	ld	a0,-40(s0)
    8001a55c:	dabff0ef          	jal	ra,8001a306 <virtio_release_device>
}
    8001a560:	70a2                	ld	ra,40(sp)
    8001a562:	7402                	ld	s0,32(sp)
    8001a564:	6145                	addi	sp,sp,48
    8001a566:	8082                	ret

000000008001a568 <virtio_get_block_config>:

volatile struct VirtioBlockConfig *virtio_get_block_config(VirtioDevice *device) {
    8001a568:	1101                	addi	sp,sp,-32
    8001a56a:	ec06                	sd	ra,24(sp)
    8001a56c:	e822                	sd	s0,16(sp)
    8001a56e:	1000                	addi	s0,sp,32
    8001a570:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioBlockConfig *)pci_get_device_specific_config(device->pcidev);
    8001a574:	fe843783          	ld	a5,-24(s0)
    8001a578:	63bc                	ld	a5,64(a5)
    8001a57a:	853e                	mv	a0,a5
    8001a57c:	e8af80ef          	jal	ra,80012c06 <pci_get_device_specific_config>
    8001a580:	87aa                	mv	a5,a0
}
    8001a582:	853e                	mv	a0,a5
    8001a584:	60e2                	ld	ra,24(sp)
    8001a586:	6442                	ld	s0,16(sp)
    8001a588:	6105                	addi	sp,sp,32
    8001a58a:	8082                	ret

000000008001a58c <virtio_get_input_config>:

volatile struct VirtioInputConfig *virtio_get_input_config(VirtioDevice *device) {
    8001a58c:	1101                	addi	sp,sp,-32
    8001a58e:	ec06                	sd	ra,24(sp)
    8001a590:	e822                	sd	s0,16(sp)
    8001a592:	1000                	addi	s0,sp,32
    8001a594:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioInputConfig *)pci_get_device_specific_config(device->pcidev);
    8001a598:	fe843783          	ld	a5,-24(s0)
    8001a59c:	63bc                	ld	a5,64(a5)
    8001a59e:	853e                	mv	a0,a5
    8001a5a0:	e66f80ef          	jal	ra,80012c06 <pci_get_device_specific_config>
    8001a5a4:	87aa                	mv	a5,a0
}
    8001a5a6:	853e                	mv	a0,a5
    8001a5a8:	60e2                	ld	ra,24(sp)
    8001a5aa:	6442                	ld	s0,16(sp)
    8001a5ac:	6105                	addi	sp,sp,32
    8001a5ae:	8082                	ret

000000008001a5b0 <virtio_get_gpu_config>:

volatile struct VirtioGpuConfig *virtio_get_gpu_config(VirtioDevice *device) {
    8001a5b0:	1101                	addi	sp,sp,-32
    8001a5b2:	ec06                	sd	ra,24(sp)
    8001a5b4:	e822                	sd	s0,16(sp)
    8001a5b6:	1000                	addi	s0,sp,32
    8001a5b8:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioGpuConfig *)pci_get_device_specific_config(device->pcidev);
    8001a5bc:	fe843783          	ld	a5,-24(s0)
    8001a5c0:	63bc                	ld	a5,64(a5)
    8001a5c2:	853e                	mv	a0,a5
    8001a5c4:	e42f80ef          	jal	ra,80012c06 <pci_get_device_specific_config>
    8001a5c8:	87aa                	mv	a5,a0
}
    8001a5ca:	853e                	mv	a0,a5
    8001a5cc:	60e2                	ld	ra,24(sp)
    8001a5ce:	6442                	ld	s0,16(sp)
    8001a5d0:	6105                	addi	sp,sp,32
    8001a5d2:	8082                	ret

000000008001a5d4 <virtio_get_device_id>:

uint16_t virtio_get_device_id(VirtioDevice *dev) {
    8001a5d4:	1101                	addi	sp,sp,-32
    8001a5d6:	ec22                	sd	s0,24(sp)
    8001a5d8:	1000                	addi	s0,sp,32
    8001a5da:	fea43423          	sd	a0,-24(s0)
    return dev->pcidev->ecam_header->device_id;
    8001a5de:	fe843783          	ld	a5,-24(s0)
    8001a5e2:	63bc                	ld	a5,64(a5)
    8001a5e4:	639c                	ld	a5,0(a5)
    8001a5e6:	0027d783          	lhu	a5,2(a5)
    8001a5ea:	17c2                	slli	a5,a5,0x30
    8001a5ec:	93c1                	srli	a5,a5,0x30
}
    8001a5ee:	853e                	mv	a0,a5
    8001a5f0:	6462                	ld	s0,24(sp)
    8001a5f2:	6105                	addi	sp,sp,32
    8001a5f4:	8082                	ret

000000008001a5f6 <virtio_is_rng_device>:

bool virtio_is_rng_device(VirtioDevice *dev) {
    8001a5f6:	1101                	addi	sp,sp,-32
    8001a5f8:	ec06                	sd	ra,24(sp)
    8001a5fa:	e822                	sd	s0,16(sp)
    8001a5fc:	1000                	addi	s0,sp,32
    8001a5fe:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_ENTROPY);
    8001a602:	fe843503          	ld	a0,-24(s0)
    8001a606:	fcfff0ef          	jal	ra,8001a5d4 <virtio_get_device_id>
    8001a60a:	87aa                	mv	a5,a0
    8001a60c:	0007871b          	sext.w	a4,a5
    8001a610:	6785                	lui	a5,0x1
    8001a612:	04478793          	addi	a5,a5,68 # 1044 <i+0x1024>
    8001a616:	40f707b3          	sub	a5,a4,a5
    8001a61a:	0017b793          	seqz	a5,a5
    8001a61e:	0ff7f793          	andi	a5,a5,255
}
    8001a622:	853e                	mv	a0,a5
    8001a624:	60e2                	ld	ra,24(sp)
    8001a626:	6442                	ld	s0,16(sp)
    8001a628:	6105                	addi	sp,sp,32
    8001a62a:	8082                	ret

000000008001a62c <virtio_is_block_device>:

bool virtio_is_block_device(VirtioDevice *dev) {
    8001a62c:	1101                	addi	sp,sp,-32
    8001a62e:	ec06                	sd	ra,24(sp)
    8001a630:	e822                	sd	s0,16(sp)
    8001a632:	1000                	addi	s0,sp,32
    8001a634:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_BLOCK);
    8001a638:	fe843503          	ld	a0,-24(s0)
    8001a63c:	f99ff0ef          	jal	ra,8001a5d4 <virtio_get_device_id>
    8001a640:	87aa                	mv	a5,a0
    8001a642:	0007871b          	sext.w	a4,a5
    8001a646:	6785                	lui	a5,0x1
    8001a648:	04278793          	addi	a5,a5,66 # 1042 <i+0x1022>
    8001a64c:	40f707b3          	sub	a5,a4,a5
    8001a650:	0017b793          	seqz	a5,a5
    8001a654:	0ff7f793          	andi	a5,a5,255
}
    8001a658:	853e                	mv	a0,a5
    8001a65a:	60e2                	ld	ra,24(sp)
    8001a65c:	6442                	ld	s0,16(sp)
    8001a65e:	6105                	addi	sp,sp,32
    8001a660:	8082                	ret

000000008001a662 <virtio_is_input_device>:

bool virtio_is_input_device(VirtioDevice *dev) {
    8001a662:	1101                	addi	sp,sp,-32
    8001a664:	ec06                	sd	ra,24(sp)
    8001a666:	e822                	sd	s0,16(sp)
    8001a668:	1000                	addi	s0,sp,32
    8001a66a:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_INPUT);
    8001a66e:	fe843503          	ld	a0,-24(s0)
    8001a672:	f63ff0ef          	jal	ra,8001a5d4 <virtio_get_device_id>
    8001a676:	87aa                	mv	a5,a0
    8001a678:	0007871b          	sext.w	a4,a5
    8001a67c:	6785                	lui	a5,0x1
    8001a67e:	05278793          	addi	a5,a5,82 # 1052 <i+0x1032>
    8001a682:	40f707b3          	sub	a5,a4,a5
    8001a686:	0017b793          	seqz	a5,a5
    8001a68a:	0ff7f793          	andi	a5,a5,255
}
    8001a68e:	853e                	mv	a0,a5
    8001a690:	60e2                	ld	ra,24(sp)
    8001a692:	6442                	ld	s0,16(sp)
    8001a694:	6105                	addi	sp,sp,32
    8001a696:	8082                	ret

000000008001a698 <virtio_is_gpu_device>:

bool virtio_is_gpu_device(VirtioDevice *dev) {
    8001a698:	1101                	addi	sp,sp,-32
    8001a69a:	ec06                	sd	ra,24(sp)
    8001a69c:	e822                	sd	s0,16(sp)
    8001a69e:	1000                	addi	s0,sp,32
    8001a6a0:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_GPU);
    8001a6a4:	fe843503          	ld	a0,-24(s0)
    8001a6a8:	f2dff0ef          	jal	ra,8001a5d4 <virtio_get_device_id>
    8001a6ac:	87aa                	mv	a5,a0
    8001a6ae:	0007871b          	sext.w	a4,a5
    8001a6b2:	6785                	lui	a5,0x1
    8001a6b4:	05078793          	addi	a5,a5,80 # 1050 <i+0x1030>
    8001a6b8:	40f707b3          	sub	a5,a4,a5
    8001a6bc:	0017b793          	seqz	a5,a5
    8001a6c0:	0ff7f793          	andi	a5,a5,255
}
    8001a6c4:	853e                	mv	a0,a5
    8001a6c6:	60e2                	ld	ra,24(sp)
    8001a6c8:	6442                	ld	s0,16(sp)
    8001a6ca:	6105                	addi	sp,sp,32
    8001a6cc:	8082                	ret

000000008001a6ce <virtio_get_queue_size>:

uint16_t virtio_get_queue_size(VirtioDevice *dev) {
    8001a6ce:	1101                	addi	sp,sp,-32
    8001a6d0:	ec22                	sd	s0,24(sp)
    8001a6d2:	1000                	addi	s0,sp,32
    8001a6d4:	fea43423          	sd	a0,-24(s0)
    return dev->common_cfg->queue_size;
    8001a6d8:	fe843783          	ld	a5,-24(s0)
    8001a6dc:	67bc                	ld	a5,72(a5)
    8001a6de:	0187d783          	lhu	a5,24(a5)
    8001a6e2:	17c2                	slli	a5,a5,0x30
    8001a6e4:	93c1                	srli	a5,a5,0x30
}
    8001a6e6:	853e                	mv	a0,a5
    8001a6e8:	6462                	ld	s0,24(sp)
    8001a6ea:	6105                	addi	sp,sp,32
    8001a6ec:	8082                	ret

000000008001a6ee <virtio_get_device>:

VirtioDevice *virtio_get_device(uint16_t device_type, uint16_t n) {
    8001a6ee:	7139                	addi	sp,sp,-64
    8001a6f0:	fc06                	sd	ra,56(sp)
    8001a6f2:	f822                	sd	s0,48(sp)
    8001a6f4:	f426                	sd	s1,40(sp)
    8001a6f6:	0080                	addi	s0,sp,64
    8001a6f8:	87aa                	mv	a5,a0
    8001a6fa:	872e                	mv	a4,a1
    8001a6fc:	fcf41723          	sh	a5,-50(s0)
    8001a700:	87ba                	mv	a5,a4
    8001a702:	fcf41623          	sh	a5,-52(s0)
    uint16_t count = 0;
    8001a706:	fc041f23          	sh	zero,-34(s0)
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a70a:	fc041e23          	sh	zero,-36(s0)
    8001a70e:	a8b9                	j	8001a76c <virtio_get_device+0x7e>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001a710:	fdc45783          	lhu	a5,-36(s0)
    8001a714:	853e                	mv	a0,a5
    8001a716:	16c000ef          	jal	ra,8001a882 <virtio_get_nth_saved_device>
    8001a71a:	fca43823          	sd	a0,-48(s0)
        if (virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(device_type) && count++ == n) {
    8001a71e:	fd043503          	ld	a0,-48(s0)
    8001a722:	eb3ff0ef          	jal	ra,8001a5d4 <virtio_get_device_id>
    8001a726:	87aa                	mv	a5,a0
    8001a728:	0007869b          	sext.w	a3,a5
    8001a72c:	fce45783          	lhu	a5,-50(s0)
    8001a730:	0007871b          	sext.w	a4,a5
    8001a734:	6785                	lui	a5,0x1
    8001a736:	0407879b          	addiw	a5,a5,64
    8001a73a:	9fb9                	addw	a5,a5,a4
    8001a73c:	2781                	sext.w	a5,a5
    8001a73e:	8736                	mv	a4,a3
    8001a740:	02f71163          	bne	a4,a5,8001a762 <virtio_get_device+0x74>
    8001a744:	fde45783          	lhu	a5,-34(s0)
    8001a748:	0017871b          	addiw	a4,a5,1
    8001a74c:	fce41f23          	sh	a4,-34(s0)
    8001a750:	fcc45703          	lhu	a4,-52(s0)
    8001a754:	2701                	sext.w	a4,a4
    8001a756:	2781                	sext.w	a5,a5
    8001a758:	00f71563          	bne	a4,a5,8001a762 <virtio_get_device+0x74>
            return dev;
    8001a75c:	fd043783          	ld	a5,-48(s0)
    8001a760:	a825                	j	8001a798 <virtio_get_device+0xaa>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001a762:	fdc45783          	lhu	a5,-36(s0)
    8001a766:	2785                	addiw	a5,a5,1
    8001a768:	fcf41e23          	sh	a5,-36(s0)
    8001a76c:	fdc45483          	lhu	s1,-36(s0)
    8001a770:	212000ef          	jal	ra,8001a982 <virtio_count_saved_devices>
    8001a774:	87aa                	mv	a5,a0
    8001a776:	f8f4ede3          	bltu	s1,a5,8001a710 <virtio_get_device+0x22>
        }
    }

    warnf("Device #%d with PCI ID=%d could not be found\n", n, device_type);
    8001a77a:	fcc45783          	lhu	a5,-52(s0)
    8001a77e:	2781                	sext.w	a5,a5
    8001a780:	fce45703          	lhu	a4,-50(s0)
    8001a784:	2701                	sext.w	a4,a4
    8001a786:	863a                	mv	a2,a4
    8001a788:	85be                	mv	a1,a5
    8001a78a:	0000b517          	auipc	a0,0xb
    8001a78e:	ef650513          	addi	a0,a0,-266 # 80025680 <pow10.0+0x1450>
    8001a792:	a6ffe0ef          	jal	ra,80019200 <warnf>
    return NULL;
    8001a796:	4781                	li	a5,0
}
    8001a798:	853e                	mv	a0,a5
    8001a79a:	70e2                	ld	ra,56(sp)
    8001a79c:	7442                	ld	s0,48(sp)
    8001a79e:	74a2                	ld	s1,40(sp)
    8001a7a0:	6121                	addi	sp,sp,64
    8001a7a2:	8082                	ret

000000008001a7a4 <virtio_get_rng_device>:

VirtioDevice *virtio_get_rng_device(void) {
    8001a7a4:	1141                	addi	sp,sp,-16
    8001a7a6:	e406                	sd	ra,8(sp)
    8001a7a8:	e022                	sd	s0,0(sp)
    8001a7aa:	0800                	addi	s0,sp,16
    debugf("Getting RNG device\n");
    return virtio_get_device(VIRTIO_PCI_DEVICE_ENTROPY, 0);
    8001a7ac:	4581                	li	a1,0
    8001a7ae:	4511                	li	a0,4
    8001a7b0:	f3fff0ef          	jal	ra,8001a6ee <virtio_get_device>
    8001a7b4:	87aa                	mv	a5,a0
}
    8001a7b6:	853e                	mv	a0,a5
    8001a7b8:	60a2                	ld	ra,8(sp)
    8001a7ba:	6402                	ld	s0,0(sp)
    8001a7bc:	0141                	addi	sp,sp,16
    8001a7be:	8082                	ret

000000008001a7c0 <virtio_get_block_device>:

VirtioDevice *virtio_get_block_device(uint16_t n) {
    8001a7c0:	7179                	addi	sp,sp,-48
    8001a7c2:	f406                	sd	ra,40(sp)
    8001a7c4:	f022                	sd	s0,32(sp)
    8001a7c6:	1800                	addi	s0,sp,48
    8001a7c8:	87aa                	mv	a5,a0
    8001a7ca:	fcf41f23          	sh	a5,-34(s0)
    debugf("Getting block device %d\n", n);
    VirtioDevice *result = virtio_get_device(VIRTIO_PCI_DEVICE_BLOCK, n);
    8001a7ce:	fde45783          	lhu	a5,-34(s0)
    8001a7d2:	85be                	mv	a1,a5
    8001a7d4:	4509                	li	a0,2
    8001a7d6:	f19ff0ef          	jal	ra,8001a6ee <virtio_get_device>
    8001a7da:	fea43423          	sd	a0,-24(s0)
    if (result == NULL) {
    8001a7de:	fe843783          	ld	a5,-24(s0)
    8001a7e2:	eb99                	bnez	a5,8001a7f8 <virtio_get_block_device+0x38>
        warnf("No block device #%d\n", n);
    8001a7e4:	fde45783          	lhu	a5,-34(s0)
    8001a7e8:	2781                	sext.w	a5,a5
    8001a7ea:	85be                	mv	a1,a5
    8001a7ec:	0000b517          	auipc	a0,0xb
    8001a7f0:	ec450513          	addi	a0,a0,-316 # 800256b0 <pow10.0+0x1480>
    8001a7f4:	a0dfe0ef          	jal	ra,80019200 <warnf>
    }
    return result;
    8001a7f8:	fe843783          	ld	a5,-24(s0)
}
    8001a7fc:	853e                	mv	a0,a5
    8001a7fe:	70a2                	ld	ra,40(sp)
    8001a800:	7402                	ld	s0,32(sp)
    8001a802:	6145                	addi	sp,sp,48
    8001a804:	8082                	ret

000000008001a806 <virtio_get_input_device>:

VirtioDevice *virtio_get_input_device(uint16_t n) {
    8001a806:	7179                	addi	sp,sp,-48
    8001a808:	f406                	sd	ra,40(sp)
    8001a80a:	f022                	sd	s0,32(sp)
    8001a80c:	1800                	addi	s0,sp,48
    8001a80e:	87aa                	mv	a5,a0
    8001a810:	fcf41f23          	sh	a5,-34(s0)
    debugf("Getting input device %d\n", n);
    VirtioDevice *result = virtio_get_device(VIRTIO_PCI_DEVICE_INPUT, n);
    8001a814:	fde45783          	lhu	a5,-34(s0)
    8001a818:	85be                	mv	a1,a5
    8001a81a:	4549                	li	a0,18
    8001a81c:	ed3ff0ef          	jal	ra,8001a6ee <virtio_get_device>
    8001a820:	fea43423          	sd	a0,-24(s0)
    if (result == NULL) {
    8001a824:	fe843783          	ld	a5,-24(s0)
    8001a828:	eb99                	bnez	a5,8001a83e <virtio_get_input_device+0x38>
        warnf("No input device #%d\n", n);
    8001a82a:	fde45783          	lhu	a5,-34(s0)
    8001a82e:	2781                	sext.w	a5,a5
    8001a830:	85be                	mv	a1,a5
    8001a832:	0000b517          	auipc	a0,0xb
    8001a836:	e9650513          	addi	a0,a0,-362 # 800256c8 <pow10.0+0x1498>
    8001a83a:	9c7fe0ef          	jal	ra,80019200 <warnf>
    }
    return result;
    8001a83e:	fe843783          	ld	a5,-24(s0)
}
    8001a842:	853e                	mv	a0,a5
    8001a844:	70a2                	ld	ra,40(sp)
    8001a846:	7402                	ld	s0,32(sp)
    8001a848:	6145                	addi	sp,sp,48
    8001a84a:	8082                	ret

000000008001a84c <virtio_get_gpu_device>:

VirtioDevice *virtio_get_gpu_device(void) {
    8001a84c:	1101                	addi	sp,sp,-32
    8001a84e:	ec06                	sd	ra,24(sp)
    8001a850:	e822                	sd	s0,16(sp)
    8001a852:	1000                	addi	s0,sp,32
    // return virtio_get_device(VIRTIO_PCI_DEVICE_GPU, 0);
    debugf("Getting GPU device %d\n", 0);
    VirtioDevice *result = virtio_get_device(VIRTIO_PCI_DEVICE_GPU, 0);
    8001a854:	4581                	li	a1,0
    8001a856:	4541                	li	a0,16
    8001a858:	e97ff0ef          	jal	ra,8001a6ee <virtio_get_device>
    8001a85c:	fea43423          	sd	a0,-24(s0)
    if (result == NULL) {
    8001a860:	fe843783          	ld	a5,-24(s0)
    8001a864:	eb81                	bnez	a5,8001a874 <virtio_get_gpu_device+0x28>
        warnf("No GPU device #%d\n", 0);
    8001a866:	4581                	li	a1,0
    8001a868:	0000b517          	auipc	a0,0xb
    8001a86c:	e7850513          	addi	a0,a0,-392 # 800256e0 <pow10.0+0x14b0>
    8001a870:	991fe0ef          	jal	ra,80019200 <warnf>
    }
    return result;
    8001a874:	fe843783          	ld	a5,-24(s0)
}
    8001a878:	853e                	mv	a0,a5
    8001a87a:	60e2                	ld	ra,24(sp)
    8001a87c:	6442                	ld	s0,16(sp)
    8001a87e:	6105                	addi	sp,sp,32
    8001a880:	8082                	ret

000000008001a882 <virtio_get_nth_saved_device>:

VirtioDevice *virtio_get_nth_saved_device(uint16_t n) {
    8001a882:	7179                	addi	sp,sp,-48
    8001a884:	f406                	sd	ra,40(sp)
    8001a886:	f022                	sd	s0,32(sp)
    8001a888:	1800                	addi	s0,sp,48
    8001a88a:	87aa                	mv	a5,a0
    8001a88c:	fcf41f23          	sh	a5,-34(s0)
    VirtioDevice *result;
    vector_get_ptr(virtio_devices, n, &result);
    8001a890:	00009797          	auipc	a5,0x9
    8001a894:	8a878793          	addi	a5,a5,-1880 # 80023138 <virtio_devices>
    8001a898:	639c                	ld	a5,0(a5)
    8001a89a:	fde45703          	lhu	a4,-34(s0)
    8001a89e:	2701                	sext.w	a4,a4
    8001a8a0:	fe840693          	addi	a3,s0,-24
    8001a8a4:	8636                	mv	a2,a3
    8001a8a6:	85ba                	mv	a1,a4
    8001a8a8:	853e                	mv	a0,a5
    8001a8aa:	114060ef          	jal	ra,800209be <vector_get>
    return result;
    8001a8ae:	fe843783          	ld	a5,-24(s0)
}
    8001a8b2:	853e                	mv	a0,a5
    8001a8b4:	70a2                	ld	ra,40(sp)
    8001a8b6:	7402                	ld	s0,32(sp)
    8001a8b8:	6145                	addi	sp,sp,48
    8001a8ba:	8082                	ret

000000008001a8bc <virtio_save_device>:

void virtio_save_device(VirtioDevice device) {
    8001a8bc:	7179                	addi	sp,sp,-48
    8001a8be:	f406                	sd	ra,40(sp)
    8001a8c0:	f022                	sd	s0,32(sp)
    8001a8c2:	ec26                	sd	s1,24(sp)
    8001a8c4:	1800                	addi	s0,sp,48
    8001a8c6:	84aa                	mv	s1,a0
    VirtioDevice *mem = (VirtioDevice *)kzalloc(sizeof(VirtioDevice));
    8001a8c8:	09800593          	li	a1,152
    8001a8cc:	4505                	li	a0,1
    8001a8ce:	be8f90ef          	jal	ra,80013cb6 <kcalloc>
    8001a8d2:	fca43c23          	sd	a0,-40(s0)
    memcpy(mem, &device, sizeof(VirtioDevice));
    8001a8d6:	09800613          	li	a2,152
    8001a8da:	85a6                	mv	a1,s1
    8001a8dc:	fd843503          	ld	a0,-40(s0)
    8001a8e0:	58e050ef          	jal	ra,8001fe6e <memcpy>
    vector_push_ptr(virtio_devices, mem);
    8001a8e4:	00009797          	auipc	a5,0x9
    8001a8e8:	85478793          	addi	a5,a5,-1964 # 80023138 <virtio_devices>
    8001a8ec:	639c                	ld	a5,0(a5)
    8001a8ee:	fd843703          	ld	a4,-40(s0)
    8001a8f2:	85ba                	mv	a1,a4
    8001a8f4:	853e                	mv	a0,a5
    8001a8f6:	769050ef          	jal	ra,8002085e <vector_push>
}
    8001a8fa:	0001                	nop
    8001a8fc:	70a2                	ld	ra,40(sp)
    8001a8fe:	7402                	ld	s0,32(sp)
    8001a900:	64e2                	ld	s1,24(sp)
    8001a902:	6145                	addi	sp,sp,48
    8001a904:	8082                	ret

000000008001a906 <virtio_from_pci_device>:

VirtioDevice *virtio_from_pci_device(PCIDevice *pcidevice) {
    8001a906:	7179                	addi	sp,sp,-48
    8001a908:	f406                	sd	ra,40(sp)
    8001a90a:	f022                	sd	s0,32(sp)
    8001a90c:	1800                	addi	s0,sp,48
    8001a90e:	fca43c23          	sd	a0,-40(s0)
    for(uint32_t i = 0; i < vector_size(virtio_devices);i++){
    8001a912:	fe042623          	sw	zero,-20(s0)
    8001a916:	a081                	j	8001a956 <virtio_from_pci_device+0x50>
        VirtioDevice *curr_virt_device = NULL;
    8001a918:	fe043023          	sd	zero,-32(s0)
        vector_get_ptr(virtio_devices, i, &curr_virt_device);
    8001a91c:	00009797          	auipc	a5,0x9
    8001a920:	81c78793          	addi	a5,a5,-2020 # 80023138 <virtio_devices>
    8001a924:	639c                	ld	a5,0(a5)
    8001a926:	fe040693          	addi	a3,s0,-32
    8001a92a:	fec42703          	lw	a4,-20(s0)
    8001a92e:	8636                	mv	a2,a3
    8001a930:	85ba                	mv	a1,a4
    8001a932:	853e                	mv	a0,a5
    8001a934:	08a060ef          	jal	ra,800209be <vector_get>
        if(curr_virt_device->pcidev == pcidevice) {
    8001a938:	fe043783          	ld	a5,-32(s0)
    8001a93c:	63bc                	ld	a5,64(a5)
    8001a93e:	fd843703          	ld	a4,-40(s0)
    8001a942:	00f71563          	bne	a4,a5,8001a94c <virtio_from_pci_device+0x46>
            return curr_virt_device;
    8001a946:	fe043783          	ld	a5,-32(s0)
    8001a94a:	a03d                	j	8001a978 <virtio_from_pci_device+0x72>
    for(uint32_t i = 0; i < vector_size(virtio_devices);i++){
    8001a94c:	fec42783          	lw	a5,-20(s0)
    8001a950:	2785                	addiw	a5,a5,1
    8001a952:	fef42623          	sw	a5,-20(s0)
    8001a956:	00008797          	auipc	a5,0x8
    8001a95a:	7e278793          	addi	a5,a5,2018 # 80023138 <virtio_devices>
    8001a95e:	639c                	ld	a5,0(a5)
    8001a960:	853e                	mv	a0,a5
    8001a962:	7bc060ef          	jal	ra,8002111e <vector_size>
    8001a966:	87aa                	mv	a5,a0
    8001a968:	0007871b          	sext.w	a4,a5
    8001a96c:	fec42783          	lw	a5,-20(s0)
    8001a970:	2781                	sext.w	a5,a5
    8001a972:	fae7e3e3          	bltu	a5,a4,8001a918 <virtio_from_pci_device+0x12>
        }
    }
    return NULL;
    8001a976:	4781                	li	a5,0
}
    8001a978:	853e                	mv	a0,a5
    8001a97a:	70a2                	ld	ra,40(sp)
    8001a97c:	7402                	ld	s0,32(sp)
    8001a97e:	6145                	addi	sp,sp,48
    8001a980:	8082                	ret

000000008001a982 <virtio_count_saved_devices>:

// Get the number of saved Virtio devices.
uint64_t virtio_count_saved_devices(void) {
    8001a982:	1141                	addi	sp,sp,-16
    8001a984:	e406                	sd	ra,8(sp)
    8001a986:	e022                	sd	s0,0(sp)
    8001a988:	0800                	addi	s0,sp,16
    return vector_size(virtio_devices);
    8001a98a:	00008797          	auipc	a5,0x8
    8001a98e:	7ae78793          	addi	a5,a5,1966 # 80023138 <virtio_devices>
    8001a992:	639c                	ld	a5,0(a5)
    8001a994:	853e                	mv	a0,a5
    8001a996:	788060ef          	jal	ra,8002111e <vector_size>
    8001a99a:	87aa                	mv	a5,a0
    8001a99c:	2781                	sext.w	a5,a5
    8001a99e:	1782                	slli	a5,a5,0x20
    8001a9a0:	9381                	srli	a5,a5,0x20
}
    8001a9a2:	853e                	mv	a0,a5
    8001a9a4:	60a2                	ld	ra,8(sp)
    8001a9a6:	6402                	ld	s0,0(sp)
    8001a9a8:	0141                	addi	sp,sp,16
    8001a9aa:	8082                	ret

000000008001a9ac <virtio_get_capability>:

// Get a virtio capability for a given device by the virtio capability's type.
// If this is zero, it will get the common configuration capability. If this is
// one, it will get the notify capability. If this is two, it will get the ISR
// capability. Etc.
volatile struct VirtioCapability *virtio_get_capability(VirtioDevice *dev, uint8_t type) {
    8001a9ac:	1101                	addi	sp,sp,-32
    8001a9ae:	ec06                	sd	ra,24(sp)
    8001a9b0:	e822                	sd	s0,16(sp)
    8001a9b2:	1000                	addi	s0,sp,32
    8001a9b4:	fea43423          	sd	a0,-24(s0)
    8001a9b8:	87ae                	mv	a5,a1
    8001a9ba:	fef403a3          	sb	a5,-25(s0)
    return pci_get_virtio_capability(dev->pcidev, type);
    8001a9be:	fe843783          	ld	a5,-24(s0)
    8001a9c2:	63bc                	ld	a5,64(a5)
    8001a9c4:	fe744703          	lbu	a4,-25(s0)
    8001a9c8:	85ba                	mv	a1,a4
    8001a9ca:	853e                	mv	a0,a5
    8001a9cc:	f1ff70ef          	jal	ra,800128ea <pci_get_virtio_capability>
    8001a9d0:	87aa                	mv	a5,a0
}
    8001a9d2:	853e                	mv	a0,a5
    8001a9d4:	60e2                	ld	ra,24(sp)
    8001a9d6:	6442                	ld	s0,16(sp)
    8001a9d8:	6105                	addi	sp,sp,32
    8001a9da:	8082                	ret

000000008001a9dc <virtio_init>:
/**
 * @brief Initialize the virtio system
 */


void virtio_init(void) {
    8001a9dc:	7161                	addi	sp,sp,-432
    8001a9de:	f706                	sd	ra,424(sp)
    8001a9e0:	f322                	sd	s0,416(sp)
    8001a9e2:	ef26                	sd	s1,408(sp)
    8001a9e4:	1b00                	addi	s0,sp,432
    debugf("virtio_init: Initializing virtio system...\n");
    // Initialize the vector of virtio devices
    virtio_devices = vector_new();
    8001a9e6:	5d9050ef          	jal	ra,800207be <vector_new>
    8001a9ea:	872a                	mv	a4,a0
    8001a9ec:	00008797          	auipc	a5,0x8
    8001a9f0:	74c78793          	addi	a5,a5,1868 # 80023138 <virtio_devices>
    8001a9f4:	e398                	sd	a4,0(a5)

    // Get the number of PCI devices saved
    // This will allow us to iterate through all of them and find the virtio devices
    uint64_t num_pci_devices = pci_count_saved_devices();
    8001a9f6:	f71f70ef          	jal	ra,80012966 <pci_count_saved_devices>
    8001a9fa:	fca43423          	sd	a0,-56(s0)
    
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    8001a9fe:	fc043c23          	sd	zero,-40(s0)
    8001aa02:	acc1                	j	8001acd2 <virtio_init+0x2f6>
        // Get the PCI device
        PCIDevice *pcidevice = pci_get_nth_saved_device(i);
    8001aa04:	fd843783          	ld	a5,-40(s0)
    8001aa08:	17c2                	slli	a5,a5,0x30
    8001aa0a:	93c1                	srli	a5,a5,0x30
    8001aa0c:	853e                	mv	a0,a5
    8001aa0e:	8aef80ef          	jal	ra,80012abc <pci_get_nth_saved_device>
    8001aa12:	faa43823          	sd	a0,-80(s0)
        
        // Is this a virtio device?
        if (pci_is_virtio_device(pcidevice)) { // Access through ecam_header
    8001aa16:	fb043503          	ld	a0,-80(s0)
    8001aa1a:	d19f70ef          	jal	ra,80012732 <pci_is_virtio_device>
    8001aa1e:	87aa                	mv	a5,a0
    8001aa20:	2a078463          	beqz	a5,8001acc8 <virtio_init+0x2ec>

            // Create a new bookkeeping structure for the virtio device
            VirtioDevice viodev;

            // Add the PCI device to the bookkeeping structure
            viodev.pcidev = pcidevice;
    8001aa24:	fb043783          	ld	a5,-80(s0)
    8001aa28:	f2f43c23          	sd	a5,-200(s0)
            // Add the common configuration, notify capability, and ISR to the bookkeeping structure
            viodev.common_cfg = pci_get_virtio_common_config(pcidevice);
    8001aa2c:	fb043503          	ld	a0,-80(s0)
    8001aa30:	a2ef80ef          	jal	ra,80012c5e <pci_get_virtio_common_config>
    8001aa34:	87aa                	mv	a5,a0
    8001aa36:	f4f43023          	sd	a5,-192(s0)
            viodev.notify_cap = pci_get_virtio_notify_capability(pcidevice);
    8001aa3a:	fb043503          	ld	a0,-80(s0)
    8001aa3e:	a78f80ef          	jal	ra,80012cb6 <pci_get_virtio_notify_capability>
    8001aa42:	87aa                	mv	a5,a0
    8001aa44:	f4f43423          	sd	a5,-184(s0)
            viodev.isr = pci_get_virtio_isr_status(pcidevice);
    8001aa48:	fb043503          	ld	a0,-80(s0)
    8001aa4c:	acef80ef          	jal	ra,80012d1a <pci_get_virtio_isr_status>
    8001aa50:	87aa                	mv	a5,a0
    8001aa52:	f4f43823          	sd	a5,-176(s0)
            if (virtio_is_rng_device(&viodev)) {
    8001aa56:	ef840793          	addi	a5,s0,-264
    8001aa5a:	853e                	mv	a0,a5
    8001aa5c:	b9bff0ef          	jal	ra,8001a5f6 <virtio_is_rng_device>
    8001aa60:	87aa                	mv	a5,a0
    8001aa62:	ef89                	bnez	a5,8001aa7c <virtio_init+0xa0>
                debugf("Setting up RNG device\n");
            } else if (virtio_is_block_device(&viodev)) {
    8001aa64:	ef840793          	addi	a5,s0,-264
    8001aa68:	853e                	mv	a0,a5
    8001aa6a:	bc3ff0ef          	jal	ra,8001a62c <virtio_is_block_device>
    8001aa6e:	87aa                	mv	a5,a0
    8001aa70:	e791                	bnez	a5,8001aa7c <virtio_init+0xa0>
                debugf("Setting up block device\n");
            } else if (virtio_is_input_device(&viodev)) {
    8001aa72:	ef840793          	addi	a5,s0,-264
    8001aa76:	853e                	mv	a0,a5
    8001aa78:	bebff0ef          	jal	ra,8001a662 <virtio_is_input_device>
            debugf("Common config at 0x%08x\n", viodev.common_cfg);
            debugf("Notify config at 0x%08x\n", viodev.notify_cap);
            debugf("ISR config at 0x%08x\n", viodev.isr);

            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status = VIRTIO_F_RESET;
    8001aa7c:	f4043783          	ld	a5,-192(s0)
    8001aa80:	00078a23          	sb	zero,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status = VIRTIO_F_ACKNOWLEDGE;
    8001aa84:	f4043783          	ld	a5,-192(s0)
    8001aa88:	4705                	li	a4,1
    8001aa8a:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER;
    8001aa8e:	f4043783          	ld	a5,-192(s0)
    8001aa92:	0147c783          	lbu	a5,20(a5)
    8001aa96:	0ff7f713          	andi	a4,a5,255
    8001aa9a:	f4043783          	ld	a5,-192(s0)
    8001aa9e:	00276713          	ori	a4,a4,2
    8001aaa2:	0ff77713          	andi	a4,a4,255
    8001aaa6:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            if (viodev.common_cfg->device_feature & VIRTIO_F_IN_ORDER) {
    8001aaaa:	f4043783          	ld	a5,-192(s0)
    8001aaae:	43dc                	lw	a5,4(a5)
    8001aab0:	2781                	sext.w	a5,a5
    8001aab2:	0237f793          	andi	a5,a5,35
    8001aab6:	2781                	sext.w	a5,a5
    8001aab8:	cf81                	beqz	a5,8001aad0 <virtio_init+0xf4>
                debugf("Device supports in-order\n");
                viodev.common_cfg->driver_feature |= VIRTIO_F_IN_ORDER;
    8001aaba:	f4043783          	ld	a5,-192(s0)
    8001aabe:	47dc                	lw	a5,12(a5)
    8001aac0:	0007871b          	sext.w	a4,a5
    8001aac4:	f4043783          	ld	a5,-192(s0)
    8001aac8:	02376713          	ori	a4,a4,35
    8001aacc:	2701                	sext.w	a4,a4
    8001aace:	c7d8                	sw	a4,12(a5)
            } else {
                debugf("Device does not support in-order\n");
            }
            viodev.common_cfg->device_status |= VIRTIO_F_FEATURES_OK;
    8001aad0:	f4043783          	ld	a5,-192(s0)
    8001aad4:	0147c783          	lbu	a5,20(a5)
    8001aad8:	0ff7f713          	andi	a4,a5,255
    8001aadc:	f4043783          	ld	a5,-192(s0)
    8001aae0:	00876713          	ori	a4,a4,8
    8001aae4:	0ff77713          	andi	a4,a4,255
    8001aae8:	00e78a23          	sb	a4,20(a5)
            if (!(viodev.common_cfg->device_status & VIRTIO_F_FEATURES_OK)) {
    8001aaec:	f4043783          	ld	a5,-192(s0)
    8001aaf0:	0147c783          	lbu	a5,20(a5)
    8001aaf4:	0ff7f793          	andi	a5,a5,255
    8001aaf8:	2781                	sext.w	a5,a5
    8001aafa:	8ba1                	andi	a5,a5,8
    8001aafc:	2781                	sext.w	a5,a5
    8001aafe:	e799                	bnez	a5,8001ab0c <virtio_init+0x130>
                warnf("Device does not accept features\n");
    8001ab00:	0000b517          	auipc	a0,0xb
    8001ab04:	bf850513          	addi	a0,a0,-1032 # 800256f8 <pow10.0+0x14c8>
    8001ab08:	ef8fe0ef          	jal	ra,80019200 <warnf>
            }
            
            // Fix qsize below
            viodev.common_cfg->queue_select = 0;
    8001ab0c:	f4043783          	ld	a5,-192(s0)
    8001ab10:	00079b23          	sh	zero,22(a5)
            uint16_t qsize = viodev.common_cfg->queue_size;
    8001ab14:	f4043783          	ld	a5,-192(s0)
    8001ab18:	0187d783          	lhu	a5,24(a5)
    8001ab1c:	faf41723          	sh	a5,-82(s0)
            debugf("Virtio device has queue size %d\n", qsize);

            // Allocate contiguous physical memory for descriptor table, driver ring, and device ring
            // These are virtual memory pointers that we will use in the OS side.
            viodev.desc = (VirtioDescriptor *)kzalloc(VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
    8001ab20:	fae45783          	lhu	a5,-82(s0)
    8001ab24:	2781                	sext.w	a5,a5
    8001ab26:	0047979b          	slliw	a5,a5,0x4
    8001ab2a:	2781                	sext.w	a5,a5
    8001ab2c:	85be                	mv	a1,a5
    8001ab2e:	4505                	li	a0,1
    8001ab30:	986f90ef          	jal	ra,80013cb6 <kcalloc>
    8001ab34:	87aa                	mv	a5,a0
    8001ab36:	f4f43c23          	sd	a5,-168(s0)
            viodev.driver = (VirtioDriverRing *)kzalloc(VIRTIO_DRIVER_TABLE_BYTES(qsize));
    8001ab3a:	fae45783          	lhu	a5,-82(s0)
    8001ab3e:	2781                	sext.w	a5,a5
    8001ab40:	278d                	addiw	a5,a5,3
    8001ab42:	2781                	sext.w	a5,a5
    8001ab44:	0017979b          	slliw	a5,a5,0x1
    8001ab48:	2781                	sext.w	a5,a5
    8001ab4a:	85be                	mv	a1,a5
    8001ab4c:	4505                	li	a0,1
    8001ab4e:	968f90ef          	jal	ra,80013cb6 <kcalloc>
    8001ab52:	87aa                	mv	a5,a0
    8001ab54:	f6f43023          	sd	a5,-160(s0)
            viodev.device = (VirtioDeviceRing *)kzalloc(VIRTIO_DEVICE_TABLE_BYTES(qsize));
    8001ab58:	fae45783          	lhu	a5,-82(s0)
    8001ab5c:	2781                	sext.w	a5,a5
    8001ab5e:	0037979b          	slliw	a5,a5,0x3
    8001ab62:	2781                	sext.w	a5,a5
    8001ab64:	2799                	addiw	a5,a5,6
    8001ab66:	2781                	sext.w	a5,a5
    8001ab68:	85be                	mv	a1,a5
    8001ab6a:	4505                	li	a0,1
    8001ab6c:	94af90ef          	jal	ra,80013cb6 <kcalloc>
    8001ab70:	87aa                	mv	a5,a0
    8001ab72:	f6f43423          	sd	a5,-152(s0)
            debugf("Descriptor ring size: %d\n", VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
            debugf("Driver ring size: %d\n", VIRTIO_DRIVER_TABLE_BYTES(qsize));
            debugf("Device ring size: %d\n", VIRTIO_DEVICE_TABLE_BYTES(qsize));

            // Initialize the indices
            viodev.desc_idx = 0;
    8001ab76:	f8041023          	sh	zero,-128(s0)
            viodev.driver_idx = 0;
    8001ab7a:	f8041123          	sh	zero,-126(s0)
            viodev.device_idx = 0;
    8001ab7e:	f8041223          	sh	zero,-124(s0)

            // Add the physical addresses for the descriptor table, driver ring, and device ring to the common configuration
            // We translate the virtual addresses so the devices can actuall access the memory.
            uint64_t phys_desc = kernel_mmu_translate((uint64_t)viodev.desc),
    8001ab82:	f5843783          	ld	a5,-168(s0)
    8001ab86:	853e                	mv	a0,a5
    8001ab88:	94aff0ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    8001ab8c:	faa43023          	sd	a0,-96(s0)
                phys_driver = kernel_mmu_translate((uint64_t)viodev.driver),
    8001ab90:	f6043783          	ld	a5,-160(s0)
    8001ab94:	853e                	mv	a0,a5
    8001ab96:	93cff0ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    8001ab9a:	f8a43c23          	sd	a0,-104(s0)
                phys_device = kernel_mmu_translate((uint64_t)viodev.device);
    8001ab9e:	f6843783          	ld	a5,-152(s0)
    8001aba2:	853e                	mv	a0,a5
    8001aba4:	92eff0ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    8001aba8:	f8a43823          	sd	a0,-112(s0)
            viodev.common_cfg->queue_desc = phys_desc;
    8001abac:	f4043783          	ld	a5,-192(s0)
    8001abb0:	fa043703          	ld	a4,-96(s0)
    8001abb4:	f398                	sd	a4,32(a5)
            viodev.common_cfg->queue_driver = phys_driver;
    8001abb6:	f4043783          	ld	a5,-192(s0)
    8001abba:	f9843703          	ld	a4,-104(s0)
    8001abbe:	f798                	sd	a4,40(a5)
            viodev.common_cfg->queue_device = phys_device;
    8001abc0:	f4043783          	ld	a5,-192(s0)
    8001abc4:	f9043703          	ld	a4,-112(s0)
    8001abc8:	fb98                	sd	a4,48(a5)
            debugf("virtio_init: queue_desc = 0x%08lx physical (0x%08lx virtual)\n", phys_desc, viodev.desc);
            debugf("virtio_init: queue_driver = 0x%08lx physical (0x%08lx virtual)\n", phys_driver, viodev.driver);
            debugf("virtio_init: queue_device = 0x%08lx physical (0x%08lx virtual)\n", phys_device, viodev.device);
            if (viodev.common_cfg->queue_desc != phys_desc) {
    8001abca:	f4043783          	ld	a5,-192(s0)
    8001abce:	739c                	ld	a5,32(a5)
    8001abd0:	fa043703          	ld	a4,-96(s0)
    8001abd4:	02f70363          	beq	a4,a5,8001abfa <virtio_init+0x21e>
                warnf("Device does not reflect physical desc ring  @0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_desc, phys_desc, viodev.common_cfg->queue_desc);
    8001abd8:	f4043783          	ld	a5,-192(s0)
    8001abdc:	02078713          	addi	a4,a5,32
    8001abe0:	f4043783          	ld	a5,-192(s0)
    8001abe4:	739c                	ld	a5,32(a5)
    8001abe6:	86be                	mv	a3,a5
    8001abe8:	fa043603          	ld	a2,-96(s0)
    8001abec:	85ba                	mv	a1,a4
    8001abee:	0000b517          	auipc	a0,0xb
    8001abf2:	b3250513          	addi	a0,a0,-1230 # 80025720 <pow10.0+0x14f0>
    8001abf6:	e0afe0ef          	jal	ra,80019200 <warnf>
            }
            if (viodev.common_cfg->queue_driver != phys_driver) {
    8001abfa:	f4043783          	ld	a5,-192(s0)
    8001abfe:	779c                	ld	a5,40(a5)
    8001ac00:	f9843703          	ld	a4,-104(s0)
    8001ac04:	02f70363          	beq	a4,a5,8001ac2a <virtio_init+0x24e>
                warnf("Device does not reflect physical driver ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_driver, phys_driver, viodev.common_cfg->queue_driver);
    8001ac08:	f4043783          	ld	a5,-192(s0)
    8001ac0c:	02878713          	addi	a4,a5,40
    8001ac10:	f4043783          	ld	a5,-192(s0)
    8001ac14:	779c                	ld	a5,40(a5)
    8001ac16:	86be                	mv	a3,a5
    8001ac18:	f9843603          	ld	a2,-104(s0)
    8001ac1c:	85ba                	mv	a1,a4
    8001ac1e:	0000b517          	auipc	a0,0xb
    8001ac22:	b5250513          	addi	a0,a0,-1198 # 80025770 <pow10.0+0x1540>
    8001ac26:	ddafe0ef          	jal	ra,80019200 <warnf>
            }
            if (viodev.common_cfg->queue_device != phys_device){
    8001ac2a:	f4043783          	ld	a5,-192(s0)
    8001ac2e:	7b9c                	ld	a5,48(a5)
    8001ac30:	f9043703          	ld	a4,-112(s0)
    8001ac34:	02f70363          	beq	a4,a5,8001ac5a <virtio_init+0x27e>
                warnf("Device does not reflect physical device ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_device, phys_device, viodev.common_cfg->queue_device);
    8001ac38:	f4043783          	ld	a5,-192(s0)
    8001ac3c:	03078713          	addi	a4,a5,48
    8001ac40:	f4043783          	ld	a5,-192(s0)
    8001ac44:	7b9c                	ld	a5,48(a5)
    8001ac46:	86be                	mv	a3,a5
    8001ac48:	f9043603          	ld	a2,-112(s0)
    8001ac4c:	85ba                	mv	a1,a4
    8001ac4e:	0000b517          	auipc	a0,0xb
    8001ac52:	b7250513          	addi	a0,a0,-1166 # 800257c0 <pow10.0+0x1590>
    8001ac56:	daafe0ef          	jal	ra,80019200 <warnf>
            }
            debugf("Set up tables for virtio device\n");
            viodev.common_cfg->queue_enable = 1;
    8001ac5a:	f4043783          	ld	a5,-192(s0)
    8001ac5e:	4705                	li	a4,1
    8001ac60:	00e79e23          	sh	a4,28(a5)
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER_OK;
    8001ac64:	f4043783          	ld	a5,-192(s0)
    8001ac68:	0147c783          	lbu	a5,20(a5)
    8001ac6c:	0ff7f713          	andi	a4,a5,255
    8001ac70:	f4043783          	ld	a5,-192(s0)
    8001ac74:	00476713          	ori	a4,a4,4
    8001ac78:	0ff77713          	andi	a4,a4,255
    8001ac7c:	00e78a23          	sb	a4,20(a5)
            viodev.device->flags = 0;
    8001ac80:	f6843783          	ld	a5,-152(s0)
    8001ac84:	00079023          	sh	zero,0(a5)
            viodev.lock = MUTEX_UNLOCKED;
    8001ac88:	f8042423          	sw	zero,-120(s0)
            viodev.jobs = vector_new();
    8001ac8c:	333050ef          	jal	ra,800207be <vector_new>
    8001ac90:	87aa                	mv	a5,a0
    8001ac92:	f6f43c23          	sd	a5,-136(s0)
            virtio_set_device_name(&viodev, "Unknown Virtio Device");
    8001ac96:	ef840793          	addi	a5,s0,-264
    8001ac9a:	0000b597          	auipc	a1,0xb
    8001ac9e:	b7658593          	addi	a1,a1,-1162 # 80025810 <pow10.0+0x15e0>
    8001aca2:	853e                	mv	a0,a5
    8001aca4:	0ee000ef          	jal	ra,8001ad92 <virtio_set_device_name>
            // Add to vector using vector_push
            virtio_save_device(viodev);
    8001aca8:	e5040793          	addi	a5,s0,-432
    8001acac:	ef840713          	addi	a4,s0,-264
    8001acb0:	09800693          	li	a3,152
    8001acb4:	8636                	mv	a2,a3
    8001acb6:	85ba                	mv	a1,a4
    8001acb8:	853e                	mv	a0,a5
    8001acba:	1b4050ef          	jal	ra,8001fe6e <memcpy>
    8001acbe:	e5040793          	addi	a5,s0,-432
    8001acc2:	853e                	mv	a0,a5
    8001acc4:	bf9ff0ef          	jal	ra,8001a8bc <virtio_save_device>
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    8001acc8:	fd843783          	ld	a5,-40(s0)
    8001accc:	0785                	addi	a5,a5,1
    8001acce:	fcf43c23          	sd	a5,-40(s0)
    8001acd2:	fd843703          	ld	a4,-40(s0)
    8001acd6:	fc843783          	ld	a5,-56(s0)
    8001acda:	d2f765e3          	bltu	a4,a5,8001aa04 <virtio_init+0x28>
        }
    }
    rng_device_init();
    8001acde:	8fff70ef          	jal	ra,800125dc <rng_device_init>
    block_device_init();
    8001ace2:	4f4010ef          	jal	ra,8001c1d6 <block_device_init>
    gpu_device_init();
    8001ace6:	b2ffc0ef          	jal	ra,80017814 <gpu_device_init>
    /*
    loop over every virtio device and initialize based on type
    */

    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001acea:	fc041b23          	sh	zero,-42(s0)
    8001acee:	a82d                	j	8001ad28 <virtio_init+0x34c>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001acf0:	fd645783          	lhu	a5,-42(s0)
    8001acf4:	853e                	mv	a0,a5
    8001acf6:	b8dff0ef          	jal	ra,8001a882 <virtio_get_nth_saved_device>
    8001acfa:	faa43c23          	sd	a0,-72(s0)
        if(virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_INPUT)){
    8001acfe:	fb843503          	ld	a0,-72(s0)
    8001ad02:	8d3ff0ef          	jal	ra,8001a5d4 <virtio_get_device_id>
    8001ad06:	87aa                	mv	a5,a0
    8001ad08:	0007871b          	sext.w	a4,a5
    8001ad0c:	6785                	lui	a5,0x1
    8001ad0e:	05278793          	addi	a5,a5,82 # 1052 <i+0x1032>
    8001ad12:	00f71663          	bne	a4,a5,8001ad1e <virtio_init+0x342>
            input_device_init(dev);
    8001ad16:	fb843503          	ld	a0,-72(s0)
    8001ad1a:	7c7000ef          	jal	ra,8001bce0 <input_device_init>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001ad1e:	fd645783          	lhu	a5,-42(s0)
    8001ad22:	2785                	addiw	a5,a5,1
    8001ad24:	fcf41b23          	sh	a5,-42(s0)
    8001ad28:	fd645483          	lhu	s1,-42(s0)
    8001ad2c:	c57ff0ef          	jal	ra,8001a982 <virtio_count_saved_devices>
    8001ad30:	87aa                	mv	a5,a0
    8001ad32:	faf4efe3          	bltu	s1,a5,8001acf0 <virtio_init+0x314>
        }
    }
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001ad36:	fc041a23          	sh	zero,-44(s0)
    8001ad3a:	a835                	j	8001ad76 <virtio_init+0x39a>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001ad3c:	fd445783          	lhu	a5,-44(s0)
    8001ad40:	853e                	mv	a0,a5
    8001ad42:	b41ff0ef          	jal	ra,8001a882 <virtio_get_nth_saved_device>
    8001ad46:	fca43023          	sd	a0,-64(s0)
        infof("Found device #%u: \"%s\"\n", i, virtio_get_device_name(dev));
    8001ad4a:	fd445783          	lhu	a5,-44(s0)
    8001ad4e:	0007849b          	sext.w	s1,a5
    8001ad52:	fc043503          	ld	a0,-64(s0)
    8001ad56:	068000ef          	jal	ra,8001adbe <virtio_get_device_name>
    8001ad5a:	87aa                	mv	a5,a0
    8001ad5c:	863e                	mv	a2,a5
    8001ad5e:	85a6                	mv	a1,s1
    8001ad60:	0000b517          	auipc	a0,0xb
    8001ad64:	ac850513          	addi	a0,a0,-1336 # 80025828 <pow10.0+0x15f8>
    8001ad68:	d46fe0ef          	jal	ra,800192ae <infof>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001ad6c:	fd445783          	lhu	a5,-44(s0)
    8001ad70:	2785                	addiw	a5,a5,1
    8001ad72:	fcf41a23          	sh	a5,-44(s0)
    8001ad76:	fd445483          	lhu	s1,-44(s0)
    8001ad7a:	c09ff0ef          	jal	ra,8001a982 <virtio_count_saved_devices>
    8001ad7e:	87aa                	mv	a5,a0
    8001ad80:	faf4eee3          	bltu	s1,a5,8001ad3c <virtio_init+0x360>
    }
    debugf("virtio_init: Done initializing virtio system\n");
}
    8001ad84:	0001                	nop
    8001ad86:	0001                	nop
    8001ad88:	70ba                	ld	ra,424(sp)
    8001ad8a:	741a                	ld	s0,416(sp)
    8001ad8c:	64fa                	ld	s1,408(sp)
    8001ad8e:	615d                	addi	sp,sp,432
    8001ad90:	8082                	ret

000000008001ad92 <virtio_set_device_name>:

void virtio_set_device_name(VirtioDevice *dev, const char *name) {
    8001ad92:	1101                	addi	sp,sp,-32
    8001ad94:	ec06                	sd	ra,24(sp)
    8001ad96:	e822                	sd	s0,16(sp)
    8001ad98:	1000                	addi	s0,sp,32
    8001ad9a:	fea43423          	sd	a0,-24(s0)
    8001ad9e:	feb43023          	sd	a1,-32(s0)
    strncpy(dev->name, name, sizeof(dev->name));
    8001ada2:	fe843783          	ld	a5,-24(s0)
    8001ada6:	04000613          	li	a2,64
    8001adaa:	fe043583          	ld	a1,-32(s0)
    8001adae:	853e                	mv	a0,a5
    8001adb0:	7de050ef          	jal	ra,8002058e <strncpy>
}
    8001adb4:	0001                	nop
    8001adb6:	60e2                	ld	ra,24(sp)
    8001adb8:	6442                	ld	s0,16(sp)
    8001adba:	6105                	addi	sp,sp,32
    8001adbc:	8082                	ret

000000008001adbe <virtio_get_device_name>:

const char *virtio_get_device_name(VirtioDevice *dev) {
    8001adbe:	1101                	addi	sp,sp,-32
    8001adc0:	ec22                	sd	s0,24(sp)
    8001adc2:	1000                	addi	s0,sp,32
    8001adc4:	fea43423          	sd	a0,-24(s0)
    return dev->name;
    8001adc8:	fe843783          	ld	a5,-24(s0)
}
    8001adcc:	853e                	mv	a0,a5
    8001adce:	6462                	ld	s0,24(sp)
    8001add0:	6105                	addi	sp,sp,32
    8001add2:	8082                	ret

000000008001add4 <virtio_notify_register>:

// Get the notify capability for the given virtio device.
volatile uint16_t *virtio_notify_register(VirtioDevice *device) {
    8001add4:	715d                	addi	sp,sp,-80
    8001add6:	e486                	sd	ra,72(sp)
    8001add8:	e0a2                	sd	s0,64(sp)
    8001adda:	0880                	addi	s0,sp,80
    8001addc:	faa43c23          	sd	a0,-72(s0)
    // struct VirtioCapability *vio_cap = pci_get_virtio_capability(device->pcidev, VIRTIO_PCI_CAP_NOTIFY_CFG);
    // volatile VirtioPciNotifyCfg *notify_cap = pci_get_virtio_notify_capability(device->pcidev);
    uint8_t bar_num = device->notify_cap->cap.bar;
    8001ade0:	fb843783          	ld	a5,-72(s0)
    8001ade4:	6bbc                	ld	a5,80(a5)
    8001ade6:	0047c783          	lbu	a5,4(a5)
    8001adea:	fef407a3          	sb	a5,-17(s0)
    uint64_t offset = device->notify_cap->cap.offset;
    8001adee:	fb843783          	ld	a5,-72(s0)
    8001adf2:	6bbc                	ld	a5,80(a5)
    8001adf4:	479c                	lw	a5,8(a5)
    8001adf6:	2781                	sext.w	a5,a5
    8001adf8:	1782                	slli	a5,a5,0x20
    8001adfa:	9381                	srli	a5,a5,0x20
    8001adfc:	fef43023          	sd	a5,-32(s0)
    uint16_t queue_notify_off = device->common_cfg->queue_notify_off;
    8001ae00:	fb843783          	ld	a5,-72(s0)
    8001ae04:	67bc                	ld	a5,72(a5)
    8001ae06:	01e7d783          	lhu	a5,30(a5)
    8001ae0a:	fcf41f23          	sh	a5,-34(s0)
    uint32_t notify_off_multiplier = device->notify_cap->notify_off_multiplier;
    8001ae0e:	fb843783          	ld	a5,-72(s0)
    8001ae12:	6bbc                	ld	a5,80(a5)
    8001ae14:	4b9c                	lw	a5,16(a5)
    8001ae16:	fcf42c23          	sw	a5,-40(s0)
    uint64_t bar = (uint64_t)pci_get_device_bar(device->pcidev, bar_num);
    8001ae1a:	fb843783          	ld	a5,-72(s0)
    8001ae1e:	63bc                	ld	a5,64(a5)
    8001ae20:	fef44703          	lbu	a4,-17(s0)
    8001ae24:	85ba                	mv	a1,a4
    8001ae26:	853e                	mv	a0,a5
    8001ae28:	eb7f70ef          	jal	ra,80012cde <pci_get_device_bar>
    8001ae2c:	87aa                	mv	a5,a0
    8001ae2e:	fcf43823          	sd	a5,-48(s0)
    // debugf("Notify cap bar=%d offset=%x, (len=%d)\n", bar_num, offset, device->notify_cap->cap.length);
    // debugf("BAR at %x, offset=%x, queue_notify_off=%x, notify_off_mult=%x\n", bar, offset, queue_notify_off, notify_off_multiplier);

    uint16_t *notify = (uint16_t*)(bar + BAR_NOTIFY_CAP(offset, queue_notify_off, notify_off_multiplier));
    8001ae32:	fde45783          	lhu	a5,-34(s0)
    8001ae36:	2781                	sext.w	a5,a5
    8001ae38:	fd842703          	lw	a4,-40(s0)
    8001ae3c:	02f707bb          	mulw	a5,a4,a5
    8001ae40:	2781                	sext.w	a5,a5
    8001ae42:	02079713          	slli	a4,a5,0x20
    8001ae46:	9301                	srli	a4,a4,0x20
    8001ae48:	fe043783          	ld	a5,-32(s0)
    8001ae4c:	973e                	add	a4,a4,a5
    8001ae4e:	fd043783          	ld	a5,-48(s0)
    8001ae52:	97ba                	add	a5,a5,a4
    8001ae54:	fcf43423          	sd	a5,-56(s0)
    return notify;
    8001ae58:	fc843783          	ld	a5,-56(s0)
}
    8001ae5c:	853e                	mv	a0,a5
    8001ae5e:	60a6                	ld	ra,72(sp)
    8001ae60:	6406                	ld	s0,64(sp)
    8001ae62:	6161                	addi	sp,sp,80
    8001ae64:	8082                	ret

000000008001ae66 <virtio_notify>:
 * @brief Virtio notification
 * @param viodev - virtio device to notify for
 * @param which_queue - queue number to notify
 */
void virtio_notify(VirtioDevice *viodev, uint16_t which_queue)
{
    8001ae66:	7179                	addi	sp,sp,-48
    8001ae68:	f406                	sd	ra,40(sp)
    8001ae6a:	f022                	sd	s0,32(sp)
    8001ae6c:	1800                	addi	s0,sp,48
    8001ae6e:	fca43c23          	sd	a0,-40(s0)
    8001ae72:	87ae                	mv	a5,a1
    8001ae74:	fcf41b23          	sh	a5,-42(s0)
    uint16_t num_queues = viodev->common_cfg->num_queues;
    8001ae78:	fd843783          	ld	a5,-40(s0)
    8001ae7c:	67bc                	ld	a5,72(a5)
    8001ae7e:	0127d783          	lhu	a5,18(a5)
    8001ae82:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    8001ae86:	fd645703          	lhu	a4,-42(s0)
    8001ae8a:	fee45783          	lhu	a5,-18(s0)
    8001ae8e:	2701                	sext.w	a4,a4
    8001ae90:	2781                	sext.w	a5,a5
    8001ae92:	02f76363          	bltu	a4,a5,8001aeb8 <virtio_notify+0x52>
        warnf("virtio_notify: Provided queue number %d is too big (num_queues=%d) for device %s\n", which_queue, num_queues, viodev->name);
    8001ae96:	fd645783          	lhu	a5,-42(s0)
    8001ae9a:	2781                	sext.w	a5,a5
    8001ae9c:	fee45703          	lhu	a4,-18(s0)
    8001aea0:	2701                	sext.w	a4,a4
    8001aea2:	fd843683          	ld	a3,-40(s0)
    8001aea6:	863a                	mv	a2,a4
    8001aea8:	85be                	mv	a1,a5
    8001aeaa:	0000b517          	auipc	a0,0xb
    8001aeae:	99650513          	addi	a0,a0,-1642 # 80025840 <pow10.0+0x1610>
    8001aeb2:	b4efe0ef          	jal	ra,80019200 <warnf>
        return;
    8001aeb6:	a025                	j	8001aede <virtio_notify+0x78>
    }

    // Select the queue we are looking at
    viodev->common_cfg->queue_select = which_queue;
    8001aeb8:	fd843783          	ld	a5,-40(s0)
    8001aebc:	67bc                	ld	a5,72(a5)
    8001aebe:	fd645703          	lhu	a4,-42(s0)
    8001aec2:	00e79b23          	sh	a4,22(a5)

    volatile uint16_t *notify_register = virtio_notify_register(viodev);
    8001aec6:	fd843503          	ld	a0,-40(s0)
    8001aeca:	f0bff0ef          	jal	ra,8001add4 <virtio_notify_register>
    8001aece:	fea43023          	sd	a0,-32(s0)
    // debugf("Notifying at 0x%p on instruction...\n", notify_register);
    *notify_register = which_queue;
    8001aed2:	fe043783          	ld	a5,-32(s0)
    8001aed6:	fd645703          	lhu	a4,-42(s0)
    8001aeda:	00e79023          	sh	a4,0(a5)
    // debugf("Notified device\n\n");
}
    8001aede:	70a2                	ld	ra,40(sp)
    8001aee0:	7402                	ld	s0,32(sp)
    8001aee2:	6145                	addi	sp,sp,48
    8001aee4:	8082                	ret

000000008001aee6 <virtio_set_queue_and_get_size>:

// Select the queue and get its size
uint16_t virtio_set_queue_and_get_size(VirtioDevice *device, uint16_t which_queue) {
    8001aee6:	7179                	addi	sp,sp,-48
    8001aee8:	f406                	sd	ra,40(sp)
    8001aeea:	f022                	sd	s0,32(sp)
    8001aeec:	1800                	addi	s0,sp,48
    8001aeee:	fca43c23          	sd	a0,-40(s0)
    8001aef2:	87ae                	mv	a5,a1
    8001aef4:	fcf41b23          	sh	a5,-42(s0)
    if (device->common_cfg->queue_select != which_queue) {
    8001aef8:	fd843783          	ld	a5,-40(s0)
    8001aefc:	67bc                	ld	a5,72(a5)
    8001aefe:	0167d783          	lhu	a5,22(a5)
    8001af02:	17c2                	slli	a5,a5,0x30
    8001af04:	93c1                	srli	a5,a5,0x30
    8001af06:	fd645703          	lhu	a4,-42(s0)
    8001af0a:	2701                	sext.w	a4,a4
    8001af0c:	2781                	sext.w	a5,a5
    8001af0e:	00f70963          	beq	a4,a5,8001af20 <virtio_set_queue_and_get_size+0x3a>
        device->common_cfg->queue_select = which_queue;
    8001af12:	fd843783          	ld	a5,-40(s0)
    8001af16:	67bc                	ld	a5,72(a5)
    8001af18:	fd645703          	lhu	a4,-42(s0)
    8001af1c:	00e79b23          	sh	a4,22(a5)
    }
    uint16_t num_queues = device->common_cfg->num_queues;
    8001af20:	fd843783          	ld	a5,-40(s0)
    8001af24:	67bc                	ld	a5,72(a5)
    8001af26:	0127d783          	lhu	a5,18(a5)
    8001af2a:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    8001af2e:	fd645703          	lhu	a4,-42(s0)
    8001af32:	fee45783          	lhu	a5,-18(s0)
    8001af36:	2701                	sext.w	a4,a4
    8001af38:	2781                	sext.w	a5,a5
    8001af3a:	02f76363          	bltu	a4,a5,8001af60 <virtio_set_queue_and_get_size+0x7a>
        warnf("virtio_notify: Provided queue number %d is too big (num_queues=%d)...\n", which_queue, num_queues);
    8001af3e:	fd645783          	lhu	a5,-42(s0)
    8001af42:	2781                	sext.w	a5,a5
    8001af44:	fee45703          	lhu	a4,-18(s0)
    8001af48:	2701                	sext.w	a4,a4
    8001af4a:	863a                	mv	a2,a4
    8001af4c:	85be                	mv	a1,a5
    8001af4e:	0000b517          	auipc	a0,0xb
    8001af52:	94a50513          	addi	a0,a0,-1718 # 80025898 <pow10.0+0x1668>
    8001af56:	aaafe0ef          	jal	ra,80019200 <warnf>
        return -1;
    8001af5a:	67c1                	lui	a5,0x10
    8001af5c:	17fd                	addi	a5,a5,-1
    8001af5e:	a801                	j	8001af6e <virtio_set_queue_and_get_size+0x88>
    }

    return device->common_cfg->queue_size;
    8001af60:	fd843783          	ld	a5,-40(s0)
    8001af64:	67bc                	ld	a5,72(a5)
    8001af66:	0187d783          	lhu	a5,24(a5) # 10018 <i+0xfff8>
    8001af6a:	17c2                	slli	a5,a5,0x30
    8001af6c:	93c1                	srli	a5,a5,0x30
}
    8001af6e:	853e                	mv	a0,a5
    8001af70:	70a2                	ld	ra,40(sp)
    8001af72:	7402                	ld	s0,32(sp)
    8001af74:	6145                	addi	sp,sp,48
    8001af76:	8082                	ret

000000008001af78 <virtio_send_one_descriptor>:

void virtio_send_one_descriptor(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor descriptor, bool notify_device_when_done) {
    8001af78:	7179                	addi	sp,sp,-48
    8001af7a:	f406                	sd	ra,40(sp)
    8001af7c:	f022                	sd	s0,32(sp)
    8001af7e:	1800                	addi	s0,sp,48
    8001af80:	fea43423          	sd	a0,-24(s0)
    8001af84:	87ae                	mv	a5,a1
    8001af86:	fcc43823          	sd	a2,-48(s0)
    8001af8a:	fcd43c23          	sd	a3,-40(s0)
    8001af8e:	fef41323          	sh	a5,-26(s0)
    8001af92:	87ba                	mv	a5,a4
    8001af94:	fef402a3          	sb	a5,-27(s0)
    virtio_send_descriptor_chain(device, which_queue, &descriptor, 1, notify_device_when_done);
    8001af98:	fe544703          	lbu	a4,-27(s0)
    8001af9c:	fd040613          	addi	a2,s0,-48
    8001afa0:	fe645783          	lhu	a5,-26(s0)
    8001afa4:	4685                	li	a3,1
    8001afa6:	85be                	mv	a1,a5
    8001afa8:	fe843503          	ld	a0,-24(s0)
    8001afac:	00e000ef          	jal	ra,8001afba <virtio_send_descriptor_chain>
}
    8001afb0:	0001                	nop
    8001afb2:	70a2                	ld	ra,40(sp)
    8001afb4:	7402                	ld	s0,32(sp)
    8001afb6:	6145                	addi	sp,sp,48
    8001afb8:	8082                	ret

000000008001afba <virtio_send_descriptor_chain>:


void virtio_send_descriptor_chain(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor *descriptors, uint16_t num_descriptors, bool notify_device_when_done) {
    8001afba:	711d                	addi	sp,sp,-96
    8001afbc:	ec86                	sd	ra,88(sp)
    8001afbe:	e8a2                	sd	s0,80(sp)
    8001afc0:	1080                	addi	s0,sp,96
    8001afc2:	faa43c23          	sd	a0,-72(s0)
    8001afc6:	87ae                	mv	a5,a1
    8001afc8:	fac43423          	sd	a2,-88(s0)
    8001afcc:	faf41b23          	sh	a5,-74(s0)
    8001afd0:	87b6                	mv	a5,a3
    8001afd2:	faf41a23          	sh	a5,-76(s0)
    8001afd6:	87ba                	mv	a5,a4
    8001afd8:	faf409a3          	sb	a5,-77(s0)
    // Confirm the device is ready
    if (!device->ready) {
    8001afdc:	fb843783          	ld	a5,-72(s0)
    8001afe0:	08e7c783          	lbu	a5,142(a5)
    8001afe4:	0017c793          	xori	a5,a5,1
    8001afe8:	0ff7f793          	andi	a5,a5,255
    8001afec:	cb81                	beqz	a5,8001affc <virtio_send_descriptor_chain+0x42>
        fatalf("device is not ready\n");
    8001afee:	0000b517          	auipc	a0,0xb
    8001aff2:	8f250513          	addi	a0,a0,-1806 # 800258e0 <pow10.0+0x16b0>
    8001aff6:	b0efe0ef          	jal	ra,80019304 <fatalf>
        return;
    8001affa:	aaf1                	j	8001b1d6 <virtio_send_descriptor_chain+0x21c>
    }

    virtio_acquire_device(device);
    8001affc:	fb843503          	ld	a0,-72(s0)
    8001b000:	ad0ff0ef          	jal	ra,8001a2d0 <virtio_acquire_device>

    // Select the queue we're using
    if (which_queue >= device->common_cfg->num_queues) {
    8001b004:	fb843783          	ld	a5,-72(s0)
    8001b008:	67bc                	ld	a5,72(a5)
    8001b00a:	0127d783          	lhu	a5,18(a5)
    8001b00e:	17c2                	slli	a5,a5,0x30
    8001b010:	93c1                	srli	a5,a5,0x30
    8001b012:	fb645703          	lhu	a4,-74(s0)
    8001b016:	2701                	sext.w	a4,a4
    8001b018:	2781                	sext.w	a5,a5
    8001b01a:	02f76763          	bltu	a4,a5,8001b048 <virtio_send_descriptor_chain+0x8e>
        fatalf("queue number %d is too big (num_queues=%d)\n", which_queue, device->common_cfg->num_queues);
    8001b01e:	fb645783          	lhu	a5,-74(s0)
    8001b022:	0007871b          	sext.w	a4,a5
    8001b026:	fb843783          	ld	a5,-72(s0)
    8001b02a:	67bc                	ld	a5,72(a5)
    8001b02c:	0127d783          	lhu	a5,18(a5)
    8001b030:	17c2                	slli	a5,a5,0x30
    8001b032:	93c1                	srli	a5,a5,0x30
    8001b034:	2781                	sext.w	a5,a5
    8001b036:	863e                	mv	a2,a5
    8001b038:	85ba                	mv	a1,a4
    8001b03a:	0000b517          	auipc	a0,0xb
    8001b03e:	8be50513          	addi	a0,a0,-1858 # 800258f8 <pow10.0+0x16c8>
    8001b042:	ac2fe0ef          	jal	ra,80019304 <fatalf>
        return;
    8001b046:	aa41                	j	8001b1d6 <virtio_send_descriptor_chain+0x21c>
    }

    // The size of the queue we're using
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    8001b048:	fb645783          	lhu	a5,-74(s0)
    8001b04c:	85be                	mv	a1,a5
    8001b04e:	fb843503          	ld	a0,-72(s0)
    8001b052:	e95ff0ef          	jal	ra,8001aee6 <virtio_set_queue_and_get_size>
    8001b056:	87aa                	mv	a5,a0
    8001b058:	fef43023          	sd	a5,-32(s0)
#define VIRTQ_DESC_F_NEXT 1
#define VIRTQ_DESC_F_WRITE 2
#define VIRTQ_DESC_F_INDIRECT 4
    uint16_t    flags;
    uint16_t    next;*/
    device->driver_idx = device->driver->idx;
    8001b05c:	fb843783          	ld	a5,-72(s0)
    8001b060:	77bc                	ld	a5,104(a5)
    8001b062:	0027d783          	lhu	a5,2(a5)
    8001b066:	03079713          	slli	a4,a5,0x30
    8001b06a:	9341                	srli	a4,a4,0x30
    8001b06c:	fb843783          	ld	a5,-72(s0)
    8001b070:	08e79523          	sh	a4,138(a5)
    uint64_t head_descriptor_index = device->desc_idx;
    8001b074:	fb843783          	ld	a5,-72(s0)
    8001b078:	0887d783          	lhu	a5,136(a5)
    8001b07c:	fcf43c23          	sd	a5,-40(s0)
    for (int i=0; i<num_descriptors; i++) {
    8001b080:	fe042623          	sw	zero,-20(s0)
    8001b084:	a075                	j	8001b130 <virtio_send_descriptor_chain+0x176>
        uint64_t descriptor_index = (device->desc_idx + i) % queue_size;
    8001b086:	fb843783          	ld	a5,-72(s0)
    8001b08a:	0887d783          	lhu	a5,136(a5)
    8001b08e:	2781                	sext.w	a5,a5
    8001b090:	fec42703          	lw	a4,-20(s0)
    8001b094:	9fb9                	addw	a5,a5,a4
    8001b096:	2781                	sext.w	a5,a5
    8001b098:	873e                	mv	a4,a5
    8001b09a:	fe043783          	ld	a5,-32(s0)
    8001b09e:	02f777b3          	remu	a5,a4,a5
    8001b0a2:	fcf43823          	sd	a5,-48(s0)
        // debugf("Writing descriptor %d to queue %d\n", descriptor_index, which_queue);
        VirtioDescriptor descriptor = descriptors[i];
    8001b0a6:	fec42783          	lw	a5,-20(s0)
    8001b0aa:	0792                	slli	a5,a5,0x4
    8001b0ac:	fa843703          	ld	a4,-88(s0)
    8001b0b0:	97ba                	add	a5,a5,a4
    8001b0b2:	6398                	ld	a4,0(a5)
    8001b0b4:	fce43023          	sd	a4,-64(s0)
    8001b0b8:	679c                	ld	a5,8(a5)
    8001b0ba:	fcf43423          	sd	a5,-56(s0)
        descriptor.next = (descriptor_index + 1) % queue_size;
    8001b0be:	fd043783          	ld	a5,-48(s0)
    8001b0c2:	00178713          	addi	a4,a5,1
    8001b0c6:	fe043783          	ld	a5,-32(s0)
    8001b0ca:	02f777b3          	remu	a5,a4,a5
    8001b0ce:	17c2                	slli	a5,a5,0x30
    8001b0d0:	93c1                	srli	a5,a5,0x30
    8001b0d2:	fcf41723          	sh	a5,-50(s0)
        if (i < num_descriptors - 1) {
    8001b0d6:	fb445783          	lhu	a5,-76(s0)
    8001b0da:	2781                	sext.w	a5,a5
    8001b0dc:	37fd                	addiw	a5,a5,-1
    8001b0de:	0007871b          	sext.w	a4,a5
    8001b0e2:	fec42783          	lw	a5,-20(s0)
    8001b0e6:	2781                	sext.w	a5,a5
    8001b0e8:	00e7db63          	bge	a5,a4,8001b0fe <virtio_send_descriptor_chain+0x144>
            descriptor.flags |= VIRTQ_DESC_F_NEXT;
    8001b0ec:	fcc45783          	lhu	a5,-52(s0)
    8001b0f0:	0017e793          	ori	a5,a5,1
    8001b0f4:	17c2                	slli	a5,a5,0x30
    8001b0f6:	93c1                	srli	a5,a5,0x30
    8001b0f8:	fcf41623          	sh	a5,-52(s0)
    8001b0fc:	a801                	j	8001b10c <virtio_send_descriptor_chain+0x152>
        } else {
            descriptor.flags &= ~VIRTQ_DESC_F_NEXT;
    8001b0fe:	fcc45783          	lhu	a5,-52(s0)
    8001b102:	9bf9                	andi	a5,a5,-2
    8001b104:	17c2                	slli	a5,a5,0x30
    8001b106:	93c1                	srli	a5,a5,0x30
    8001b108:	fcf41623          	sh	a5,-52(s0)
        // debugf("Descriptor addr: %p\n", descriptor.addr);
        // debugf("Descriptor len: 0x%x = %d\n", descriptor.len, descriptor.len);
        // debugf("Descriptor flags: 0x%x = %d\n", descriptor.flags, descriptor.flags);
        // debugf("Descriptor next: 0x%x = %d\n", descriptor.next, descriptor.next);
        // Put the descriptor in the descriptor table
        device->desc[descriptor_index] = descriptor;
    8001b10c:	fb843783          	ld	a5,-72(s0)
    8001b110:	73b8                	ld	a4,96(a5)
    8001b112:	fd043783          	ld	a5,-48(s0)
    8001b116:	0792                	slli	a5,a5,0x4
    8001b118:	97ba                	add	a5,a5,a4
    8001b11a:	fc043703          	ld	a4,-64(s0)
    8001b11e:	e398                	sd	a4,0(a5)
    8001b120:	fc843703          	ld	a4,-56(s0)
    8001b124:	e798                	sd	a4,8(a5)
    for (int i=0; i<num_descriptors; i++) {
    8001b126:	fec42783          	lw	a5,-20(s0)
    8001b12a:	2785                	addiw	a5,a5,1
    8001b12c:	fef42623          	sw	a5,-20(s0)
    8001b130:	fb445783          	lhu	a5,-76(s0)
    8001b134:	0007871b          	sext.w	a4,a5
    8001b138:	fec42783          	lw	a5,-20(s0)
    8001b13c:	2781                	sext.w	a5,a5
    8001b13e:	f4e7c4e3          	blt	a5,a4,8001b086 <virtio_send_descriptor_chain+0xcc>
    }
    // Put the descriptor into the driver ring
    device->driver->ring[device->driver->idx % queue_size] = head_descriptor_index;
    8001b142:	fb843783          	ld	a5,-72(s0)
    8001b146:	77b4                	ld	a3,104(a5)
    8001b148:	fb843783          	ld	a5,-72(s0)
    8001b14c:	77bc                	ld	a5,104(a5)
    8001b14e:	0027d783          	lhu	a5,2(a5)
    8001b152:	17c2                	slli	a5,a5,0x30
    8001b154:	93c1                	srli	a5,a5,0x30
    8001b156:	873e                	mv	a4,a5
    8001b158:	fe043783          	ld	a5,-32(s0)
    8001b15c:	02f777b3          	remu	a5,a4,a5
    8001b160:	fd843703          	ld	a4,-40(s0)
    8001b164:	1742                	slli	a4,a4,0x30
    8001b166:	9341                	srli	a4,a4,0x30
    8001b168:	0786                	slli	a5,a5,0x1
    8001b16a:	97b6                	add	a5,a5,a3
    8001b16c:	00e79223          	sh	a4,4(a5)
    // Increment the index to make it "visible" to the device
    device->driver->idx++;
    8001b170:	fb843783          	ld	a5,-72(s0)
    8001b174:	77bc                	ld	a5,104(a5)
    8001b176:	0027d703          	lhu	a4,2(a5)
    8001b17a:	1742                	slli	a4,a4,0x30
    8001b17c:	9341                	srli	a4,a4,0x30
    8001b17e:	2705                	addiw	a4,a4,1
    8001b180:	1742                	slli	a4,a4,0x30
    8001b182:	9341                	srli	a4,a4,0x30
    8001b184:	00e79123          	sh	a4,2(a5)
    // Update the descriptor index for our bookkeeping
    device->desc_idx = (device->desc_idx + num_descriptors) % queue_size;
    8001b188:	fb843783          	ld	a5,-72(s0)
    8001b18c:	0887d783          	lhu	a5,136(a5)
    8001b190:	0007871b          	sext.w	a4,a5
    8001b194:	fb445783          	lhu	a5,-76(s0)
    8001b198:	2781                	sext.w	a5,a5
    8001b19a:	9fb9                	addw	a5,a5,a4
    8001b19c:	2781                	sext.w	a5,a5
    8001b19e:	873e                	mv	a4,a5
    8001b1a0:	fe043783          	ld	a5,-32(s0)
    8001b1a4:	02f777b3          	remu	a5,a4,a5
    8001b1a8:	03079713          	slli	a4,a5,0x30
    8001b1ac:	9341                	srli	a4,a4,0x30
    8001b1ae:	fb843783          	ld	a5,-72(s0)
    8001b1b2:	08e79423          	sh	a4,136(a5)

    // debugf("Driver index: %d\n", device->driver->idx);
    // debugf("Descriptor index: %d\n", device->desc_idx);
    
    virtio_release_device(device);
    8001b1b6:	fb843503          	ld	a0,-72(s0)
    8001b1ba:	94cff0ef          	jal	ra,8001a306 <virtio_release_device>

    // Notify the device if we're ready to do so
    if (notify_device_when_done) {
    8001b1be:	fb344783          	lbu	a5,-77(s0)
    8001b1c2:	0ff7f793          	andi	a5,a5,255
    8001b1c6:	cb81                	beqz	a5,8001b1d6 <virtio_send_descriptor_chain+0x21c>
        virtio_notify(device, which_queue);
    8001b1c8:	fb645783          	lhu	a5,-74(s0)
    8001b1cc:	85be                	mv	a1,a5
    8001b1ce:	fb843503          	ld	a0,-72(s0)
    8001b1d2:	c95ff0ef          	jal	ra,8001ae66 <virtio_notify>
    }
}
    8001b1d6:	60e6                	ld	ra,88(sp)
    8001b1d8:	6446                	ld	s0,80(sp)
    8001b1da:	6125                	addi	sp,sp,96
    8001b1dc:	8082                	ret

000000008001b1de <virtio_receive_descriptor_chain>:


uint16_t virtio_receive_descriptor_chain(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor *received, uint16_t max_descriptors, bool wait_for_descriptor) {
    8001b1de:	715d                	addi	sp,sp,-80
    8001b1e0:	e486                	sd	ra,72(sp)
    8001b1e2:	e0a2                	sd	s0,64(sp)
    8001b1e4:	0880                	addi	s0,sp,80
    8001b1e6:	fca43423          	sd	a0,-56(s0)
    8001b1ea:	87ae                	mv	a5,a1
    8001b1ec:	fac43c23          	sd	a2,-72(s0)
    8001b1f0:	fcf41323          	sh	a5,-58(s0)
    8001b1f4:	87b6                	mv	a5,a3
    8001b1f6:	fcf41223          	sh	a5,-60(s0)
    8001b1fa:	87ba                	mv	a5,a4
    8001b1fc:	fcf401a3          	sb	a5,-61(s0)
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    8001b200:	fc645783          	lhu	a5,-58(s0)
    8001b204:	85be                	mv	a1,a5
    8001b206:	fc843503          	ld	a0,-56(s0)
    8001b20a:	cddff0ef          	jal	ra,8001aee6 <virtio_set_queue_and_get_size>
    8001b20e:	87aa                	mv	a5,a0
    8001b210:	fcf43c23          	sd	a5,-40(s0)
    if (wait_for_descriptor) {
    8001b214:	fc344783          	lbu	a5,-61(s0)
    8001b218:	0ff7f793          	andi	a5,a5,255
    8001b21c:	cb81                	beqz	a5,8001b22c <virtio_receive_descriptor_chain+0x4e>
        virtio_wait_for_descriptor(device, which_queue);
    8001b21e:	fc645783          	lhu	a5,-58(s0)
    8001b222:	85be                	mv	a1,a5
    8001b224:	fc843503          	ld	a0,-56(s0)
    8001b228:	1fc000ef          	jal	ra,8001b424 <virtio_wait_for_descriptor>
    }

    if (!virtio_has_received_descriptor(device, which_queue)) {
    8001b22c:	fc645783          	lhu	a5,-58(s0)
    8001b230:	85be                	mv	a1,a5
    8001b232:	fc843503          	ld	a0,-56(s0)
    8001b236:	1a0000ef          	jal	ra,8001b3d6 <virtio_has_received_descriptor>
    8001b23a:	87aa                	mv	a5,a0
    8001b23c:	0017c793          	xori	a5,a5,1
    8001b240:	0ff7f793          	andi	a5,a5,255
    8001b244:	cb89                	beqz	a5,8001b256 <virtio_receive_descriptor_chain+0x78>
        warnf("No descriptor received\n");
    8001b246:	0000a517          	auipc	a0,0xa
    8001b24a:	6e250513          	addi	a0,a0,1762 # 80025928 <pow10.0+0x16f8>
    8001b24e:	fb3fd0ef          	jal	ra,80019200 <warnf>
        return 0;
    8001b252:	4781                	li	a5,0
    8001b254:	a209                	j	8001b356 <virtio_receive_descriptor_chain+0x178>
    }
    

    // Get the descriptor index from the device ring
    uint64_t descriptor_index = device->device->ring[device->device_idx % queue_size].id;
    8001b256:	fc843783          	ld	a5,-56(s0)
    8001b25a:	7bb8                	ld	a4,112(a5)
    8001b25c:	fc843783          	ld	a5,-56(s0)
    8001b260:	08c7d783          	lhu	a5,140(a5)
    8001b264:	86be                	mv	a3,a5
    8001b266:	fd843783          	ld	a5,-40(s0)
    8001b26a:	02f6f7b3          	remu	a5,a3,a5
    8001b26e:	078e                	slli	a5,a5,0x3
    8001b270:	97ba                	add	a5,a5,a4
    8001b272:	43dc                	lw	a5,4(a5)
    8001b274:	2781                	sext.w	a5,a5
    8001b276:	1782                	slli	a5,a5,0x20
    8001b278:	9381                	srli	a5,a5,0x20
    8001b27a:	fcf43823          	sd	a5,-48(s0)
    // Get the length of the descriptor
    volatile VirtioDescriptor *descriptor = (volatile VirtioDescriptor*)&device->desc[descriptor_index];
    8001b27e:	fc843783          	ld	a5,-56(s0)
    8001b282:	73b8                	ld	a4,96(a5)
    8001b284:	fd043783          	ld	a5,-48(s0)
    8001b288:	0792                	slli	a5,a5,0x4
    8001b28a:	97ba                	add	a5,a5,a4
    8001b28c:	fef43423          	sd	a5,-24(s0)

    uint16_t i = 0;
    8001b290:	fe041323          	sh	zero,-26(s0)
    while (descriptor->flags & VIRTQ_DESC_F_NEXT) {
    8001b294:	a091                	j	8001b2d8 <virtio_receive_descriptor_chain+0xfa>
        received[i++] = *descriptor;
    8001b296:	fe645783          	lhu	a5,-26(s0)
    8001b29a:	0017871b          	addiw	a4,a5,1
    8001b29e:	fee41323          	sh	a4,-26(s0)
    8001b2a2:	0792                	slli	a5,a5,0x4
    8001b2a4:	fb843703          	ld	a4,-72(s0)
    8001b2a8:	97ba                	add	a5,a5,a4
    8001b2aa:	fe843703          	ld	a4,-24(s0)
    8001b2ae:	6314                	ld	a3,0(a4)
    8001b2b0:	e394                	sd	a3,0(a5)
    8001b2b2:	6718                	ld	a4,8(a4)
    8001b2b4:	e798                	sd	a4,8(a5)
        // debugf("Reading descriptor %d from queue %d\n", descriptor_index, which_queue);
        // debugf("Descriptor addr: %p\n", descriptor->addr);
        // debugf("Descriptor len: 0x%x = %d\n", descriptor->len, descriptor->len);
        // debugf("Descriptor flags: 0x%x = %d\n", descriptor->flags, descriptor->flags);
        // debugf("Descriptor next: 0x%x = %d\n", descriptor->next, descriptor->next);
        descriptor_index = descriptor->next;
    8001b2b6:	fe843783          	ld	a5,-24(s0)
    8001b2ba:	00e7d783          	lhu	a5,14(a5)
    8001b2be:	17c2                	slli	a5,a5,0x30
    8001b2c0:	93c1                	srli	a5,a5,0x30
    8001b2c2:	fcf43823          	sd	a5,-48(s0)
        descriptor = (volatile VirtioDescriptor*)&device->desc[descriptor_index];
    8001b2c6:	fc843783          	ld	a5,-56(s0)
    8001b2ca:	73b8                	ld	a4,96(a5)
    8001b2cc:	fd043783          	ld	a5,-48(s0)
    8001b2d0:	0792                	slli	a5,a5,0x4
    8001b2d2:	97ba                	add	a5,a5,a4
    8001b2d4:	fef43423          	sd	a5,-24(s0)
    while (descriptor->flags & VIRTQ_DESC_F_NEXT) {
    8001b2d8:	fe843783          	ld	a5,-24(s0)
    8001b2dc:	00c7d783          	lhu	a5,12(a5)
    8001b2e0:	17c2                	slli	a5,a5,0x30
    8001b2e2:	93c1                	srli	a5,a5,0x30
    8001b2e4:	2781                	sext.w	a5,a5
    8001b2e6:	8b85                	andi	a5,a5,1
    8001b2e8:	2781                	sext.w	a5,a5
    8001b2ea:	f7d5                	bnez	a5,8001b296 <virtio_receive_descriptor_chain+0xb8>
    }

    received[i] = *descriptor;
    8001b2ec:	fe645783          	lhu	a5,-26(s0)
    8001b2f0:	0792                	slli	a5,a5,0x4
    8001b2f2:	fb843703          	ld	a4,-72(s0)
    8001b2f6:	97ba                	add	a5,a5,a4
    8001b2f8:	fe843703          	ld	a4,-24(s0)
    8001b2fc:	6314                	ld	a3,0(a4)
    8001b2fe:	e394                	sd	a3,0(a5)
    8001b300:	6718                	ld	a4,8(a4)
    8001b302:	e798                	sd	a4,8(a5)
    // debugf("Reading descriptor %d from queue %d\n", i, which_queue);
    // debugf("Descriptor addr: %p\n", descriptor->addr);
    // debugf("Descriptor len: 0x%x = %d\n", descriptor->len, descriptor->len);
    // debugf("Descriptor flags: 0x%x = %d\n", descriptor->flags, descriptor->flags);
    // debugf("Descriptor next: 0x%x = %d\n", descriptor->next, descriptor->next);
    i++;
    8001b304:	fe645783          	lhu	a5,-26(s0)
    8001b308:	2785                	addiw	a5,a5,1
    8001b30a:	fef41323          	sh	a5,-26(s0)
    // device->device_idx = device->device->idx;
    if (i > max_descriptors) {
    8001b30e:	fe645703          	lhu	a4,-26(s0)
    8001b312:	fc445783          	lhu	a5,-60(s0)
    8001b316:	2701                	sext.w	a4,a4
    8001b318:	2781                	sext.w	a5,a5
    8001b31a:	02e7f063          	bgeu	a5,a4,8001b33a <virtio_receive_descriptor_chain+0x15c>
        warnf("Received %d descriptors, but expected %d or fewer\n", i, max_descriptors);
    8001b31e:	fe645783          	lhu	a5,-26(s0)
    8001b322:	2781                	sext.w	a5,a5
    8001b324:	fc445703          	lhu	a4,-60(s0)
    8001b328:	2701                	sext.w	a4,a4
    8001b32a:	863a                	mv	a2,a4
    8001b32c:	85be                	mv	a1,a5
    8001b32e:	0000a517          	auipc	a0,0xa
    8001b332:	61250513          	addi	a0,a0,1554 # 80025940 <pow10.0+0x1710>
    8001b336:	ecbfd0ef          	jal	ra,80019200 <warnf>
    }
    device->device_idx++;
    8001b33a:	fc843783          	ld	a5,-56(s0)
    8001b33e:	08c7d783          	lhu	a5,140(a5)
    8001b342:	2785                	addiw	a5,a5,1
    8001b344:	03079713          	slli	a4,a5,0x30
    8001b348:	9341                	srli	a4,a4,0x30
    8001b34a:	fc843783          	ld	a5,-56(s0)
    8001b34e:	08e79623          	sh	a4,140(a5)
    return i;
    8001b352:	fe645783          	lhu	a5,-26(s0)
}
    8001b356:	853e                	mv	a0,a5
    8001b358:	60a6                	ld	ra,72(sp)
    8001b35a:	6406                	ld	s0,64(sp)
    8001b35c:	6161                	addi	sp,sp,80
    8001b35e:	8082                	ret

000000008001b360 <virtio_receive_one_descriptor>:

VirtioDescriptor virtio_receive_one_descriptor(VirtioDevice *device, uint16_t which_queue, bool wait_for_descriptor) {
    8001b360:	715d                	addi	sp,sp,-80
    8001b362:	e486                	sd	ra,72(sp)
    8001b364:	e0a2                	sd	s0,64(sp)
    8001b366:	fc4a                	sd	s2,56(sp)
    8001b368:	f84e                	sd	s3,48(sp)
    8001b36a:	0880                	addi	s0,sp,80
    8001b36c:	faa43c23          	sd	a0,-72(s0)
    8001b370:	87ae                	mv	a5,a1
    8001b372:	8732                	mv	a4,a2
    8001b374:	faf41b23          	sh	a5,-74(s0)
    8001b378:	87ba                	mv	a5,a4
    8001b37a:	faf40aa3          	sb	a5,-75(s0)
    VirtioDescriptor received;
    received.addr = 0;
    8001b37e:	fc043023          	sd	zero,-64(s0)
    received.flags = 0;
    8001b382:	fc041623          	sh	zero,-52(s0)
    received.len = 0;
    8001b386:	fc042423          	sw	zero,-56(s0)
    received.next = 0;
    8001b38a:	fc041723          	sh	zero,-50(s0)
    virtio_receive_descriptor_chain(device, which_queue, &received, 1, wait_for_descriptor);
    8001b38e:	fb544703          	lbu	a4,-75(s0)
    8001b392:	fc040613          	addi	a2,s0,-64
    8001b396:	fb645783          	lhu	a5,-74(s0)
    8001b39a:	4685                	li	a3,1
    8001b39c:	85be                	mv	a1,a5
    8001b39e:	fb843503          	ld	a0,-72(s0)
    8001b3a2:	e3dff0ef          	jal	ra,8001b1de <virtio_receive_descriptor_chain>
    return received;
    8001b3a6:	fc043783          	ld	a5,-64(s0)
    8001b3aa:	fcf43823          	sd	a5,-48(s0)
    8001b3ae:	fc843783          	ld	a5,-56(s0)
    8001b3b2:	fcf43c23          	sd	a5,-40(s0)
    8001b3b6:	fd043703          	ld	a4,-48(s0)
    8001b3ba:	fd843783          	ld	a5,-40(s0)
    8001b3be:	893a                	mv	s2,a4
    8001b3c0:	89be                	mv	s3,a5
    8001b3c2:	874a                	mv	a4,s2
    8001b3c4:	87ce                	mv	a5,s3
}
    8001b3c6:	853a                	mv	a0,a4
    8001b3c8:	85be                	mv	a1,a5
    8001b3ca:	60a6                	ld	ra,72(sp)
    8001b3cc:	6406                	ld	s0,64(sp)
    8001b3ce:	7962                	ld	s2,56(sp)
    8001b3d0:	79c2                	ld	s3,48(sp)
    8001b3d2:	6161                	addi	sp,sp,80
    8001b3d4:	8082                	ret

000000008001b3d6 <virtio_has_received_descriptor>:

bool virtio_has_received_descriptor(VirtioDevice *device, uint16_t which_queue) {
    8001b3d6:	1101                	addi	sp,sp,-32
    8001b3d8:	ec06                	sd	ra,24(sp)
    8001b3da:	e822                	sd	s0,16(sp)
    8001b3dc:	1000                	addi	s0,sp,32
    8001b3de:	fea43423          	sd	a0,-24(s0)
    8001b3e2:	87ae                	mv	a5,a1
    8001b3e4:	fef41323          	sh	a5,-26(s0)
    virtio_set_queue_and_get_size(device, which_queue);
    8001b3e8:	fe645783          	lhu	a5,-26(s0)
    8001b3ec:	85be                	mv	a1,a5
    8001b3ee:	fe843503          	ld	a0,-24(s0)
    8001b3f2:	af5ff0ef          	jal	ra,8001aee6 <virtio_set_queue_and_get_size>
    if (device->device_idx == device->device->idx) {
    8001b3f6:	fe843783          	ld	a5,-24(s0)
    8001b3fa:	08c7d703          	lhu	a4,140(a5)
    8001b3fe:	fe843783          	ld	a5,-24(s0)
    8001b402:	7bbc                	ld	a5,112(a5)
    8001b404:	0027d783          	lhu	a5,2(a5)
    8001b408:	17c2                	slli	a5,a5,0x30
    8001b40a:	93c1                	srli	a5,a5,0x30
    8001b40c:	2701                	sext.w	a4,a4
    8001b40e:	2781                	sext.w	a5,a5
    8001b410:	00f71463          	bne	a4,a5,8001b418 <virtio_has_received_descriptor+0x42>
        return false;
    8001b414:	4781                	li	a5,0
    8001b416:	a011                	j	8001b41a <virtio_has_received_descriptor+0x44>
    }
    return true;
    8001b418:	4785                	li	a5,1
}
    8001b41a:	853e                	mv	a0,a5
    8001b41c:	60e2                	ld	ra,24(sp)
    8001b41e:	6442                	ld	s0,16(sp)
    8001b420:	6105                	addi	sp,sp,32
    8001b422:	8082                	ret

000000008001b424 <virtio_wait_for_descriptor>:

void virtio_wait_for_descriptor(VirtioDevice *device, uint16_t which_queue) {
    8001b424:	1101                	addi	sp,sp,-32
    8001b426:	ec06                	sd	ra,24(sp)
    8001b428:	e822                	sd	s0,16(sp)
    8001b42a:	1000                	addi	s0,sp,32
    8001b42c:	fea43423          	sd	a0,-24(s0)
    8001b430:	87ae                	mv	a5,a1
    8001b432:	fef41323          	sh	a5,-26(s0)
    while (!virtio_has_received_descriptor(device, which_queue)) {
    8001b436:	0001                	nop
    8001b438:	fe645783          	lhu	a5,-26(s0)
    8001b43c:	85be                	mv	a1,a5
    8001b43e:	fe843503          	ld	a0,-24(s0)
    8001b442:	f95ff0ef          	jal	ra,8001b3d6 <virtio_has_received_descriptor>
    8001b446:	87aa                	mv	a5,a0
    8001b448:	0017c793          	xori	a5,a5,1
    8001b44c:	0ff7f793          	andi	a5,a5,255
    8001b450:	f7e5                	bnez	a5,8001b438 <virtio_wait_for_descriptor+0x14>
        debugf("Blocking on descriptor\n");
        // Do nothing
    }
}
    8001b452:	0001                	nop
    8001b454:	0001                	nop
    8001b456:	60e2                	ld	ra,24(sp)
    8001b458:	6442                	ld	s0,16(sp)
    8001b45a:	6105                	addi	sp,sp,32
    8001b45c:	8082                	ret

000000008001b45e <set_taken>:

static uint8_t *bookkeeping;  // Pointer to the bookkeeping area

// For some reason, the macros didn't work for me, so I used the static functions like Marz said and it works.
static void set_taken(uint64_t index)
{
    8001b45e:	1101                	addi	sp,sp,-32
    8001b460:	ec22                	sd	s0,24(sp)
    8001b462:	1000                	addi	s0,sp,32
    8001b464:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2));
    8001b468:	00008797          	auipc	a5,0x8
    8001b46c:	cd878793          	addi	a5,a5,-808 # 80023140 <bookkeeping>
    8001b470:	6398                	ld	a4,0(a5)
    8001b472:	fe843783          	ld	a5,-24(s0)
    8001b476:	8389                	srli	a5,a5,0x2
    8001b478:	973e                	add	a4,a4,a5
    8001b47a:	00074703          	lbu	a4,0(a4) # ffffffffc0fff000 <_heap_end+0xffffffff38fef000>
    8001b47e:	0187169b          	slliw	a3,a4,0x18
    8001b482:	4186d69b          	sraiw	a3,a3,0x18
    8001b486:	fe843703          	ld	a4,-24(s0)
    8001b48a:	2701                	sext.w	a4,a4
    8001b48c:	8b0d                	andi	a4,a4,3
    8001b48e:	2701                	sext.w	a4,a4
    8001b490:	0017171b          	slliw	a4,a4,0x1
    8001b494:	2701                	sext.w	a4,a4
    8001b496:	4605                	li	a2,1
    8001b498:	00e6173b          	sllw	a4,a2,a4
    8001b49c:	2701                	sext.w	a4,a4
    8001b49e:	0187171b          	slliw	a4,a4,0x18
    8001b4a2:	4187571b          	sraiw	a4,a4,0x18
    8001b4a6:	8f55                	or	a4,a4,a3
    8001b4a8:	0187169b          	slliw	a3,a4,0x18
    8001b4ac:	4186d69b          	sraiw	a3,a3,0x18
    8001b4b0:	00008717          	auipc	a4,0x8
    8001b4b4:	c9070713          	addi	a4,a4,-880 # 80023140 <bookkeeping>
    8001b4b8:	6318                	ld	a4,0(a4)
    8001b4ba:	97ba                	add	a5,a5,a4
    8001b4bc:	0ff6f713          	andi	a4,a3,255
    8001b4c0:	00e78023          	sb	a4,0(a5)
}
    8001b4c4:	0001                	nop
    8001b4c6:	6462                	ld	s0,24(sp)
    8001b4c8:	6105                	addi	sp,sp,32
    8001b4ca:	8082                	ret

000000008001b4cc <clear_taken>:

static void clear_taken(uint64_t index)
{
    8001b4cc:	1101                	addi	sp,sp,-32
    8001b4ce:	ec22                	sd	s0,24(sp)
    8001b4d0:	1000                	addi	s0,sp,32
    8001b4d2:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2));
    8001b4d6:	00008797          	auipc	a5,0x8
    8001b4da:	c6a78793          	addi	a5,a5,-918 # 80023140 <bookkeeping>
    8001b4de:	6398                	ld	a4,0(a5)
    8001b4e0:	fe843783          	ld	a5,-24(s0)
    8001b4e4:	8389                	srli	a5,a5,0x2
    8001b4e6:	973e                	add	a4,a4,a5
    8001b4e8:	00074703          	lbu	a4,0(a4)
    8001b4ec:	0187169b          	slliw	a3,a4,0x18
    8001b4f0:	4186d69b          	sraiw	a3,a3,0x18
    8001b4f4:	fe843703          	ld	a4,-24(s0)
    8001b4f8:	2701                	sext.w	a4,a4
    8001b4fa:	8b0d                	andi	a4,a4,3
    8001b4fc:	2701                	sext.w	a4,a4
    8001b4fe:	0017171b          	slliw	a4,a4,0x1
    8001b502:	2701                	sext.w	a4,a4
    8001b504:	4605                	li	a2,1
    8001b506:	00e6173b          	sllw	a4,a2,a4
    8001b50a:	2701                	sext.w	a4,a4
    8001b50c:	0187171b          	slliw	a4,a4,0x18
    8001b510:	4187571b          	sraiw	a4,a4,0x18
    8001b514:	fff74713          	not	a4,a4
    8001b518:	0187171b          	slliw	a4,a4,0x18
    8001b51c:	4187571b          	sraiw	a4,a4,0x18
    8001b520:	8f75                	and	a4,a4,a3
    8001b522:	0187169b          	slliw	a3,a4,0x18
    8001b526:	4186d69b          	sraiw	a3,a3,0x18
    8001b52a:	00008717          	auipc	a4,0x8
    8001b52e:	c1670713          	addi	a4,a4,-1002 # 80023140 <bookkeeping>
    8001b532:	6318                	ld	a4,0(a4)
    8001b534:	97ba                	add	a5,a5,a4
    8001b536:	0ff6f713          	andi	a4,a3,255
    8001b53a:	00e78023          	sb	a4,0(a5)
}
    8001b53e:	0001                	nop
    8001b540:	6462                	ld	s0,24(sp)
    8001b542:	6105                	addi	sp,sp,32
    8001b544:	8082                	ret

000000008001b546 <is_taken>:

static int is_taken(uint64_t index)
{
    8001b546:	1101                	addi	sp,sp,-32
    8001b548:	ec22                	sd	s0,24(sp)
    8001b54a:	1000                	addi	s0,sp,32
    8001b54c:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2));
    8001b550:	00008797          	auipc	a5,0x8
    8001b554:	bf078793          	addi	a5,a5,-1040 # 80023140 <bookkeeping>
    8001b558:	6398                	ld	a4,0(a5)
    8001b55a:	fe843783          	ld	a5,-24(s0)
    8001b55e:	8389                	srli	a5,a5,0x2
    8001b560:	97ba                	add	a5,a5,a4
    8001b562:	0007c783          	lbu	a5,0(a5)
    8001b566:	0007871b          	sext.w	a4,a5
    8001b56a:	fe843783          	ld	a5,-24(s0)
    8001b56e:	2781                	sext.w	a5,a5
    8001b570:	8b8d                	andi	a5,a5,3
    8001b572:	2781                	sext.w	a5,a5
    8001b574:	0017979b          	slliw	a5,a5,0x1
    8001b578:	2781                	sext.w	a5,a5
    8001b57a:	4685                	li	a3,1
    8001b57c:	00f697bb          	sllw	a5,a3,a5
    8001b580:	2781                	sext.w	a5,a5
    8001b582:	8ff9                	and	a5,a5,a4
    8001b584:	2781                	sext.w	a5,a5
}
    8001b586:	853e                	mv	a0,a5
    8001b588:	6462                	ld	s0,24(sp)
    8001b58a:	6105                	addi	sp,sp,32
    8001b58c:	8082                	ret

000000008001b58e <set_last>:

static void set_last(uint64_t index)
{
    8001b58e:	1101                	addi	sp,sp,-32
    8001b590:	ec22                	sd	s0,24(sp)
    8001b592:	1000                	addi	s0,sp,32
    8001b594:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2 + 1));
    8001b598:	00008797          	auipc	a5,0x8
    8001b59c:	ba878793          	addi	a5,a5,-1112 # 80023140 <bookkeeping>
    8001b5a0:	6398                	ld	a4,0(a5)
    8001b5a2:	fe843783          	ld	a5,-24(s0)
    8001b5a6:	8389                	srli	a5,a5,0x2
    8001b5a8:	973e                	add	a4,a4,a5
    8001b5aa:	00074703          	lbu	a4,0(a4)
    8001b5ae:	0187169b          	slliw	a3,a4,0x18
    8001b5b2:	4186d69b          	sraiw	a3,a3,0x18
    8001b5b6:	fe843703          	ld	a4,-24(s0)
    8001b5ba:	2701                	sext.w	a4,a4
    8001b5bc:	8b0d                	andi	a4,a4,3
    8001b5be:	2701                	sext.w	a4,a4
    8001b5c0:	0017171b          	slliw	a4,a4,0x1
    8001b5c4:	2701                	sext.w	a4,a4
    8001b5c6:	2705                	addiw	a4,a4,1
    8001b5c8:	2701                	sext.w	a4,a4
    8001b5ca:	4605                	li	a2,1
    8001b5cc:	00e6173b          	sllw	a4,a2,a4
    8001b5d0:	2701                	sext.w	a4,a4
    8001b5d2:	0187171b          	slliw	a4,a4,0x18
    8001b5d6:	4187571b          	sraiw	a4,a4,0x18
    8001b5da:	8f55                	or	a4,a4,a3
    8001b5dc:	0187169b          	slliw	a3,a4,0x18
    8001b5e0:	4186d69b          	sraiw	a3,a3,0x18
    8001b5e4:	00008717          	auipc	a4,0x8
    8001b5e8:	b5c70713          	addi	a4,a4,-1188 # 80023140 <bookkeeping>
    8001b5ec:	6318                	ld	a4,0(a4)
    8001b5ee:	97ba                	add	a5,a5,a4
    8001b5f0:	0ff6f713          	andi	a4,a3,255
    8001b5f4:	00e78023          	sb	a4,0(a5)
}
    8001b5f8:	0001                	nop
    8001b5fa:	6462                	ld	s0,24(sp)
    8001b5fc:	6105                	addi	sp,sp,32
    8001b5fe:	8082                	ret

000000008001b600 <clear_last>:

static void clear_last(uint64_t index)
{
    8001b600:	1101                	addi	sp,sp,-32
    8001b602:	ec22                	sd	s0,24(sp)
    8001b604:	1000                	addi	s0,sp,32
    8001b606:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2 + 1));
    8001b60a:	00008797          	auipc	a5,0x8
    8001b60e:	b3678793          	addi	a5,a5,-1226 # 80023140 <bookkeeping>
    8001b612:	6398                	ld	a4,0(a5)
    8001b614:	fe843783          	ld	a5,-24(s0)
    8001b618:	8389                	srli	a5,a5,0x2
    8001b61a:	973e                	add	a4,a4,a5
    8001b61c:	00074703          	lbu	a4,0(a4)
    8001b620:	0187169b          	slliw	a3,a4,0x18
    8001b624:	4186d69b          	sraiw	a3,a3,0x18
    8001b628:	fe843703          	ld	a4,-24(s0)
    8001b62c:	2701                	sext.w	a4,a4
    8001b62e:	8b0d                	andi	a4,a4,3
    8001b630:	2701                	sext.w	a4,a4
    8001b632:	0017171b          	slliw	a4,a4,0x1
    8001b636:	2701                	sext.w	a4,a4
    8001b638:	2705                	addiw	a4,a4,1
    8001b63a:	2701                	sext.w	a4,a4
    8001b63c:	4605                	li	a2,1
    8001b63e:	00e6173b          	sllw	a4,a2,a4
    8001b642:	2701                	sext.w	a4,a4
    8001b644:	0187171b          	slliw	a4,a4,0x18
    8001b648:	4187571b          	sraiw	a4,a4,0x18
    8001b64c:	fff74713          	not	a4,a4
    8001b650:	0187171b          	slliw	a4,a4,0x18
    8001b654:	4187571b          	sraiw	a4,a4,0x18
    8001b658:	8f75                	and	a4,a4,a3
    8001b65a:	0187169b          	slliw	a3,a4,0x18
    8001b65e:	4186d69b          	sraiw	a3,a3,0x18
    8001b662:	00008717          	auipc	a4,0x8
    8001b666:	ade70713          	addi	a4,a4,-1314 # 80023140 <bookkeeping>
    8001b66a:	6318                	ld	a4,0(a4)
    8001b66c:	97ba                	add	a5,a5,a4
    8001b66e:	0ff6f713          	andi	a4,a3,255
    8001b672:	00e78023          	sb	a4,0(a5)
}
    8001b676:	0001                	nop
    8001b678:	6462                	ld	s0,24(sp)
    8001b67a:	6105                	addi	sp,sp,32
    8001b67c:	8082                	ret

000000008001b67e <is_last>:

static int is_last(uint64_t index)
{
    8001b67e:	1101                	addi	sp,sp,-32
    8001b680:	ec22                	sd	s0,24(sp)
    8001b682:	1000                	addi	s0,sp,32
    8001b684:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2 + 1));
    8001b688:	00008797          	auipc	a5,0x8
    8001b68c:	ab878793          	addi	a5,a5,-1352 # 80023140 <bookkeeping>
    8001b690:	6398                	ld	a4,0(a5)
    8001b692:	fe843783          	ld	a5,-24(s0)
    8001b696:	8389                	srli	a5,a5,0x2
    8001b698:	97ba                	add	a5,a5,a4
    8001b69a:	0007c783          	lbu	a5,0(a5)
    8001b69e:	0007871b          	sext.w	a4,a5
    8001b6a2:	fe843783          	ld	a5,-24(s0)
    8001b6a6:	2781                	sext.w	a5,a5
    8001b6a8:	8b8d                	andi	a5,a5,3
    8001b6aa:	2781                	sext.w	a5,a5
    8001b6ac:	0017979b          	slliw	a5,a5,0x1
    8001b6b0:	2781                	sext.w	a5,a5
    8001b6b2:	2785                	addiw	a5,a5,1
    8001b6b4:	2781                	sext.w	a5,a5
    8001b6b6:	4685                	li	a3,1
    8001b6b8:	00f697bb          	sllw	a5,a3,a5
    8001b6bc:	2781                	sext.w	a5,a5
    8001b6be:	8ff9                	and	a5,a5,a4
    8001b6c0:	2781                	sext.w	a5,a5
}
    8001b6c2:	853e                	mv	a0,a5
    8001b6c4:	6462                	ld	s0,24(sp)
    8001b6c6:	6105                	addi	sp,sp,32
    8001b6c8:	8082                	ret

000000008001b6ca <page_init>:

void page_init(void)
{
    8001b6ca:	1101                	addi	sp,sp,-32
    8001b6cc:	ec06                	sd	ra,24(sp)
    8001b6ce:	e822                	sd	s0,16(sp)
    8001b6d0:	1000                	addi	s0,sp,32
    /* Initialize the page system. */
    bookkeeping = (uint8_t*)sym_start(heap);
    8001b6d2:	00008797          	auipc	a5,0x8
    8001b6d6:	a6e78793          	addi	a5,a5,-1426 # 80023140 <bookkeeping>
    8001b6da:	00015717          	auipc	a4,0x15
    8001b6de:	92670713          	addi	a4,a4,-1754 # 80030000 <_heap_start>
    8001b6e2:	e398                	sd	a4,0(a5)
    
    // Print bookkeeping area
    mutex_spinlock(&page_lock);
    8001b6e4:	00008517          	auipc	a0,0x8
    8001b6e8:	92450513          	addi	a0,a0,-1756 # 80023008 <page_lock>
    8001b6ec:	eb2f80ef          	jal	ra,80013d9e <mutex_spinlock>

    // Initialize the bookkeeping area
    memset(bookkeeping, 0, BK_SIZE_IN_BYTES);
    8001b6f0:	00008797          	auipc	a5,0x8
    8001b6f4:	a5078793          	addi	a5,a5,-1456 # 80023140 <bookkeeping>
    8001b6f8:	6394                	ld	a3,0(a5)
    8001b6fa:	07ff5717          	auipc	a4,0x7ff5
    8001b6fe:	90670713          	addi	a4,a4,-1786 # 88010000 <_heap_end>
    8001b702:	00015797          	auipc	a5,0x15
    8001b706:	8fe78793          	addi	a5,a5,-1794 # 80030000 <_heap_start>
    8001b70a:	40f707b3          	sub	a5,a4,a5
    8001b70e:	83b9                	srli	a5,a5,0xe
    8001b710:	0007871b          	sext.w	a4,a5
    8001b714:	6785                	lui	a5,0x1
    8001b716:	37fd                	addiw	a5,a5,-1
    8001b718:	9fb9                	addw	a5,a5,a4
    8001b71a:	2781                	sext.w	a5,a5
    8001b71c:	0007871b          	sext.w	a4,a5
    8001b720:	77fd                	lui	a5,0xfffff
    8001b722:	8ff9                	and	a5,a5,a4
    8001b724:	2781                	sext.w	a5,a5
    8001b726:	863e                	mv	a2,a5
    8001b728:	4581                	li	a1,0
    8001b72a:	8536                	mv	a0,a3
    8001b72c:	640040ef          	jal	ra,8001fd6c <memset>
    // Mark the bookkeeping pages as taken
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    8001b730:	fe043423          	sd	zero,-24(s0)
    8001b734:	a811                	j	8001b748 <page_init+0x7e>
        set_taken(i);
    8001b736:	fe843503          	ld	a0,-24(s0)
    8001b73a:	d25ff0ef          	jal	ra,8001b45e <set_taken>
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    8001b73e:	fe843783          	ld	a5,-24(s0)
    8001b742:	0785                	addi	a5,a5,1
    8001b744:	fef43423          	sd	a5,-24(s0)
    8001b748:	07ff5717          	auipc	a4,0x7ff5
    8001b74c:	8b870713          	addi	a4,a4,-1864 # 88010000 <_heap_end>
    8001b750:	00015797          	auipc	a5,0x15
    8001b754:	8b078793          	addi	a5,a5,-1872 # 80030000 <_heap_start>
    8001b758:	40f707b3          	sub	a5,a4,a5
    8001b75c:	00e7d713          	srli	a4,a5,0xe
    8001b760:	6785                	lui	a5,0x1
    8001b762:	17fd                	addi	a5,a5,-1
    8001b764:	97ba                	add	a5,a5,a4
    8001b766:	83b1                	srli	a5,a5,0xc
    8001b768:	fe843703          	ld	a4,-24(s0)
    8001b76c:	fcf765e3          	bltu	a4,a5,8001b736 <page_init+0x6c>
    }
    set_last(BK_SIZE_IN_PAGES-1);
    8001b770:	07ff5717          	auipc	a4,0x7ff5
    8001b774:	89070713          	addi	a4,a4,-1904 # 88010000 <_heap_end>
    8001b778:	00015797          	auipc	a5,0x15
    8001b77c:	88878793          	addi	a5,a5,-1912 # 80030000 <_heap_start>
    8001b780:	40f707b3          	sub	a5,a4,a5
    8001b784:	00e7d713          	srli	a4,a5,0xe
    8001b788:	6785                	lui	a5,0x1
    8001b78a:	17fd                	addi	a5,a5,-1
    8001b78c:	97ba                	add	a5,a5,a4
    8001b78e:	83b1                	srli	a5,a5,0xc
    8001b790:	17fd                	addi	a5,a5,-1
    8001b792:	853e                	mv	a0,a5
    8001b794:	dfbff0ef          	jal	ra,8001b58e <set_last>

    debugf("page_init: bookkeeping area initialized\n");
    8001b798:	0000a517          	auipc	a0,0xa
    8001b79c:	1e050513          	addi	a0,a0,480 # 80025978 <pow10.0+0x1748>
    8001b7a0:	a0bfd0ef          	jal	ra,800191aa <debugf>
    debugf("page_init: bookkeeping area starts at 0x%08lx\n", bookkeeping);
    8001b7a4:	00008797          	auipc	a5,0x8
    8001b7a8:	99c78793          	addi	a5,a5,-1636 # 80023140 <bookkeeping>
    8001b7ac:	639c                	ld	a5,0(a5)
    8001b7ae:	85be                	mv	a1,a5
    8001b7b0:	0000a517          	auipc	a0,0xa
    8001b7b4:	1f850513          	addi	a0,a0,504 # 800259a8 <pow10.0+0x1778>
    8001b7b8:	9f3fd0ef          	jal	ra,800191aa <debugf>
    debugf("page_init: bookkeeping area ends at 0x%08lx\n", bookkeeping + BK_SIZE_IN_BYTES);
    8001b7bc:	00008797          	auipc	a5,0x8
    8001b7c0:	98478793          	addi	a5,a5,-1660 # 80023140 <bookkeeping>
    8001b7c4:	6398                	ld	a4,0(a5)
    8001b7c6:	07ff5697          	auipc	a3,0x7ff5
    8001b7ca:	83a68693          	addi	a3,a3,-1990 # 88010000 <_heap_end>
    8001b7ce:	00015797          	auipc	a5,0x15
    8001b7d2:	83278793          	addi	a5,a5,-1998 # 80030000 <_heap_start>
    8001b7d6:	40f687b3          	sub	a5,a3,a5
    8001b7da:	00e7d693          	srli	a3,a5,0xe
    8001b7de:	6785                	lui	a5,0x1
    8001b7e0:	17fd                	addi	a5,a5,-1
    8001b7e2:	96be                	add	a3,a3,a5
    8001b7e4:	77fd                	lui	a5,0xfffff
    8001b7e6:	8ff5                	and	a5,a5,a3
    8001b7e8:	97ba                	add	a5,a5,a4
    8001b7ea:	85be                	mv	a1,a5
    8001b7ec:	0000a517          	auipc	a0,0xa
    8001b7f0:	1ec50513          	addi	a0,a0,492 # 800259d8 <pow10.0+0x17a8>
    8001b7f4:	9b7fd0ef          	jal	ra,800191aa <debugf>
    mutex_unlock(&page_lock);
    8001b7f8:	00008517          	auipc	a0,0x8
    8001b7fc:	81050513          	addi	a0,a0,-2032 # 80023008 <page_lock>
    8001b800:	dccf80ef          	jal	ra,80013dcc <mutex_unlock>

    // Print out the bookkeeping area's contents
    logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    8001b804:	00008797          	auipc	a5,0x8
    8001b808:	93c78793          	addi	a5,a5,-1732 # 80023140 <bookkeeping>
    8001b80c:	6390                	ld	a2,0(a5)
    8001b80e:	00008797          	auipc	a5,0x8
    8001b812:	93278793          	addi	a5,a5,-1742 # 80023140 <bookkeeping>
    8001b816:	6398                	ld	a4,0(a5)
    8001b818:	07ff4697          	auipc	a3,0x7ff4
    8001b81c:	7e868693          	addi	a3,a3,2024 # 88010000 <_heap_end>
    8001b820:	00014797          	auipc	a5,0x14
    8001b824:	7e078793          	addi	a5,a5,2016 # 80030000 <_heap_start>
    8001b828:	40f687b3          	sub	a5,a3,a5
    8001b82c:	00e7d693          	srli	a3,a5,0xe
    8001b830:	6785                	lui	a5,0x1
    8001b832:	17fd                	addi	a5,a5,-1
    8001b834:	96be                	add	a3,a3,a5
    8001b836:	77fd                	lui	a5,0xfffff
    8001b838:	8ff5                	and	a5,a5,a3
    8001b83a:	97ba                	add	a5,a5,a4
    8001b83c:	86be                	mv	a3,a5
    8001b83e:	0000a597          	auipc	a1,0xa
    8001b842:	1ca58593          	addi	a1,a1,458 # 80025a08 <pow10.0+0x17d8>
    8001b846:	4511                	li	a0,4
    8001b848:	905fd0ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  Heap: 0x%08lx -> 0x%08lx", bookkeeping + BK_SIZE_IN_BYTES, bookkeeping + HEAP_SIZE_IN_BYTES);
    8001b84c:	00008797          	auipc	a5,0x8
    8001b850:	8f478793          	addi	a5,a5,-1804 # 80023140 <bookkeeping>
    8001b854:	6398                	ld	a4,0(a5)
    8001b856:	07ff4697          	auipc	a3,0x7ff4
    8001b85a:	7aa68693          	addi	a3,a3,1962 # 88010000 <_heap_end>
    8001b85e:	00014797          	auipc	a5,0x14
    8001b862:	7a278793          	addi	a5,a5,1954 # 80030000 <_heap_start>
    8001b866:	40f687b3          	sub	a5,a3,a5
    8001b86a:	00e7d693          	srli	a3,a5,0xe
    8001b86e:	6785                	lui	a5,0x1
    8001b870:	17fd                	addi	a5,a5,-1
    8001b872:	96be                	add	a3,a3,a5
    8001b874:	77fd                	lui	a5,0xfffff
    8001b876:	8ff5                	and	a5,a5,a3
    8001b878:	00f70633          	add	a2,a4,a5
    8001b87c:	00008797          	auipc	a5,0x8
    8001b880:	8c478793          	addi	a5,a5,-1852 # 80023140 <bookkeeping>
    8001b884:	6398                	ld	a4,0(a5)
    8001b886:	07ff4697          	auipc	a3,0x7ff4
    8001b88a:	77a68693          	addi	a3,a3,1914 # 88010000 <_heap_end>
    8001b88e:	00014797          	auipc	a5,0x14
    8001b892:	77278793          	addi	a5,a5,1906 # 80030000 <_heap_start>
    8001b896:	40f687b3          	sub	a5,a3,a5
    8001b89a:	97ba                	add	a5,a5,a4
    8001b89c:	86be                	mv	a3,a5
    8001b89e:	0000a597          	auipc	a1,0xa
    8001b8a2:	18a58593          	addi	a1,a1,394 # 80025a28 <pow10.0+0x17f8>
    8001b8a6:	4511                	li	a0,4
    8001b8a8:	8a5fd0ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    8001b8ac:	07ff4717          	auipc	a4,0x7ff4
    8001b8b0:	75470713          	addi	a4,a4,1876 # 88010000 <_heap_end>
    8001b8b4:	00014797          	auipc	a5,0x14
    8001b8b8:	74c78793          	addi	a5,a5,1868 # 80030000 <_heap_start>
    8001b8bc:	40f70633          	sub	a2,a4,a5
    8001b8c0:	07ff4717          	auipc	a4,0x7ff4
    8001b8c4:	74070713          	addi	a4,a4,1856 # 88010000 <_heap_end>
    8001b8c8:	00014797          	auipc	a5,0x14
    8001b8cc:	73878793          	addi	a5,a5,1848 # 80030000 <_heap_start>
    8001b8d0:	40f707b3          	sub	a5,a4,a5
    8001b8d4:	83b1                	srli	a5,a5,0xc
    8001b8d6:	86be                	mv	a3,a5
    8001b8d8:	0000a597          	auipc	a1,0xa
    8001b8dc:	17058593          	addi	a1,a1,368 # 80025a48 <pow10.0+0x1818>
    8001b8e0:	4511                	li	a0,4
    8001b8e2:	86bfd0ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    8001b8e6:	07ff4717          	auipc	a4,0x7ff4
    8001b8ea:	71a70713          	addi	a4,a4,1818 # 88010000 <_heap_end>
    8001b8ee:	00014797          	auipc	a5,0x14
    8001b8f2:	71278793          	addi	a5,a5,1810 # 80030000 <_heap_start>
    8001b8f6:	40f707b3          	sub	a5,a4,a5
    8001b8fa:	00e7d713          	srli	a4,a5,0xe
    8001b8fe:	6785                	lui	a5,0x1
    8001b900:	17fd                	addi	a5,a5,-1
    8001b902:	973e                	add	a4,a4,a5
    8001b904:	77fd                	lui	a5,0xfffff
    8001b906:	00f77633          	and	a2,a4,a5
    8001b90a:	07ff4717          	auipc	a4,0x7ff4
    8001b90e:	6f670713          	addi	a4,a4,1782 # 88010000 <_heap_end>
    8001b912:	00014797          	auipc	a5,0x14
    8001b916:	6ee78793          	addi	a5,a5,1774 # 80030000 <_heap_start>
    8001b91a:	40f707b3          	sub	a5,a4,a5
    8001b91e:	00e7d713          	srli	a4,a5,0xe
    8001b922:	6785                	lui	a5,0x1
    8001b924:	17fd                	addi	a5,a5,-1
    8001b926:	97ba                	add	a5,a5,a4
    8001b928:	83b1                	srli	a5,a5,0xc
    8001b92a:	86be                	mv	a3,a5
    8001b92c:	0000a597          	auipc	a1,0xa
    8001b930:	14458593          	addi	a1,a1,324 # 80025a70 <pow10.0+0x1840>
    8001b934:	4511                	li	a0,4
    8001b936:	817fd0ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    8001b93a:	330000ef          	jal	ra,8001bc6a <page_count_taken>
    8001b93e:	87aa                	mv	a5,a0
    8001b940:	863e                	mv	a2,a5
    8001b942:	0000a597          	auipc	a1,0xa
    8001b946:	15e58593          	addi	a1,a1,350 # 80025aa0 <pow10.0+0x1870>
    8001b94a:	4511                	li	a0,4
    8001b94c:	801fd0ef          	jal	ra,8001914c <logf>
    logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
    8001b950:	2a4000ef          	jal	ra,8001bbf4 <page_count_free>
    8001b954:	87aa                	mv	a5,a0
    8001b956:	863e                	mv	a2,a5
    8001b958:	0000a597          	auipc	a1,0xa
    8001b95c:	16058593          	addi	a1,a1,352 # 80025ab8 <pow10.0+0x1888>
    8001b960:	4511                	li	a0,4
    8001b962:	feafd0ef          	jal	ra,8001914c <logf>
    // logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    // logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    // logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
}
    8001b966:	0001                	nop
    8001b968:	60e2                	ld	ra,24(sp)
    8001b96a:	6442                	ld	s0,16(sp)
    8001b96c:	6105                	addi	sp,sp,32
    8001b96e:	8082                	ret

000000008001b970 <page_nalloc>:

void *page_nalloc(int n)
{
    8001b970:	7139                	addi	sp,sp,-64
    8001b972:	fc06                	sd	ra,56(sp)
    8001b974:	f822                	sd	s0,48(sp)
    8001b976:	0080                	addi	s0,sp,64
    8001b978:	87aa                	mv	a5,a0
    8001b97a:	fcf42623          	sw	a5,-52(s0)
    if (n <= 0) {
    8001b97e:	fcc42783          	lw	a5,-52(s0)
    8001b982:	2781                	sext.w	a5,a5
    8001b984:	00f04463          	bgtz	a5,8001b98c <page_nalloc+0x1c>
        return NULL;
    8001b988:	4781                	li	a5,0
    8001b98a:	a23d                	j	8001bab8 <page_nalloc+0x148>
    }

    mutex_spinlock(&page_lock);
    8001b98c:	00007517          	auipc	a0,0x7
    8001b990:	67c50513          	addi	a0,a0,1660 # 80023008 <page_lock>
    8001b994:	c0af80ef          	jal	ra,80013d9e <mutex_spinlock>

    int start = 0;
    8001b998:	fe042623          	sw	zero,-20(s0)
    int consecutive = 0;
    8001b99c:	fe042423          	sw	zero,-24(s0)

    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001b9a0:	fe043023          	sd	zero,-32(s0)
    8001b9a4:	a0e5                	j	8001ba8c <page_nalloc+0x11c>
        if (!is_taken(i) && !is_last(i)) {
    8001b9a6:	fe043503          	ld	a0,-32(s0)
    8001b9aa:	b9dff0ef          	jal	ra,8001b546 <is_taken>
    8001b9ae:	87aa                	mv	a5,a0
    8001b9b0:	e7f9                	bnez	a5,8001ba7e <page_nalloc+0x10e>
    8001b9b2:	fe043503          	ld	a0,-32(s0)
    8001b9b6:	cc9ff0ef          	jal	ra,8001b67e <is_last>
    8001b9ba:	87aa                	mv	a5,a0
    8001b9bc:	e3e9                	bnez	a5,8001ba7e <page_nalloc+0x10e>
            if (consecutive == 0) {
    8001b9be:	fe842783          	lw	a5,-24(s0)
    8001b9c2:	2781                	sext.w	a5,a5
    8001b9c4:	e789                	bnez	a5,8001b9ce <page_nalloc+0x5e>
                start = i;
    8001b9c6:	fe043783          	ld	a5,-32(s0)
    8001b9ca:	fef42623          	sw	a5,-20(s0)
            }

            consecutive++;
    8001b9ce:	fe842783          	lw	a5,-24(s0)
    8001b9d2:	2785                	addiw	a5,a5,1
    8001b9d4:	fef42423          	sw	a5,-24(s0)

            if (consecutive >= n) {
    8001b9d8:	fe842703          	lw	a4,-24(s0)
    8001b9dc:	fcc42783          	lw	a5,-52(s0)
    8001b9e0:	2701                	sext.w	a4,a4
    8001b9e2:	2781                	sext.w	a5,a5
    8001b9e4:	08f74f63          	blt	a4,a5,8001ba82 <page_nalloc+0x112>
                // debugf("page_nalloc: found %d consecutive pages starting at 0x%08lx\n", n, start);
                for (int j = 0; j < n; j++) {
    8001b9e8:	fc042e23          	sw	zero,-36(s0)
    8001b9ec:	a091                	j	8001ba30 <page_nalloc+0xc0>
                    // debugf("page_nalloc: marking page 0x%08lx as taken\n", start + j);
                    set_taken(start + j);
    8001b9ee:	fec42703          	lw	a4,-20(s0)
    8001b9f2:	fdc42783          	lw	a5,-36(s0)
    8001b9f6:	9fb9                	addw	a5,a5,a4
    8001b9f8:	2781                	sext.w	a5,a5
    8001b9fa:	853e                	mv	a0,a5
    8001b9fc:	a63ff0ef          	jal	ra,8001b45e <set_taken>
                    if (j == n - 1) {
    8001ba00:	fcc42783          	lw	a5,-52(s0)
    8001ba04:	37fd                	addiw	a5,a5,-1
    8001ba06:	0007871b          	sext.w	a4,a5
    8001ba0a:	fdc42783          	lw	a5,-36(s0)
    8001ba0e:	2781                	sext.w	a5,a5
    8001ba10:	00e79b63          	bne	a5,a4,8001ba26 <page_nalloc+0xb6>
                        set_last(start + j);
    8001ba14:	fec42703          	lw	a4,-20(s0)
    8001ba18:	fdc42783          	lw	a5,-36(s0)
    8001ba1c:	9fb9                	addw	a5,a5,a4
    8001ba1e:	2781                	sext.w	a5,a5
    8001ba20:	853e                	mv	a0,a5
    8001ba22:	b6dff0ef          	jal	ra,8001b58e <set_last>
                for (int j = 0; j < n; j++) {
    8001ba26:	fdc42783          	lw	a5,-36(s0)
    8001ba2a:	2785                	addiw	a5,a5,1
    8001ba2c:	fcf42e23          	sw	a5,-36(s0)
    8001ba30:	fdc42703          	lw	a4,-36(s0)
    8001ba34:	fcc42783          	lw	a5,-52(s0)
    8001ba38:	2701                	sext.w	a4,a4
    8001ba3a:	2781                	sext.w	a5,a5
    8001ba3c:	faf749e3          	blt	a4,a5,8001b9ee <page_nalloc+0x7e>
                    }
                }
                // debugf("page_nalloc: marking page 0x%08lx as last\n", start + n - 1);

                mutex_unlock(&page_lock);
    8001ba40:	00007517          	auipc	a0,0x7
    8001ba44:	5c850513          	addi	a0,a0,1480 # 80023008 <page_lock>
    8001ba48:	b84f80ef          	jal	ra,80013dcc <mutex_unlock>
                // debugf("Found free %d pages at #%d, %d\n", n, start, i);
                void *result = (void*)((uint64_t)bookkeeping + ((uint64_t)start * PAGE_SIZE));
    8001ba4c:	fec42783          	lw	a5,-20(s0)
    8001ba50:	07b2                	slli	a5,a5,0xc
    8001ba52:	00007717          	auipc	a4,0x7
    8001ba56:	6ee70713          	addi	a4,a4,1774 # 80023140 <bookkeeping>
    8001ba5a:	6318                	ld	a4,0(a4)
    8001ba5c:	97ba                	add	a5,a5,a4
    8001ba5e:	fcf43823          	sd	a5,-48(s0)

                debugf("Found %d free pages at %p\n", n, result);
    8001ba62:	fcc42783          	lw	a5,-52(s0)
    8001ba66:	fd043603          	ld	a2,-48(s0)
    8001ba6a:	85be                	mv	a1,a5
    8001ba6c:	0000a517          	auipc	a0,0xa
    8001ba70:	06450513          	addi	a0,a0,100 # 80025ad0 <pow10.0+0x18a0>
    8001ba74:	f36fd0ef          	jal	ra,800191aa <debugf>
                return result;
    8001ba78:	fd043783          	ld	a5,-48(s0)
    8001ba7c:	a835                	j	8001bab8 <page_nalloc+0x148>
            }
        } else {
            // debugf("page_nalloc: page 0x%08lx is taken\n", i);
            consecutive = 0;
    8001ba7e:	fe042423          	sw	zero,-24(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001ba82:	fe043783          	ld	a5,-32(s0)
    8001ba86:	0785                	addi	a5,a5,1
    8001ba88:	fef43023          	sd	a5,-32(s0)
    8001ba8c:	07ff4717          	auipc	a4,0x7ff4
    8001ba90:	57470713          	addi	a4,a4,1396 # 88010000 <_heap_end>
    8001ba94:	00014797          	auipc	a5,0x14
    8001ba98:	56c78793          	addi	a5,a5,1388 # 80030000 <_heap_start>
    8001ba9c:	40f707b3          	sub	a5,a4,a5
    8001baa0:	83b1                	srli	a5,a5,0xc
    8001baa2:	fe043703          	ld	a4,-32(s0)
    8001baa6:	f0f760e3          	bltu	a4,a5,8001b9a6 <page_nalloc+0x36>
        }
    }

    mutex_unlock(&page_lock);
    8001baaa:	00007517          	auipc	a0,0x7
    8001baae:	55e50513          	addi	a0,a0,1374 # 80023008 <page_lock>
    8001bab2:	b1af80ef          	jal	ra,80013dcc <mutex_unlock>
    return NULL;
    8001bab6:	4781                	li	a5,0
}
    8001bab8:	853e                	mv	a0,a5
    8001baba:	70e2                	ld	ra,56(sp)
    8001babc:	7442                	ld	s0,48(sp)
    8001babe:	6121                	addi	sp,sp,64
    8001bac0:	8082                	ret

000000008001bac2 <page_znalloc>:

void *page_znalloc(int n)
{
    8001bac2:	7179                	addi	sp,sp,-48
    8001bac4:	f406                	sd	ra,40(sp)
    8001bac6:	f022                	sd	s0,32(sp)
    8001bac8:	1800                	addi	s0,sp,48
    8001baca:	87aa                	mv	a5,a0
    8001bacc:	fcf42e23          	sw	a5,-36(s0)
    if (n <= 0) {
    8001bad0:	fdc42783          	lw	a5,-36(s0)
    8001bad4:	2781                	sext.w	a5,a5
    8001bad6:	00f04463          	bgtz	a5,8001bade <page_znalloc+0x1c>
        return NULL;
    8001bada:	4781                	li	a5,0
    8001badc:	a805                	j	8001bb0c <page_znalloc+0x4a>
    }
    
    void *mem = page_nalloc(n);
    8001bade:	fdc42783          	lw	a5,-36(s0)
    8001bae2:	853e                	mv	a0,a5
    8001bae4:	e8dff0ef          	jal	ra,8001b970 <page_nalloc>
    8001bae8:	fea43423          	sd	a0,-24(s0)
    if (mem) {
    8001baec:	fe843783          	ld	a5,-24(s0)
    8001baf0:	cf81                	beqz	a5,8001bb08 <page_znalloc+0x46>
        // debugf("page_znalloc: zeroing out %d pages starting at 0x%08lx\n", n, mem);
        memset(mem, 0, n * PAGE_SIZE);
    8001baf2:	fdc42783          	lw	a5,-36(s0)
    8001baf6:	00c7979b          	slliw	a5,a5,0xc
    8001bafa:	2781                	sext.w	a5,a5
    8001bafc:	863e                	mv	a2,a5
    8001bafe:	4581                	li	a1,0
    8001bb00:	fe843503          	ld	a0,-24(s0)
    8001bb04:	268040ef          	jal	ra,8001fd6c <memset>
    }
    return mem;
    8001bb08:	fe843783          	ld	a5,-24(s0)
}
    8001bb0c:	853e                	mv	a0,a5
    8001bb0e:	70a2                	ld	ra,40(sp)
    8001bb10:	7402                	ld	s0,32(sp)
    8001bb12:	6145                	addi	sp,sp,48
    8001bb14:	8082                	ret

000000008001bb16 <page_to_index>:

uint64_t page_to_index(void *page) {
    8001bb16:	1101                	addi	sp,sp,-32
    8001bb18:	ec22                	sd	s0,24(sp)
    8001bb1a:	1000                	addi	s0,sp,32
    8001bb1c:	fea43423          	sd	a0,-24(s0)
    return ((uint64_t)page - (uint64_t)bookkeeping) / PAGE_SIZE;
    8001bb20:	fe843783          	ld	a5,-24(s0)
    8001bb24:	00007717          	auipc	a4,0x7
    8001bb28:	61c70713          	addi	a4,a4,1564 # 80023140 <bookkeeping>
    8001bb2c:	6318                	ld	a4,0(a4)
    8001bb2e:	8f99                	sub	a5,a5,a4
    8001bb30:	83b1                	srli	a5,a5,0xc
}
    8001bb32:	853e                	mv	a0,a5
    8001bb34:	6462                	ld	s0,24(sp)
    8001bb36:	6105                	addi	sp,sp,32
    8001bb38:	8082                	ret

000000008001bb3a <index_to_page>:

void *index_to_page(uint64_t idx) {
    8001bb3a:	1101                	addi	sp,sp,-32
    8001bb3c:	ec22                	sd	s0,24(sp)
    8001bb3e:	1000                	addi	s0,sp,32
    8001bb40:	fea43423          	sd	a0,-24(s0)
    return (void*)(idx * PAGE_SIZE + (uint64_t)bookkeeping);
    8001bb44:	fe843783          	ld	a5,-24(s0)
    8001bb48:	07b2                	slli	a5,a5,0xc
    8001bb4a:	00007717          	auipc	a4,0x7
    8001bb4e:	5f670713          	addi	a4,a4,1526 # 80023140 <bookkeeping>
    8001bb52:	6318                	ld	a4,0(a4)
    8001bb54:	97ba                	add	a5,a5,a4
}
    8001bb56:	853e                	mv	a0,a5
    8001bb58:	6462                	ld	s0,24(sp)
    8001bb5a:	6105                	addi	sp,sp,32
    8001bb5c:	8082                	ret

000000008001bb5e <page_free>:

void page_free(void *p)
{
    8001bb5e:	7179                	addi	sp,sp,-48
    8001bb60:	f406                	sd	ra,40(sp)
    8001bb62:	f022                	sd	s0,32(sp)
    8001bb64:	1800                	addi	s0,sp,48
    8001bb66:	fca43c23          	sd	a0,-40(s0)
    if (p == NULL) {
    8001bb6a:	fd843783          	ld	a5,-40(s0)
    8001bb6e:	cfb5                	beqz	a5,8001bbea <page_free+0x8c>
        return;
    }
    /* Free the page */
    // uint64_t x = ((uint64_t)p - (uint64_t)bookkeeping) / PAGE_SIZE;
    uint64_t x = page_to_index(p);
    8001bb70:	fd843503          	ld	a0,-40(s0)
    8001bb74:	fa3ff0ef          	jal	ra,8001bb16 <page_to_index>
    8001bb78:	fea43423          	sd	a0,-24(s0)
    // debugf("page_free: freeing page %lu at address 0x%p\n", x, p);

    mutex_spinlock(&page_lock);
    8001bb7c:	00007517          	auipc	a0,0x7
    8001bb80:	48c50513          	addi	a0,a0,1164 # 80023008 <page_lock>
    8001bb84:	a1af80ef          	jal	ra,80013d9e <mutex_spinlock>


    if (!is_taken(x)) {
    8001bb88:	fe843503          	ld	a0,-24(s0)
    8001bb8c:	9bbff0ef          	jal	ra,8001b546 <is_taken>
    8001bb90:	87aa                	mv	a5,a0
    8001bb92:	e38d                	bnez	a5,8001bbb4 <page_free+0x56>
        // logf(LOG_ERROR, "page_free: page 0x%08lx is already free!\n", x);
        mutex_unlock(&page_lock);
    8001bb94:	00007517          	auipc	a0,0x7
    8001bb98:	47450513          	addi	a0,a0,1140 # 80023008 <page_lock>
    8001bb9c:	a30f80ef          	jal	ra,80013dcc <mutex_unlock>
        return;
    8001bba0:	a0b1                	j	8001bbec <page_free+0x8e>
    }

    // Clear all the pages starting at the index until the last page
    while (is_taken(x) && !is_last(x)) {
        clear_taken(x);
    8001bba2:	fe843503          	ld	a0,-24(s0)
    8001bba6:	927ff0ef          	jal	ra,8001b4cc <clear_taken>
        x++;
    8001bbaa:	fe843783          	ld	a5,-24(s0)
    8001bbae:	0785                	addi	a5,a5,1
    8001bbb0:	fef43423          	sd	a5,-24(s0)
    while (is_taken(x) && !is_last(x)) {
    8001bbb4:	fe843503          	ld	a0,-24(s0)
    8001bbb8:	98fff0ef          	jal	ra,8001b546 <is_taken>
    8001bbbc:	87aa                	mv	a5,a0
    8001bbbe:	c799                	beqz	a5,8001bbcc <page_free+0x6e>
    8001bbc0:	fe843503          	ld	a0,-24(s0)
    8001bbc4:	abbff0ef          	jal	ra,8001b67e <is_last>
    8001bbc8:	87aa                	mv	a5,a0
    8001bbca:	dfe1                	beqz	a5,8001bba2 <page_free+0x44>
    }
    clear_taken(x);
    8001bbcc:	fe843503          	ld	a0,-24(s0)
    8001bbd0:	8fdff0ef          	jal	ra,8001b4cc <clear_taken>
    clear_last(x);
    8001bbd4:	fe843503          	ld	a0,-24(s0)
    8001bbd8:	a29ff0ef          	jal	ra,8001b600 <clear_last>


    mutex_unlock(&page_lock);
    8001bbdc:	00007517          	auipc	a0,0x7
    8001bbe0:	42c50513          	addi	a0,a0,1068 # 80023008 <page_lock>
    8001bbe4:	9e8f80ef          	jal	ra,80013dcc <mutex_unlock>
    8001bbe8:	a011                	j	8001bbec <page_free+0x8e>
        return;
    8001bbea:	0001                	nop
}
    8001bbec:	70a2                	ld	ra,40(sp)
    8001bbee:	7402                	ld	s0,32(sp)
    8001bbf0:	6145                	addi	sp,sp,48
    8001bbf2:	8082                	ret

000000008001bbf4 <page_count_free>:

int page_count_free(void)
{
    8001bbf4:	1101                	addi	sp,sp,-32
    8001bbf6:	ec06                	sd	ra,24(sp)
    8001bbf8:	e822                	sd	s0,16(sp)
    8001bbfa:	1000                	addi	s0,sp,32
    int ret = 0;
    8001bbfc:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract taken. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract taken pages from it.
    */

    mutex_spinlock(&page_lock);
    8001bc00:	00007517          	auipc	a0,0x7
    8001bc04:	40850513          	addi	a0,a0,1032 # 80023008 <page_lock>
    8001bc08:	996f80ef          	jal	ra,80013d9e <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001bc0c:	fe043023          	sd	zero,-32(s0)
    8001bc10:	a00d                	j	8001bc32 <page_count_free+0x3e>
       if (!is_taken(i)) {
    8001bc12:	fe043503          	ld	a0,-32(s0)
    8001bc16:	931ff0ef          	jal	ra,8001b546 <is_taken>
    8001bc1a:	87aa                	mv	a5,a0
    8001bc1c:	e791                	bnez	a5,8001bc28 <page_count_free+0x34>
           ret++;
    8001bc1e:	fec42783          	lw	a5,-20(s0)
    8001bc22:	2785                	addiw	a5,a5,1
    8001bc24:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001bc28:	fe043783          	ld	a5,-32(s0)
    8001bc2c:	0785                	addi	a5,a5,1
    8001bc2e:	fef43023          	sd	a5,-32(s0)
    8001bc32:	07ff4717          	auipc	a4,0x7ff4
    8001bc36:	3ce70713          	addi	a4,a4,974 # 88010000 <_heap_end>
    8001bc3a:	00014797          	auipc	a5,0x14
    8001bc3e:	3c678793          	addi	a5,a5,966 # 80030000 <_heap_start>
    8001bc42:	40f707b3          	sub	a5,a4,a5
    8001bc46:	83b1                	srli	a5,a5,0xc
    8001bc48:	fe043703          	ld	a4,-32(s0)
    8001bc4c:	fcf763e3          	bltu	a4,a5,8001bc12 <page_count_free+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    8001bc50:	00007517          	auipc	a0,0x7
    8001bc54:	3b850513          	addi	a0,a0,952 # 80023008 <page_lock>
    8001bc58:	974f80ef          	jal	ra,80013dcc <mutex_unlock>

    return ret;
    8001bc5c:	fec42783          	lw	a5,-20(s0)
}
    8001bc60:	853e                	mv	a0,a5
    8001bc62:	60e2                	ld	ra,24(sp)
    8001bc64:	6442                	ld	s0,16(sp)
    8001bc66:	6105                	addi	sp,sp,32
    8001bc68:	8082                	ret

000000008001bc6a <page_count_taken>:

int page_count_taken(void)
{
    8001bc6a:	1101                	addi	sp,sp,-32
    8001bc6c:	ec06                	sd	ra,24(sp)
    8001bc6e:	e822                	sd	s0,16(sp)
    8001bc70:	1000                	addi	s0,sp,32
    int ret = 0;
    8001bc72:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract free. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract free pages from it.
    */

    mutex_spinlock(&page_lock);
    8001bc76:	00007517          	auipc	a0,0x7
    8001bc7a:	39250513          	addi	a0,a0,914 # 80023008 <page_lock>
    8001bc7e:	920f80ef          	jal	ra,80013d9e <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001bc82:	fe043023          	sd	zero,-32(s0)
    8001bc86:	a00d                	j	8001bca8 <page_count_taken+0x3e>
       if (is_taken(i)) {
    8001bc88:	fe043503          	ld	a0,-32(s0)
    8001bc8c:	8bbff0ef          	jal	ra,8001b546 <is_taken>
    8001bc90:	87aa                	mv	a5,a0
    8001bc92:	c791                	beqz	a5,8001bc9e <page_count_taken+0x34>
           ret++;
    8001bc94:	fec42783          	lw	a5,-20(s0)
    8001bc98:	2785                	addiw	a5,a5,1
    8001bc9a:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001bc9e:	fe043783          	ld	a5,-32(s0)
    8001bca2:	0785                	addi	a5,a5,1
    8001bca4:	fef43023          	sd	a5,-32(s0)
    8001bca8:	07ff4717          	auipc	a4,0x7ff4
    8001bcac:	35870713          	addi	a4,a4,856 # 88010000 <_heap_end>
    8001bcb0:	00014797          	auipc	a5,0x14
    8001bcb4:	35078793          	addi	a5,a5,848 # 80030000 <_heap_start>
    8001bcb8:	40f707b3          	sub	a5,a4,a5
    8001bcbc:	83b1                	srli	a5,a5,0xc
    8001bcbe:	fe043703          	ld	a4,-32(s0)
    8001bcc2:	fcf763e3          	bltu	a4,a5,8001bc88 <page_count_taken+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    8001bcc6:	00007517          	auipc	a0,0x7
    8001bcca:	34250513          	addi	a0,a0,834 # 80023008 <page_lock>
    8001bcce:	8fef80ef          	jal	ra,80013dcc <mutex_unlock>

    return ret;
    8001bcd2:	fec42783          	lw	a5,-20(s0)
}
    8001bcd6:	853e                	mv	a0,a5
    8001bcd8:	60e2                	ld	ra,24(sp)
    8001bcda:	6442                	ld	s0,16(sp)
    8001bcdc:	6105                	addi	sp,sp,32
    8001bcde:	8082                	ret

000000008001bce0 <input_device_init>:
static InputDevice keyboard_dev;
static InputDevice tablet_dev;
// static Ring *input_events;  //TODO: use the ring to buffer input events and also limit the number of events
// const int event_limit = 1000;   //limits number of events so we don't run out of memory

void input_device_init(VirtioDevice *device) {
    8001bce0:	715d                	addi	sp,sp,-80
    8001bce2:	e486                	sd	ra,72(sp)
    8001bce4:	e0a2                	sd	s0,64(sp)
    8001bce6:	0880                	addi	s0,sp,80
    8001bce8:	faa43c23          	sd	a0,-72(s0)
    IRQ_OFF();
    8001bcec:	100027f3          	csrr	a5,sstatus
    8001bcf0:	fef43023          	sd	a5,-32(s0)
    8001bcf4:	fe043783          	ld	a5,-32(s0)
    8001bcf8:	9bf5                	andi	a5,a5,-3
    8001bcfa:	10079073          	csrw	sstatus,a5
    device_active_jobs = vector_new();
    8001bcfe:	2c1040ef          	jal	ra,800207be <vector_new>
    8001bd02:	872a                	mv	a4,a0
    8001bd04:	00007797          	auipc	a5,0x7
    8001bd08:	44478793          	addi	a5,a5,1092 # 80023148 <device_active_jobs>
    8001bd0c:	e398                	sd	a4,0(a5)
    volatile VirtioInputConfig *config = virtio_get_input_config(device);
    8001bd0e:	fb843503          	ld	a0,-72(s0)
    8001bd12:	87bfe0ef          	jal	ra,8001a58c <virtio_get_input_config>
    8001bd16:	fca43c23          	sd	a0,-40(s0)

    uint16_t prod_id = input_device_get_prod_id(config);
    8001bd1a:	fd843503          	ld	a0,-40(s0)
    8001bd1e:	248000ef          	jal	ra,8001bf66 <input_device_get_prod_id>
    8001bd22:	87aa                	mv	a5,a0
    8001bd24:	fcf41b23          	sh	a5,-42(s0)
    InputDevice *input_dev;
    switch (prod_id) {
    8001bd28:	fd645783          	lhu	a5,-42(s0)
    8001bd2c:	0007871b          	sext.w	a4,a5
    8001bd30:	86ba                	mv	a3,a4
    8001bd32:	4785                	li	a5,1
    8001bd34:	00f68663          	beq	a3,a5,8001bd40 <input_device_init+0x60>
    8001bd38:	478d                	li	a5,3
    8001bd3a:	06f70363          	beq	a4,a5,8001bda0 <input_device_init+0xc0>
    8001bd3e:	a0c9                	j	8001be00 <input_device_init+0x120>
    case EV_KEY:
        virtio_set_device_name(device, "Keyboard");
    8001bd40:	0000a597          	auipc	a1,0xa
    8001bd44:	db058593          	addi	a1,a1,-592 # 80025af0 <pow10.0+0x18c0>
    8001bd48:	fb843503          	ld	a0,-72(s0)
    8001bd4c:	846ff0ef          	jal	ra,8001ad92 <virtio_set_device_name>
        device->ready = true;
    8001bd50:	fb843783          	ld	a5,-72(s0)
    8001bd54:	4705                	li	a4,1
    8001bd56:	08e78723          	sb	a4,142(a5)
        device->is_keyboard = 1;
    8001bd5a:	fb843783          	ld	a5,-72(s0)
    8001bd5e:	0947c703          	lbu	a4,148(a5)
    8001bd62:	00176713          	ori	a4,a4,1
    8001bd66:	08e78a23          	sb	a4,148(a5)
        device->is_tablet = 0;
    8001bd6a:	fb843783          	ld	a5,-72(s0)
    8001bd6e:	0947c703          	lbu	a4,148(a5)
    8001bd72:	9b75                	andi	a4,a4,-3
    8001bd74:	08e78a23          	sb	a4,148(a5)
        keyboard_dev.viodev = device;
    8001bd78:	00007797          	auipc	a5,0x7
    8001bd7c:	3d878793          	addi	a5,a5,984 # 80023150 <keyboard_dev>
    8001bd80:	fb843703          	ld	a4,-72(s0)
    8001bd84:	e798                	sd	a4,8(a5)
        input_dev = &keyboard_dev;
    8001bd86:	00007797          	auipc	a5,0x7
    8001bd8a:	3ca78793          	addi	a5,a5,970 # 80023150 <keyboard_dev>
    8001bd8e:	fef43423          	sd	a5,-24(s0)
        debugf("input_device_init: Input device initialized as keyboard\n");
    8001bd92:	0000a517          	auipc	a0,0xa
    8001bd96:	d6e50513          	addi	a0,a0,-658 # 80025b00 <pow10.0+0x18d0>
    8001bd9a:	c10fd0ef          	jal	ra,800191aa <debugf>
        break;
    8001bd9e:	a8a5                	j	8001be16 <input_device_init+0x136>
    case EV_ABS:
        virtio_set_device_name(device, "Tablet");
    8001bda0:	0000a597          	auipc	a1,0xa
    8001bda4:	da058593          	addi	a1,a1,-608 # 80025b40 <pow10.0+0x1910>
    8001bda8:	fb843503          	ld	a0,-72(s0)
    8001bdac:	fe7fe0ef          	jal	ra,8001ad92 <virtio_set_device_name>
        device->ready = true;
    8001bdb0:	fb843783          	ld	a5,-72(s0)
    8001bdb4:	4705                	li	a4,1
    8001bdb6:	08e78723          	sb	a4,142(a5)
        device->is_keyboard = 1;
    8001bdba:	fb843783          	ld	a5,-72(s0)
    8001bdbe:	0947c703          	lbu	a4,148(a5)
    8001bdc2:	00176713          	ori	a4,a4,1
    8001bdc6:	08e78a23          	sb	a4,148(a5)
        device->is_tablet = 0;
    8001bdca:	fb843783          	ld	a5,-72(s0)
    8001bdce:	0947c703          	lbu	a4,148(a5)
    8001bdd2:	9b75                	andi	a4,a4,-3
    8001bdd4:	08e78a23          	sb	a4,148(a5)
        tablet_dev.viodev = device;
    8001bdd8:	00007797          	auipc	a5,0x7
    8001bddc:	59878793          	addi	a5,a5,1432 # 80023370 <tablet_dev>
    8001bde0:	fb843703          	ld	a4,-72(s0)
    8001bde4:	e798                	sd	a4,8(a5)
        input_dev = &tablet_dev;
    8001bde6:	00007797          	auipc	a5,0x7
    8001bdea:	58a78793          	addi	a5,a5,1418 # 80023370 <tablet_dev>
    8001bdee:	fef43423          	sd	a5,-24(s0)
        debugf("input_device_init: Input device initialized as tablet\n");
    8001bdf2:	0000a517          	auipc	a0,0xa
    8001bdf6:	d5650513          	addi	a0,a0,-682 # 80025b48 <pow10.0+0x1918>
    8001bdfa:	bb0fd0ef          	jal	ra,800191aa <debugf>
        break;
    8001bdfe:	a821                	j	8001be16 <input_device_init+0x136>
    default:
        fatalf("input_device_init: Unsupported device\n", prod_id);
    8001be00:	fd645783          	lhu	a5,-42(s0)
    8001be04:	2781                	sext.w	a5,a5
    8001be06:	85be                	mv	a1,a5
    8001be08:	0000a517          	auipc	a0,0xa
    8001be0c:	d7850513          	addi	a0,a0,-648 # 80025b80 <pow10.0+0x1950>
    8001be10:	cf4fd0ef          	jal	ra,80019304 <fatalf>
        break;
    8001be14:	0001                	nop
    }

    IRQ_ON();
    8001be16:	100027f3          	csrr	a5,sstatus
    8001be1a:	fcf43423          	sd	a5,-56(s0)
    8001be1e:	fc843783          	ld	a5,-56(s0)
    8001be22:	0027e793          	ori	a5,a5,2
    8001be26:	10079073          	csrw	sstatus,a5
    input_device_receive_buffer_init(input_dev);
    8001be2a:	fe843503          	ld	a0,-24(s0)
    8001be2e:	024000ef          	jal	ra,8001be52 <input_device_receive_buffer_init>
    debugf("Input device init done for device at %p\n", device->pcidev->ecam_header);
    8001be32:	fb843783          	ld	a5,-72(s0)
    8001be36:	63bc                	ld	a5,64(a5)
    8001be38:	639c                	ld	a5,0(a5)
    8001be3a:	85be                	mv	a1,a5
    8001be3c:	0000a517          	auipc	a0,0xa
    8001be40:	d6c50513          	addi	a0,a0,-660 # 80025ba8 <pow10.0+0x1978>
    8001be44:	b66fd0ef          	jal	ra,800191aa <debugf>
}
    8001be48:	0001                	nop
    8001be4a:	60a6                	ld	ra,72(sp)
    8001be4c:	6406                	ld	s0,64(sp)
    8001be4e:	6161                	addi	sp,sp,80
    8001be50:	8082                	ret

000000008001be52 <input_device_receive_buffer_init>:
//     debugf("[Input] Input not found!");
//     return NULL;
// }

// At device init, populate the driver ring with receive buffers so we can receive events
void input_device_receive_buffer_init(InputDevice *input_dev) {
    8001be52:	7139                	addi	sp,sp,-64
    8001be54:	fc06                	sd	ra,56(sp)
    8001be56:	f822                	sd	s0,48(sp)
    8001be58:	0080                	addi	s0,sp,64
    8001be5a:	fca43423          	sd	a0,-56(s0)
    for (int i = 0; i < INPUT_EVENT_BUFFER_SIZE; i++) {
    8001be5e:	fe042623          	sw	zero,-20(s0)
    8001be62:	a0b9                	j	8001beb0 <input_device_receive_buffer_init+0x5e>
        VirtioDescriptor recv_buf_desc;
        recv_buf_desc.addr = kernel_mmu_translate((uintptr_t)&input_dev->event_buffer[i]);
    8001be64:	fec42783          	lw	a5,-20(s0)
    8001be68:	0789                	addi	a5,a5,2
    8001be6a:	078e                	slli	a5,a5,0x3
    8001be6c:	fc843703          	ld	a4,-56(s0)
    8001be70:	97ba                	add	a5,a5,a4
    8001be72:	853e                	mv	a0,a5
    8001be74:	e5ffd0ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    8001be78:	87aa                	mv	a5,a0
    8001be7a:	fcf43c23          	sd	a5,-40(s0)
        recv_buf_desc.flags = VIRTQ_DESC_F_WRITE;
    8001be7e:	4789                	li	a5,2
    8001be80:	fef41223          	sh	a5,-28(s0)
        recv_buf_desc.len = sizeof(VirtioInputEvent);
    8001be84:	47a1                	li	a5,8
    8001be86:	fef42023          	sw	a5,-32(s0)
        recv_buf_desc.next = 0;
    8001be8a:	fe041323          	sh	zero,-26(s0)
        virtio_send_one_descriptor(input_dev->viodev, 0, recv_buf_desc, true);
    8001be8e:	fc843783          	ld	a5,-56(s0)
    8001be92:	679c                	ld	a5,8(a5)
    8001be94:	4705                	li	a4,1
    8001be96:	fd843603          	ld	a2,-40(s0)
    8001be9a:	fe043683          	ld	a3,-32(s0)
    8001be9e:	4581                	li	a1,0
    8001bea0:	853e                	mv	a0,a5
    8001bea2:	8d6ff0ef          	jal	ra,8001af78 <virtio_send_one_descriptor>
    for (int i = 0; i < INPUT_EVENT_BUFFER_SIZE; i++) {
    8001bea6:	fec42783          	lw	a5,-20(s0)
    8001beaa:	2785                	addiw	a5,a5,1
    8001beac:	fef42623          	sw	a5,-20(s0)
    8001beb0:	fec42783          	lw	a5,-20(s0)
    8001beb4:	0007871b          	sext.w	a4,a5
    8001beb8:	03f00793          	li	a5,63
    8001bebc:	fae7d4e3          	bge	a5,a4,8001be64 <input_device_receive_buffer_init+0x12>
    }
}
    8001bec0:	0001                	nop
    8001bec2:	0001                	nop
    8001bec4:	70e2                	ld	ra,56(sp)
    8001bec6:	7442                	ld	s0,48(sp)
    8001bec8:	6121                	addi	sp,sp,64
    8001beca:	8082                	ret

000000008001becc <get_input_device_config>:

void get_input_device_config(VirtioDevice *device, uint8_t select, uint8_t subsel, uint8_t size) {
    8001becc:	7179                	addi	sp,sp,-48
    8001bece:	f406                	sd	ra,40(sp)
    8001bed0:	f022                	sd	s0,32(sp)
    8001bed2:	1800                	addi	s0,sp,48
    8001bed4:	fca43c23          	sd	a0,-40(s0)
    8001bed8:	87ae                	mv	a5,a1
    8001beda:	8736                	mv	a4,a3
    8001bedc:	fcf40ba3          	sb	a5,-41(s0)
    8001bee0:	87b2                	mv	a5,a2
    8001bee2:	fcf40b23          	sb	a5,-42(s0)
    8001bee6:	87ba                	mv	a5,a4
    8001bee8:	fcf40aa3          	sb	a5,-43(s0)
    volatile VirtioInputConfig *config = virtio_get_input_config(device);
    8001beec:	fd843503          	ld	a0,-40(s0)
    8001bef0:	e9cfe0ef          	jal	ra,8001a58c <virtio_get_input_config>
    8001bef4:	fea43423          	sd	a0,-24(s0)
    config->select = select;
    8001bef8:	fe843783          	ld	a5,-24(s0)
    8001befc:	fd744703          	lbu	a4,-41(s0)
    8001bf00:	00e78023          	sb	a4,0(a5)
    debugf("set_input_device_config: select = 0x%x\n", config->select);
    8001bf04:	fe843783          	ld	a5,-24(s0)
    8001bf08:	0007c783          	lbu	a5,0(a5)
    8001bf0c:	0ff7f793          	andi	a5,a5,255
    8001bf10:	2781                	sext.w	a5,a5
    8001bf12:	85be                	mv	a1,a5
    8001bf14:	0000a517          	auipc	a0,0xa
    8001bf18:	cc450513          	addi	a0,a0,-828 # 80025bd8 <pow10.0+0x19a8>
    8001bf1c:	a8efd0ef          	jal	ra,800191aa <debugf>
    config->subsel = subsel;
    8001bf20:	fe843783          	ld	a5,-24(s0)
    8001bf24:	fd644703          	lbu	a4,-42(s0)
    8001bf28:	00e780a3          	sb	a4,1(a5)
    debugf("set_input_device_config: subsel = 0x%x\n", config->subsel);
    8001bf2c:	fe843783          	ld	a5,-24(s0)
    8001bf30:	0017c783          	lbu	a5,1(a5)
    8001bf34:	0ff7f793          	andi	a5,a5,255
    8001bf38:	2781                	sext.w	a5,a5
    8001bf3a:	85be                	mv	a1,a5
    8001bf3c:	0000a517          	auipc	a0,0xa
    8001bf40:	cc450513          	addi	a0,a0,-828 # 80025c00 <pow10.0+0x19d0>
    8001bf44:	a66fd0ef          	jal	ra,800191aa <debugf>
    debugf("%.128s\n", config->string);
    8001bf48:	fe843783          	ld	a5,-24(s0)
    8001bf4c:	07a1                	addi	a5,a5,8
    8001bf4e:	85be                	mv	a1,a5
    8001bf50:	0000a517          	auipc	a0,0xa
    8001bf54:	cd850513          	addi	a0,a0,-808 # 80025c28 <pow10.0+0x19f8>
    8001bf58:	a52fd0ef          	jal	ra,800191aa <debugf>
}
    8001bf5c:	0001                	nop
    8001bf5e:	70a2                	ld	ra,40(sp)
    8001bf60:	7402                	ld	s0,32(sp)
    8001bf62:	6145                	addi	sp,sp,48
    8001bf64:	8082                	ret

000000008001bf66 <input_device_get_prod_id>:

uint16_t input_device_get_prod_id(volatile VirtioInputConfig *config) {
    8001bf66:	1101                	addi	sp,sp,-32
    8001bf68:	ec22                	sd	s0,24(sp)
    8001bf6a:	1000                	addi	s0,sp,32
    8001bf6c:	fea43423          	sd	a0,-24(s0)
    config->select = VIRTIO_INPUT_CFG_ID_DEVIDS;
    8001bf70:	fe843783          	ld	a5,-24(s0)
    8001bf74:	470d                	li	a4,3
    8001bf76:	00e78023          	sb	a4,0(a5)
    config->subsel = 0;
    8001bf7a:	fe843783          	ld	a5,-24(s0)
    8001bf7e:	000780a3          	sb	zero,1(a5)
    return config->ids.product;
    8001bf82:	fe843783          	ld	a5,-24(s0)
    8001bf86:	00c7d783          	lhu	a5,12(a5)
    8001bf8a:	17c2                	slli	a5,a5,0x30
    8001bf8c:	93c1                	srli	a5,a5,0x30
}
    8001bf8e:	853e                	mv	a0,a5
    8001bf90:	6462                	ld	s0,24(sp)
    8001bf92:	6105                	addi	sp,sp,32
    8001bf94:	8082                	ret

000000008001bf96 <input_device_isr>:

void input_device_isr(VirtioDevice* viodev) {
    8001bf96:	715d                	addi	sp,sp,-80
    8001bf98:	e486                	sd	ra,72(sp)
    8001bf9a:	e0a2                	sd	s0,64(sp)
    8001bf9c:	0880                	addi	s0,sp,80
    8001bf9e:	faa43c23          	sd	a0,-72(s0)
    debugf("input_device_isr: Starting ISR\n");
    8001bfa2:	0000a517          	auipc	a0,0xa
    8001bfa6:	c8e50513          	addi	a0,a0,-882 # 80025c30 <pow10.0+0x1a00>
    8001bfaa:	a00fd0ef          	jal	ra,800191aa <debugf>
    
    if(!viodev->ready){
    8001bfae:	fb843783          	ld	a5,-72(s0)
    8001bfb2:	08e7c783          	lbu	a5,142(a5)
    8001bfb6:	0017c793          	xori	a5,a5,1
    8001bfba:	0ff7f793          	andi	a5,a5,255
    8001bfbe:	c799                	beqz	a5,8001bfcc <input_device_isr+0x36>
        fatalf("input_device_isr: Device not ready!\n");
    8001bfc0:	0000a517          	auipc	a0,0xa
    8001bfc4:	c9050513          	addi	a0,a0,-880 # 80025c50 <pow10.0+0x1a20>
    8001bfc8:	b3cfd0ef          	jal	ra,80019304 <fatalf>
    }

    InputDevice *input_dev;
    if (viodev->is_keyboard) {
    8001bfcc:	fb843783          	ld	a5,-72(s0)
    8001bfd0:	0947c783          	lbu	a5,148(a5)
    8001bfd4:	8b85                	andi	a5,a5,1
    8001bfd6:	0ff7f793          	andi	a5,a5,255
    8001bfda:	cb81                	beqz	a5,8001bfea <input_device_isr+0x54>
        input_dev = &keyboard_dev;
    8001bfdc:	00007797          	auipc	a5,0x7
    8001bfe0:	17478793          	addi	a5,a5,372 # 80023150 <keyboard_dev>
    8001bfe4:	fef43423          	sd	a5,-24(s0)
    8001bfe8:	a035                	j	8001c014 <input_device_isr+0x7e>
    } else if (viodev->is_tablet) {
    8001bfea:	fb843783          	ld	a5,-72(s0)
    8001bfee:	0947c783          	lbu	a5,148(a5)
    8001bff2:	8b89                	andi	a5,a5,2
    8001bff4:	0ff7f793          	andi	a5,a5,255
    8001bff8:	cb81                	beqz	a5,8001c008 <input_device_isr+0x72>
        input_dev = &tablet_dev;
    8001bffa:	00007797          	auipc	a5,0x7
    8001bffe:	37678793          	addi	a5,a5,886 # 80023370 <tablet_dev>
    8001c002:	fef43423          	sd	a5,-24(s0)
    8001c006:	a039                	j	8001c014 <input_device_isr+0x7e>
    } else {
        fatalf("input_device_isr: Unsupported input device\n");
    8001c008:	0000a517          	auipc	a0,0xa
    8001c00c:	c7050513          	addi	a0,a0,-912 # 80025c78 <pow10.0+0x1a48>
    8001c010:	af4fd0ef          	jal	ra,80019304 <fatalf>
    }

    uint16_t start_device_idx = viodev->device_idx;
    8001c014:	fb843783          	ld	a5,-72(s0)
    8001c018:	08c7d783          	lhu	a5,140(a5)
    8001c01c:	fef41223          	sh	a5,-28(s0)
    uint16_t num_received = 0;
    8001c020:	fe041323          	sh	zero,-26(s0)
    // Have to receive multiple descriptors
    while (viodev->device_idx != viodev->device->idx) {
    8001c024:	a229                	j	8001c12e <input_device_isr+0x198>
        // uint32_t id = viodev->device->ring[viodev->device_idx % queue_size].id;
        VirtioDescriptor received_desc;
        virtio_receive_descriptor_chain(viodev, 0, &received_desc, 1, false);
    8001c026:	fc040793          	addi	a5,s0,-64
    8001c02a:	4701                	li	a4,0
    8001c02c:	4685                	li	a3,1
    8001c02e:	863e                	mv	a2,a5
    8001c030:	4581                	li	a1,0
    8001c032:	fb843503          	ld	a0,-72(s0)
    8001c036:	9a8ff0ef          	jal	ra,8001b1de <virtio_receive_descriptor_chain>
        VirtioInputEvent *event_ptr = (VirtioInputEvent *)received_desc.addr;
    8001c03a:	fc043783          	ld	a5,-64(s0)
    8001c03e:	fcf43c23          	sd	a5,-40(s0)

        uint32_t len = received_desc.len;
    8001c042:	fc842783          	lw	a5,-56(s0)
    8001c046:	fcf42a23          	sw	a5,-44(s0)
        if (len != sizeof(VirtioInputEvent)) {
    8001c04a:	fd442783          	lw	a5,-44(s0)
    8001c04e:	0007871b          	sext.w	a4,a5
    8001c052:	47a1                	li	a5,8
    8001c054:	02f70663          	beq	a4,a5,8001c080 <input_device_isr+0xea>
            debugf("input_device_isr: Received invalid input event size: %d\n", len);
    8001c058:	fd442783          	lw	a5,-44(s0)
    8001c05c:	85be                	mv	a1,a5
    8001c05e:	0000a517          	auipc	a0,0xa
    8001c062:	c4a50513          	addi	a0,a0,-950 # 80025ca8 <pow10.0+0x1a78>
    8001c066:	944fd0ef          	jal	ra,800191aa <debugf>
            virtio_send_one_descriptor(viodev, 0, received_desc, true);
    8001c06a:	4705                	li	a4,1
    8001c06c:	fc043603          	ld	a2,-64(s0)
    8001c070:	fc843683          	ld	a3,-56(s0)
    8001c074:	4581                	li	a1,0
    8001c076:	fb843503          	ld	a0,-72(s0)
    8001c07a:	efffe0ef          	jal	ra,8001af78 <virtio_send_one_descriptor>
    8001c07e:	a845                	j	8001c12e <input_device_isr+0x198>
            continue;
        }

        // Copy event to local buffer
        if (input_dev->buffer_size < INPUT_EVENT_BUFFER_SIZE) {
    8001c080:	fe843783          	ld	a5,-24(s0)
    8001c084:	2187a783          	lw	a5,536(a5)
    8001c088:	873e                	mv	a4,a5
    8001c08a:	03f00793          	li	a5,63
    8001c08e:	06e7cb63          	blt	a5,a4,8001c104 <input_device_isr+0x16e>
            // IRQ_OFF();
            // memcpy(&input_dev->event_buffer[input_dev->tail], event_ptr, sizeof(VirtioInputEvent));
            // IRQ_ON();
            input_dev->tail = (input_dev->tail + 1) % INPUT_EVENT_BUFFER_SIZE;
    8001c092:	fe843783          	ld	a5,-24(s0)
    8001c096:	2147a783          	lw	a5,532(a5)
    8001c09a:	2785                	addiw	a5,a5,1
    8001c09c:	2781                	sext.w	a5,a5
    8001c09e:	873e                	mv	a4,a5
    8001c0a0:	41f7579b          	sraiw	a5,a4,0x1f
    8001c0a4:	01a7d79b          	srliw	a5,a5,0x1a
    8001c0a8:	9f3d                	addw	a4,a4,a5
    8001c0aa:	03f77713          	andi	a4,a4,63
    8001c0ae:	40f707bb          	subw	a5,a4,a5
    8001c0b2:	0007871b          	sext.w	a4,a5
    8001c0b6:	fe843783          	ld	a5,-24(s0)
    8001c0ba:	20e7aa23          	sw	a4,532(a5)
            input_dev->buffer_size++;
    8001c0be:	fe843783          	ld	a5,-24(s0)
    8001c0c2:	2187a783          	lw	a5,536(a5)
    8001c0c6:	2785                	addiw	a5,a5,1
    8001c0c8:	0007871b          	sext.w	a4,a5
    8001c0cc:	fe843783          	ld	a5,-24(s0)
    8001c0d0:	20e7ac23          	sw	a4,536(a5)
            debugf("input_device_isr: Input event received: type = 0x%x, code = 0x%x, value = 0x%x\n", event_ptr->type, event_ptr->code, event_ptr->value);
    8001c0d4:	fd843783          	ld	a5,-40(s0)
    8001c0d8:	0007d783          	lhu	a5,0(a5)
    8001c0dc:	0007871b          	sext.w	a4,a5
    8001c0e0:	fd843783          	ld	a5,-40(s0)
    8001c0e4:	0027d783          	lhu	a5,2(a5)
    8001c0e8:	0007861b          	sext.w	a2,a5
    8001c0ec:	fd843783          	ld	a5,-40(s0)
    8001c0f0:	43dc                	lw	a5,4(a5)
    8001c0f2:	86be                	mv	a3,a5
    8001c0f4:	85ba                	mv	a1,a4
    8001c0f6:	0000a517          	auipc	a0,0xa
    8001c0fa:	bf250513          	addi	a0,a0,-1038 # 80025ce8 <pow10.0+0x1ab8>
    8001c0fe:	8acfd0ef          	jal	ra,800191aa <debugf>
    8001c102:	a039                	j	8001c110 <input_device_isr+0x17a>
        } else {
            debugf("input_device_isr: Input event buffer full, event dropped\n");
    8001c104:	0000a517          	auipc	a0,0xa
    8001c108:	c3450513          	addi	a0,a0,-972 # 80025d38 <pow10.0+0x1b08>
    8001c10c:	89efd0ef          	jal	ra,800191aa <debugf>
        }
        virtio_send_one_descriptor(viodev, 0, received_desc, true);
    8001c110:	4705                	li	a4,1
    8001c112:	fc043603          	ld	a2,-64(s0)
    8001c116:	fc843683          	ld	a3,-56(s0)
    8001c11a:	4581                	li	a1,0
    8001c11c:	fb843503          	ld	a0,-72(s0)
    8001c120:	e59fe0ef          	jal	ra,8001af78 <virtio_send_one_descriptor>
        ++num_received;
    8001c124:	fe645783          	lhu	a5,-26(s0)
    8001c128:	2785                	addiw	a5,a5,1
    8001c12a:	fef41323          	sh	a5,-26(s0)
    while (viodev->device_idx != viodev->device->idx) {
    8001c12e:	fb843783          	ld	a5,-72(s0)
    8001c132:	08c7d703          	lhu	a4,140(a5)
    8001c136:	fb843783          	ld	a5,-72(s0)
    8001c13a:	7bbc                	ld	a5,112(a5)
    8001c13c:	0027d783          	lhu	a5,2(a5)
    8001c140:	17c2                	slli	a5,a5,0x30
    8001c142:	93c1                	srli	a5,a5,0x30
    8001c144:	2701                	sext.w	a4,a4
    8001c146:	2781                	sext.w	a5,a5
    8001c148:	ecf71fe3          	bne	a4,a5,8001c026 <input_device_isr+0x90>
    }

    // Sanity check
    debugf("input_device_isr: After receiving descriptors\n");
    8001c14c:	0000a517          	auipc	a0,0xa
    8001c150:	c2c50513          	addi	a0,a0,-980 # 80025d78 <pow10.0+0x1b48>
    8001c154:	856fd0ef          	jal	ra,800191aa <debugf>
    debugf("  num_received = %d\n", num_received);
    8001c158:	fe645783          	lhu	a5,-26(s0)
    8001c15c:	2781                	sext.w	a5,a5
    8001c15e:	85be                	mv	a1,a5
    8001c160:	0000a517          	auipc	a0,0xa
    8001c164:	c4850513          	addi	a0,a0,-952 # 80025da8 <pow10.0+0x1b78>
    8001c168:	842fd0ef          	jal	ra,800191aa <debugf>
    debugf("  Starting device_idx = %d\n", start_device_idx);
    8001c16c:	fe445783          	lhu	a5,-28(s0)
    8001c170:	2781                	sext.w	a5,a5
    8001c172:	85be                	mv	a1,a5
    8001c174:	0000a517          	auipc	a0,0xa
    8001c178:	c4c50513          	addi	a0,a0,-948 # 80025dc0 <pow10.0+0x1b90>
    8001c17c:	82efd0ef          	jal	ra,800191aa <debugf>
    debugf("  Ending device_idx = %d\n", viodev->device_idx);
    8001c180:	fb843783          	ld	a5,-72(s0)
    8001c184:	08c7d783          	lhu	a5,140(a5)
    8001c188:	2781                	sext.w	a5,a5
    8001c18a:	85be                	mv	a1,a5
    8001c18c:	0000a517          	auipc	a0,0xa
    8001c190:	c5450513          	addi	a0,a0,-940 # 80025de0 <pow10.0+0x1bb0>
    8001c194:	816fd0ef          	jal	ra,800191aa <debugf>
    debugf("  Ending device->idx = %d\n", viodev->device->idx);
    8001c198:	fb843783          	ld	a5,-72(s0)
    8001c19c:	7bbc                	ld	a5,112(a5)
    8001c19e:	0027d783          	lhu	a5,2(a5)
    8001c1a2:	17c2                	slli	a5,a5,0x30
    8001c1a4:	93c1                	srli	a5,a5,0x30
    8001c1a6:	2781                	sext.w	a5,a5
    8001c1a8:	85be                	mv	a1,a5
    8001c1aa:	0000a517          	auipc	a0,0xa
    8001c1ae:	c5650513          	addi	a0,a0,-938 # 80025e00 <pow10.0+0x1bd0>
    8001c1b2:	ff9fc0ef          	jal	ra,800191aa <debugf>
    debugf("  input_dev->buffer_size = %d\n", input_dev->buffer_size);
    8001c1b6:	fe843783          	ld	a5,-24(s0)
    8001c1ba:	2187a783          	lw	a5,536(a5)
    8001c1be:	85be                	mv	a1,a5
    8001c1c0:	0000a517          	auipc	a0,0xa
    8001c1c4:	c6050513          	addi	a0,a0,-928 # 80025e20 <pow10.0+0x1bf0>
    8001c1c8:	fe3fc0ef          	jal	ra,800191aa <debugf>
}
    8001c1cc:	0001                	nop
    8001c1ce:	60a6                	ld	ra,72(sp)
    8001c1d0:	6406                	ld	s0,64(sp)
    8001c1d2:	6161                	addi	sp,sp,80
    8001c1d4:	8082                	ret

000000008001c1d6 <block_device_init>:
static uint64_t request_count = 0;
static Vector *device_active_jobs;
// static VirtioDevice *block_device;
static Mutex block_device_mutex;

void block_device_init() {
    8001c1d6:	7139                	addi	sp,sp,-64
    8001c1d8:	fc06                	sd	ra,56(sp)
    8001c1da:	f822                	sd	s0,48(sp)
    8001c1dc:	0080                	addi	s0,sp,64
    // device_active_jobs = vector_new();
    // block_device = virtio_get_block_device();
    block_device_mutex = MUTEX_UNLOCKED;
    8001c1de:	00007797          	auipc	a5,0x7
    8001c1e2:	3c278793          	addi	a5,a5,962 # 800235a0 <block_device_mutex>
    8001c1e6:	0007a023          	sw	zero,0(a5)
    for (uint16_t n; n < 8; n++) {
    8001c1ea:	a095                	j	8001c24e <block_device_init+0x78>
        // debugf("BAR %d: %x\n", n, pci_get_bar(block_device->pcidev, n));
        VirtioDevice *block_device = virtio_get_block_device(n);
    8001c1ec:	fee45783          	lhu	a5,-18(s0)
    8001c1f0:	853e                	mv	a0,a5
    8001c1f2:	dcefe0ef          	jal	ra,8001a7c0 <virtio_get_block_device>
    8001c1f6:	fea43023          	sd	a0,-32(s0)
        if (block_device == NULL) {
    8001c1fa:	fe043783          	ld	a5,-32(s0)
    8001c1fe:	c3b1                	beqz	a5,8001c242 <block_device_init+0x6c>
            debugf("No block device #%d\n", n);
            continue;
        }
        char name[16];
        sprintf(name, "block%d", n);
    8001c200:	fee45783          	lhu	a5,-18(s0)
    8001c204:	0007871b          	sext.w	a4,a5
    8001c208:	fc840793          	addi	a5,s0,-56
    8001c20c:	863a                	mv	a2,a4
    8001c20e:	0000a597          	auipc	a1,0xa
    8001c212:	c3258593          	addi	a1,a1,-974 # 80025e40 <pow10.0+0x1c10>
    8001c216:	853e                	mv	a0,a5
    8001c218:	890f60ef          	jal	ra,800122a8 <sprintf>
        virtio_set_device_name(block_device, name);
    8001c21c:	fc840793          	addi	a5,s0,-56
    8001c220:	85be                	mv	a1,a5
    8001c222:	fe043503          	ld	a0,-32(s0)
    8001c226:	b6dfe0ef          	jal	ra,8001ad92 <virtio_set_device_name>
        block_device->ready = true;
    8001c22a:	fe043783          	ld	a5,-32(s0)
    8001c22e:	4705                	li	a4,1
    8001c230:	08e78723          	sb	a4,142(a5)
        volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001c234:	fe043503          	ld	a0,-32(s0)
    8001c238:	b30fe0ef          	jal	ra,8001a568 <virtio_get_block_config>
    8001c23c:	fca43c23          	sd	a0,-40(s0)
    8001c240:	a011                	j	8001c244 <block_device_init+0x6e>
            continue;
    8001c242:	0001                	nop
    for (uint16_t n; n < 8; n++) {
    8001c244:	fee45783          	lhu	a5,-18(s0)
    8001c248:	2785                	addiw	a5,a5,1
    8001c24a:	fef41723          	sh	a5,-18(s0)
    8001c24e:	fee45783          	lhu	a5,-18(s0)
    8001c252:	0007871b          	sext.w	a4,a5
    8001c256:	479d                	li	a5,7
    8001c258:	f8e7fae3          	bgeu	a5,a4,8001c1ec <block_device_init+0x16>
        debugf("Block #%d device has %d capacity\n", n, config->capacity);
        debugf("Block #%d device has %d cylinders\n", n, config->geometry.cylinders);
        debugf("Block #%d device has %d heads\n", n, config->geometry.heads);
        debugf("Block device init done for device at %p\n", block_device->pcidev->ecam_header);
    }
}
    8001c25c:	0001                	nop
    8001c25e:	0001                	nop
    8001c260:	70e2                	ld	ra,56(sp)
    8001c262:	7442                	ld	s0,48(sp)
    8001c264:	6121                	addi	sp,sp,64
    8001c266:	8082                	ret

000000008001c268 <block_device_get_sector_size>:

uint64_t block_device_get_sector_size(VirtioDevice *block_device) {
    8001c268:	7179                	addi	sp,sp,-48
    8001c26a:	f406                	sd	ra,40(sp)
    8001c26c:	f022                	sd	s0,32(sp)
    8001c26e:	1800                	addi	s0,sp,48
    8001c270:	fca43c23          	sd	a0,-40(s0)
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001c274:	fd843503          	ld	a0,-40(s0)
    8001c278:	af0fe0ef          	jal	ra,8001a568 <virtio_get_block_config>
    8001c27c:	fea43423          	sd	a0,-24(s0)
    return config->blk_size;
    8001c280:	fe843783          	ld	a5,-24(s0)
    8001c284:	4bdc                	lw	a5,20(a5)
    8001c286:	2781                	sext.w	a5,a5
    8001c288:	1782                	slli	a5,a5,0x20
    8001c28a:	9381                	srli	a5,a5,0x20
}
    8001c28c:	853e                	mv	a0,a5
    8001c28e:	70a2                	ld	ra,40(sp)
    8001c290:	7402                	ld	s0,32(sp)
    8001c292:	6145                	addi	sp,sp,48
    8001c294:	8082                	ret

000000008001c296 <block_device_get_sector_count>:

uint64_t block_device_get_sector_count(VirtioDevice *block_device) {
    8001c296:	7179                	addi	sp,sp,-48
    8001c298:	f406                	sd	ra,40(sp)
    8001c29a:	f022                	sd	s0,32(sp)
    8001c29c:	1800                	addi	s0,sp,48
    8001c29e:	fca43c23          	sd	a0,-40(s0)
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001c2a2:	fd843503          	ld	a0,-40(s0)
    8001c2a6:	ac2fe0ef          	jal	ra,8001a568 <virtio_get_block_config>
    8001c2aa:	fea43423          	sd	a0,-24(s0)
    return config->capacity;
    8001c2ae:	fe843783          	ld	a5,-24(s0)
    8001c2b2:	639c                	ld	a5,0(a5)
}
    8001c2b4:	853e                	mv	a0,a5
    8001c2b6:	70a2                	ld	ra,40(sp)
    8001c2b8:	7402                	ld	s0,32(sp)
    8001c2ba:	6145                	addi	sp,sp,48
    8001c2bc:	8082                	ret

000000008001c2be <block_device_get_bytes>:

uint64_t block_device_get_bytes(VirtioDevice *block_device) {
    8001c2be:	7179                	addi	sp,sp,-48
    8001c2c0:	f406                	sd	ra,40(sp)
    8001c2c2:	f022                	sd	s0,32(sp)
    8001c2c4:	1800                	addi	s0,sp,48
    8001c2c6:	fca43c23          	sd	a0,-40(s0)
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001c2ca:	fd843503          	ld	a0,-40(s0)
    8001c2ce:	a9afe0ef          	jal	ra,8001a568 <virtio_get_block_config>
    8001c2d2:	fea43423          	sd	a0,-24(s0)
    return config->capacity * config->blk_size;
    8001c2d6:	fe843783          	ld	a5,-24(s0)
    8001c2da:	6398                	ld	a4,0(a5)
    8001c2dc:	fe843783          	ld	a5,-24(s0)
    8001c2e0:	4bdc                	lw	a5,20(a5)
    8001c2e2:	2781                	sext.w	a5,a5
    8001c2e4:	1782                	slli	a5,a5,0x20
    8001c2e6:	9381                	srli	a5,a5,0x20
    8001c2e8:	02f707b3          	mul	a5,a4,a5
}
    8001c2ec:	853e                	mv	a0,a5
    8001c2ee:	70a2                	ld	ra,40(sp)
    8001c2f0:	7402                	ld	s0,32(sp)
    8001c2f2:	6145                	addi	sp,sp,48
    8001c2f4:	8082                	ret

000000008001c2f6 <block_device_handle_job>:

void block_device_handle_job(VirtioDevice *block_device, Job *job) {
    8001c2f6:	7179                	addi	sp,sp,-48
    8001c2f8:	f422                	sd	s0,40(sp)
    8001c2fa:	1800                	addi	s0,sp,48
    8001c2fc:	fca43c23          	sd	a0,-40(s0)
    8001c300:	fcb43823          	sd	a1,-48(s0)
    debugf("Handling block device job %u\n", job->job_id);
    BlockRequestPacket *packet = (BlockRequestPacket *)job->data;
    8001c304:	fd043783          	ld	a5,-48(s0)
    8001c308:	7b9c                	ld	a5,48(a5)
    8001c30a:	fef43423          	sd	a5,-24(s0)
    debugf("Packet status in handle: %x\n", packet->status);
    
    job->data = NULL;
    8001c30e:	fd043783          	ld	a5,-48(s0)
    8001c312:	0207b823          	sd	zero,48(a5)
}
    8001c316:	0001                	nop
    8001c318:	7422                	ld	s0,40(sp)
    8001c31a:	6145                	addi	sp,sp,48
    8001c31c:	8082                	ret

000000008001c31e <block_device_send_request>:

void block_device_send_request(VirtioDevice *block_device, BlockRequestPacket *packet) {
    8001c31e:	7119                	addi	sp,sp,-128
    8001c320:	fc86                	sd	ra,120(sp)
    8001c322:	f8a2                	sd	s0,112(sp)
    8001c324:	0100                	addi	s0,sp,128
    8001c326:	f8a43423          	sd	a0,-120(s0)
    8001c32a:	f8b43023          	sd	a1,-128(s0)
    mutex_spinlock(&block_device_mutex);
    8001c32e:	00007517          	auipc	a0,0x7
    8001c332:	27250513          	addi	a0,a0,626 # 800235a0 <block_device_mutex>
    8001c336:	a69f70ef          	jal	ra,80013d9e <mutex_spinlock>
    request_count++;
    8001c33a:	00007797          	auipc	a5,0x7
    8001c33e:	25678793          	addi	a5,a5,598 # 80023590 <request_count>
    8001c342:	639c                	ld	a5,0(a5)
    8001c344:	00178713          	addi	a4,a5,1
    8001c348:	00007797          	auipc	a5,0x7
    8001c34c:	24878793          	addi	a5,a5,584 # 80023590 <request_count>
    8001c350:	e398                	sd	a4,0(a5)

    debugf("Sending block request #%u\n", request_count);
    // First descriptor is the header
    packet->status = 0xf;
    8001c352:	f8043783          	ld	a5,-128(s0)
    8001c356:	473d                	li	a4,15
    8001c358:	00e78ca3          	sb	a4,25(a5)

    VirtioDescriptor header;
    header.addr = kernel_mmu_translate((uint64_t)packet);
    8001c35c:	f8043783          	ld	a5,-128(s0)
    8001c360:	853e                	mv	a0,a5
    8001c362:	971fd0ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    8001c366:	87aa                	mv	a5,a0
    8001c368:	fef43023          	sd	a5,-32(s0)
    header.flags = VIRTQ_DESC_F_NEXT;
    8001c36c:	4785                	li	a5,1
    8001c36e:	fef41623          	sh	a5,-20(s0)
    header.len = sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t);
    8001c372:	47c1                	li	a5,16
    8001c374:	fef42423          	sw	a5,-24(s0)

    // Second descriptor is the data
    VirtioDescriptor data;
    data.addr = kernel_mmu_translate((uint64_t)packet->data);
    8001c378:	f8043783          	ld	a5,-128(s0)
    8001c37c:	6b9c                	ld	a5,16(a5)
    8001c37e:	853e                	mv	a0,a5
    8001c380:	953fd0ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    8001c384:	87aa                	mv	a5,a0
    8001c386:	fcf43823          	sd	a5,-48(s0)
    if (packet->type == VIRTIO_BLK_T_IN)
    8001c38a:	f8043783          	ld	a5,-128(s0)
    8001c38e:	439c                	lw	a5,0(a5)
    8001c390:	e781                	bnez	a5,8001c398 <block_device_send_request+0x7a>
        data.flags = VIRTQ_DESC_F_WRITE;
    8001c392:	4789                	li	a5,2
    8001c394:	fcf41e23          	sh	a5,-36(s0)
    data.flags |= VIRTQ_DESC_F_NEXT;
    8001c398:	fdc45783          	lhu	a5,-36(s0)
    8001c39c:	0017e793          	ori	a5,a5,1
    8001c3a0:	17c2                	slli	a5,a5,0x30
    8001c3a2:	93c1                	srli	a5,a5,0x30
    8001c3a4:	fcf41e23          	sh	a5,-36(s0)
    data.len = packet->sector_count * 512;
    8001c3a8:	f8043783          	ld	a5,-128(s0)
    8001c3ac:	0187c783          	lbu	a5,24(a5)
    8001c3b0:	2781                	sext.w	a5,a5
    8001c3b2:	0097979b          	slliw	a5,a5,0x9
    8001c3b6:	2781                	sext.w	a5,a5
    8001c3b8:	2781                	sext.w	a5,a5
    8001c3ba:	fcf42c23          	sw	a5,-40(s0)

    // The third descriptor is the status
    VirtioDescriptor status;
    status.addr = kernel_mmu_translate((uint64_t)&packet->status);
    8001c3be:	f8043783          	ld	a5,-128(s0)
    8001c3c2:	07e5                	addi	a5,a5,25
    8001c3c4:	853e                	mv	a0,a5
    8001c3c6:	90dfd0ef          	jal	ra,80019cd2 <kernel_mmu_translate>
    8001c3ca:	87aa                	mv	a5,a0
    8001c3cc:	fcf43023          	sd	a5,-64(s0)
    status.flags = VIRTQ_DESC_F_WRITE;
    8001c3d0:	4789                	li	a5,2
    8001c3d2:	fcf41623          	sh	a5,-52(s0)
    status.len = sizeof(packet->status);
    8001c3d6:	4785                	li	a5,1
    8001c3d8:	fcf42423          	sw	a5,-56(s0)

    VirtioDescriptor chain[3];
    chain[0] = header;
    8001c3dc:	fe043783          	ld	a5,-32(s0)
    8001c3e0:	f8f43823          	sd	a5,-112(s0)
    8001c3e4:	fe843783          	ld	a5,-24(s0)
    8001c3e8:	f8f43c23          	sd	a5,-104(s0)
    chain[1] = data;
    8001c3ec:	fd043783          	ld	a5,-48(s0)
    8001c3f0:	faf43023          	sd	a5,-96(s0)
    8001c3f4:	fd843783          	ld	a5,-40(s0)
    8001c3f8:	faf43423          	sd	a5,-88(s0)
    chain[2] = status;
    8001c3fc:	fc043783          	ld	a5,-64(s0)
    8001c400:	faf43823          	sd	a5,-80(s0)
    8001c404:	fc843783          	ld	a5,-56(s0)
    8001c408:	faf43c23          	sd	a5,-72(s0)

    virtio_create_job_with_data(block_device, 1, block_device_handle_job, packet);
    8001c40c:	f8043683          	ld	a3,-128(s0)
    8001c410:	00000617          	auipc	a2,0x0
    8001c414:	ee660613          	addi	a2,a2,-282 # 8001c2f6 <block_device_handle_job>
    8001c418:	4585                	li	a1,1
    8001c41a:	f8843503          	ld	a0,-120(s0)
    8001c41e:	c05fd0ef          	jal	ra,8001a022 <virtio_create_job_with_data>
    virtio_send_descriptor_chain(block_device, 0, chain, 3, true);
    8001c422:	f9040793          	addi	a5,s0,-112
    8001c426:	4705                	li	a4,1
    8001c428:	468d                	li	a3,3
    8001c42a:	863e                	mv	a2,a5
    8001c42c:	4581                	li	a1,0
    8001c42e:	f8843503          	ld	a0,-120(s0)
    8001c432:	b89fe0ef          	jal	ra,8001afba <virtio_send_descriptor_chain>
    WFI();
    8001c436:	10500073          	wfi

    debugf("Packet status after sending request #%u: %x\n", request_count, packet->status);
    if (packet->status != 0) {
    8001c43a:	f8043783          	ld	a5,-128(s0)
    8001c43e:	0197c783          	lbu	a5,25(a5)
    8001c442:	cf89                	beqz	a5,8001c45c <block_device_send_request+0x13e>
        warnf("Block device request failed with status %x\n", packet->status);
    8001c444:	f8043783          	ld	a5,-128(s0)
    8001c448:	0197c783          	lbu	a5,25(a5)
    8001c44c:	2781                	sext.w	a5,a5
    8001c44e:	85be                	mv	a1,a5
    8001c450:	0000a517          	auipc	a0,0xa
    8001c454:	9f850513          	addi	a0,a0,-1544 # 80025e48 <pow10.0+0x1c18>
    8001c458:	da9fc0ef          	jal	ra,80019200 <warnf>
    }
    
    mutex_unlock(&block_device_mutex);
    8001c45c:	00007517          	auipc	a0,0x7
    8001c460:	14450513          	addi	a0,a0,324 # 800235a0 <block_device_mutex>
    8001c464:	969f70ef          	jal	ra,80013dcc <mutex_unlock>
}
    8001c468:	0001                	nop
    8001c46a:	70e6                	ld	ra,120(sp)
    8001c46c:	7446                	ld	s0,112(sp)
    8001c46e:	6109                	addi	sp,sp,128
    8001c470:	8082                	ret

000000008001c472 <block_device_read_sector>:

void block_device_read_sector(VirtioDevice *block_device, uint64_t sector, uint8_t *data) {
    8001c472:	715d                	addi	sp,sp,-80
    8001c474:	e486                	sd	ra,72(sp)
    8001c476:	e0a2                	sd	s0,64(sp)
    8001c478:	0880                	addi	s0,sp,80
    8001c47a:	fca43423          	sd	a0,-56(s0)
    8001c47e:	fcb43023          	sd	a1,-64(s0)
    8001c482:	fac43c23          	sd	a2,-72(s0)
    debugf("Reading sector %d\n", sector);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_IN;
    8001c486:	fc042823          	sw	zero,-48(s0)
    packet.sector = sector;
    8001c48a:	fc043783          	ld	a5,-64(s0)
    8001c48e:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001c492:	fb843783          	ld	a5,-72(s0)
    8001c496:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    8001c49a:	4785                	li	a5,1
    8001c49c:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001c4a0:	47bd                	li	a5,15
    8001c4a2:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001c4a6:	fd040793          	addi	a5,s0,-48
    8001c4aa:	85be                	mv	a1,a5
    8001c4ac:	fc843503          	ld	a0,-56(s0)
    8001c4b0:	e6fff0ef          	jal	ra,8001c31e <block_device_send_request>
}
    8001c4b4:	0001                	nop
    8001c4b6:	60a6                	ld	ra,72(sp)
    8001c4b8:	6406                	ld	s0,64(sp)
    8001c4ba:	6161                	addi	sp,sp,80
    8001c4bc:	8082                	ret

000000008001c4be <block_device_write_sector>:

void block_device_write_sector(VirtioDevice *block_device, uint64_t sector, uint8_t *data) {
    8001c4be:	715d                	addi	sp,sp,-80
    8001c4c0:	e486                	sd	ra,72(sp)
    8001c4c2:	e0a2                	sd	s0,64(sp)
    8001c4c4:	0880                	addi	s0,sp,80
    8001c4c6:	fca43423          	sd	a0,-56(s0)
    8001c4ca:	fcb43023          	sd	a1,-64(s0)
    8001c4ce:	fac43c23          	sd	a2,-72(s0)
    debugf("Writing sector %d\n", sector);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_OUT;
    8001c4d2:	4785                	li	a5,1
    8001c4d4:	fcf42823          	sw	a5,-48(s0)
    packet.sector = sector;
    8001c4d8:	fc043783          	ld	a5,-64(s0)
    8001c4dc:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001c4e0:	fb843783          	ld	a5,-72(s0)
    8001c4e4:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    8001c4e8:	4785                	li	a5,1
    8001c4ea:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001c4ee:	47bd                	li	a5,15
    8001c4f0:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001c4f4:	fd040793          	addi	a5,s0,-48
    8001c4f8:	85be                	mv	a1,a5
    8001c4fa:	fc843503          	ld	a0,-56(s0)
    8001c4fe:	e21ff0ef          	jal	ra,8001c31e <block_device_send_request>
}
    8001c502:	0001                	nop
    8001c504:	60a6                	ld	ra,72(sp)
    8001c506:	6406                	ld	s0,64(sp)
    8001c508:	6161                	addi	sp,sp,80
    8001c50a:	8082                	ret

000000008001c50c <block_device_read_sectors>:

void block_device_read_sectors(VirtioDevice *block_device, uint64_t sector, uint8_t *data, uint64_t count) {
    8001c50c:	715d                	addi	sp,sp,-80
    8001c50e:	e486                	sd	ra,72(sp)
    8001c510:	e0a2                	sd	s0,64(sp)
    8001c512:	0880                	addi	s0,sp,80
    8001c514:	fca43423          	sd	a0,-56(s0)
    8001c518:	fcb43023          	sd	a1,-64(s0)
    8001c51c:	fac43c23          	sd	a2,-72(s0)
    8001c520:	fad43823          	sd	a3,-80(s0)
    debugf("Read sectors %d-%d\n", sector, sector + count);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_IN;
    8001c524:	fc042823          	sw	zero,-48(s0)
    packet.sector = sector;
    8001c528:	fc043783          	ld	a5,-64(s0)
    8001c52c:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001c530:	fb843783          	ld	a5,-72(s0)
    8001c534:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = count;
    8001c538:	fb043783          	ld	a5,-80(s0)
    8001c53c:	0ff7f793          	andi	a5,a5,255
    8001c540:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001c544:	47bd                	li	a5,15
    8001c546:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001c54a:	fd040793          	addi	a5,s0,-48
    8001c54e:	85be                	mv	a1,a5
    8001c550:	fc843503          	ld	a0,-56(s0)
    8001c554:	dcbff0ef          	jal	ra,8001c31e <block_device_send_request>
}
    8001c558:	0001                	nop
    8001c55a:	60a6                	ld	ra,72(sp)
    8001c55c:	6406                	ld	s0,64(sp)
    8001c55e:	6161                	addi	sp,sp,80
    8001c560:	8082                	ret

000000008001c562 <block_device_write_sectors>:

void block_device_write_sectors(VirtioDevice *block_device, uint64_t sector, uint8_t *data, uint64_t count) {
    8001c562:	715d                	addi	sp,sp,-80
    8001c564:	e486                	sd	ra,72(sp)
    8001c566:	e0a2                	sd	s0,64(sp)
    8001c568:	0880                	addi	s0,sp,80
    8001c56a:	fca43423          	sd	a0,-56(s0)
    8001c56e:	fcb43023          	sd	a1,-64(s0)
    8001c572:	fac43c23          	sd	a2,-72(s0)
    8001c576:	fad43823          	sd	a3,-80(s0)
    debugf("Writing sectors %d-%d\n", sector, sector + count);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_OUT;
    8001c57a:	4785                	li	a5,1
    8001c57c:	fcf42823          	sw	a5,-48(s0)
    packet.sector = sector;
    8001c580:	fc043783          	ld	a5,-64(s0)
    8001c584:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001c588:	fb843783          	ld	a5,-72(s0)
    8001c58c:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = count;
    8001c590:	fb043783          	ld	a5,-80(s0)
    8001c594:	0ff7f793          	andi	a5,a5,255
    8001c598:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001c59c:	47bd                	li	a5,15
    8001c59e:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001c5a2:	fd040793          	addi	a5,s0,-48
    8001c5a6:	85be                	mv	a1,a5
    8001c5a8:	fc843503          	ld	a0,-56(s0)
    8001c5ac:	d73ff0ef          	jal	ra,8001c31e <block_device_send_request>
}
    8001c5b0:	0001                	nop
    8001c5b2:	60a6                	ld	ra,72(sp)
    8001c5b4:	6406                	ld	s0,64(sp)
    8001c5b6:	6161                	addi	sp,sp,80
    8001c5b8:	8082                	ret

000000008001c5ba <block_device_read_bytes>:


void block_device_read_bytes(VirtioDevice *block_device, uint64_t byte, uint8_t *data, uint64_t bytes) {
    8001c5ba:	7159                	addi	sp,sp,-112
    8001c5bc:	f486                	sd	ra,104(sp)
    8001c5be:	f0a2                	sd	s0,96(sp)
    8001c5c0:	eca6                	sd	s1,88(sp)
    8001c5c2:	1880                	addi	s0,sp,112
    8001c5c4:	faa43423          	sd	a0,-88(s0)
    8001c5c8:	fab43023          	sd	a1,-96(s0)
    8001c5cc:	f8c43c23          	sd	a2,-104(s0)
    8001c5d0:	f8d43823          	sd	a3,-112(s0)
    8001c5d4:	868a                	mv	a3,sp
    8001c5d6:	84b6                	mv	s1,a3
    debugf("block_device_read_bytes(%d, %p, %d)\n", byte, data, bytes);
    uint64_t sectors = ALIGN_UP_POT(bytes, 512) / 512;
    8001c5d8:	f9043683          	ld	a3,-112(s0)
    8001c5dc:	1ff68693          	addi	a3,a3,511
    8001c5e0:	82a5                	srli	a3,a3,0x9
    8001c5e2:	fcd43823          	sd	a3,-48(s0)
    uint64_t sector = byte / 512;
    8001c5e6:	fa043683          	ld	a3,-96(s0)
    8001c5ea:	82a5                	srli	a3,a3,0x9
    8001c5ec:	fcd43423          	sd	a3,-56(s0)
    uint8_t buffer[sectors][512];
    8001c5f0:	fd043683          	ld	a3,-48(s0)
    8001c5f4:	8636                	mv	a2,a3
    8001c5f6:	167d                	addi	a2,a2,-1
    8001c5f8:	fcc43023          	sd	a2,-64(s0)
    8001c5fc:	8e36                	mv	t3,a3
    8001c5fe:	4e81                	li	t4,0
    8001c600:	034e5613          	srli	a2,t3,0x34
    8001c604:	00ce9893          	slli	a7,t4,0xc
    8001c608:	011668b3          	or	a7,a2,a7
    8001c60c:	00ce1813          	slli	a6,t3,0xc
    8001c610:	8336                	mv	t1,a3
    8001c612:	4381                	li	t2,0
    8001c614:	03435613          	srli	a2,t1,0x34
    8001c618:	00c39793          	slli	a5,t2,0xc
    8001c61c:	8fd1                	or	a5,a5,a2
    8001c61e:	00c31713          	slli	a4,t1,0xc
    8001c622:	00969793          	slli	a5,a3,0x9
    8001c626:	07bd                	addi	a5,a5,15
    8001c628:	8391                	srli	a5,a5,0x4
    8001c62a:	0792                	slli	a5,a5,0x4
    8001c62c:	40f10133          	sub	sp,sp,a5
    8001c630:	878a                	mv	a5,sp
    8001c632:	00078793          	mv	a5,a5
    8001c636:	faf43c23          	sd	a5,-72(s0)
    
    block_device_read_sectors(block_device, sector, (uint8_t *)buffer, sectors);
    8001c63a:	fd043683          	ld	a3,-48(s0)
    8001c63e:	fb843603          	ld	a2,-72(s0)
    8001c642:	fc843583          	ld	a1,-56(s0)
    8001c646:	fa843503          	ld	a0,-88(s0)
    8001c64a:	ec3ff0ef          	jal	ra,8001c50c <block_device_read_sectors>

    uint64_t alignment_offset = byte % 512;
    8001c64e:	fa043783          	ld	a5,-96(s0)
    8001c652:	1ff7f793          	andi	a5,a5,511
    8001c656:	faf43823          	sd	a5,-80(s0)

    // Copy the data with the correct offset
    for (uint64_t i = 0; i < bytes; i++) {
    8001c65a:	fc043c23          	sd	zero,-40(s0)
    8001c65e:	a83d                	j	8001c69c <block_device_read_bytes+0xe2>
        data[i] = buffer[i / 512][(alignment_offset + i) % 512];
    8001c660:	fd843783          	ld	a5,-40(s0)
    8001c664:	0097d693          	srli	a3,a5,0x9
    8001c668:	fb043703          	ld	a4,-80(s0)
    8001c66c:	fd843783          	ld	a5,-40(s0)
    8001c670:	97ba                	add	a5,a5,a4
    8001c672:	1ff7f713          	andi	a4,a5,511
    8001c676:	f9843603          	ld	a2,-104(s0)
    8001c67a:	fd843783          	ld	a5,-40(s0)
    8001c67e:	97b2                	add	a5,a5,a2
    8001c680:	fb843603          	ld	a2,-72(s0)
    8001c684:	06a6                	slli	a3,a3,0x9
    8001c686:	96b2                	add	a3,a3,a2
    8001c688:	9736                	add	a4,a4,a3
    8001c68a:	00074703          	lbu	a4,0(a4)
    8001c68e:	00e78023          	sb	a4,0(a5)
    for (uint64_t i = 0; i < bytes; i++) {
    8001c692:	fd843783          	ld	a5,-40(s0)
    8001c696:	0785                	addi	a5,a5,1
    8001c698:	fcf43c23          	sd	a5,-40(s0)
    8001c69c:	fd843703          	ld	a4,-40(s0)
    8001c6a0:	f9043783          	ld	a5,-112(s0)
    8001c6a4:	faf76ee3          	bltu	a4,a5,8001c660 <block_device_read_bytes+0xa6>
    8001c6a8:	8126                	mv	sp,s1
    }
}
    8001c6aa:	0001                	nop
    8001c6ac:	f9040113          	addi	sp,s0,-112
    8001c6b0:	70a6                	ld	ra,104(sp)
    8001c6b2:	7406                	ld	s0,96(sp)
    8001c6b4:	64e6                	ld	s1,88(sp)
    8001c6b6:	6165                	addi	sp,sp,112
    8001c6b8:	8082                	ret

000000008001c6ba <block_device_write_bytes>:


void block_device_write_bytes(VirtioDevice *block_device, uint64_t byte, uint8_t *data, uint64_t bytes) {
    8001c6ba:	7159                	addi	sp,sp,-112
    8001c6bc:	f486                	sd	ra,104(sp)
    8001c6be:	f0a2                	sd	s0,96(sp)
    8001c6c0:	eca6                	sd	s1,88(sp)
    8001c6c2:	1880                	addi	s0,sp,112
    8001c6c4:	faa43423          	sd	a0,-88(s0)
    8001c6c8:	fab43023          	sd	a1,-96(s0)
    8001c6cc:	f8c43c23          	sd	a2,-104(s0)
    8001c6d0:	f8d43823          	sd	a3,-112(s0)
    8001c6d4:	868a                	mv	a3,sp
    8001c6d6:	84b6                	mv	s1,a3
    debugf("block_device_write_bytes(%d, %p, %d)\n", byte, data, bytes);
    uint64_t sectors = ALIGN_UP_POT(bytes, 512) / 512;
    8001c6d8:	f9043683          	ld	a3,-112(s0)
    8001c6dc:	1ff68693          	addi	a3,a3,511
    8001c6e0:	82a5                	srli	a3,a3,0x9
    8001c6e2:	fcd43823          	sd	a3,-48(s0)
    uint64_t sector = byte / 512;
    8001c6e6:	fa043683          	ld	a3,-96(s0)
    8001c6ea:	82a5                	srli	a3,a3,0x9
    8001c6ec:	fcd43423          	sd	a3,-56(s0)
    uint8_t buffer[sectors][512];
    8001c6f0:	fd043683          	ld	a3,-48(s0)
    8001c6f4:	8636                	mv	a2,a3
    8001c6f6:	167d                	addi	a2,a2,-1
    8001c6f8:	fcc43023          	sd	a2,-64(s0)
    8001c6fc:	8e36                	mv	t3,a3
    8001c6fe:	4e81                	li	t4,0
    8001c700:	034e5613          	srli	a2,t3,0x34
    8001c704:	00ce9893          	slli	a7,t4,0xc
    8001c708:	011668b3          	or	a7,a2,a7
    8001c70c:	00ce1813          	slli	a6,t3,0xc
    8001c710:	8336                	mv	t1,a3
    8001c712:	4381                	li	t2,0
    8001c714:	03435613          	srli	a2,t1,0x34
    8001c718:	00c39793          	slli	a5,t2,0xc
    8001c71c:	8fd1                	or	a5,a5,a2
    8001c71e:	00c31713          	slli	a4,t1,0xc
    8001c722:	00969793          	slli	a5,a3,0x9
    8001c726:	07bd                	addi	a5,a5,15
    8001c728:	8391                	srli	a5,a5,0x4
    8001c72a:	0792                	slli	a5,a5,0x4
    8001c72c:	40f10133          	sub	sp,sp,a5
    8001c730:	878a                	mv	a5,sp
    8001c732:	00078793          	mv	a5,a5
    8001c736:	faf43c23          	sd	a5,-72(s0)

    uint64_t alignment_offset = byte % 512;
    8001c73a:	fa043783          	ld	a5,-96(s0)
    8001c73e:	1ff7f793          	andi	a5,a5,511
    8001c742:	faf43823          	sd	a5,-80(s0)
    block_device_read_sectors(block_device, sector, (uint8_t *)buffer, sectors);
    8001c746:	fd043683          	ld	a3,-48(s0)
    8001c74a:	fb843603          	ld	a2,-72(s0)
    8001c74e:	fc843583          	ld	a1,-56(s0)
    8001c752:	fa843503          	ld	a0,-88(s0)
    8001c756:	db7ff0ef          	jal	ra,8001c50c <block_device_read_sectors>
    // Copy the data with the correct offset
    for (uint64_t i = 0; i < bytes; i++) {
    8001c75a:	fc043c23          	sd	zero,-40(s0)
    8001c75e:	a83d                	j	8001c79c <block_device_write_bytes+0xe2>
        buffer[i / 512][(alignment_offset + i) % 512] = data[i];
    8001c760:	f9843703          	ld	a4,-104(s0)
    8001c764:	fd843783          	ld	a5,-40(s0)
    8001c768:	973e                	add	a4,a4,a5
    8001c76a:	fd843783          	ld	a5,-40(s0)
    8001c76e:	0097d693          	srli	a3,a5,0x9
    8001c772:	fb043603          	ld	a2,-80(s0)
    8001c776:	fd843783          	ld	a5,-40(s0)
    8001c77a:	97b2                	add	a5,a5,a2
    8001c77c:	1ff7f793          	andi	a5,a5,511
    8001c780:	00074703          	lbu	a4,0(a4)
    8001c784:	fb843603          	ld	a2,-72(s0)
    8001c788:	06a6                	slli	a3,a3,0x9
    8001c78a:	96b2                	add	a3,a3,a2
    8001c78c:	97b6                	add	a5,a5,a3
    8001c78e:	00e78023          	sb	a4,0(a5)
    for (uint64_t i = 0; i < bytes; i++) {
    8001c792:	fd843783          	ld	a5,-40(s0)
    8001c796:	0785                	addi	a5,a5,1
    8001c798:	fcf43c23          	sd	a5,-40(s0)
    8001c79c:	fd843703          	ld	a4,-40(s0)
    8001c7a0:	f9043783          	ld	a5,-112(s0)
    8001c7a4:	faf76ee3          	bltu	a4,a5,8001c760 <block_device_write_bytes+0xa6>
    }

    block_device_write_sectors(block_device, sector, (uint8_t *)buffer, sectors);
    8001c7a8:	fd043683          	ld	a3,-48(s0)
    8001c7ac:	fb843603          	ld	a2,-72(s0)
    8001c7b0:	fc843583          	ld	a1,-56(s0)
    8001c7b4:	fa843503          	ld	a0,-88(s0)
    8001c7b8:	dabff0ef          	jal	ra,8001c562 <block_device_write_sectors>
    8001c7bc:	8126                	mv	sp,s1
}
    8001c7be:	0001                	nop
    8001c7c0:	f9040113          	addi	sp,s0,-112
    8001c7c4:	70a6                	ld	ra,104(sp)
    8001c7c6:	7406                	ld	s0,96(sp)
    8001c7c8:	64e6                	ld	s1,88(sp)
    8001c7ca:	6165                	addi	sp,sp,112
    8001c7cc:	8082                	ret

000000008001c7ce <debug_file>:
#define debugf(...) debugf(__VA_ARGS__)
#else
#define debugf(...)
#endif

void debug_file(File *file) {
    8001c7ce:	1101                	addi	sp,sp,-32
    8001c7d0:	ec22                	sd	s0,24(sp)
    8001c7d2:	1000                	addi	s0,sp,32
    8001c7d4:	fea43423          	sd	a0,-24(s0)
    debugf("    type: %x\n", file->type);
    debugf("    is_file: %u\n", file->is_file);
    debugf("    is_dir: %u\n", file->is_dir);
    debugf("    is_block_device: %u\n", file->is_block_device);
    debugf("}\n");
}
    8001c7d8:	0001                	nop
    8001c7da:	6462                	ld	s0,24(sp)
    8001c7dc:	6105                	addi	sp,sp,32
    8001c7de:	8082                	ret

000000008001c7e0 <vfs_read>:

int vfs_read(File *file, void *buf, int count) {
    8001c7e0:	7179                	addi	sp,sp,-48
    8001c7e2:	f406                	sd	ra,40(sp)
    8001c7e4:	f022                	sd	s0,32(sp)
    8001c7e6:	1800                	addi	s0,sp,48
    8001c7e8:	fea43423          	sd	a0,-24(s0)
    8001c7ec:	feb43023          	sd	a1,-32(s0)
    8001c7f0:	87b2                	mv	a5,a2
    8001c7f2:	fcf42e23          	sw	a5,-36(s0)
    if (file->offset + count > file->size) {
    8001c7f6:	fe843783          	ld	a5,-24(s0)
    8001c7fa:	6bb8                	ld	a4,80(a5)
    8001c7fc:	fdc42783          	lw	a5,-36(s0)
    8001c800:	97ba                	add	a5,a5,a4
    8001c802:	873e                	mv	a4,a5
    8001c804:	fe843783          	ld	a5,-24(s0)
    8001c808:	73bc                	ld	a5,96(a5)
    8001c80a:	02e7f063          	bgeu	a5,a4,8001c82a <vfs_read+0x4a>
        count = file->size - file->offset;
    8001c80e:	fe843783          	ld	a5,-24(s0)
    8001c812:	73bc                	ld	a5,96(a5)
    8001c814:	0007871b          	sext.w	a4,a5
    8001c818:	fe843783          	ld	a5,-24(s0)
    8001c81c:	6bbc                	ld	a5,80(a5)
    8001c81e:	2781                	sext.w	a5,a5
    8001c820:	40f707bb          	subw	a5,a4,a5
    8001c824:	2781                	sext.w	a5,a5
    8001c826:	fcf42e23          	sw	a5,-36(s0)
    }

    switch (file->type) {
    8001c82a:	fe843783          	ld	a5,-24(s0)
    8001c82e:	0087d783          	lhu	a5,8(a5)
    8001c832:	2781                	sext.w	a5,a5
    8001c834:	86be                	mv	a3,a5
    8001c836:	4741                	li	a4,16
    8001c838:	04e68c63          	beq	a3,a4,8001c890 <vfs_read+0xb0>
    8001c83c:	86be                	mv	a3,a5
    8001c83e:	4741                	li	a4,16
    8001c840:	08d74563          	blt	a4,a3,8001c8ca <vfs_read+0xea>
    8001c844:	86be                	mv	a3,a5
    8001c846:	4705                	li	a4,1
    8001c848:	00e68763          	beq	a3,a4,8001c856 <vfs_read+0x76>
    8001c84c:	873e                	mv	a4,a5
    8001c84e:	4789                	li	a5,2
    8001c850:	06f70b63          	beq	a4,a5,8001c8c6 <vfs_read+0xe6>
    8001c854:	a89d                	j	8001c8ca <vfs_read+0xea>
    case VFS_TYPE_FILE:
        minix3_get_data(file->dev, file->inode, buf, file->offset, count);
    8001c856:	fe843783          	ld	a5,-24(s0)
    8001c85a:	6388                	ld	a0,0(a5)
    8001c85c:	fe843783          	ld	a5,-24(s0)
    8001c860:	47ec                	lw	a1,76(a5)
    8001c862:	fe843783          	ld	a5,-24(s0)
    8001c866:	6bbc                	ld	a5,80(a5)
    8001c868:	2781                	sext.w	a5,a5
    8001c86a:	fdc42703          	lw	a4,-36(s0)
    8001c86e:	86be                	mv	a3,a5
    8001c870:	fe043603          	ld	a2,-32(s0)
    8001c874:	a2df80ef          	jal	ra,800152a0 <minix3_get_data>
        file->offset += count;
    8001c878:	fe843783          	ld	a5,-24(s0)
    8001c87c:	6bb8                	ld	a4,80(a5)
    8001c87e:	fdc42783          	lw	a5,-36(s0)
    8001c882:	973e                	add	a4,a4,a5
    8001c884:	fe843783          	ld	a5,-24(s0)
    8001c888:	ebb8                	sd	a4,80(a5)
        return count;
    8001c88a:	fdc42783          	lw	a5,-36(s0)
    8001c88e:	a83d                	j	8001c8cc <vfs_read+0xec>
    case VFS_TYPE_BLOCK:
        block_device_read_bytes(file->dev, file->offset, buf, (uint64_t)count);
    8001c890:	fe843783          	ld	a5,-24(s0)
    8001c894:	6398                	ld	a4,0(a5)
    8001c896:	fe843783          	ld	a5,-24(s0)
    8001c89a:	6bbc                	ld	a5,80(a5)
    8001c89c:	85be                	mv	a1,a5
    8001c89e:	fdc42783          	lw	a5,-36(s0)
    8001c8a2:	86be                	mv	a3,a5
    8001c8a4:	fe043603          	ld	a2,-32(s0)
    8001c8a8:	853a                	mv	a0,a4
    8001c8aa:	d11ff0ef          	jal	ra,8001c5ba <block_device_read_bytes>
        file->offset += count;
    8001c8ae:	fe843783          	ld	a5,-24(s0)
    8001c8b2:	6bb8                	ld	a4,80(a5)
    8001c8b4:	fdc42783          	lw	a5,-36(s0)
    8001c8b8:	973e                	add	a4,a4,a5
    8001c8ba:	fe843783          	ld	a5,-24(s0)
    8001c8be:	ebb8                	sd	a4,80(a5)
        return count;
    8001c8c0:	fdc42783          	lw	a5,-36(s0)
    8001c8c4:	a021                	j	8001c8cc <vfs_read+0xec>
    case VFS_TYPE_DIR:
        debugf("vfs_read: reading from directory not supported\n");
        return -1;
    8001c8c6:	57fd                	li	a5,-1
    8001c8c8:	a011                	j	8001c8cc <vfs_read+0xec>
    default:
        debugf("vfs_read: unsupported file type %d\n", file->type);
        return -1;
    8001c8ca:	57fd                	li	a5,-1
    }
}
    8001c8cc:	853e                	mv	a0,a5
    8001c8ce:	70a2                	ld	ra,40(sp)
    8001c8d0:	7402                	ld	s0,32(sp)
    8001c8d2:	6145                	addi	sp,sp,48
    8001c8d4:	8082                	ret

000000008001c8d6 <vfs_write>:
int vfs_write(File *file, const char *buf, int count) {
    8001c8d6:	7179                	addi	sp,sp,-48
    8001c8d8:	f406                	sd	ra,40(sp)
    8001c8da:	f022                	sd	s0,32(sp)
    8001c8dc:	1800                	addi	s0,sp,48
    8001c8de:	fea43423          	sd	a0,-24(s0)
    8001c8e2:	feb43023          	sd	a1,-32(s0)
    8001c8e6:	87b2                	mv	a5,a2
    8001c8e8:	fcf42e23          	sw	a5,-36(s0)
    if (file->offset + count > file->size) {
    8001c8ec:	fe843783          	ld	a5,-24(s0)
    8001c8f0:	6bb8                	ld	a4,80(a5)
    8001c8f2:	fdc42783          	lw	a5,-36(s0)
    8001c8f6:	97ba                	add	a5,a5,a4
    8001c8f8:	873e                	mv	a4,a5
    8001c8fa:	fe843783          	ld	a5,-24(s0)
    8001c8fe:	73bc                	ld	a5,96(a5)
    8001c900:	02e7f063          	bgeu	a5,a4,8001c920 <vfs_write+0x4a>
        count = file->size - file->offset;
    8001c904:	fe843783          	ld	a5,-24(s0)
    8001c908:	73bc                	ld	a5,96(a5)
    8001c90a:	0007871b          	sext.w	a4,a5
    8001c90e:	fe843783          	ld	a5,-24(s0)
    8001c912:	6bbc                	ld	a5,80(a5)
    8001c914:	2781                	sext.w	a5,a5
    8001c916:	40f707bb          	subw	a5,a4,a5
    8001c91a:	2781                	sext.w	a5,a5
    8001c91c:	fcf42e23          	sw	a5,-36(s0)
    }

    switch (file->type) {
    8001c920:	fe843783          	ld	a5,-24(s0)
    8001c924:	0087d783          	lhu	a5,8(a5)
    8001c928:	2781                	sext.w	a5,a5
    8001c92a:	86be                	mv	a3,a5
    8001c92c:	4741                	li	a4,16
    8001c92e:	04e68c63          	beq	a3,a4,8001c986 <vfs_write+0xb0>
    8001c932:	86be                	mv	a3,a5
    8001c934:	4741                	li	a4,16
    8001c936:	08d74563          	blt	a4,a3,8001c9c0 <vfs_write+0xea>
    8001c93a:	86be                	mv	a3,a5
    8001c93c:	4705                	li	a4,1
    8001c93e:	00e68763          	beq	a3,a4,8001c94c <vfs_write+0x76>
    8001c942:	873e                	mv	a4,a5
    8001c944:	4789                	li	a5,2
    8001c946:	06f70b63          	beq	a4,a5,8001c9bc <vfs_write+0xe6>
    8001c94a:	a89d                	j	8001c9c0 <vfs_write+0xea>
    case VFS_TYPE_FILE:
        minix3_put_data(file->dev, file->inode, buf, file->offset, count);
    8001c94c:	fe843783          	ld	a5,-24(s0)
    8001c950:	6388                	ld	a0,0(a5)
    8001c952:	fe843783          	ld	a5,-24(s0)
    8001c956:	47ec                	lw	a1,76(a5)
    8001c958:	fe843783          	ld	a5,-24(s0)
    8001c95c:	6bbc                	ld	a5,80(a5)
    8001c95e:	2781                	sext.w	a5,a5
    8001c960:	fdc42703          	lw	a4,-36(s0)
    8001c964:	86be                	mv	a3,a5
    8001c966:	fe043603          	ld	a2,-32(s0)
    8001c96a:	f28f90ef          	jal	ra,80016092 <minix3_put_data>
        file->offset += count;
    8001c96e:	fe843783          	ld	a5,-24(s0)
    8001c972:	6bb8                	ld	a4,80(a5)
    8001c974:	fdc42783          	lw	a5,-36(s0)
    8001c978:	973e                	add	a4,a4,a5
    8001c97a:	fe843783          	ld	a5,-24(s0)
    8001c97e:	ebb8                	sd	a4,80(a5)
        return count;
    8001c980:	fdc42783          	lw	a5,-36(s0)
    8001c984:	a83d                	j	8001c9c2 <vfs_write+0xec>
    case VFS_TYPE_BLOCK:
        block_device_write_bytes(file->dev, file->offset, buf, (uint64_t)count);
    8001c986:	fe843783          	ld	a5,-24(s0)
    8001c98a:	6398                	ld	a4,0(a5)
    8001c98c:	fe843783          	ld	a5,-24(s0)
    8001c990:	6bbc                	ld	a5,80(a5)
    8001c992:	85be                	mv	a1,a5
    8001c994:	fdc42783          	lw	a5,-36(s0)
    8001c998:	86be                	mv	a3,a5
    8001c99a:	fe043603          	ld	a2,-32(s0)
    8001c99e:	853a                	mv	a0,a4
    8001c9a0:	d1bff0ef          	jal	ra,8001c6ba <block_device_write_bytes>
        file->offset += count;
    8001c9a4:	fe843783          	ld	a5,-24(s0)
    8001c9a8:	6bb8                	ld	a4,80(a5)
    8001c9aa:	fdc42783          	lw	a5,-36(s0)
    8001c9ae:	973e                	add	a4,a4,a5
    8001c9b0:	fe843783          	ld	a5,-24(s0)
    8001c9b4:	ebb8                	sd	a4,80(a5)
        return count;
    8001c9b6:	fdc42783          	lw	a5,-36(s0)
    8001c9ba:	a021                	j	8001c9c2 <vfs_write+0xec>
    case VFS_TYPE_DIR:
        debugf("vfs_write: writing to directory not supported\n");
        return -1;
    8001c9bc:	57fd                	li	a5,-1
    8001c9be:	a011                	j	8001c9c2 <vfs_write+0xec>
    default:
        debugf("vfs_write: unsupported file type %d\n", file->type);
        return -1;
    8001c9c0:	57fd                	li	a5,-1
    }
}
    8001c9c2:	853e                	mv	a0,a5
    8001c9c4:	70a2                	ld	ra,40(sp)
    8001c9c6:	7402                	ld	s0,32(sp)
    8001c9c8:	6145                	addi	sp,sp,48
    8001c9ca:	8082                	ret

000000008001c9cc <vfs_print_mounted_devices>:
// static Map *mapped_paths;

// // A map of inodes to file paths (absolute path strings)
// static Map *mapped_inodes;

void vfs_print_mounted_devices() {
    8001c9cc:	7139                	addi	sp,sp,-64
    8001c9ce:	fc06                	sd	ra,56(sp)
    8001c9d0:	f822                	sd	s0,48(sp)
    8001c9d2:	f426                	sd	s1,40(sp)
    8001c9d4:	0080                	addi	s0,sp,64
    if (mounted_devices == NULL) {
    8001c9d6:	00007797          	auipc	a5,0x7
    8001c9da:	be278793          	addi	a5,a5,-1054 # 800235b8 <mounted_devices>
    8001c9de:	639c                	ld	a5,0(a5)
    8001c9e0:	eb89                	bnez	a5,8001c9f2 <vfs_print_mounted_devices+0x26>
        mounted_devices = map_new();
    8001c9e2:	054020ef          	jal	ra,8001ea36 <map_new>
    8001c9e6:	872a                	mv	a4,a0
    8001c9e8:	00007797          	auipc	a5,0x7
    8001c9ec:	bd078793          	addi	a5,a5,-1072 # 800235b8 <mounted_devices>
    8001c9f0:	e398                	sd	a4,0(a5)
    }

    List *keys = map_get_keys(mounted_devices);
    8001c9f2:	00007797          	auipc	a5,0x7
    8001c9f6:	bc678793          	addi	a5,a5,-1082 # 800235b8 <mounted_devices>
    8001c9fa:	639c                	ld	a5,0(a5)
    8001c9fc:	853e                	mv	a0,a5
    8001c9fe:	494020ef          	jal	ra,8001ee92 <map_get_keys>
    8001ca02:	fca43423          	sd	a0,-56(s0)
    list_sort(keys, list_sort_string_comparator_ascending);
    8001ca06:	00002597          	auipc	a1,0x2
    8001ca0a:	b0058593          	addi	a1,a1,-1280 # 8001e506 <list_sort_string_comparator_ascending>
    8001ca0e:	fc843503          	ld	a0,-56(s0)
    8001ca12:	5fa010ef          	jal	ra,8001e00c <list_sort>
    ListElem *key = NULL;
    8001ca16:	fc043c23          	sd	zero,-40(s0)
    size_t count = 0;
    8001ca1a:	fc043823          	sd	zero,-48(s0)
    infof("Printing mounted drives:\n");
    8001ca1e:	00009517          	auipc	a0,0x9
    8001ca22:	45a50513          	addi	a0,a0,1114 # 80025e78 <pow10.0+0x1c48>
    8001ca26:	889fc0ef          	jal	ra,800192ae <infof>
    list_for_each(keys, key) {
    8001ca2a:	fc843503          	ld	a0,-56(s0)
    8001ca2e:	159010ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001ca32:	fca43c23          	sd	a0,-40(s0)
    8001ca36:	a8a1                	j	8001ca8e <vfs_print_mounted_devices+0xc2>
        VirtioDevice *block_device;
        map_get(mounted_devices, list_elem_value(key), &block_device);
    8001ca38:	00007797          	auipc	a5,0x7
    8001ca3c:	b8078793          	addi	a5,a5,-1152 # 800235b8 <mounted_devices>
    8001ca40:	6384                	ld	s1,0(a5)
    8001ca42:	fd843503          	ld	a0,-40(s0)
    8001ca46:	1a1010ef          	jal	ra,8001e3e6 <list_elem_value>
    8001ca4a:	87aa                	mv	a5,a0
    8001ca4c:	873e                	mv	a4,a5
    8001ca4e:	fc040793          	addi	a5,s0,-64
    8001ca52:	863e                	mv	a2,a5
    8001ca54:	85ba                	mv	a1,a4
    8001ca56:	8526                	mv	a0,s1
    8001ca58:	126020ef          	jal	ra,8001eb7e <map_get>
        infof("    %s at disk #%u\n", list_elem_value(key), count);
    8001ca5c:	fd843503          	ld	a0,-40(s0)
    8001ca60:	187010ef          	jal	ra,8001e3e6 <list_elem_value>
    8001ca64:	87aa                	mv	a5,a0
    8001ca66:	fd043603          	ld	a2,-48(s0)
    8001ca6a:	85be                	mv	a1,a5
    8001ca6c:	00009517          	auipc	a0,0x9
    8001ca70:	42c50513          	addi	a0,a0,1068 # 80025e98 <pow10.0+0x1c68>
    8001ca74:	83bfc0ef          	jal	ra,800192ae <infof>
        count++;
    8001ca78:	fd043783          	ld	a5,-48(s0)
    8001ca7c:	0785                	addi	a5,a5,1
    8001ca7e:	fcf43823          	sd	a5,-48(s0)
    list_for_each(keys, key) {
    8001ca82:	fd843503          	ld	a0,-40(s0)
    8001ca86:	149010ef          	jal	ra,8001e3ce <list_elem_prev>
    8001ca8a:	fca43c23          	sd	a0,-40(s0)
    8001ca8e:	fd843583          	ld	a1,-40(s0)
    8001ca92:	fc843503          	ld	a0,-56(s0)
    8001ca96:	063010ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001ca9a:	87aa                	mv	a5,a0
    8001ca9c:	ffd1                	bnez	a5,8001ca38 <vfs_print_mounted_devices+0x6c>
    }
    map_free_get_keys(keys);
    8001ca9e:	fc843503          	ld	a0,-56(s0)
    8001caa2:	496020ef          	jal	ra,8001ef38 <map_free_get_keys>

    if (count == 0) {
    8001caa6:	fd043783          	ld	a5,-48(s0)
    8001caaa:	eb81                	bnez	a5,8001caba <vfs_print_mounted_devices+0xee>
        warnf("There are no mounted devices\n");
    8001caac:	00009517          	auipc	a0,0x9
    8001cab0:	40450513          	addi	a0,a0,1028 # 80025eb0 <pow10.0+0x1c80>
    8001cab4:	f4cfc0ef          	jal	ra,80019200 <warnf>
    } else {
        infof("There are %u mounted drives\n", count);
    }
}
    8001cab8:	a809                	j	8001caca <vfs_print_mounted_devices+0xfe>
        infof("There are %u mounted drives\n", count);
    8001caba:	fd043583          	ld	a1,-48(s0)
    8001cabe:	00009517          	auipc	a0,0x9
    8001cac2:	41250513          	addi	a0,a0,1042 # 80025ed0 <pow10.0+0x1ca0>
    8001cac6:	fe8fc0ef          	jal	ra,800192ae <infof>
}
    8001caca:	0001                	nop
    8001cacc:	70e2                	ld	ra,56(sp)
    8001cace:	7442                	ld	s0,48(sp)
    8001cad0:	74a2                	ld	s1,40(sp)
    8001cad2:	6121                	addi	sp,sp,64
    8001cad4:	8082                	ret

000000008001cad6 <vfs_path_from_mounted_device>:

const char *vfs_path_from_mounted_device(VirtioDevice *mounted_device) {
    8001cad6:	711d                	addi	sp,sp,-96
    8001cad8:	ec86                	sd	ra,88(sp)
    8001cada:	e8a2                	sd	s0,80(sp)
    8001cadc:	e4a6                	sd	s1,72(sp)
    8001cade:	1080                	addi	s0,sp,96
    8001cae0:	faa43423          	sd	a0,-88(s0)
    if (mounted_devices == NULL) {
    8001cae4:	00007797          	auipc	a5,0x7
    8001cae8:	ad478793          	addi	a5,a5,-1324 # 800235b8 <mounted_devices>
    8001caec:	639c                	ld	a5,0(a5)
    8001caee:	eb89                	bnez	a5,8001cb00 <vfs_path_from_mounted_device+0x2a>
        mounted_devices = map_new();
    8001caf0:	747010ef          	jal	ra,8001ea36 <map_new>
    8001caf4:	872a                	mv	a4,a0
    8001caf6:	00007797          	auipc	a5,0x7
    8001cafa:	ac278793          	addi	a5,a5,-1342 # 800235b8 <mounted_devices>
    8001cafe:	e398                	sd	a4,0(a5)
    }

    List *keys = map_get_keys(mounted_devices);
    8001cb00:	00007797          	auipc	a5,0x7
    8001cb04:	ab878793          	addi	a5,a5,-1352 # 800235b8 <mounted_devices>
    8001cb08:	639c                	ld	a5,0(a5)
    8001cb0a:	853e                	mv	a0,a5
    8001cb0c:	386020ef          	jal	ra,8001ee92 <map_get_keys>
    8001cb10:	fca43023          	sd	a0,-64(s0)
    list_sort(keys, list_sort_string_comparator_ascending);
    8001cb14:	00002597          	auipc	a1,0x2
    8001cb18:	9f258593          	addi	a1,a1,-1550 # 8001e506 <list_sort_string_comparator_ascending>
    8001cb1c:	fc043503          	ld	a0,-64(s0)
    8001cb20:	4ec010ef          	jal	ra,8001e00c <list_sort>
    ListElem *key = NULL;
    8001cb24:	fc043c23          	sd	zero,-40(s0)
    size_t count = 1;
    8001cb28:	4785                	li	a5,1
    8001cb2a:	fcf43823          	sd	a5,-48(s0)

    VirtioDevice *result;
    list_for_each(keys, key) {
    8001cb2e:	fc043503          	ld	a0,-64(s0)
    8001cb32:	055010ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001cb36:	fca43c23          	sd	a0,-40(s0)
    8001cb3a:	a899                	j	8001cb90 <vfs_path_from_mounted_device+0xba>
        VirtioDevice *block_device;
        map_get(mounted_devices, list_elem_value(key), &block_device);
    8001cb3c:	00007797          	auipc	a5,0x7
    8001cb40:	a7c78793          	addi	a5,a5,-1412 # 800235b8 <mounted_devices>
    8001cb44:	6384                	ld	s1,0(a5)
    8001cb46:	fd843503          	ld	a0,-40(s0)
    8001cb4a:	09d010ef          	jal	ra,8001e3e6 <list_elem_value>
    8001cb4e:	87aa                	mv	a5,a0
    8001cb50:	873e                	mv	a4,a5
    8001cb52:	fb840793          	addi	a5,s0,-72
    8001cb56:	863e                	mv	a2,a5
    8001cb58:	85ba                	mv	a1,a4
    8001cb5a:	8526                	mv	a0,s1
    8001cb5c:	022020ef          	jal	ra,8001eb7e <map_get>
        if (block_device == mounted_device) {
    8001cb60:	fb843783          	ld	a5,-72(s0)
    8001cb64:	fa843703          	ld	a4,-88(s0)
    8001cb68:	00f71963          	bne	a4,a5,8001cb7a <vfs_path_from_mounted_device+0xa4>
            result = list_elem_value(key);
    8001cb6c:	fd843503          	ld	a0,-40(s0)
    8001cb70:	077010ef          	jal	ra,8001e3e6 <list_elem_value>
    8001cb74:	87aa                	mv	a5,a0
    8001cb76:	fcf43423          	sd	a5,-56(s0)
        }
        count++;
    8001cb7a:	fd043783          	ld	a5,-48(s0)
    8001cb7e:	0785                	addi	a5,a5,1
    8001cb80:	fcf43823          	sd	a5,-48(s0)
    list_for_each(keys, key) {
    8001cb84:	fd843503          	ld	a0,-40(s0)
    8001cb88:	047010ef          	jal	ra,8001e3ce <list_elem_prev>
    8001cb8c:	fca43c23          	sd	a0,-40(s0)
    8001cb90:	fd843583          	ld	a1,-40(s0)
    8001cb94:	fc043503          	ld	a0,-64(s0)
    8001cb98:	760010ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001cb9c:	87aa                	mv	a5,a0
    8001cb9e:	ffd9                	bnez	a5,8001cb3c <vfs_path_from_mounted_device+0x66>
    }
    map_free_get_keys(keys);
    8001cba0:	fc043503          	ld	a0,-64(s0)
    8001cba4:	394020ef          	jal	ra,8001ef38 <map_free_get_keys>

    return result;
    8001cba8:	fc843783          	ld	a5,-56(s0)
}
    8001cbac:	853e                	mv	a0,a5
    8001cbae:	60e6                	ld	ra,88(sp)
    8001cbb0:	6446                	ld	s0,80(sp)
    8001cbb2:	64a6                	ld	s1,72(sp)
    8001cbb4:	6125                	addi	sp,sp,96
    8001cbb6:	8082                	ret

000000008001cbb8 <vfs_print_open_files>:

void vfs_print_open_files() {
    8001cbb8:	715d                	addi	sp,sp,-80
    8001cbba:	e486                	sd	ra,72(sp)
    8001cbbc:	e0a2                	sd	s0,64(sp)
    8001cbbe:	fc26                	sd	s1,56(sp)
    8001cbc0:	0880                	addi	s0,sp,80
    if (open_files == NULL) {
    8001cbc2:	00007797          	auipc	a5,0x7
    8001cbc6:	9e678793          	addi	a5,a5,-1562 # 800235a8 <open_files>
    8001cbca:	639c                	ld	a5,0(a5)
    8001cbcc:	eb89                	bnez	a5,8001cbde <vfs_print_open_files+0x26>
        open_files = map_new();
    8001cbce:	669010ef          	jal	ra,8001ea36 <map_new>
    8001cbd2:	872a                	mv	a4,a0
    8001cbd4:	00007797          	auipc	a5,0x7
    8001cbd8:	9d478793          	addi	a5,a5,-1580 # 800235a8 <open_files>
    8001cbdc:	e398                	sd	a4,0(a5)
    }

    infof("Printing open files:\n");
    8001cbde:	00009517          	auipc	a0,0x9
    8001cbe2:	31250513          	addi	a0,a0,786 # 80025ef0 <pow10.0+0x1cc0>
    8001cbe6:	ec8fc0ef          	jal	ra,800192ae <infof>
    List *keys = map_get_keys(open_files);
    8001cbea:	00007797          	auipc	a5,0x7
    8001cbee:	9be78793          	addi	a5,a5,-1602 # 800235a8 <open_files>
    8001cbf2:	639c                	ld	a5,0(a5)
    8001cbf4:	853e                	mv	a0,a5
    8001cbf6:	29c020ef          	jal	ra,8001ee92 <map_get_keys>
    8001cbfa:	fca43423          	sd	a0,-56(s0)
    ListElem *key = NULL;
    8001cbfe:	fc043c23          	sd	zero,-40(s0)
    size_t count = 0;
    8001cc02:	fc043823          	sd	zero,-48(s0)
    list_for_each(keys, key) {
    8001cc06:	fc843503          	ld	a0,-56(s0)
    8001cc0a:	77c010ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001cc0e:	fca43c23          	sd	a0,-40(s0)
    8001cc12:	a0a5                	j	8001cc7a <vfs_print_open_files+0xc2>
        File *file;
        map_get(open_files, list_elem_value(key), &file);
    8001cc14:	00007797          	auipc	a5,0x7
    8001cc18:	99478793          	addi	a5,a5,-1644 # 800235a8 <open_files>
    8001cc1c:	6384                	ld	s1,0(a5)
    8001cc1e:	fd843503          	ld	a0,-40(s0)
    8001cc22:	7c4010ef          	jal	ra,8001e3e6 <list_elem_value>
    8001cc26:	87aa                	mv	a5,a0
    8001cc28:	873e                	mv	a4,a5
    8001cc2a:	fb840793          	addi	a5,s0,-72
    8001cc2e:	863e                	mv	a2,a5
    8001cc30:	85ba                	mv	a1,a4
    8001cc32:	8526                	mv	a0,s1
    8001cc34:	74b010ef          	jal	ra,8001eb7e <map_get>
        const char *device_name = vfs_path_from_mounted_device(file->dev);
    8001cc38:	fb843783          	ld	a5,-72(s0)
    8001cc3c:	639c                	ld	a5,0(a5)
    8001cc3e:	853e                	mv	a0,a5
    8001cc40:	e97ff0ef          	jal	ra,8001cad6 <vfs_path_from_mounted_device>
    8001cc44:	fca43023          	sd	a0,-64(s0)
        infof("   %s on device %s\n", list_elem_value(key), device_name);
    8001cc48:	fd843503          	ld	a0,-40(s0)
    8001cc4c:	79a010ef          	jal	ra,8001e3e6 <list_elem_value>
    8001cc50:	87aa                	mv	a5,a0
    8001cc52:	fc043603          	ld	a2,-64(s0)
    8001cc56:	85be                	mv	a1,a5
    8001cc58:	00009517          	auipc	a0,0x9
    8001cc5c:	2b050513          	addi	a0,a0,688 # 80025f08 <pow10.0+0x1cd8>
    8001cc60:	e4efc0ef          	jal	ra,800192ae <infof>
        count++;
    8001cc64:	fd043783          	ld	a5,-48(s0)
    8001cc68:	0785                	addi	a5,a5,1
    8001cc6a:	fcf43823          	sd	a5,-48(s0)
    list_for_each(keys, key) {
    8001cc6e:	fd843503          	ld	a0,-40(s0)
    8001cc72:	75c010ef          	jal	ra,8001e3ce <list_elem_prev>
    8001cc76:	fca43c23          	sd	a0,-40(s0)
    8001cc7a:	fd843583          	ld	a1,-40(s0)
    8001cc7e:	fc843503          	ld	a0,-56(s0)
    8001cc82:	676010ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001cc86:	87aa                	mv	a5,a0
    8001cc88:	f7d1                	bnez	a5,8001cc14 <vfs_print_open_files+0x5c>
    }
    map_free_get_keys(keys);
    8001cc8a:	fc843503          	ld	a0,-56(s0)
    8001cc8e:	2aa020ef          	jal	ra,8001ef38 <map_free_get_keys>

    if (count == 0) {
    8001cc92:	fd043783          	ld	a5,-48(s0)
    8001cc96:	eb81                	bnez	a5,8001cca6 <vfs_print_open_files+0xee>
        infof("There are no open files\n");
    8001cc98:	00009517          	auipc	a0,0x9
    8001cc9c:	28850513          	addi	a0,a0,648 # 80025f20 <pow10.0+0x1cf0>
    8001cca0:	e0efc0ef          	jal	ra,800192ae <infof>
    } else {
        infof("There are %u open files\n", count);
    }
}
    8001cca4:	a809                	j	8001ccb6 <vfs_print_open_files+0xfe>
        infof("There are %u open files\n", count);
    8001cca6:	fd043583          	ld	a1,-48(s0)
    8001ccaa:	00009517          	auipc	a0,0x9
    8001ccae:	29650513          	addi	a0,a0,662 # 80025f40 <pow10.0+0x1d10>
    8001ccb2:	dfcfc0ef          	jal	ra,800192ae <infof>
}
    8001ccb6:	0001                	nop
    8001ccb8:	60a6                	ld	ra,72(sp)
    8001ccba:	6406                	ld	s0,64(sp)
    8001ccbc:	74e2                	ld	s1,56(sp)
    8001ccbe:	6161                	addi	sp,sp,80
    8001ccc0:	8082                	ret

000000008001ccc2 <vfs_mount_callback>:

void vfs_mount_callback(VirtioDevice *block_device, uint32_t inode, const char *path, char *name, void *data, uint32_t depth) {
    8001ccc2:	7119                	addi	sp,sp,-128
    8001ccc4:	fc86                	sd	ra,120(sp)
    8001ccc6:	f8a2                	sd	s0,112(sp)
    8001ccc8:	0100                	addi	s0,sp,128
    8001ccca:	faa43423          	sd	a0,-88(s0)
    8001ccce:	f8c43c23          	sd	a2,-104(s0)
    8001ccd2:	f8d43823          	sd	a3,-112(s0)
    8001ccd6:	f8e43423          	sd	a4,-120(s0)
    8001ccda:	873e                	mv	a4,a5
    8001ccdc:	87ae                	mv	a5,a1
    8001ccde:	faf42223          	sw	a5,-92(s0)
    8001cce2:	87ba                	mv	a5,a4
    8001cce4:	faf42023          	sw	a5,-96(s0)
    if (strcmp(path, "/") == 0) {
    8001cce8:	00009597          	auipc	a1,0x9
    8001ccec:	27858593          	addi	a1,a1,632 # 80025f60 <pow10.0+0x1d30>
    8001ccf0:	f9843503          	ld	a0,-104(s0)
    8001ccf4:	508030ef          	jal	ra,800201fc <strcmp>
    8001ccf8:	87aa                	mv	a5,a0
    8001ccfa:	c7a5                	beqz	a5,8001cd62 <vfs_mount_callback+0xa0>
        debugf("vfs_mount_callback: skipping /\n");
        return;
    }

    // Check if this is a block device that needs to be mounted
    Inode inode_data = minix3_get_inode(block_device, inode);
    8001ccfc:	fb040793          	addi	a5,s0,-80
    8001cd00:	fa442703          	lw	a4,-92(s0)
    8001cd04:	863a                	mv	a2,a4
    8001cd06:	fa843583          	ld	a1,-88(s0)
    8001cd0a:	853e                	mv	a0,a5
    8001cd0c:	8d2f80ef          	jal	ra,80014dde <minix3_get_inode>
    if (S_ISBLK(inode_data.mode)) {
    8001cd10:	fb045783          	lhu	a5,-80(s0)
    8001cd14:	0007871b          	sext.w	a4,a5
    8001cd18:	67bd                	lui	a5,0xf
    8001cd1a:	8ff9                	and	a5,a5,a4
    8001cd1c:	2781                	sext.w	a5,a5
    8001cd1e:	873e                	mv	a4,a5
    8001cd20:	6799                	lui	a5,0x6
    8001cd22:	04f71363          	bne	a4,a5,8001cd68 <vfs_mount_callback+0xa6>
        debugf("vfs_mount_callback: found block device %s\n", path);
        // Mount the block device
        block_device = virtio_get_block_device(mounted_device_count);
    8001cd26:	00007797          	auipc	a5,0x7
    8001cd2a:	88a78793          	addi	a5,a5,-1910 # 800235b0 <mounted_device_count>
    8001cd2e:	639c                	ld	a5,0(a5)
    8001cd30:	17c2                	slli	a5,a5,0x30
    8001cd32:	93c1                	srli	a5,a5,0x30
    8001cd34:	853e                	mv	a0,a5
    8001cd36:	a8bfd0ef          	jal	ra,8001a7c0 <virtio_get_block_device>
    8001cd3a:	faa43423          	sd	a0,-88(s0)
        if (block_device == NULL) {
    8001cd3e:	fa843783          	ld	a5,-88(s0)
    8001cd42:	c395                	beqz	a5,8001cd66 <vfs_mount_callback+0xa4>
            debugf("vfs_mount_callback: could not find block device %u\n", mounted_device_count);
            return;
        }
        infof("Mounting block device at %s\n", path);
    8001cd44:	f9843583          	ld	a1,-104(s0)
    8001cd48:	00009517          	auipc	a0,0x9
    8001cd4c:	22050513          	addi	a0,a0,544 # 80025f68 <pow10.0+0x1d38>
    8001cd50:	d5efc0ef          	jal	ra,800192ae <infof>
        vfs_mount(block_device, path);
    8001cd54:	f9843583          	ld	a1,-104(s0)
    8001cd58:	fa843503          	ld	a0,-88(s0)
    8001cd5c:	10e000ef          	jal	ra,8001ce6a <vfs_mount>
    8001cd60:	a021                	j	8001cd68 <vfs_mount_callback+0xa6>
        return;
    8001cd62:	0001                	nop
    8001cd64:	a011                	j	8001cd68 <vfs_mount_callback+0xa6>
            return;
    8001cd66:	0001                	nop
    }
}
    8001cd68:	70e6                	ld	ra,120(sp)
    8001cd6a:	7446                	ld	s0,112(sp)
    8001cd6c:	6109                	addi	sp,sp,128
    8001cd6e:	8082                	ret

000000008001cd70 <vfs_init>:

void vfs_init(void) {
    8001cd70:	1101                	addi	sp,sp,-32
    8001cd72:	ec06                	sd	ra,24(sp)
    8001cd74:	e822                	sd	s0,16(sp)
    8001cd76:	1000                	addi	s0,sp,32
    mounted_devices = map_new();
    8001cd78:	4bf010ef          	jal	ra,8001ea36 <map_new>
    8001cd7c:	872a                	mv	a4,a0
    8001cd7e:	00007797          	auipc	a5,0x7
    8001cd82:	83a78793          	addi	a5,a5,-1990 # 800235b8 <mounted_devices>
    8001cd86:	e398                	sd	a4,0(a5)
    mounted_device_count = 0;
    8001cd88:	00007797          	auipc	a5,0x7
    8001cd8c:	82878793          	addi	a5,a5,-2008 # 800235b0 <mounted_device_count>
    8001cd90:	0007b023          	sd	zero,0(a5)
    VirtioDevice *block_device = virtio_get_block_device(0);
    8001cd94:	4501                	li	a0,0
    8001cd96:	a2bfd0ef          	jal	ra,8001a7c0 <virtio_get_block_device>
    8001cd9a:	fea43423          	sd	a0,-24(s0)
    vfs_print_mounted_devices();
    8001cd9e:	c2fff0ef          	jal	ra,8001c9cc <vfs_print_mounted_devices>
    vfs_mount(block_device, "/");
    8001cda2:	00009597          	auipc	a1,0x9
    8001cda6:	1be58593          	addi	a1,a1,446 # 80025f60 <pow10.0+0x1d30>
    8001cdaa:	fe843503          	ld	a0,-24(s0)
    8001cdae:	0bc000ef          	jal	ra,8001ce6a <vfs_mount>
    
    minix3_traverse(block_device, 1, "/", NULL, 0, 10, vfs_mount_callback);
    8001cdb2:	00000817          	auipc	a6,0x0
    8001cdb6:	f1080813          	addi	a6,a6,-240 # 8001ccc2 <vfs_mount_callback>
    8001cdba:	47a9                	li	a5,10
    8001cdbc:	4701                	li	a4,0
    8001cdbe:	4681                	li	a3,0
    8001cdc0:	00009617          	auipc	a2,0x9
    8001cdc4:	1a060613          	addi	a2,a2,416 # 80025f60 <pow10.0+0x1d30>
    8001cdc8:	4585                	li	a1,1
    8001cdca:	fe843503          	ld	a0,-24(s0)
    8001cdce:	e70fa0ef          	jal	ra,8001743e <minix3_traverse>
    vfs_print_mounted_devices();
    8001cdd2:	bfbff0ef          	jal	ra,8001c9cc <vfs_print_mounted_devices>
    vfs_print_open_files();
    8001cdd6:	de3ff0ef          	jal	ra,8001cbb8 <vfs_print_open_files>
    infof("vfs_init: mounted %u devices\n", mounted_device_count);
    8001cdda:	00006797          	auipc	a5,0x6
    8001cdde:	7d678793          	addi	a5,a5,2006 # 800235b0 <mounted_device_count>
    8001cde2:	639c                	ld	a5,0(a5)
    8001cde4:	85be                	mv	a1,a5
    8001cde6:	00009517          	auipc	a0,0x9
    8001cdea:	1a250513          	addi	a0,a0,418 # 80025f88 <pow10.0+0x1d58>
    8001cdee:	cc0fc0ef          	jal	ra,800192ae <infof>
}
    8001cdf2:	0001                	nop
    8001cdf4:	60e2                	ld	ra,24(sp)
    8001cdf6:	6442                	ld	s0,16(sp)
    8001cdf8:	6105                	addi	sp,sp,32
    8001cdfa:	8082                	ret

000000008001cdfc <get_parent_path>:

char *get_parent_path(const char *path) {
    8001cdfc:	7179                	addi	sp,sp,-48
    8001cdfe:	f406                	sd	ra,40(sp)
    8001ce00:	f022                	sd	s0,32(sp)
    8001ce02:	1800                	addi	s0,sp,48
    8001ce04:	fca43c23          	sd	a0,-40(s0)
    char *parent_path = kmalloc(strlen(path) + 1);
    8001ce08:	fd843503          	ld	a0,-40(s0)
    8001ce0c:	6ee030ef          	jal	ra,800204fa <strlen>
    8001ce10:	87aa                	mv	a5,a0
    8001ce12:	0785                	addi	a5,a5,1
    8001ce14:	853e                	mv	a0,a5
    8001ce16:	e81f60ef          	jal	ra,80013c96 <kmalloc>
    8001ce1a:	fea43423          	sd	a0,-24(s0)
    strcpy(parent_path, path);
    8001ce1e:	fd843583          	ld	a1,-40(s0)
    8001ce22:	fe843503          	ld	a0,-24(s0)
    8001ce26:	712030ef          	jal	ra,80020538 <strcpy>
    char *filename = path_file_name(parent_path);
    8001ce2a:	fe843503          	ld	a0,-24(s0)
    8001ce2e:	1da020ef          	jal	ra,8001f008 <path_file_name>
    8001ce32:	fea43023          	sd	a0,-32(s0)
    if (&filename[-1] == parent_path) {
    8001ce36:	fe043783          	ld	a5,-32(s0)
    8001ce3a:	17fd                	addi	a5,a5,-1
    8001ce3c:	fe843703          	ld	a4,-24(s0)
    8001ce40:	00f71963          	bne	a4,a5,8001ce52 <get_parent_path+0x56>
        // We are at root
        filename[0] = '\0';
    8001ce44:	fe043783          	ld	a5,-32(s0)
    8001ce48:	00078023          	sb	zero,0(a5)
        return parent_path;
    8001ce4c:	fe843783          	ld	a5,-24(s0)
    8001ce50:	a801                	j	8001ce60 <get_parent_path+0x64>
    }

    filename[-1] = '\0';
    8001ce52:	fe043783          	ld	a5,-32(s0)
    8001ce56:	17fd                	addi	a5,a5,-1
    8001ce58:	00078023          	sb	zero,0(a5)
    return parent_path;
    8001ce5c:	fe843783          	ld	a5,-24(s0)
}
    8001ce60:	853e                	mv	a0,a5
    8001ce62:	70a2                	ld	ra,40(sp)
    8001ce64:	7402                	ld	s0,32(sp)
    8001ce66:	6145                	addi	sp,sp,48
    8001ce68:	8082                	ret

000000008001ce6a <vfs_mount>:

void vfs_mount(VirtioDevice *block_device, const char *path) {
    8001ce6a:	7179                	addi	sp,sp,-48
    8001ce6c:	f406                	sd	ra,40(sp)
    8001ce6e:	f022                	sd	s0,32(sp)
    8001ce70:	1800                	addi	s0,sp,48
    8001ce72:	fca43c23          	sd	a0,-40(s0)
    8001ce76:	fcb43823          	sd	a1,-48(s0)
    minix3_init(block_device, path);
    8001ce7a:	fd043583          	ld	a1,-48(s0)
    8001ce7e:	fd843503          	ld	a0,-40(s0)
    8001ce82:	f64f70ef          	jal	ra,800145e6 <minix3_init>

    if (mounted_devices == NULL) {
    8001ce86:	00006797          	auipc	a5,0x6
    8001ce8a:	73278793          	addi	a5,a5,1842 # 800235b8 <mounted_devices>
    8001ce8e:	639c                	ld	a5,0(a5)
    8001ce90:	eb89                	bnez	a5,8001cea2 <vfs_mount+0x38>
        mounted_devices = map_new();
    8001ce92:	3a5010ef          	jal	ra,8001ea36 <map_new>
    8001ce96:	872a                	mv	a4,a0
    8001ce98:	00006797          	auipc	a5,0x6
    8001ce9c:	72078793          	addi	a5,a5,1824 # 800235b8 <mounted_devices>
    8001cea0:	e398                	sd	a4,0(a5)
    }

    char *block_device_path = kmalloc(strlen(path) + 1);
    8001cea2:	fd043503          	ld	a0,-48(s0)
    8001cea6:	654030ef          	jal	ra,800204fa <strlen>
    8001ceaa:	87aa                	mv	a5,a0
    8001ceac:	0785                	addi	a5,a5,1
    8001ceae:	853e                	mv	a0,a5
    8001ceb0:	de7f60ef          	jal	ra,80013c96 <kmalloc>
    8001ceb4:	fea43423          	sd	a0,-24(s0)
    strcpy(block_device_path, path);
    8001ceb8:	fd043583          	ld	a1,-48(s0)
    8001cebc:	fe843503          	ld	a0,-24(s0)
    8001cec0:	678030ef          	jal	ra,80020538 <strcpy>
    
    map_set(mounted_devices, block_device_path, (uint64_t)block_device);
    8001cec4:	00006797          	auipc	a5,0x6
    8001cec8:	6f478793          	addi	a5,a5,1780 # 800235b8 <mounted_devices>
    8001cecc:	639c                	ld	a5,0(a5)
    8001cece:	fd843703          	ld	a4,-40(s0)
    8001ced2:	863a                	mv	a2,a4
    8001ced4:	fe843583          	ld	a1,-24(s0)
    8001ced8:	853e                	mv	a0,a5
    8001ceda:	3e3010ef          	jal	ra,8001eabc <map_set>
    debugf("vfs_mount: mounted (%p) %s at %s\n", block_device, block_device_path, path);
    mounted_device_count += 1;
    8001cede:	00006797          	auipc	a5,0x6
    8001cee2:	6d278793          	addi	a5,a5,1746 # 800235b0 <mounted_device_count>
    8001cee6:	639c                	ld	a5,0(a5)
    8001cee8:	00178713          	addi	a4,a5,1
    8001ceec:	00006797          	auipc	a5,0x6
    8001cef0:	6c478793          	addi	a5,a5,1732 # 800235b0 <mounted_device_count>
    8001cef4:	e398                	sd	a4,0(a5)

}
    8001cef6:	0001                	nop
    8001cef8:	70a2                	ld	ra,40(sp)
    8001cefa:	7402                	ld	s0,32(sp)
    8001cefc:	6145                	addi	sp,sp,48
    8001cefe:	8082                	ret

000000008001cf00 <vfs_get_mounted_device>:

VirtioDevice *vfs_get_mounted_device(const char *path) {
    8001cf00:	7139                	addi	sp,sp,-64
    8001cf02:	fc06                	sd	ra,56(sp)
    8001cf04:	f822                	sd	s0,48(sp)
    8001cf06:	0080                	addi	s0,sp,64
    8001cf08:	fca43423          	sd	a0,-56(s0)
    if (path == NULL) {
    8001cf0c:	fc843783          	ld	a5,-56(s0)
    8001cf10:	e399                	bnez	a5,8001cf16 <vfs_get_mounted_device+0x16>
        debugf("vfs_get_mounted_device: path is NULL\n");
        return NULL;
    8001cf12:	4781                	li	a5,0
    8001cf14:	a0fd                	j	8001d002 <vfs_get_mounted_device+0x102>
    }

    if (strlen(path) == 0 || strcmp(path, "") == 0) {
    8001cf16:	fc843503          	ld	a0,-56(s0)
    8001cf1a:	5e0030ef          	jal	ra,800204fa <strlen>
    8001cf1e:	87aa                	mv	a5,a0
    8001cf20:	cb99                	beqz	a5,8001cf36 <vfs_get_mounted_device+0x36>
    8001cf22:	00009597          	auipc	a1,0x9
    8001cf26:	08658593          	addi	a1,a1,134 # 80025fa8 <pow10.0+0x1d78>
    8001cf2a:	fc843503          	ld	a0,-56(s0)
    8001cf2e:	2ce030ef          	jal	ra,800201fc <strcmp>
    8001cf32:	87aa                	mv	a5,a0
    8001cf34:	e399                	bnez	a5,8001cf3a <vfs_get_mounted_device+0x3a>
        debugf("vfs_get_mounted_device: path is empty\n");
        return NULL;
    8001cf36:	4781                	li	a5,0
    8001cf38:	a0e9                	j	8001d002 <vfs_get_mounted_device+0x102>
    }

    if (mounted_devices == NULL) {
    8001cf3a:	00006797          	auipc	a5,0x6
    8001cf3e:	67e78793          	addi	a5,a5,1662 # 800235b8 <mounted_devices>
    8001cf42:	639c                	ld	a5,0(a5)
    8001cf44:	eb89                	bnez	a5,8001cf56 <vfs_get_mounted_device+0x56>
        mounted_devices = map_new();
    8001cf46:	2f1010ef          	jal	ra,8001ea36 <map_new>
    8001cf4a:	872a                	mv	a4,a0
    8001cf4c:	00006797          	auipc	a5,0x6
    8001cf50:	66c78793          	addi	a5,a5,1644 # 800235b8 <mounted_devices>
    8001cf54:	e398                	sd	a4,0(a5)
    }

    VirtioDevice *block_device = NULL;
    8001cf56:	fc043c23          	sd	zero,-40(s0)
    map_get(mounted_devices, path, &block_device);
    8001cf5a:	00006797          	auipc	a5,0x6
    8001cf5e:	65e78793          	addi	a5,a5,1630 # 800235b8 <mounted_devices>
    8001cf62:	639c                	ld	a5,0(a5)
    8001cf64:	fd840713          	addi	a4,s0,-40
    8001cf68:	863a                	mv	a2,a4
    8001cf6a:	fc843583          	ld	a1,-56(s0)
    8001cf6e:	853e                	mv	a0,a5
    8001cf70:	40f010ef          	jal	ra,8001eb7e <map_get>
    // map_get_int(mounted_devices, 0, &block_device);

    if (block_device == NULL) {
    8001cf74:	fd843783          	ld	a5,-40(s0)
    8001cf78:	e3d9                	bnez	a5,8001cffe <vfs_get_mounted_device+0xfe>
        debugf("vfs_get_mounted_device: no device found for %s\n", path);
        if (strcmp(path, "/") == 0) {
    8001cf7a:	00009597          	auipc	a1,0x9
    8001cf7e:	fe658593          	addi	a1,a1,-26 # 80025f60 <pow10.0+0x1d30>
    8001cf82:	fc843503          	ld	a0,-56(s0)
    8001cf86:	276030ef          	jal	ra,800201fc <strcmp>
    8001cf8a:	87aa                	mv	a5,a0
    8001cf8c:	e399                	bnez	a5,8001cf92 <vfs_get_mounted_device+0x92>
            debugf("vfs_get_mounted_device: no device found for /\n");
            return NULL;
    8001cf8e:	4781                	li	a5,0
    8001cf90:	a88d                	j	8001d002 <vfs_get_mounted_device+0x102>
        }

        // Get the parent path
        char *parent_path = kmalloc(strlen(path) + 1);
    8001cf92:	fc843503          	ld	a0,-56(s0)
    8001cf96:	564030ef          	jal	ra,800204fa <strlen>
    8001cf9a:	87aa                	mv	a5,a0
    8001cf9c:	0785                	addi	a5,a5,1
    8001cf9e:	853e                	mv	a0,a5
    8001cfa0:	cf7f60ef          	jal	ra,80013c96 <kmalloc>
    8001cfa4:	fea43423          	sd	a0,-24(s0)
        strcpy(parent_path, path);
    8001cfa8:	fc843583          	ld	a1,-56(s0)
    8001cfac:	fe843503          	ld	a0,-24(s0)
    8001cfb0:	588030ef          	jal	ra,80020538 <strcpy>
        char *filename = path_file_name(parent_path);
    8001cfb4:	fe843503          	ld	a0,-24(s0)
    8001cfb8:	050020ef          	jal	ra,8001f008 <path_file_name>
    8001cfbc:	fea43023          	sd	a0,-32(s0)
        if (&filename[-1] == parent_path) {
    8001cfc0:	fe043783          	ld	a5,-32(s0)
    8001cfc4:	17fd                	addi	a5,a5,-1
    8001cfc6:	fe843703          	ld	a4,-24(s0)
    8001cfca:	00f71a63          	bne	a4,a5,8001cfde <vfs_get_mounted_device+0xde>
            // We are at root
            debugf("vfs_get_mounted_device: we are at root\n");
            return vfs_get_mounted_device("/");
    8001cfce:	00009517          	auipc	a0,0x9
    8001cfd2:	f9250513          	addi	a0,a0,-110 # 80025f60 <pow10.0+0x1d30>
    8001cfd6:	f2bff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001cfda:	87aa                	mv	a5,a0
    8001cfdc:	a01d                	j	8001d002 <vfs_get_mounted_device+0x102>
        }

        filename[-1] = '\0';
    8001cfde:	fe043783          	ld	a5,-32(s0)
    8001cfe2:	17fd                	addi	a5,a5,-1
    8001cfe4:	00078023          	sb	zero,0(a5)


        // Get the parent device
        debugf("vfs_get_mounted_device: getting parent device for %s\n", path);
        block_device = vfs_get_mounted_device(parent_path);
    8001cfe8:	fe843503          	ld	a0,-24(s0)
    8001cfec:	f15ff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001cff0:	87aa                	mv	a5,a0
    8001cff2:	fcf43c23          	sd	a5,-40(s0)
        kfree(parent_path);
    8001cff6:	fe843503          	ld	a0,-24(s0)
    8001cffa:	ce5f60ef          	jal	ra,80013cde <kfree>
    } else {
        debugf("vfs_get_mounted_device: found device for %s\n", path);
    }

    debugf("vfs_get_mounted_device: returning %p\n", block_device);
    return block_device;
    8001cffe:	fd843783          	ld	a5,-40(s0)
}
    8001d002:	853e                	mv	a0,a5
    8001d004:	70e2                	ld	ra,56(sp)
    8001d006:	7442                	ld	s0,48(sp)
    8001d008:	6121                	addi	sp,sp,64
    8001d00a:	8082                	ret

000000008001d00c <is_mounted_device>:

bool is_mounted_device(const char *path) {
    8001d00c:	1101                	addi	sp,sp,-32
    8001d00e:	ec06                	sd	ra,24(sp)
    8001d010:	e822                	sd	s0,16(sp)
    8001d012:	1000                	addi	s0,sp,32
    8001d014:	fea43423          	sd	a0,-24(s0)
    return map_contains(mounted_devices, path);
    8001d018:	00006797          	auipc	a5,0x6
    8001d01c:	5a078793          	addi	a5,a5,1440 # 800235b8 <mounted_devices>
    8001d020:	639c                	ld	a5,0(a5)
    8001d022:	fe843583          	ld	a1,-24(s0)
    8001d026:	853e                	mv	a0,a5
    8001d028:	3e1010ef          	jal	ra,8001ec08 <map_contains>
    8001d02c:	87aa                	mv	a5,a0
}
    8001d02e:	853e                	mv	a0,a5
    8001d030:	60e2                	ld	ra,24(sp)
    8001d032:	6442                	ld	s0,16(sp)
    8001d034:	6105                	addi	sp,sp,32
    8001d036:	8082                	ret

000000008001d038 <get_path_relative_to_mount_point>:

char *get_path_relative_to_mount_point(const char *path) {
    8001d038:	7139                	addi	sp,sp,-64
    8001d03a:	fc06                	sd	ra,56(sp)
    8001d03c:	f822                	sd	s0,48(sp)
    8001d03e:	0080                	addi	s0,sp,64
    8001d040:	fca43423          	sd	a0,-56(s0)
    // vfs_get_mounted_device(path);
    if (path == NULL) {
    8001d044:	fc843783          	ld	a5,-56(s0)
    8001d048:	e399                	bnez	a5,8001d04e <get_path_relative_to_mount_point+0x16>
        debugf("get_path_relative_to_mount_point: path is NULL\n");
        return NULL;
    8001d04a:	4781                	li	a5,0
    8001d04c:	a299                	j	8001d192 <get_path_relative_to_mount_point+0x15a>
    }

    if (strlen(path) == 0 || strcmp(path, "") == 0) {
    8001d04e:	fc843503          	ld	a0,-56(s0)
    8001d052:	4a8030ef          	jal	ra,800204fa <strlen>
    8001d056:	87aa                	mv	a5,a0
    8001d058:	cb99                	beqz	a5,8001d06e <get_path_relative_to_mount_point+0x36>
    8001d05a:	00009597          	auipc	a1,0x9
    8001d05e:	f4e58593          	addi	a1,a1,-178 # 80025fa8 <pow10.0+0x1d78>
    8001d062:	fc843503          	ld	a0,-56(s0)
    8001d066:	196030ef          	jal	ra,800201fc <strcmp>
    8001d06a:	87aa                	mv	a5,a0
    8001d06c:	e399                	bnez	a5,8001d072 <get_path_relative_to_mount_point+0x3a>
        debugf("get_path_relative_to_mount_point: path is empty\n");
        return NULL;
    8001d06e:	4781                	li	a5,0
    8001d070:	a20d                	j	8001d192 <get_path_relative_to_mount_point+0x15a>
    }

    char *result = kmalloc(strlen(path) + 1);
    8001d072:	fc843503          	ld	a0,-56(s0)
    8001d076:	484030ef          	jal	ra,800204fa <strlen>
    8001d07a:	87aa                	mv	a5,a0
    8001d07c:	0785                	addi	a5,a5,1
    8001d07e:	853e                	mv	a0,a5
    8001d080:	c17f60ef          	jal	ra,80013c96 <kmalloc>
    8001d084:	fea43023          	sd	a0,-32(s0)
    if (strcmp(path, "/") == 0) {
    8001d088:	00009597          	auipc	a1,0x9
    8001d08c:	ed858593          	addi	a1,a1,-296 # 80025f60 <pow10.0+0x1d30>
    8001d090:	fc843503          	ld	a0,-56(s0)
    8001d094:	168030ef          	jal	ra,800201fc <strcmp>
    8001d098:	87aa                	mv	a5,a0
    8001d09a:	ef81                	bnez	a5,8001d0b2 <get_path_relative_to_mount_point+0x7a>
        debugf("get_path_relative_to_mount_point: path is /\n");
        strcpy(result, "/");
    8001d09c:	00009597          	auipc	a1,0x9
    8001d0a0:	ec458593          	addi	a1,a1,-316 # 80025f60 <pow10.0+0x1d30>
    8001d0a4:	fe043503          	ld	a0,-32(s0)
    8001d0a8:	490030ef          	jal	ra,80020538 <strcpy>
        return result;
    8001d0ac:	fe043783          	ld	a5,-32(s0)
    8001d0b0:	a0cd                	j	8001d192 <get_path_relative_to_mount_point+0x15a>
    }


    if (is_mounted_device(path)) {
    8001d0b2:	fc843503          	ld	a0,-56(s0)
    8001d0b6:	f57ff0ef          	jal	ra,8001d00c <is_mounted_device>
    8001d0ba:	87aa                	mv	a5,a0
    8001d0bc:	cf81                	beqz	a5,8001d0d4 <get_path_relative_to_mount_point+0x9c>
        debugf("get_path_relative_to_mount_point: path is a mounted device\n");
        strcpy(result, "/");
    8001d0be:	00009597          	auipc	a1,0x9
    8001d0c2:	ea258593          	addi	a1,a1,-350 # 80025f60 <pow10.0+0x1d30>
    8001d0c6:	fe043503          	ld	a0,-32(s0)
    8001d0ca:	46e030ef          	jal	ra,80020538 <strcpy>
        return result;
    8001d0ce:	fe043783          	ld	a5,-32(s0)
    8001d0d2:	a0c1                	j	8001d192 <get_path_relative_to_mount_point+0x15a>
    } else {
        debugf("get_path_relative_to_mount_point: path is not a mounted device\n");
        char *parent_path = get_parent_path(path);
    8001d0d4:	fc843503          	ld	a0,-56(s0)
    8001d0d8:	d25ff0ef          	jal	ra,8001cdfc <get_parent_path>
    8001d0dc:	fea43423          	sd	a0,-24(s0)
        while (!is_mounted_device(parent_path)) {
    8001d0e0:	a089                	j	8001d122 <get_path_relative_to_mount_point+0xea>
            debugf("get_path_relative_to_mount_point: %s is not a mounted device\n", parent_path);
            char *parent_parent_path = get_parent_path(parent_path);
    8001d0e2:	fe843503          	ld	a0,-24(s0)
    8001d0e6:	d17ff0ef          	jal	ra,8001cdfc <get_parent_path>
    8001d0ea:	fca43c23          	sd	a0,-40(s0)
            kfree(parent_path);
    8001d0ee:	fe843503          	ld	a0,-24(s0)
    8001d0f2:	bedf60ef          	jal	ra,80013cde <kfree>
            parent_path = parent_parent_path;
    8001d0f6:	fd843783          	ld	a5,-40(s0)
    8001d0fa:	fef43423          	sd	a5,-24(s0)

            if (strcmp(parent_path, "/") == 0 || strcmp(parent_path, "") == 0) {
    8001d0fe:	00009597          	auipc	a1,0x9
    8001d102:	e6258593          	addi	a1,a1,-414 # 80025f60 <pow10.0+0x1d30>
    8001d106:	fe843503          	ld	a0,-24(s0)
    8001d10a:	0f2030ef          	jal	ra,800201fc <strcmp>
    8001d10e:	87aa                	mv	a5,a0
    8001d110:	cb89                	beqz	a5,8001d122 <get_path_relative_to_mount_point+0xea>
    8001d112:	00009597          	auipc	a1,0x9
    8001d116:	e9658593          	addi	a1,a1,-362 # 80025fa8 <pow10.0+0x1d78>
    8001d11a:	fe843503          	ld	a0,-24(s0)
    8001d11e:	0de030ef          	jal	ra,800201fc <strcmp>
        while (!is_mounted_device(parent_path)) {
    8001d122:	fe843503          	ld	a0,-24(s0)
    8001d126:	ee7ff0ef          	jal	ra,8001d00c <is_mounted_device>
    8001d12a:	87aa                	mv	a5,a0
    8001d12c:	0017c793          	xori	a5,a5,1
    8001d130:	0ff7f793          	andi	a5,a5,255
    8001d134:	f7dd                	bnez	a5,8001d0e2 <get_path_relative_to_mount_point+0xaa>
                debugf("get_path_relative_to_mount_point: parent path is /\n");
            }
        }

        debugf("get_path_relative_to_mount_point: %s is a mounted device\n", parent_path);
        if (strcmp(parent_path, "/") == 0 || strcmp(parent_path, "") == 0) {
    8001d136:	00009597          	auipc	a1,0x9
    8001d13a:	e2a58593          	addi	a1,a1,-470 # 80025f60 <pow10.0+0x1d30>
    8001d13e:	fe843503          	ld	a0,-24(s0)
    8001d142:	0ba030ef          	jal	ra,800201fc <strcmp>
    8001d146:	87aa                	mv	a5,a0
    8001d148:	cb99                	beqz	a5,8001d15e <get_path_relative_to_mount_point+0x126>
    8001d14a:	00009597          	auipc	a1,0x9
    8001d14e:	e5e58593          	addi	a1,a1,-418 # 80025fa8 <pow10.0+0x1d78>
    8001d152:	fe843503          	ld	a0,-24(s0)
    8001d156:	0a6030ef          	jal	ra,800201fc <strcmp>
    8001d15a:	87aa                	mv	a5,a0
    8001d15c:	eb81                	bnez	a5,8001d16c <get_path_relative_to_mount_point+0x134>
            debugf("get_path_relative_to_mount_point: parent path is /\n");
            strcpy(result, path);
    8001d15e:	fc843583          	ld	a1,-56(s0)
    8001d162:	fe043503          	ld	a0,-32(s0)
    8001d166:	3d2030ef          	jal	ra,80020538 <strcpy>
    8001d16a:	a831                	j	8001d186 <get_path_relative_to_mount_point+0x14e>
        } else {
            strcpy(result, path + strlen(parent_path));
    8001d16c:	fe843503          	ld	a0,-24(s0)
    8001d170:	38a030ef          	jal	ra,800204fa <strlen>
    8001d174:	872a                	mv	a4,a0
    8001d176:	fc843783          	ld	a5,-56(s0)
    8001d17a:	97ba                	add	a5,a5,a4
    8001d17c:	85be                	mv	a1,a5
    8001d17e:	fe043503          	ld	a0,-32(s0)
    8001d182:	3b6030ef          	jal	ra,80020538 <strcpy>
        }
        kfree(parent_path);
    8001d186:	fe843503          	ld	a0,-24(s0)
    8001d18a:	b55f60ef          	jal	ra,80013cde <kfree>
        return result;
    8001d18e:	fe043783          	ld	a5,-32(s0)
    }
}
    8001d192:	853e                	mv	a0,a5
    8001d194:	70e2                	ld	ra,56(sp)
    8001d196:	7442                	ld	s0,48(sp)
    8001d198:	6121                	addi	sp,sp,64
    8001d19a:	8082                	ret

000000008001d19c <vfs_should_create_if_doesnt_exist>:

bool vfs_should_create_if_doesnt_exist(flags_t flags, mode_t mode, type_t type) {
    8001d19c:	1101                	addi	sp,sp,-32
    8001d19e:	ec22                	sd	s0,24(sp)
    8001d1a0:	1000                	addi	s0,sp,32
    8001d1a2:	fea43423          	sd	a0,-24(s0)
    8001d1a6:	87ae                	mv	a5,a1
    8001d1a8:	8732                	mv	a4,a2
    8001d1aa:	fef41323          	sh	a5,-26(s0)
    8001d1ae:	87ba                	mv	a5,a4
    8001d1b0:	fef41223          	sh	a5,-28(s0)
    return flags & O_CREAT;
    8001d1b4:	fe843783          	ld	a5,-24(s0)
    8001d1b8:	8ba1                	andi	a5,a5,8
    8001d1ba:	00f037b3          	snez	a5,a5
    8001d1be:	0ff7f793          	andi	a5,a5,255
}
    8001d1c2:	853e                	mv	a0,a5
    8001d1c4:	6462                	ld	s0,24(sp)
    8001d1c6:	6105                	addi	sp,sp,32
    8001d1c8:	8082                	ret

000000008001d1ca <vfs_should_truncate>:

bool vfs_should_truncate(flags_t flags, mode_t mode, type_t type) {
    8001d1ca:	1101                	addi	sp,sp,-32
    8001d1cc:	ec22                	sd	s0,24(sp)
    8001d1ce:	1000                	addi	s0,sp,32
    8001d1d0:	fea43423          	sd	a0,-24(s0)
    8001d1d4:	87ae                	mv	a5,a1
    8001d1d6:	8732                	mv	a4,a2
    8001d1d8:	fef41323          	sh	a5,-26(s0)
    8001d1dc:	87ba                	mv	a5,a4
    8001d1de:	fef41223          	sh	a5,-28(s0)
    return flags & O_TRUNC;
    8001d1e2:	fe843783          	ld	a5,-24(s0)
    8001d1e6:	8bc1                	andi	a5,a5,16
    8001d1e8:	00f037b3          	snez	a5,a5
    8001d1ec:	0ff7f793          	andi	a5,a5,255
}
    8001d1f0:	853e                	mv	a0,a5
    8001d1f2:	6462                	ld	s0,24(sp)
    8001d1f4:	6105                	addi	sp,sp,32
    8001d1f6:	8082                	ret

000000008001d1f8 <vfs_get_open_file>:

File *vfs_get_open_file(const char *path) {
    8001d1f8:	7179                	addi	sp,sp,-48
    8001d1fa:	f406                	sd	ra,40(sp)
    8001d1fc:	f022                	sd	s0,32(sp)
    8001d1fe:	1800                	addi	s0,sp,48
    8001d200:	fca43c23          	sd	a0,-40(s0)
    if (open_files == NULL) {
    8001d204:	00006797          	auipc	a5,0x6
    8001d208:	3a478793          	addi	a5,a5,932 # 800235a8 <open_files>
    8001d20c:	639c                	ld	a5,0(a5)
    8001d20e:	eb89                	bnez	a5,8001d220 <vfs_get_open_file+0x28>
        open_files = map_new();
    8001d210:	027010ef          	jal	ra,8001ea36 <map_new>
    8001d214:	872a                	mv	a4,a0
    8001d216:	00006797          	auipc	a5,0x6
    8001d21a:	39278793          	addi	a5,a5,914 # 800235a8 <open_files>
    8001d21e:	e398                	sd	a4,0(a5)
    }
    if (!map_contains(open_files, path)) {
    8001d220:	00006797          	auipc	a5,0x6
    8001d224:	38878793          	addi	a5,a5,904 # 800235a8 <open_files>
    8001d228:	639c                	ld	a5,0(a5)
    8001d22a:	fd843583          	ld	a1,-40(s0)
    8001d22e:	853e                	mv	a0,a5
    8001d230:	1d9010ef          	jal	ra,8001ec08 <map_contains>
    8001d234:	87aa                	mv	a5,a0
    8001d236:	0017c793          	xori	a5,a5,1
    8001d23a:	0ff7f793          	andi	a5,a5,255
    8001d23e:	c399                	beqz	a5,8001d244 <vfs_get_open_file+0x4c>
        debugf("vfs_get_open_file: file is not open\n");
        return NULL;
    8001d240:	4781                	li	a5,0
    8001d242:	a015                	j	8001d266 <vfs_get_open_file+0x6e>
    }

    File *file = NULL;
    8001d244:	fe043423          	sd	zero,-24(s0)
    map_get(open_files, path, &file);
    8001d248:	00006797          	auipc	a5,0x6
    8001d24c:	36078793          	addi	a5,a5,864 # 800235a8 <open_files>
    8001d250:	639c                	ld	a5,0(a5)
    8001d252:	fe840713          	addi	a4,s0,-24
    8001d256:	863a                	mv	a2,a4
    8001d258:	fd843583          	ld	a1,-40(s0)
    8001d25c:	853e                	mv	a0,a5
    8001d25e:	121010ef          	jal	ra,8001eb7e <map_get>
    debugf("vfs_get_open_file: %s is %p\n", path, file);
    return file;
    8001d262:	fe843783          	ld	a5,-24(s0)
}
    8001d266:	853e                	mv	a0,a5
    8001d268:	70a2                	ld	ra,40(sp)
    8001d26a:	7402                	ld	s0,32(sp)
    8001d26c:	6145                	addi	sp,sp,48
    8001d26e:	8082                	ret

000000008001d270 <vfs_is_open>:

bool vfs_is_open(const char *path) {
    8001d270:	1101                	addi	sp,sp,-32
    8001d272:	ec06                	sd	ra,24(sp)
    8001d274:	e822                	sd	s0,16(sp)
    8001d276:	1000                	addi	s0,sp,32
    8001d278:	fea43423          	sd	a0,-24(s0)
    if (open_files == NULL) {
    8001d27c:	00006797          	auipc	a5,0x6
    8001d280:	32c78793          	addi	a5,a5,812 # 800235a8 <open_files>
    8001d284:	639c                	ld	a5,0(a5)
    8001d286:	eb89                	bnez	a5,8001d298 <vfs_is_open+0x28>
        open_files = map_new();
    8001d288:	7ae010ef          	jal	ra,8001ea36 <map_new>
    8001d28c:	872a                	mv	a4,a0
    8001d28e:	00006797          	auipc	a5,0x6
    8001d292:	31a78793          	addi	a5,a5,794 # 800235a8 <open_files>
    8001d296:	e398                	sd	a4,0(a5)
    }
    debugf("vfs_is_open: %s\n", path);

    return map_contains(open_files, path);
    8001d298:	00006797          	auipc	a5,0x6
    8001d29c:	31078793          	addi	a5,a5,784 # 800235a8 <open_files>
    8001d2a0:	639c                	ld	a5,0(a5)
    8001d2a2:	fe843583          	ld	a1,-24(s0)
    8001d2a6:	853e                	mv	a0,a5
    8001d2a8:	161010ef          	jal	ra,8001ec08 <map_contains>
    8001d2ac:	87aa                	mv	a5,a0
}
    8001d2ae:	853e                	mv	a0,a5
    8001d2b0:	60e2                	ld	ra,24(sp)
    8001d2b2:	6442                	ld	s0,16(sp)
    8001d2b4:	6105                	addi	sp,sp,32
    8001d2b6:	8082                	ret

000000008001d2b8 <vfs_open>:

File *vfs_open(const char *path, flags_t flags, mode_t mode, type_t type) {
    8001d2b8:	7125                	addi	sp,sp,-416
    8001d2ba:	ef06                	sd	ra,408(sp)
    8001d2bc:	eb22                	sd	s0,400(sp)
    8001d2be:	e726                	sd	s1,392(sp)
    8001d2c0:	1300                	addi	s0,sp,416
    8001d2c2:	eaa43c23          	sd	a0,-328(s0)
    8001d2c6:	eab43823          	sd	a1,-336(s0)
    8001d2ca:	87b2                	mv	a5,a2
    8001d2cc:	8736                	mv	a4,a3
    8001d2ce:	eaf41723          	sh	a5,-338(s0)
    8001d2d2:	87ba                	mv	a5,a4
    8001d2d4:	eaf41623          	sh	a5,-340(s0)
    debugf("vfs_open: opening %s\n", path);

    if (is_mounted_device(path)) {
    8001d2d8:	eb843503          	ld	a0,-328(s0)
    8001d2dc:	d31ff0ef          	jal	ra,8001d00c <is_mounted_device>
    8001d2e0:	87aa                	mv	a5,a0
    8001d2e2:	14078363          	beqz	a5,8001d428 <vfs_open+0x170>
        debugf("vfs_open: path is a mounted device\n");
        if (!vfs_is_open(path)) {
    8001d2e6:	eb843503          	ld	a0,-328(s0)
    8001d2ea:	f87ff0ef          	jal	ra,8001d270 <vfs_is_open>
    8001d2ee:	87aa                	mv	a5,a0
    8001d2f0:	0017c793          	xori	a5,a5,1
    8001d2f4:	0ff7f793          	andi	a5,a5,255
    8001d2f8:	12078663          	beqz	a5,8001d424 <vfs_open+0x16c>
            debugf("vfs_open: mounting device\n");
            VirtioDevice *block_device = vfs_get_mounted_device(path);
    8001d2fc:	eb843503          	ld	a0,-328(s0)
    8001d300:	c01ff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001d304:	f8a43823          	sd	a0,-112(s0)
            File *file = kmalloc(sizeof(File));
    8001d308:	08800513          	li	a0,136
    8001d30c:	98bf60ef          	jal	ra,80013c96 <kmalloc>
    8001d310:	f8a43423          	sd	a0,-120(s0)
            memset(file, 0, sizeof(File));
    8001d314:	08800613          	li	a2,136
    8001d318:	4581                	li	a1,0
    8001d31a:	f8843503          	ld	a0,-120(s0)
    8001d31e:	24f020ef          	jal	ra,8001fd6c <memset>
            file->path = kmalloc(strlen(path) + 1);
    8001d322:	eb843503          	ld	a0,-328(s0)
    8001d326:	1d4030ef          	jal	ra,800204fa <strlen>
    8001d32a:	87aa                	mv	a5,a0
    8001d32c:	0785                	addi	a5,a5,1
    8001d32e:	853e                	mv	a0,a5
    8001d330:	967f60ef          	jal	ra,80013c96 <kmalloc>
    8001d334:	872a                	mv	a4,a0
    8001d336:	f8843783          	ld	a5,-120(s0)
    8001d33a:	fbb8                	sd	a4,112(a5)
            strcpy(file->path, path);
    8001d33c:	f8843783          	ld	a5,-120(s0)
    8001d340:	7bbc                	ld	a5,112(a5)
    8001d342:	eb843583          	ld	a1,-328(s0)
    8001d346:	853e                	mv	a0,a5
    8001d348:	1f0030ef          	jal	ra,80020538 <strcpy>
            file->flags = flags;
    8001d34c:	f8843783          	ld	a5,-120(s0)
    8001d350:	eb043703          	ld	a4,-336(s0)
    8001d354:	f7b8                	sd	a4,104(a5)
            file->mode = mode;
    8001d356:	f8843783          	ld	a5,-120(s0)
    8001d35a:	eae45703          	lhu	a4,-338(s0)
    8001d35e:	04e79c23          	sh	a4,88(a5)
            file->type = type;
    8001d362:	f8843783          	ld	a5,-120(s0)
    8001d366:	eac45703          	lhu	a4,-340(s0)
    8001d36a:	00e79423          	sh	a4,8(a5)
            file->dev = block_device;
    8001d36e:	f8843783          	ld	a5,-120(s0)
    8001d372:	f9043703          	ld	a4,-112(s0)
    8001d376:	e398                	sd	a4,0(a5)
            file->inode = 1;
    8001d378:	f8843783          	ld	a5,-120(s0)
    8001d37c:	4705                	li	a4,1
    8001d37e:	c7f8                	sw	a4,76(a5)
            file->inode_data = minix3_get_inode(block_device, file->inode);
    8001d380:	f8843783          	ld	a5,-120(s0)
    8001d384:	47f8                	lw	a4,76(a5)
    8001d386:	f8843483          	ld	s1,-120(s0)
    8001d38a:	e6040793          	addi	a5,s0,-416
    8001d38e:	863a                	mv	a2,a4
    8001d390:	f9043583          	ld	a1,-112(s0)
    8001d394:	853e                	mv	a0,a5
    8001d396:	a49f70ef          	jal	ra,80014dde <minix3_get_inode>
    8001d39a:	00c48793          	addi	a5,s1,12
    8001d39e:	e6040713          	addi	a4,s0,-416
    8001d3a2:	04000693          	li	a3,64
    8001d3a6:	8636                	mv	a2,a3
    8001d3a8:	85ba                	mv	a1,a4
    8001d3aa:	853e                	mv	a0,a5
    8001d3ac:	2c3020ef          	jal	ra,8001fe6e <memcpy>
            file->size = file->inode_data.size;
    8001d3b0:	f8843783          	ld	a5,-120(s0)
    8001d3b4:	4bdc                	lw	a5,20(a5)
    8001d3b6:	02079713          	slli	a4,a5,0x20
    8001d3ba:	9301                	srli	a4,a4,0x20
    8001d3bc:	f8843783          	ld	a5,-120(s0)
    8001d3c0:	f3b8                	sd	a4,96(a5)
            file->is_dir = true;
    8001d3c2:	f8843783          	ld	a5,-120(s0)
    8001d3c6:	4705                	li	a4,1
    8001d3c8:	06e78c23          	sb	a4,120(a5)
            file->is_file = false;
    8001d3cc:	f8843783          	ld	a5,-120(s0)
    8001d3d0:	06078ca3          	sb	zero,121(a5)
            file->is_symlink = false;
    8001d3d4:	f8843783          	ld	a5,-120(s0)
    8001d3d8:	06078d23          	sb	zero,122(a5)
            file->is_hardlink = false;
    8001d3dc:	f8843783          	ld	a5,-120(s0)
    8001d3e0:	06078da3          	sb	zero,123(a5)
            file->is_block_device = false;
    8001d3e4:	f8843783          	ld	a5,-120(s0)
    8001d3e8:	06078e23          	sb	zero,124(a5)
            file->is_char_device = false;
    8001d3ec:	f8843783          	ld	a5,-120(s0)
    8001d3f0:	06078ea3          	sb	zero,125(a5)
            file->major = 0;
    8001d3f4:	f8843783          	ld	a5,-120(s0)
    8001d3f8:	06079f23          	sh	zero,126(a5)
            file->minor = 0;
    8001d3fc:	f8843783          	ld	a5,-120(s0)
    8001d400:	08079023          	sh	zero,128(a5)
            map_set(open_files, path, file);
    8001d404:	00006797          	auipc	a5,0x6
    8001d408:	1a478793          	addi	a5,a5,420 # 800235a8 <open_files>
    8001d40c:	639c                	ld	a5,0(a5)
    8001d40e:	f8843703          	ld	a4,-120(s0)
    8001d412:	863a                	mv	a2,a4
    8001d414:	eb843583          	ld	a1,-328(s0)
    8001d418:	853e                	mv	a0,a5
    8001d41a:	6a2010ef          	jal	ra,8001eabc <map_set>
            return file; 
    8001d41e:	f8843783          	ld	a5,-120(s0)
    8001d422:	a565                	j	8001daca <vfs_open+0x812>
        }
        return NULL;
    8001d424:	4781                	li	a5,0
    8001d426:	a555                	j	8001daca <vfs_open+0x812>
    }

    if (path == NULL) {
    8001d428:	eb843783          	ld	a5,-328(s0)
    8001d42c:	e399                	bnez	a5,8001d432 <vfs_open+0x17a>
        debugf("vfs_open: path is NULL\n");
        return NULL;
    8001d42e:	4781                	li	a5,0
    8001d430:	ad69                	j	8001daca <vfs_open+0x812>
    }

    if (strlen(path) == 0 || strcmp(path, "") == 0) {
    8001d432:	eb843503          	ld	a0,-328(s0)
    8001d436:	0c4030ef          	jal	ra,800204fa <strlen>
    8001d43a:	87aa                	mv	a5,a0
    8001d43c:	cb99                	beqz	a5,8001d452 <vfs_open+0x19a>
    8001d43e:	00009597          	auipc	a1,0x9
    8001d442:	b6a58593          	addi	a1,a1,-1174 # 80025fa8 <pow10.0+0x1d78>
    8001d446:	eb843503          	ld	a0,-328(s0)
    8001d44a:	5b3020ef          	jal	ra,800201fc <strcmp>
    8001d44e:	87aa                	mv	a5,a0
    8001d450:	e399                	bnez	a5,8001d456 <vfs_open+0x19e>
        debugf("vfs_open: path is empty\n");
        return NULL;
    8001d452:	4781                	li	a5,0
    8001d454:	ad9d                	j	8001daca <vfs_open+0x812>
    }

    if (open_files == NULL) {
    8001d456:	00006797          	auipc	a5,0x6
    8001d45a:	15278793          	addi	a5,a5,338 # 800235a8 <open_files>
    8001d45e:	639c                	ld	a5,0(a5)
    8001d460:	eb89                	bnez	a5,8001d472 <vfs_open+0x1ba>
        open_files = map_new();
    8001d462:	5d4010ef          	jal	ra,8001ea36 <map_new>
    8001d466:	872a                	mv	a4,a0
    8001d468:	00006797          	auipc	a5,0x6
    8001d46c:	14078793          	addi	a5,a5,320 # 800235a8 <open_files>
    8001d470:	e398                	sd	a4,0(a5)
    }

    if (map_contains(open_files, path)) {
    8001d472:	00006797          	auipc	a5,0x6
    8001d476:	13678793          	addi	a5,a5,310 # 800235a8 <open_files>
    8001d47a:	639c                	ld	a5,0(a5)
    8001d47c:	eb843583          	ld	a1,-328(s0)
    8001d480:	853e                	mv	a0,a5
    8001d482:	786010ef          	jal	ra,8001ec08 <map_contains>
    8001d486:	87aa                	mv	a5,a0
    8001d488:	c38d                	beqz	a5,8001d4aa <vfs_open+0x1f2>
        debugf("vfs_open: file is already open\n");
        File *file;
        map_get(open_files, path, &file);
    8001d48a:	00006797          	auipc	a5,0x6
    8001d48e:	11e78793          	addi	a5,a5,286 # 800235a8 <open_files>
    8001d492:	639c                	ld	a5,0(a5)
    8001d494:	f4040713          	addi	a4,s0,-192
    8001d498:	863a                	mv	a2,a4
    8001d49a:	eb843583          	ld	a1,-328(s0)
    8001d49e:	853e                	mv	a0,a5
    8001d4a0:	6de010ef          	jal	ra,8001eb7e <map_get>
        return file;
    8001d4a4:	f4043783          	ld	a5,-192(s0)
    8001d4a8:	a50d                	j	8001daca <vfs_open+0x812>
    }


    File *file = kmalloc(sizeof(File));
    8001d4aa:	08800513          	li	a0,136
    8001d4ae:	fe8f60ef          	jal	ra,80013c96 <kmalloc>
    8001d4b2:	fca43823          	sd	a0,-48(s0)
    memset(file, 0, sizeof(File));
    8001d4b6:	08800613          	li	a2,136
    8001d4ba:	4581                	li	a1,0
    8001d4bc:	fd043503          	ld	a0,-48(s0)
    8001d4c0:	0ad020ef          	jal	ra,8001fd6c <memset>
    file->path = kmalloc(strlen(path) + 1);
    8001d4c4:	eb843503          	ld	a0,-328(s0)
    8001d4c8:	032030ef          	jal	ra,800204fa <strlen>
    8001d4cc:	87aa                	mv	a5,a0
    8001d4ce:	0785                	addi	a5,a5,1
    8001d4d0:	853e                	mv	a0,a5
    8001d4d2:	fc4f60ef          	jal	ra,80013c96 <kmalloc>
    8001d4d6:	872a                	mv	a4,a0
    8001d4d8:	fd043783          	ld	a5,-48(s0)
    8001d4dc:	fbb8                	sd	a4,112(a5)
    strcpy(file->path, path);
    8001d4de:	fd043783          	ld	a5,-48(s0)
    8001d4e2:	7bbc                	ld	a5,112(a5)
    8001d4e4:	eb843583          	ld	a1,-328(s0)
    8001d4e8:	853e                	mv	a0,a5
    8001d4ea:	04e030ef          	jal	ra,80020538 <strcpy>
    file->flags = flags;
    8001d4ee:	fd043783          	ld	a5,-48(s0)
    8001d4f2:	eb043703          	ld	a4,-336(s0)
    8001d4f6:	f7b8                	sd	a4,104(a5)
    file->mode = mode;
    8001d4f8:	fd043783          	ld	a5,-48(s0)
    8001d4fc:	eae45703          	lhu	a4,-338(s0)
    8001d500:	04e79c23          	sh	a4,88(a5)
    file->type = type;
    8001d504:	fd043783          	ld	a5,-48(s0)
    8001d508:	eac45703          	lhu	a4,-340(s0)
    8001d50c:	00e79423          	sh	a4,8(a5)
    file->dev = vfs_get_mounted_device(path);
    8001d510:	eb843503          	ld	a0,-328(s0)
    8001d514:	9edff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001d518:	872a                	mv	a4,a0
    8001d51a:	fd043783          	ld	a5,-48(s0)
    8001d51e:	e398                	sd	a4,0(a5)

    char *path_relative_to_mount_point;
    // debugf("vfs_open: %s relative to mount point is %s\n", path, path_relative_to_mount_point);
    VirtioDevice *parent_device = vfs_get_mounted_device(path);
    8001d520:	eb843503          	ld	a0,-328(s0)
    8001d524:	9ddff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001d528:	fca43423          	sd	a0,-56(s0)
    debugf("vfs_open: parent device is %p\n", parent_device);
    char *block_device_name = path_file_name(path);
    8001d52c:	eb843503          	ld	a0,-328(s0)
    8001d530:	2d9010ef          	jal	ra,8001f008 <path_file_name>
    8001d534:	fca43023          	sd	a0,-64(s0)
    uint32_t block_device_num = mounted_device_count;
    8001d538:	00006797          	auipc	a5,0x6
    8001d53c:	07878793          	addi	a5,a5,120 # 800235b0 <mounted_device_count>
    8001d540:	639c                	ld	a5,0(a5)
    8001d542:	faf42e23          	sw	a5,-68(s0)
    char *parent_path = get_parent_path(path);
    8001d546:	eb843503          	ld	a0,-328(s0)
    8001d54a:	8b3ff0ef          	jal	ra,8001cdfc <get_parent_path>
    8001d54e:	faa43823          	sd	a0,-80(s0)
    debugf("vfs_open: parent path is %s\n", parent_path);
    DirEntry dir_entry;
    size_t i = 0;
    8001d552:	fa043423          	sd	zero,-88(s0)
    uint32_t free_dir_entry = 0;
    8001d556:	fa042223          	sw	zero,-92(s0)
    uint32_t parent_inode = 0;
    8001d55a:	fa042023          	sw	zero,-96(s0)

    bool is_parent_open = vfs_is_open(parent_path);
    8001d55e:	fb043503          	ld	a0,-80(s0)
    8001d562:	d0fff0ef          	jal	ra,8001d270 <vfs_is_open>
    8001d566:	87aa                	mv	a5,a0
    8001d568:	f8f40fa3          	sb	a5,-97(s0)
    debugf("vfs_open: parent is open: %u\n", is_parent_open);
    switch (type) {
    8001d56c:	eac45783          	lhu	a5,-340(s0)
    8001d570:	2781                	sext.w	a5,a5
    8001d572:	86be                	mv	a3,a5
    8001d574:	4741                	li	a4,16
    8001d576:	24e68e63          	beq	a3,a4,8001d7d2 <vfs_open+0x51a>
    8001d57a:	86be                	mv	a3,a5
    8001d57c:	4741                	li	a4,16
    8001d57e:	4ed74763          	blt	a4,a3,8001da6c <vfs_open+0x7b4>
    8001d582:	86be                	mv	a3,a5
    8001d584:	4709                	li	a4,2
    8001d586:	1ce68063          	beq	a3,a4,8001d746 <vfs_open+0x48e>
    8001d58a:	86be                	mv	a3,a5
    8001d58c:	4709                	li	a4,2
    8001d58e:	4cd74f63          	blt	a4,a3,8001da6c <vfs_open+0x7b4>
    8001d592:	c791                	beqz	a5,8001d59e <vfs_open+0x2e6>
    8001d594:	873e                	mv	a4,a5
    8001d596:	4785                	li	a5,1
    8001d598:	0cf70463          	beq	a4,a5,8001d660 <vfs_open+0x3a8>
    8001d59c:	a9c1                	j	8001da6c <vfs_open+0x7b4>
    case VFS_TYPE_INFER:
        // Infer the type from the minix3 type
        file->dev = vfs_get_mounted_device(path);
    8001d59e:	eb843503          	ld	a0,-328(s0)
    8001d5a2:	95fff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001d5a6:	872a                	mv	a4,a0
    8001d5a8:	fd043783          	ld	a5,-48(s0)
    8001d5ac:	e398                	sd	a4,0(a5)
        file->inode = minix3_get_inode_from_path(file->dev, file->path, false);
    8001d5ae:	fd043783          	ld	a5,-48(s0)
    8001d5b2:	6398                	ld	a4,0(a5)
    8001d5b4:	fd043783          	ld	a5,-48(s0)
    8001d5b8:	7bbc                	ld	a5,112(a5)
    8001d5ba:	4601                	li	a2,0
    8001d5bc:	85be                	mv	a1,a5
    8001d5be:	853a                	mv	a0,a4
    8001d5c0:	857f60ef          	jal	ra,80013e16 <minix3_get_inode_from_path>
    8001d5c4:	87aa                	mv	a5,a0
    8001d5c6:	0007871b          	sext.w	a4,a5
    8001d5ca:	fd043783          	ld	a5,-48(s0)
    8001d5ce:	c7f8                	sw	a4,76(a5)
        // file->inode_data = minix3_get_inode(file->dev, file->inode);
        // file->size = file->inode_data.size;

        // kfree(path_relative_to_mount_point);
        kfree(parent_path);
    8001d5d0:	fb043503          	ld	a0,-80(s0)
    8001d5d4:	f0af60ef          	jal	ra,80013cde <kfree>
        if (minix3_is_file(file->dev, file->inode)) {
    8001d5d8:	fd043783          	ld	a5,-48(s0)
    8001d5dc:	6398                	ld	a4,0(a5)
    8001d5de:	fd043783          	ld	a5,-48(s0)
    8001d5e2:	47fc                	lw	a5,76(a5)
    8001d5e4:	85be                	mv	a1,a5
    8001d5e6:	853a                	mv	a0,a4
    8001d5e8:	b99f70ef          	jal	ra,80015180 <minix3_is_file>
    8001d5ec:	87aa                	mv	a5,a0
    8001d5ee:	c789                	beqz	a5,8001d5f8 <vfs_open+0x340>
            debugf("vfs_open: %s is a file\n", path);
            type = VFS_TYPE_FILE;
    8001d5f0:	4785                	li	a5,1
    8001d5f2:	eaf41623          	sh	a5,-340(s0)
    8001d5f6:	a0b9                	j	8001d644 <vfs_open+0x38c>
        } else if (minix3_is_dir(file->dev, file->inode)) {
    8001d5f8:	fd043783          	ld	a5,-48(s0)
    8001d5fc:	6398                	ld	a4,0(a5)
    8001d5fe:	fd043783          	ld	a5,-48(s0)
    8001d602:	47fc                	lw	a5,76(a5)
    8001d604:	85be                	mv	a1,a5
    8001d606:	853a                	mv	a0,a4
    8001d608:	b09f70ef          	jal	ra,80015110 <minix3_is_dir>
    8001d60c:	87aa                	mv	a5,a0
    8001d60e:	c789                	beqz	a5,8001d618 <vfs_open+0x360>
            debugf("vfs_open: %s is a dir\n", path);
            type = VFS_TYPE_DIR;
    8001d610:	4789                	li	a5,2
    8001d612:	eaf41623          	sh	a5,-340(s0)
    8001d616:	a03d                	j	8001d644 <vfs_open+0x38c>
        } else if (minix3_is_block_device(file->dev, file->inode)) {
    8001d618:	fd043783          	ld	a5,-48(s0)
    8001d61c:	6398                	ld	a4,0(a5)
    8001d61e:	fd043783          	ld	a5,-48(s0)
    8001d622:	47fc                	lw	a5,76(a5)
    8001d624:	85be                	mv	a1,a5
    8001d626:	853a                	mv	a0,a4
    8001d628:	bc9f70ef          	jal	ra,800151f0 <minix3_is_block_device>
    8001d62c:	87aa                	mv	a5,a0
    8001d62e:	c789                	beqz	a5,8001d638 <vfs_open+0x380>
            debugf("vfs_open: %s is a block device\n", path);
            type = VFS_TYPE_BLOCK;
    8001d630:	47c1                	li	a5,16
    8001d632:	eaf41623          	sh	a5,-340(s0)
    8001d636:	a039                	j	8001d644 <vfs_open+0x38c>
        } else {
            debugf("vfs_open: could not infer type\n");
            kfree(file);
    8001d638:	fd043503          	ld	a0,-48(s0)
    8001d63c:	ea2f60ef          	jal	ra,80013cde <kfree>
            return NULL;
    8001d640:	4781                	li	a5,0
    8001d642:	a161                	j	8001daca <vfs_open+0x812>
        }
        return vfs_open(path, flags, mode, type);
    8001d644:	eac45703          	lhu	a4,-340(s0)
    8001d648:	eae45783          	lhu	a5,-338(s0)
    8001d64c:	86ba                	mv	a3,a4
    8001d64e:	863e                	mv	a2,a5
    8001d650:	eb043583          	ld	a1,-336(s0)
    8001d654:	eb843503          	ld	a0,-328(s0)
    8001d658:	c61ff0ef          	jal	ra,8001d2b8 <vfs_open>
    8001d65c:	87aa                	mv	a5,a0
    8001d65e:	a1b5                	j	8001daca <vfs_open+0x812>
        break;

    case VFS_TYPE_FILE:
        debugf("vfs_open: opening file\n");
        if (vfs_is_open(path)) {
    8001d660:	eb843503          	ld	a0,-328(s0)
    8001d664:	c0dff0ef          	jal	ra,8001d270 <vfs_is_open>
    8001d668:	87aa                	mv	a5,a0
    8001d66a:	c799                	beqz	a5,8001d678 <vfs_open+0x3c0>
            debugf("vfs_open: file is already open\n");
            return vfs_get_open_file(path);
    8001d66c:	eb843503          	ld	a0,-328(s0)
    8001d670:	b89ff0ef          	jal	ra,8001d1f8 <vfs_get_open_file>
    8001d674:	87aa                	mv	a5,a0
    8001d676:	a991                	j	8001daca <vfs_open+0x812>
        }
        if (!is_parent_open) {
    8001d678:	f9f44783          	lbu	a5,-97(s0)
    8001d67c:	0017c793          	xori	a5,a5,1
    8001d680:	0ff7f793          	andi	a5,a5,255
    8001d684:	cb99                	beqz	a5,8001d69a <vfs_open+0x3e2>
            debugf("vfs_open: parent is not open\n");
            vfs_open(parent_path, flags, mode, VFS_TYPE_INFER);
    8001d686:	eae45783          	lhu	a5,-338(s0)
    8001d68a:	4681                	li	a3,0
    8001d68c:	863e                	mv	a2,a5
    8001d68e:	eb043583          	ld	a1,-336(s0)
    8001d692:	fb043503          	ld	a0,-80(s0)
    8001d696:	c23ff0ef          	jal	ra,8001d2b8 <vfs_open>
            //     debugf("vfs_open: could not open parent %s\n", parent_path);
            //     return NULL;
            // }
        }

        file->dev = vfs_get_mounted_device(path);
    8001d69a:	eb843503          	ld	a0,-328(s0)
    8001d69e:	863ff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001d6a2:	872a                	mv	a4,a0
    8001d6a4:	fd043783          	ld	a5,-48(s0)
    8001d6a8:	e398                	sd	a4,0(a5)
        path_relative_to_mount_point = get_path_relative_to_mount_point(path);
    8001d6aa:	eb843503          	ld	a0,-328(s0)
    8001d6ae:	98bff0ef          	jal	ra,8001d038 <get_path_relative_to_mount_point>
    8001d6b2:	fca43c23          	sd	a0,-40(s0)
        debugf("vfs_open: device is %p\n", file->dev);
        file->inode = minix3_get_inode_from_path(file->dev, path_relative_to_mount_point, false);
    8001d6b6:	fd043783          	ld	a5,-48(s0)
    8001d6ba:	639c                	ld	a5,0(a5)
    8001d6bc:	4601                	li	a2,0
    8001d6be:	fd843583          	ld	a1,-40(s0)
    8001d6c2:	853e                	mv	a0,a5
    8001d6c4:	f52f60ef          	jal	ra,80013e16 <minix3_get_inode_from_path>
    8001d6c8:	87aa                	mv	a5,a0
    8001d6ca:	0007871b          	sext.w	a4,a5
    8001d6ce:	fd043783          	ld	a5,-48(s0)
    8001d6d2:	c7f8                	sw	a4,76(a5)
        file->inode_data = minix3_get_inode(file->dev, file->inode);
    8001d6d4:	fd043783          	ld	a5,-48(s0)
    8001d6d8:	6398                	ld	a4,0(a5)
    8001d6da:	fd043783          	ld	a5,-48(s0)
    8001d6de:	47f4                	lw	a3,76(a5)
    8001d6e0:	fd043483          	ld	s1,-48(s0)
    8001d6e4:	e6040793          	addi	a5,s0,-416
    8001d6e8:	8636                	mv	a2,a3
    8001d6ea:	85ba                	mv	a1,a4
    8001d6ec:	853e                	mv	a0,a5
    8001d6ee:	ef0f70ef          	jal	ra,80014dde <minix3_get_inode>
    8001d6f2:	00c48793          	addi	a5,s1,12
    8001d6f6:	e6040713          	addi	a4,s0,-416
    8001d6fa:	04000693          	li	a3,64
    8001d6fe:	8636                	mv	a2,a3
    8001d700:	85ba                	mv	a1,a4
    8001d702:	853e                	mv	a0,a5
    8001d704:	76a020ef          	jal	ra,8001fe6e <memcpy>
        file->size = file->inode_data.size;
    8001d708:	fd043783          	ld	a5,-48(s0)
    8001d70c:	4bdc                	lw	a5,20(a5)
    8001d70e:	02079713          	slli	a4,a5,0x20
    8001d712:	9301                	srli	a4,a4,0x20
    8001d714:	fd043783          	ld	a5,-48(s0)
    8001d718:	f3b8                	sd	a4,96(a5)
        file->is_file = true;
    8001d71a:	fd043783          	ld	a5,-48(s0)
    8001d71e:	4705                	li	a4,1
    8001d720:	06e78ca3          	sb	a4,121(a5)

        if (!is_parent_open) {
    8001d724:	f9f44783          	lbu	a5,-97(s0)
    8001d728:	0017c793          	xori	a5,a5,1
    8001d72c:	0ff7f793          	andi	a5,a5,255
    8001d730:	32078d63          	beqz	a5,8001da6a <vfs_open+0x7b2>
            debugf("vfs_open: closing parent %s\n", parent_path);
            vfs_close(vfs_get_open_file(parent_path));
    8001d734:	fb043503          	ld	a0,-80(s0)
    8001d738:	ac1ff0ef          	jal	ra,8001d1f8 <vfs_get_open_file>
    8001d73c:	87aa                	mv	a5,a0
    8001d73e:	853e                	mv	a0,a5
    8001d740:	396000ef          	jal	ra,8001dad6 <vfs_close>
        }

        break;
    8001d744:	a61d                	j	8001da6a <vfs_open+0x7b2>

    case VFS_TYPE_DIR:
        file->dev = vfs_get_mounted_device(path);
    8001d746:	eb843503          	ld	a0,-328(s0)
    8001d74a:	fb6ff0ef          	jal	ra,8001cf00 <vfs_get_mounted_device>
    8001d74e:	872a                	mv	a4,a0
    8001d750:	fd043783          	ld	a5,-48(s0)
    8001d754:	e398                	sd	a4,0(a5)
        path_relative_to_mount_point = get_path_relative_to_mount_point(path);
    8001d756:	eb843503          	ld	a0,-328(s0)
    8001d75a:	8dfff0ef          	jal	ra,8001d038 <get_path_relative_to_mount_point>
    8001d75e:	fca43c23          	sd	a0,-40(s0)
        file->inode = minix3_get_inode_from_path(file->dev, path_relative_to_mount_point, false);
    8001d762:	fd043783          	ld	a5,-48(s0)
    8001d766:	639c                	ld	a5,0(a5)
    8001d768:	4601                	li	a2,0
    8001d76a:	fd843583          	ld	a1,-40(s0)
    8001d76e:	853e                	mv	a0,a5
    8001d770:	ea6f60ef          	jal	ra,80013e16 <minix3_get_inode_from_path>
    8001d774:	87aa                	mv	a5,a0
    8001d776:	0007871b          	sext.w	a4,a5
    8001d77a:	fd043783          	ld	a5,-48(s0)
    8001d77e:	c7f8                	sw	a4,76(a5)
        file->inode_data = minix3_get_inode(file->dev, file->inode);
    8001d780:	fd043783          	ld	a5,-48(s0)
    8001d784:	6398                	ld	a4,0(a5)
    8001d786:	fd043783          	ld	a5,-48(s0)
    8001d78a:	47f4                	lw	a3,76(a5)
    8001d78c:	fd043483          	ld	s1,-48(s0)
    8001d790:	e6040793          	addi	a5,s0,-416
    8001d794:	8636                	mv	a2,a3
    8001d796:	85ba                	mv	a1,a4
    8001d798:	853e                	mv	a0,a5
    8001d79a:	e44f70ef          	jal	ra,80014dde <minix3_get_inode>
    8001d79e:	00c48793          	addi	a5,s1,12
    8001d7a2:	e6040713          	addi	a4,s0,-416
    8001d7a6:	04000693          	li	a3,64
    8001d7aa:	8636                	mv	a2,a3
    8001d7ac:	85ba                	mv	a1,a4
    8001d7ae:	853e                	mv	a0,a5
    8001d7b0:	6be020ef          	jal	ra,8001fe6e <memcpy>
        file->size = file->inode_data.size;
    8001d7b4:	fd043783          	ld	a5,-48(s0)
    8001d7b8:	4bdc                	lw	a5,20(a5)
    8001d7ba:	02079713          	slli	a4,a5,0x20
    8001d7be:	9301                	srli	a4,a4,0x20
    8001d7c0:	fd043783          	ld	a5,-48(s0)
    8001d7c4:	f3b8                	sd	a4,96(a5)
        file->is_dir = true;
    8001d7c6:	fd043783          	ld	a5,-48(s0)
    8001d7ca:	4705                	li	a4,1
    8001d7cc:	06e78c23          	sb	a4,120(a5)
        break;
    8001d7d0:	ac71                	j	8001da6c <vfs_open+0x7b4>
    
    case VFS_TYPE_BLOCK:
        // Read the filename
        debugf("vfs_open: block device name is %s\n", block_device_name);
        path_relative_to_mount_point = get_path_relative_to_mount_point(path);
    8001d7d2:	eb843503          	ld	a0,-328(s0)
    8001d7d6:	863ff0ef          	jal	ra,8001d038 <get_path_relative_to_mount_point>
    8001d7da:	fca43c23          	sd	a0,-40(s0)

        // Get the number of the block device
        debugf("vfs_open: block device number is %u\n", block_device_num);
        file->inode = minix3_get_inode_from_path(parent_device, path_relative_to_mount_point, false);
    8001d7de:	4601                	li	a2,0
    8001d7e0:	fd843583          	ld	a1,-40(s0)
    8001d7e4:	fc843503          	ld	a0,-56(s0)
    8001d7e8:	e2ef60ef          	jal	ra,80013e16 <minix3_get_inode_from_path>
    8001d7ec:	87aa                	mv	a5,a0
    8001d7ee:	0007871b          	sext.w	a4,a5
    8001d7f2:	fd043783          	ld	a5,-48(s0)
    8001d7f6:	c7f8                	sw	a4,76(a5)
        debugf("vfs_open: inode is %u\n", file->inode);

        if (file->inode == 0 && vfs_should_create_if_doesnt_exist(flags, mode, type)) {
    8001d7f8:	fd043783          	ld	a5,-48(s0)
    8001d7fc:	47fc                	lw	a5,76(a5)
    8001d7fe:	20079563          	bnez	a5,8001da08 <vfs_open+0x750>
    8001d802:	eac45703          	lhu	a4,-340(s0)
    8001d806:	eae45783          	lhu	a5,-338(s0)
    8001d80a:	863a                	mv	a2,a4
    8001d80c:	85be                	mv	a1,a5
    8001d80e:	eb043503          	ld	a0,-336(s0)
    8001d812:	98bff0ef          	jal	ra,8001d19c <vfs_should_create_if_doesnt_exist>
    8001d816:	87aa                	mv	a5,a0
    8001d818:	1e078863          	beqz	a5,8001da08 <vfs_open+0x750>
            debugf("vfs_open: creating block device\n");
            debugf("vfs_open: parent device is %p\n", parent_device);
            // Create the block device
            file->inode = minix3_alloc_inode(parent_device);
    8001d81c:	fc843503          	ld	a0,-56(s0)
    8001d820:	fa6f70ef          	jal	ra,80014fc6 <minix3_alloc_inode>
    8001d824:	87aa                	mv	a5,a0
    8001d826:	0007871b          	sext.w	a4,a5
    8001d82a:	fd043783          	ld	a5,-48(s0)
    8001d82e:	c7f8                	sw	a4,76(a5)
            debugf("vfs_open: created block device with inode %u\n", file->inode);
            file->inode_data = minix3_get_inode(parent_device, file->inode);
    8001d830:	fd043783          	ld	a5,-48(s0)
    8001d834:	47f8                	lw	a4,76(a5)
    8001d836:	fd043483          	ld	s1,-48(s0)
    8001d83a:	e6040793          	addi	a5,s0,-416
    8001d83e:	863a                	mv	a2,a4
    8001d840:	fc843583          	ld	a1,-56(s0)
    8001d844:	853e                	mv	a0,a5
    8001d846:	d98f70ef          	jal	ra,80014dde <minix3_get_inode>
    8001d84a:	00c48793          	addi	a5,s1,12
    8001d84e:	e6040713          	addi	a4,s0,-416
    8001d852:	04000693          	li	a3,64
    8001d856:	8636                	mv	a2,a3
    8001d858:	85ba                	mv	a1,a4
    8001d85a:	853e                	mv	a0,a5
    8001d85c:	612020ef          	jal	ra,8001fe6e <memcpy>
            file->inode_data.mode = S_IFBLK;
    8001d860:	fd043783          	ld	a5,-48(s0)
    8001d864:	6719                	lui	a4,0x6
    8001d866:	00e79623          	sh	a4,12(a5)
            file->inode_data.num_links = 1;
    8001d86a:	fd043783          	ld	a5,-48(s0)
    8001d86e:	4705                	li	a4,1
    8001d870:	00e79723          	sh	a4,14(a5)
            file->inode_data.uid = 0;
    8001d874:	fd043783          	ld	a5,-48(s0)
    8001d878:	00079823          	sh	zero,16(a5)
            file->inode_data.gid = 0;
    8001d87c:	fd043783          	ld	a5,-48(s0)
    8001d880:	00079923          	sh	zero,18(a5)
            file->inode_data.size = 0;
    8001d884:	fd043783          	ld	a5,-48(s0)
    8001d888:	0007aa23          	sw	zero,20(a5)
            file->inode_data.atime = 0;
    8001d88c:	fd043783          	ld	a5,-48(s0)
    8001d890:	0007ac23          	sw	zero,24(a5)
            file->inode_data.mtime = 0;
    8001d894:	fd043783          	ld	a5,-48(s0)
    8001d898:	0007ae23          	sw	zero,28(a5)
            file->inode_data.ctime = 0;
    8001d89c:	fd043783          	ld	a5,-48(s0)
    8001d8a0:	0207a023          	sw	zero,32(a5)
            minix3_put_inode(parent_device, file->inode, file->inode_data);
    8001d8a4:	fd043783          	ld	a5,-48(s0)
    8001d8a8:	47e4                	lw	s1,76(a5)
    8001d8aa:	fd043783          	ld	a5,-48(s0)
    8001d8ae:	e6040713          	addi	a4,s0,-416
    8001d8b2:	07b1                	addi	a5,a5,12
    8001d8b4:	04000693          	li	a3,64
    8001d8b8:	8636                	mv	a2,a3
    8001d8ba:	85be                	mv	a1,a5
    8001d8bc:	853a                	mv	a0,a4
    8001d8be:	5b0020ef          	jal	ra,8001fe6e <memcpy>
    8001d8c2:	e6040793          	addi	a5,s0,-416
    8001d8c6:	863e                	mv	a2,a5
    8001d8c8:	85a6                	mv	a1,s1
    8001d8ca:	fc843503          	ld	a0,-56(s0)
    8001d8ce:	e5cf70ef          	jal	ra,80014f2a <minix3_put_inode>
            debugf("vfs_open: put inode\n");

            parent_inode = minix3_get_inode_from_path(parent_device, path_relative_to_mount_point, true);
    8001d8d2:	4605                	li	a2,1
    8001d8d4:	fd843583          	ld	a1,-40(s0)
    8001d8d8:	fc843503          	ld	a0,-56(s0)
    8001d8dc:	d3af60ef          	jal	ra,80013e16 <minix3_get_inode_from_path>
    8001d8e0:	87aa                	mv	a5,a0
    8001d8e2:	faf42023          	sw	a5,-96(s0)
            debugf("vfs_open: parent inode is %u\n", parent_inode);

            // Create the directory entry
            DirEntry dir_entry;
            memset(&dir_entry, 0, sizeof(dir_entry));
    8001d8e6:	ec040793          	addi	a5,s0,-320
    8001d8ea:	04000613          	li	a2,64
    8001d8ee:	4581                	li	a1,0
    8001d8f0:	853e                	mv	a0,a5
    8001d8f2:	47a020ef          	jal	ra,8001fd6c <memset>
            dir_entry.inode = file->inode;
    8001d8f6:	fd043783          	ld	a5,-48(s0)
    8001d8fa:	47fc                	lw	a5,76(a5)
    8001d8fc:	ecf42023          	sw	a5,-320(s0)
            strcpy(dir_entry.name, block_device_name);
    8001d900:	ec040793          	addi	a5,s0,-320
    8001d904:	0791                	addi	a5,a5,4
    8001d906:	fc043583          	ld	a1,-64(s0)
    8001d90a:	853e                	mv	a0,a5
    8001d90c:	42d020ef          	jal	ra,80020538 <strcpy>
            debugf("vfs_open: created dir entry with inode %u and name %s\n", dir_entry.inode, dir_entry.name);

            // Find the next free directory entry
            free_dir_entry = minix3_find_next_free_dir_entry(parent_device, parent_inode);
    8001d910:	fa042783          	lw	a5,-96(s0)
    8001d914:	85be                	mv	a1,a5
    8001d916:	fc843503          	ld	a0,-56(s0)
    8001d91a:	ea0f90ef          	jal	ra,80016fba <minix3_find_next_free_dir_entry>
    8001d91e:	87aa                	mv	a5,a0
    8001d920:	faf42223          	sw	a5,-92(s0)
            debugf("vfs_open: found free dir entry %u\n", free_dir_entry);

            // Put the directory entry
            minix3_put_dir_entry(parent_device, parent_inode, free_dir_entry, dir_entry);
    8001d924:	ec043883          	ld	a7,-320(s0)
    8001d928:	ec843803          	ld	a6,-312(s0)
    8001d92c:	ed043503          	ld	a0,-304(s0)
    8001d930:	ed843583          	ld	a1,-296(s0)
    8001d934:	ee043603          	ld	a2,-288(s0)
    8001d938:	ee843683          	ld	a3,-280(s0)
    8001d93c:	ef043703          	ld	a4,-272(s0)
    8001d940:	ef843783          	ld	a5,-264(s0)
    8001d944:	e7143023          	sd	a7,-416(s0)
    8001d948:	e7043423          	sd	a6,-408(s0)
    8001d94c:	e6a43823          	sd	a0,-400(s0)
    8001d950:	e6b43c23          	sd	a1,-392(s0)
    8001d954:	e8c43023          	sd	a2,-384(s0)
    8001d958:	e8d43423          	sd	a3,-376(s0)
    8001d95c:	e8e43823          	sd	a4,-368(s0)
    8001d960:	e8f43c23          	sd	a5,-360(s0)
    8001d964:	e6040693          	addi	a3,s0,-416
    8001d968:	fa442703          	lw	a4,-92(s0)
    8001d96c:	fa042783          	lw	a5,-96(s0)
    8001d970:	863a                	mv	a2,a4
    8001d972:	85be                	mv	a1,a5
    8001d974:	fc843503          	ld	a0,-56(s0)
    8001d978:	fc2f90ef          	jal	ra,8001713a <minix3_put_dir_entry>
            debugf("vfs_open: put dir entry\n");

            // Create the inode
            Inode inode_data;
            memset(&inode_data, 0, sizeof(inode_data));
    8001d97c:	f0040793          	addi	a5,s0,-256
    8001d980:	04000613          	li	a2,64
    8001d984:	4581                	li	a1,0
    8001d986:	853e                	mv	a0,a5
    8001d988:	3e4020ef          	jal	ra,8001fd6c <memset>
            inode_data.mode = S_IFBLK;
    8001d98c:	6799                	lui	a5,0x6
    8001d98e:	f0f41023          	sh	a5,-256(s0)
            inode_data.num_links = 1;
    8001d992:	4785                	li	a5,1
    8001d994:	f0f41123          	sh	a5,-254(s0)
            inode_data.uid = 0;
    8001d998:	f0041223          	sh	zero,-252(s0)
            inode_data.gid = 0;
    8001d99c:	f0041323          	sh	zero,-250(s0)
            inode_data.size = 0;
    8001d9a0:	f0042423          	sw	zero,-248(s0)
            inode_data.atime = 0;
    8001d9a4:	f0042623          	sw	zero,-244(s0)
            inode_data.mtime = 0;
    8001d9a8:	f0042823          	sw	zero,-240(s0)
            inode_data.ctime = 0;
    8001d9ac:	f0042a23          	sw	zero,-236(s0)
            minix3_put_inode(parent_device, file->inode, inode_data);
    8001d9b0:	fd043783          	ld	a5,-48(s0)
    8001d9b4:	04c7a303          	lw	t1,76(a5) # 604c <i+0x602c>
    8001d9b8:	f0043883          	ld	a7,-256(s0)
    8001d9bc:	f0843803          	ld	a6,-248(s0)
    8001d9c0:	f1043503          	ld	a0,-240(s0)
    8001d9c4:	f1843583          	ld	a1,-232(s0)
    8001d9c8:	f2043603          	ld	a2,-224(s0)
    8001d9cc:	f2843683          	ld	a3,-216(s0)
    8001d9d0:	f3043703          	ld	a4,-208(s0)
    8001d9d4:	f3843783          	ld	a5,-200(s0)
    8001d9d8:	e7143023          	sd	a7,-416(s0)
    8001d9dc:	e7043423          	sd	a6,-408(s0)
    8001d9e0:	e6a43823          	sd	a0,-400(s0)
    8001d9e4:	e6b43c23          	sd	a1,-392(s0)
    8001d9e8:	e8c43023          	sd	a2,-384(s0)
    8001d9ec:	e8d43423          	sd	a3,-376(s0)
    8001d9f0:	e8e43823          	sd	a4,-368(s0)
    8001d9f4:	e8f43c23          	sd	a5,-360(s0)
    8001d9f8:	e6040793          	addi	a5,s0,-416
    8001d9fc:	863e                	mv	a2,a5
    8001d9fe:	859a                	mv	a1,t1
    8001da00:	fc843503          	ld	a0,-56(s0)
    8001da04:	d26f70ef          	jal	ra,80014f2a <minix3_put_inode>
        } else {
            debugf("vfs_open: not creating block device\n");
        }

        // Get the block device
        file->dev = virtio_get_block_device(block_device_num);
    8001da08:	fbc42783          	lw	a5,-68(s0)
    8001da0c:	17c2                	slli	a5,a5,0x30
    8001da0e:	93c1                	srli	a5,a5,0x30
    8001da10:	853e                	mv	a0,a5
    8001da12:	daffc0ef          	jal	ra,8001a7c0 <virtio_get_block_device>
    8001da16:	872a                	mv	a4,a0
    8001da18:	fd043783          	ld	a5,-48(s0)
    8001da1c:	e398                	sd	a4,0(a5)
        
        if (file->dev == NULL) {
    8001da1e:	fd043783          	ld	a5,-48(s0)
    8001da22:	639c                	ld	a5,0(a5)
    8001da24:	eb99                	bnez	a5,8001da3a <vfs_open+0x782>
            debugf("vfs_open: could not find block device\n");
            kfree(path_relative_to_mount_point);
    8001da26:	fd843503          	ld	a0,-40(s0)
    8001da2a:	ab4f60ef          	jal	ra,80013cde <kfree>
            kfree(parent_path);
    8001da2e:	fb043503          	ld	a0,-80(s0)
    8001da32:	aacf60ef          	jal	ra,80013cde <kfree>
            return NULL;
    8001da36:	4781                	li	a5,0
    8001da38:	a849                	j	8001daca <vfs_open+0x812>
        //     debugf("vfs_open: not a block device\n");
        //     debugf("vfs_open: mode is %x\n", file->inode_data.mode);
        //     return NULL;
        // }

        file->size = block_device_get_bytes(file->dev);
    8001da3a:	fd043783          	ld	a5,-48(s0)
    8001da3e:	639c                	ld	a5,0(a5)
    8001da40:	853e                	mv	a0,a5
    8001da42:	87dfe0ef          	jal	ra,8001c2be <block_device_get_bytes>
    8001da46:	872a                	mv	a4,a0
    8001da48:	fd043783          	ld	a5,-48(s0)
    8001da4c:	f3b8                	sd	a4,96(a5)
        file->is_block_device = true;
    8001da4e:	fd043783          	ld	a5,-48(s0)
    8001da52:	4705                	li	a4,1
    8001da54:	06e78e23          	sb	a4,124(a5)
        vfs_mount(file->dev, path);
    8001da58:	fd043783          	ld	a5,-48(s0)
    8001da5c:	639c                	ld	a5,0(a5)
    8001da5e:	eb843583          	ld	a1,-328(s0)
    8001da62:	853e                	mv	a0,a5
    8001da64:	c06ff0ef          	jal	ra,8001ce6a <vfs_mount>
        break;
    8001da68:	a011                	j	8001da6c <vfs_open+0x7b4>
        break;
    8001da6a:	0001                	nop
    }
    kfree(path_relative_to_mount_point);
    8001da6c:	fd843503          	ld	a0,-40(s0)
    8001da70:	a6ef60ef          	jal	ra,80013cde <kfree>
    kfree(parent_path);
    8001da74:	fb043503          	ld	a0,-80(s0)
    8001da78:	a66f60ef          	jal	ra,80013cde <kfree>

    // Insert the file into the open files map
    map_set(open_files, path, file);
    8001da7c:	00006797          	auipc	a5,0x6
    8001da80:	b2c78793          	addi	a5,a5,-1236 # 800235a8 <open_files>
    8001da84:	639c                	ld	a5,0(a5)
    8001da86:	fd043703          	ld	a4,-48(s0)
    8001da8a:	863a                	mv	a2,a4
    8001da8c:	eb843583          	ld	a1,-328(s0)
    8001da90:	853e                	mv	a0,a5
    8001da92:	02a010ef          	jal	ra,8001eabc <map_set>
    if (!map_contains(open_files, path)) {
    8001da96:	00006797          	auipc	a5,0x6
    8001da9a:	b1278793          	addi	a5,a5,-1262 # 800235a8 <open_files>
    8001da9e:	639c                	ld	a5,0(a5)
    8001daa0:	eb843583          	ld	a1,-328(s0)
    8001daa4:	853e                	mv	a0,a5
    8001daa6:	162010ef          	jal	ra,8001ec08 <map_contains>
    8001daaa:	87aa                	mv	a5,a0
    8001daac:	0017c793          	xori	a5,a5,1
    8001dab0:	0ff7f793          	andi	a5,a5,255
    8001dab4:	c399                	beqz	a5,8001daba <vfs_open+0x802>
        debugf("vfs_open: could not insert file into open files map\n");
        return NULL;
    8001dab6:	4781                	li	a5,0
    8001dab8:	a809                	j	8001daca <vfs_open+0x812>
    }

    // debugf("vfs_open: %d files open\n", map_size(open_files));
    debug_file(file);
    8001daba:	fd043503          	ld	a0,-48(s0)
    8001dabe:	d11fe0ef          	jal	ra,8001c7ce <debug_file>
    vfs_print_open_files();
    8001dac2:	8f6ff0ef          	jal	ra,8001cbb8 <vfs_print_open_files>
    return file;
    8001dac6:	fd043783          	ld	a5,-48(s0)
}
    8001daca:	853e                	mv	a0,a5
    8001dacc:	60fa                	ld	ra,408(sp)
    8001dace:	645a                	ld	s0,400(sp)
    8001dad0:	64ba                	ld	s1,392(sp)
    8001dad2:	611d                	addi	sp,sp,416
    8001dad4:	8082                	ret

000000008001dad6 <vfs_close>:

void vfs_close(File *file) {
    8001dad6:	1101                	addi	sp,sp,-32
    8001dad8:	ec06                	sd	ra,24(sp)
    8001dada:	e822                	sd	s0,16(sp)
    8001dadc:	1000                	addi	s0,sp,32
    8001dade:	fea43423          	sd	a0,-24(s0)
    debugf("vfs_close: closing %s\n", file->path);
    if (open_files == NULL) {
    8001dae2:	00006797          	auipc	a5,0x6
    8001dae6:	ac678793          	addi	a5,a5,-1338 # 800235a8 <open_files>
    8001daea:	639c                	ld	a5,0(a5)
    8001daec:	eb89                	bnez	a5,8001dafe <vfs_close+0x28>
        open_files = map_new();
    8001daee:	749000ef          	jal	ra,8001ea36 <map_new>
    8001daf2:	872a                	mv	a4,a0
    8001daf4:	00006797          	auipc	a5,0x6
    8001daf8:	ab478793          	addi	a5,a5,-1356 # 800235a8 <open_files>
    8001dafc:	e398                	sd	a4,0(a5)
    }
    if (!map_contains(open_files, file->path)) {
    8001dafe:	00006797          	auipc	a5,0x6
    8001db02:	aaa78793          	addi	a5,a5,-1366 # 800235a8 <open_files>
    8001db06:	6398                	ld	a4,0(a5)
    8001db08:	fe843783          	ld	a5,-24(s0)
    8001db0c:	7bbc                	ld	a5,112(a5)
    8001db0e:	85be                	mv	a1,a5
    8001db10:	853a                	mv	a0,a4
    8001db12:	0f6010ef          	jal	ra,8001ec08 <map_contains>
    8001db16:	87aa                	mv	a5,a0
    8001db18:	0017c793          	xori	a5,a5,1
    8001db1c:	0ff7f793          	andi	a5,a5,255
    8001db20:	eb95                	bnez	a5,8001db54 <vfs_close+0x7e>
        debugf("vfs_close: file is not open\n");
        return;
    }
    // Remove the file from the open files map
    map_remove(open_files, file->path);
    8001db22:	00006797          	auipc	a5,0x6
    8001db26:	a8678793          	addi	a5,a5,-1402 # 800235a8 <open_files>
    8001db2a:	6398                	ld	a4,0(a5)
    8001db2c:	fe843783          	ld	a5,-24(s0)
    8001db30:	7bbc                	ld	a5,112(a5)
    8001db32:	85be                	mv	a1,a5
    8001db34:	853a                	mv	a0,a4
    8001db36:	126010ef          	jal	ra,8001ec5c <map_remove>
    // debug_file(file);
    vfs_print_open_files();
    8001db3a:	87eff0ef          	jal	ra,8001cbb8 <vfs_print_open_files>
    kfree(file->path);
    8001db3e:	fe843783          	ld	a5,-24(s0)
    8001db42:	7bbc                	ld	a5,112(a5)
    8001db44:	853e                	mv	a0,a5
    8001db46:	998f60ef          	jal	ra,80013cde <kfree>
    kfree(file);
    8001db4a:	fe843503          	ld	a0,-24(s0)
    8001db4e:	990f60ef          	jal	ra,80013cde <kfree>
    8001db52:	a011                	j	8001db56 <vfs_close+0x80>
        return;
    8001db54:	0001                	nop
}
    8001db56:	60e2                	ld	ra,24(sp)
    8001db58:	6442                	ld	s0,16(sp)
    8001db5a:	6105                	addi	sp,sp,32
    8001db5c:	8082                	ret

000000008001db5e <vfs_stat>:
//     infof("Mapping %s to %u\n", path, inode);
//     map_set(mapped_paths, path, inode);
//     map_set_int(mapped_inodes, inode, (uintptr_t)path);
// }

int vfs_stat(File *file, Stat *stat) {
    8001db5e:	7159                	addi	sp,sp,-112
    8001db60:	f486                	sd	ra,104(sp)
    8001db62:	f0a2                	sd	s0,96(sp)
    8001db64:	1880                	addi	s0,sp,112
    8001db66:	f8a43c23          	sd	a0,-104(s0)
    8001db6a:	f8b43823          	sd	a1,-112(s0)
    VirtioDevice *block_device = file->dev;
    8001db6e:	f9843783          	ld	a5,-104(s0)
    8001db72:	639c                	ld	a5,0(a5)
    8001db74:	fef43423          	sd	a5,-24(s0)
    Inode data = minix3_get_inode(block_device, file->inode);
    8001db78:	f9843783          	ld	a5,-104(s0)
    8001db7c:	47f8                	lw	a4,76(a5)
    8001db7e:	fa840793          	addi	a5,s0,-88
    8001db82:	863a                	mv	a2,a4
    8001db84:	fe843583          	ld	a1,-24(s0)
    8001db88:	853e                	mv	a0,a5
    8001db8a:	a54f70ef          	jal	ra,80014dde <minix3_get_inode>
    stat->inode = file->inode;
    8001db8e:	f9843783          	ld	a5,-104(s0)
    8001db92:	47f8                	lw	a4,76(a5)
    8001db94:	f9043783          	ld	a5,-112(s0)
    8001db98:	c398                	sw	a4,0(a5)
    stat->mode = data.mode;
    8001db9a:	fa845703          	lhu	a4,-88(s0)
    8001db9e:	f9043783          	ld	a5,-112(s0)
    8001dba2:	00e79223          	sh	a4,4(a5)
    stat->num_link = data.num_links;
    8001dba6:	faa45703          	lhu	a4,-86(s0)
    8001dbaa:	f9043783          	ld	a5,-112(s0)
    8001dbae:	00e79323          	sh	a4,6(a5)
    stat->uid = data.uid;
    8001dbb2:	fac45783          	lhu	a5,-84(s0)
    8001dbb6:	0007871b          	sext.w	a4,a5
    8001dbba:	f9043783          	ld	a5,-112(s0)
    8001dbbe:	c798                	sw	a4,8(a5)
    stat->gid = data.gid;
    8001dbc0:	fae45783          	lhu	a5,-82(s0)
    8001dbc4:	0007871b          	sext.w	a4,a5
    8001dbc8:	f9043783          	ld	a5,-112(s0)
    8001dbcc:	c7d8                	sw	a4,12(a5)
    stat->size = data.size;
    8001dbce:	fb042703          	lw	a4,-80(s0)
    8001dbd2:	f9043783          	ld	a5,-112(s0)
    8001dbd6:	cb98                	sw	a4,16(a5)
    stat->atime = data.atime;
    8001dbd8:	fb442703          	lw	a4,-76(s0)
    8001dbdc:	f9043783          	ld	a5,-112(s0)
    8001dbe0:	cbd8                	sw	a4,20(a5)
    stat->mtime = data.mtime;
    8001dbe2:	fb842703          	lw	a4,-72(s0)
    8001dbe6:	f9043783          	ld	a5,-112(s0)
    8001dbea:	cf98                	sw	a4,24(a5)
    stat->ctime = data.ctime;
    8001dbec:	fbc42703          	lw	a4,-68(s0)
    8001dbf0:	f9043783          	ld	a5,-112(s0)
    8001dbf4:	cfd8                	sw	a4,28(a5)
    return 0;
    8001dbf6:	4781                	li	a5,0
}
    8001dbf8:	853e                	mv	a0,a5
    8001dbfa:	70a6                	ld	ra,104(sp)
    8001dbfc:	7406                	ld	s0,96(sp)
    8001dbfe:	6165                	addi	sp,sp,112
    8001dc00:	8082                	ret

000000008001dc02 <vfs_link>:

bool vfs_link(File *dir, File *file) {
    8001dc02:	7151                	addi	sp,sp,-240
    8001dc04:	f586                	sd	ra,232(sp)
    8001dc06:	f1a2                	sd	s0,224(sp)
    8001dc08:	1980                	addi	s0,sp,240
    8001dc0a:	f4a43c23          	sd	a0,-168(s0)
    8001dc0e:	f4b43823          	sd	a1,-176(s0)
    // uint32_t inode1 = minix3_get_inode_from_path(file1->path1, 0);
    // uint32_t inode2 = minix3_get_inode_from_path(path2, 1);
    VirtioDevice *block_device = dir->dev;
    8001dc12:	f5843783          	ld	a5,-168(s0)
    8001dc16:	639c                	ld	a5,0(a5)
    8001dc18:	fef43423          	sd	a5,-24(s0)

    // path1 must exist
    if (file->inode == INVALID_INODE) {
    8001dc1c:	f5043783          	ld	a5,-176(s0)
    8001dc20:	47fc                	lw	a5,76(a5)
    8001dc22:	e399                	bnez	a5,8001dc28 <vfs_link+0x26>
        debugf("vfs_link: file doesn't exist\n");
        return false;
    8001dc24:	4781                	li	a5,0
    8001dc26:	a2bd                	j	8001dd94 <vfs_link+0x192>
    }

    // path1 must not be a directory
    if (minix3_is_dir(block_device, file->inode)) {
    8001dc28:	f5043783          	ld	a5,-176(s0)
    8001dc2c:	47fc                	lw	a5,76(a5)
    8001dc2e:	85be                	mv	a1,a5
    8001dc30:	fe843503          	ld	a0,-24(s0)
    8001dc34:	cdcf70ef          	jal	ra,80015110 <minix3_is_dir>
    8001dc38:	87aa                	mv	a5,a0
    8001dc3a:	c399                	beqz	a5,8001dc40 <vfs_link+0x3e>
        debugf("vfs_link: file is a directory\n");
        return false;
    8001dc3c:	4781                	li	a5,0
    8001dc3e:	aa99                	j	8001dd94 <vfs_link+0x192>
    }

    // Parent of path2 must exist
    if (dir->inode == INVALID_INODE) {
    8001dc40:	f5843783          	ld	a5,-168(s0)
    8001dc44:	47fc                	lw	a5,76(a5)
    8001dc46:	e399                	bnez	a5,8001dc4c <vfs_link+0x4a>
        debugf("vfs_link: parent of dir doesn't exist\n");
        return false;
    8001dc48:	4781                	li	a5,0
    8001dc4a:	a2a9                	j	8001dd94 <vfs_link+0x192>
    }

    if (!minix3_is_dir(block_device, dir->inode)) {
    8001dc4c:	f5843783          	ld	a5,-168(s0)
    8001dc50:	47fc                	lw	a5,76(a5)
    8001dc52:	85be                	mv	a1,a5
    8001dc54:	fe843503          	ld	a0,-24(s0)
    8001dc58:	cb8f70ef          	jal	ra,80015110 <minix3_is_dir>
    8001dc5c:	87aa                	mv	a5,a0
    8001dc5e:	0017c793          	xori	a5,a5,1
    8001dc62:	0ff7f793          	andi	a5,a5,255
    8001dc66:	c399                	beqz	a5,8001dc6c <vfs_link+0x6a>
        debugf("vfs_link: parent of dir is not a directory\n");
        return false;
    8001dc68:	4781                	li	a5,0
    8001dc6a:	a22d                	j	8001dd94 <vfs_link+0x192>
    }

    DirEntry data;
    memset(&data, 0, sizeof(data));
    8001dc6c:	fa040793          	addi	a5,s0,-96
    8001dc70:	04000613          	li	a2,64
    8001dc74:	4581                	li	a1,0
    8001dc76:	853e                	mv	a0,a5
    8001dc78:	0f4020ef          	jal	ra,8001fd6c <memset>
    data.inode = file->inode;
    8001dc7c:	f5043783          	ld	a5,-176(s0)
    8001dc80:	47fc                	lw	a5,76(a5)
    8001dc82:	faf42023          	sw	a5,-96(s0)
    strcpy(data.name, path_file_name(dir->path));
    8001dc86:	f5843783          	ld	a5,-168(s0)
    8001dc8a:	7bbc                	ld	a5,112(a5)
    8001dc8c:	853e                	mv	a0,a5
    8001dc8e:	37a010ef          	jal	ra,8001f008 <path_file_name>
    8001dc92:	872a                	mv	a4,a0
    8001dc94:	fa040793          	addi	a5,s0,-96
    8001dc98:	0791                	addi	a5,a5,4
    8001dc9a:	85ba                	mv	a1,a4
    8001dc9c:	853e                	mv	a0,a5
    8001dc9e:	09b020ef          	jal	ra,80020538 <strcpy>
    uint32_t free_dir_entry = minix3_find_next_free_dir_entry(block_device, dir->inode);
    8001dca2:	f5843783          	ld	a5,-168(s0)
    8001dca6:	47fc                	lw	a5,76(a5)
    8001dca8:	85be                	mv	a1,a5
    8001dcaa:	fe843503          	ld	a0,-24(s0)
    8001dcae:	b0cf90ef          	jal	ra,80016fba <minix3_find_next_free_dir_entry>
    8001dcb2:	87aa                	mv	a5,a0
    8001dcb4:	fef42223          	sw	a5,-28(s0)
    minix3_put_dir_entry(block_device, dir->inode, free_dir_entry, data);
    8001dcb8:	f5843783          	ld	a5,-168(s0)
    8001dcbc:	04c7a303          	lw	t1,76(a5)
    8001dcc0:	fa043883          	ld	a7,-96(s0)
    8001dcc4:	fa843803          	ld	a6,-88(s0)
    8001dcc8:	fb043503          	ld	a0,-80(s0)
    8001dccc:	fb843583          	ld	a1,-72(s0)
    8001dcd0:	fc043603          	ld	a2,-64(s0)
    8001dcd4:	fc843683          	ld	a3,-56(s0)
    8001dcd8:	fd043703          	ld	a4,-48(s0)
    8001dcdc:	fd843783          	ld	a5,-40(s0)
    8001dce0:	f1143823          	sd	a7,-240(s0)
    8001dce4:	f1043c23          	sd	a6,-232(s0)
    8001dce8:	f2a43023          	sd	a0,-224(s0)
    8001dcec:	f2b43423          	sd	a1,-216(s0)
    8001dcf0:	f2c43823          	sd	a2,-208(s0)
    8001dcf4:	f2d43c23          	sd	a3,-200(s0)
    8001dcf8:	f4e43023          	sd	a4,-192(s0)
    8001dcfc:	f4f43423          	sd	a5,-184(s0)
    8001dd00:	f1040713          	addi	a4,s0,-240
    8001dd04:	fe442783          	lw	a5,-28(s0)
    8001dd08:	86ba                	mv	a3,a4
    8001dd0a:	863e                	mv	a2,a5
    8001dd0c:	859a                	mv	a1,t1
    8001dd0e:	fe843503          	ld	a0,-24(s0)
    8001dd12:	c28f90ef          	jal	ra,8001713a <minix3_put_dir_entry>

    Inode inode1_data = minix3_get_inode(block_device, file->inode);
    8001dd16:	f5043783          	ld	a5,-176(s0)
    8001dd1a:	47f8                	lw	a4,76(a5)
    8001dd1c:	f6040793          	addi	a5,s0,-160
    8001dd20:	863a                	mv	a2,a4
    8001dd22:	fe843583          	ld	a1,-24(s0)
    8001dd26:	853e                	mv	a0,a5
    8001dd28:	8b6f70ef          	jal	ra,80014dde <minix3_get_inode>
    inode1_data.num_links += 1;
    8001dd2c:	f6245783          	lhu	a5,-158(s0)
    8001dd30:	2785                	addiw	a5,a5,1
    8001dd32:	17c2                	slli	a5,a5,0x30
    8001dd34:	93c1                	srli	a5,a5,0x30
    8001dd36:	f6f41123          	sh	a5,-158(s0)
    minix3_put_inode(block_device, file->inode, inode1_data);
    8001dd3a:	f5043783          	ld	a5,-176(s0)
    8001dd3e:	04c7a303          	lw	t1,76(a5)
    8001dd42:	f6043883          	ld	a7,-160(s0)
    8001dd46:	f6843803          	ld	a6,-152(s0)
    8001dd4a:	f7043503          	ld	a0,-144(s0)
    8001dd4e:	f7843583          	ld	a1,-136(s0)
    8001dd52:	f8043603          	ld	a2,-128(s0)
    8001dd56:	f8843683          	ld	a3,-120(s0)
    8001dd5a:	f9043703          	ld	a4,-112(s0)
    8001dd5e:	f9843783          	ld	a5,-104(s0)
    8001dd62:	f1143823          	sd	a7,-240(s0)
    8001dd66:	f1043c23          	sd	a6,-232(s0)
    8001dd6a:	f2a43023          	sd	a0,-224(s0)
    8001dd6e:	f2b43423          	sd	a1,-216(s0)
    8001dd72:	f2c43823          	sd	a2,-208(s0)
    8001dd76:	f2d43c23          	sd	a3,-200(s0)
    8001dd7a:	f4e43023          	sd	a4,-192(s0)
    8001dd7e:	f4f43423          	sd	a5,-184(s0)
    8001dd82:	f1040793          	addi	a5,s0,-240
    8001dd86:	863e                	mv	a2,a5
    8001dd88:	859a                	mv	a1,t1
    8001dd8a:	fe843503          	ld	a0,-24(s0)
    8001dd8e:	99cf70ef          	jal	ra,80014f2a <minix3_put_inode>
    return true;
    8001dd92:	4785                	li	a5,1
}
    8001dd94:	853e                	mv	a0,a5
    8001dd96:	70ae                	ld	ra,232(sp)
    8001dd98:	740e                	ld	s0,224(sp)
    8001dd9a:	616d                	addi	sp,sp,240
    8001dd9c:	8082                	ret
	...

000000008001dda0 <_start>:
.section .text
.global _start
_start:
.option push
.option norelax
	la		sp, _stack_end
    8001dda0:	00012117          	auipc	sp,0x12
    8001dda4:	26010113          	addi	sp,sp,608 # 80030000 <_heap_start>
	la		gp, __global_pointer$
    8001dda8:	00005197          	auipc	gp,0x5
    8001ddac:	25818193          	addi	gp,gp,600 # 80023000 <kernel_mmu_table>
    # Unlike the SBI, we will be trap returning so that
    # we know the registers sstatus, sip, stvec, and sepc are
    # in a place where we expect them to be. We can just jump
    # into main (tail main) like the SBI, but this ensures the CSRs
    # are what we say they are instead of just assuming from the SBI.
	la		t0, main
    8001ddb0:	ffffb297          	auipc	t0,0xffffb
    8001ddb4:	99e28293          	addi	t0,t0,-1634 # 8001874e <main>
	csrw	sepc, t0
    8001ddb8:	14129073          	csrw	sepc,t0
	li		t0, 1 << 9
    8001ddbc:	20000293          	li	t0,512
	csrw	sie, t0
    8001ddc0:	10429073          	csrw	sie,t0
    # 1 << 13 - FS:  in the "initial" position
    # 1 << 8  - SPP: into Supervisor Mode
    # 1 << 5  - SPIE: enable interrupts
	li		t0, (1 << 13) | (1 << 8) | (1 << 5)
    8001ddc4:	6289                	lui	t0,0x2
    8001ddc6:	1202829b          	addiw	t0,t0,288
	csrw	sstatus, t0
    8001ddca:	10029073          	csrw	sstatus,t0
    # Load the return address (RA) to the park. When main
    # returns, it will park the HART.
	la		ra, park
    8001ddce:	00000097          	auipc	ra,0x0
    8001ddd2:	01208093          	addi	ra,ra,18 # 8001dde0 <park>
	csrr	a0, sscratch
    8001ddd6:	14002573          	csrr	a0,sscratch
	sret
    8001ddda:	10200073          	sret
    8001ddde:	0001                	nop

000000008001dde0 <park>:

.section .text
.global park
.align 4
park:
	wfi
    8001dde0:	10500073          	wfi
	j	park
    8001dde4:	bff5                	j	8001dde0 <park>

000000008001dde6 <park_end>:
	...

000000008001ddf4 <process_asm_run>:

.section .text
.global process_asm_run
process_asm_run:
    # a0 - Trap frame
    csrw    sscratch, a0
    8001ddf4:	14051073          	csrw	sscratch,a0
    tail    _spawn_kthread
    8001ddf8:	2080406f          	j	80022000 <_spawn_kthread>

000000008001ddfc <g_kmalloc>:
void *(*__global_kmalloc)(uint64_t size);
void *(*__global_kcalloc)(uint64_t num, uint64_t size);
void (*__global_kfree)(void *ptr);

void *g_kmalloc(uint64_t size)
{
    8001ddfc:	1101                	addi	sp,sp,-32
    8001ddfe:	ec06                	sd	ra,24(sp)
    8001de00:	e822                	sd	s0,16(sp)
    8001de02:	1000                	addi	s0,sp,32
    8001de04:	fea43423          	sd	a0,-24(s0)
    if (__global_kmalloc == NULL) {
    8001de08:	00005797          	auipc	a5,0x5
    8001de0c:	20878793          	addi	a5,a5,520 # 80023010 <__global_kmalloc>
    8001de10:	639c                	ld	a5,0(a5)
    8001de12:	e399                	bnez	a5,8001de18 <g_kmalloc+0x1c>
        return NULL;
    8001de14:	4781                	li	a5,0
    8001de16:	a811                	j	8001de2a <g_kmalloc+0x2e>
    }
    return __global_kmalloc(size);
    8001de18:	00005797          	auipc	a5,0x5
    8001de1c:	1f878793          	addi	a5,a5,504 # 80023010 <__global_kmalloc>
    8001de20:	639c                	ld	a5,0(a5)
    8001de22:	fe843503          	ld	a0,-24(s0)
    8001de26:	9782                	jalr	a5
    8001de28:	87aa                	mv	a5,a0
}
    8001de2a:	853e                	mv	a0,a5
    8001de2c:	60e2                	ld	ra,24(sp)
    8001de2e:	6442                	ld	s0,16(sp)
    8001de30:	6105                	addi	sp,sp,32
    8001de32:	8082                	ret

000000008001de34 <g_kcalloc>:
void *g_kcalloc(uint64_t num, uint64_t size)
{
    8001de34:	1101                	addi	sp,sp,-32
    8001de36:	ec06                	sd	ra,24(sp)
    8001de38:	e822                	sd	s0,16(sp)
    8001de3a:	1000                	addi	s0,sp,32
    8001de3c:	fea43423          	sd	a0,-24(s0)
    8001de40:	feb43023          	sd	a1,-32(s0)
    if (__global_kcalloc == NULL) {
    8001de44:	00005797          	auipc	a5,0x5
    8001de48:	1d478793          	addi	a5,a5,468 # 80023018 <__global_kcalloc>
    8001de4c:	639c                	ld	a5,0(a5)
    8001de4e:	e399                	bnez	a5,8001de54 <g_kcalloc+0x20>
        return NULL;
    8001de50:	4781                	li	a5,0
    8001de52:	a821                	j	8001de6a <g_kcalloc+0x36>
    }
    return __global_kcalloc(num, size);
    8001de54:	00005797          	auipc	a5,0x5
    8001de58:	1c478793          	addi	a5,a5,452 # 80023018 <__global_kcalloc>
    8001de5c:	639c                	ld	a5,0(a5)
    8001de5e:	fe043583          	ld	a1,-32(s0)
    8001de62:	fe843503          	ld	a0,-24(s0)
    8001de66:	9782                	jalr	a5
    8001de68:	87aa                	mv	a5,a0
}
    8001de6a:	853e                	mv	a0,a5
    8001de6c:	60e2                	ld	ra,24(sp)
    8001de6e:	6442                	ld	s0,16(sp)
    8001de70:	6105                	addi	sp,sp,32
    8001de72:	8082                	ret

000000008001de74 <g_kzalloc>:
void *g_kzalloc(uint64_t size)
{
    8001de74:	1101                	addi	sp,sp,-32
    8001de76:	ec06                	sd	ra,24(sp)
    8001de78:	e822                	sd	s0,16(sp)
    8001de7a:	1000                	addi	s0,sp,32
    8001de7c:	fea43423          	sd	a0,-24(s0)
    return g_kcalloc(1, size);
    8001de80:	fe843583          	ld	a1,-24(s0)
    8001de84:	4505                	li	a0,1
    8001de86:	fafff0ef          	jal	ra,8001de34 <g_kcalloc>
    8001de8a:	87aa                	mv	a5,a0
}
    8001de8c:	853e                	mv	a0,a5
    8001de8e:	60e2                	ld	ra,24(sp)
    8001de90:	6442                	ld	s0,16(sp)
    8001de92:	6105                	addi	sp,sp,32
    8001de94:	8082                	ret

000000008001de96 <g_kfree>:
void g_kfree(void *ptr)
{
    8001de96:	1101                	addi	sp,sp,-32
    8001de98:	ec06                	sd	ra,24(sp)
    8001de9a:	e822                	sd	s0,16(sp)
    8001de9c:	1000                	addi	s0,sp,32
    8001de9e:	fea43423          	sd	a0,-24(s0)
    if (__global_kfree != NULL) {
    8001dea2:	00005797          	auipc	a5,0x5
    8001dea6:	17e78793          	addi	a5,a5,382 # 80023020 <__global_kfree>
    8001deaa:	639c                	ld	a5,0(a5)
    8001deac:	cb89                	beqz	a5,8001debe <g_kfree+0x28>
        __global_kfree(ptr);
    8001deae:	00005797          	auipc	a5,0x5
    8001deb2:	17278793          	addi	a5,a5,370 # 80023020 <__global_kfree>
    8001deb6:	639c                	ld	a5,0(a5)
    8001deb8:	fe843503          	ld	a0,-24(s0)
    8001debc:	9782                	jalr	a5
    }
}
    8001debe:	0001                	nop
    8001dec0:	60e2                	ld	ra,24(sp)
    8001dec2:	6442                	ld	s0,16(sp)
    8001dec4:	6105                	addi	sp,sp,32
    8001dec6:	8082                	ret

000000008001dec8 <util_connect_galloc>:

void util_connect_galloc(void *(*malloc)(uint64_t size),
                         void *(*calloc)(uint64_t elem, uint64_t size), void (*free)(void *ptr))
{
    8001dec8:	7179                	addi	sp,sp,-48
    8001deca:	f422                	sd	s0,40(sp)
    8001decc:	1800                	addi	s0,sp,48
    8001dece:	fea43423          	sd	a0,-24(s0)
    8001ded2:	feb43023          	sd	a1,-32(s0)
    8001ded6:	fcc43c23          	sd	a2,-40(s0)
    __global_kmalloc = malloc;
    8001deda:	00005797          	auipc	a5,0x5
    8001dede:	13678793          	addi	a5,a5,310 # 80023010 <__global_kmalloc>
    8001dee2:	fe843703          	ld	a4,-24(s0)
    8001dee6:	e398                	sd	a4,0(a5)
    __global_kcalloc = calloc;
    8001dee8:	00005797          	auipc	a5,0x5
    8001deec:	13078793          	addi	a5,a5,304 # 80023018 <__global_kcalloc>
    8001def0:	fe043703          	ld	a4,-32(s0)
    8001def4:	e398                	sd	a4,0(a5)
    __global_kfree   = free;
    8001def6:	00005797          	auipc	a5,0x5
    8001defa:	12a78793          	addi	a5,a5,298 # 80023020 <__global_kfree>
    8001defe:	fd843703          	ld	a4,-40(s0)
    8001df02:	e398                	sd	a4,0(a5)
}
    8001df04:	0001                	nop
    8001df06:	7422                	ld	s0,40(sp)
    8001df08:	6145                	addi	sp,sp,48
    8001df0a:	8082                	ret

000000008001df0c <list_init>:
typedef struct List {
    ListElem head;
} List;

static List *list_init(List *lst)
{
    8001df0c:	1101                	addi	sp,sp,-32
    8001df0e:	ec22                	sd	s0,24(sp)
    8001df10:	1000                	addi	s0,sp,32
    8001df12:	fea43423          	sd	a0,-24(s0)
    lst->head.next = &lst->head;
    8001df16:	fe843703          	ld	a4,-24(s0)
    8001df1a:	fe843783          	ld	a5,-24(s0)
    8001df1e:	e798                	sd	a4,8(a5)
    lst->head.prev = &lst->head;
    8001df20:	fe843703          	ld	a4,-24(s0)
    8001df24:	fe843783          	ld	a5,-24(s0)
    8001df28:	eb98                	sd	a4,16(a5)

    return lst;
    8001df2a:	fe843783          	ld	a5,-24(s0)
}
    8001df2e:	853e                	mv	a0,a5
    8001df30:	6462                	ld	s0,24(sp)
    8001df32:	6105                	addi	sp,sp,32
    8001df34:	8082                	ret

000000008001df36 <list_new>:

List *list_new(void)
{
    8001df36:	1101                	addi	sp,sp,-32
    8001df38:	ec06                	sd	ra,24(sp)
    8001df3a:	e822                	sd	s0,16(sp)
    8001df3c:	1000                	addi	s0,sp,32
    List *m = (List *)g_kmalloc(sizeof(List));
    8001df3e:	4561                	li	a0,24
    8001df40:	ebdff0ef          	jal	ra,8001ddfc <g_kmalloc>
    8001df44:	fea43423          	sd	a0,-24(s0)
    if (m == NULL) {
    8001df48:	fe843783          	ld	a5,-24(s0)
    8001df4c:	e399                	bnez	a5,8001df52 <list_new+0x1c>
        return NULL;
    8001df4e:	4781                	li	a5,0
    8001df50:	a031                	j	8001df5c <list_new+0x26>
    }
    return list_init(m);
    8001df52:	fe843503          	ld	a0,-24(s0)
    8001df56:	fb7ff0ef          	jal	ra,8001df0c <list_init>
    8001df5a:	87aa                	mv	a5,a0
}
    8001df5c:	853e                	mv	a0,a5
    8001df5e:	60e2                	ld	ra,24(sp)
    8001df60:	6442                	ld	s0,16(sp)
    8001df62:	6105                	addi	sp,sp,32
    8001df64:	8082                	ret

000000008001df66 <list_add>:

void list_add(List *lst, uint64_t value)
{
    8001df66:	7179                	addi	sp,sp,-48
    8001df68:	f406                	sd	ra,40(sp)
    8001df6a:	f022                	sd	s0,32(sp)
    8001df6c:	1800                	addi	s0,sp,48
    8001df6e:	fca43c23          	sd	a0,-40(s0)
    8001df72:	fcb43823          	sd	a1,-48(s0)
    ListElem *l;
    l             = (ListElem *)g_kzalloc(sizeof(ListElem));
    8001df76:	4561                	li	a0,24
    8001df78:	efdff0ef          	jal	ra,8001de74 <g_kzalloc>
    8001df7c:	fea43423          	sd	a0,-24(s0)
    l->next       = lst->head.next;
    8001df80:	fd843783          	ld	a5,-40(s0)
    8001df84:	6798                	ld	a4,8(a5)
    8001df86:	fe843783          	ld	a5,-24(s0)
    8001df8a:	e798                	sd	a4,8(a5)
    l->prev       = &lst->head;
    8001df8c:	fd843703          	ld	a4,-40(s0)
    8001df90:	fe843783          	ld	a5,-24(s0)
    8001df94:	eb98                	sd	a4,16(a5)
    l->next->prev = l;
    8001df96:	fe843783          	ld	a5,-24(s0)
    8001df9a:	679c                	ld	a5,8(a5)
    8001df9c:	fe843703          	ld	a4,-24(s0)
    8001dfa0:	eb98                	sd	a4,16(a5)
    l->prev->next = l;
    8001dfa2:	fe843783          	ld	a5,-24(s0)
    8001dfa6:	6b9c                	ld	a5,16(a5)
    8001dfa8:	fe843703          	ld	a4,-24(s0)
    8001dfac:	e798                	sd	a4,8(a5)
    l->value      = value;
    8001dfae:	fe843783          	ld	a5,-24(s0)
    8001dfb2:	fd043703          	ld	a4,-48(s0)
    8001dfb6:	e398                	sd	a4,0(a5)
}
    8001dfb8:	0001                	nop
    8001dfba:	70a2                	ld	ra,40(sp)
    8001dfbc:	7402                	ld	s0,32(sp)
    8001dfbe:	6145                	addi	sp,sp,48
    8001dfc0:	8082                	ret

000000008001dfc2 <list_clear>:

void list_clear(List *lst)
{
    8001dfc2:	7179                	addi	sp,sp,-48
    8001dfc4:	f406                	sd	ra,40(sp)
    8001dfc6:	f022                	sd	s0,32(sp)
    8001dfc8:	1800                	addi	s0,sp,48
    8001dfca:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001dfce:	fd843783          	ld	a5,-40(s0)
    8001dfd2:	679c                	ld	a5,8(a5)
    8001dfd4:	fef43423          	sd	a5,-24(s0)
    8001dfd8:	a831                	j	8001dff4 <list_clear+0x32>
        n = e->next;
    8001dfda:	fe843783          	ld	a5,-24(s0)
    8001dfde:	679c                	ld	a5,8(a5)
    8001dfe0:	fef43023          	sd	a5,-32(s0)
        list_remove_elem(e);
    8001dfe4:	fe843503          	ld	a0,-24(s0)
    8001dfe8:	120000ef          	jal	ra,8001e108 <list_remove_elem>
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001dfec:	fe043783          	ld	a5,-32(s0)
    8001dff0:	fef43423          	sd	a5,-24(s0)
    8001dff4:	fd843783          	ld	a5,-40(s0)
    8001dff8:	fe843703          	ld	a4,-24(s0)
    8001dffc:	fcf71fe3          	bne	a4,a5,8001dfda <list_clear+0x18>
    }
}
    8001e000:	0001                	nop
    8001e002:	0001                	nop
    8001e004:	70a2                	ld	ra,40(sp)
    8001e006:	7402                	ld	s0,32(sp)
    8001e008:	6145                	addi	sp,sp,48
    8001e00a:	8082                	ret

000000008001e00c <list_sort>:

void list_sort(List *lst, LIST_COMPARATOR_PARAM(comp))
{
    8001e00c:	7139                	addi	sp,sp,-64
    8001e00e:	fc06                	sd	ra,56(sp)
    8001e010:	f822                	sd	s0,48(sp)
    8001e012:	0080                	addi	s0,sp,64
    8001e014:	fca43423          	sd	a0,-56(s0)
    8001e018:	fcb43023          	sd	a1,-64(s0)
    ListElem *e;
    bool swapped;
    uint64_t tmp;

    do {
        swapped = false;
    8001e01c:	fe0403a3          	sb	zero,-25(s0)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    8001e020:	fc843783          	ld	a5,-56(s0)
    8001e024:	6b9c                	ld	a5,16(a5)
    8001e026:	fef43423          	sd	a5,-24(s0)
    8001e02a:	a8a9                	j	8001e084 <list_sort+0x78>
            if (!comp(e->value, e->prev->value)) {
    8001e02c:	fe843783          	ld	a5,-24(s0)
    8001e030:	6398                	ld	a4,0(a5)
    8001e032:	fe843783          	ld	a5,-24(s0)
    8001e036:	6b9c                	ld	a5,16(a5)
    8001e038:	639c                	ld	a5,0(a5)
    8001e03a:	fc043683          	ld	a3,-64(s0)
    8001e03e:	85be                	mv	a1,a5
    8001e040:	853a                	mv	a0,a4
    8001e042:	9682                	jalr	a3
    8001e044:	87aa                	mv	a5,a0
    8001e046:	0017c793          	xori	a5,a5,1
    8001e04a:	0ff7f793          	andi	a5,a5,255
    8001e04e:	c795                	beqz	a5,8001e07a <list_sort+0x6e>
                swapped        = true;
    8001e050:	4785                	li	a5,1
    8001e052:	fef403a3          	sb	a5,-25(s0)
                tmp            = e->value;
    8001e056:	fe843783          	ld	a5,-24(s0)
    8001e05a:	639c                	ld	a5,0(a5)
    8001e05c:	fcf43c23          	sd	a5,-40(s0)
                e->value       = e->prev->value;
    8001e060:	fe843783          	ld	a5,-24(s0)
    8001e064:	6b9c                	ld	a5,16(a5)
    8001e066:	6398                	ld	a4,0(a5)
    8001e068:	fe843783          	ld	a5,-24(s0)
    8001e06c:	e398                	sd	a4,0(a5)
                e->prev->value = tmp;
    8001e06e:	fe843783          	ld	a5,-24(s0)
    8001e072:	6b9c                	ld	a5,16(a5)
    8001e074:	fd843703          	ld	a4,-40(s0)
    8001e078:	e398                	sd	a4,0(a5)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    8001e07a:	fe843783          	ld	a5,-24(s0)
    8001e07e:	6b9c                	ld	a5,16(a5)
    8001e080:	fef43423          	sd	a5,-24(s0)
    8001e084:	fe843783          	ld	a5,-24(s0)
    8001e088:	6b98                	ld	a4,16(a5)
    8001e08a:	fc843783          	ld	a5,-56(s0)
    8001e08e:	f8f71fe3          	bne	a4,a5,8001e02c <list_sort+0x20>
            }
        }
    } while (swapped);
    8001e092:	fe744783          	lbu	a5,-25(s0)
    8001e096:	0ff7f793          	andi	a5,a5,255
    8001e09a:	f3c9                	bnez	a5,8001e01c <list_sort+0x10>
}
    8001e09c:	0001                	nop
    8001e09e:	0001                	nop
    8001e0a0:	70e2                	ld	ra,56(sp)
    8001e0a2:	7442                	ld	s0,48(sp)
    8001e0a4:	6121                	addi	sp,sp,64
    8001e0a6:	8082                	ret

000000008001e0a8 <list_remove>:

bool list_remove(List *lst, uint64_t value)
{
    8001e0a8:	7179                	addi	sp,sp,-48
    8001e0aa:	f406                	sd	ra,40(sp)
    8001e0ac:	f022                	sd	s0,32(sp)
    8001e0ae:	1800                	addi	s0,sp,48
    8001e0b0:	fca43c23          	sd	a0,-40(s0)
    8001e0b4:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(lst, e)
    8001e0b8:	fd843503          	ld	a0,-40(s0)
    8001e0bc:	2ca000ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001e0c0:	fea43423          	sd	a0,-24(s0)
    8001e0c4:	a025                	j	8001e0ec <list_remove+0x44>
    {
        if (e->value == value) {
    8001e0c6:	fe843783          	ld	a5,-24(s0)
    8001e0ca:	639c                	ld	a5,0(a5)
    8001e0cc:	fd043703          	ld	a4,-48(s0)
    8001e0d0:	00f71863          	bne	a4,a5,8001e0e0 <list_remove+0x38>
            list_remove_elem(e);
    8001e0d4:	fe843503          	ld	a0,-24(s0)
    8001e0d8:	030000ef          	jal	ra,8001e108 <list_remove_elem>
            return true;
    8001e0dc:	4785                	li	a5,1
    8001e0de:	a005                	j	8001e0fe <list_remove+0x56>
    list_for_each(lst, e)
    8001e0e0:	fe843503          	ld	a0,-24(s0)
    8001e0e4:	2ea000ef          	jal	ra,8001e3ce <list_elem_prev>
    8001e0e8:	fea43423          	sd	a0,-24(s0)
    8001e0ec:	fe843583          	ld	a1,-24(s0)
    8001e0f0:	fd843503          	ld	a0,-40(s0)
    8001e0f4:	204000ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001e0f8:	87aa                	mv	a5,a0
    8001e0fa:	f7f1                	bnez	a5,8001e0c6 <list_remove+0x1e>
        }
    }
    return false;
    8001e0fc:	4781                	li	a5,0
}
    8001e0fe:	853e                	mv	a0,a5
    8001e100:	70a2                	ld	ra,40(sp)
    8001e102:	7402                	ld	s0,32(sp)
    8001e104:	6145                	addi	sp,sp,48
    8001e106:	8082                	ret

000000008001e108 <list_remove_elem>:

void list_remove_elem(ListElem *e)
{
    8001e108:	1101                	addi	sp,sp,-32
    8001e10a:	ec06                	sd	ra,24(sp)
    8001e10c:	e822                	sd	s0,16(sp)
    8001e10e:	1000                	addi	s0,sp,32
    8001e110:	fea43423          	sd	a0,-24(s0)
    e->next->prev = e->prev;
    8001e114:	fe843783          	ld	a5,-24(s0)
    8001e118:	679c                	ld	a5,8(a5)
    8001e11a:	fe843703          	ld	a4,-24(s0)
    8001e11e:	6b18                	ld	a4,16(a4)
    8001e120:	eb98                	sd	a4,16(a5)
    e->prev->next = e->next;
    8001e122:	fe843783          	ld	a5,-24(s0)
    8001e126:	6b9c                	ld	a5,16(a5)
    8001e128:	fe843703          	ld	a4,-24(s0)
    8001e12c:	6718                	ld	a4,8(a4)
    8001e12e:	e798                	sd	a4,8(a5)
    g_kfree(e);
    8001e130:	fe843503          	ld	a0,-24(s0)
    8001e134:	d63ff0ef          	jal	ra,8001de96 <g_kfree>
}
    8001e138:	0001                	nop
    8001e13a:	60e2                	ld	ra,24(sp)
    8001e13c:	6442                	ld	s0,16(sp)
    8001e13e:	6105                	addi	sp,sp,32
    8001e140:	8082                	ret

000000008001e142 <list_find_elem>:

ListElem *list_find_elem(List *l, uint64_t value)
{
    8001e142:	7179                	addi	sp,sp,-48
    8001e144:	f406                	sd	ra,40(sp)
    8001e146:	f022                	sd	s0,32(sp)
    8001e148:	1800                	addi	s0,sp,48
    8001e14a:	fca43c23          	sd	a0,-40(s0)
    8001e14e:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(l, e)
    8001e152:	fd843503          	ld	a0,-40(s0)
    8001e156:	230000ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001e15a:	fea43423          	sd	a0,-24(s0)
    8001e15e:	a00d                	j	8001e180 <list_find_elem+0x3e>
    {
        if (e->value == value) {
    8001e160:	fe843783          	ld	a5,-24(s0)
    8001e164:	639c                	ld	a5,0(a5)
    8001e166:	fd043703          	ld	a4,-48(s0)
    8001e16a:	00f71563          	bne	a4,a5,8001e174 <list_find_elem+0x32>
            return e;
    8001e16e:	fe843783          	ld	a5,-24(s0)
    8001e172:	a005                	j	8001e192 <list_find_elem+0x50>
    list_for_each(l, e)
    8001e174:	fe843503          	ld	a0,-24(s0)
    8001e178:	256000ef          	jal	ra,8001e3ce <list_elem_prev>
    8001e17c:	fea43423          	sd	a0,-24(s0)
    8001e180:	fe843583          	ld	a1,-24(s0)
    8001e184:	fd843503          	ld	a0,-40(s0)
    8001e188:	170000ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001e18c:	87aa                	mv	a5,a0
    8001e18e:	fbe9                	bnez	a5,8001e160 <list_find_elem+0x1e>
        }
    }
    return NULL;
    8001e190:	4781                	li	a5,0
}
    8001e192:	853e                	mv	a0,a5
    8001e194:	70a2                	ld	ra,40(sp)
    8001e196:	7402                	ld	s0,32(sp)
    8001e198:	6145                	addi	sp,sp,48
    8001e19a:	8082                	ret

000000008001e19c <list_contains>:

bool list_contains(const List *lst, uint64_t value)
{
    8001e19c:	7179                	addi	sp,sp,-48
    8001e19e:	f406                	sd	ra,40(sp)
    8001e1a0:	f022                	sd	s0,32(sp)
    8001e1a2:	1800                	addi	s0,sp,48
    8001e1a4:	fca43c23          	sd	a0,-40(s0)
    8001e1a8:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e = list_find_celem(lst, value);
    8001e1ac:	fd043583          	ld	a1,-48(s0)
    8001e1b0:	fd843503          	ld	a0,-40(s0)
    8001e1b4:	178000ef          	jal	ra,8001e32c <list_find_celem>
    8001e1b8:	fea43423          	sd	a0,-24(s0)

    return e == NULL ? false : true;
    8001e1bc:	fe843783          	ld	a5,-24(s0)
    8001e1c0:	00f037b3          	snez	a5,a5
    8001e1c4:	0ff7f793          	andi	a5,a5,255
}
    8001e1c8:	853e                	mv	a0,a5
    8001e1ca:	70a2                	ld	ra,40(sp)
    8001e1cc:	7402                	ld	s0,32(sp)
    8001e1ce:	6145                	addi	sp,sp,48
    8001e1d0:	8082                	ret

000000008001e1d2 <list_pop_back>:

ListElem *list_pop_back(List *l)
{
    8001e1d2:	7179                	addi	sp,sp,-48
    8001e1d4:	f406                	sd	ra,40(sp)
    8001e1d6:	f022                	sd	s0,32(sp)
    8001e1d8:	1800                	addi	s0,sp,48
    8001e1da:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.next) {
    8001e1de:	fd843703          	ld	a4,-40(s0)
    8001e1e2:	fd843783          	ld	a5,-40(s0)
    8001e1e6:	679c                	ld	a5,8(a5)
    8001e1e8:	00f71463          	bne	a4,a5,8001e1f0 <list_pop_back+0x1e>
        return NULL;
    8001e1ec:	4781                	li	a5,0
    8001e1ee:	a821                	j	8001e206 <list_pop_back+0x34>
    }
    ListElem *e = l->head.next;
    8001e1f0:	fd843783          	ld	a5,-40(s0)
    8001e1f4:	679c                	ld	a5,8(a5)
    8001e1f6:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    8001e1fa:	fe843503          	ld	a0,-24(s0)
    8001e1fe:	f0bff0ef          	jal	ra,8001e108 <list_remove_elem>
    return e;
    8001e202:	fe843783          	ld	a5,-24(s0)
}
    8001e206:	853e                	mv	a0,a5
    8001e208:	70a2                	ld	ra,40(sp)
    8001e20a:	7402                	ld	s0,32(sp)
    8001e20c:	6145                	addi	sp,sp,48
    8001e20e:	8082                	ret

000000008001e210 <list_pop>:

ListElem *list_pop(List *l)
{
    8001e210:	7179                	addi	sp,sp,-48
    8001e212:	f406                	sd	ra,40(sp)
    8001e214:	f022                	sd	s0,32(sp)
    8001e216:	1800                	addi	s0,sp,48
    8001e218:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.prev) {
    8001e21c:	fd843703          	ld	a4,-40(s0)
    8001e220:	fd843783          	ld	a5,-40(s0)
    8001e224:	6b9c                	ld	a5,16(a5)
    8001e226:	00f71463          	bne	a4,a5,8001e22e <list_pop+0x1e>
        return NULL;
    8001e22a:	4781                	li	a5,0
    8001e22c:	a821                	j	8001e244 <list_pop+0x34>
    }
    ListElem *e = l->head.prev;
    8001e22e:	fd843783          	ld	a5,-40(s0)
    8001e232:	6b9c                	ld	a5,16(a5)
    8001e234:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    8001e238:	fe843503          	ld	a0,-24(s0)
    8001e23c:	ecdff0ef          	jal	ra,8001e108 <list_remove_elem>
    return e;
    8001e240:	fe843783          	ld	a5,-24(s0)
}
    8001e244:	853e                	mv	a0,a5
    8001e246:	70a2                	ld	ra,40(sp)
    8001e248:	7402                	ld	s0,32(sp)
    8001e24a:	6145                	addi	sp,sp,48
    8001e24c:	8082                	ret

000000008001e24e <list_size>:

uint64_t list_size(const List *lst)
{
    8001e24e:	7179                	addi	sp,sp,-48
    8001e250:	f406                	sd	ra,40(sp)
    8001e252:	f022                	sd	s0,32(sp)
    8001e254:	1800                	addi	s0,sp,48
    8001e256:	fca43c23          	sd	a0,-40(s0)
    uint64_t s = 0;
    8001e25a:	fe043423          	sd	zero,-24(s0)
    const ListElem *e;
    list_for_ceach(lst, e)
    8001e25e:	fd843503          	ld	a0,-40(s0)
    8001e262:	19c000ef          	jal	ra,8001e3fe <list_celem_start_ascending>
    8001e266:	fea43023          	sd	a0,-32(s0)
    8001e26a:	a821                	j	8001e282 <list_size+0x34>
    {
        s += 1;
    8001e26c:	fe843783          	ld	a5,-24(s0)
    8001e270:	0785                	addi	a5,a5,1
    8001e272:	fef43423          	sd	a5,-24(s0)
    list_for_ceach(lst, e)
    8001e276:	fe043503          	ld	a0,-32(s0)
    8001e27a:	1cc000ef          	jal	ra,8001e446 <list_celem_prev>
    8001e27e:	fea43023          	sd	a0,-32(s0)
    8001e282:	fe043583          	ld	a1,-32(s0)
    8001e286:	fd843503          	ld	a0,-40(s0)
    8001e28a:	06e000ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001e28e:	87aa                	mv	a5,a0
    8001e290:	fff1                	bnez	a5,8001e26c <list_size+0x1e>
    }
    return s;
    8001e292:	fe843783          	ld	a5,-24(s0)
}
    8001e296:	853e                	mv	a0,a5
    8001e298:	70a2                	ld	ra,40(sp)
    8001e29a:	7402                	ld	s0,32(sp)
    8001e29c:	6145                	addi	sp,sp,48
    8001e29e:	8082                	ret

000000008001e2a0 <list_free>:

void list_free(List *lst)
{
    8001e2a0:	7179                	addi	sp,sp,-48
    8001e2a2:	f406                	sd	ra,40(sp)
    8001e2a4:	f022                	sd	s0,32(sp)
    8001e2a6:	1800                	addi	s0,sp,48
    8001e2a8:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    if (lst == NULL) {
    8001e2ac:	fd843783          	ld	a5,-40(s0)
    8001e2b0:	cf9d                	beqz	a5,8001e2ee <list_free+0x4e>
        return;
    }
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001e2b2:	fd843783          	ld	a5,-40(s0)
    8001e2b6:	679c                	ld	a5,8(a5)
    8001e2b8:	fef43423          	sd	a5,-24(s0)
    8001e2bc:	a831                	j	8001e2d8 <list_free+0x38>
        n = e->next;
    8001e2be:	fe843783          	ld	a5,-24(s0)
    8001e2c2:	679c                	ld	a5,8(a5)
    8001e2c4:	fef43023          	sd	a5,-32(s0)
        g_kfree(e);
    8001e2c8:	fe843503          	ld	a0,-24(s0)
    8001e2cc:	bcbff0ef          	jal	ra,8001de96 <g_kfree>
    for (e = lst->head.next; e != &lst->head; e = n) {
    8001e2d0:	fe043783          	ld	a5,-32(s0)
    8001e2d4:	fef43423          	sd	a5,-24(s0)
    8001e2d8:	fd843783          	ld	a5,-40(s0)
    8001e2dc:	fe843703          	ld	a4,-24(s0)
    8001e2e0:	fcf71fe3          	bne	a4,a5,8001e2be <list_free+0x1e>
    }
    g_kfree(lst);
    8001e2e4:	fd843503          	ld	a0,-40(s0)
    8001e2e8:	bafff0ef          	jal	ra,8001de96 <g_kfree>
    8001e2ec:	a011                	j	8001e2f0 <list_free+0x50>
        return;
    8001e2ee:	0001                	nop
}
    8001e2f0:	70a2                	ld	ra,40(sp)
    8001e2f2:	7402                	ld	s0,32(sp)
    8001e2f4:	6145                	addi	sp,sp,48
    8001e2f6:	8082                	ret

000000008001e2f8 <list_elem_valid>:

bool list_elem_valid(const List *l, const ListElem *e)
{
    8001e2f8:	1101                	addi	sp,sp,-32
    8001e2fa:	ec22                	sd	s0,24(sp)
    8001e2fc:	1000                	addi	s0,sp,32
    8001e2fe:	fea43423          	sd	a0,-24(s0)
    8001e302:	feb43023          	sd	a1,-32(s0)
    return e != NULL && e != &l->head;
    8001e306:	fe043783          	ld	a5,-32(s0)
    8001e30a:	cb89                	beqz	a5,8001e31c <list_elem_valid+0x24>
    8001e30c:	fe843783          	ld	a5,-24(s0)
    8001e310:	fe043703          	ld	a4,-32(s0)
    8001e314:	00f70463          	beq	a4,a5,8001e31c <list_elem_valid+0x24>
    8001e318:	4785                	li	a5,1
    8001e31a:	a011                	j	8001e31e <list_elem_valid+0x26>
    8001e31c:	4781                	li	a5,0
    8001e31e:	8b85                	andi	a5,a5,1
    8001e320:	0ff7f793          	andi	a5,a5,255
}
    8001e324:	853e                	mv	a0,a5
    8001e326:	6462                	ld	s0,24(sp)
    8001e328:	6105                	addi	sp,sp,32
    8001e32a:	8082                	ret

000000008001e32c <list_find_celem>:

const ListElem *list_find_celem(const List *l, uint64_t value) 
{
    8001e32c:	7179                	addi	sp,sp,-48
    8001e32e:	f406                	sd	ra,40(sp)
    8001e330:	f022                	sd	s0,32(sp)
    8001e332:	1800                	addi	s0,sp,48
    8001e334:	fca43c23          	sd	a0,-40(s0)
    8001e338:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e;
    list_for_ceach(l, e) 
    8001e33c:	fd843503          	ld	a0,-40(s0)
    8001e340:	0be000ef          	jal	ra,8001e3fe <list_celem_start_ascending>
    8001e344:	fea43423          	sd	a0,-24(s0)
    8001e348:	a00d                	j	8001e36a <list_find_celem+0x3e>
    {
        if (e->value == value) {
    8001e34a:	fe843783          	ld	a5,-24(s0)
    8001e34e:	639c                	ld	a5,0(a5)
    8001e350:	fd043703          	ld	a4,-48(s0)
    8001e354:	00f71563          	bne	a4,a5,8001e35e <list_find_celem+0x32>
            return e;
    8001e358:	fe843783          	ld	a5,-24(s0)
    8001e35c:	a005                	j	8001e37c <list_find_celem+0x50>
    list_for_ceach(l, e) 
    8001e35e:	fe843503          	ld	a0,-24(s0)
    8001e362:	0e4000ef          	jal	ra,8001e446 <list_celem_prev>
    8001e366:	fea43423          	sd	a0,-24(s0)
    8001e36a:	fe843583          	ld	a1,-24(s0)
    8001e36e:	fd843503          	ld	a0,-40(s0)
    8001e372:	f87ff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001e376:	87aa                	mv	a5,a0
    8001e378:	fbe9                	bnez	a5,8001e34a <list_find_celem+0x1e>
        }
    }
    return NULL;
    8001e37a:	4781                	li	a5,0
}
    8001e37c:	853e                	mv	a0,a5
    8001e37e:	70a2                	ld	ra,40(sp)
    8001e380:	7402                	ld	s0,32(sp)
    8001e382:	6145                	addi	sp,sp,48
    8001e384:	8082                	ret

000000008001e386 <list_elem_start_ascending>:

ListElem *list_elem_start_ascending(List *l)
{
    8001e386:	1101                	addi	sp,sp,-32
    8001e388:	ec22                	sd	s0,24(sp)
    8001e38a:	1000                	addi	s0,sp,32
    8001e38c:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    8001e390:	fe843783          	ld	a5,-24(s0)
    8001e394:	6b9c                	ld	a5,16(a5)
}
    8001e396:	853e                	mv	a0,a5
    8001e398:	6462                	ld	s0,24(sp)
    8001e39a:	6105                	addi	sp,sp,32
    8001e39c:	8082                	ret

000000008001e39e <list_elem_start_descending>:

ListElem *list_elem_start_descending(List *l)
{
    8001e39e:	1101                	addi	sp,sp,-32
    8001e3a0:	ec22                	sd	s0,24(sp)
    8001e3a2:	1000                	addi	s0,sp,32
    8001e3a4:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    8001e3a8:	fe843783          	ld	a5,-24(s0)
    8001e3ac:	679c                	ld	a5,8(a5)
}
    8001e3ae:	853e                	mv	a0,a5
    8001e3b0:	6462                	ld	s0,24(sp)
    8001e3b2:	6105                	addi	sp,sp,32
    8001e3b4:	8082                	ret

000000008001e3b6 <list_elem_next>:

ListElem *list_elem_next(ListElem *e)
{
    8001e3b6:	1101                	addi	sp,sp,-32
    8001e3b8:	ec22                	sd	s0,24(sp)
    8001e3ba:	1000                	addi	s0,sp,32
    8001e3bc:	fea43423          	sd	a0,-24(s0)
    return e->next;
    8001e3c0:	fe843783          	ld	a5,-24(s0)
    8001e3c4:	679c                	ld	a5,8(a5)
}
    8001e3c6:	853e                	mv	a0,a5
    8001e3c8:	6462                	ld	s0,24(sp)
    8001e3ca:	6105                	addi	sp,sp,32
    8001e3cc:	8082                	ret

000000008001e3ce <list_elem_prev>:

ListElem *list_elem_prev(ListElem *e)
{
    8001e3ce:	1101                	addi	sp,sp,-32
    8001e3d0:	ec22                	sd	s0,24(sp)
    8001e3d2:	1000                	addi	s0,sp,32
    8001e3d4:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    8001e3d8:	fe843783          	ld	a5,-24(s0)
    8001e3dc:	6b9c                	ld	a5,16(a5)
}
    8001e3de:	853e                	mv	a0,a5
    8001e3e0:	6462                	ld	s0,24(sp)
    8001e3e2:	6105                	addi	sp,sp,32
    8001e3e4:	8082                	ret

000000008001e3e6 <list_elem_value>:

uint64_t list_elem_value(const ListElem *e)
{
    8001e3e6:	1101                	addi	sp,sp,-32
    8001e3e8:	ec22                	sd	s0,24(sp)
    8001e3ea:	1000                	addi	s0,sp,32
    8001e3ec:	fea43423          	sd	a0,-24(s0)
    return e->value;
    8001e3f0:	fe843783          	ld	a5,-24(s0)
    8001e3f4:	639c                	ld	a5,0(a5)
}
    8001e3f6:	853e                	mv	a0,a5
    8001e3f8:	6462                	ld	s0,24(sp)
    8001e3fa:	6105                	addi	sp,sp,32
    8001e3fc:	8082                	ret

000000008001e3fe <list_celem_start_ascending>:

const ListElem *list_celem_start_ascending(const List *l) {
    8001e3fe:	1101                	addi	sp,sp,-32
    8001e400:	ec22                	sd	s0,24(sp)
    8001e402:	1000                	addi	s0,sp,32
    8001e404:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    8001e408:	fe843783          	ld	a5,-24(s0)
    8001e40c:	6b9c                	ld	a5,16(a5)
}
    8001e40e:	853e                	mv	a0,a5
    8001e410:	6462                	ld	s0,24(sp)
    8001e412:	6105                	addi	sp,sp,32
    8001e414:	8082                	ret

000000008001e416 <list_celem_start_descending>:
const ListElem *list_celem_start_descending(const List *l) {
    8001e416:	1101                	addi	sp,sp,-32
    8001e418:	ec22                	sd	s0,24(sp)
    8001e41a:	1000                	addi	s0,sp,32
    8001e41c:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    8001e420:	fe843783          	ld	a5,-24(s0)
    8001e424:	679c                	ld	a5,8(a5)
}
    8001e426:	853e                	mv	a0,a5
    8001e428:	6462                	ld	s0,24(sp)
    8001e42a:	6105                	addi	sp,sp,32
    8001e42c:	8082                	ret

000000008001e42e <list_celem_next>:
const ListElem *list_celem_next(const ListElem *e) {
    8001e42e:	1101                	addi	sp,sp,-32
    8001e430:	ec22                	sd	s0,24(sp)
    8001e432:	1000                	addi	s0,sp,32
    8001e434:	fea43423          	sd	a0,-24(s0)
    return e->next;
    8001e438:	fe843783          	ld	a5,-24(s0)
    8001e43c:	679c                	ld	a5,8(a5)
}
    8001e43e:	853e                	mv	a0,a5
    8001e440:	6462                	ld	s0,24(sp)
    8001e442:	6105                	addi	sp,sp,32
    8001e444:	8082                	ret

000000008001e446 <list_celem_prev>:
const ListElem *list_celem_prev(const ListElem *e) {
    8001e446:	1101                	addi	sp,sp,-32
    8001e448:	ec22                	sd	s0,24(sp)
    8001e44a:	1000                	addi	s0,sp,32
    8001e44c:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    8001e450:	fe843783          	ld	a5,-24(s0)
    8001e454:	6b9c                	ld	a5,16(a5)
}
    8001e456:	853e                	mv	a0,a5
    8001e458:	6462                	ld	s0,24(sp)
    8001e45a:	6105                	addi	sp,sp,32
    8001e45c:	8082                	ret

000000008001e45e <list_sort_signed_long_comparator_ascending>:

// Default list comparators
LIST_COMPARATOR(list_sort_signed_long_comparator_ascending)
{
    8001e45e:	1101                	addi	sp,sp,-32
    8001e460:	ec22                	sd	s0,24(sp)
    8001e462:	1000                	addi	s0,sp,32
    8001e464:	fea43423          	sd	a0,-24(s0)
    8001e468:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    8001e46c:	fe843703          	ld	a4,-24(s0)
    8001e470:	fe043783          	ld	a5,-32(s0)
    8001e474:	00e7a7b3          	slt	a5,a5,a4
    8001e478:	0017c793          	xori	a5,a5,1
    8001e47c:	0ff7f793          	andi	a5,a5,255
}
    8001e480:	853e                	mv	a0,a5
    8001e482:	6462                	ld	s0,24(sp)
    8001e484:	6105                	addi	sp,sp,32
    8001e486:	8082                	ret

000000008001e488 <list_sort_signed_long_comparator_descending>:
LIST_COMPARATOR(list_sort_signed_long_comparator_descending)
{
    8001e488:	1101                	addi	sp,sp,-32
    8001e48a:	ec22                	sd	s0,24(sp)
    8001e48c:	1000                	addi	s0,sp,32
    8001e48e:	fea43423          	sd	a0,-24(s0)
    8001e492:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    8001e496:	fe843703          	ld	a4,-24(s0)
    8001e49a:	fe043783          	ld	a5,-32(s0)
    8001e49e:	00f727b3          	slt	a5,a4,a5
    8001e4a2:	0017c793          	xori	a5,a5,1
    8001e4a6:	0ff7f793          	andi	a5,a5,255
}
    8001e4aa:	853e                	mv	a0,a5
    8001e4ac:	6462                	ld	s0,24(sp)
    8001e4ae:	6105                	addi	sp,sp,32
    8001e4b0:	8082                	ret

000000008001e4b2 <list_sort_unsigned_long_comparator_ascending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_ascending)
{
    8001e4b2:	1101                	addi	sp,sp,-32
    8001e4b4:	ec22                	sd	s0,24(sp)
    8001e4b6:	1000                	addi	s0,sp,32
    8001e4b8:	fea43423          	sd	a0,-24(s0)
    8001e4bc:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    8001e4c0:	fe843703          	ld	a4,-24(s0)
    8001e4c4:	fe043783          	ld	a5,-32(s0)
    8001e4c8:	00e7b7b3          	sltu	a5,a5,a4
    8001e4cc:	0017c793          	xori	a5,a5,1
    8001e4d0:	0ff7f793          	andi	a5,a5,255
}
    8001e4d4:	853e                	mv	a0,a5
    8001e4d6:	6462                	ld	s0,24(sp)
    8001e4d8:	6105                	addi	sp,sp,32
    8001e4da:	8082                	ret

000000008001e4dc <list_sort_unsigned_long_comparator_descending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_descending)
{
    8001e4dc:	1101                	addi	sp,sp,-32
    8001e4de:	ec22                	sd	s0,24(sp)
    8001e4e0:	1000                	addi	s0,sp,32
    8001e4e2:	fea43423          	sd	a0,-24(s0)
    8001e4e6:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    8001e4ea:	fe843703          	ld	a4,-24(s0)
    8001e4ee:	fe043783          	ld	a5,-32(s0)
    8001e4f2:	00f737b3          	sltu	a5,a4,a5
    8001e4f6:	0017c793          	xori	a5,a5,1
    8001e4fa:	0ff7f793          	andi	a5,a5,255
}
    8001e4fe:	853e                	mv	a0,a5
    8001e500:	6462                	ld	s0,24(sp)
    8001e502:	6105                	addi	sp,sp,32
    8001e504:	8082                	ret

000000008001e506 <list_sort_string_comparator_ascending>:
LIST_COMPARATOR(list_sort_string_comparator_ascending)
{
    8001e506:	1101                	addi	sp,sp,-32
    8001e508:	ec06                	sd	ra,24(sp)
    8001e50a:	e822                	sd	s0,16(sp)
    8001e50c:	1000                	addi	s0,sp,32
    8001e50e:	fea43423          	sd	a0,-24(s0)
    8001e512:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    8001e516:	fe843783          	ld	a5,-24(s0)
    8001e51a:	fe043703          	ld	a4,-32(s0)
    8001e51e:	85ba                	mv	a1,a4
    8001e520:	853e                	mv	a0,a5
    8001e522:	4db010ef          	jal	ra,800201fc <strcmp>
    8001e526:	87aa                	mv	a5,a0
    8001e528:	0017a793          	slti	a5,a5,1
    8001e52c:	0ff7f793          	andi	a5,a5,255
}
    8001e530:	853e                	mv	a0,a5
    8001e532:	60e2                	ld	ra,24(sp)
    8001e534:	6442                	ld	s0,16(sp)
    8001e536:	6105                	addi	sp,sp,32
    8001e538:	8082                	ret

000000008001e53a <list_sort_string_comparator_descending>:
LIST_COMPARATOR(list_sort_string_comparator_descending)
{
    8001e53a:	1101                	addi	sp,sp,-32
    8001e53c:	ec06                	sd	ra,24(sp)
    8001e53e:	e822                	sd	s0,16(sp)
    8001e540:	1000                	addi	s0,sp,32
    8001e542:	fea43423          	sd	a0,-24(s0)
    8001e546:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    8001e54a:	fe843783          	ld	a5,-24(s0)
    8001e54e:	fe043703          	ld	a4,-32(s0)
    8001e552:	85ba                	mv	a1,a4
    8001e554:	853e                	mv	a0,a5
    8001e556:	4a7010ef          	jal	ra,800201fc <strcmp>
    8001e55a:	87aa                	mv	a5,a0
    8001e55c:	fff7c793          	not	a5,a5
    8001e560:	01f7d79b          	srliw	a5,a5,0x1f
    8001e564:	0ff7f793          	andi	a5,a5,255
}
    8001e568:	853e                	mv	a0,a5
    8001e56a:	60e2                	ld	ra,24(sp)
    8001e56c:	6442                	ld	s0,16(sp)
    8001e56e:	6105                	addi	sp,sp,32
    8001e570:	8082                	ret

000000008001e572 <fnv1a_digest_64>:
#define FNV1_64_OFFSET  14695981039346656037UL
#define FNV1_64_PRIME   1099511628211UL

// FNV-1a hashing
static uint64_t fnv1a_digest_64(const char *key)
{
    8001e572:	7179                	addi	sp,sp,-48
    8001e574:	f422                	sd	s0,40(sp)
    8001e576:	1800                	addi	s0,sp,48
    8001e578:	fca43c23          	sd	a0,-40(s0)
    uint64_t digest = FNV1_64_OFFSET;
    8001e57c:	00008797          	auipc	a5,0x8
    8001e580:	27c78793          	addi	a5,a5,636 # 800267f8 <trampoline_trap_size+0xf>
    8001e584:	639c                	ld	a5,0(a5)
    8001e586:	fef43423          	sd	a5,-24(s0)
    const unsigned char *k;

    for (k = (unsigned char *)key; *k; k += 1) {
    8001e58a:	fd843783          	ld	a5,-40(s0)
    8001e58e:	fef43023          	sd	a5,-32(s0)
    8001e592:	a035                	j	8001e5be <fnv1a_digest_64+0x4c>
        digest = (digest ^ *k) * FNV1_64_PRIME;
    8001e594:	fe043783          	ld	a5,-32(s0)
    8001e598:	0007c783          	lbu	a5,0(a5)
    8001e59c:	873e                	mv	a4,a5
    8001e59e:	fe843783          	ld	a5,-24(s0)
    8001e5a2:	8f3d                	xor	a4,a4,a5
    8001e5a4:	4785                	li	a5,1
    8001e5a6:	17a2                	slli	a5,a5,0x28
    8001e5a8:	1b378793          	addi	a5,a5,435
    8001e5ac:	02f707b3          	mul	a5,a4,a5
    8001e5b0:	fef43423          	sd	a5,-24(s0)
    for (k = (unsigned char *)key; *k; k += 1) {
    8001e5b4:	fe043783          	ld	a5,-32(s0)
    8001e5b8:	0785                	addi	a5,a5,1
    8001e5ba:	fef43023          	sd	a5,-32(s0)
    8001e5be:	fe043783          	ld	a5,-32(s0)
    8001e5c2:	0007c783          	lbu	a5,0(a5)
    8001e5c6:	f7f9                	bnez	a5,8001e594 <fnv1a_digest_64+0x22>
    }
    return digest;
    8001e5c8:	fe843783          	ld	a5,-24(s0)
}
    8001e5cc:	853e                	mv	a0,a5
    8001e5ce:	7422                	ld	s0,40(sp)
    8001e5d0:	6145                	addi	sp,sp,48
    8001e5d2:	8082                	ret

000000008001e5d4 <map_int_to_str>:


// We need to store 20 digits, a possible negative sign, and the NULL-terminator
#define STR_KEY_SIZE 64
static char *map_int_to_str(char dst[], long n)
{
    8001e5d4:	7139                	addi	sp,sp,-64
    8001e5d6:	fc22                	sd	s0,56(sp)
    8001e5d8:	0080                	addi	s0,sp,64
    8001e5da:	fca43423          	sd	a0,-56(s0)
    8001e5de:	fcb43023          	sd	a1,-64(s0)
    char *const ret = dst;
    8001e5e2:	fc843783          	ld	a5,-56(s0)
    8001e5e6:	fef43023          	sd	a5,-32(s0)
    int i;
    int j;
    if (n == 0) {
    8001e5ea:	fc043783          	ld	a5,-64(s0)
    8001e5ee:	ef99                	bnez	a5,8001e60c <map_int_to_str+0x38>
        dst[0] = '0';
    8001e5f0:	fc843783          	ld	a5,-56(s0)
    8001e5f4:	03000713          	li	a4,48
    8001e5f8:	00e78023          	sb	a4,0(a5)
        dst[1] = '\0';
    8001e5fc:	fc843783          	ld	a5,-56(s0)
    8001e600:	0785                	addi	a5,a5,1
    8001e602:	00078023          	sb	zero,0(a5)
        return ret;
    8001e606:	fe043783          	ld	a5,-32(s0)
    8001e60a:	aa29                	j	8001e724 <map_int_to_str+0x150>
    }
    if (n < 0) {
    8001e60c:	fc043783          	ld	a5,-64(s0)
    8001e610:	0207d263          	bgez	a5,8001e634 <map_int_to_str+0x60>
        // Advance the pointer so that when we flip,
        // we don't flip the negative sign.
        *dst++ = '-';
    8001e614:	fc843783          	ld	a5,-56(s0)
    8001e618:	00178713          	addi	a4,a5,1
    8001e61c:	fce43423          	sd	a4,-56(s0)
    8001e620:	02d00713          	li	a4,45
    8001e624:	00e78023          	sb	a4,0(a5)
        n = -n;
    8001e628:	fc043783          	ld	a5,-64(s0)
    8001e62c:	40f007b3          	neg	a5,a5
    8001e630:	fcf43023          	sd	a5,-64(s0)
    }
    // We can get the one's place by modding by 10, but
    // this stores the number backwards.
    for (i = 0;i < (STR_KEY_SIZE - 2) && n > 0;i += 1, n /= 10) {
    8001e634:	fe042623          	sw	zero,-20(s0)
    8001e638:	a83d                	j	8001e676 <map_int_to_str+0xa2>
        dst[i] = (char)(n % 10) + '0';
    8001e63a:	fc043703          	ld	a4,-64(s0)
    8001e63e:	47a9                	li	a5,10
    8001e640:	02f767b3          	rem	a5,a4,a5
    8001e644:	0ff7f713          	andi	a4,a5,255
    8001e648:	fec42783          	lw	a5,-20(s0)
    8001e64c:	fc843683          	ld	a3,-56(s0)
    8001e650:	97b6                	add	a5,a5,a3
    8001e652:	0307071b          	addiw	a4,a4,48
    8001e656:	0ff77713          	andi	a4,a4,255
    8001e65a:	00e78023          	sb	a4,0(a5)
    for (i = 0;i < (STR_KEY_SIZE - 2) && n > 0;i += 1, n /= 10) {
    8001e65e:	fec42783          	lw	a5,-20(s0)
    8001e662:	2785                	addiw	a5,a5,1
    8001e664:	fef42623          	sw	a5,-20(s0)
    8001e668:	fc043703          	ld	a4,-64(s0)
    8001e66c:	47a9                	li	a5,10
    8001e66e:	02f747b3          	div	a5,a4,a5
    8001e672:	fcf43023          	sd	a5,-64(s0)
    8001e676:	fec42783          	lw	a5,-20(s0)
    8001e67a:	0007871b          	sext.w	a4,a5
    8001e67e:	03d00793          	li	a5,61
    8001e682:	00e7c663          	blt	a5,a4,8001e68e <map_int_to_str+0xba>
    8001e686:	fc043783          	ld	a5,-64(s0)
    8001e68a:	faf048e3          	bgtz	a5,8001e63a <map_int_to_str+0x66>
    }
    // Flip the number back into order.
    for (j = 0;j < i / 2;j+=1) {
    8001e68e:	fe042423          	sw	zero,-24(s0)
    8001e692:	a095                	j	8001e6f6 <map_int_to_str+0x122>
        char c;
        c = dst[j];
    8001e694:	fe842783          	lw	a5,-24(s0)
    8001e698:	fc843703          	ld	a4,-56(s0)
    8001e69c:	97ba                	add	a5,a5,a4
    8001e69e:	0007c783          	lbu	a5,0(a5)
    8001e6a2:	fcf40fa3          	sb	a5,-33(s0)
        dst[j] = dst[i - j - 1];
    8001e6a6:	fec42703          	lw	a4,-20(s0)
    8001e6aa:	fe842783          	lw	a5,-24(s0)
    8001e6ae:	40f707bb          	subw	a5,a4,a5
    8001e6b2:	2781                	sext.w	a5,a5
    8001e6b4:	17fd                	addi	a5,a5,-1
    8001e6b6:	fc843703          	ld	a4,-56(s0)
    8001e6ba:	973e                	add	a4,a4,a5
    8001e6bc:	fe842783          	lw	a5,-24(s0)
    8001e6c0:	fc843683          	ld	a3,-56(s0)
    8001e6c4:	97b6                	add	a5,a5,a3
    8001e6c6:	00074703          	lbu	a4,0(a4) # 6000 <i+0x5fe0>
    8001e6ca:	00e78023          	sb	a4,0(a5)
        dst[i - j - 1] = c;
    8001e6ce:	fec42703          	lw	a4,-20(s0)
    8001e6d2:	fe842783          	lw	a5,-24(s0)
    8001e6d6:	40f707bb          	subw	a5,a4,a5
    8001e6da:	2781                	sext.w	a5,a5
    8001e6dc:	17fd                	addi	a5,a5,-1
    8001e6de:	fc843703          	ld	a4,-56(s0)
    8001e6e2:	97ba                	add	a5,a5,a4
    8001e6e4:	fdf44703          	lbu	a4,-33(s0)
    8001e6e8:	00e78023          	sb	a4,0(a5)
    for (j = 0;j < i / 2;j+=1) {
    8001e6ec:	fe842783          	lw	a5,-24(s0)
    8001e6f0:	2785                	addiw	a5,a5,1
    8001e6f2:	fef42423          	sw	a5,-24(s0)
    8001e6f6:	fec42783          	lw	a5,-20(s0)
    8001e6fa:	01f7d71b          	srliw	a4,a5,0x1f
    8001e6fe:	9fb9                	addw	a5,a5,a4
    8001e700:	4017d79b          	sraiw	a5,a5,0x1
    8001e704:	0007871b          	sext.w	a4,a5
    8001e708:	fe842783          	lw	a5,-24(s0)
    8001e70c:	2781                	sext.w	a5,a5
    8001e70e:	f8e7c3e3          	blt	a5,a4,8001e694 <map_int_to_str+0xc0>
    }
    dst[i] = '\0';
    8001e712:	fec42783          	lw	a5,-20(s0)
    8001e716:	fc843703          	ld	a4,-56(s0)
    8001e71a:	97ba                	add	a5,a5,a4
    8001e71c:	00078023          	sb	zero,0(a5)
    return ret;
    8001e720:	fe043783          	ld	a5,-32(s0)
}
    8001e724:	853e                	mv	a0,a5
    8001e726:	7462                	ld	s0,56(sp)
    8001e728:	6121                	addi	sp,sp,64
    8001e72a:	8082                	ret

000000008001e72c <map_get_elem>:

static MapElem *map_get_elem(Map *map, const char *key)
{
    8001e72c:	7139                	addi	sp,sp,-64
    8001e72e:	fc06                	sd	ra,56(sp)
    8001e730:	f822                	sd	s0,48(sp)
    8001e732:	0080                	addi	s0,sp,64
    8001e734:	fca43423          	sd	a0,-56(s0)
    8001e738:	fcb43023          	sd	a1,-64(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001e73c:	fc043503          	ld	a0,-64(s0)
    8001e740:	e33ff0ef          	jal	ra,8001e572 <fnv1a_digest_64>
    8001e744:	872a                	mv	a4,a0
    8001e746:	fc843783          	ld	a5,-56(s0)
    8001e74a:	439c                	lw	a5,0(a5)
    8001e74c:	1782                	slli	a5,a5,0x20
    8001e74e:	9381                	srli	a5,a5,0x20
    8001e750:	02f777b3          	remu	a5,a4,a5
    8001e754:	fef43023          	sd	a5,-32(s0)
    ListElem *e;
    MapElem *me;

    list_for_each_ascending(map->values[idx], e)
    8001e758:	fc843783          	ld	a5,-56(s0)
    8001e75c:	6798                	ld	a4,8(a5)
    8001e75e:	fe043783          	ld	a5,-32(s0)
    8001e762:	078e                	slli	a5,a5,0x3
    8001e764:	97ba                	add	a5,a5,a4
    8001e766:	639c                	ld	a5,0(a5)
    8001e768:	853e                	mv	a0,a5
    8001e76a:	c1dff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001e76e:	fea43423          	sd	a0,-24(s0)
    8001e772:	a81d                	j	8001e7a8 <map_get_elem+0x7c>
    {
        me = list_elem_value_ptr(e);
    8001e774:	fe843503          	ld	a0,-24(s0)
    8001e778:	c6fff0ef          	jal	ra,8001e3e6 <list_elem_value>
    8001e77c:	87aa                	mv	a5,a0
    8001e77e:	fcf43c23          	sd	a5,-40(s0)
        if (!strcmp(key, me->key)) {
    8001e782:	fd843783          	ld	a5,-40(s0)
    8001e786:	639c                	ld	a5,0(a5)
    8001e788:	85be                	mv	a1,a5
    8001e78a:	fc043503          	ld	a0,-64(s0)
    8001e78e:	26f010ef          	jal	ra,800201fc <strcmp>
    8001e792:	87aa                	mv	a5,a0
    8001e794:	e781                	bnez	a5,8001e79c <map_get_elem+0x70>
            return me;
    8001e796:	fd843783          	ld	a5,-40(s0)
    8001e79a:	a03d                	j	8001e7c8 <map_get_elem+0x9c>
    list_for_each_ascending(map->values[idx], e)
    8001e79c:	fe843503          	ld	a0,-24(s0)
    8001e7a0:	c2fff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001e7a4:	fea43423          	sd	a0,-24(s0)
    8001e7a8:	fc843783          	ld	a5,-56(s0)
    8001e7ac:	6798                	ld	a4,8(a5)
    8001e7ae:	fe043783          	ld	a5,-32(s0)
    8001e7b2:	078e                	slli	a5,a5,0x3
    8001e7b4:	97ba                	add	a5,a5,a4
    8001e7b6:	639c                	ld	a5,0(a5)
    8001e7b8:	fe843583          	ld	a1,-24(s0)
    8001e7bc:	853e                	mv	a0,a5
    8001e7be:	b3bff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001e7c2:	87aa                	mv	a5,a0
    8001e7c4:	fbc5                	bnez	a5,8001e774 <map_get_elem+0x48>
        }
    }

    return NULL;
    8001e7c6:	4781                	li	a5,0
}
    8001e7c8:	853e                	mv	a0,a5
    8001e7ca:	70e2                	ld	ra,56(sp)
    8001e7cc:	7442                	ld	s0,48(sp)
    8001e7ce:	6121                	addi	sp,sp,64
    8001e7d0:	8082                	ret

000000008001e7d2 <map_get_celem>:

static const MapElem *map_get_celem(const Map *map, const char *key)
{
    8001e7d2:	7139                	addi	sp,sp,-64
    8001e7d4:	fc06                	sd	ra,56(sp)
    8001e7d6:	f822                	sd	s0,48(sp)
    8001e7d8:	0080                	addi	s0,sp,64
    8001e7da:	fca43423          	sd	a0,-56(s0)
    8001e7de:	fcb43023          	sd	a1,-64(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001e7e2:	fc043503          	ld	a0,-64(s0)
    8001e7e6:	d8dff0ef          	jal	ra,8001e572 <fnv1a_digest_64>
    8001e7ea:	872a                	mv	a4,a0
    8001e7ec:	fc843783          	ld	a5,-56(s0)
    8001e7f0:	439c                	lw	a5,0(a5)
    8001e7f2:	1782                	slli	a5,a5,0x20
    8001e7f4:	9381                	srli	a5,a5,0x20
    8001e7f6:	02f777b3          	remu	a5,a4,a5
    8001e7fa:	fef43023          	sd	a5,-32(s0)
    ListElem *e;
    const MapElem *me;

    list_for_each_ascending(map->values[idx], e)
    8001e7fe:	fc843783          	ld	a5,-56(s0)
    8001e802:	6798                	ld	a4,8(a5)
    8001e804:	fe043783          	ld	a5,-32(s0)
    8001e808:	078e                	slli	a5,a5,0x3
    8001e80a:	97ba                	add	a5,a5,a4
    8001e80c:	639c                	ld	a5,0(a5)
    8001e80e:	853e                	mv	a0,a5
    8001e810:	b77ff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001e814:	fea43423          	sd	a0,-24(s0)
    8001e818:	a81d                	j	8001e84e <map_get_celem+0x7c>
    {
        me = list_celem_value_ptr(e);
    8001e81a:	fe843503          	ld	a0,-24(s0)
    8001e81e:	bc9ff0ef          	jal	ra,8001e3e6 <list_elem_value>
    8001e822:	87aa                	mv	a5,a0
    8001e824:	fcf43c23          	sd	a5,-40(s0)
        if (!strcmp(key, me->key)) {
    8001e828:	fd843783          	ld	a5,-40(s0)
    8001e82c:	639c                	ld	a5,0(a5)
    8001e82e:	85be                	mv	a1,a5
    8001e830:	fc043503          	ld	a0,-64(s0)
    8001e834:	1c9010ef          	jal	ra,800201fc <strcmp>
    8001e838:	87aa                	mv	a5,a0
    8001e83a:	e781                	bnez	a5,8001e842 <map_get_celem+0x70>
            return me;
    8001e83c:	fd843783          	ld	a5,-40(s0)
    8001e840:	a03d                	j	8001e86e <map_get_celem+0x9c>
    list_for_each_ascending(map->values[idx], e)
    8001e842:	fe843503          	ld	a0,-24(s0)
    8001e846:	b89ff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001e84a:	fea43423          	sd	a0,-24(s0)
    8001e84e:	fc843783          	ld	a5,-56(s0)
    8001e852:	6798                	ld	a4,8(a5)
    8001e854:	fe043783          	ld	a5,-32(s0)
    8001e858:	078e                	slli	a5,a5,0x3
    8001e85a:	97ba                	add	a5,a5,a4
    8001e85c:	639c                	ld	a5,0(a5)
    8001e85e:	fe843583          	ld	a1,-24(s0)
    8001e862:	853e                	mv	a0,a5
    8001e864:	a95ff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001e868:	87aa                	mv	a5,a0
    8001e86a:	fbc5                	bnez	a5,8001e81a <map_get_celem+0x48>
        }
    }

    return NULL;
    8001e86c:	4781                	li	a5,0
}
    8001e86e:	853e                	mv	a0,a5
    8001e870:	70e2                	ld	ra,56(sp)
    8001e872:	7442                	ld	s0,48(sp)
    8001e874:	6121                	addi	sp,sp,64
    8001e876:	8082                	ret

000000008001e878 <mapelem_set_val>:

static void mapelem_set_val(MapElem *me, MapValue val) {
    8001e878:	1101                	addi	sp,sp,-32
    8001e87a:	ec22                	sd	s0,24(sp)
    8001e87c:	1000                	addi	s0,sp,32
    8001e87e:	fea43423          	sd	a0,-24(s0)
    8001e882:	feb43023          	sd	a1,-32(s0)
    me->val = val;
    8001e886:	fe843783          	ld	a5,-24(s0)
    8001e88a:	fe043703          	ld	a4,-32(s0)
    8001e88e:	e798                	sd	a4,8(a5)
}
    8001e890:	0001                	nop
    8001e892:	6462                	ld	s0,24(sp)
    8001e894:	6105                	addi	sp,sp,32
    8001e896:	8082                	ret

000000008001e898 <mapelem_new_val>:

static void mapelem_new_val(Map *map, const char *key, MapValue val) {
    8001e898:	7139                	addi	sp,sp,-64
    8001e89a:	fc06                	sd	ra,56(sp)
    8001e89c:	f822                	sd	s0,48(sp)
    8001e89e:	0080                	addi	s0,sp,64
    8001e8a0:	fca43c23          	sd	a0,-40(s0)
    8001e8a4:	fcb43823          	sd	a1,-48(s0)
    8001e8a8:	fcc43423          	sd	a2,-56(s0)
    MapElem *me;
    // If we get here, the key isn't there.
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001e8ac:	fd043503          	ld	a0,-48(s0)
    8001e8b0:	cc3ff0ef          	jal	ra,8001e572 <fnv1a_digest_64>
    8001e8b4:	872a                	mv	a4,a0
    8001e8b6:	fd843783          	ld	a5,-40(s0)
    8001e8ba:	439c                	lw	a5,0(a5)
    8001e8bc:	1782                	slli	a5,a5,0x20
    8001e8be:	9381                	srli	a5,a5,0x20
    8001e8c0:	02f777b3          	remu	a5,a4,a5
    8001e8c4:	fef43423          	sd	a5,-24(s0)
    me           = (MapElem *)g_kmalloc(sizeof(MapElem));
    8001e8c8:	4541                	li	a0,16
    8001e8ca:	d32ff0ef          	jal	ra,8001ddfc <g_kmalloc>
    8001e8ce:	fea43023          	sd	a0,-32(s0)
    me->key      = strdup(key);
    8001e8d2:	fd043503          	ld	a0,-48(s0)
    8001e8d6:	525010ef          	jal	ra,800205fa <strdup>
    8001e8da:	872a                	mv	a4,a0
    8001e8dc:	fe043783          	ld	a5,-32(s0)
    8001e8e0:	e398                	sd	a4,0(a5)
    me->val      = val;
    8001e8e2:	fe043783          	ld	a5,-32(s0)
    8001e8e6:	fc843703          	ld	a4,-56(s0)
    8001e8ea:	e798                	sd	a4,8(a5)
    list_add_ptr(map->values[idx], me);
    8001e8ec:	fd843783          	ld	a5,-40(s0)
    8001e8f0:	6798                	ld	a4,8(a5)
    8001e8f2:	fe843783          	ld	a5,-24(s0)
    8001e8f6:	078e                	slli	a5,a5,0x3
    8001e8f8:	97ba                	add	a5,a5,a4
    8001e8fa:	639c                	ld	a5,0(a5)
    8001e8fc:	fe043703          	ld	a4,-32(s0)
    8001e900:	85ba                	mv	a1,a4
    8001e902:	853e                	mv	a0,a5
    8001e904:	e62ff0ef          	jal	ra,8001df66 <list_add>
    map->size += 1;
    8001e908:	fd843783          	ld	a5,-40(s0)
    8001e90c:	43dc                	lw	a5,4(a5)
    8001e90e:	2785                	addiw	a5,a5,1
    8001e910:	0007871b          	sext.w	a4,a5
    8001e914:	fd843783          	ld	a5,-40(s0)
    8001e918:	c3d8                	sw	a4,4(a5)
}
    8001e91a:	0001                	nop
    8001e91c:	70e2                	ld	ra,56(sp)
    8001e91e:	7442                	ld	s0,48(sp)
    8001e920:	6121                	addi	sp,sp,64
    8001e922:	8082                	ret

000000008001e924 <map_init_values>:

static struct List **map_init_values(uint32_t slots) {
    8001e924:	7139                	addi	sp,sp,-64
    8001e926:	fc06                	sd	ra,56(sp)
    8001e928:	f822                	sd	s0,48(sp)
    8001e92a:	f426                	sd	s1,40(sp)
    8001e92c:	0080                	addi	s0,sp,64
    8001e92e:	87aa                	mv	a5,a0
    8001e930:	fcf42623          	sw	a5,-52(s0)
    struct List **lst = (struct List **)g_kcalloc(slots, sizeof(struct List *));
    8001e934:	fcc46783          	lwu	a5,-52(s0)
    8001e938:	45a1                	li	a1,8
    8001e93a:	853e                	mv	a0,a5
    8001e93c:	cf8ff0ef          	jal	ra,8001de34 <g_kcalloc>
    8001e940:	fca43823          	sd	a0,-48(s0)
    for (uint32_t i = 0; i < slots; i++) {
    8001e944:	fc042e23          	sw	zero,-36(s0)
    8001e948:	a00d                	j	8001e96a <map_init_values+0x46>
        lst[i] = list_new();
    8001e94a:	fdc46783          	lwu	a5,-36(s0)
    8001e94e:	078e                	slli	a5,a5,0x3
    8001e950:	fd043703          	ld	a4,-48(s0)
    8001e954:	00f704b3          	add	s1,a4,a5
    8001e958:	ddeff0ef          	jal	ra,8001df36 <list_new>
    8001e95c:	87aa                	mv	a5,a0
    8001e95e:	e09c                	sd	a5,0(s1)
    for (uint32_t i = 0; i < slots; i++) {
    8001e960:	fdc42783          	lw	a5,-36(s0)
    8001e964:	2785                	addiw	a5,a5,1
    8001e966:	fcf42e23          	sw	a5,-36(s0)
    8001e96a:	fdc42703          	lw	a4,-36(s0)
    8001e96e:	fcc42783          	lw	a5,-52(s0)
    8001e972:	2701                	sext.w	a4,a4
    8001e974:	2781                	sext.w	a5,a5
    8001e976:	fcf76ae3          	bltu	a4,a5,8001e94a <map_init_values+0x26>
    }
    return lst;
    8001e97a:	fd043783          	ld	a5,-48(s0)
}
    8001e97e:	853e                	mv	a0,a5
    8001e980:	70e2                	ld	ra,56(sp)
    8001e982:	7442                	ld	s0,48(sp)
    8001e984:	74a2                	ld	s1,40(sp)
    8001e986:	6121                	addi	sp,sp,64
    8001e988:	8082                	ret

000000008001e98a <map_elem_free>:

static void map_elem_free(MapElem *me) {
    8001e98a:	1101                	addi	sp,sp,-32
    8001e98c:	ec06                	sd	ra,24(sp)
    8001e98e:	e822                	sd	s0,16(sp)
    8001e990:	1000                	addi	s0,sp,32
    8001e992:	fea43423          	sd	a0,-24(s0)
    g_kfree(me->key);
    8001e996:	fe843783          	ld	a5,-24(s0)
    8001e99a:	639c                	ld	a5,0(a5)
    8001e99c:	853e                	mv	a0,a5
    8001e99e:	cf8ff0ef          	jal	ra,8001de96 <g_kfree>
    g_kfree(me);
    8001e9a2:	fe843503          	ld	a0,-24(s0)
    8001e9a6:	cf0ff0ef          	jal	ra,8001de96 <g_kfree>
}
    8001e9aa:	0001                	nop
    8001e9ac:	60e2                	ld	ra,24(sp)
    8001e9ae:	6442                	ld	s0,16(sp)
    8001e9b0:	6105                	addi	sp,sp,32
    8001e9b2:	8082                	ret

000000008001e9b4 <map_lst_free>:

static void map_lst_free(ListElem *e) {
    8001e9b4:	1101                	addi	sp,sp,-32
    8001e9b6:	ec06                	sd	ra,24(sp)
    8001e9b8:	e822                	sd	s0,16(sp)
    8001e9ba:	1000                	addi	s0,sp,32
    8001e9bc:	fea43423          	sd	a0,-24(s0)
    map_elem_free(list_elem_value_ptr(e));
    8001e9c0:	fe843503          	ld	a0,-24(s0)
    8001e9c4:	a23ff0ef          	jal	ra,8001e3e6 <list_elem_value>
    8001e9c8:	87aa                	mv	a5,a0
    8001e9ca:	853e                	mv	a0,a5
    8001e9cc:	fbfff0ef          	jal	ra,8001e98a <map_elem_free>
    list_remove_elem(e);
    8001e9d0:	fe843503          	ld	a0,-24(s0)
    8001e9d4:	f34ff0ef          	jal	ra,8001e108 <list_remove_elem>
}
    8001e9d8:	0001                	nop
    8001e9da:	60e2                	ld	ra,24(sp)
    8001e9dc:	6442                	ld	s0,16(sp)
    8001e9de:	6105                	addi	sp,sp,32
    8001e9e0:	8082                	ret

000000008001e9e2 <map_init>:

static Map *map_init(Map *map, uint32_t slots)
{
    8001e9e2:	1101                	addi	sp,sp,-32
    8001e9e4:	ec06                	sd	ra,24(sp)
    8001e9e6:	e822                	sd	s0,16(sp)
    8001e9e8:	1000                	addi	s0,sp,32
    8001e9ea:	fea43423          	sd	a0,-24(s0)
    8001e9ee:	87ae                	mv	a5,a1
    8001e9f0:	fef42223          	sw	a5,-28(s0)
    if (map == NULL) {
    8001e9f4:	fe843783          	ld	a5,-24(s0)
    8001e9f8:	e399                	bnez	a5,8001e9fe <map_init+0x1c>
        return NULL;
    8001e9fa:	4781                	li	a5,0
    8001e9fc:	a805                	j	8001ea2c <map_init+0x4a>
    }

    map->slots  = slots == 0 ? 1 : slots;
    8001e9fe:	fe442783          	lw	a5,-28(s0)
    8001ea02:	2781                	sext.w	a5,a5
    8001ea04:	c781                	beqz	a5,8001ea0c <map_init+0x2a>
    8001ea06:	fe442783          	lw	a5,-28(s0)
    8001ea0a:	a011                	j	8001ea0e <map_init+0x2c>
    8001ea0c:	4785                	li	a5,1
    8001ea0e:	fe843703          	ld	a4,-24(s0)
    8001ea12:	c31c                	sw	a5,0(a4)
    map->values = map_init_values(map->slots);
    8001ea14:	fe843783          	ld	a5,-24(s0)
    8001ea18:	439c                	lw	a5,0(a5)
    8001ea1a:	853e                	mv	a0,a5
    8001ea1c:	f09ff0ef          	jal	ra,8001e924 <map_init_values>
    8001ea20:	872a                	mv	a4,a0
    8001ea22:	fe843783          	ld	a5,-24(s0)
    8001ea26:	e798                	sd	a4,8(a5)
    return map;
    8001ea28:	fe843783          	ld	a5,-24(s0)
}
    8001ea2c:	853e                	mv	a0,a5
    8001ea2e:	60e2                	ld	ra,24(sp)
    8001ea30:	6442                	ld	s0,16(sp)
    8001ea32:	6105                	addi	sp,sp,32
    8001ea34:	8082                	ret

000000008001ea36 <map_new>:

Map *map_new(void)
{
    8001ea36:	1141                	addi	sp,sp,-16
    8001ea38:	e406                	sd	ra,8(sp)
    8001ea3a:	e022                	sd	s0,0(sp)
    8001ea3c:	0800                	addi	s0,sp,16
    return map_new_with_slots(DEFAULT_MAP_SIZE);
    8001ea3e:	04000513          	li	a0,64
    8001ea42:	010000ef          	jal	ra,8001ea52 <map_new_with_slots>
    8001ea46:	87aa                	mv	a5,a0
}
    8001ea48:	853e                	mv	a0,a5
    8001ea4a:	60a2                	ld	ra,8(sp)
    8001ea4c:	6402                	ld	s0,0(sp)
    8001ea4e:	0141                	addi	sp,sp,16
    8001ea50:	8082                	ret

000000008001ea52 <map_new_with_slots>:

Map *map_new_with_slots(uint32_t slots)
{
    8001ea52:	1101                	addi	sp,sp,-32
    8001ea54:	ec06                	sd	ra,24(sp)
    8001ea56:	e822                	sd	s0,16(sp)
    8001ea58:	1000                	addi	s0,sp,32
    8001ea5a:	87aa                	mv	a5,a0
    8001ea5c:	fef42623          	sw	a5,-20(s0)
    if (slots == 0) {
    8001ea60:	fec42783          	lw	a5,-20(s0)
    8001ea64:	2781                	sext.w	a5,a5
    8001ea66:	e399                	bnez	a5,8001ea6c <map_new_with_slots+0x1a>
        return NULL;
    8001ea68:	4781                	li	a5,0
    8001ea6a:	a821                	j	8001ea82 <map_new_with_slots+0x30>
    }
    return map_init((Map *)g_kmalloc(sizeof(Map)), slots);
    8001ea6c:	4541                	li	a0,16
    8001ea6e:	b8eff0ef          	jal	ra,8001ddfc <g_kmalloc>
    8001ea72:	872a                	mv	a4,a0
    8001ea74:	fec42783          	lw	a5,-20(s0)
    8001ea78:	85be                	mv	a1,a5
    8001ea7a:	853a                	mv	a0,a4
    8001ea7c:	f67ff0ef          	jal	ra,8001e9e2 <map_init>
    8001ea80:	87aa                	mv	a5,a0
}
    8001ea82:	853e                	mv	a0,a5
    8001ea84:	60e2                	ld	ra,24(sp)
    8001ea86:	6442                	ld	s0,16(sp)
    8001ea88:	6105                	addi	sp,sp,32
    8001ea8a:	8082                	ret

000000008001ea8c <map_slots>:


uint32_t map_slots(const Map *map)
{
    8001ea8c:	1101                	addi	sp,sp,-32
    8001ea8e:	ec22                	sd	s0,24(sp)
    8001ea90:	1000                	addi	s0,sp,32
    8001ea92:	fea43423          	sd	a0,-24(s0)
    return map->slots;
    8001ea96:	fe843783          	ld	a5,-24(s0)
    8001ea9a:	439c                	lw	a5,0(a5)
}
    8001ea9c:	853e                	mv	a0,a5
    8001ea9e:	6462                	ld	s0,24(sp)
    8001eaa0:	6105                	addi	sp,sp,32
    8001eaa2:	8082                	ret

000000008001eaa4 <map_size>:

uint32_t map_size(const Map *map)
{
    8001eaa4:	1101                	addi	sp,sp,-32
    8001eaa6:	ec22                	sd	s0,24(sp)
    8001eaa8:	1000                	addi	s0,sp,32
    8001eaaa:	fea43423          	sd	a0,-24(s0)
    return map->size;
    8001eaae:	fe843783          	ld	a5,-24(s0)
    8001eab2:	43dc                	lw	a5,4(a5)
}
    8001eab4:	853e                	mv	a0,a5
    8001eab6:	6462                	ld	s0,24(sp)
    8001eab8:	6105                	addi	sp,sp,32
    8001eaba:	8082                	ret

000000008001eabc <map_set>:

void map_set(Map *map, const char *key, MapValue val)
{
    8001eabc:	7139                	addi	sp,sp,-64
    8001eabe:	fc06                	sd	ra,56(sp)
    8001eac0:	f822                	sd	s0,48(sp)
    8001eac2:	0080                	addi	s0,sp,64
    8001eac4:	fca43c23          	sd	a0,-40(s0)
    8001eac8:	fcb43823          	sd	a1,-48(s0)
    8001eacc:	fcc43423          	sd	a2,-56(s0)
    MapElem *me = map_get_elem(map, key);
    8001ead0:	fd043583          	ld	a1,-48(s0)
    8001ead4:	fd843503          	ld	a0,-40(s0)
    8001ead8:	c55ff0ef          	jal	ra,8001e72c <map_get_elem>
    8001eadc:	fea43423          	sd	a0,-24(s0)
    if (me != NULL) {
    8001eae0:	fe843783          	ld	a5,-24(s0)
    8001eae4:	cb81                	beqz	a5,8001eaf4 <map_set+0x38>
        mapelem_set_val(me, val);
    8001eae6:	fc843583          	ld	a1,-56(s0)
    8001eaea:	fe843503          	ld	a0,-24(s0)
    8001eaee:	d8bff0ef          	jal	ra,8001e878 <mapelem_set_val>
    }
    else {
        mapelem_new_val(map, key, val);
    }
}
    8001eaf2:	a809                	j	8001eb04 <map_set+0x48>
        mapelem_new_val(map, key, val);
    8001eaf4:	fc843603          	ld	a2,-56(s0)
    8001eaf8:	fd043583          	ld	a1,-48(s0)
    8001eafc:	fd843503          	ld	a0,-40(s0)
    8001eb00:	d99ff0ef          	jal	ra,8001e898 <mapelem_new_val>
}
    8001eb04:	0001                	nop
    8001eb06:	70e2                	ld	ra,56(sp)
    8001eb08:	7442                	ld	s0,48(sp)
    8001eb0a:	6121                	addi	sp,sp,64
    8001eb0c:	8082                	ret

000000008001eb0e <map_set_int>:

void map_set_int(Map *map, long ikey, MapValue val)
{
    8001eb0e:	7159                	addi	sp,sp,-112
    8001eb10:	f486                	sd	ra,104(sp)
    8001eb12:	f0a2                	sd	s0,96(sp)
    8001eb14:	1880                	addi	s0,sp,112
    8001eb16:	faa43423          	sd	a0,-88(s0)
    8001eb1a:	fab43023          	sd	a1,-96(s0)
    8001eb1e:	f8c43c23          	sd	a2,-104(s0)
    char key[STR_KEY_SIZE];
    map_set(map, map_int_to_str(key, ikey), val);
    8001eb22:	fb040793          	addi	a5,s0,-80
    8001eb26:	fa043583          	ld	a1,-96(s0)
    8001eb2a:	853e                	mv	a0,a5
    8001eb2c:	aa9ff0ef          	jal	ra,8001e5d4 <map_int_to_str>
    8001eb30:	87aa                	mv	a5,a0
    8001eb32:	f9843603          	ld	a2,-104(s0)
    8001eb36:	85be                	mv	a1,a5
    8001eb38:	fa843503          	ld	a0,-88(s0)
    8001eb3c:	f81ff0ef          	jal	ra,8001eabc <map_set>
}
    8001eb40:	0001                	nop
    8001eb42:	70a6                	ld	ra,104(sp)
    8001eb44:	7406                	ld	s0,96(sp)
    8001eb46:	6165                	addi	sp,sp,112
    8001eb48:	8082                	ret

000000008001eb4a <map_get_unchecked>:

MapValue map_get_unchecked(const Map *map, const char *key)
{
    8001eb4a:	7179                	addi	sp,sp,-48
    8001eb4c:	f406                	sd	ra,40(sp)
    8001eb4e:	f022                	sd	s0,32(sp)
    8001eb50:	1800                	addi	s0,sp,48
    8001eb52:	fca43c23          	sd	a0,-40(s0)
    8001eb56:	fcb43823          	sd	a1,-48(s0)
    MapValue ret = 0;
    8001eb5a:	fe043423          	sd	zero,-24(s0)
    map_get(map, key, &ret);
    8001eb5e:	fe840793          	addi	a5,s0,-24
    8001eb62:	863e                	mv	a2,a5
    8001eb64:	fd043583          	ld	a1,-48(s0)
    8001eb68:	fd843503          	ld	a0,-40(s0)
    8001eb6c:	012000ef          	jal	ra,8001eb7e <map_get>
    return ret;
    8001eb70:	fe843783          	ld	a5,-24(s0)
}
    8001eb74:	853e                	mv	a0,a5
    8001eb76:	70a2                	ld	ra,40(sp)
    8001eb78:	7402                	ld	s0,32(sp)
    8001eb7a:	6145                	addi	sp,sp,48
    8001eb7c:	8082                	ret

000000008001eb7e <map_get>:

bool map_get(const Map *map, const char *key, MapValue *value)
{
    8001eb7e:	7139                	addi	sp,sp,-64
    8001eb80:	fc06                	sd	ra,56(sp)
    8001eb82:	f822                	sd	s0,48(sp)
    8001eb84:	0080                	addi	s0,sp,64
    8001eb86:	fca43c23          	sd	a0,-40(s0)
    8001eb8a:	fcb43823          	sd	a1,-48(s0)
    8001eb8e:	fcc43423          	sd	a2,-56(s0)
    const MapElem *me = map_get_celem(map, key);
    8001eb92:	fd043583          	ld	a1,-48(s0)
    8001eb96:	fd843503          	ld	a0,-40(s0)
    8001eb9a:	c39ff0ef          	jal	ra,8001e7d2 <map_get_celem>
    8001eb9e:	fea43423          	sd	a0,-24(s0)
    if (me == NULL) {
    8001eba2:	fe843783          	ld	a5,-24(s0)
    8001eba6:	e399                	bnez	a5,8001ebac <map_get+0x2e>
        return false;
    8001eba8:	4781                	li	a5,0
    8001ebaa:	a819                	j	8001ebc0 <map_get+0x42>
    }
    if (value != NULL) {
    8001ebac:	fc843783          	ld	a5,-56(s0)
    8001ebb0:	c799                	beqz	a5,8001ebbe <map_get+0x40>
        *value = me->val;
    8001ebb2:	fe843783          	ld	a5,-24(s0)
    8001ebb6:	6798                	ld	a4,8(a5)
    8001ebb8:	fc843783          	ld	a5,-56(s0)
    8001ebbc:	e398                	sd	a4,0(a5)
    }
    return true;
    8001ebbe:	4785                	li	a5,1
}
    8001ebc0:	853e                	mv	a0,a5
    8001ebc2:	70e2                	ld	ra,56(sp)
    8001ebc4:	7442                	ld	s0,48(sp)
    8001ebc6:	6121                	addi	sp,sp,64
    8001ebc8:	8082                	ret

000000008001ebca <map_get_int>:

bool map_get_int(const Map *map, long ikey, MapValue *value)
{
    8001ebca:	7159                	addi	sp,sp,-112
    8001ebcc:	f486                	sd	ra,104(sp)
    8001ebce:	f0a2                	sd	s0,96(sp)
    8001ebd0:	1880                	addi	s0,sp,112
    8001ebd2:	faa43423          	sd	a0,-88(s0)
    8001ebd6:	fab43023          	sd	a1,-96(s0)
    8001ebda:	f8c43c23          	sd	a2,-104(s0)
    char key[STR_KEY_SIZE];
    return map_get(map, map_int_to_str(key, ikey), value);
    8001ebde:	fb040793          	addi	a5,s0,-80
    8001ebe2:	fa043583          	ld	a1,-96(s0)
    8001ebe6:	853e                	mv	a0,a5
    8001ebe8:	9edff0ef          	jal	ra,8001e5d4 <map_int_to_str>
    8001ebec:	87aa                	mv	a5,a0
    8001ebee:	f9843603          	ld	a2,-104(s0)
    8001ebf2:	85be                	mv	a1,a5
    8001ebf4:	fa843503          	ld	a0,-88(s0)
    8001ebf8:	f87ff0ef          	jal	ra,8001eb7e <map_get>
    8001ebfc:	87aa                	mv	a5,a0
}
    8001ebfe:	853e                	mv	a0,a5
    8001ec00:	70a6                	ld	ra,104(sp)
    8001ec02:	7406                	ld	s0,96(sp)
    8001ec04:	6165                	addi	sp,sp,112
    8001ec06:	8082                	ret

000000008001ec08 <map_contains>:

bool map_contains(const Map *map, const char *key)
{
    8001ec08:	1101                	addi	sp,sp,-32
    8001ec0a:	ec06                	sd	ra,24(sp)
    8001ec0c:	e822                	sd	s0,16(sp)
    8001ec0e:	1000                	addi	s0,sp,32
    8001ec10:	fea43423          	sd	a0,-24(s0)
    8001ec14:	feb43023          	sd	a1,-32(s0)
    return map_get(map, key, NULL);
    8001ec18:	4601                	li	a2,0
    8001ec1a:	fe043583          	ld	a1,-32(s0)
    8001ec1e:	fe843503          	ld	a0,-24(s0)
    8001ec22:	f5dff0ef          	jal	ra,8001eb7e <map_get>
    8001ec26:	87aa                	mv	a5,a0
}
    8001ec28:	853e                	mv	a0,a5
    8001ec2a:	60e2                	ld	ra,24(sp)
    8001ec2c:	6442                	ld	s0,16(sp)
    8001ec2e:	6105                	addi	sp,sp,32
    8001ec30:	8082                	ret

000000008001ec32 <map_contains_int>:

bool map_contains_int(const struct Map *map, long ikey)
{
    8001ec32:	1101                	addi	sp,sp,-32
    8001ec34:	ec06                	sd	ra,24(sp)
    8001ec36:	e822                	sd	s0,16(sp)
    8001ec38:	1000                	addi	s0,sp,32
    8001ec3a:	fea43423          	sd	a0,-24(s0)
    8001ec3e:	feb43023          	sd	a1,-32(s0)
    return map_get_int(map, ikey, NULL);
    8001ec42:	4601                	li	a2,0
    8001ec44:	fe043583          	ld	a1,-32(s0)
    8001ec48:	fe843503          	ld	a0,-24(s0)
    8001ec4c:	f7fff0ef          	jal	ra,8001ebca <map_get_int>
    8001ec50:	87aa                	mv	a5,a0
}
    8001ec52:	853e                	mv	a0,a5
    8001ec54:	60e2                	ld	ra,24(sp)
    8001ec56:	6442                	ld	s0,16(sp)
    8001ec58:	6105                	addi	sp,sp,32
    8001ec5a:	8082                	ret

000000008001ec5c <map_remove>:

bool map_remove(Map *map, const char *key)
{
    8001ec5c:	7179                	addi	sp,sp,-48
    8001ec5e:	f406                	sd	ra,40(sp)
    8001ec60:	f022                	sd	s0,32(sp)
    8001ec62:	1800                	addi	s0,sp,48
    8001ec64:	fca43c23          	sd	a0,-40(s0)
    8001ec68:	fcb43823          	sd	a1,-48(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8001ec6c:	fd043503          	ld	a0,-48(s0)
    8001ec70:	903ff0ef          	jal	ra,8001e572 <fnv1a_digest_64>
    8001ec74:	872a                	mv	a4,a0
    8001ec76:	fd843783          	ld	a5,-40(s0)
    8001ec7a:	439c                	lw	a5,0(a5)
    8001ec7c:	1782                	slli	a5,a5,0x20
    8001ec7e:	9381                	srli	a5,a5,0x20
    8001ec80:	02f777b3          	remu	a5,a4,a5
    8001ec84:	fef43023          	sd	a5,-32(s0)
    ListElem *e;

    list_for_each_ascending(map->values[idx], e)
    8001ec88:	fd843783          	ld	a5,-40(s0)
    8001ec8c:	6798                	ld	a4,8(a5)
    8001ec8e:	fe043783          	ld	a5,-32(s0)
    8001ec92:	078e                	slli	a5,a5,0x3
    8001ec94:	97ba                	add	a5,a5,a4
    8001ec96:	639c                	ld	a5,0(a5)
    8001ec98:	853e                	mv	a0,a5
    8001ec9a:	eecff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001ec9e:	fea43423          	sd	a0,-24(s0)
    8001eca2:	a099                	j	8001ece8 <map_remove+0x8c>
    {
        if (!strcmp(key, ((MapElem *)list_elem_value(e))->key)) {
    8001eca4:	fe843503          	ld	a0,-24(s0)
    8001eca8:	f3eff0ef          	jal	ra,8001e3e6 <list_elem_value>
    8001ecac:	87aa                	mv	a5,a0
    8001ecae:	639c                	ld	a5,0(a5)
    8001ecb0:	85be                	mv	a1,a5
    8001ecb2:	fd043503          	ld	a0,-48(s0)
    8001ecb6:	546010ef          	jal	ra,800201fc <strcmp>
    8001ecba:	87aa                	mv	a5,a0
    8001ecbc:	e385                	bnez	a5,8001ecdc <map_remove+0x80>
            map_lst_free(e);
    8001ecbe:	fe843503          	ld	a0,-24(s0)
    8001ecc2:	cf3ff0ef          	jal	ra,8001e9b4 <map_lst_free>
            map->size -= 1;
    8001ecc6:	fd843783          	ld	a5,-40(s0)
    8001ecca:	43dc                	lw	a5,4(a5)
    8001eccc:	37fd                	addiw	a5,a5,-1
    8001ecce:	0007871b          	sext.w	a4,a5
    8001ecd2:	fd843783          	ld	a5,-40(s0)
    8001ecd6:	c3d8                	sw	a4,4(a5)
            return true;
    8001ecd8:	4785                	li	a5,1
    8001ecda:	a03d                	j	8001ed08 <map_remove+0xac>
    list_for_each_ascending(map->values[idx], e)
    8001ecdc:	fe843503          	ld	a0,-24(s0)
    8001ece0:	eeeff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001ece4:	fea43423          	sd	a0,-24(s0)
    8001ece8:	fd843783          	ld	a5,-40(s0)
    8001ecec:	6798                	ld	a4,8(a5)
    8001ecee:	fe043783          	ld	a5,-32(s0)
    8001ecf2:	078e                	slli	a5,a5,0x3
    8001ecf4:	97ba                	add	a5,a5,a4
    8001ecf6:	639c                	ld	a5,0(a5)
    8001ecf8:	fe843583          	ld	a1,-24(s0)
    8001ecfc:	853e                	mv	a0,a5
    8001ecfe:	dfaff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001ed02:	87aa                	mv	a5,a0
    8001ed04:	f3c5                	bnez	a5,8001eca4 <map_remove+0x48>
        }
    }
    return false;
    8001ed06:	4781                	li	a5,0
}
    8001ed08:	853e                	mv	a0,a5
    8001ed0a:	70a2                	ld	ra,40(sp)
    8001ed0c:	7402                	ld	s0,32(sp)
    8001ed0e:	6145                	addi	sp,sp,48
    8001ed10:	8082                	ret

000000008001ed12 <map_remove_int>:

bool map_remove_int(Map *map, long ikey)
{
    8001ed12:	711d                	addi	sp,sp,-96
    8001ed14:	ec86                	sd	ra,88(sp)
    8001ed16:	e8a2                	sd	s0,80(sp)
    8001ed18:	1080                	addi	s0,sp,96
    8001ed1a:	faa43423          	sd	a0,-88(s0)
    8001ed1e:	fab43023          	sd	a1,-96(s0)
    char key[STR_KEY_SIZE];
    return map_remove(map, map_int_to_str(key, ikey));
    8001ed22:	fb040793          	addi	a5,s0,-80
    8001ed26:	fa043583          	ld	a1,-96(s0)
    8001ed2a:	853e                	mv	a0,a5
    8001ed2c:	8a9ff0ef          	jal	ra,8001e5d4 <map_int_to_str>
    8001ed30:	87aa                	mv	a5,a0
    8001ed32:	85be                	mv	a1,a5
    8001ed34:	fa843503          	ld	a0,-88(s0)
    8001ed38:	f25ff0ef          	jal	ra,8001ec5c <map_remove>
    8001ed3c:	87aa                	mv	a5,a0
}
    8001ed3e:	853e                	mv	a0,a5
    8001ed40:	60e6                	ld	ra,88(sp)
    8001ed42:	6446                	ld	s0,80(sp)
    8001ed44:	6125                	addi	sp,sp,96
    8001ed46:	8082                	ret

000000008001ed48 <map_clear>:

void map_clear(Map *map)
{
    8001ed48:	7179                	addi	sp,sp,-48
    8001ed4a:	f406                	sd	ra,40(sp)
    8001ed4c:	f022                	sd	s0,32(sp)
    8001ed4e:	1800                	addi	s0,sp,48
    8001ed50:	fca43c23          	sd	a0,-40(s0)
    uint32_t i;
    ListElem *e;

    for (i = 0; i < map->slots; i++) {
    8001ed54:	fe042623          	sw	zero,-20(s0)
    8001ed58:	a8a9                	j	8001edb2 <map_clear+0x6a>
        list_for_each_ascending(map->values[i], e)
    8001ed5a:	fd843783          	ld	a5,-40(s0)
    8001ed5e:	6798                	ld	a4,8(a5)
    8001ed60:	fec46783          	lwu	a5,-20(s0)
    8001ed64:	078e                	slli	a5,a5,0x3
    8001ed66:	97ba                	add	a5,a5,a4
    8001ed68:	639c                	ld	a5,0(a5)
    8001ed6a:	853e                	mv	a0,a5
    8001ed6c:	e1aff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001ed70:	fea43023          	sd	a0,-32(s0)
    8001ed74:	a819                	j	8001ed8a <map_clear+0x42>
        {
            map_lst_free(e);
    8001ed76:	fe043503          	ld	a0,-32(s0)
    8001ed7a:	c3bff0ef          	jal	ra,8001e9b4 <map_lst_free>
        list_for_each_ascending(map->values[i], e)
    8001ed7e:	fe043503          	ld	a0,-32(s0)
    8001ed82:	e4cff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001ed86:	fea43023          	sd	a0,-32(s0)
    8001ed8a:	fd843783          	ld	a5,-40(s0)
    8001ed8e:	6798                	ld	a4,8(a5)
    8001ed90:	fec46783          	lwu	a5,-20(s0)
    8001ed94:	078e                	slli	a5,a5,0x3
    8001ed96:	97ba                	add	a5,a5,a4
    8001ed98:	639c                	ld	a5,0(a5)
    8001ed9a:	fe043583          	ld	a1,-32(s0)
    8001ed9e:	853e                	mv	a0,a5
    8001eda0:	d58ff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001eda4:	87aa                	mv	a5,a0
    8001eda6:	fbe1                	bnez	a5,8001ed76 <map_clear+0x2e>
    for (i = 0; i < map->slots; i++) {
    8001eda8:	fec42783          	lw	a5,-20(s0)
    8001edac:	2785                	addiw	a5,a5,1
    8001edae:	fef42623          	sw	a5,-20(s0)
    8001edb2:	fd843783          	ld	a5,-40(s0)
    8001edb6:	4398                	lw	a4,0(a5)
    8001edb8:	fec42783          	lw	a5,-20(s0)
    8001edbc:	2781                	sext.w	a5,a5
    8001edbe:	f8e7eee3          	bltu	a5,a4,8001ed5a <map_clear+0x12>
        }
    }
    map->size = 0;
    8001edc2:	fd843783          	ld	a5,-40(s0)
    8001edc6:	0007a223          	sw	zero,4(a5)
}
    8001edca:	0001                	nop
    8001edcc:	70a2                	ld	ra,40(sp)
    8001edce:	7402                	ld	s0,32(sp)
    8001edd0:	6145                	addi	sp,sp,48
    8001edd2:	8082                	ret

000000008001edd4 <map_free>:

void map_free(Map *map)
{
    8001edd4:	7179                	addi	sp,sp,-48
    8001edd6:	f406                	sd	ra,40(sp)
    8001edd8:	f022                	sd	s0,32(sp)
    8001edda:	1800                	addi	s0,sp,48
    8001eddc:	fca43c23          	sd	a0,-40(s0)
    uint32_t i;
    ListElem *e;

    if (map == NULL) {
    8001ede0:	fd843783          	ld	a5,-40(s0)
    8001ede4:	c3d5                	beqz	a5,8001ee88 <map_free+0xb4>
        return;
    }
    for (i = 0; i < map->slots; i++) {
    8001ede6:	fe042623          	sw	zero,-20(s0)
    8001edea:	a885                	j	8001ee5a <map_free+0x86>
        list_for_each_ascending(map->values[i], e)
    8001edec:	fd843783          	ld	a5,-40(s0)
    8001edf0:	6798                	ld	a4,8(a5)
    8001edf2:	fec46783          	lwu	a5,-20(s0)
    8001edf6:	078e                	slli	a5,a5,0x3
    8001edf8:	97ba                	add	a5,a5,a4
    8001edfa:	639c                	ld	a5,0(a5)
    8001edfc:	853e                	mv	a0,a5
    8001edfe:	d88ff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001ee02:	fea43023          	sd	a0,-32(s0)
    8001ee06:	a819                	j	8001ee1c <map_free+0x48>
        {
            map_lst_free(e);
    8001ee08:	fe043503          	ld	a0,-32(s0)
    8001ee0c:	ba9ff0ef          	jal	ra,8001e9b4 <map_lst_free>
        list_for_each_ascending(map->values[i], e)
    8001ee10:	fe043503          	ld	a0,-32(s0)
    8001ee14:	dbaff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001ee18:	fea43023          	sd	a0,-32(s0)
    8001ee1c:	fd843783          	ld	a5,-40(s0)
    8001ee20:	6798                	ld	a4,8(a5)
    8001ee22:	fec46783          	lwu	a5,-20(s0)
    8001ee26:	078e                	slli	a5,a5,0x3
    8001ee28:	97ba                	add	a5,a5,a4
    8001ee2a:	639c                	ld	a5,0(a5)
    8001ee2c:	fe043583          	ld	a1,-32(s0)
    8001ee30:	853e                	mv	a0,a5
    8001ee32:	cc6ff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001ee36:	87aa                	mv	a5,a0
    8001ee38:	fbe1                	bnez	a5,8001ee08 <map_free+0x34>
        }
        list_free(map->values[i]);
    8001ee3a:	fd843783          	ld	a5,-40(s0)
    8001ee3e:	6798                	ld	a4,8(a5)
    8001ee40:	fec46783          	lwu	a5,-20(s0)
    8001ee44:	078e                	slli	a5,a5,0x3
    8001ee46:	97ba                	add	a5,a5,a4
    8001ee48:	639c                	ld	a5,0(a5)
    8001ee4a:	853e                	mv	a0,a5
    8001ee4c:	c54ff0ef          	jal	ra,8001e2a0 <list_free>
    for (i = 0; i < map->slots; i++) {
    8001ee50:	fec42783          	lw	a5,-20(s0)
    8001ee54:	2785                	addiw	a5,a5,1
    8001ee56:	fef42623          	sw	a5,-20(s0)
    8001ee5a:	fd843783          	ld	a5,-40(s0)
    8001ee5e:	4398                	lw	a4,0(a5)
    8001ee60:	fec42783          	lw	a5,-20(s0)
    8001ee64:	2781                	sext.w	a5,a5
    8001ee66:	f8e7e3e3          	bltu	a5,a4,8001edec <map_free+0x18>
    }
    g_kfree(map->values);
    8001ee6a:	fd843783          	ld	a5,-40(s0)
    8001ee6e:	679c                	ld	a5,8(a5)
    8001ee70:	853e                	mv	a0,a5
    8001ee72:	824ff0ef          	jal	ra,8001de96 <g_kfree>
    map->size = 0;
    8001ee76:	fd843783          	ld	a5,-40(s0)
    8001ee7a:	0007a223          	sw	zero,4(a5)
    g_kfree(map);
    8001ee7e:	fd843503          	ld	a0,-40(s0)
    8001ee82:	814ff0ef          	jal	ra,8001de96 <g_kfree>
    8001ee86:	a011                	j	8001ee8a <map_free+0xb6>
        return;
    8001ee88:	0001                	nop
}
    8001ee8a:	70a2                	ld	ra,40(sp)
    8001ee8c:	7402                	ld	s0,32(sp)
    8001ee8e:	6145                	addi	sp,sp,48
    8001ee90:	8082                	ret

000000008001ee92 <map_get_keys>:

struct List *map_get_keys(const Map *map) {
    8001ee92:	7139                	addi	sp,sp,-64
    8001ee94:	fc06                	sd	ra,56(sp)
    8001ee96:	f822                	sd	s0,48(sp)
    8001ee98:	0080                	addi	s0,sp,64
    8001ee9a:	fca43423          	sd	a0,-56(s0)
    uint32_t i;
    ListElem *e;
    struct List *ret = list_new();
    8001ee9e:	898ff0ef          	jal	ra,8001df36 <list_new>
    8001eea2:	fca43c23          	sd	a0,-40(s0)

    for (i = 0;i < map->slots;i++) {
    8001eea6:	fe042623          	sw	zero,-20(s0)
    8001eeaa:	a885                	j	8001ef1a <map_get_keys+0x88>
        list_for_each_ascending(map->values[i], e) {
    8001eeac:	fc843783          	ld	a5,-56(s0)
    8001eeb0:	6798                	ld	a4,8(a5)
    8001eeb2:	fec46783          	lwu	a5,-20(s0)
    8001eeb6:	078e                	slli	a5,a5,0x3
    8001eeb8:	97ba                	add	a5,a5,a4
    8001eeba:	639c                	ld	a5,0(a5)
    8001eebc:	853e                	mv	a0,a5
    8001eebe:	cc8ff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001eec2:	fea43023          	sd	a0,-32(s0)
    8001eec6:	a035                	j	8001eef2 <map_get_keys+0x60>
            list_add(ret, (uint64_t)strdup(((MapElem *)list_elem_value(e))->key));
    8001eec8:	fe043503          	ld	a0,-32(s0)
    8001eecc:	d1aff0ef          	jal	ra,8001e3e6 <list_elem_value>
    8001eed0:	87aa                	mv	a5,a0
    8001eed2:	639c                	ld	a5,0(a5)
    8001eed4:	853e                	mv	a0,a5
    8001eed6:	724010ef          	jal	ra,800205fa <strdup>
    8001eeda:	87aa                	mv	a5,a0
    8001eedc:	85be                	mv	a1,a5
    8001eede:	fd843503          	ld	a0,-40(s0)
    8001eee2:	884ff0ef          	jal	ra,8001df66 <list_add>
        list_for_each_ascending(map->values[i], e) {
    8001eee6:	fe043503          	ld	a0,-32(s0)
    8001eeea:	ce4ff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001eeee:	fea43023          	sd	a0,-32(s0)
    8001eef2:	fc843783          	ld	a5,-56(s0)
    8001eef6:	6798                	ld	a4,8(a5)
    8001eef8:	fec46783          	lwu	a5,-20(s0)
    8001eefc:	078e                	slli	a5,a5,0x3
    8001eefe:	97ba                	add	a5,a5,a4
    8001ef00:	639c                	ld	a5,0(a5)
    8001ef02:	fe043583          	ld	a1,-32(s0)
    8001ef06:	853e                	mv	a0,a5
    8001ef08:	bf0ff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001ef0c:	87aa                	mv	a5,a0
    8001ef0e:	ffcd                	bnez	a5,8001eec8 <map_get_keys+0x36>
    for (i = 0;i < map->slots;i++) {
    8001ef10:	fec42783          	lw	a5,-20(s0)
    8001ef14:	2785                	addiw	a5,a5,1
    8001ef16:	fef42623          	sw	a5,-20(s0)
    8001ef1a:	fc843783          	ld	a5,-56(s0)
    8001ef1e:	4398                	lw	a4,0(a5)
    8001ef20:	fec42783          	lw	a5,-20(s0)
    8001ef24:	2781                	sext.w	a5,a5
    8001ef26:	f8e7e3e3          	bltu	a5,a4,8001eeac <map_get_keys+0x1a>
        }
    }

    return ret;
    8001ef2a:	fd843783          	ld	a5,-40(s0)
}
    8001ef2e:	853e                	mv	a0,a5
    8001ef30:	70e2                	ld	ra,56(sp)
    8001ef32:	7442                	ld	s0,48(sp)
    8001ef34:	6121                	addi	sp,sp,64
    8001ef36:	8082                	ret

000000008001ef38 <map_free_get_keys>:

void map_free_get_keys(List *src) {
    8001ef38:	7179                	addi	sp,sp,-48
    8001ef3a:	f406                	sd	ra,40(sp)
    8001ef3c:	f022                	sd	s0,32(sp)
    8001ef3e:	1800                	addi	s0,sp,48
    8001ef40:	fca43c23          	sd	a0,-40(s0)
    if (src != NULL) {
    8001ef44:	fd843783          	ld	a5,-40(s0)
    8001ef48:	c3b1                	beqz	a5,8001ef8c <map_free_get_keys+0x54>
        ListElem *e;
        list_for_each_ascending(src, e) {
    8001ef4a:	fd843503          	ld	a0,-40(s0)
    8001ef4e:	c38ff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001ef52:	fea43423          	sd	a0,-24(s0)
    8001ef56:	a839                	j	8001ef74 <map_free_get_keys+0x3c>
            g_kfree(list_elem_value_ptr(e));
    8001ef58:	fe843503          	ld	a0,-24(s0)
    8001ef5c:	c8aff0ef          	jal	ra,8001e3e6 <list_elem_value>
    8001ef60:	87aa                	mv	a5,a0
    8001ef62:	853e                	mv	a0,a5
    8001ef64:	f33fe0ef          	jal	ra,8001de96 <g_kfree>
        list_for_each_ascending(src, e) {
    8001ef68:	fe843503          	ld	a0,-24(s0)
    8001ef6c:	c62ff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001ef70:	fea43423          	sd	a0,-24(s0)
    8001ef74:	fe843583          	ld	a1,-24(s0)
    8001ef78:	fd843503          	ld	a0,-40(s0)
    8001ef7c:	b7cff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001ef80:	87aa                	mv	a5,a0
    8001ef82:	fbf9                	bnez	a5,8001ef58 <map_free_get_keys+0x20>
        }
        list_free(src);
    8001ef84:	fd843503          	ld	a0,-40(s0)
    8001ef88:	b18ff0ef          	jal	ra,8001e2a0 <list_free>
    }
}
    8001ef8c:	0001                	nop
    8001ef8e:	70a2                	ld	ra,40(sp)
    8001ef90:	7402                	ld	s0,32(sp)
    8001ef92:	6145                	addi	sp,sp,48
    8001ef94:	8082                	ret

000000008001ef96 <path_skip_slashes>:
#include <list.h>
#include <path.h>
#include <util.h>

const char *path_skip_slashes(const char *path)
{
    8001ef96:	1101                	addi	sp,sp,-32
    8001ef98:	ec22                	sd	s0,24(sp)
    8001ef9a:	1000                	addi	s0,sp,32
    8001ef9c:	fea43423          	sd	a0,-24(s0)
    while (*path == '/') {
    8001efa0:	a031                	j	8001efac <path_skip_slashes+0x16>
        path++;
    8001efa2:	fe843783          	ld	a5,-24(s0)
    8001efa6:	0785                	addi	a5,a5,1
    8001efa8:	fef43423          	sd	a5,-24(s0)
    while (*path == '/') {
    8001efac:	fe843783          	ld	a5,-24(s0)
    8001efb0:	0007c783          	lbu	a5,0(a5)
    8001efb4:	873e                	mv	a4,a5
    8001efb6:	02f00793          	li	a5,47
    8001efba:	fef704e3          	beq	a4,a5,8001efa2 <path_skip_slashes+0xc>
    }
    return path;
    8001efbe:	fe843783          	ld	a5,-24(s0)
}
    8001efc2:	853e                	mv	a0,a5
    8001efc4:	6462                	ld	s0,24(sp)
    8001efc6:	6105                	addi	sp,sp,32
    8001efc8:	8082                	ret

000000008001efca <path_next_slash>:

const char *path_next_slash(const char *path)
{
    8001efca:	1101                	addi	sp,sp,-32
    8001efcc:	ec22                	sd	s0,24(sp)
    8001efce:	1000                	addi	s0,sp,32
    8001efd0:	fea43423          	sd	a0,-24(s0)
    while (*path != '/' && *path != '\0') {
    8001efd4:	a031                	j	8001efe0 <path_next_slash+0x16>
        path++;
    8001efd6:	fe843783          	ld	a5,-24(s0)
    8001efda:	0785                	addi	a5,a5,1
    8001efdc:	fef43423          	sd	a5,-24(s0)
    while (*path != '/' && *path != '\0') {
    8001efe0:	fe843783          	ld	a5,-24(s0)
    8001efe4:	0007c783          	lbu	a5,0(a5)
    8001efe8:	873e                	mv	a4,a5
    8001efea:	02f00793          	li	a5,47
    8001efee:	00f70763          	beq	a4,a5,8001effc <path_next_slash+0x32>
    8001eff2:	fe843783          	ld	a5,-24(s0)
    8001eff6:	0007c783          	lbu	a5,0(a5)
    8001effa:	fff1                	bnez	a5,8001efd6 <path_next_slash+0xc>
    }
    return path;
    8001effc:	fe843783          	ld	a5,-24(s0)
}
    8001f000:	853e                	mv	a0,a5
    8001f002:	6462                	ld	s0,24(sp)
    8001f004:	6105                	addi	sp,sp,32
    8001f006:	8082                	ret

000000008001f008 <path_file_name>:

const char *path_file_name(const char *path)
{
    8001f008:	7179                	addi	sp,sp,-48
    8001f00a:	f406                	sd	ra,40(sp)
    8001f00c:	f022                	sd	s0,32(sp)
    8001f00e:	1800                	addi	s0,sp,48
    8001f010:	fca43c23          	sd	a0,-40(s0)
    int len = strlen(path);
    8001f014:	fd843503          	ld	a0,-40(s0)
    8001f018:	4e2010ef          	jal	ra,800204fa <strlen>
    8001f01c:	87aa                	mv	a5,a0
    8001f01e:	fef42423          	sw	a5,-24(s0)
    int i;
    for (i = len - 1; path[i] != '/' && i >= 0; i -= 1)
    8001f022:	fe842783          	lw	a5,-24(s0)
    8001f026:	37fd                	addiw	a5,a5,-1
    8001f028:	fef42623          	sw	a5,-20(s0)
    8001f02c:	a031                	j	8001f038 <path_file_name+0x30>
    8001f02e:	fec42783          	lw	a5,-20(s0)
    8001f032:	37fd                	addiw	a5,a5,-1
    8001f034:	fef42623          	sw	a5,-20(s0)
    8001f038:	fec42783          	lw	a5,-20(s0)
    8001f03c:	fd843703          	ld	a4,-40(s0)
    8001f040:	97ba                	add	a5,a5,a4
    8001f042:	0007c783          	lbu	a5,0(a5)
    8001f046:	873e                	mv	a4,a5
    8001f048:	02f00793          	li	a5,47
    8001f04c:	00f70763          	beq	a4,a5,8001f05a <path_file_name+0x52>
    8001f050:	fec42783          	lw	a5,-20(s0)
    8001f054:	2781                	sext.w	a5,a5
    8001f056:	fc07dce3          	bgez	a5,8001f02e <path_file_name+0x26>
        ;
    return path + i + 1;
    8001f05a:	fec42783          	lw	a5,-20(s0)
    8001f05e:	0785                	addi	a5,a5,1
    8001f060:	fd843703          	ld	a4,-40(s0)
    8001f064:	97ba                	add	a5,a5,a4
}
    8001f066:	853e                	mv	a0,a5
    8001f068:	70a2                	ld	ra,40(sp)
    8001f06a:	7402                	ld	s0,32(sp)
    8001f06c:	6145                	addi	sp,sp,48
    8001f06e:	8082                	ret

000000008001f070 <path_split>:

List *path_split(const char *path)
{
    8001f070:	7129                	addi	sp,sp,-320
    8001f072:	fe06                	sd	ra,312(sp)
    8001f074:	fa22                	sd	s0,304(sp)
    8001f076:	0280                	addi	s0,sp,320
    8001f078:	eca43423          	sd	a0,-312(s0)
    char name[256];
    char *ptr;
    unsigned int i;
    List *v = list_new();
    8001f07c:	ebbfe0ef          	jal	ra,8001df36 <list_new>
    8001f080:	fea43023          	sd	a0,-32(s0)
    while (*path != '\0') {
    8001f084:	a065                	j	8001f12c <path_split+0xbc>
        path = path_skip_slashes(path);
    8001f086:	ec843503          	ld	a0,-312(s0)
    8001f08a:	f0dff0ef          	jal	ra,8001ef96 <path_skip_slashes>
    8001f08e:	eca43423          	sd	a0,-312(s0)
        for (i = 0; i < (sizeof(name) - 1) && path[i] != '/' && path[i] != '\0'; i += 1) {
    8001f092:	fe042623          	sw	zero,-20(s0)
    8001f096:	a025                	j	8001f0be <path_split+0x4e>
            name[i] = path[i];
    8001f098:	fec46783          	lwu	a5,-20(s0)
    8001f09c:	ec843703          	ld	a4,-312(s0)
    8001f0a0:	97ba                	add	a5,a5,a4
    8001f0a2:	0007c703          	lbu	a4,0(a5)
    8001f0a6:	fec46783          	lwu	a5,-20(s0)
    8001f0aa:	ff040693          	addi	a3,s0,-16
    8001f0ae:	97b6                	add	a5,a5,a3
    8001f0b0:	eee78423          	sb	a4,-280(a5)
        for (i = 0; i < (sizeof(name) - 1) && path[i] != '/' && path[i] != '\0'; i += 1) {
    8001f0b4:	fec42783          	lw	a5,-20(s0)
    8001f0b8:	2785                	addiw	a5,a5,1
    8001f0ba:	fef42623          	sw	a5,-20(s0)
    8001f0be:	fec42783          	lw	a5,-20(s0)
    8001f0c2:	0007871b          	sext.w	a4,a5
    8001f0c6:	0fe00793          	li	a5,254
    8001f0ca:	02e7e663          	bltu	a5,a4,8001f0f6 <path_split+0x86>
    8001f0ce:	fec46783          	lwu	a5,-20(s0)
    8001f0d2:	ec843703          	ld	a4,-312(s0)
    8001f0d6:	97ba                	add	a5,a5,a4
    8001f0d8:	0007c783          	lbu	a5,0(a5)
    8001f0dc:	873e                	mv	a4,a5
    8001f0de:	02f00793          	li	a5,47
    8001f0e2:	00f70a63          	beq	a4,a5,8001f0f6 <path_split+0x86>
    8001f0e6:	fec46783          	lwu	a5,-20(s0)
    8001f0ea:	ec843703          	ld	a4,-312(s0)
    8001f0ee:	97ba                	add	a5,a5,a4
    8001f0f0:	0007c783          	lbu	a5,0(a5)
    8001f0f4:	f3d5                	bnez	a5,8001f098 <path_split+0x28>
        }
        name[i] = '\0';
    8001f0f6:	fec46783          	lwu	a5,-20(s0)
    8001f0fa:	ff040713          	addi	a4,s0,-16
    8001f0fe:	97ba                	add	a5,a5,a4
    8001f100:	ee078423          	sb	zero,-280(a5)
        ptr     = strdup(name);
    8001f104:	ed840793          	addi	a5,s0,-296
    8001f108:	853e                	mv	a0,a5
    8001f10a:	4f0010ef          	jal	ra,800205fa <strdup>
    8001f10e:	fca43c23          	sd	a0,-40(s0)
        list_add(v, (uint64_t)ptr);
    8001f112:	fd843783          	ld	a5,-40(s0)
    8001f116:	85be                	mv	a1,a5
    8001f118:	fe043503          	ld	a0,-32(s0)
    8001f11c:	e4bfe0ef          	jal	ra,8001df66 <list_add>
        path = path_next_slash(path);
    8001f120:	ec843503          	ld	a0,-312(s0)
    8001f124:	ea7ff0ef          	jal	ra,8001efca <path_next_slash>
    8001f128:	eca43423          	sd	a0,-312(s0)
    while (*path != '\0') {
    8001f12c:	ec843783          	ld	a5,-312(s0)
    8001f130:	0007c783          	lbu	a5,0(a5)
    8001f134:	fba9                	bnez	a5,8001f086 <path_split+0x16>
    }
    return v;
    8001f136:	fe043783          	ld	a5,-32(s0)
}
    8001f13a:	853e                	mv	a0,a5
    8001f13c:	70f2                	ld	ra,312(sp)
    8001f13e:	7452                	ld	s0,304(sp)
    8001f140:	6131                	addi	sp,sp,320
    8001f142:	8082                	ret

000000008001f144 <path_split_free>:

void path_split_free(struct List *l)
{
    8001f144:	7179                	addi	sp,sp,-48
    8001f146:	f406                	sd	ra,40(sp)
    8001f148:	f022                	sd	s0,32(sp)
    8001f14a:	1800                	addi	s0,sp,48
    8001f14c:	fca43c23          	sd	a0,-40(s0)
    ListElem *e;
    list_for_each(l, e)
    8001f150:	fd843503          	ld	a0,-40(s0)
    8001f154:	a32ff0ef          	jal	ra,8001e386 <list_elem_start_ascending>
    8001f158:	fea43423          	sd	a0,-24(s0)
    8001f15c:	a015                	j	8001f180 <path_split_free+0x3c>
    {
        void *ptr = (void *)list_elem_value(e);
    8001f15e:	fe843503          	ld	a0,-24(s0)
    8001f162:	a84ff0ef          	jal	ra,8001e3e6 <list_elem_value>
    8001f166:	87aa                	mv	a5,a0
    8001f168:	fef43023          	sd	a5,-32(s0)
        g_kfree(ptr);
    8001f16c:	fe043503          	ld	a0,-32(s0)
    8001f170:	d27fe0ef          	jal	ra,8001de96 <g_kfree>
    list_for_each(l, e)
    8001f174:	fe843503          	ld	a0,-24(s0)
    8001f178:	a56ff0ef          	jal	ra,8001e3ce <list_elem_prev>
    8001f17c:	fea43423          	sd	a0,-24(s0)
    8001f180:	fe843583          	ld	a1,-24(s0)
    8001f184:	fd843503          	ld	a0,-40(s0)
    8001f188:	970ff0ef          	jal	ra,8001e2f8 <list_elem_valid>
    8001f18c:	87aa                	mv	a5,a0
    8001f18e:	fbe1                	bnez	a5,8001f15e <path_split_free+0x1a>
    }
    list_free(l);
    8001f190:	fd843503          	ld	a0,-40(s0)
    8001f194:	90cff0ef          	jal	ra,8001e2a0 <list_free>
    g_kfree(l);
    8001f198:	fd843503          	ld	a0,-40(s0)
    8001f19c:	cfbfe0ef          	jal	ra,8001de96 <g_kfree>
}
    8001f1a0:	0001                	nop
    8001f1a2:	70a2                	ld	ra,40(sp)
    8001f1a4:	7402                	ld	s0,32(sp)
    8001f1a6:	6145                	addi	sp,sp,48
    8001f1a8:	8082                	ret

000000008001f1aa <create_node>:
    Node *root;
} RBTree;

// Function to create new node
Node *create_node(int key, uint64_t value)
{
    8001f1aa:	7179                	addi	sp,sp,-48
    8001f1ac:	f406                	sd	ra,40(sp)
    8001f1ae:	f022                	sd	s0,32(sp)
    8001f1b0:	1800                	addi	s0,sp,48
    8001f1b2:	87aa                	mv	a5,a0
    8001f1b4:	fcb43823          	sd	a1,-48(s0)
    8001f1b8:	fcf42e23          	sw	a5,-36(s0)
    Node *node  = (Node *)g_kmalloc(sizeof(Node));
    8001f1bc:	02800513          	li	a0,40
    8001f1c0:	c3dfe0ef          	jal	ra,8001ddfc <g_kmalloc>
    8001f1c4:	fea43423          	sd	a0,-24(s0)
    node->key   = key;
    8001f1c8:	fe843783          	ld	a5,-24(s0)
    8001f1cc:	fdc42703          	lw	a4,-36(s0)
    8001f1d0:	c3d8                	sw	a4,4(a5)
    node->value = value;
    8001f1d2:	fe843783          	ld	a5,-24(s0)
    8001f1d6:	fd043703          	ld	a4,-48(s0)
    8001f1da:	e798                	sd	a4,8(a5)
    node->color = RED;
    8001f1dc:	fe843783          	ld	a5,-24(s0)
    8001f1e0:	0007a023          	sw	zero,0(a5)
    node->left = node->right = node->parent = NULL;
    8001f1e4:	fe843783          	ld	a5,-24(s0)
    8001f1e8:	0207b023          	sd	zero,32(a5)
    8001f1ec:	fe843783          	ld	a5,-24(s0)
    8001f1f0:	7398                	ld	a4,32(a5)
    8001f1f2:	fe843783          	ld	a5,-24(s0)
    8001f1f6:	ef98                	sd	a4,24(a5)
    8001f1f8:	fe843783          	ld	a5,-24(s0)
    8001f1fc:	6f98                	ld	a4,24(a5)
    8001f1fe:	fe843783          	ld	a5,-24(s0)
    8001f202:	eb98                	sd	a4,16(a5)
    return node;
    8001f204:	fe843783          	ld	a5,-24(s0)
}
    8001f208:	853e                	mv	a0,a5
    8001f20a:	70a2                	ld	ra,40(sp)
    8001f20c:	7402                	ld	s0,32(sp)
    8001f20e:	6145                	addi	sp,sp,48
    8001f210:	8082                	ret

000000008001f212 <csearch>:

static const Node *csearch(const Node *node, int key)
{
    8001f212:	1101                	addi	sp,sp,-32
    8001f214:	ec22                	sd	s0,24(sp)
    8001f216:	1000                	addi	s0,sp,32
    8001f218:	fea43423          	sd	a0,-24(s0)
    8001f21c:	87ae                	mv	a5,a1
    8001f21e:	fef42223          	sw	a5,-28(s0)
    while (node != NULL) {
    8001f222:	a081                	j	8001f262 <csearch+0x50>
        if (key < node->key) {
    8001f224:	fe843783          	ld	a5,-24(s0)
    8001f228:	43d8                	lw	a4,4(a5)
    8001f22a:	fe442783          	lw	a5,-28(s0)
    8001f22e:	2781                	sext.w	a5,a5
    8001f230:	00e7d863          	bge	a5,a4,8001f240 <csearch+0x2e>
            node = node->left;
    8001f234:	fe843783          	ld	a5,-24(s0)
    8001f238:	6b9c                	ld	a5,16(a5)
    8001f23a:	fef43423          	sd	a5,-24(s0)
    8001f23e:	a015                	j	8001f262 <csearch+0x50>
        }
        else if (key > node->key) {
    8001f240:	fe843783          	ld	a5,-24(s0)
    8001f244:	43d8                	lw	a4,4(a5)
    8001f246:	fe442783          	lw	a5,-28(s0)
    8001f24a:	2781                	sext.w	a5,a5
    8001f24c:	00f75863          	bge	a4,a5,8001f25c <csearch+0x4a>
            node = node->right;
    8001f250:	fe843783          	ld	a5,-24(s0)
    8001f254:	6f9c                	ld	a5,24(a5)
    8001f256:	fef43423          	sd	a5,-24(s0)
    8001f25a:	a021                	j	8001f262 <csearch+0x50>
        }
        else {
            return node;
    8001f25c:	fe843783          	ld	a5,-24(s0)
    8001f260:	a029                	j	8001f26a <csearch+0x58>
    while (node != NULL) {
    8001f262:	fe843783          	ld	a5,-24(s0)
    8001f266:	ffdd                	bnez	a5,8001f224 <csearch+0x12>
        }
    }
    return NULL;
    8001f268:	4781                	li	a5,0
}
    8001f26a:	853e                	mv	a0,a5
    8001f26c:	6462                	ld	s0,24(sp)
    8001f26e:	6105                	addi	sp,sp,32
    8001f270:	8082                	ret

000000008001f272 <search>:

static Node *search(Node *node, int key)
{
    8001f272:	1101                	addi	sp,sp,-32
    8001f274:	ec22                	sd	s0,24(sp)
    8001f276:	1000                	addi	s0,sp,32
    8001f278:	fea43423          	sd	a0,-24(s0)
    8001f27c:	87ae                	mv	a5,a1
    8001f27e:	fef42223          	sw	a5,-28(s0)
    while (node != NULL) {
    8001f282:	a081                	j	8001f2c2 <search+0x50>
        if (key < node->key) {
    8001f284:	fe843783          	ld	a5,-24(s0)
    8001f288:	43d8                	lw	a4,4(a5)
    8001f28a:	fe442783          	lw	a5,-28(s0)
    8001f28e:	2781                	sext.w	a5,a5
    8001f290:	00e7d863          	bge	a5,a4,8001f2a0 <search+0x2e>
            node = node->left;
    8001f294:	fe843783          	ld	a5,-24(s0)
    8001f298:	6b9c                	ld	a5,16(a5)
    8001f29a:	fef43423          	sd	a5,-24(s0)
    8001f29e:	a015                	j	8001f2c2 <search+0x50>
        }
        else if (key > node->key) {
    8001f2a0:	fe843783          	ld	a5,-24(s0)
    8001f2a4:	43d8                	lw	a4,4(a5)
    8001f2a6:	fe442783          	lw	a5,-28(s0)
    8001f2aa:	2781                	sext.w	a5,a5
    8001f2ac:	00f75863          	bge	a4,a5,8001f2bc <search+0x4a>
            node = node->right;
    8001f2b0:	fe843783          	ld	a5,-24(s0)
    8001f2b4:	6f9c                	ld	a5,24(a5)
    8001f2b6:	fef43423          	sd	a5,-24(s0)
    8001f2ba:	a021                	j	8001f2c2 <search+0x50>
        }
        else {
            return node;
    8001f2bc:	fe843783          	ld	a5,-24(s0)
    8001f2c0:	a029                	j	8001f2ca <search+0x58>
    while (node != NULL) {
    8001f2c2:	fe843783          	ld	a5,-24(s0)
    8001f2c6:	ffdd                	bnez	a5,8001f284 <search+0x12>
        }
    }
    return NULL;
    8001f2c8:	4781                	li	a5,0
}
    8001f2ca:	853e                	mv	a0,a5
    8001f2cc:	6462                	ld	s0,24(sp)
    8001f2ce:	6105                	addi	sp,sp,32
    8001f2d0:	8082                	ret

000000008001f2d2 <minimum>:


static Node *minimum(Node *node)
{
    8001f2d2:	1101                	addi	sp,sp,-32
    8001f2d4:	ec22                	sd	s0,24(sp)
    8001f2d6:	1000                	addi	s0,sp,32
    8001f2d8:	fea43423          	sd	a0,-24(s0)
    while (node->left != NULL) {
    8001f2dc:	a031                	j	8001f2e8 <minimum+0x16>
        node = node->left;
    8001f2de:	fe843783          	ld	a5,-24(s0)
    8001f2e2:	6b9c                	ld	a5,16(a5)
    8001f2e4:	fef43423          	sd	a5,-24(s0)
    while (node->left != NULL) {
    8001f2e8:	fe843783          	ld	a5,-24(s0)
    8001f2ec:	6b9c                	ld	a5,16(a5)
    8001f2ee:	fbe5                	bnez	a5,8001f2de <minimum+0xc>
    }
    return node;
    8001f2f0:	fe843783          	ld	a5,-24(s0)
}
    8001f2f4:	853e                	mv	a0,a5
    8001f2f6:	6462                	ld	s0,24(sp)
    8001f2f8:	6105                	addi	sp,sp,32
    8001f2fa:	8082                	ret

000000008001f2fc <cminimum>:

static const Node *cminimum(const Node *node)
{
    8001f2fc:	1101                	addi	sp,sp,-32
    8001f2fe:	ec22                	sd	s0,24(sp)
    8001f300:	1000                	addi	s0,sp,32
    8001f302:	fea43423          	sd	a0,-24(s0)
    while (node->left != NULL) {
    8001f306:	a031                	j	8001f312 <cminimum+0x16>
        node = node->left;
    8001f308:	fe843783          	ld	a5,-24(s0)
    8001f30c:	6b9c                	ld	a5,16(a5)
    8001f30e:	fef43423          	sd	a5,-24(s0)
    while (node->left != NULL) {
    8001f312:	fe843783          	ld	a5,-24(s0)
    8001f316:	6b9c                	ld	a5,16(a5)
    8001f318:	fbe5                	bnez	a5,8001f308 <cminimum+0xc>
    }
    return node;
    8001f31a:	fe843783          	ld	a5,-24(s0)
}
    8001f31e:	853e                	mv	a0,a5
    8001f320:	6462                	ld	s0,24(sp)
    8001f322:	6105                	addi	sp,sp,32
    8001f324:	8082                	ret

000000008001f326 <cmaximum>:

static const Node *cmaximum(const Node *node)
{
    8001f326:	1101                	addi	sp,sp,-32
    8001f328:	ec22                	sd	s0,24(sp)
    8001f32a:	1000                	addi	s0,sp,32
    8001f32c:	fea43423          	sd	a0,-24(s0)
    while (node->right != NULL) {
    8001f330:	a031                	j	8001f33c <cmaximum+0x16>
        node = node->right;
    8001f332:	fe843783          	ld	a5,-24(s0)
    8001f336:	6f9c                	ld	a5,24(a5)
    8001f338:	fef43423          	sd	a5,-24(s0)
    while (node->right != NULL) {
    8001f33c:	fe843783          	ld	a5,-24(s0)
    8001f340:	6f9c                	ld	a5,24(a5)
    8001f342:	fbe5                	bnez	a5,8001f332 <cmaximum+0xc>
    }
    return node;
    8001f344:	fe843783          	ld	a5,-24(s0)
}
    8001f348:	853e                	mv	a0,a5
    8001f34a:	6462                	ld	s0,24(sp)
    8001f34c:	6105                	addi	sp,sp,32
    8001f34e:	8082                	ret

000000008001f350 <rb_min>:


bool rb_min(const RBTree *rb, int *key)
{
    8001f350:	7179                	addi	sp,sp,-48
    8001f352:	f406                	sd	ra,40(sp)
    8001f354:	f022                	sd	s0,32(sp)
    8001f356:	1800                	addi	s0,sp,48
    8001f358:	fca43c23          	sd	a0,-40(s0)
    8001f35c:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    8001f360:	fd843783          	ld	a5,-40(s0)
    8001f364:	639c                	ld	a5,0(a5)
    8001f366:	e399                	bnez	a5,8001f36c <rb_min+0x1c>
        return false;
    8001f368:	4781                	li	a5,0
    8001f36a:	a805                	j	8001f39a <rb_min+0x4a>
    }
    const Node *n = cminimum(rb->root);
    8001f36c:	fd843783          	ld	a5,-40(s0)
    8001f370:	639c                	ld	a5,0(a5)
    8001f372:	853e                	mv	a0,a5
    8001f374:	f89ff0ef          	jal	ra,8001f2fc <cminimum>
    8001f378:	fea43423          	sd	a0,-24(s0)
    if (n != NULL) {
    8001f37c:	fe843783          	ld	a5,-24(s0)
    8001f380:	cf81                	beqz	a5,8001f398 <rb_min+0x48>
        if (key) {
    8001f382:	fd043783          	ld	a5,-48(s0)
    8001f386:	c799                	beqz	a5,8001f394 <rb_min+0x44>
            *key = n->key;
    8001f388:	fe843783          	ld	a5,-24(s0)
    8001f38c:	43d8                	lw	a4,4(a5)
    8001f38e:	fd043783          	ld	a5,-48(s0)
    8001f392:	c398                	sw	a4,0(a5)
        }
        return true;
    8001f394:	4785                	li	a5,1
    8001f396:	a011                	j	8001f39a <rb_min+0x4a>
    }
    return false;
    8001f398:	4781                	li	a5,0
}
    8001f39a:	853e                	mv	a0,a5
    8001f39c:	70a2                	ld	ra,40(sp)
    8001f39e:	7402                	ld	s0,32(sp)
    8001f3a0:	6145                	addi	sp,sp,48
    8001f3a2:	8082                	ret

000000008001f3a4 <rb_max>:

bool rb_max(const RBTree *rb, int *key)
{
    8001f3a4:	7179                	addi	sp,sp,-48
    8001f3a6:	f406                	sd	ra,40(sp)
    8001f3a8:	f022                	sd	s0,32(sp)
    8001f3aa:	1800                	addi	s0,sp,48
    8001f3ac:	fca43c23          	sd	a0,-40(s0)
    8001f3b0:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    8001f3b4:	fd843783          	ld	a5,-40(s0)
    8001f3b8:	639c                	ld	a5,0(a5)
    8001f3ba:	e399                	bnez	a5,8001f3c0 <rb_max+0x1c>
        return false;
    8001f3bc:	4781                	li	a5,0
    8001f3be:	a805                	j	8001f3ee <rb_max+0x4a>
    }
    const Node *n = cmaximum(rb->root);
    8001f3c0:	fd843783          	ld	a5,-40(s0)
    8001f3c4:	639c                	ld	a5,0(a5)
    8001f3c6:	853e                	mv	a0,a5
    8001f3c8:	f5fff0ef          	jal	ra,8001f326 <cmaximum>
    8001f3cc:	fea43423          	sd	a0,-24(s0)
    if (n != NULL) {
    8001f3d0:	fe843783          	ld	a5,-24(s0)
    8001f3d4:	cf81                	beqz	a5,8001f3ec <rb_max+0x48>
        if (key) {
    8001f3d6:	fd043783          	ld	a5,-48(s0)
    8001f3da:	c799                	beqz	a5,8001f3e8 <rb_max+0x44>
            *key = n->key;
    8001f3dc:	fe843783          	ld	a5,-24(s0)
    8001f3e0:	43d8                	lw	a4,4(a5)
    8001f3e2:	fd043783          	ld	a5,-48(s0)
    8001f3e6:	c398                	sw	a4,0(a5)
        }
        return true;
    8001f3e8:	4785                	li	a5,1
    8001f3ea:	a011                	j	8001f3ee <rb_max+0x4a>
    }
    return false;
    8001f3ec:	4781                	li	a5,0
}
    8001f3ee:	853e                	mv	a0,a5
    8001f3f0:	70a2                	ld	ra,40(sp)
    8001f3f2:	7402                	ld	s0,32(sp)
    8001f3f4:	6145                	addi	sp,sp,48
    8001f3f6:	8082                	ret

000000008001f3f8 <rb_min_val>:

bool rb_min_val(const RBTree *rb, uint64_t *value)
{
    8001f3f8:	7179                	addi	sp,sp,-48
    8001f3fa:	f406                	sd	ra,40(sp)
    8001f3fc:	f022                	sd	s0,32(sp)
    8001f3fe:	1800                	addi	s0,sp,48
    8001f400:	fca43c23          	sd	a0,-40(s0)
    8001f404:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    8001f408:	fd843783          	ld	a5,-40(s0)
    8001f40c:	639c                	ld	a5,0(a5)
    8001f40e:	e399                	bnez	a5,8001f414 <rb_min_val+0x1c>
        return false;
    8001f410:	4781                	li	a5,0
    8001f412:	a805                	j	8001f442 <rb_min_val+0x4a>
    }
    const Node *n = cminimum(rb->root);
    8001f414:	fd843783          	ld	a5,-40(s0)
    8001f418:	639c                	ld	a5,0(a5)
    8001f41a:	853e                	mv	a0,a5
    8001f41c:	ee1ff0ef          	jal	ra,8001f2fc <cminimum>
    8001f420:	fea43423          	sd	a0,-24(s0)
    if (n) {
    8001f424:	fe843783          	ld	a5,-24(s0)
    8001f428:	cf81                	beqz	a5,8001f440 <rb_min_val+0x48>
        if (value) {
    8001f42a:	fd043783          	ld	a5,-48(s0)
    8001f42e:	c799                	beqz	a5,8001f43c <rb_min_val+0x44>
            *value = n->value;
    8001f430:	fe843783          	ld	a5,-24(s0)
    8001f434:	6798                	ld	a4,8(a5)
    8001f436:	fd043783          	ld	a5,-48(s0)
    8001f43a:	e398                	sd	a4,0(a5)
        }
        return true;
    8001f43c:	4785                	li	a5,1
    8001f43e:	a011                	j	8001f442 <rb_min_val+0x4a>
    }
    return false;
    8001f440:	4781                	li	a5,0
}
    8001f442:	853e                	mv	a0,a5
    8001f444:	70a2                	ld	ra,40(sp)
    8001f446:	7402                	ld	s0,32(sp)
    8001f448:	6145                	addi	sp,sp,48
    8001f44a:	8082                	ret

000000008001f44c <rb_max_val>:

bool rb_max_val(const RBTree *rb, uint64_t *value)
{
    8001f44c:	7179                	addi	sp,sp,-48
    8001f44e:	f406                	sd	ra,40(sp)
    8001f450:	f022                	sd	s0,32(sp)
    8001f452:	1800                	addi	s0,sp,48
    8001f454:	fca43c23          	sd	a0,-40(s0)
    8001f458:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    8001f45c:	fd843783          	ld	a5,-40(s0)
    8001f460:	639c                	ld	a5,0(a5)
    8001f462:	e399                	bnez	a5,8001f468 <rb_max_val+0x1c>
        return false;
    8001f464:	4781                	li	a5,0
    8001f466:	a805                	j	8001f496 <rb_max_val+0x4a>
    }
    const Node *n = cmaximum(rb->root);
    8001f468:	fd843783          	ld	a5,-40(s0)
    8001f46c:	639c                	ld	a5,0(a5)
    8001f46e:	853e                	mv	a0,a5
    8001f470:	eb7ff0ef          	jal	ra,8001f326 <cmaximum>
    8001f474:	fea43423          	sd	a0,-24(s0)
    if (n) {
    8001f478:	fe843783          	ld	a5,-24(s0)
    8001f47c:	cf81                	beqz	a5,8001f494 <rb_max_val+0x48>
        if (value) {
    8001f47e:	fd043783          	ld	a5,-48(s0)
    8001f482:	c799                	beqz	a5,8001f490 <rb_max_val+0x44>
            *value = n->value;
    8001f484:	fe843783          	ld	a5,-24(s0)
    8001f488:	6798                	ld	a4,8(a5)
    8001f48a:	fd043783          	ld	a5,-48(s0)
    8001f48e:	e398                	sd	a4,0(a5)
        }
        return true;
    8001f490:	4785                	li	a5,1
    8001f492:	a011                	j	8001f496 <rb_max_val+0x4a>
    }
    return false;
    8001f494:	4781                	li	a5,0
}
    8001f496:	853e                	mv	a0,a5
    8001f498:	70a2                	ld	ra,40(sp)
    8001f49a:	7402                	ld	s0,32(sp)
    8001f49c:	6145                	addi	sp,sp,48
    8001f49e:	8082                	ret

000000008001f4a0 <left_rotate>:

// Function to left rotate tree at given node
static void left_rotate(RBTree *rb, Node *x)
{
    8001f4a0:	7179                	addi	sp,sp,-48
    8001f4a2:	f422                	sd	s0,40(sp)
    8001f4a4:	1800                	addi	s0,sp,48
    8001f4a6:	fca43c23          	sd	a0,-40(s0)
    8001f4aa:	fcb43823          	sd	a1,-48(s0)
    Node *y  = x->right;
    8001f4ae:	fd043783          	ld	a5,-48(s0)
    8001f4b2:	6f9c                	ld	a5,24(a5)
    8001f4b4:	fef43423          	sd	a5,-24(s0)
    x->right = y->left;
    8001f4b8:	fe843783          	ld	a5,-24(s0)
    8001f4bc:	6b98                	ld	a4,16(a5)
    8001f4be:	fd043783          	ld	a5,-48(s0)
    8001f4c2:	ef98                	sd	a4,24(a5)
    if (y->left != NULL) {
    8001f4c4:	fe843783          	ld	a5,-24(s0)
    8001f4c8:	6b9c                	ld	a5,16(a5)
    8001f4ca:	c799                	beqz	a5,8001f4d8 <left_rotate+0x38>
        y->left->parent = x;
    8001f4cc:	fe843783          	ld	a5,-24(s0)
    8001f4d0:	6b9c                	ld	a5,16(a5)
    8001f4d2:	fd043703          	ld	a4,-48(s0)
    8001f4d6:	f398                	sd	a4,32(a5)
    }
    y->parent = x->parent;
    8001f4d8:	fd043783          	ld	a5,-48(s0)
    8001f4dc:	7398                	ld	a4,32(a5)
    8001f4de:	fe843783          	ld	a5,-24(s0)
    8001f4e2:	f398                	sd	a4,32(a5)
    if (x->parent == NULL) {
    8001f4e4:	fd043783          	ld	a5,-48(s0)
    8001f4e8:	739c                	ld	a5,32(a5)
    8001f4ea:	e799                	bnez	a5,8001f4f8 <left_rotate+0x58>
        rb->root = y;
    8001f4ec:	fd843783          	ld	a5,-40(s0)
    8001f4f0:	fe843703          	ld	a4,-24(s0)
    8001f4f4:	e398                	sd	a4,0(a5)
    8001f4f6:	a035                	j	8001f522 <left_rotate+0x82>
    }
    else if (x == x->parent->left) {
    8001f4f8:	fd043783          	ld	a5,-48(s0)
    8001f4fc:	739c                	ld	a5,32(a5)
    8001f4fe:	6b9c                	ld	a5,16(a5)
    8001f500:	fd043703          	ld	a4,-48(s0)
    8001f504:	00f71963          	bne	a4,a5,8001f516 <left_rotate+0x76>
        x->parent->left = y;
    8001f508:	fd043783          	ld	a5,-48(s0)
    8001f50c:	739c                	ld	a5,32(a5)
    8001f50e:	fe843703          	ld	a4,-24(s0)
    8001f512:	eb98                	sd	a4,16(a5)
    8001f514:	a039                	j	8001f522 <left_rotate+0x82>
    }
    else {
        x->parent->right = y;
    8001f516:	fd043783          	ld	a5,-48(s0)
    8001f51a:	739c                	ld	a5,32(a5)
    8001f51c:	fe843703          	ld	a4,-24(s0)
    8001f520:	ef98                	sd	a4,24(a5)
    }
    y->left   = x;
    8001f522:	fe843783          	ld	a5,-24(s0)
    8001f526:	fd043703          	ld	a4,-48(s0)
    8001f52a:	eb98                	sd	a4,16(a5)
    x->parent = y;
    8001f52c:	fd043783          	ld	a5,-48(s0)
    8001f530:	fe843703          	ld	a4,-24(s0)
    8001f534:	f398                	sd	a4,32(a5)
}
    8001f536:	0001                	nop
    8001f538:	7422                	ld	s0,40(sp)
    8001f53a:	6145                	addi	sp,sp,48
    8001f53c:	8082                	ret

000000008001f53e <right_rotate>:

// Function to right rotate tree at given node
static void right_rotate(RBTree *rb, Node *y)
{
    8001f53e:	7179                	addi	sp,sp,-48
    8001f540:	f422                	sd	s0,40(sp)
    8001f542:	1800                	addi	s0,sp,48
    8001f544:	fca43c23          	sd	a0,-40(s0)
    8001f548:	fcb43823          	sd	a1,-48(s0)
    Node *x = y->left;
    8001f54c:	fd043783          	ld	a5,-48(s0)
    8001f550:	6b9c                	ld	a5,16(a5)
    8001f552:	fef43423          	sd	a5,-24(s0)
    y->left = x->right;
    8001f556:	fe843783          	ld	a5,-24(s0)
    8001f55a:	6f98                	ld	a4,24(a5)
    8001f55c:	fd043783          	ld	a5,-48(s0)
    8001f560:	eb98                	sd	a4,16(a5)
    if (x->right != NULL) {
    8001f562:	fe843783          	ld	a5,-24(s0)
    8001f566:	6f9c                	ld	a5,24(a5)
    8001f568:	c799                	beqz	a5,8001f576 <right_rotate+0x38>
        x->right->parent = y;
    8001f56a:	fe843783          	ld	a5,-24(s0)
    8001f56e:	6f9c                	ld	a5,24(a5)
    8001f570:	fd043703          	ld	a4,-48(s0)
    8001f574:	f398                	sd	a4,32(a5)
    }
    x->parent = y->parent;
    8001f576:	fd043783          	ld	a5,-48(s0)
    8001f57a:	7398                	ld	a4,32(a5)
    8001f57c:	fe843783          	ld	a5,-24(s0)
    8001f580:	f398                	sd	a4,32(a5)
    if (y->parent == NULL) {
    8001f582:	fd043783          	ld	a5,-48(s0)
    8001f586:	739c                	ld	a5,32(a5)
    8001f588:	e799                	bnez	a5,8001f596 <right_rotate+0x58>
        rb->root = x;
    8001f58a:	fd843783          	ld	a5,-40(s0)
    8001f58e:	fe843703          	ld	a4,-24(s0)
    8001f592:	e398                	sd	a4,0(a5)
    8001f594:	a035                	j	8001f5c0 <right_rotate+0x82>
    }
    else if (y == y->parent->left) {
    8001f596:	fd043783          	ld	a5,-48(s0)
    8001f59a:	739c                	ld	a5,32(a5)
    8001f59c:	6b9c                	ld	a5,16(a5)
    8001f59e:	fd043703          	ld	a4,-48(s0)
    8001f5a2:	00f71963          	bne	a4,a5,8001f5b4 <right_rotate+0x76>
        y->parent->left = x;
    8001f5a6:	fd043783          	ld	a5,-48(s0)
    8001f5aa:	739c                	ld	a5,32(a5)
    8001f5ac:	fe843703          	ld	a4,-24(s0)
    8001f5b0:	eb98                	sd	a4,16(a5)
    8001f5b2:	a039                	j	8001f5c0 <right_rotate+0x82>
    }
    else {
        y->parent->right = x;
    8001f5b4:	fd043783          	ld	a5,-48(s0)
    8001f5b8:	739c                	ld	a5,32(a5)
    8001f5ba:	fe843703          	ld	a4,-24(s0)
    8001f5be:	ef98                	sd	a4,24(a5)
    }
    x->right  = y;
    8001f5c0:	fe843783          	ld	a5,-24(s0)
    8001f5c4:	fd043703          	ld	a4,-48(s0)
    8001f5c8:	ef98                	sd	a4,24(a5)
    y->parent = x;
    8001f5ca:	fd043783          	ld	a5,-48(s0)
    8001f5ce:	fe843703          	ld	a4,-24(s0)
    8001f5d2:	f398                	sd	a4,32(a5)
}
    8001f5d4:	0001                	nop
    8001f5d6:	7422                	ld	s0,40(sp)
    8001f5d8:	6145                	addi	sp,sp,48
    8001f5da:	8082                	ret

000000008001f5dc <fix_insert>:

// Function to fix the red-black tree after insertion
static void fix_insert(RBTree *rb, Node *z)
{
    8001f5dc:	7179                	addi	sp,sp,-48
    8001f5de:	f406                	sd	ra,40(sp)
    8001f5e0:	f022                	sd	s0,32(sp)
    8001f5e2:	1800                	addi	s0,sp,48
    8001f5e4:	fca43c23          	sd	a0,-40(s0)
    8001f5e8:	fcb43823          	sd	a1,-48(s0)
    while (z != rb->root && z->parent->color == RED) {
    8001f5ec:	a291                	j	8001f730 <fix_insert+0x154>
        if (z->parent == z->parent->parent->left) {
    8001f5ee:	fd043783          	ld	a5,-48(s0)
    8001f5f2:	7398                	ld	a4,32(a5)
    8001f5f4:	fd043783          	ld	a5,-48(s0)
    8001f5f8:	739c                	ld	a5,32(a5)
    8001f5fa:	739c                	ld	a5,32(a5)
    8001f5fc:	6b9c                	ld	a5,16(a5)
    8001f5fe:	08f71e63          	bne	a4,a5,8001f69a <fix_insert+0xbe>
            Node *y = z->parent->parent->right;
    8001f602:	fd043783          	ld	a5,-48(s0)
    8001f606:	739c                	ld	a5,32(a5)
    8001f608:	739c                	ld	a5,32(a5)
    8001f60a:	6f9c                	ld	a5,24(a5)
    8001f60c:	fef43023          	sd	a5,-32(s0)
            if (y != NULL && y->color == RED) {
    8001f610:	fe043783          	ld	a5,-32(s0)
    8001f614:	cb9d                	beqz	a5,8001f64a <fix_insert+0x6e>
    8001f616:	fe043783          	ld	a5,-32(s0)
    8001f61a:	439c                	lw	a5,0(a5)
    8001f61c:	e79d                	bnez	a5,8001f64a <fix_insert+0x6e>
                z->parent->color         = BLACK;
    8001f61e:	fd043783          	ld	a5,-48(s0)
    8001f622:	739c                	ld	a5,32(a5)
    8001f624:	4705                	li	a4,1
    8001f626:	c398                	sw	a4,0(a5)
                y->color                 = BLACK;
    8001f628:	fe043783          	ld	a5,-32(s0)
    8001f62c:	4705                	li	a4,1
    8001f62e:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    8001f630:	fd043783          	ld	a5,-48(s0)
    8001f634:	739c                	ld	a5,32(a5)
    8001f636:	739c                	ld	a5,32(a5)
    8001f638:	0007a023          	sw	zero,0(a5)
                z                        = z->parent->parent;
    8001f63c:	fd043783          	ld	a5,-48(s0)
    8001f640:	739c                	ld	a5,32(a5)
    8001f642:	739c                	ld	a5,32(a5)
    8001f644:	fcf43823          	sd	a5,-48(s0)
    8001f648:	a0e5                	j	8001f730 <fix_insert+0x154>
            }
            else {
                if (z == z->parent->right) {
    8001f64a:	fd043783          	ld	a5,-48(s0)
    8001f64e:	739c                	ld	a5,32(a5)
    8001f650:	6f9c                	ld	a5,24(a5)
    8001f652:	fd043703          	ld	a4,-48(s0)
    8001f656:	00f71d63          	bne	a4,a5,8001f670 <fix_insert+0x94>
                    z = z->parent;
    8001f65a:	fd043783          	ld	a5,-48(s0)
    8001f65e:	739c                	ld	a5,32(a5)
    8001f660:	fcf43823          	sd	a5,-48(s0)
                    left_rotate(rb, z);
    8001f664:	fd043583          	ld	a1,-48(s0)
    8001f668:	fd843503          	ld	a0,-40(s0)
    8001f66c:	e35ff0ef          	jal	ra,8001f4a0 <left_rotate>
                }
                z->parent->color         = BLACK;
    8001f670:	fd043783          	ld	a5,-48(s0)
    8001f674:	739c                	ld	a5,32(a5)
    8001f676:	4705                	li	a4,1
    8001f678:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    8001f67a:	fd043783          	ld	a5,-48(s0)
    8001f67e:	739c                	ld	a5,32(a5)
    8001f680:	739c                	ld	a5,32(a5)
    8001f682:	0007a023          	sw	zero,0(a5)
                right_rotate(rb, z->parent->parent);
    8001f686:	fd043783          	ld	a5,-48(s0)
    8001f68a:	739c                	ld	a5,32(a5)
    8001f68c:	739c                	ld	a5,32(a5)
    8001f68e:	85be                	mv	a1,a5
    8001f690:	fd843503          	ld	a0,-40(s0)
    8001f694:	eabff0ef          	jal	ra,8001f53e <right_rotate>
    8001f698:	a861                	j	8001f730 <fix_insert+0x154>
            }
        }
        else {
            Node *y = z->parent->parent->left;
    8001f69a:	fd043783          	ld	a5,-48(s0)
    8001f69e:	739c                	ld	a5,32(a5)
    8001f6a0:	739c                	ld	a5,32(a5)
    8001f6a2:	6b9c                	ld	a5,16(a5)
    8001f6a4:	fef43423          	sd	a5,-24(s0)
            if (y != NULL && y->color == RED) {
    8001f6a8:	fe843783          	ld	a5,-24(s0)
    8001f6ac:	cb9d                	beqz	a5,8001f6e2 <fix_insert+0x106>
    8001f6ae:	fe843783          	ld	a5,-24(s0)
    8001f6b2:	439c                	lw	a5,0(a5)
    8001f6b4:	e79d                	bnez	a5,8001f6e2 <fix_insert+0x106>
                z->parent->color         = BLACK;
    8001f6b6:	fd043783          	ld	a5,-48(s0)
    8001f6ba:	739c                	ld	a5,32(a5)
    8001f6bc:	4705                	li	a4,1
    8001f6be:	c398                	sw	a4,0(a5)
                y->color                 = BLACK;
    8001f6c0:	fe843783          	ld	a5,-24(s0)
    8001f6c4:	4705                	li	a4,1
    8001f6c6:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    8001f6c8:	fd043783          	ld	a5,-48(s0)
    8001f6cc:	739c                	ld	a5,32(a5)
    8001f6ce:	739c                	ld	a5,32(a5)
    8001f6d0:	0007a023          	sw	zero,0(a5)
                z                        = z->parent->parent;
    8001f6d4:	fd043783          	ld	a5,-48(s0)
    8001f6d8:	739c                	ld	a5,32(a5)
    8001f6da:	739c                	ld	a5,32(a5)
    8001f6dc:	fcf43823          	sd	a5,-48(s0)
    8001f6e0:	a881                	j	8001f730 <fix_insert+0x154>
            }
            else {
                if (z == z->parent->left) {
    8001f6e2:	fd043783          	ld	a5,-48(s0)
    8001f6e6:	739c                	ld	a5,32(a5)
    8001f6e8:	6b9c                	ld	a5,16(a5)
    8001f6ea:	fd043703          	ld	a4,-48(s0)
    8001f6ee:	00f71d63          	bne	a4,a5,8001f708 <fix_insert+0x12c>
                    z = z->parent;
    8001f6f2:	fd043783          	ld	a5,-48(s0)
    8001f6f6:	739c                	ld	a5,32(a5)
    8001f6f8:	fcf43823          	sd	a5,-48(s0)
                    right_rotate(rb, z);
    8001f6fc:	fd043583          	ld	a1,-48(s0)
    8001f700:	fd843503          	ld	a0,-40(s0)
    8001f704:	e3bff0ef          	jal	ra,8001f53e <right_rotate>
                }
                z->parent->color         = BLACK;
    8001f708:	fd043783          	ld	a5,-48(s0)
    8001f70c:	739c                	ld	a5,32(a5)
    8001f70e:	4705                	li	a4,1
    8001f710:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    8001f712:	fd043783          	ld	a5,-48(s0)
    8001f716:	739c                	ld	a5,32(a5)
    8001f718:	739c                	ld	a5,32(a5)
    8001f71a:	0007a023          	sw	zero,0(a5)
                left_rotate(rb, z->parent->parent);
    8001f71e:	fd043783          	ld	a5,-48(s0)
    8001f722:	739c                	ld	a5,32(a5)
    8001f724:	739c                	ld	a5,32(a5)
    8001f726:	85be                	mv	a1,a5
    8001f728:	fd843503          	ld	a0,-40(s0)
    8001f72c:	d75ff0ef          	jal	ra,8001f4a0 <left_rotate>
    while (z != rb->root && z->parent->color == RED) {
    8001f730:	fd843783          	ld	a5,-40(s0)
    8001f734:	639c                	ld	a5,0(a5)
    8001f736:	fd043703          	ld	a4,-48(s0)
    8001f73a:	00f70863          	beq	a4,a5,8001f74a <fix_insert+0x16e>
    8001f73e:	fd043783          	ld	a5,-48(s0)
    8001f742:	739c                	ld	a5,32(a5)
    8001f744:	439c                	lw	a5,0(a5)
    8001f746:	ea0784e3          	beqz	a5,8001f5ee <fix_insert+0x12>
            }
        }
    }
    rb->root->color = BLACK;
    8001f74a:	fd843783          	ld	a5,-40(s0)
    8001f74e:	639c                	ld	a5,0(a5)
    8001f750:	4705                	li	a4,1
    8001f752:	c398                	sw	a4,0(a5)
}
    8001f754:	0001                	nop
    8001f756:	70a2                	ld	ra,40(sp)
    8001f758:	7402                	ld	s0,32(sp)
    8001f75a:	6145                	addi	sp,sp,48
    8001f75c:	8082                	ret

000000008001f75e <rb_insert>:

// Function to insert a node into the red-black tree
void rb_insert(RBTree *rb, int key, uint64_t value)
{
    8001f75e:	715d                	addi	sp,sp,-80
    8001f760:	e486                	sd	ra,72(sp)
    8001f762:	e0a2                	sd	s0,64(sp)
    8001f764:	0880                	addi	s0,sp,80
    8001f766:	fca43423          	sd	a0,-56(s0)
    8001f76a:	87ae                	mv	a5,a1
    8001f76c:	fac43c23          	sd	a2,-72(s0)
    8001f770:	fcf42223          	sw	a5,-60(s0)
    Node *z = create_node(key, value);
    8001f774:	fc442783          	lw	a5,-60(s0)
    8001f778:	fb843583          	ld	a1,-72(s0)
    8001f77c:	853e                	mv	a0,a5
    8001f77e:	a2dff0ef          	jal	ra,8001f1aa <create_node>
    8001f782:	fca43c23          	sd	a0,-40(s0)
    Node *y = NULL;
    8001f786:	fe043423          	sd	zero,-24(s0)
    Node *x = rb->root;
    8001f78a:	fc843783          	ld	a5,-56(s0)
    8001f78e:	639c                	ld	a5,0(a5)
    8001f790:	fef43023          	sd	a5,-32(s0)
    while (x != NULL) {
    8001f794:	a805                	j	8001f7c4 <rb_insert+0x66>
        y = x;
    8001f796:	fe043783          	ld	a5,-32(s0)
    8001f79a:	fef43423          	sd	a5,-24(s0)
        if (z->key < x->key) {
    8001f79e:	fd843783          	ld	a5,-40(s0)
    8001f7a2:	43d8                	lw	a4,4(a5)
    8001f7a4:	fe043783          	ld	a5,-32(s0)
    8001f7a8:	43dc                	lw	a5,4(a5)
    8001f7aa:	00f75863          	bge	a4,a5,8001f7ba <rb_insert+0x5c>
            x = x->left;
    8001f7ae:	fe043783          	ld	a5,-32(s0)
    8001f7b2:	6b9c                	ld	a5,16(a5)
    8001f7b4:	fef43023          	sd	a5,-32(s0)
    8001f7b8:	a031                	j	8001f7c4 <rb_insert+0x66>
        }
        else {
            x = x->right;
    8001f7ba:	fe043783          	ld	a5,-32(s0)
    8001f7be:	6f9c                	ld	a5,24(a5)
    8001f7c0:	fef43023          	sd	a5,-32(s0)
    while (x != NULL) {
    8001f7c4:	fe043783          	ld	a5,-32(s0)
    8001f7c8:	f7f9                	bnez	a5,8001f796 <rb_insert+0x38>
        }
    }
    z->parent = y;
    8001f7ca:	fd843783          	ld	a5,-40(s0)
    8001f7ce:	fe843703          	ld	a4,-24(s0)
    8001f7d2:	f398                	sd	a4,32(a5)
    if (y == NULL) {
    8001f7d4:	fe843783          	ld	a5,-24(s0)
    8001f7d8:	e799                	bnez	a5,8001f7e6 <rb_insert+0x88>
        rb->root = z;
    8001f7da:	fc843783          	ld	a5,-56(s0)
    8001f7de:	fd843703          	ld	a4,-40(s0)
    8001f7e2:	e398                	sd	a4,0(a5)
    8001f7e4:	a025                	j	8001f80c <rb_insert+0xae>
    }
    else if (z->key < y->key) {
    8001f7e6:	fd843783          	ld	a5,-40(s0)
    8001f7ea:	43d8                	lw	a4,4(a5)
    8001f7ec:	fe843783          	ld	a5,-24(s0)
    8001f7f0:	43dc                	lw	a5,4(a5)
    8001f7f2:	00f75863          	bge	a4,a5,8001f802 <rb_insert+0xa4>
        y->left = z;
    8001f7f6:	fe843783          	ld	a5,-24(s0)
    8001f7fa:	fd843703          	ld	a4,-40(s0)
    8001f7fe:	eb98                	sd	a4,16(a5)
    8001f800:	a031                	j	8001f80c <rb_insert+0xae>
    }
    else {
        y->right = z;
    8001f802:	fe843783          	ld	a5,-24(s0)
    8001f806:	fd843703          	ld	a4,-40(s0)
    8001f80a:	ef98                	sd	a4,24(a5)
    }
    fix_insert(rb, z);
    8001f80c:	fd843583          	ld	a1,-40(s0)
    8001f810:	fc843503          	ld	a0,-56(s0)
    8001f814:	dc9ff0ef          	jal	ra,8001f5dc <fix_insert>
}
    8001f818:	0001                	nop
    8001f81a:	60a6                	ld	ra,72(sp)
    8001f81c:	6406                	ld	s0,64(sp)
    8001f81e:	6161                	addi	sp,sp,80
    8001f820:	8082                	ret

000000008001f822 <transplant>:

static void transplant(RBTree *rb, Node *u, Node *v)
{
    8001f822:	7179                	addi	sp,sp,-48
    8001f824:	f422                	sd	s0,40(sp)
    8001f826:	1800                	addi	s0,sp,48
    8001f828:	fea43423          	sd	a0,-24(s0)
    8001f82c:	feb43023          	sd	a1,-32(s0)
    8001f830:	fcc43c23          	sd	a2,-40(s0)
    if (u->parent == NULL) {
    8001f834:	fe043783          	ld	a5,-32(s0)
    8001f838:	739c                	ld	a5,32(a5)
    8001f83a:	e799                	bnez	a5,8001f848 <transplant+0x26>
        rb->root = v;
    8001f83c:	fe843783          	ld	a5,-24(s0)
    8001f840:	fd843703          	ld	a4,-40(s0)
    8001f844:	e398                	sd	a4,0(a5)
    8001f846:	a035                	j	8001f872 <transplant+0x50>
    }
    else if (u == u->parent->left) {
    8001f848:	fe043783          	ld	a5,-32(s0)
    8001f84c:	739c                	ld	a5,32(a5)
    8001f84e:	6b9c                	ld	a5,16(a5)
    8001f850:	fe043703          	ld	a4,-32(s0)
    8001f854:	00f71963          	bne	a4,a5,8001f866 <transplant+0x44>
        u->parent->left = v;
    8001f858:	fe043783          	ld	a5,-32(s0)
    8001f85c:	739c                	ld	a5,32(a5)
    8001f85e:	fd843703          	ld	a4,-40(s0)
    8001f862:	eb98                	sd	a4,16(a5)
    8001f864:	a039                	j	8001f872 <transplant+0x50>
    }
    else {
        u->parent->right = v;
    8001f866:	fe043783          	ld	a5,-32(s0)
    8001f86a:	739c                	ld	a5,32(a5)
    8001f86c:	fd843703          	ld	a4,-40(s0)
    8001f870:	ef98                	sd	a4,24(a5)
    }
    if (v != NULL) {
    8001f872:	fd843783          	ld	a5,-40(s0)
    8001f876:	c799                	beqz	a5,8001f884 <transplant+0x62>
        v->parent = u->parent;
    8001f878:	fe043783          	ld	a5,-32(s0)
    8001f87c:	7398                	ld	a4,32(a5)
    8001f87e:	fd843783          	ld	a5,-40(s0)
    8001f882:	f398                	sd	a4,32(a5)
    }
}
    8001f884:	0001                	nop
    8001f886:	7422                	ld	s0,40(sp)
    8001f888:	6145                	addi	sp,sp,48
    8001f88a:	8082                	ret

000000008001f88c <delete_fixup>:

static void delete_fixup(RBTree *rb, Node *x, Node *x_parent)
{
    8001f88c:	7139                	addi	sp,sp,-64
    8001f88e:	fc06                	sd	ra,56(sp)
    8001f890:	f822                	sd	s0,48(sp)
    8001f892:	0080                	addi	s0,sp,64
    8001f894:	fca43c23          	sd	a0,-40(s0)
    8001f898:	fcb43823          	sd	a1,-48(s0)
    8001f89c:	fcc43423          	sd	a2,-56(s0)
    Node *w;
    while (x != rb->root && (x == NULL || x->color == BLACK)) {
    8001f8a0:	a415                	j	8001fac4 <delete_fixup+0x238>
        if (x == x_parent->left) {
    8001f8a2:	fc843783          	ld	a5,-56(s0)
    8001f8a6:	6b9c                	ld	a5,16(a5)
    8001f8a8:	fd043703          	ld	a4,-48(s0)
    8001f8ac:	10f71763          	bne	a4,a5,8001f9ba <delete_fixup+0x12e>
            w = x_parent->right;
    8001f8b0:	fc843783          	ld	a5,-56(s0)
    8001f8b4:	6f9c                	ld	a5,24(a5)
    8001f8b6:	fef43423          	sd	a5,-24(s0)
            if (w->color == RED) {
    8001f8ba:	fe843783          	ld	a5,-24(s0)
    8001f8be:	439c                	lw	a5,0(a5)
    8001f8c0:	e785                	bnez	a5,8001f8e8 <delete_fixup+0x5c>
                w->color        = BLACK;
    8001f8c2:	fe843783          	ld	a5,-24(s0)
    8001f8c6:	4705                	li	a4,1
    8001f8c8:	c398                	sw	a4,0(a5)
                x_parent->color = RED;
    8001f8ca:	fc843783          	ld	a5,-56(s0)
    8001f8ce:	0007a023          	sw	zero,0(a5)
                left_rotate(rb, x_parent);
    8001f8d2:	fc843583          	ld	a1,-56(s0)
    8001f8d6:	fd843503          	ld	a0,-40(s0)
    8001f8da:	bc7ff0ef          	jal	ra,8001f4a0 <left_rotate>
                w = x_parent->right;
    8001f8de:	fc843783          	ld	a5,-56(s0)
    8001f8e2:	6f9c                	ld	a5,24(a5)
    8001f8e4:	fef43423          	sd	a5,-24(s0)
            }
            if ((w->left == NULL || w->left->color == BLACK) &&
    8001f8e8:	fe843783          	ld	a5,-24(s0)
    8001f8ec:	6b9c                	ld	a5,16(a5)
    8001f8ee:	cb89                	beqz	a5,8001f900 <delete_fixup+0x74>
    8001f8f0:	fe843783          	ld	a5,-24(s0)
    8001f8f4:	6b9c                	ld	a5,16(a5)
    8001f8f6:	439c                	lw	a5,0(a5)
    8001f8f8:	873e                	mv	a4,a5
    8001f8fa:	4785                	li	a5,1
    8001f8fc:	02f71c63          	bne	a4,a5,8001f934 <delete_fixup+0xa8>
                (w->right == NULL || w->right->color == BLACK)) {
    8001f900:	fe843783          	ld	a5,-24(s0)
    8001f904:	6f9c                	ld	a5,24(a5)
            if ((w->left == NULL || w->left->color == BLACK) &&
    8001f906:	cb89                	beqz	a5,8001f918 <delete_fixup+0x8c>
                (w->right == NULL || w->right->color == BLACK)) {
    8001f908:	fe843783          	ld	a5,-24(s0)
    8001f90c:	6f9c                	ld	a5,24(a5)
    8001f90e:	439c                	lw	a5,0(a5)
    8001f910:	873e                	mv	a4,a5
    8001f912:	4785                	li	a5,1
    8001f914:	02f71063          	bne	a4,a5,8001f934 <delete_fixup+0xa8>
                w->color = RED;
    8001f918:	fe843783          	ld	a5,-24(s0)
    8001f91c:	0007a023          	sw	zero,0(a5)
                x        = x_parent;
    8001f920:	fc843783          	ld	a5,-56(s0)
    8001f924:	fcf43823          	sd	a5,-48(s0)
                x_parent = x_parent->parent;
    8001f928:	fc843783          	ld	a5,-56(s0)
    8001f92c:	739c                	ld	a5,32(a5)
    8001f92e:	fcf43423          	sd	a5,-56(s0)
    8001f932:	aa49                	j	8001fac4 <delete_fixup+0x238>
            }
            else {
                if (w->right == NULL || w->right->color == BLACK) {
    8001f934:	fe843783          	ld	a5,-24(s0)
    8001f938:	6f9c                	ld	a5,24(a5)
    8001f93a:	cb89                	beqz	a5,8001f94c <delete_fixup+0xc0>
    8001f93c:	fe843783          	ld	a5,-24(s0)
    8001f940:	6f9c                	ld	a5,24(a5)
    8001f942:	439c                	lw	a5,0(a5)
    8001f944:	873e                	mv	a4,a5
    8001f946:	4785                	li	a5,1
    8001f948:	02f71a63          	bne	a4,a5,8001f97c <delete_fixup+0xf0>
                    if (w->left != NULL) {
    8001f94c:	fe843783          	ld	a5,-24(s0)
    8001f950:	6b9c                	ld	a5,16(a5)
    8001f952:	c791                	beqz	a5,8001f95e <delete_fixup+0xd2>
                        w->left->color = BLACK;
    8001f954:	fe843783          	ld	a5,-24(s0)
    8001f958:	6b9c                	ld	a5,16(a5)
    8001f95a:	4705                	li	a4,1
    8001f95c:	c398                	sw	a4,0(a5)
                    }
                    w->color = RED;
    8001f95e:	fe843783          	ld	a5,-24(s0)
    8001f962:	0007a023          	sw	zero,0(a5)
                    right_rotate(rb, w);
    8001f966:	fe843583          	ld	a1,-24(s0)
    8001f96a:	fd843503          	ld	a0,-40(s0)
    8001f96e:	bd1ff0ef          	jal	ra,8001f53e <right_rotate>
                    w = x_parent->right;
    8001f972:	fc843783          	ld	a5,-56(s0)
    8001f976:	6f9c                	ld	a5,24(a5)
    8001f978:	fef43423          	sd	a5,-24(s0)
                }
                w->color        = x_parent->color;
    8001f97c:	fc843783          	ld	a5,-56(s0)
    8001f980:	4398                	lw	a4,0(a5)
    8001f982:	fe843783          	ld	a5,-24(s0)
    8001f986:	c398                	sw	a4,0(a5)
                x_parent->color = BLACK;
    8001f988:	fc843783          	ld	a5,-56(s0)
    8001f98c:	4705                	li	a4,1
    8001f98e:	c398                	sw	a4,0(a5)
                if (w->right != NULL) {
    8001f990:	fe843783          	ld	a5,-24(s0)
    8001f994:	6f9c                	ld	a5,24(a5)
    8001f996:	c791                	beqz	a5,8001f9a2 <delete_fixup+0x116>
                    w->right->color = BLACK;
    8001f998:	fe843783          	ld	a5,-24(s0)
    8001f99c:	6f9c                	ld	a5,24(a5)
    8001f99e:	4705                	li	a4,1
    8001f9a0:	c398                	sw	a4,0(a5)
                }
                left_rotate(rb, x_parent);
    8001f9a2:	fc843583          	ld	a1,-56(s0)
    8001f9a6:	fd843503          	ld	a0,-40(s0)
    8001f9aa:	af7ff0ef          	jal	ra,8001f4a0 <left_rotate>
                x = rb->root;
    8001f9ae:	fd843783          	ld	a5,-40(s0)
    8001f9b2:	639c                	ld	a5,0(a5)
    8001f9b4:	fcf43823          	sd	a5,-48(s0)
                break;
    8001f9b8:	aa05                	j	8001fae8 <delete_fixup+0x25c>
            }
        }
        else {
            w = x_parent->left;
    8001f9ba:	fc843783          	ld	a5,-56(s0)
    8001f9be:	6b9c                	ld	a5,16(a5)
    8001f9c0:	fef43423          	sd	a5,-24(s0)
            if (w->color == RED) {
    8001f9c4:	fe843783          	ld	a5,-24(s0)
    8001f9c8:	439c                	lw	a5,0(a5)
    8001f9ca:	e785                	bnez	a5,8001f9f2 <delete_fixup+0x166>
                w->color        = BLACK;
    8001f9cc:	fe843783          	ld	a5,-24(s0)
    8001f9d0:	4705                	li	a4,1
    8001f9d2:	c398                	sw	a4,0(a5)
                x_parent->color = RED;
    8001f9d4:	fc843783          	ld	a5,-56(s0)
    8001f9d8:	0007a023          	sw	zero,0(a5)
                right_rotate(rb, x_parent);
    8001f9dc:	fc843583          	ld	a1,-56(s0)
    8001f9e0:	fd843503          	ld	a0,-40(s0)
    8001f9e4:	b5bff0ef          	jal	ra,8001f53e <right_rotate>
                w = x_parent->left;
    8001f9e8:	fc843783          	ld	a5,-56(s0)
    8001f9ec:	6b9c                	ld	a5,16(a5)
    8001f9ee:	fef43423          	sd	a5,-24(s0)
            }
            if ((w->left == NULL || w->left->color == BLACK) &&
    8001f9f2:	fe843783          	ld	a5,-24(s0)
    8001f9f6:	6b9c                	ld	a5,16(a5)
    8001f9f8:	cb89                	beqz	a5,8001fa0a <delete_fixup+0x17e>
    8001f9fa:	fe843783          	ld	a5,-24(s0)
    8001f9fe:	6b9c                	ld	a5,16(a5)
    8001fa00:	439c                	lw	a5,0(a5)
    8001fa02:	873e                	mv	a4,a5
    8001fa04:	4785                	li	a5,1
    8001fa06:	02f71c63          	bne	a4,a5,8001fa3e <delete_fixup+0x1b2>
                (w->right == NULL || w->right->color == BLACK)) {
    8001fa0a:	fe843783          	ld	a5,-24(s0)
    8001fa0e:	6f9c                	ld	a5,24(a5)
            if ((w->left == NULL || w->left->color == BLACK) &&
    8001fa10:	cb89                	beqz	a5,8001fa22 <delete_fixup+0x196>
                (w->right == NULL || w->right->color == BLACK)) {
    8001fa12:	fe843783          	ld	a5,-24(s0)
    8001fa16:	6f9c                	ld	a5,24(a5)
    8001fa18:	439c                	lw	a5,0(a5)
    8001fa1a:	873e                	mv	a4,a5
    8001fa1c:	4785                	li	a5,1
    8001fa1e:	02f71063          	bne	a4,a5,8001fa3e <delete_fixup+0x1b2>
                w->color = RED;
    8001fa22:	fe843783          	ld	a5,-24(s0)
    8001fa26:	0007a023          	sw	zero,0(a5)
                x        = x_parent;
    8001fa2a:	fc843783          	ld	a5,-56(s0)
    8001fa2e:	fcf43823          	sd	a5,-48(s0)
                x_parent = x_parent->parent;
    8001fa32:	fc843783          	ld	a5,-56(s0)
    8001fa36:	739c                	ld	a5,32(a5)
    8001fa38:	fcf43423          	sd	a5,-56(s0)
    8001fa3c:	a061                	j	8001fac4 <delete_fixup+0x238>
            }
            else {
                if (w->left == NULL || w->left->color == BLACK) {
    8001fa3e:	fe843783          	ld	a5,-24(s0)
    8001fa42:	6b9c                	ld	a5,16(a5)
    8001fa44:	cb89                	beqz	a5,8001fa56 <delete_fixup+0x1ca>
    8001fa46:	fe843783          	ld	a5,-24(s0)
    8001fa4a:	6b9c                	ld	a5,16(a5)
    8001fa4c:	439c                	lw	a5,0(a5)
    8001fa4e:	873e                	mv	a4,a5
    8001fa50:	4785                	li	a5,1
    8001fa52:	02f71a63          	bne	a4,a5,8001fa86 <delete_fixup+0x1fa>
                    if (w->right != NULL) {
    8001fa56:	fe843783          	ld	a5,-24(s0)
    8001fa5a:	6f9c                	ld	a5,24(a5)
    8001fa5c:	c791                	beqz	a5,8001fa68 <delete_fixup+0x1dc>
                        w->right->color = BLACK;
    8001fa5e:	fe843783          	ld	a5,-24(s0)
    8001fa62:	6f9c                	ld	a5,24(a5)
    8001fa64:	4705                	li	a4,1
    8001fa66:	c398                	sw	a4,0(a5)
                    }
                    w->color = RED;
    8001fa68:	fe843783          	ld	a5,-24(s0)
    8001fa6c:	0007a023          	sw	zero,0(a5)
                    left_rotate(rb, w);
    8001fa70:	fe843583          	ld	a1,-24(s0)
    8001fa74:	fd843503          	ld	a0,-40(s0)
    8001fa78:	a29ff0ef          	jal	ra,8001f4a0 <left_rotate>
                    w = x_parent->left;
    8001fa7c:	fc843783          	ld	a5,-56(s0)
    8001fa80:	6b9c                	ld	a5,16(a5)
    8001fa82:	fef43423          	sd	a5,-24(s0)
                }
                w->color        = x_parent->color;
    8001fa86:	fc843783          	ld	a5,-56(s0)
    8001fa8a:	4398                	lw	a4,0(a5)
    8001fa8c:	fe843783          	ld	a5,-24(s0)
    8001fa90:	c398                	sw	a4,0(a5)
                x_parent->color = BLACK;
    8001fa92:	fc843783          	ld	a5,-56(s0)
    8001fa96:	4705                	li	a4,1
    8001fa98:	c398                	sw	a4,0(a5)
                if (w->left != NULL) {
    8001fa9a:	fe843783          	ld	a5,-24(s0)
    8001fa9e:	6b9c                	ld	a5,16(a5)
    8001faa0:	c791                	beqz	a5,8001faac <delete_fixup+0x220>
                    w->left->color = BLACK;
    8001faa2:	fe843783          	ld	a5,-24(s0)
    8001faa6:	6b9c                	ld	a5,16(a5)
    8001faa8:	4705                	li	a4,1
    8001faaa:	c398                	sw	a4,0(a5)
                }
                right_rotate(rb, x_parent);
    8001faac:	fc843583          	ld	a1,-56(s0)
    8001fab0:	fd843503          	ld	a0,-40(s0)
    8001fab4:	a8bff0ef          	jal	ra,8001f53e <right_rotate>
                x = rb->root;
    8001fab8:	fd843783          	ld	a5,-40(s0)
    8001fabc:	639c                	ld	a5,0(a5)
    8001fabe:	fcf43823          	sd	a5,-48(s0)
                break;
    8001fac2:	a01d                	j	8001fae8 <delete_fixup+0x25c>
    while (x != rb->root && (x == NULL || x->color == BLACK)) {
    8001fac4:	fd843783          	ld	a5,-40(s0)
    8001fac8:	639c                	ld	a5,0(a5)
    8001faca:	fd043703          	ld	a4,-48(s0)
    8001face:	00f70d63          	beq	a4,a5,8001fae8 <delete_fixup+0x25c>
    8001fad2:	fd043783          	ld	a5,-48(s0)
    8001fad6:	dc0786e3          	beqz	a5,8001f8a2 <delete_fixup+0x16>
    8001fada:	fd043783          	ld	a5,-48(s0)
    8001fade:	439c                	lw	a5,0(a5)
    8001fae0:	873e                	mv	a4,a5
    8001fae2:	4785                	li	a5,1
    8001fae4:	daf70fe3          	beq	a4,a5,8001f8a2 <delete_fixup+0x16>
            }
        }
    }
    if (x != NULL) {
    8001fae8:	fd043783          	ld	a5,-48(s0)
    8001faec:	c789                	beqz	a5,8001faf6 <delete_fixup+0x26a>
        x->color = BLACK;
    8001faee:	fd043783          	ld	a5,-48(s0)
    8001faf2:	4705                	li	a4,1
    8001faf4:	c398                	sw	a4,0(a5)
    }
}
    8001faf6:	0001                	nop
    8001faf8:	70e2                	ld	ra,56(sp)
    8001fafa:	7442                	ld	s0,48(sp)
    8001fafc:	6121                	addi	sp,sp,64
    8001fafe:	8082                	ret

000000008001fb00 <rb_delete>:

void rb_delete(RBTree *rb, int key)
{
    8001fb00:	7139                	addi	sp,sp,-64
    8001fb02:	fc06                	sd	ra,56(sp)
    8001fb04:	f822                	sd	s0,48(sp)
    8001fb06:	0080                	addi	s0,sp,64
    8001fb08:	fca43423          	sd	a0,-56(s0)
    8001fb0c:	87ae                	mv	a5,a1
    8001fb0e:	fcf42223          	sw	a5,-60(s0)
    Node *z = search(rb->root, key);
    8001fb12:	fc843783          	ld	a5,-56(s0)
    8001fb16:	639c                	ld	a5,0(a5)
    8001fb18:	fc442703          	lw	a4,-60(s0)
    8001fb1c:	85ba                	mv	a1,a4
    8001fb1e:	853e                	mv	a0,a5
    8001fb20:	f52ff0ef          	jal	ra,8001f272 <search>
    8001fb24:	fca43823          	sd	a0,-48(s0)
    if (z == NULL) {
    8001fb28:	fd043783          	ld	a5,-48(s0)
    8001fb2c:	12078b63          	beqz	a5,8001fc62 <rb_delete+0x162>
        return;
    }
    Node *x, *y = z;
    8001fb30:	fd043783          	ld	a5,-48(s0)
    8001fb34:	fef43023          	sd	a5,-32(s0)
    Color y_original_color = y->color;
    8001fb38:	fe043783          	ld	a5,-32(s0)
    8001fb3c:	439c                	lw	a5,0(a5)
    8001fb3e:	fcf42e23          	sw	a5,-36(s0)
    if (z->left == NULL) {
    8001fb42:	fd043783          	ld	a5,-48(s0)
    8001fb46:	6b9c                	ld	a5,16(a5)
    8001fb48:	e38d                	bnez	a5,8001fb6a <rb_delete+0x6a>
        x = z->right;
    8001fb4a:	fd043783          	ld	a5,-48(s0)
    8001fb4e:	6f9c                	ld	a5,24(a5)
    8001fb50:	fef43423          	sd	a5,-24(s0)
        transplant(rb, z, z->right);
    8001fb54:	fd043783          	ld	a5,-48(s0)
    8001fb58:	6f9c                	ld	a5,24(a5)
    8001fb5a:	863e                	mv	a2,a5
    8001fb5c:	fd043583          	ld	a1,-48(s0)
    8001fb60:	fc843503          	ld	a0,-56(s0)
    8001fb64:	cbfff0ef          	jal	ra,8001f822 <transplant>
    8001fb68:	a0f9                	j	8001fc36 <rb_delete+0x136>
    }
    else if (z->right == NULL) {
    8001fb6a:	fd043783          	ld	a5,-48(s0)
    8001fb6e:	6f9c                	ld	a5,24(a5)
    8001fb70:	e38d                	bnez	a5,8001fb92 <rb_delete+0x92>
        x = z->left;
    8001fb72:	fd043783          	ld	a5,-48(s0)
    8001fb76:	6b9c                	ld	a5,16(a5)
    8001fb78:	fef43423          	sd	a5,-24(s0)
        transplant(rb, z, z->left);
    8001fb7c:	fd043783          	ld	a5,-48(s0)
    8001fb80:	6b9c                	ld	a5,16(a5)
    8001fb82:	863e                	mv	a2,a5
    8001fb84:	fd043583          	ld	a1,-48(s0)
    8001fb88:	fc843503          	ld	a0,-56(s0)
    8001fb8c:	c97ff0ef          	jal	ra,8001f822 <transplant>
    8001fb90:	a05d                	j	8001fc36 <rb_delete+0x136>
    }
    else {
        y                = minimum(z->right);
    8001fb92:	fd043783          	ld	a5,-48(s0)
    8001fb96:	6f9c                	ld	a5,24(a5)
    8001fb98:	853e                	mv	a0,a5
    8001fb9a:	f38ff0ef          	jal	ra,8001f2d2 <minimum>
    8001fb9e:	fea43023          	sd	a0,-32(s0)
        y_original_color = y->color;
    8001fba2:	fe043783          	ld	a5,-32(s0)
    8001fba6:	439c                	lw	a5,0(a5)
    8001fba8:	fcf42e23          	sw	a5,-36(s0)
        x                = y->right;
    8001fbac:	fe043783          	ld	a5,-32(s0)
    8001fbb0:	6f9c                	ld	a5,24(a5)
    8001fbb2:	fef43423          	sd	a5,-24(s0)
        if (y->parent == z) {
    8001fbb6:	fe043783          	ld	a5,-32(s0)
    8001fbba:	739c                	ld	a5,32(a5)
    8001fbbc:	fd043703          	ld	a4,-48(s0)
    8001fbc0:	00f71b63          	bne	a4,a5,8001fbd6 <rb_delete+0xd6>
            if (x != NULL) {
    8001fbc4:	fe843783          	ld	a5,-24(s0)
    8001fbc8:	cf8d                	beqz	a5,8001fc02 <rb_delete+0x102>
                x->parent = y;
    8001fbca:	fe843783          	ld	a5,-24(s0)
    8001fbce:	fe043703          	ld	a4,-32(s0)
    8001fbd2:	f398                	sd	a4,32(a5)
    8001fbd4:	a03d                	j	8001fc02 <rb_delete+0x102>
            }
        }
        else {
            transplant(rb, y, y->right);
    8001fbd6:	fe043783          	ld	a5,-32(s0)
    8001fbda:	6f9c                	ld	a5,24(a5)
    8001fbdc:	863e                	mv	a2,a5
    8001fbde:	fe043583          	ld	a1,-32(s0)
    8001fbe2:	fc843503          	ld	a0,-56(s0)
    8001fbe6:	c3dff0ef          	jal	ra,8001f822 <transplant>
            y->right         = z->right;
    8001fbea:	fd043783          	ld	a5,-48(s0)
    8001fbee:	6f98                	ld	a4,24(a5)
    8001fbf0:	fe043783          	ld	a5,-32(s0)
    8001fbf4:	ef98                	sd	a4,24(a5)
            y->right->parent = y;
    8001fbf6:	fe043783          	ld	a5,-32(s0)
    8001fbfa:	6f9c                	ld	a5,24(a5)
    8001fbfc:	fe043703          	ld	a4,-32(s0)
    8001fc00:	f398                	sd	a4,32(a5)
        }
        transplant(rb, z, y);
    8001fc02:	fe043603          	ld	a2,-32(s0)
    8001fc06:	fd043583          	ld	a1,-48(s0)
    8001fc0a:	fc843503          	ld	a0,-56(s0)
    8001fc0e:	c15ff0ef          	jal	ra,8001f822 <transplant>
        y->left         = z->left;
    8001fc12:	fd043783          	ld	a5,-48(s0)
    8001fc16:	6b98                	ld	a4,16(a5)
    8001fc18:	fe043783          	ld	a5,-32(s0)
    8001fc1c:	eb98                	sd	a4,16(a5)
        y->left->parent = y;
    8001fc1e:	fe043783          	ld	a5,-32(s0)
    8001fc22:	6b9c                	ld	a5,16(a5)
    8001fc24:	fe043703          	ld	a4,-32(s0)
    8001fc28:	f398                	sd	a4,32(a5)
        y->color        = z->color;
    8001fc2a:	fd043783          	ld	a5,-48(s0)
    8001fc2e:	4398                	lw	a4,0(a5)
    8001fc30:	fe043783          	ld	a5,-32(s0)
    8001fc34:	c398                	sw	a4,0(a5)
    }
    if (y_original_color == BLACK) {
    8001fc36:	fdc42783          	lw	a5,-36(s0)
    8001fc3a:	0007871b          	sext.w	a4,a5
    8001fc3e:	4785                	li	a5,1
    8001fc40:	00f71c63          	bne	a4,a5,8001fc58 <rb_delete+0x158>
        delete_fixup(rb, x, y->parent);
    8001fc44:	fe043783          	ld	a5,-32(s0)
    8001fc48:	739c                	ld	a5,32(a5)
    8001fc4a:	863e                	mv	a2,a5
    8001fc4c:	fe843583          	ld	a1,-24(s0)
    8001fc50:	fc843503          	ld	a0,-56(s0)
    8001fc54:	c39ff0ef          	jal	ra,8001f88c <delete_fixup>
    }
    g_kfree(z);
    8001fc58:	fd043503          	ld	a0,-48(s0)
    8001fc5c:	a3afe0ef          	jal	ra,8001de96 <g_kfree>
    8001fc60:	a011                	j	8001fc64 <rb_delete+0x164>
        return;
    8001fc62:	0001                	nop
}
    8001fc64:	70e2                	ld	ra,56(sp)
    8001fc66:	7442                	ld	s0,48(sp)
    8001fc68:	6121                	addi	sp,sp,64
    8001fc6a:	8082                	ret

000000008001fc6c <rb_new>:

struct RBTree *rb_new(void)
{
    8001fc6c:	1141                	addi	sp,sp,-16
    8001fc6e:	e406                	sd	ra,8(sp)
    8001fc70:	e022                	sd	s0,0(sp)
    8001fc72:	0800                	addi	s0,sp,16
    return (RBTree *)g_kcalloc(1, sizeof(RBTree));
    8001fc74:	45a1                	li	a1,8
    8001fc76:	4505                	li	a0,1
    8001fc78:	9bcfe0ef          	jal	ra,8001de34 <g_kcalloc>
    8001fc7c:	87aa                	mv	a5,a0
}
    8001fc7e:	853e                	mv	a0,a5
    8001fc80:	60a2                	ld	ra,8(sp)
    8001fc82:	6402                	ld	s0,0(sp)
    8001fc84:	0141                	addi	sp,sp,16
    8001fc86:	8082                	ret

000000008001fc88 <rb_find>:

bool rb_find(const struct RBTree *rb, int key, uint64_t *value)
{
    8001fc88:	7139                	addi	sp,sp,-64
    8001fc8a:	fc06                	sd	ra,56(sp)
    8001fc8c:	f822                	sd	s0,48(sp)
    8001fc8e:	0080                	addi	s0,sp,64
    8001fc90:	fca43c23          	sd	a0,-40(s0)
    8001fc94:	87ae                	mv	a5,a1
    8001fc96:	fcc43423          	sd	a2,-56(s0)
    8001fc9a:	fcf42a23          	sw	a5,-44(s0)
    const Node *node = csearch(rb->root, key);
    8001fc9e:	fd843783          	ld	a5,-40(s0)
    8001fca2:	639c                	ld	a5,0(a5)
    8001fca4:	fd442703          	lw	a4,-44(s0)
    8001fca8:	85ba                	mv	a1,a4
    8001fcaa:	853e                	mv	a0,a5
    8001fcac:	d66ff0ef          	jal	ra,8001f212 <csearch>
    8001fcb0:	fea43423          	sd	a0,-24(s0)

    if (!node) {
    8001fcb4:	fe843783          	ld	a5,-24(s0)
    8001fcb8:	e399                	bnez	a5,8001fcbe <rb_find+0x36>
        return false;
    8001fcba:	4781                	li	a5,0
    8001fcbc:	a819                	j	8001fcd2 <rb_find+0x4a>
    }
    if (value) {
    8001fcbe:	fc843783          	ld	a5,-56(s0)
    8001fcc2:	c799                	beqz	a5,8001fcd0 <rb_find+0x48>
        *value = node->value;
    8001fcc4:	fe843783          	ld	a5,-24(s0)
    8001fcc8:	6798                	ld	a4,8(a5)
    8001fcca:	fc843783          	ld	a5,-56(s0)
    8001fcce:	e398                	sd	a4,0(a5)
    }
    return true;
    8001fcd0:	4785                	li	a5,1
}
    8001fcd2:	853e                	mv	a0,a5
    8001fcd4:	70e2                	ld	ra,56(sp)
    8001fcd6:	7442                	ld	s0,48(sp)
    8001fcd8:	6121                	addi	sp,sp,64
    8001fcda:	8082                	ret

000000008001fcdc <rbfree_node>:

static void rbfree_node(Node *node)
{
    8001fcdc:	1101                	addi	sp,sp,-32
    8001fcde:	ec06                	sd	ra,24(sp)
    8001fce0:	e822                	sd	s0,16(sp)
    8001fce2:	1000                	addi	s0,sp,32
    8001fce4:	fea43423          	sd	a0,-24(s0)
    if (node != NULL) {
    8001fce8:	fe843783          	ld	a5,-24(s0)
    8001fcec:	c38d                	beqz	a5,8001fd0e <rbfree_node+0x32>
        rbfree_node(node->right);
    8001fcee:	fe843783          	ld	a5,-24(s0)
    8001fcf2:	6f9c                	ld	a5,24(a5)
    8001fcf4:	853e                	mv	a0,a5
    8001fcf6:	fe7ff0ef          	jal	ra,8001fcdc <rbfree_node>
        rbfree_node(node->left);
    8001fcfa:	fe843783          	ld	a5,-24(s0)
    8001fcfe:	6b9c                	ld	a5,16(a5)
    8001fd00:	853e                	mv	a0,a5
    8001fd02:	fdbff0ef          	jal	ra,8001fcdc <rbfree_node>
        g_kfree(node);
    8001fd06:	fe843503          	ld	a0,-24(s0)
    8001fd0a:	98cfe0ef          	jal	ra,8001de96 <g_kfree>
    }
}
    8001fd0e:	0001                	nop
    8001fd10:	60e2                	ld	ra,24(sp)
    8001fd12:	6442                	ld	s0,16(sp)
    8001fd14:	6105                	addi	sp,sp,32
    8001fd16:	8082                	ret

000000008001fd18 <rb_clear>:

void rb_clear(struct RBTree *rb)
{
    8001fd18:	1101                	addi	sp,sp,-32
    8001fd1a:	ec06                	sd	ra,24(sp)
    8001fd1c:	e822                	sd	s0,16(sp)
    8001fd1e:	1000                	addi	s0,sp,32
    8001fd20:	fea43423          	sd	a0,-24(s0)
    rbfree_node(rb->root);
    8001fd24:	fe843783          	ld	a5,-24(s0)
    8001fd28:	639c                	ld	a5,0(a5)
    8001fd2a:	853e                	mv	a0,a5
    8001fd2c:	fb1ff0ef          	jal	ra,8001fcdc <rbfree_node>
    rb->root = NULL;
    8001fd30:	fe843783          	ld	a5,-24(s0)
    8001fd34:	0007b023          	sd	zero,0(a5)
}
    8001fd38:	0001                	nop
    8001fd3a:	60e2                	ld	ra,24(sp)
    8001fd3c:	6442                	ld	s0,16(sp)
    8001fd3e:	6105                	addi	sp,sp,32
    8001fd40:	8082                	ret

000000008001fd42 <rb_free>:

void rb_free(struct RBTree *rb)
{
    8001fd42:	1101                	addi	sp,sp,-32
    8001fd44:	ec06                	sd	ra,24(sp)
    8001fd46:	e822                	sd	s0,16(sp)
    8001fd48:	1000                	addi	s0,sp,32
    8001fd4a:	fea43423          	sd	a0,-24(s0)
    rbfree_node(rb->root);
    8001fd4e:	fe843783          	ld	a5,-24(s0)
    8001fd52:	639c                	ld	a5,0(a5)
    8001fd54:	853e                	mv	a0,a5
    8001fd56:	f87ff0ef          	jal	ra,8001fcdc <rbfree_node>
    g_kfree(rb);
    8001fd5a:	fe843503          	ld	a0,-24(s0)
    8001fd5e:	938fe0ef          	jal	ra,8001de96 <g_kfree>
}
    8001fd62:	0001                	nop
    8001fd64:	60e2                	ld	ra,24(sp)
    8001fd66:	6442                	ld	s0,16(sp)
    8001fd68:	6105                	addi	sp,sp,32
    8001fd6a:	8082                	ret

000000008001fd6c <memset>:
#include <alloc.h>
#include <stdint.h>
#include <util.h>

void *memset(void *dst, char data, int size)
{
    8001fd6c:	715d                	addi	sp,sp,-80
    8001fd6e:	e4a2                	sd	s0,72(sp)
    8001fd70:	0880                	addi	s0,sp,80
    8001fd72:	faa43c23          	sd	a0,-72(s0)
    8001fd76:	87ae                	mv	a5,a1
    8001fd78:	8732                	mv	a4,a2
    8001fd7a:	faf40ba3          	sb	a5,-73(s0)
    8001fd7e:	87ba                	mv	a5,a4
    8001fd80:	faf42823          	sw	a5,-80(s0)
    int64_t i;
    long *ldst = (long *)dst;
    8001fd84:	fb843783          	ld	a5,-72(s0)
    8001fd88:	fef43023          	sd	a5,-32(s0)
    char *cdst;
    char l[]              = {data, data, data, data, data, data, data, data};
    8001fd8c:	fb744783          	lbu	a5,-73(s0)
    8001fd90:	fcf40423          	sb	a5,-56(s0)
    8001fd94:	fb744783          	lbu	a5,-73(s0)
    8001fd98:	fcf404a3          	sb	a5,-55(s0)
    8001fd9c:	fb744783          	lbu	a5,-73(s0)
    8001fda0:	fcf40523          	sb	a5,-54(s0)
    8001fda4:	fb744783          	lbu	a5,-73(s0)
    8001fda8:	fcf405a3          	sb	a5,-53(s0)
    8001fdac:	fb744783          	lbu	a5,-73(s0)
    8001fdb0:	fcf40623          	sb	a5,-52(s0)
    8001fdb4:	fb744783          	lbu	a5,-73(s0)
    8001fdb8:	fcf406a3          	sb	a5,-51(s0)
    8001fdbc:	fb744783          	lbu	a5,-73(s0)
    8001fdc0:	fcf40723          	sb	a5,-50(s0)
    8001fdc4:	fb744783          	lbu	a5,-73(s0)
    8001fdc8:	fcf407a3          	sb	a5,-49(s0)

    int num_8_byte_copies = size / 8;
    8001fdcc:	fb042783          	lw	a5,-80(s0)
    8001fdd0:	41f7d71b          	sraiw	a4,a5,0x1f
    8001fdd4:	01d7571b          	srliw	a4,a4,0x1d
    8001fdd8:	9fb9                	addw	a5,a5,a4
    8001fdda:	4037d79b          	sraiw	a5,a5,0x3
    8001fdde:	fcf42a23          	sw	a5,-44(s0)
    int num_1_byte_copies = size % 8;
    8001fde2:	fb042703          	lw	a4,-80(s0)
    8001fde6:	41f7579b          	sraiw	a5,a4,0x1f
    8001fdea:	01d7d79b          	srliw	a5,a5,0x1d
    8001fdee:	9f3d                	addw	a4,a4,a5
    8001fdf0:	8b1d                	andi	a4,a4,7
    8001fdf2:	40f707bb          	subw	a5,a4,a5
    8001fdf6:	fcf42823          	sw	a5,-48(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    8001fdfa:	fe043423          	sd	zero,-24(s0)
    8001fdfe:	a005                	j	8001fe1e <memset+0xb2>
        *ldst++ = *((long *)l);
    8001fe00:	fc840713          	addi	a4,s0,-56
    8001fe04:	fe043783          	ld	a5,-32(s0)
    8001fe08:	00878693          	addi	a3,a5,8
    8001fe0c:	fed43023          	sd	a3,-32(s0)
    8001fe10:	6318                	ld	a4,0(a4)
    8001fe12:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    8001fe14:	fe843783          	ld	a5,-24(s0)
    8001fe18:	0785                	addi	a5,a5,1
    8001fe1a:	fef43423          	sd	a5,-24(s0)
    8001fe1e:	fd442783          	lw	a5,-44(s0)
    8001fe22:	fe843703          	ld	a4,-24(s0)
    8001fe26:	fcf74de3          	blt	a4,a5,8001fe00 <memset+0x94>
    }

    cdst = (char *)ldst;
    8001fe2a:	fe043783          	ld	a5,-32(s0)
    8001fe2e:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    8001fe32:	fe043423          	sd	zero,-24(s0)
    8001fe36:	a005                	j	8001fe56 <memset+0xea>
        *cdst++ = data;
    8001fe38:	fd843783          	ld	a5,-40(s0)
    8001fe3c:	00178713          	addi	a4,a5,1
    8001fe40:	fce43c23          	sd	a4,-40(s0)
    8001fe44:	fb744703          	lbu	a4,-73(s0)
    8001fe48:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    8001fe4c:	fe843783          	ld	a5,-24(s0)
    8001fe50:	0785                	addi	a5,a5,1
    8001fe52:	fef43423          	sd	a5,-24(s0)
    8001fe56:	fd042783          	lw	a5,-48(s0)
    8001fe5a:	fe843703          	ld	a4,-24(s0)
    8001fe5e:	fcf74de3          	blt	a4,a5,8001fe38 <memset+0xcc>
    }

    return dst;
    8001fe62:	fb843783          	ld	a5,-72(s0)
}
    8001fe66:	853e                	mv	a0,a5
    8001fe68:	6426                	ld	s0,72(sp)
    8001fe6a:	6161                	addi	sp,sp,80
    8001fe6c:	8082                	ret

000000008001fe6e <memcpy>:

void *memcpy(void *dst, const void *src, int size)
{
    8001fe6e:	711d                	addi	sp,sp,-96
    8001fe70:	eca2                	sd	s0,88(sp)
    8001fe72:	1080                	addi	s0,sp,96
    8001fe74:	faa43c23          	sd	a0,-72(s0)
    8001fe78:	fab43823          	sd	a1,-80(s0)
    8001fe7c:	87b2                	mv	a5,a2
    8001fe7e:	faf42623          	sw	a5,-84(s0)
    int i;
    char *cdst;
    const char *csrc;
    long *ldst            = (long *)dst;
    8001fe82:	fb843783          	ld	a5,-72(s0)
    8001fe86:	fcf43823          	sd	a5,-48(s0)
    const long *lsrc      = (long *)src;
    8001fe8a:	fb043783          	ld	a5,-80(s0)
    8001fe8e:	fcf43423          	sd	a5,-56(s0)

    int num_8_byte_copies = size / 8;
    8001fe92:	fac42783          	lw	a5,-84(s0)
    8001fe96:	41f7d71b          	sraiw	a4,a5,0x1f
    8001fe9a:	01d7571b          	srliw	a4,a4,0x1d
    8001fe9e:	9fb9                	addw	a5,a5,a4
    8001fea0:	4037d79b          	sraiw	a5,a5,0x3
    8001fea4:	fcf42223          	sw	a5,-60(s0)
    int num_1_byte_copies = size % 8;
    8001fea8:	fac42703          	lw	a4,-84(s0)
    8001feac:	41f7579b          	sraiw	a5,a4,0x1f
    8001feb0:	01d7d79b          	srliw	a5,a5,0x1d
    8001feb4:	9f3d                	addw	a4,a4,a5
    8001feb6:	8b1d                	andi	a4,a4,7
    8001feb8:	40f707bb          	subw	a5,a4,a5
    8001febc:	fcf42023          	sw	a5,-64(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    8001fec0:	fe042623          	sw	zero,-20(s0)
    8001fec4:	a025                	j	8001feec <memcpy+0x7e>
        *ldst++ = *lsrc++;
    8001fec6:	fc843703          	ld	a4,-56(s0)
    8001feca:	00870793          	addi	a5,a4,8
    8001fece:	fcf43423          	sd	a5,-56(s0)
    8001fed2:	fd043783          	ld	a5,-48(s0)
    8001fed6:	00878693          	addi	a3,a5,8
    8001feda:	fcd43823          	sd	a3,-48(s0)
    8001fede:	6318                	ld	a4,0(a4)
    8001fee0:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    8001fee2:	fec42783          	lw	a5,-20(s0)
    8001fee6:	2785                	addiw	a5,a5,1
    8001fee8:	fef42623          	sw	a5,-20(s0)
    8001feec:	fec42703          	lw	a4,-20(s0)
    8001fef0:	fc442783          	lw	a5,-60(s0)
    8001fef4:	2701                	sext.w	a4,a4
    8001fef6:	2781                	sext.w	a5,a5
    8001fef8:	fcf747e3          	blt	a4,a5,8001fec6 <memcpy+0x58>
    }

    cdst = (char *)ldst;
    8001fefc:	fd043783          	ld	a5,-48(s0)
    8001ff00:	fef43023          	sd	a5,-32(s0)
    csrc = (char *)lsrc;
    8001ff04:	fc843783          	ld	a5,-56(s0)
    8001ff08:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    8001ff0c:	fe042623          	sw	zero,-20(s0)
    8001ff10:	a035                	j	8001ff3c <memcpy+0xce>
        *cdst++ = *csrc++;
    8001ff12:	fd843703          	ld	a4,-40(s0)
    8001ff16:	00170793          	addi	a5,a4,1
    8001ff1a:	fcf43c23          	sd	a5,-40(s0)
    8001ff1e:	fe043783          	ld	a5,-32(s0)
    8001ff22:	00178693          	addi	a3,a5,1
    8001ff26:	fed43023          	sd	a3,-32(s0)
    8001ff2a:	00074703          	lbu	a4,0(a4)
    8001ff2e:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    8001ff32:	fec42783          	lw	a5,-20(s0)
    8001ff36:	2785                	addiw	a5,a5,1
    8001ff38:	fef42623          	sw	a5,-20(s0)
    8001ff3c:	fec42703          	lw	a4,-20(s0)
    8001ff40:	fc042783          	lw	a5,-64(s0)
    8001ff44:	2701                	sext.w	a4,a4
    8001ff46:	2781                	sext.w	a5,a5
    8001ff48:	fcf745e3          	blt	a4,a5,8001ff12 <memcpy+0xa4>
    }

    return dst;
    8001ff4c:	fb843783          	ld	a5,-72(s0)
}
    8001ff50:	853e                	mv	a0,a5
    8001ff52:	6466                	ld	s0,88(sp)
    8001ff54:	6125                	addi	sp,sp,96
    8001ff56:	8082                	ret

000000008001ff58 <memmove>:

void *memmove(void *_dst, const void *_src, int n)
{
    8001ff58:	7139                	addi	sp,sp,-64
    8001ff5a:	fc22                	sd	s0,56(sp)
    8001ff5c:	0080                	addi	s0,sp,64
    8001ff5e:	fca43c23          	sd	a0,-40(s0)
    8001ff62:	fcb43823          	sd	a1,-48(s0)
    8001ff66:	87b2                	mv	a5,a2
    8001ff68:	fcf42623          	sw	a5,-52(s0)
    const char *src = _src;
    8001ff6c:	fd043783          	ld	a5,-48(s0)
    8001ff70:	fef43423          	sd	a5,-24(s0)
    char *dst       = _dst;
    8001ff74:	fd843783          	ld	a5,-40(s0)
    8001ff78:	fef43023          	sd	a5,-32(s0)

    if (n == 0)
    8001ff7c:	fcc42783          	lw	a5,-52(s0)
    8001ff80:	2781                	sext.w	a5,a5
    8001ff82:	e781                	bnez	a5,8001ff8a <memmove+0x32>
        return _dst;
    8001ff84:	fd843783          	ld	a5,-40(s0)
    8001ff88:	a845                	j	80020038 <memmove+0xe0>

    if (src < dst && src + n > dst) {
    8001ff8a:	fe843703          	ld	a4,-24(s0)
    8001ff8e:	fe043783          	ld	a5,-32(s0)
    8001ff92:	08f77c63          	bgeu	a4,a5,8002002a <memmove+0xd2>
    8001ff96:	fcc42783          	lw	a5,-52(s0)
    8001ff9a:	fe843703          	ld	a4,-24(s0)
    8001ff9e:	97ba                	add	a5,a5,a4
    8001ffa0:	fe043703          	ld	a4,-32(s0)
    8001ffa4:	08f77363          	bgeu	a4,a5,8002002a <memmove+0xd2>
        src += n;
    8001ffa8:	fcc42783          	lw	a5,-52(s0)
    8001ffac:	fe843703          	ld	a4,-24(s0)
    8001ffb0:	97ba                	add	a5,a5,a4
    8001ffb2:	fef43423          	sd	a5,-24(s0)
        dst += n;
    8001ffb6:	fcc42783          	lw	a5,-52(s0)
    8001ffba:	fe043703          	ld	a4,-32(s0)
    8001ffbe:	97ba                	add	a5,a5,a4
    8001ffc0:	fef43023          	sd	a5,-32(s0)
        for (; n > 0; n -= 1) {
    8001ffc4:	a805                	j	8001fff4 <memmove+0x9c>
            *--dst = *--src;
    8001ffc6:	fe843783          	ld	a5,-24(s0)
    8001ffca:	17fd                	addi	a5,a5,-1
    8001ffcc:	fef43423          	sd	a5,-24(s0)
    8001ffd0:	fe043783          	ld	a5,-32(s0)
    8001ffd4:	17fd                	addi	a5,a5,-1
    8001ffd6:	fef43023          	sd	a5,-32(s0)
    8001ffda:	fe843783          	ld	a5,-24(s0)
    8001ffde:	0007c703          	lbu	a4,0(a5)
    8001ffe2:	fe043783          	ld	a5,-32(s0)
    8001ffe6:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    8001ffea:	fcc42783          	lw	a5,-52(s0)
    8001ffee:	37fd                	addiw	a5,a5,-1
    8001fff0:	fcf42623          	sw	a5,-52(s0)
    8001fff4:	fcc42783          	lw	a5,-52(s0)
    8001fff8:	2781                	sext.w	a5,a5
    8001fffa:	fcf046e3          	bgtz	a5,8001ffc6 <memmove+0x6e>
    if (src < dst && src + n > dst) {
    8001fffe:	a81d                	j	80020034 <memmove+0xdc>
        }
    }
    else {
        for (; n > 0; n -= 1) {
            *dst++ = *src++;
    80020000:	fe843703          	ld	a4,-24(s0)
    80020004:	00170793          	addi	a5,a4,1
    80020008:	fef43423          	sd	a5,-24(s0)
    8002000c:	fe043783          	ld	a5,-32(s0)
    80020010:	00178693          	addi	a3,a5,1
    80020014:	fed43023          	sd	a3,-32(s0)
    80020018:	00074703          	lbu	a4,0(a4)
    8002001c:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    80020020:	fcc42783          	lw	a5,-52(s0)
    80020024:	37fd                	addiw	a5,a5,-1
    80020026:	fcf42623          	sw	a5,-52(s0)
    8002002a:	fcc42783          	lw	a5,-52(s0)
    8002002e:	2781                	sext.w	a5,a5
    80020030:	fcf048e3          	bgtz	a5,80020000 <memmove+0xa8>
        }
    }

    return _dst;
    80020034:	fd843783          	ld	a5,-40(s0)
}
    80020038:	853e                	mv	a0,a5
    8002003a:	7462                	ld	s0,56(sp)
    8002003c:	6121                	addi	sp,sp,64
    8002003e:	8082                	ret

0000000080020040 <memcmp>:

int memcmp(const void *haystack, const void *needle, int size)
{
    80020040:	715d                	addi	sp,sp,-80
    80020042:	e4a2                	sd	s0,72(sp)
    80020044:	0880                	addi	s0,sp,80
    80020046:	fca43423          	sd	a0,-56(s0)
    8002004a:	fcb43023          	sd	a1,-64(s0)
    8002004e:	87b2                	mv	a5,a2
    80020050:	faf42e23          	sw	a5,-68(s0)
    const char *hay  = (char *)haystack;
    80020054:	fc843783          	ld	a5,-56(s0)
    80020058:	fef43023          	sd	a5,-32(s0)
    const char *need = (char *)needle;
    8002005c:	fc043783          	ld	a5,-64(s0)
    80020060:	fcf43c23          	sd	a5,-40(s0)
    int i;

    for (i = 0; i < (size - 1); i++) {
    80020064:	fe042623          	sw	zero,-20(s0)
    80020068:	a8a1                	j	800200c0 <memcmp+0x80>
        if (hay[i] != need[i]) {
    8002006a:	fec42783          	lw	a5,-20(s0)
    8002006e:	fe043703          	ld	a4,-32(s0)
    80020072:	97ba                	add	a5,a5,a4
    80020074:	0007c683          	lbu	a3,0(a5)
    80020078:	fec42783          	lw	a5,-20(s0)
    8002007c:	fd843703          	ld	a4,-40(s0)
    80020080:	97ba                	add	a5,a5,a4
    80020082:	0007c783          	lbu	a5,0(a5)
    80020086:	8736                	mv	a4,a3
    80020088:	02f70763          	beq	a4,a5,800200b6 <memcmp+0x76>
            return hay[i] - need[i];
    8002008c:	fec42783          	lw	a5,-20(s0)
    80020090:	fe043703          	ld	a4,-32(s0)
    80020094:	97ba                	add	a5,a5,a4
    80020096:	0007c783          	lbu	a5,0(a5)
    8002009a:	0007871b          	sext.w	a4,a5
    8002009e:	fec42783          	lw	a5,-20(s0)
    800200a2:	fd843683          	ld	a3,-40(s0)
    800200a6:	97b6                	add	a5,a5,a3
    800200a8:	0007c783          	lbu	a5,0(a5)
    800200ac:	2781                	sext.w	a5,a5
    800200ae:	40f707bb          	subw	a5,a4,a5
    800200b2:	2781                	sext.w	a5,a5
    800200b4:	a0a1                	j	800200fc <memcmp+0xbc>
    for (i = 0; i < (size - 1); i++) {
    800200b6:	fec42783          	lw	a5,-20(s0)
    800200ba:	2785                	addiw	a5,a5,1
    800200bc:	fef42623          	sw	a5,-20(s0)
    800200c0:	fbc42783          	lw	a5,-68(s0)
    800200c4:	37fd                	addiw	a5,a5,-1
    800200c6:	0007871b          	sext.w	a4,a5
    800200ca:	fec42783          	lw	a5,-20(s0)
    800200ce:	2781                	sext.w	a5,a5
    800200d0:	f8e7cde3          	blt	a5,a4,8002006a <memcmp+0x2a>
        }
    }

    return hay[i] - need[i];
    800200d4:	fec42783          	lw	a5,-20(s0)
    800200d8:	fe043703          	ld	a4,-32(s0)
    800200dc:	97ba                	add	a5,a5,a4
    800200de:	0007c783          	lbu	a5,0(a5)
    800200e2:	0007871b          	sext.w	a4,a5
    800200e6:	fec42783          	lw	a5,-20(s0)
    800200ea:	fd843683          	ld	a3,-40(s0)
    800200ee:	97b6                	add	a5,a5,a3
    800200f0:	0007c783          	lbu	a5,0(a5)
    800200f4:	2781                	sext.w	a5,a5
    800200f6:	40f707bb          	subw	a5,a4,a5
    800200fa:	2781                	sext.w	a5,a5
}
    800200fc:	853e                	mv	a0,a5
    800200fe:	6426                	ld	s0,72(sp)
    80020100:	6161                	addi	sp,sp,80
    80020102:	8082                	ret

0000000080020104 <atoi>:

int atoi(const char *st)
{
    80020104:	7139                	addi	sp,sp,-64
    80020106:	fc22                	sd	s0,56(sp)
    80020108:	0080                	addi	s0,sp,64
    8002010a:	fca43423          	sd	a0,-56(s0)
    int r = 0;
    8002010e:	fe042623          	sw	zero,-20(s0)
    int p = 1;
    80020112:	4785                	li	a5,1
    80020114:	fef42423          	sw	a5,-24(s0)
    int i;
    int l = 0;
    80020118:	fe042023          	sw	zero,-32(s0)
    int n = 0;
    8002011c:	fc042e23          	sw	zero,-36(s0)

    if (st[0] == '-') {
    80020120:	fc843783          	ld	a5,-56(s0)
    80020124:	0007c783          	lbu	a5,0(a5)
    80020128:	873e                	mv	a4,a5
    8002012a:	02d00793          	li	a5,45
    8002012e:	02f71063          	bne	a4,a5,8002014e <atoi+0x4a>
        st++;
    80020132:	fc843783          	ld	a5,-56(s0)
    80020136:	0785                	addi	a5,a5,1
    80020138:	fcf43423          	sd	a5,-56(s0)
        n = 1;
    8002013c:	4785                	li	a5,1
    8002013e:	fcf42e23          	sw	a5,-36(s0)
    }

    while (st[l] >= '0' && st[l] <= '9')
    80020142:	a031                	j	8002014e <atoi+0x4a>
        l++;
    80020144:	fe042783          	lw	a5,-32(s0)
    80020148:	2785                	addiw	a5,a5,1
    8002014a:	fef42023          	sw	a5,-32(s0)
    while (st[l] >= '0' && st[l] <= '9')
    8002014e:	fe042783          	lw	a5,-32(s0)
    80020152:	fc843703          	ld	a4,-56(s0)
    80020156:	97ba                	add	a5,a5,a4
    80020158:	0007c783          	lbu	a5,0(a5)
    8002015c:	873e                	mv	a4,a5
    8002015e:	02f00793          	li	a5,47
    80020162:	00e7fe63          	bgeu	a5,a4,8002017e <atoi+0x7a>
    80020166:	fe042783          	lw	a5,-32(s0)
    8002016a:	fc843703          	ld	a4,-56(s0)
    8002016e:	97ba                	add	a5,a5,a4
    80020170:	0007c783          	lbu	a5,0(a5)
    80020174:	873e                	mv	a4,a5
    80020176:	03900793          	li	a5,57
    8002017a:	fce7f5e3          	bgeu	a5,a4,80020144 <atoi+0x40>

    for (i = l - 1; i >= 0; i--) {
    8002017e:	fe042783          	lw	a5,-32(s0)
    80020182:	37fd                	addiw	a5,a5,-1
    80020184:	fef42223          	sw	a5,-28(s0)
    80020188:	a0a9                	j	800201d2 <atoi+0xce>
        r += p * (st[i] - '0');
    8002018a:	fe442783          	lw	a5,-28(s0)
    8002018e:	fc843703          	ld	a4,-56(s0)
    80020192:	97ba                	add	a5,a5,a4
    80020194:	0007c783          	lbu	a5,0(a5)
    80020198:	2781                	sext.w	a5,a5
    8002019a:	fd07879b          	addiw	a5,a5,-48
    8002019e:	2781                	sext.w	a5,a5
    800201a0:	fe842703          	lw	a4,-24(s0)
    800201a4:	02f707bb          	mulw	a5,a4,a5
    800201a8:	2781                	sext.w	a5,a5
    800201aa:	fec42703          	lw	a4,-20(s0)
    800201ae:	9fb9                	addw	a5,a5,a4
    800201b0:	fef42623          	sw	a5,-20(s0)
        p *= 10;
    800201b4:	fe842703          	lw	a4,-24(s0)
    800201b8:	87ba                	mv	a5,a4
    800201ba:	0027979b          	slliw	a5,a5,0x2
    800201be:	9fb9                	addw	a5,a5,a4
    800201c0:	0017979b          	slliw	a5,a5,0x1
    800201c4:	fef42423          	sw	a5,-24(s0)
    for (i = l - 1; i >= 0; i--) {
    800201c8:	fe442783          	lw	a5,-28(s0)
    800201cc:	37fd                	addiw	a5,a5,-1
    800201ce:	fef42223          	sw	a5,-28(s0)
    800201d2:	fe442783          	lw	a5,-28(s0)
    800201d6:	2781                	sext.w	a5,a5
    800201d8:	fa07d9e3          	bgez	a5,8002018a <atoi+0x86>
    }

    return (n ? -r : r);
    800201dc:	fdc42783          	lw	a5,-36(s0)
    800201e0:	2781                	sext.w	a5,a5
    800201e2:	c799                	beqz	a5,800201f0 <atoi+0xec>
    800201e4:	fec42783          	lw	a5,-20(s0)
    800201e8:	40f007bb          	negw	a5,a5
    800201ec:	2781                	sext.w	a5,a5
    800201ee:	a019                	j	800201f4 <atoi+0xf0>
    800201f0:	fec42783          	lw	a5,-20(s0)
}
    800201f4:	853e                	mv	a0,a5
    800201f6:	7462                	ld	s0,56(sp)
    800201f8:	6121                	addi	sp,sp,64
    800201fa:	8082                	ret

00000000800201fc <strcmp>:

int strcmp(const char *l, const char *r)
{
    800201fc:	7139                	addi	sp,sp,-64
    800201fe:	fc22                	sd	s0,56(sp)
    80020200:	0080                	addi	s0,sp,64
    80020202:	fca43423          	sd	a0,-56(s0)
    80020206:	fcb43023          	sd	a1,-64(s0)
    const unsigned char *s1 = (const unsigned char *)l;
    8002020a:	fc843783          	ld	a5,-56(s0)
    8002020e:	fef43423          	sd	a5,-24(s0)
    const unsigned char *s2 = (const unsigned char *)r;
    80020212:	fc043783          	ld	a5,-64(s0)
    80020216:	fef43023          	sd	a5,-32(s0)
    unsigned int c1, c2;

    do {
        c1 = (unsigned char)*s1++;
    8002021a:	fe843783          	ld	a5,-24(s0)
    8002021e:	00178713          	addi	a4,a5,1
    80020222:	fee43423          	sd	a4,-24(s0)
    80020226:	0007c783          	lbu	a5,0(a5)
    8002022a:	fcf42e23          	sw	a5,-36(s0)
        c2 = (unsigned char)*s2++;
    8002022e:	fe043783          	ld	a5,-32(s0)
    80020232:	00178713          	addi	a4,a5,1
    80020236:	fee43023          	sd	a4,-32(s0)
    8002023a:	0007c783          	lbu	a5,0(a5)
    8002023e:	fcf42c23          	sw	a5,-40(s0)
        if (c1 == '\0')
    80020242:	fdc42783          	lw	a5,-36(s0)
    80020246:	2781                	sext.w	a5,a5
    80020248:	eb91                	bnez	a5,8002025c <strcmp+0x60>
            return c1 - c2;
    8002024a:	fdc42703          	lw	a4,-36(s0)
    8002024e:	fd842783          	lw	a5,-40(s0)
    80020252:	40f707bb          	subw	a5,a4,a5
    80020256:	2781                	sext.w	a5,a5
    80020258:	2781                	sext.w	a5,a5
    8002025a:	a00d                	j	8002027c <strcmp+0x80>
    } while (c1 == c2);
    8002025c:	fdc42703          	lw	a4,-36(s0)
    80020260:	fd842783          	lw	a5,-40(s0)
    80020264:	2701                	sext.w	a4,a4
    80020266:	2781                	sext.w	a5,a5
    80020268:	faf709e3          	beq	a4,a5,8002021a <strcmp+0x1e>

    return c1 - c2;
    8002026c:	fdc42703          	lw	a4,-36(s0)
    80020270:	fd842783          	lw	a5,-40(s0)
    80020274:	40f707bb          	subw	a5,a4,a5
    80020278:	2781                	sext.w	a5,a5
    8002027a:	2781                	sext.w	a5,a5
}
    8002027c:	853e                	mv	a0,a5
    8002027e:	7462                	ld	s0,56(sp)
    80020280:	6121                	addi	sp,sp,64
    80020282:	8082                	ret

0000000080020284 <strncmp>:

int strncmp(const char *left, const char *right, int n)
{
    80020284:	7139                	addi	sp,sp,-64
    80020286:	fc22                	sd	s0,56(sp)
    80020288:	0080                	addi	s0,sp,64
    8002028a:	fca43c23          	sd	a0,-40(s0)
    8002028e:	fcb43823          	sd	a1,-48(s0)
    80020292:	87b2                	mv	a5,a2
    80020294:	fcf42623          	sw	a5,-52(s0)
    unsigned int c1 = '\0';
    80020298:	fe042623          	sw	zero,-20(s0)
    unsigned int c2 = '\0';
    8002029c:	fe042423          	sw	zero,-24(s0)

    if (n >= 4) {
    800202a0:	fcc42783          	lw	a5,-52(s0)
    800202a4:	0007871b          	sext.w	a4,a5
    800202a8:	478d                	li	a5,3
    800202aa:	1ce7da63          	bge	a5,a4,8002047e <strncmp+0x1fa>
        int n4 = n >> 2;
    800202ae:	fcc42783          	lw	a5,-52(s0)
    800202b2:	4027d79b          	sraiw	a5,a5,0x2
    800202b6:	fef42223          	sw	a5,-28(s0)
        do {
            c1 = (unsigned char)*left++;
    800202ba:	fd843783          	ld	a5,-40(s0)
    800202be:	00178713          	addi	a4,a5,1
    800202c2:	fce43c23          	sd	a4,-40(s0)
    800202c6:	0007c783          	lbu	a5,0(a5)
    800202ca:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    800202ce:	fd043783          	ld	a5,-48(s0)
    800202d2:	00178713          	addi	a4,a5,1
    800202d6:	fce43823          	sd	a4,-48(s0)
    800202da:	0007c783          	lbu	a5,0(a5)
    800202de:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    800202e2:	fec42783          	lw	a5,-20(s0)
    800202e6:	2781                	sext.w	a5,a5
    800202e8:	cb89                	beqz	a5,800202fa <strncmp+0x76>
    800202ea:	fec42703          	lw	a4,-20(s0)
    800202ee:	fe842783          	lw	a5,-24(s0)
    800202f2:	2701                	sext.w	a4,a4
    800202f4:	2781                	sext.w	a5,a5
    800202f6:	00f70b63          	beq	a4,a5,8002030c <strncmp+0x88>
                return c1 - c2;
    800202fa:	fec42703          	lw	a4,-20(s0)
    800202fe:	fe842783          	lw	a5,-24(s0)
    80020302:	40f707bb          	subw	a5,a4,a5
    80020306:	2781                	sext.w	a5,a5
    80020308:	2781                	sext.w	a5,a5
    8002030a:	a279                	j	80020498 <strncmp+0x214>
            }

            c1 = (unsigned char)*left++;
    8002030c:	fd843783          	ld	a5,-40(s0)
    80020310:	00178713          	addi	a4,a5,1
    80020314:	fce43c23          	sd	a4,-40(s0)
    80020318:	0007c783          	lbu	a5,0(a5)
    8002031c:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80020320:	fd043783          	ld	a5,-48(s0)
    80020324:	00178713          	addi	a4,a5,1
    80020328:	fce43823          	sd	a4,-48(s0)
    8002032c:	0007c783          	lbu	a5,0(a5)
    80020330:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80020334:	fec42783          	lw	a5,-20(s0)
    80020338:	2781                	sext.w	a5,a5
    8002033a:	cb89                	beqz	a5,8002034c <strncmp+0xc8>
    8002033c:	fec42703          	lw	a4,-20(s0)
    80020340:	fe842783          	lw	a5,-24(s0)
    80020344:	2701                	sext.w	a4,a4
    80020346:	2781                	sext.w	a5,a5
    80020348:	00f70b63          	beq	a4,a5,8002035e <strncmp+0xda>
                return c1 - c2;
    8002034c:	fec42703          	lw	a4,-20(s0)
    80020350:	fe842783          	lw	a5,-24(s0)
    80020354:	40f707bb          	subw	a5,a4,a5
    80020358:	2781                	sext.w	a5,a5
    8002035a:	2781                	sext.w	a5,a5
    8002035c:	aa35                	j	80020498 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    8002035e:	fd843783          	ld	a5,-40(s0)
    80020362:	00178713          	addi	a4,a5,1
    80020366:	fce43c23          	sd	a4,-40(s0)
    8002036a:	0007c783          	lbu	a5,0(a5)
    8002036e:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80020372:	fd043783          	ld	a5,-48(s0)
    80020376:	00178713          	addi	a4,a5,1
    8002037a:	fce43823          	sd	a4,-48(s0)
    8002037e:	0007c783          	lbu	a5,0(a5)
    80020382:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80020386:	fec42783          	lw	a5,-20(s0)
    8002038a:	2781                	sext.w	a5,a5
    8002038c:	cb89                	beqz	a5,8002039e <strncmp+0x11a>
    8002038e:	fec42703          	lw	a4,-20(s0)
    80020392:	fe842783          	lw	a5,-24(s0)
    80020396:	2701                	sext.w	a4,a4
    80020398:	2781                	sext.w	a5,a5
    8002039a:	00f70b63          	beq	a4,a5,800203b0 <strncmp+0x12c>
                return c1 - c2;
    8002039e:	fec42703          	lw	a4,-20(s0)
    800203a2:	fe842783          	lw	a5,-24(s0)
    800203a6:	40f707bb          	subw	a5,a4,a5
    800203aa:	2781                	sext.w	a5,a5
    800203ac:	2781                	sext.w	a5,a5
    800203ae:	a0ed                	j	80020498 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    800203b0:	fd843783          	ld	a5,-40(s0)
    800203b4:	00178713          	addi	a4,a5,1
    800203b8:	fce43c23          	sd	a4,-40(s0)
    800203bc:	0007c783          	lbu	a5,0(a5)
    800203c0:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    800203c4:	fd043783          	ld	a5,-48(s0)
    800203c8:	00178713          	addi	a4,a5,1
    800203cc:	fce43823          	sd	a4,-48(s0)
    800203d0:	0007c783          	lbu	a5,0(a5)
    800203d4:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    800203d8:	fec42783          	lw	a5,-20(s0)
    800203dc:	2781                	sext.w	a5,a5
    800203de:	cb89                	beqz	a5,800203f0 <strncmp+0x16c>
    800203e0:	fec42703          	lw	a4,-20(s0)
    800203e4:	fe842783          	lw	a5,-24(s0)
    800203e8:	2701                	sext.w	a4,a4
    800203ea:	2781                	sext.w	a5,a5
    800203ec:	00f70b63          	beq	a4,a5,80020402 <strncmp+0x17e>
                return c1 - c2;
    800203f0:	fec42703          	lw	a4,-20(s0)
    800203f4:	fe842783          	lw	a5,-24(s0)
    800203f8:	40f707bb          	subw	a5,a4,a5
    800203fc:	2781                	sext.w	a5,a5
    800203fe:	2781                	sext.w	a5,a5
    80020400:	a861                	j	80020498 <strncmp+0x214>
            }
        } while (--n4 > 0);
    80020402:	fe442783          	lw	a5,-28(s0)
    80020406:	37fd                	addiw	a5,a5,-1
    80020408:	fef42223          	sw	a5,-28(s0)
    8002040c:	fe442783          	lw	a5,-28(s0)
    80020410:	2781                	sext.w	a5,a5
    80020412:	eaf044e3          	bgtz	a5,800202ba <strncmp+0x36>
        n &= 3;
    80020416:	fcc42783          	lw	a5,-52(s0)
    8002041a:	8b8d                	andi	a5,a5,3
    8002041c:	fcf42623          	sw	a5,-52(s0)
    }

    while (n > 0) {
    80020420:	a8b9                	j	8002047e <strncmp+0x1fa>
        c1 = (unsigned char)*left++;
    80020422:	fd843783          	ld	a5,-40(s0)
    80020426:	00178713          	addi	a4,a5,1
    8002042a:	fce43c23          	sd	a4,-40(s0)
    8002042e:	0007c783          	lbu	a5,0(a5)
    80020432:	fef42623          	sw	a5,-20(s0)
        c2 = (unsigned char)*right++;
    80020436:	fd043783          	ld	a5,-48(s0)
    8002043a:	00178713          	addi	a4,a5,1
    8002043e:	fce43823          	sd	a4,-48(s0)
    80020442:	0007c783          	lbu	a5,0(a5)
    80020446:	fef42423          	sw	a5,-24(s0)
        if (c1 == '\0' || c1 != c2)
    8002044a:	fec42783          	lw	a5,-20(s0)
    8002044e:	2781                	sext.w	a5,a5
    80020450:	cb89                	beqz	a5,80020462 <strncmp+0x1de>
    80020452:	fec42703          	lw	a4,-20(s0)
    80020456:	fe842783          	lw	a5,-24(s0)
    8002045a:	2701                	sext.w	a4,a4
    8002045c:	2781                	sext.w	a5,a5
    8002045e:	00f70b63          	beq	a4,a5,80020474 <strncmp+0x1f0>
            return c1 - c2;
    80020462:	fec42703          	lw	a4,-20(s0)
    80020466:	fe842783          	lw	a5,-24(s0)
    8002046a:	40f707bb          	subw	a5,a4,a5
    8002046e:	2781                	sext.w	a5,a5
    80020470:	2781                	sext.w	a5,a5
    80020472:	a01d                	j	80020498 <strncmp+0x214>
        n--;
    80020474:	fcc42783          	lw	a5,-52(s0)
    80020478:	37fd                	addiw	a5,a5,-1
    8002047a:	fcf42623          	sw	a5,-52(s0)
    while (n > 0) {
    8002047e:	fcc42783          	lw	a5,-52(s0)
    80020482:	2781                	sext.w	a5,a5
    80020484:	f8f04fe3          	bgtz	a5,80020422 <strncmp+0x19e>
    }

    return c1 - c2;
    80020488:	fec42703          	lw	a4,-20(s0)
    8002048c:	fe842783          	lw	a5,-24(s0)
    80020490:	40f707bb          	subw	a5,a4,a5
    80020494:	2781                	sext.w	a5,a5
    80020496:	2781                	sext.w	a5,a5
}
    80020498:	853e                	mv	a0,a5
    8002049a:	7462                	ld	s0,56(sp)
    8002049c:	6121                	addi	sp,sp,64
    8002049e:	8082                	ret

00000000800204a0 <strfindchr>:

int strfindchr(const char *r, char t)
{
    800204a0:	7179                	addi	sp,sp,-48
    800204a2:	f422                	sd	s0,40(sp)
    800204a4:	1800                	addi	s0,sp,48
    800204a6:	fca43c23          	sd	a0,-40(s0)
    800204aa:	87ae                	mv	a5,a1
    800204ac:	fcf40ba3          	sb	a5,-41(s0)
    int i = 0;
    800204b0:	fe042623          	sw	zero,-20(s0)
    while (r[i] != t) {
    800204b4:	a005                	j	800204d4 <strfindchr+0x34>
        if (r[i] == '\0') {
    800204b6:	fec42783          	lw	a5,-20(s0)
    800204ba:	fd843703          	ld	a4,-40(s0)
    800204be:	97ba                	add	a5,a5,a4
    800204c0:	0007c783          	lbu	a5,0(a5)
    800204c4:	e399                	bnez	a5,800204ca <strfindchr+0x2a>
            return -1;
    800204c6:	57fd                	li	a5,-1
    800204c8:	a02d                	j	800204f2 <strfindchr+0x52>
        }
        i++;
    800204ca:	fec42783          	lw	a5,-20(s0)
    800204ce:	2785                	addiw	a5,a5,1
    800204d0:	fef42623          	sw	a5,-20(s0)
    while (r[i] != t) {
    800204d4:	fec42783          	lw	a5,-20(s0)
    800204d8:	fd843703          	ld	a4,-40(s0)
    800204dc:	97ba                	add	a5,a5,a4
    800204de:	0007c703          	lbu	a4,0(a5)
    800204e2:	fd744783          	lbu	a5,-41(s0)
    800204e6:	0ff7f793          	andi	a5,a5,255
    800204ea:	fce796e3          	bne	a5,a4,800204b6 <strfindchr+0x16>
    }
    return i;
    800204ee:	fec42783          	lw	a5,-20(s0)
}
    800204f2:	853e                	mv	a0,a5
    800204f4:	7422                	ld	s0,40(sp)
    800204f6:	6145                	addi	sp,sp,48
    800204f8:	8082                	ret

00000000800204fa <strlen>:

int strlen(const char *s)
{
    800204fa:	7179                	addi	sp,sp,-48
    800204fc:	f422                	sd	s0,40(sp)
    800204fe:	1800                	addi	s0,sp,48
    80020500:	fca43c23          	sd	a0,-40(s0)
    int len = 0;
    80020504:	fe042623          	sw	zero,-20(s0)
    while (s[len] && ++len)
    80020508:	0001                	nop
    8002050a:	fec42783          	lw	a5,-20(s0)
    8002050e:	fd843703          	ld	a4,-40(s0)
    80020512:	97ba                	add	a5,a5,a4
    80020514:	0007c783          	lbu	a5,0(a5)
    80020518:	cb91                	beqz	a5,8002052c <strlen+0x32>
    8002051a:	fec42783          	lw	a5,-20(s0)
    8002051e:	2785                	addiw	a5,a5,1
    80020520:	fef42623          	sw	a5,-20(s0)
    80020524:	fec42783          	lw	a5,-20(s0)
    80020528:	2781                	sext.w	a5,a5
    8002052a:	f3e5                	bnez	a5,8002050a <strlen+0x10>
        ;
    return len;
    8002052c:	fec42783          	lw	a5,-20(s0)
}
    80020530:	853e                	mv	a0,a5
    80020532:	7422                	ld	s0,40(sp)
    80020534:	6145                	addi	sp,sp,48
    80020536:	8082                	ret

0000000080020538 <strcpy>:

char *strcpy(char *dest, const char *s)
{
    80020538:	7179                	addi	sp,sp,-48
    8002053a:	f422                	sd	s0,40(sp)
    8002053c:	1800                	addi	s0,sp,48
    8002053e:	fca43c23          	sd	a0,-40(s0)
    80020542:	fcb43823          	sd	a1,-48(s0)
    char *o = dest;
    80020546:	fd843783          	ld	a5,-40(s0)
    8002054a:	fef43423          	sd	a5,-24(s0)
    while (*s) {
    8002054e:	a00d                	j	80020570 <strcpy+0x38>
        *dest++ = *s++;
    80020550:	fd043703          	ld	a4,-48(s0)
    80020554:	00170793          	addi	a5,a4,1
    80020558:	fcf43823          	sd	a5,-48(s0)
    8002055c:	fd843783          	ld	a5,-40(s0)
    80020560:	00178693          	addi	a3,a5,1
    80020564:	fcd43c23          	sd	a3,-40(s0)
    80020568:	00074703          	lbu	a4,0(a4)
    8002056c:	00e78023          	sb	a4,0(a5)
    while (*s) {
    80020570:	fd043783          	ld	a5,-48(s0)
    80020574:	0007c783          	lbu	a5,0(a5)
    80020578:	ffe1                	bnez	a5,80020550 <strcpy+0x18>
    }
    *dest = '\0';
    8002057a:	fd843783          	ld	a5,-40(s0)
    8002057e:	00078023          	sb	zero,0(a5)
    return o;
    80020582:	fe843783          	ld	a5,-24(s0)
}
    80020586:	853e                	mv	a0,a5
    80020588:	7422                	ld	s0,40(sp)
    8002058a:	6145                	addi	sp,sp,48
    8002058c:	8082                	ret

000000008002058e <strncpy>:

char *strncpy(char *dest, const char *s, int n)
{
    8002058e:	7139                	addi	sp,sp,-64
    80020590:	fc22                	sd	s0,56(sp)
    80020592:	0080                	addi	s0,sp,64
    80020594:	fca43c23          	sd	a0,-40(s0)
    80020598:	fcb43823          	sd	a1,-48(s0)
    8002059c:	87b2                	mv	a5,a2
    8002059e:	fcf42623          	sw	a5,-52(s0)
    char *o = dest;
    800205a2:	fd843783          	ld	a5,-40(s0)
    800205a6:	fef43423          	sd	a5,-24(s0)
    while (*s && n-- > 0) {
    800205aa:	a00d                	j	800205cc <strncpy+0x3e>
        *dest++ = *s++;
    800205ac:	fd043703          	ld	a4,-48(s0)
    800205b0:	00170793          	addi	a5,a4,1
    800205b4:	fcf43823          	sd	a5,-48(s0)
    800205b8:	fd843783          	ld	a5,-40(s0)
    800205bc:	00178693          	addi	a3,a5,1
    800205c0:	fcd43c23          	sd	a3,-40(s0)
    800205c4:	00074703          	lbu	a4,0(a4)
    800205c8:	00e78023          	sb	a4,0(a5)
    while (*s && n-- > 0) {
    800205cc:	fd043783          	ld	a5,-48(s0)
    800205d0:	0007c783          	lbu	a5,0(a5)
    800205d4:	cb89                	beqz	a5,800205e6 <strncpy+0x58>
    800205d6:	fcc42783          	lw	a5,-52(s0)
    800205da:	fff7871b          	addiw	a4,a5,-1
    800205de:	fce42623          	sw	a4,-52(s0)
    800205e2:	fcf045e3          	bgtz	a5,800205ac <strncpy+0x1e>
    }
    *dest = '\0';
    800205e6:	fd843783          	ld	a5,-40(s0)
    800205ea:	00078023          	sb	zero,0(a5)
    return o;
    800205ee:	fe843783          	ld	a5,-24(s0)
}
    800205f2:	853e                	mv	a0,a5
    800205f4:	7462                	ld	s0,56(sp)
    800205f6:	6121                	addi	sp,sp,64
    800205f8:	8082                	ret

00000000800205fa <strdup>:


char *strdup(const char *src)
{
    800205fa:	7179                	addi	sp,sp,-48
    800205fc:	f406                	sd	ra,40(sp)
    800205fe:	f022                	sd	s0,32(sp)
    80020600:	1800                	addi	s0,sp,48
    80020602:	fca43c23          	sd	a0,-40(s0)
    int len   = strlen(src);
    80020606:	fd843503          	ld	a0,-40(s0)
    8002060a:	ef1ff0ef          	jal	ra,800204fa <strlen>
    8002060e:	87aa                	mv	a5,a0
    80020610:	fef42623          	sw	a5,-20(s0)
    char *ret = (char *)g_kmalloc(len + 1);
    80020614:	fec42783          	lw	a5,-20(s0)
    80020618:	2785                	addiw	a5,a5,1
    8002061a:	2781                	sext.w	a5,a5
    8002061c:	853e                	mv	a0,a5
    8002061e:	fdefd0ef          	jal	ra,8001ddfc <g_kmalloc>
    80020622:	fea43023          	sd	a0,-32(s0)
    if (!ret) {
    80020626:	fe043783          	ld	a5,-32(s0)
    8002062a:	e399                	bnez	a5,80020630 <strdup+0x36>
        return NULL;
    8002062c:	4781                	li	a5,0
    8002062e:	a801                	j	8002063e <strdup+0x44>
    }
    return strcpy(ret, src);
    80020630:	fd843583          	ld	a1,-40(s0)
    80020634:	fe043503          	ld	a0,-32(s0)
    80020638:	f01ff0ef          	jal	ra,80020538 <strcpy>
    8002063c:	87aa                	mv	a5,a0
}
    8002063e:	853e                	mv	a0,a5
    80020640:	70a2                	ld	ra,40(sp)
    80020642:	7402                	ld	s0,32(sp)
    80020644:	6145                	addi	sp,sp,48
    80020646:	8082                	ret

0000000080020648 <strstartswith>:

bool strstartswith(const char *src, const char *start)
{
    80020648:	7179                	addi	sp,sp,-48
    8002064a:	f406                	sd	ra,40(sp)
    8002064c:	f022                	sd	s0,32(sp)
    8002064e:	1800                	addi	s0,sp,48
    80020650:	fca43c23          	sd	a0,-40(s0)
    80020654:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    80020658:	fd843503          	ld	a0,-40(s0)
    8002065c:	e9fff0ef          	jal	ra,800204fa <strlen>
    80020660:	87aa                	mv	a5,a0
    80020662:	fef42423          	sw	a5,-24(s0)
    int start_len = strlen(start);
    80020666:	fd043503          	ld	a0,-48(s0)
    8002066a:	e91ff0ef          	jal	ra,800204fa <strlen>
    8002066e:	87aa                	mv	a5,a0
    80020670:	fef42223          	sw	a5,-28(s0)
    int i;
    
    if (src_len < start_len) {
    80020674:	fe842703          	lw	a4,-24(s0)
    80020678:	fe442783          	lw	a5,-28(s0)
    8002067c:	2701                	sext.w	a4,a4
    8002067e:	2781                	sext.w	a5,a5
    80020680:	00f75463          	bge	a4,a5,80020688 <strstartswith+0x40>
        return false;
    80020684:	4781                	li	a5,0
    80020686:	a0a9                	j	800206d0 <strstartswith+0x88>
    }

    for (i = 0;i < start_len;i++) {
    80020688:	fe042623          	sw	zero,-20(s0)
    8002068c:	a80d                	j	800206be <strstartswith+0x76>
        if (src[i] != start[i]) {
    8002068e:	fec42783          	lw	a5,-20(s0)
    80020692:	fd843703          	ld	a4,-40(s0)
    80020696:	97ba                	add	a5,a5,a4
    80020698:	0007c683          	lbu	a3,0(a5)
    8002069c:	fec42783          	lw	a5,-20(s0)
    800206a0:	fd043703          	ld	a4,-48(s0)
    800206a4:	97ba                	add	a5,a5,a4
    800206a6:	0007c783          	lbu	a5,0(a5)
    800206aa:	8736                	mv	a4,a3
    800206ac:	00f70463          	beq	a4,a5,800206b4 <strstartswith+0x6c>
            return false;
    800206b0:	4781                	li	a5,0
    800206b2:	a839                	j	800206d0 <strstartswith+0x88>
    for (i = 0;i < start_len;i++) {
    800206b4:	fec42783          	lw	a5,-20(s0)
    800206b8:	2785                	addiw	a5,a5,1
    800206ba:	fef42623          	sw	a5,-20(s0)
    800206be:	fec42703          	lw	a4,-20(s0)
    800206c2:	fe442783          	lw	a5,-28(s0)
    800206c6:	2701                	sext.w	a4,a4
    800206c8:	2781                	sext.w	a5,a5
    800206ca:	fcf742e3          	blt	a4,a5,8002068e <strstartswith+0x46>
        }
    }

    return true;
    800206ce:	4785                	li	a5,1
}
    800206d0:	853e                	mv	a0,a5
    800206d2:	70a2                	ld	ra,40(sp)
    800206d4:	7402                	ld	s0,32(sp)
    800206d6:	6145                	addi	sp,sp,48
    800206d8:	8082                	ret

00000000800206da <strendswith>:

bool strendswith(const char *src, const char *end)
{
    800206da:	7179                	addi	sp,sp,-48
    800206dc:	f406                	sd	ra,40(sp)
    800206de:	f022                	sd	s0,32(sp)
    800206e0:	1800                	addi	s0,sp,48
    800206e2:	fca43c23          	sd	a0,-40(s0)
    800206e6:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    800206ea:	fd843503          	ld	a0,-40(s0)
    800206ee:	e0dff0ef          	jal	ra,800204fa <strlen>
    800206f2:	87aa                	mv	a5,a0
    800206f4:	fef42423          	sw	a5,-24(s0)
    int end_len = strlen(end);
    800206f8:	fd043503          	ld	a0,-48(s0)
    800206fc:	dffff0ef          	jal	ra,800204fa <strlen>
    80020700:	87aa                	mv	a5,a0
    80020702:	fef42223          	sw	a5,-28(s0)
    int cmp = src_len - end_len;
    80020706:	fe842703          	lw	a4,-24(s0)
    8002070a:	fe442783          	lw	a5,-28(s0)
    8002070e:	40f707bb          	subw	a5,a4,a5
    80020712:	fef42023          	sw	a5,-32(s0)
    int i;
    
    if (src_len < end_len) {
    80020716:	fe842703          	lw	a4,-24(s0)
    8002071a:	fe442783          	lw	a5,-28(s0)
    8002071e:	2701                	sext.w	a4,a4
    80020720:	2781                	sext.w	a5,a5
    80020722:	00f75463          	bge	a4,a5,8002072a <strendswith+0x50>
        return false;
    80020726:	4781                	li	a5,0
    80020728:	a891                	j	8002077c <strendswith+0xa2>
    }

    for (i = 0;i < end_len;i++) {
    8002072a:	fe042623          	sw	zero,-20(s0)
    8002072e:	a835                	j	8002076a <strendswith+0x90>
        if (src[i + cmp] != end[i]) {
    80020730:	fec42703          	lw	a4,-20(s0)
    80020734:	fe042783          	lw	a5,-32(s0)
    80020738:	9fb9                	addw	a5,a5,a4
    8002073a:	2781                	sext.w	a5,a5
    8002073c:	873e                	mv	a4,a5
    8002073e:	fd843783          	ld	a5,-40(s0)
    80020742:	97ba                	add	a5,a5,a4
    80020744:	0007c683          	lbu	a3,0(a5)
    80020748:	fec42783          	lw	a5,-20(s0)
    8002074c:	fd043703          	ld	a4,-48(s0)
    80020750:	97ba                	add	a5,a5,a4
    80020752:	0007c783          	lbu	a5,0(a5)
    80020756:	8736                	mv	a4,a3
    80020758:	00f70463          	beq	a4,a5,80020760 <strendswith+0x86>
            return false;
    8002075c:	4781                	li	a5,0
    8002075e:	a839                	j	8002077c <strendswith+0xa2>
    for (i = 0;i < end_len;i++) {
    80020760:	fec42783          	lw	a5,-20(s0)
    80020764:	2785                	addiw	a5,a5,1
    80020766:	fef42623          	sw	a5,-20(s0)
    8002076a:	fec42703          	lw	a4,-20(s0)
    8002076e:	fe442783          	lw	a5,-28(s0)
    80020772:	2701                	sext.w	a4,a4
    80020774:	2781                	sext.w	a5,a5
    80020776:	faf74de3          	blt	a4,a5,80020730 <strendswith+0x56>
        }
    }

    return true;    
    8002077a:	4785                	li	a5,1
}
    8002077c:	853e                	mv	a0,a5
    8002077e:	70a2                	ld	ra,40(sp)
    80020780:	7402                	ld	s0,32(sp)
    80020782:	6145                	addi	sp,sp,48
    80020784:	8082                	ret

0000000080020786 <vector_init>:
    uint32_t size;
    uint32_t capacity;
    uint64_t *values;
} Vector;

static Vector *vector_init(Vector *vec) {
    80020786:	1101                	addi	sp,sp,-32
    80020788:	ec22                	sd	s0,24(sp)
    8002078a:	1000                	addi	s0,sp,32
    8002078c:	fea43423          	sd	a0,-24(s0)
    if (vec == NULL) {
    80020790:	fe843783          	ld	a5,-24(s0)
    80020794:	e399                	bnez	a5,8002079a <vector_init+0x14>
        return NULL;
    80020796:	4781                	li	a5,0
    80020798:	a839                	j	800207b6 <vector_init+0x30>
    }
    vec->size = 0;
    8002079a:	fe843783          	ld	a5,-24(s0)
    8002079e:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    800207a2:	fe843783          	ld	a5,-24(s0)
    800207a6:	0007a223          	sw	zero,4(a5)
    vec->values = NULL;
    800207aa:	fe843783          	ld	a5,-24(s0)
    800207ae:	0007b423          	sd	zero,8(a5)
    return vec;
    800207b2:	fe843783          	ld	a5,-24(s0)
}
    800207b6:	853e                	mv	a0,a5
    800207b8:	6462                	ld	s0,24(sp)
    800207ba:	6105                	addi	sp,sp,32
    800207bc:	8082                	ret

00000000800207be <vector_new>:

Vector *vector_new(void) {
    800207be:	1141                	addi	sp,sp,-16
    800207c0:	e406                	sd	ra,8(sp)
    800207c2:	e022                	sd	s0,0(sp)
    800207c4:	0800                	addi	s0,sp,16
    return vector_init((Vector *)g_kmalloc(sizeof(Vector)));
    800207c6:	4541                	li	a0,16
    800207c8:	e34fd0ef          	jal	ra,8001ddfc <g_kmalloc>
    800207cc:	87aa                	mv	a5,a0
    800207ce:	853e                	mv	a0,a5
    800207d0:	fb7ff0ef          	jal	ra,80020786 <vector_init>
    800207d4:	87aa                	mv	a5,a0
}
    800207d6:	853e                	mv	a0,a5
    800207d8:	60a2                	ld	ra,8(sp)
    800207da:	6402                	ld	s0,0(sp)
    800207dc:	0141                	addi	sp,sp,16
    800207de:	8082                	ret

00000000800207e0 <vector_init_with_capacity>:

static Vector *vector_init_with_capacity(Vector *vec, uint32_t capacity) {
    800207e0:	1101                	addi	sp,sp,-32
    800207e2:	ec06                	sd	ra,24(sp)
    800207e4:	e822                	sd	s0,16(sp)
    800207e6:	1000                	addi	s0,sp,32
    800207e8:	fea43423          	sd	a0,-24(s0)
    800207ec:	87ae                	mv	a5,a1
    800207ee:	fef42223          	sw	a5,-28(s0)
    if (vec == NULL) {
    800207f2:	fe843783          	ld	a5,-24(s0)
    800207f6:	e399                	bnez	a5,800207fc <vector_init_with_capacity+0x1c>
        return NULL;
    800207f8:	4781                	li	a5,0
    800207fa:	a035                	j	80020826 <vector_init_with_capacity+0x46>
    }
    vec->size = 0;
    800207fc:	fe843783          	ld	a5,-24(s0)
    80020800:	0007a023          	sw	zero,0(a5)
    vec->capacity = capacity;
    80020804:	fe843783          	ld	a5,-24(s0)
    80020808:	fe442703          	lw	a4,-28(s0)
    8002080c:	c3d8                	sw	a4,4(a5)
    vec->values = (uint64_t *)g_kcalloc(capacity, sizeof(uint64_t));
    8002080e:	fe446783          	lwu	a5,-28(s0)
    80020812:	45a1                	li	a1,8
    80020814:	853e                	mv	a0,a5
    80020816:	e1efd0ef          	jal	ra,8001de34 <g_kcalloc>
    8002081a:	872a                	mv	a4,a0
    8002081c:	fe843783          	ld	a5,-24(s0)
    80020820:	e798                	sd	a4,8(a5)
    return vec;
    80020822:	fe843783          	ld	a5,-24(s0)
}
    80020826:	853e                	mv	a0,a5
    80020828:	60e2                	ld	ra,24(sp)
    8002082a:	6442                	ld	s0,16(sp)
    8002082c:	6105                	addi	sp,sp,32
    8002082e:	8082                	ret

0000000080020830 <vector_new_with_capacity>:

Vector *vector_new_with_capacity(uint32_t capacity) {
    80020830:	1101                	addi	sp,sp,-32
    80020832:	ec06                	sd	ra,24(sp)
    80020834:	e822                	sd	s0,16(sp)
    80020836:	1000                	addi	s0,sp,32
    80020838:	87aa                	mv	a5,a0
    8002083a:	fef42623          	sw	a5,-20(s0)
    return vector_init_with_capacity((Vector *)g_kmalloc(sizeof(Vector)), capacity);
    8002083e:	4541                	li	a0,16
    80020840:	dbcfd0ef          	jal	ra,8001ddfc <g_kmalloc>
    80020844:	872a                	mv	a4,a0
    80020846:	fec42783          	lw	a5,-20(s0)
    8002084a:	85be                	mv	a1,a5
    8002084c:	853a                	mv	a0,a4
    8002084e:	f93ff0ef          	jal	ra,800207e0 <vector_init_with_capacity>
    80020852:	87aa                	mv	a5,a0
}
    80020854:	853e                	mv	a0,a5
    80020856:	60e2                	ld	ra,24(sp)
    80020858:	6442                	ld	s0,16(sp)
    8002085a:	6105                	addi	sp,sp,32
    8002085c:	8082                	ret

000000008002085e <vector_push>:

void vector_push(Vector *vec, uint64_t value) {
    8002085e:	1101                	addi	sp,sp,-32
    80020860:	ec06                	sd	ra,24(sp)
    80020862:	e822                	sd	s0,16(sp)
    80020864:	1000                	addi	s0,sp,32
    80020866:	fea43423          	sd	a0,-24(s0)
    8002086a:	feb43023          	sd	a1,-32(s0)
    vector_insert(vec, vec->size, value);
    8002086e:	fe843783          	ld	a5,-24(s0)
    80020872:	439c                	lw	a5,0(a5)
    80020874:	fe043603          	ld	a2,-32(s0)
    80020878:	85be                	mv	a1,a5
    8002087a:	fe843503          	ld	a0,-24(s0)
    8002087e:	00e000ef          	jal	ra,8002088c <vector_insert>
}
    80020882:	0001                	nop
    80020884:	60e2                	ld	ra,24(sp)
    80020886:	6442                	ld	s0,16(sp)
    80020888:	6105                	addi	sp,sp,32
    8002088a:	8082                	ret

000000008002088c <vector_insert>:

void vector_insert(Vector *vec, uint32_t idx, uint64_t value) {
    8002088c:	7139                	addi	sp,sp,-64
    8002088e:	fc06                	sd	ra,56(sp)
    80020890:	f822                	sd	s0,48(sp)
    80020892:	0080                	addi	s0,sp,64
    80020894:	fca43c23          	sd	a0,-40(s0)
    80020898:	87ae                	mv	a5,a1
    8002089a:	fcc43423          	sd	a2,-56(s0)
    8002089e:	fcf42a23          	sw	a5,-44(s0)
    uint32_t i;
    vector_resize(vec, vec->size + 1);
    800208a2:	fd843783          	ld	a5,-40(s0)
    800208a6:	439c                	lw	a5,0(a5)
    800208a8:	2785                	addiw	a5,a5,1
    800208aa:	2781                	sext.w	a5,a5
    800208ac:	85be                	mv	a1,a5
    800208ae:	fd843503          	ld	a0,-40(s0)
    800208b2:	214000ef          	jal	ra,80020ac6 <vector_resize>
    for (i = vec->size - 1;i > idx;i--) {
    800208b6:	fd843783          	ld	a5,-40(s0)
    800208ba:	439c                	lw	a5,0(a5)
    800208bc:	37fd                	addiw	a5,a5,-1
    800208be:	fef42623          	sw	a5,-20(s0)
    800208c2:	a805                	j	800208f2 <vector_insert+0x66>
        vector_set(vec, i, vector_get_unchecked(vec, i - 1));
    800208c4:	fec42783          	lw	a5,-20(s0)
    800208c8:	37fd                	addiw	a5,a5,-1
    800208ca:	2781                	sext.w	a5,a5
    800208cc:	85be                	mv	a1,a5
    800208ce:	fd843503          	ld	a0,-40(s0)
    800208d2:	13a000ef          	jal	ra,80020a0c <vector_get_unchecked>
    800208d6:	872a                	mv	a4,a0
    800208d8:	fec42783          	lw	a5,-20(s0)
    800208dc:	863a                	mv	a2,a4
    800208de:	85be                	mv	a1,a5
    800208e0:	fd843503          	ld	a0,-40(s0)
    800208e4:	094000ef          	jal	ra,80020978 <vector_set>
    for (i = vec->size - 1;i > idx;i--) {
    800208e8:	fec42783          	lw	a5,-20(s0)
    800208ec:	37fd                	addiw	a5,a5,-1
    800208ee:	fef42623          	sw	a5,-20(s0)
    800208f2:	fec42703          	lw	a4,-20(s0)
    800208f6:	fd442783          	lw	a5,-44(s0)
    800208fa:	2701                	sext.w	a4,a4
    800208fc:	2781                	sext.w	a5,a5
    800208fe:	fce7e3e3          	bltu	a5,a4,800208c4 <vector_insert+0x38>
    }
    vector_set(vec, idx, value);
    80020902:	fd442783          	lw	a5,-44(s0)
    80020906:	fc843603          	ld	a2,-56(s0)
    8002090a:	85be                	mv	a1,a5
    8002090c:	fd843503          	ld	a0,-40(s0)
    80020910:	068000ef          	jal	ra,80020978 <vector_set>
}
    80020914:	0001                	nop
    80020916:	70e2                	ld	ra,56(sp)
    80020918:	7442                	ld	s0,48(sp)
    8002091a:	6121                	addi	sp,sp,64
    8002091c:	8082                	ret

000000008002091e <vector_find>:

int vector_find(Vector *vec, uint64_t val) {
    8002091e:	7179                	addi	sp,sp,-48
    80020920:	f422                	sd	s0,40(sp)
    80020922:	1800                	addi	s0,sp,48
    80020924:	fca43c23          	sd	a0,-40(s0)
    80020928:	fcb43823          	sd	a1,-48(s0)
    int i;
    for (i = 0;i < (int)vec->size;i++) {
    8002092c:	fe042623          	sw	zero,-20(s0)
    80020930:	a02d                	j	8002095a <vector_find+0x3c>
        if (vec->values[i] == val) {
    80020932:	fd843783          	ld	a5,-40(s0)
    80020936:	6798                	ld	a4,8(a5)
    80020938:	fec42783          	lw	a5,-20(s0)
    8002093c:	078e                	slli	a5,a5,0x3
    8002093e:	97ba                	add	a5,a5,a4
    80020940:	639c                	ld	a5,0(a5)
    80020942:	fd043703          	ld	a4,-48(s0)
    80020946:	00f71563          	bne	a4,a5,80020950 <vector_find+0x32>
            return i;
    8002094a:	fec42783          	lw	a5,-20(s0)
    8002094e:	a00d                	j	80020970 <vector_find+0x52>
    for (i = 0;i < (int)vec->size;i++) {
    80020950:	fec42783          	lw	a5,-20(s0)
    80020954:	2785                	addiw	a5,a5,1
    80020956:	fef42623          	sw	a5,-20(s0)
    8002095a:	fd843783          	ld	a5,-40(s0)
    8002095e:	439c                	lw	a5,0(a5)
    80020960:	0007871b          	sext.w	a4,a5
    80020964:	fec42783          	lw	a5,-20(s0)
    80020968:	2781                	sext.w	a5,a5
    8002096a:	fce7c4e3          	blt	a5,a4,80020932 <vector_find+0x14>
        }
    }
    return -1;
    8002096e:	57fd                	li	a5,-1
}
    80020970:	853e                	mv	a0,a5
    80020972:	7422                	ld	s0,40(sp)
    80020974:	6145                	addi	sp,sp,48
    80020976:	8082                	ret

0000000080020978 <vector_set>:

bool vector_set(Vector *vec, uint32_t idx, uint64_t val) {
    80020978:	7179                	addi	sp,sp,-48
    8002097a:	f422                	sd	s0,40(sp)
    8002097c:	1800                	addi	s0,sp,48
    8002097e:	fea43423          	sd	a0,-24(s0)
    80020982:	87ae                	mv	a5,a1
    80020984:	fcc43c23          	sd	a2,-40(s0)
    80020988:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    8002098c:	fe843783          	ld	a5,-24(s0)
    80020990:	4398                	lw	a4,0(a5)
    80020992:	fe442783          	lw	a5,-28(s0)
    80020996:	2781                	sext.w	a5,a5
    80020998:	00e7e463          	bltu	a5,a4,800209a0 <vector_set+0x28>
        return false;
    8002099c:	4781                	li	a5,0
    8002099e:	a821                	j	800209b6 <vector_set+0x3e>
    }
    vec->values[idx] = val;
    800209a0:	fe843783          	ld	a5,-24(s0)
    800209a4:	6798                	ld	a4,8(a5)
    800209a6:	fe446783          	lwu	a5,-28(s0)
    800209aa:	078e                	slli	a5,a5,0x3
    800209ac:	97ba                	add	a5,a5,a4
    800209ae:	fd843703          	ld	a4,-40(s0)
    800209b2:	e398                	sd	a4,0(a5)
    return true;
    800209b4:	4785                	li	a5,1
}
    800209b6:	853e                	mv	a0,a5
    800209b8:	7422                	ld	s0,40(sp)
    800209ba:	6145                	addi	sp,sp,48
    800209bc:	8082                	ret

00000000800209be <vector_get>:

bool vector_get(Vector *vec, uint32_t idx, uint64_t *val) {
    800209be:	7179                	addi	sp,sp,-48
    800209c0:	f422                	sd	s0,40(sp)
    800209c2:	1800                	addi	s0,sp,48
    800209c4:	fea43423          	sd	a0,-24(s0)
    800209c8:	87ae                	mv	a5,a1
    800209ca:	fcc43c23          	sd	a2,-40(s0)
    800209ce:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    800209d2:	fe843783          	ld	a5,-24(s0)
    800209d6:	4398                	lw	a4,0(a5)
    800209d8:	fe442783          	lw	a5,-28(s0)
    800209dc:	2781                	sext.w	a5,a5
    800209de:	00e7e463          	bltu	a5,a4,800209e6 <vector_get+0x28>
        return false;
    800209e2:	4781                	li	a5,0
    800209e4:	a005                	j	80020a04 <vector_get+0x46>
    }
    if (val != NULL) {
    800209e6:	fd843783          	ld	a5,-40(s0)
    800209ea:	cf81                	beqz	a5,80020a02 <vector_get+0x44>
        *val = vec->values[idx];
    800209ec:	fe843783          	ld	a5,-24(s0)
    800209f0:	6798                	ld	a4,8(a5)
    800209f2:	fe446783          	lwu	a5,-28(s0)
    800209f6:	078e                	slli	a5,a5,0x3
    800209f8:	97ba                	add	a5,a5,a4
    800209fa:	6398                	ld	a4,0(a5)
    800209fc:	fd843783          	ld	a5,-40(s0)
    80020a00:	e398                	sd	a4,0(a5)
    }
    return true;
    80020a02:	4785                	li	a5,1
}
    80020a04:	853e                	mv	a0,a5
    80020a06:	7422                	ld	s0,40(sp)
    80020a08:	6145                	addi	sp,sp,48
    80020a0a:	8082                	ret

0000000080020a0c <vector_get_unchecked>:

uint64_t vector_get_unchecked(Vector *vec, uint32_t idx) {
    80020a0c:	1101                	addi	sp,sp,-32
    80020a0e:	ec22                	sd	s0,24(sp)
    80020a10:	1000                	addi	s0,sp,32
    80020a12:	fea43423          	sd	a0,-24(s0)
    80020a16:	87ae                	mv	a5,a1
    80020a18:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80020a1c:	fe843783          	ld	a5,-24(s0)
    80020a20:	4398                	lw	a4,0(a5)
    80020a22:	fe442783          	lw	a5,-28(s0)
    80020a26:	2781                	sext.w	a5,a5
    80020a28:	00e7e463          	bltu	a5,a4,80020a30 <vector_get_unchecked+0x24>
        return 0;
    80020a2c:	4781                	li	a5,0
    80020a2e:	a809                	j	80020a40 <vector_get_unchecked+0x34>
    }
    return vec->values[idx];
    80020a30:	fe843783          	ld	a5,-24(s0)
    80020a34:	6798                	ld	a4,8(a5)
    80020a36:	fe446783          	lwu	a5,-28(s0)
    80020a3a:	078e                	slli	a5,a5,0x3
    80020a3c:	97ba                	add	a5,a5,a4
    80020a3e:	639c                	ld	a5,0(a5)
}
    80020a40:	853e                	mv	a0,a5
    80020a42:	6462                	ld	s0,24(sp)
    80020a44:	6105                	addi	sp,sp,32
    80020a46:	8082                	ret

0000000080020a48 <vector_resize_with_default>:


void vector_resize_with_default(Vector *vec, uint32_t new_size, uint64_t def) {
    80020a48:	7139                	addi	sp,sp,-64
    80020a4a:	fc06                	sd	ra,56(sp)
    80020a4c:	f822                	sd	s0,48(sp)
    80020a4e:	0080                	addi	s0,sp,64
    80020a50:	fca43c23          	sd	a0,-40(s0)
    80020a54:	87ae                	mv	a5,a1
    80020a56:	fcc43423          	sd	a2,-56(s0)
    80020a5a:	fcf42a23          	sw	a5,-44(s0)
    uint32_t old_size = vec->size;
    80020a5e:	fd843783          	ld	a5,-40(s0)
    80020a62:	439c                	lw	a5,0(a5)
    80020a64:	fef42423          	sw	a5,-24(s0)
    vector_resize(vec, new_size);
    80020a68:	fd442783          	lw	a5,-44(s0)
    80020a6c:	85be                	mv	a1,a5
    80020a6e:	fd843503          	ld	a0,-40(s0)
    80020a72:	054000ef          	jal	ra,80020ac6 <vector_resize>
    if (old_size < new_size) {
    80020a76:	fe842703          	lw	a4,-24(s0)
    80020a7a:	fd442783          	lw	a5,-44(s0)
    80020a7e:	2701                	sext.w	a4,a4
    80020a80:	2781                	sext.w	a5,a5
    80020a82:	02f77d63          	bgeu	a4,a5,80020abc <vector_resize_with_default+0x74>
        uint32_t i;
        for (i = old_size;i < new_size;i++) {
    80020a86:	fe842783          	lw	a5,-24(s0)
    80020a8a:	fef42623          	sw	a5,-20(s0)
    80020a8e:	a839                	j	80020aac <vector_resize_with_default+0x64>
            vector_set(vec, i, def);
    80020a90:	fec42783          	lw	a5,-20(s0)
    80020a94:	fc843603          	ld	a2,-56(s0)
    80020a98:	85be                	mv	a1,a5
    80020a9a:	fd843503          	ld	a0,-40(s0)
    80020a9e:	edbff0ef          	jal	ra,80020978 <vector_set>
        for (i = old_size;i < new_size;i++) {
    80020aa2:	fec42783          	lw	a5,-20(s0)
    80020aa6:	2785                	addiw	a5,a5,1
    80020aa8:	fef42623          	sw	a5,-20(s0)
    80020aac:	fec42703          	lw	a4,-20(s0)
    80020ab0:	fd442783          	lw	a5,-44(s0)
    80020ab4:	2701                	sext.w	a4,a4
    80020ab6:	2781                	sext.w	a5,a5
    80020ab8:	fcf76ce3          	bltu	a4,a5,80020a90 <vector_resize_with_default+0x48>
        }
    }
}
    80020abc:	0001                	nop
    80020abe:	70e2                	ld	ra,56(sp)
    80020ac0:	7442                	ld	s0,48(sp)
    80020ac2:	6121                	addi	sp,sp,64
    80020ac4:	8082                	ret

0000000080020ac6 <vector_resize>:

void vector_resize(Vector *vec, uint32_t new_size) {
    80020ac6:	7179                	addi	sp,sp,-48
    80020ac8:	f406                	sd	ra,40(sp)
    80020aca:	f022                	sd	s0,32(sp)
    80020acc:	1800                	addi	s0,sp,48
    80020ace:	fca43c23          	sd	a0,-40(s0)
    80020ad2:	87ae                	mv	a5,a1
    80020ad4:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_size > vec->capacity) {
    80020ad8:	fd843783          	ld	a5,-40(s0)
    80020adc:	43d8                	lw	a4,4(a5)
    80020ade:	fd442783          	lw	a5,-44(s0)
    80020ae2:	2781                	sext.w	a5,a5
    80020ae4:	06f77963          	bgeu	a4,a5,80020b56 <vector_resize+0x90>
        vals = (uint64_t *)g_kcalloc(new_size, sizeof(uint64_t));
    80020ae8:	fd446783          	lwu	a5,-44(s0)
    80020aec:	45a1                	li	a1,8
    80020aee:	853e                	mv	a0,a5
    80020af0:	b44fd0ef          	jal	ra,8001de34 <g_kcalloc>
    80020af4:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    80020af8:	fe042623          	sw	zero,-20(s0)
    80020afc:	a02d                	j	80020b26 <vector_resize+0x60>
            vals[i] = vec->values[i];
    80020afe:	fd843783          	ld	a5,-40(s0)
    80020b02:	6798                	ld	a4,8(a5)
    80020b04:	fec46783          	lwu	a5,-20(s0)
    80020b08:	078e                	slli	a5,a5,0x3
    80020b0a:	973e                	add	a4,a4,a5
    80020b0c:	fec46783          	lwu	a5,-20(s0)
    80020b10:	078e                	slli	a5,a5,0x3
    80020b12:	fe043683          	ld	a3,-32(s0)
    80020b16:	97b6                	add	a5,a5,a3
    80020b18:	6318                	ld	a4,0(a4)
    80020b1a:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80020b1c:	fec42783          	lw	a5,-20(s0)
    80020b20:	2785                	addiw	a5,a5,1
    80020b22:	fef42623          	sw	a5,-20(s0)
    80020b26:	fd843783          	ld	a5,-40(s0)
    80020b2a:	4398                	lw	a4,0(a5)
    80020b2c:	fec42783          	lw	a5,-20(s0)
    80020b30:	2781                	sext.w	a5,a5
    80020b32:	fce7e6e3          	bltu	a5,a4,80020afe <vector_resize+0x38>
        }
        g_kfree(vec->values);
    80020b36:	fd843783          	ld	a5,-40(s0)
    80020b3a:	679c                	ld	a5,8(a5)
    80020b3c:	853e                	mv	a0,a5
    80020b3e:	b58fd0ef          	jal	ra,8001de96 <g_kfree>
        vec->values = vals;
    80020b42:	fd843783          	ld	a5,-40(s0)
    80020b46:	fe043703          	ld	a4,-32(s0)
    80020b4a:	e798                	sd	a4,8(a5)
        vec->capacity = new_size;
    80020b4c:	fd843783          	ld	a5,-40(s0)
    80020b50:	fd442703          	lw	a4,-44(s0)
    80020b54:	c3d8                	sw	a4,4(a5)
    }        
    vec->size = new_size;    
    80020b56:	fd843783          	ld	a5,-40(s0)
    80020b5a:	fd442703          	lw	a4,-44(s0)
    80020b5e:	c398                	sw	a4,0(a5)
}
    80020b60:	0001                	nop
    80020b62:	70a2                	ld	ra,40(sp)
    80020b64:	7402                	ld	s0,32(sp)
    80020b66:	6145                	addi	sp,sp,48
    80020b68:	8082                	ret

0000000080020b6a <vector_reserve>:

void vector_reserve(Vector *vec, uint32_t new_capacity) {
    80020b6a:	7179                	addi	sp,sp,-48
    80020b6c:	f406                	sd	ra,40(sp)
    80020b6e:	f022                	sd	s0,32(sp)
    80020b70:	1800                	addi	s0,sp,48
    80020b72:	fca43c23          	sd	a0,-40(s0)
    80020b76:	87ae                	mv	a5,a1
    80020b78:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_capacity > vec->capacity) {
    80020b7c:	fd843783          	ld	a5,-40(s0)
    80020b80:	43d8                	lw	a4,4(a5)
    80020b82:	fd442783          	lw	a5,-44(s0)
    80020b86:	2781                	sext.w	a5,a5
    80020b88:	06f77a63          	bgeu	a4,a5,80020bfc <vector_reserve+0x92>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    80020b8c:	fd446783          	lwu	a5,-44(s0)
    80020b90:	45a1                	li	a1,8
    80020b92:	853e                	mv	a0,a5
    80020b94:	aa0fd0ef          	jal	ra,8001de34 <g_kcalloc>
    80020b98:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    80020b9c:	fe042623          	sw	zero,-20(s0)
    80020ba0:	a02d                	j	80020bca <vector_reserve+0x60>
            vals[i] = vec->values[i];
    80020ba2:	fd843783          	ld	a5,-40(s0)
    80020ba6:	6798                	ld	a4,8(a5)
    80020ba8:	fec46783          	lwu	a5,-20(s0)
    80020bac:	078e                	slli	a5,a5,0x3
    80020bae:	973e                	add	a4,a4,a5
    80020bb0:	fec46783          	lwu	a5,-20(s0)
    80020bb4:	078e                	slli	a5,a5,0x3
    80020bb6:	fe043683          	ld	a3,-32(s0)
    80020bba:	97b6                	add	a5,a5,a3
    80020bbc:	6318                	ld	a4,0(a4)
    80020bbe:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80020bc0:	fec42783          	lw	a5,-20(s0)
    80020bc4:	2785                	addiw	a5,a5,1
    80020bc6:	fef42623          	sw	a5,-20(s0)
    80020bca:	fd843783          	ld	a5,-40(s0)
    80020bce:	4398                	lw	a4,0(a5)
    80020bd0:	fec42783          	lw	a5,-20(s0)
    80020bd4:	2781                	sext.w	a5,a5
    80020bd6:	fce7e6e3          	bltu	a5,a4,80020ba2 <vector_reserve+0x38>
        }
        g_kfree(vec->values);
    80020bda:	fd843783          	ld	a5,-40(s0)
    80020bde:	679c                	ld	a5,8(a5)
    80020be0:	853e                	mv	a0,a5
    80020be2:	ab4fd0ef          	jal	ra,8001de96 <g_kfree>
        vec->values = vals;
    80020be6:	fd843783          	ld	a5,-40(s0)
    80020bea:	fe043703          	ld	a4,-32(s0)
    80020bee:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    80020bf0:	fd843783          	ld	a5,-40(s0)
    80020bf4:	fd442703          	lw	a4,-44(s0)
    80020bf8:	c3d8                	sw	a4,4(a5)
        }
        g_kfree(vec->values);
        vec->values = vals;
        vec->capacity = new_capacity;
    }
}
    80020bfa:	a04d                	j	80020c9c <vector_reserve+0x132>
    else if (new_capacity > 0 && new_capacity < vec->capacity) {
    80020bfc:	fd442783          	lw	a5,-44(s0)
    80020c00:	2781                	sext.w	a5,a5
    80020c02:	cfc9                	beqz	a5,80020c9c <vector_reserve+0x132>
    80020c04:	fd843783          	ld	a5,-40(s0)
    80020c08:	43d8                	lw	a4,4(a5)
    80020c0a:	fd442783          	lw	a5,-44(s0)
    80020c0e:	2781                	sext.w	a5,a5
    80020c10:	08e7f663          	bgeu	a5,a4,80020c9c <vector_reserve+0x132>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    80020c14:	fd446783          	lwu	a5,-44(s0)
    80020c18:	45a1                	li	a1,8
    80020c1a:	853e                	mv	a0,a5
    80020c1c:	a18fd0ef          	jal	ra,8001de34 <g_kcalloc>
    80020c20:	fea43023          	sd	a0,-32(s0)
        if (new_capacity < vec->size) {
    80020c24:	fd843783          	ld	a5,-40(s0)
    80020c28:	4398                	lw	a4,0(a5)
    80020c2a:	fd442783          	lw	a5,-44(s0)
    80020c2e:	2781                	sext.w	a5,a5
    80020c30:	00e7f763          	bgeu	a5,a4,80020c3e <vector_reserve+0xd4>
            vec->size = new_capacity;
    80020c34:	fd843783          	ld	a5,-40(s0)
    80020c38:	fd442703          	lw	a4,-44(s0)
    80020c3c:	c398                	sw	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80020c3e:	fe042623          	sw	zero,-20(s0)
    80020c42:	a02d                	j	80020c6c <vector_reserve+0x102>
            vals[i] = vec->values[i];
    80020c44:	fd843783          	ld	a5,-40(s0)
    80020c48:	6798                	ld	a4,8(a5)
    80020c4a:	fec46783          	lwu	a5,-20(s0)
    80020c4e:	078e                	slli	a5,a5,0x3
    80020c50:	973e                	add	a4,a4,a5
    80020c52:	fec46783          	lwu	a5,-20(s0)
    80020c56:	078e                	slli	a5,a5,0x3
    80020c58:	fe043683          	ld	a3,-32(s0)
    80020c5c:	97b6                	add	a5,a5,a3
    80020c5e:	6318                	ld	a4,0(a4)
    80020c60:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80020c62:	fec42783          	lw	a5,-20(s0)
    80020c66:	2785                	addiw	a5,a5,1
    80020c68:	fef42623          	sw	a5,-20(s0)
    80020c6c:	fd843783          	ld	a5,-40(s0)
    80020c70:	4398                	lw	a4,0(a5)
    80020c72:	fec42783          	lw	a5,-20(s0)
    80020c76:	2781                	sext.w	a5,a5
    80020c78:	fce7e6e3          	bltu	a5,a4,80020c44 <vector_reserve+0xda>
        g_kfree(vec->values);
    80020c7c:	fd843783          	ld	a5,-40(s0)
    80020c80:	679c                	ld	a5,8(a5)
    80020c82:	853e                	mv	a0,a5
    80020c84:	a12fd0ef          	jal	ra,8001de96 <g_kfree>
        vec->values = vals;
    80020c88:	fd843783          	ld	a5,-40(s0)
    80020c8c:	fe043703          	ld	a4,-32(s0)
    80020c90:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    80020c92:	fd843783          	ld	a5,-40(s0)
    80020c96:	fd442703          	lw	a4,-44(s0)
    80020c9a:	c3d8                	sw	a4,4(a5)
}
    80020c9c:	0001                	nop
    80020c9e:	70a2                	ld	ra,40(sp)
    80020ca0:	7402                	ld	s0,32(sp)
    80020ca2:	6145                	addi	sp,sp,48
    80020ca4:	8082                	ret

0000000080020ca6 <vector_remove>:

bool vector_remove(Vector *vec, uint32_t idx) {
    80020ca6:	1101                	addi	sp,sp,-32
    80020ca8:	ec22                	sd	s0,24(sp)
    80020caa:	1000                	addi	s0,sp,32
    80020cac:	fea43423          	sd	a0,-24(s0)
    80020cb0:	87ae                	mv	a5,a1
    80020cb2:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80020cb6:	fe843783          	ld	a5,-24(s0)
    80020cba:	4398                	lw	a4,0(a5)
    80020cbc:	fe442783          	lw	a5,-28(s0)
    80020cc0:	2781                	sext.w	a5,a5
    80020cc2:	00e7e463          	bltu	a5,a4,80020cca <vector_remove+0x24>
        return false;
    80020cc6:	4781                	li	a5,0
    80020cc8:	a8a9                	j	80020d22 <vector_remove+0x7c>
    }
    vec->size -= 1;
    80020cca:	fe843783          	ld	a5,-24(s0)
    80020cce:	439c                	lw	a5,0(a5)
    80020cd0:	37fd                	addiw	a5,a5,-1
    80020cd2:	0007871b          	sext.w	a4,a5
    80020cd6:	fe843783          	ld	a5,-24(s0)
    80020cda:	c398                	sw	a4,0(a5)
    for (;idx < vec->size;idx++) {
    80020cdc:	a815                	j	80020d10 <vector_remove+0x6a>
        vec->values[idx] = vec->values[idx + 1];
    80020cde:	fe843783          	ld	a5,-24(s0)
    80020ce2:	6798                	ld	a4,8(a5)
    80020ce4:	fe442783          	lw	a5,-28(s0)
    80020ce8:	2785                	addiw	a5,a5,1
    80020cea:	2781                	sext.w	a5,a5
    80020cec:	1782                	slli	a5,a5,0x20
    80020cee:	9381                	srli	a5,a5,0x20
    80020cf0:	078e                	slli	a5,a5,0x3
    80020cf2:	973e                	add	a4,a4,a5
    80020cf4:	fe843783          	ld	a5,-24(s0)
    80020cf8:	6794                	ld	a3,8(a5)
    80020cfa:	fe446783          	lwu	a5,-28(s0)
    80020cfe:	078e                	slli	a5,a5,0x3
    80020d00:	97b6                	add	a5,a5,a3
    80020d02:	6318                	ld	a4,0(a4)
    80020d04:	e398                	sd	a4,0(a5)
    for (;idx < vec->size;idx++) {
    80020d06:	fe442783          	lw	a5,-28(s0)
    80020d0a:	2785                	addiw	a5,a5,1
    80020d0c:	fef42223          	sw	a5,-28(s0)
    80020d10:	fe843783          	ld	a5,-24(s0)
    80020d14:	4398                	lw	a4,0(a5)
    80020d16:	fe442783          	lw	a5,-28(s0)
    80020d1a:	2781                	sext.w	a5,a5
    80020d1c:	fce7e1e3          	bltu	a5,a4,80020cde <vector_remove+0x38>
    }
    return true;
    80020d20:	4785                	li	a5,1
}
    80020d22:	853e                	mv	a0,a5
    80020d24:	6462                	ld	s0,24(sp)
    80020d26:	6105                	addi	sp,sp,32
    80020d28:	8082                	ret

0000000080020d2a <vector_remove_value>:

bool vector_remove_value(Vector *vec, uint64_t val) {
    80020d2a:	7179                	addi	sp,sp,-48
    80020d2c:	f406                	sd	ra,40(sp)
    80020d2e:	f022                	sd	s0,32(sp)
    80020d30:	1800                	addi	s0,sp,48
    80020d32:	fca43c23          	sd	a0,-40(s0)
    80020d36:	fcb43823          	sd	a1,-48(s0)
    uint32_t i;
    for (i = 0;i < vec->size;i++) {
    80020d3a:	fe042623          	sw	zero,-20(s0)
    80020d3e:	a81d                	j	80020d74 <vector_remove_value+0x4a>
        if (vec->values[i] == val) {
    80020d40:	fd843783          	ld	a5,-40(s0)
    80020d44:	6798                	ld	a4,8(a5)
    80020d46:	fec46783          	lwu	a5,-20(s0)
    80020d4a:	078e                	slli	a5,a5,0x3
    80020d4c:	97ba                	add	a5,a5,a4
    80020d4e:	639c                	ld	a5,0(a5)
    80020d50:	fd043703          	ld	a4,-48(s0)
    80020d54:	00f71b63          	bne	a4,a5,80020d6a <vector_remove_value+0x40>
            vector_remove(vec, i);
    80020d58:	fec42783          	lw	a5,-20(s0)
    80020d5c:	85be                	mv	a1,a5
    80020d5e:	fd843503          	ld	a0,-40(s0)
    80020d62:	f45ff0ef          	jal	ra,80020ca6 <vector_remove>
            return true;
    80020d66:	4785                	li	a5,1
    80020d68:	a839                	j	80020d86 <vector_remove_value+0x5c>
    for (i = 0;i < vec->size;i++) {
    80020d6a:	fec42783          	lw	a5,-20(s0)
    80020d6e:	2785                	addiw	a5,a5,1
    80020d70:	fef42623          	sw	a5,-20(s0)
    80020d74:	fd843783          	ld	a5,-40(s0)
    80020d78:	4398                	lw	a4,0(a5)
    80020d7a:	fec42783          	lw	a5,-20(s0)
    80020d7e:	2781                	sext.w	a5,a5
    80020d80:	fce7e0e3          	bltu	a5,a4,80020d40 <vector_remove_value+0x16>
        }
    }
    return false;
    80020d84:	4781                	li	a5,0
}
    80020d86:	853e                	mv	a0,a5
    80020d88:	70a2                	ld	ra,40(sp)
    80020d8a:	7402                	ld	s0,32(sp)
    80020d8c:	6145                	addi	sp,sp,48
    80020d8e:	8082                	ret

0000000080020d90 <vector_clear>:

void vector_clear(Vector *vec) {
    80020d90:	1101                	addi	sp,sp,-32
    80020d92:	ec06                	sd	ra,24(sp)
    80020d94:	e822                	sd	s0,16(sp)
    80020d96:	1000                	addi	s0,sp,32
    80020d98:	fea43423          	sd	a0,-24(s0)
    vector_resize(vec, 0);
    80020d9c:	4581                	li	a1,0
    80020d9e:	fe843503          	ld	a0,-24(s0)
    80020da2:	d25ff0ef          	jal	ra,80020ac6 <vector_resize>
}
    80020da6:	0001                	nop
    80020da8:	60e2                	ld	ra,24(sp)
    80020daa:	6442                	ld	s0,16(sp)
    80020dac:	6105                	addi	sp,sp,32
    80020dae:	8082                	ret

0000000080020db0 <vector_binsearch_ascending>:

int vector_binsearch_ascending(struct Vector *vec, uint64_t key) {
    80020db0:	7179                	addi	sp,sp,-48
    80020db2:	f406                	sd	ra,40(sp)
    80020db4:	f022                	sd	s0,32(sp)
    80020db6:	1800                	addi	s0,sp,48
    80020db8:	fca43c23          	sd	a0,-40(s0)
    80020dbc:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    80020dc0:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec);
    80020dc4:	fd843503          	ld	a0,-40(s0)
    80020dc8:	356000ef          	jal	ra,8002111e <vector_size>
    80020dcc:	87aa                	mv	a5,a0
    80020dce:	2781                	sext.w	a5,a5
    80020dd0:	fef42423          	sw	a5,-24(s0)

    while (low < high) {
    80020dd4:	a0ad                	j	80020e3e <vector_binsearch_ascending+0x8e>
        int mid = (low + high) / 2;
    80020dd6:	fec42703          	lw	a4,-20(s0)
    80020dda:	fe842783          	lw	a5,-24(s0)
    80020dde:	9fb9                	addw	a5,a5,a4
    80020de0:	2781                	sext.w	a5,a5
    80020de2:	01f7d71b          	srliw	a4,a5,0x1f
    80020de6:	9fb9                	addw	a5,a5,a4
    80020de8:	4017d79b          	sraiw	a5,a5,0x1
    80020dec:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) > key) {
    80020df0:	fe442783          	lw	a5,-28(s0)
    80020df4:	85be                	mv	a1,a5
    80020df6:	fd843503          	ld	a0,-40(s0)
    80020dfa:	c13ff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020dfe:	872a                	mv	a4,a0
    80020e00:	fd043783          	ld	a5,-48(s0)
    80020e04:	00e7f863          	bgeu	a5,a4,80020e14 <vector_binsearch_ascending+0x64>
            high = mid - 1;
    80020e08:	fe442783          	lw	a5,-28(s0)
    80020e0c:	37fd                	addiw	a5,a5,-1
    80020e0e:	fef42423          	sw	a5,-24(s0)
    80020e12:	a035                	j	80020e3e <vector_binsearch_ascending+0x8e>
        }
        else if (vector_get_unchecked(vec, mid) < key) {
    80020e14:	fe442783          	lw	a5,-28(s0)
    80020e18:	85be                	mv	a1,a5
    80020e1a:	fd843503          	ld	a0,-40(s0)
    80020e1e:	befff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020e22:	872a                	mv	a4,a0
    80020e24:	fd043783          	ld	a5,-48(s0)
    80020e28:	00f77863          	bgeu	a4,a5,80020e38 <vector_binsearch_ascending+0x88>
            low = mid + 1;
    80020e2c:	fe442783          	lw	a5,-28(s0)
    80020e30:	2785                	addiw	a5,a5,1
    80020e32:	fef42623          	sw	a5,-20(s0)
    80020e36:	a021                	j	80020e3e <vector_binsearch_ascending+0x8e>
        }
        else {
            return mid;
    80020e38:	fe442783          	lw	a5,-28(s0)
    80020e3c:	a811                	j	80020e50 <vector_binsearch_ascending+0xa0>
    while (low < high) {
    80020e3e:	fec42703          	lw	a4,-20(s0)
    80020e42:	fe842783          	lw	a5,-24(s0)
    80020e46:	2701                	sext.w	a4,a4
    80020e48:	2781                	sext.w	a5,a5
    80020e4a:	f8f746e3          	blt	a4,a5,80020dd6 <vector_binsearch_ascending+0x26>
        }
    }
    return -1;
    80020e4e:	57fd                	li	a5,-1
}
    80020e50:	853e                	mv	a0,a5
    80020e52:	70a2                	ld	ra,40(sp)
    80020e54:	7402                	ld	s0,32(sp)
    80020e56:	6145                	addi	sp,sp,48
    80020e58:	8082                	ret

0000000080020e5a <vector_binsearch_descending>:

int vector_binsearch_descending(struct Vector *vec, uint64_t key) {
    80020e5a:	7179                	addi	sp,sp,-48
    80020e5c:	f406                	sd	ra,40(sp)
    80020e5e:	f022                	sd	s0,32(sp)
    80020e60:	1800                	addi	s0,sp,48
    80020e62:	fca43c23          	sd	a0,-40(s0)
    80020e66:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    80020e6a:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec) - 1;
    80020e6e:	fd843503          	ld	a0,-40(s0)
    80020e72:	2ac000ef          	jal	ra,8002111e <vector_size>
    80020e76:	87aa                	mv	a5,a0
    80020e78:	2781                	sext.w	a5,a5
    80020e7a:	37fd                	addiw	a5,a5,-1
    80020e7c:	2781                	sext.w	a5,a5
    80020e7e:	fef42423          	sw	a5,-24(s0)

    while (low <= high) {
    80020e82:	a0ad                	j	80020eec <vector_binsearch_descending+0x92>
        int mid = (low + high) / 2;
    80020e84:	fec42703          	lw	a4,-20(s0)
    80020e88:	fe842783          	lw	a5,-24(s0)
    80020e8c:	9fb9                	addw	a5,a5,a4
    80020e8e:	2781                	sext.w	a5,a5
    80020e90:	01f7d71b          	srliw	a4,a5,0x1f
    80020e94:	9fb9                	addw	a5,a5,a4
    80020e96:	4017d79b          	sraiw	a5,a5,0x1
    80020e9a:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) < key) {
    80020e9e:	fe442783          	lw	a5,-28(s0)
    80020ea2:	85be                	mv	a1,a5
    80020ea4:	fd843503          	ld	a0,-40(s0)
    80020ea8:	b65ff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020eac:	872a                	mv	a4,a0
    80020eae:	fd043783          	ld	a5,-48(s0)
    80020eb2:	00f77863          	bgeu	a4,a5,80020ec2 <vector_binsearch_descending+0x68>
            high = mid - 1;
    80020eb6:	fe442783          	lw	a5,-28(s0)
    80020eba:	37fd                	addiw	a5,a5,-1
    80020ebc:	fef42423          	sw	a5,-24(s0)
    80020ec0:	a035                	j	80020eec <vector_binsearch_descending+0x92>
        }
        else if (vector_get_unchecked(vec, mid) > key) {
    80020ec2:	fe442783          	lw	a5,-28(s0)
    80020ec6:	85be                	mv	a1,a5
    80020ec8:	fd843503          	ld	a0,-40(s0)
    80020ecc:	b41ff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020ed0:	872a                	mv	a4,a0
    80020ed2:	fd043783          	ld	a5,-48(s0)
    80020ed6:	00e7f863          	bgeu	a5,a4,80020ee6 <vector_binsearch_descending+0x8c>
            low = mid + 1;
    80020eda:	fe442783          	lw	a5,-28(s0)
    80020ede:	2785                	addiw	a5,a5,1
    80020ee0:	fef42623          	sw	a5,-20(s0)
    80020ee4:	a021                	j	80020eec <vector_binsearch_descending+0x92>
        }
        else {
            return mid;
    80020ee6:	fe442783          	lw	a5,-28(s0)
    80020eea:	a811                	j	80020efe <vector_binsearch_descending+0xa4>
    while (low <= high) {
    80020eec:	fec42703          	lw	a4,-20(s0)
    80020ef0:	fe842783          	lw	a5,-24(s0)
    80020ef4:	2701                	sext.w	a4,a4
    80020ef6:	2781                	sext.w	a5,a5
    80020ef8:	f8e7d6e3          	bge	a5,a4,80020e84 <vector_binsearch_descending+0x2a>
        }
    }
    return -1;
    80020efc:	57fd                	li	a5,-1
}
    80020efe:	853e                	mv	a0,a5
    80020f00:	70a2                	ld	ra,40(sp)
    80020f02:	7402                	ld	s0,32(sp)
    80020f04:	6145                	addi	sp,sp,48
    80020f06:	8082                	ret

0000000080020f08 <vector_sort>:

void vector_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80020f08:	1101                	addi	sp,sp,-32
    80020f0a:	ec06                	sd	ra,24(sp)
    80020f0c:	e822                	sd	s0,16(sp)
    80020f0e:	1000                	addi	s0,sp,32
    80020f10:	fea43423          	sd	a0,-24(s0)
    80020f14:	feb43023          	sd	a1,-32(s0)
    vector_insertion_sort(vec, comp);
    80020f18:	fe043583          	ld	a1,-32(s0)
    80020f1c:	fe843503          	ld	a0,-24(s0)
    80020f20:	10e000ef          	jal	ra,8002102e <vector_insertion_sort>
}
    80020f24:	0001                	nop
    80020f26:	60e2                	ld	ra,24(sp)
    80020f28:	6442                	ld	s0,16(sp)
    80020f2a:	6105                	addi	sp,sp,32
    80020f2c:	8082                	ret

0000000080020f2e <vector_selection_sort>:

void vector_selection_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    80020f2e:	715d                	addi	sp,sp,-80
    80020f30:	e486                	sd	ra,72(sp)
    80020f32:	e0a2                	sd	s0,64(sp)
    80020f34:	fc26                	sd	s1,56(sp)
    80020f36:	0880                	addi	s0,sp,80
    80020f38:	faa43c23          	sd	a0,-72(s0)
    80020f3c:	fab43823          	sd	a1,-80(s0)
    uint32_t i;
    uint32_t j;
    uint32_t min_idx;
    uint64_t tmp;

    for (i = 0;i < vector_size(vec);i++) {
    80020f40:	fc042e23          	sw	zero,-36(s0)
    80020f44:	a0d1                	j	80021008 <vector_selection_sort+0xda>
        min_idx = i;
    80020f46:	fdc42783          	lw	a5,-36(s0)
    80020f4a:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    80020f4e:	fdc42783          	lw	a5,-36(s0)
    80020f52:	2785                	addiw	a5,a5,1
    80020f54:	fcf42c23          	sw	a5,-40(s0)
    80020f58:	a0a9                	j	80020fa2 <vector_selection_sort+0x74>
            if (!comp(vector_get_unchecked(vec, min_idx), vector_get_unchecked(vec, j))) {
    80020f5a:	fd442783          	lw	a5,-44(s0)
    80020f5e:	85be                	mv	a1,a5
    80020f60:	fb843503          	ld	a0,-72(s0)
    80020f64:	aa9ff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020f68:	84aa                	mv	s1,a0
    80020f6a:	fd842783          	lw	a5,-40(s0)
    80020f6e:	85be                	mv	a1,a5
    80020f70:	fb843503          	ld	a0,-72(s0)
    80020f74:	a99ff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020f78:	87aa                	mv	a5,a0
    80020f7a:	fb043703          	ld	a4,-80(s0)
    80020f7e:	85be                	mv	a1,a5
    80020f80:	8526                	mv	a0,s1
    80020f82:	9702                	jalr	a4
    80020f84:	87aa                	mv	a5,a0
    80020f86:	0017c793          	xori	a5,a5,1
    80020f8a:	0ff7f793          	andi	a5,a5,255
    80020f8e:	c789                	beqz	a5,80020f98 <vector_selection_sort+0x6a>
                min_idx = j;
    80020f90:	fd842783          	lw	a5,-40(s0)
    80020f94:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    80020f98:	fd842783          	lw	a5,-40(s0)
    80020f9c:	2785                	addiw	a5,a5,1
    80020f9e:	fcf42c23          	sw	a5,-40(s0)
    80020fa2:	fb843503          	ld	a0,-72(s0)
    80020fa6:	178000ef          	jal	ra,8002111e <vector_size>
    80020faa:	87aa                	mv	a5,a0
    80020fac:	0007871b          	sext.w	a4,a5
    80020fb0:	fd842783          	lw	a5,-40(s0)
    80020fb4:	2781                	sext.w	a5,a5
    80020fb6:	fae7e2e3          	bltu	a5,a4,80020f5a <vector_selection_sort+0x2c>
            }
        }
        tmp = vector_get_unchecked(vec, i);
    80020fba:	fdc42783          	lw	a5,-36(s0)
    80020fbe:	85be                	mv	a1,a5
    80020fc0:	fb843503          	ld	a0,-72(s0)
    80020fc4:	a49ff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020fc8:	fca43423          	sd	a0,-56(s0)
        vector_set(vec, i, vector_get_unchecked(vec, min_idx));
    80020fcc:	fd442783          	lw	a5,-44(s0)
    80020fd0:	85be                	mv	a1,a5
    80020fd2:	fb843503          	ld	a0,-72(s0)
    80020fd6:	a37ff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80020fda:	872a                	mv	a4,a0
    80020fdc:	fdc42783          	lw	a5,-36(s0)
    80020fe0:	863a                	mv	a2,a4
    80020fe2:	85be                	mv	a1,a5
    80020fe4:	fb843503          	ld	a0,-72(s0)
    80020fe8:	991ff0ef          	jal	ra,80020978 <vector_set>
        vector_set(vec, min_idx, tmp);
    80020fec:	fd442783          	lw	a5,-44(s0)
    80020ff0:	fc843603          	ld	a2,-56(s0)
    80020ff4:	85be                	mv	a1,a5
    80020ff6:	fb843503          	ld	a0,-72(s0)
    80020ffa:	97fff0ef          	jal	ra,80020978 <vector_set>
    for (i = 0;i < vector_size(vec);i++) {
    80020ffe:	fdc42783          	lw	a5,-36(s0)
    80021002:	2785                	addiw	a5,a5,1
    80021004:	fcf42e23          	sw	a5,-36(s0)
    80021008:	fb843503          	ld	a0,-72(s0)
    8002100c:	112000ef          	jal	ra,8002111e <vector_size>
    80021010:	87aa                	mv	a5,a0
    80021012:	0007871b          	sext.w	a4,a5
    80021016:	fdc42783          	lw	a5,-36(s0)
    8002101a:	2781                	sext.w	a5,a5
    8002101c:	f2e7e5e3          	bltu	a5,a4,80020f46 <vector_selection_sort+0x18>
    }
}
    80021020:	0001                	nop
    80021022:	0001                	nop
    80021024:	60a6                	ld	ra,72(sp)
    80021026:	6406                	ld	s0,64(sp)
    80021028:	74e2                	ld	s1,56(sp)
    8002102a:	6161                	addi	sp,sp,80
    8002102c:	8082                	ret

000000008002102e <vector_insertion_sort>:

void vector_insertion_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    8002102e:	715d                	addi	sp,sp,-80
    80021030:	e486                	sd	ra,72(sp)
    80021032:	e0a2                	sd	s0,64(sp)
    80021034:	fc26                	sd	s1,56(sp)
    80021036:	0880                	addi	s0,sp,80
    80021038:	faa43c23          	sd	a0,-72(s0)
    8002103c:	fab43823          	sd	a1,-80(s0)
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    80021040:	4785                	li	a5,1
    80021042:	fcf42e23          	sw	a5,-36(s0)
    80021046:	a84d                	j	800210f8 <vector_insertion_sort+0xca>
        uint32_t j = i;
    80021048:	fdc42783          	lw	a5,-36(s0)
    8002104c:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    80021050:	a8b1                	j	800210ac <vector_insertion_sort+0x7e>
            uint64_t left = vector_get_unchecked(vec, j - 1);
    80021052:	fd842783          	lw	a5,-40(s0)
    80021056:	37fd                	addiw	a5,a5,-1
    80021058:	2781                	sext.w	a5,a5
    8002105a:	85be                	mv	a1,a5
    8002105c:	fb843503          	ld	a0,-72(s0)
    80021060:	9adff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80021064:	fca43823          	sd	a0,-48(s0)
            uint64_t right = vector_get_unchecked(vec, j);
    80021068:	fd842783          	lw	a5,-40(s0)
    8002106c:	85be                	mv	a1,a5
    8002106e:	fb843503          	ld	a0,-72(s0)
    80021072:	99bff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    80021076:	fca43423          	sd	a0,-56(s0)

            vector_set(vec, j, left);
    8002107a:	fd842783          	lw	a5,-40(s0)
    8002107e:	fd043603          	ld	a2,-48(s0)
    80021082:	85be                	mv	a1,a5
    80021084:	fb843503          	ld	a0,-72(s0)
    80021088:	8f1ff0ef          	jal	ra,80020978 <vector_set>
            vector_set(vec, j - 1, right);
    8002108c:	fd842783          	lw	a5,-40(s0)
    80021090:	37fd                	addiw	a5,a5,-1
    80021092:	2781                	sext.w	a5,a5
    80021094:	fc843603          	ld	a2,-56(s0)
    80021098:	85be                	mv	a1,a5
    8002109a:	fb843503          	ld	a0,-72(s0)
    8002109e:	8dbff0ef          	jal	ra,80020978 <vector_set>

            j -= 1;
    800210a2:	fd842783          	lw	a5,-40(s0)
    800210a6:	37fd                	addiw	a5,a5,-1
    800210a8:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    800210ac:	fd842783          	lw	a5,-40(s0)
    800210b0:	2781                	sext.w	a5,a5
    800210b2:	cf95                	beqz	a5,800210ee <vector_insertion_sort+0xc0>
    800210b4:	fd842783          	lw	a5,-40(s0)
    800210b8:	37fd                	addiw	a5,a5,-1
    800210ba:	2781                	sext.w	a5,a5
    800210bc:	85be                	mv	a1,a5
    800210be:	fb843503          	ld	a0,-72(s0)
    800210c2:	94bff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    800210c6:	84aa                	mv	s1,a0
    800210c8:	fd842783          	lw	a5,-40(s0)
    800210cc:	85be                	mv	a1,a5
    800210ce:	fb843503          	ld	a0,-72(s0)
    800210d2:	93bff0ef          	jal	ra,80020a0c <vector_get_unchecked>
    800210d6:	87aa                	mv	a5,a0
    800210d8:	fb043703          	ld	a4,-80(s0)
    800210dc:	85be                	mv	a1,a5
    800210de:	8526                	mv	a0,s1
    800210e0:	9702                	jalr	a4
    800210e2:	87aa                	mv	a5,a0
    800210e4:	0017c793          	xori	a5,a5,1
    800210e8:	0ff7f793          	andi	a5,a5,255
    800210ec:	f3bd                	bnez	a5,80021052 <vector_insertion_sort+0x24>
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    800210ee:	fdc42783          	lw	a5,-36(s0)
    800210f2:	2785                	addiw	a5,a5,1
    800210f4:	fcf42e23          	sw	a5,-36(s0)
    800210f8:	fb843503          	ld	a0,-72(s0)
    800210fc:	022000ef          	jal	ra,8002111e <vector_size>
    80021100:	87aa                	mv	a5,a0
    80021102:	0007871b          	sext.w	a4,a5
    80021106:	fdc42783          	lw	a5,-36(s0)
    8002110a:	2781                	sext.w	a5,a5
    8002110c:	f2e7eee3          	bltu	a5,a4,80021048 <vector_insertion_sort+0x1a>
        }
    }
}
    80021110:	0001                	nop
    80021112:	0001                	nop
    80021114:	60a6                	ld	ra,72(sp)
    80021116:	6406                	ld	s0,64(sp)
    80021118:	74e2                	ld	s1,56(sp)
    8002111a:	6161                	addi	sp,sp,80
    8002111c:	8082                	ret

000000008002111e <vector_size>:

uint32_t vector_size(Vector *vec) {
    8002111e:	1101                	addi	sp,sp,-32
    80021120:	ec22                	sd	s0,24(sp)
    80021122:	1000                	addi	s0,sp,32
    80021124:	fea43423          	sd	a0,-24(s0)
    return vec->size;
    80021128:	fe843783          	ld	a5,-24(s0)
    8002112c:	439c                	lw	a5,0(a5)
}
    8002112e:	853e                	mv	a0,a5
    80021130:	6462                	ld	s0,24(sp)
    80021132:	6105                	addi	sp,sp,32
    80021134:	8082                	ret

0000000080021136 <vector_capacity>:

uint32_t vector_capacity(Vector *vec) {
    80021136:	1101                	addi	sp,sp,-32
    80021138:	ec22                	sd	s0,24(sp)
    8002113a:	1000                	addi	s0,sp,32
    8002113c:	fea43423          	sd	a0,-24(s0)
    return vec->capacity;
    80021140:	fe843783          	ld	a5,-24(s0)
    80021144:	43dc                	lw	a5,4(a5)
}
    80021146:	853e                	mv	a0,a5
    80021148:	6462                	ld	s0,24(sp)
    8002114a:	6105                	addi	sp,sp,32
    8002114c:	8082                	ret

000000008002114e <vector_free>:

void vector_free(Vector *vec) {
    8002114e:	1101                	addi	sp,sp,-32
    80021150:	ec06                	sd	ra,24(sp)
    80021152:	e822                	sd	s0,16(sp)
    80021154:	1000                	addi	s0,sp,32
    80021156:	fea43423          	sd	a0,-24(s0)
    g_kfree(vec->values);
    8002115a:	fe843783          	ld	a5,-24(s0)
    8002115e:	679c                	ld	a5,8(a5)
    80021160:	853e                	mv	a0,a5
    80021162:	d35fc0ef          	jal	ra,8001de96 <g_kfree>
    vec->size = 0;
    80021166:	fe843783          	ld	a5,-24(s0)
    8002116a:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    8002116e:	fe843783          	ld	a5,-24(s0)
    80021172:	0007a223          	sw	zero,4(a5)
    g_kfree(vec);
    80021176:	fe843503          	ld	a0,-24(s0)
    8002117a:	d1dfc0ef          	jal	ra,8001de96 <g_kfree>
}
    8002117e:	0001                	nop
    80021180:	60e2                	ld	ra,24(sp)
    80021182:	6442                	ld	s0,16(sp)
    80021184:	6105                	addi	sp,sp,32
    80021186:	8082                	ret

0000000080021188 <vector_sort_signed_long_comparator_ascending>:

VECTOR_COMPARATOR(vector_sort_signed_long_comparator_ascending) {
    80021188:	1101                	addi	sp,sp,-32
    8002118a:	ec22                	sd	s0,24(sp)
    8002118c:	1000                	addi	s0,sp,32
    8002118e:	fea43423          	sd	a0,-24(s0)
    80021192:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    80021196:	fe843703          	ld	a4,-24(s0)
    8002119a:	fe043783          	ld	a5,-32(s0)
    8002119e:	00e7a7b3          	slt	a5,a5,a4
    800211a2:	0017c793          	xori	a5,a5,1
    800211a6:	0ff7f793          	andi	a5,a5,255
}
    800211aa:	853e                	mv	a0,a5
    800211ac:	6462                	ld	s0,24(sp)
    800211ae:	6105                	addi	sp,sp,32
    800211b0:	8082                	ret

00000000800211b2 <vector_sort_signed_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_signed_long_comparator_descending) {
    800211b2:	1101                	addi	sp,sp,-32
    800211b4:	ec22                	sd	s0,24(sp)
    800211b6:	1000                	addi	s0,sp,32
    800211b8:	fea43423          	sd	a0,-24(s0)
    800211bc:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    800211c0:	fe843703          	ld	a4,-24(s0)
    800211c4:	fe043783          	ld	a5,-32(s0)
    800211c8:	00f727b3          	slt	a5,a4,a5
    800211cc:	0017c793          	xori	a5,a5,1
    800211d0:	0ff7f793          	andi	a5,a5,255
}
    800211d4:	853e                	mv	a0,a5
    800211d6:	6462                	ld	s0,24(sp)
    800211d8:	6105                	addi	sp,sp,32
    800211da:	8082                	ret

00000000800211dc <vector_sort_unsigned_long_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_ascending) {
    800211dc:	1101                	addi	sp,sp,-32
    800211de:	ec22                	sd	s0,24(sp)
    800211e0:	1000                	addi	s0,sp,32
    800211e2:	fea43423          	sd	a0,-24(s0)
    800211e6:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    800211ea:	fe843703          	ld	a4,-24(s0)
    800211ee:	fe043783          	ld	a5,-32(s0)
    800211f2:	00e7b7b3          	sltu	a5,a5,a4
    800211f6:	0017c793          	xori	a5,a5,1
    800211fa:	0ff7f793          	andi	a5,a5,255
}
    800211fe:	853e                	mv	a0,a5
    80021200:	6462                	ld	s0,24(sp)
    80021202:	6105                	addi	sp,sp,32
    80021204:	8082                	ret

0000000080021206 <vector_sort_unsigned_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_descending) {
    80021206:	1101                	addi	sp,sp,-32
    80021208:	ec22                	sd	s0,24(sp)
    8002120a:	1000                	addi	s0,sp,32
    8002120c:	fea43423          	sd	a0,-24(s0)
    80021210:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    80021214:	fe843703          	ld	a4,-24(s0)
    80021218:	fe043783          	ld	a5,-32(s0)
    8002121c:	00f737b3          	sltu	a5,a4,a5
    80021220:	0017c793          	xori	a5,a5,1
    80021224:	0ff7f793          	andi	a5,a5,255
}
    80021228:	853e                	mv	a0,a5
    8002122a:	6462                	ld	s0,24(sp)
    8002122c:	6105                	addi	sp,sp,32
    8002122e:	8082                	ret

0000000080021230 <vector_sort_string_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_ascending) {
    80021230:	1101                	addi	sp,sp,-32
    80021232:	ec06                	sd	ra,24(sp)
    80021234:	e822                	sd	s0,16(sp)
    80021236:	1000                	addi	s0,sp,32
    80021238:	fea43423          	sd	a0,-24(s0)
    8002123c:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    80021240:	fe843783          	ld	a5,-24(s0)
    80021244:	fe043703          	ld	a4,-32(s0)
    80021248:	85ba                	mv	a1,a4
    8002124a:	853e                	mv	a0,a5
    8002124c:	fb1fe0ef          	jal	ra,800201fc <strcmp>
    80021250:	87aa                	mv	a5,a0
    80021252:	0017a793          	slti	a5,a5,1
    80021256:	0ff7f793          	andi	a5,a5,255
}
    8002125a:	853e                	mv	a0,a5
    8002125c:	60e2                	ld	ra,24(sp)
    8002125e:	6442                	ld	s0,16(sp)
    80021260:	6105                	addi	sp,sp,32
    80021262:	8082                	ret

0000000080021264 <vector_sort_string_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_descending) {
    80021264:	1101                	addi	sp,sp,-32
    80021266:	ec06                	sd	ra,24(sp)
    80021268:	e822                	sd	s0,16(sp)
    8002126a:	1000                	addi	s0,sp,32
    8002126c:	fea43423          	sd	a0,-24(s0)
    80021270:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    80021274:	fe843783          	ld	a5,-24(s0)
    80021278:	fe043703          	ld	a4,-32(s0)
    8002127c:	85ba                	mv	a1,a4
    8002127e:	853e                	mv	a0,a5
    80021280:	f7dfe0ef          	jal	ra,800201fc <strcmp>
    80021284:	87aa                	mv	a5,a0
    80021286:	fff7c793          	not	a5,a5
    8002128a:	01f7d79b          	srliw	a5,a5,0x1f
    8002128e:	0ff7f793          	andi	a5,a5,255
}
    80021292:	853e                	mv	a0,a5
    80021294:	60e2                	ld	ra,24(sp)
    80021296:	6442                	ld	s0,16(sp)
    80021298:	6105                	addi	sp,sp,32
    8002129a:	8082                	ret
