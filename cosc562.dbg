
cosc562.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000080010000 <_memory_start>:
    80010000:	fe22                	sd	s0,312(sp)
    80010002:	f1ca                	sd	s2,224(sp)
    80010004:	0bee                	slli	s7,s7,0x1b
    80010006:	dead                	beqz	a3,8000ff80 <i+0x8000ff60>
    80010008:	0270                	addi	a2,sp,268
    8001000a:	8002                	0x8002
	...

0000000080010102 <copy_from>:
*/
unsigned long copy_from(void *dst, 
                        const PageTable *from_table, 
                        const void *from, 
                        unsigned long size)
{
    80010102:	7119                	addi	sp,sp,-128
    80010104:	fc86                	sd	ra,120(sp)
    80010106:	f8a2                	sd	s0,112(sp)
    80010108:	0100                	addi	s0,sp,128
    8001010a:	f8a43c23          	sd	a0,-104(s0)
    8001010e:	f8b43823          	sd	a1,-112(s0)
    80010112:	f8c43423          	sd	a2,-120(s0)
    80010116:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    8001011a:	fe043423          	sd	zero,-24(s0)

    unsigned long src_start_addr = (unsigned long)from;
    8001011e:	f8843783          	ld	a5,-120(s0)
    80010122:	fcf43423          	sd	a5,-56(s0)
    unsigned long src_end_addr = (unsigned long)from+size;
    80010126:	f8843783          	ld	a5,-120(s0)
    8001012a:	f8043703          	ld	a4,-128(s0)
    8001012e:	97ba                	add	a5,a5,a4
    80010130:	fcf43023          	sd	a5,-64(s0)
    unsigned long src_first_page = ALIGN_DOWN_POT(src_start_addr, PAGE_SIZE_4K);
    80010134:	fc843703          	ld	a4,-56(s0)
    80010138:	77fd                	lui	a5,0xfffff
    8001013a:	8ff9                	and	a5,a5,a4
    8001013c:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    80010140:	fb843783          	ld	a5,-72(s0)
    80010144:	fef43023          	sd	a5,-32(s0)
    80010148:	a06d                	j	800101f2 <copy_from+0xf0>
        void *physical_address = (void*)mmu_translate(from_table, i);
    8001014a:	fe043583          	ld	a1,-32(s0)
    8001014e:	f9043503          	ld	a0,-112(s0)
    80010152:	7b4050ef          	jal	ra,80015906 <mmu_translate>
    80010156:	87aa                	mv	a5,a0
    80010158:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    8001015c:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == src_start_addr;
    80010160:	fe043703          	ld	a4,-32(s0)
    80010164:	fc843783          	ld	a5,-56(s0)
    80010168:	40f707b3          	sub	a5,a4,a5
    8001016c:	0017b793          	seqz	a5,a5
    80010170:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    80010174:	faf44783          	lbu	a5,-81(s0)
    80010178:	0ff7f793          	andi	a5,a5,255
    8001017c:	cb81                	beqz	a5,8001018c <copy_from+0x8a>
            offset = src_start_addr % PAGE_SIZE_4K;
    8001017e:	fc843703          	ld	a4,-56(s0)
    80010182:	6785                	lui	a5,0x1
    80010184:	17fd                	addi	a5,a5,-1
    80010186:	8ff9                	and	a5,a5,a4
    80010188:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    8001018c:	6785                	lui	a5,0x1
    8001018e:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > src_end_addr) {
    80010192:	fe043703          	ld	a4,-32(s0)
    80010196:	6785                	lui	a5,0x1
    80010198:	97ba                	add	a5,a5,a4
    8001019a:	fc043703          	ld	a4,-64(s0)
    8001019e:	00f77a63          	bgeu	a4,a5,800101b2 <copy_from+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = src_end_addr - i;
    800101a2:	fc043703          	ld	a4,-64(s0)
    800101a6:	fe043783          	ld	a5,-32(s0)
    800101aa:	40f707b3          	sub	a5,a4,a5
    800101ae:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(dst + bytes_copied, physical_address + offset, bytes_to_copy_from_page);
    800101b2:	f9843703          	ld	a4,-104(s0)
    800101b6:	fe843783          	ld	a5,-24(s0)
    800101ba:	00f706b3          	add	a3,a4,a5
    800101be:	fb043703          	ld	a4,-80(s0)
    800101c2:	fd843783          	ld	a5,-40(s0)
    800101c6:	97ba                	add	a5,a5,a4
    800101c8:	fd043703          	ld	a4,-48(s0)
    800101cc:	2701                	sext.w	a4,a4
    800101ce:	863a                	mv	a2,a4
    800101d0:	85be                	mv	a1,a5
    800101d2:	8536                	mv	a0,a3
    800101d4:	16a120ef          	jal	ra,8002233e <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800101d8:	fe843703          	ld	a4,-24(s0)
    800101dc:	fd043783          	ld	a5,-48(s0)
    800101e0:	97ba                	add	a5,a5,a4
    800101e2:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = src_first_page; i < src_end_addr; i += PAGE_SIZE_4K) {
    800101e6:	fe043703          	ld	a4,-32(s0)
    800101ea:	6785                	lui	a5,0x1
    800101ec:	97ba                	add	a5,a5,a4
    800101ee:	fef43023          	sd	a5,-32(s0)
    800101f2:	fe043703          	ld	a4,-32(s0)
    800101f6:	fc043783          	ld	a5,-64(s0)
    800101fa:	f4f768e3          	bltu	a4,a5,8001014a <copy_from+0x48>
    }

    return bytes_copied;
    800101fe:	fe843783          	ld	a5,-24(s0)
}
    80010202:	853e                	mv	a0,a5
    80010204:	70e6                	ld	ra,120(sp)
    80010206:	7446                	ld	s0,112(sp)
    80010208:	6109                	addi	sp,sp,128
    8001020a:	8082                	ret

000000008001020c <copy_to>:
*/
unsigned long copy_to(void *to, 
                      const PageTable *to_table, 
                      const void *src, 
                      unsigned long size)
{
    8001020c:	7119                	addi	sp,sp,-128
    8001020e:	fc86                	sd	ra,120(sp)
    80010210:	f8a2                	sd	s0,112(sp)
    80010212:	0100                	addi	s0,sp,128
    80010214:	f8a43c23          	sd	a0,-104(s0)
    80010218:	f8b43823          	sd	a1,-112(s0)
    8001021c:	f8c43423          	sd	a2,-120(s0)
    80010220:	f8d43023          	sd	a3,-128(s0)

    unsigned long bytes_copied = 0;
    80010224:	fe043423          	sd	zero,-24(s0)

    unsigned long dst_start_addr = (unsigned long)to;
    80010228:	f9843783          	ld	a5,-104(s0)
    8001022c:	fcf43423          	sd	a5,-56(s0)
    unsigned long dst_end_addr = (unsigned long)to+size;
    80010230:	f9843783          	ld	a5,-104(s0)
    80010234:	f8043703          	ld	a4,-128(s0)
    80010238:	97ba                	add	a5,a5,a4
    8001023a:	fcf43023          	sd	a5,-64(s0)
    unsigned long dst_first_page = ALIGN_DOWN_POT(dst_start_addr, PAGE_SIZE_4K);
    8001023e:	fc843703          	ld	a4,-56(s0)
    80010242:	77fd                	lui	a5,0xfffff
    80010244:	8ff9                	and	a5,a5,a4
    80010246:	faf43c23          	sd	a5,-72(s0)

    // Copy the data from the source to the destination.
    // Translate the page aligned source address (for each page in the virtual addresses) using mmu_translate to get the address to copy
    // from the physical memory. Then, use memcpy to copy the data from the physical memory to the destination.
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    8001024a:	fb843783          	ld	a5,-72(s0)
    8001024e:	fef43023          	sd	a5,-32(s0)
    80010252:	a06d                	j	800102fc <copy_to+0xf0>
        void *physical_address = (void*)mmu_translate(to_table, i);
    80010254:	fe043583          	ld	a1,-32(s0)
    80010258:	f9043503          	ld	a0,-112(s0)
    8001025c:	6aa050ef          	jal	ra,80015906 <mmu_translate>
    80010260:	87aa                	mv	a5,a0
    80010262:	faf43823          	sd	a5,-80(s0)

        // Is this the first page, if so, we need to copy from the offset.
        unsigned long offset = 0;
    80010266:	fc043c23          	sd	zero,-40(s0)

        bool is_first_page = i == dst_start_addr;
    8001026a:	fe043703          	ld	a4,-32(s0)
    8001026e:	fc843783          	ld	a5,-56(s0)
    80010272:	40f707b3          	sub	a5,a4,a5
    80010276:	0017b793          	seqz	a5,a5
    8001027a:	faf407a3          	sb	a5,-81(s0)

        // If this is the first page:
        if (is_first_page) {
    8001027e:	faf44783          	lbu	a5,-81(s0)
    80010282:	0ff7f793          	andi	a5,a5,255
    80010286:	cb81                	beqz	a5,80010296 <copy_to+0x8a>
            offset = dst_start_addr % PAGE_SIZE_4K;
    80010288:	fc843703          	ld	a4,-56(s0)
    8001028c:	6785                	lui	a5,0x1
    8001028e:	17fd                	addi	a5,a5,-1
    80010290:	8ff9                	and	a5,a5,a4
    80010292:	fcf43c23          	sd	a5,-40(s0)
        }

        // Is this the last page, if so, we need to copy only the remaining bytes.
        unsigned long bytes_to_copy_from_page = PAGE_SIZE_4K;
    80010296:	6785                	lui	a5,0x1
    80010298:	fcf43823          	sd	a5,-48(s0)
        // If the remaining bytes to copy is less than the page size, then we need to copy only the remaining bytes.
        if (i + PAGE_SIZE_4K > dst_end_addr) {
    8001029c:	fe043703          	ld	a4,-32(s0)
    800102a0:	6785                	lui	a5,0x1
    800102a2:	97ba                	add	a5,a5,a4
    800102a4:	fc043703          	ld	a4,-64(s0)
    800102a8:	00f77a63          	bgeu	a4,a5,800102bc <copy_to+0xb0>
            // The remaining bytes to copy is the difference between the end address and the current address.
            bytes_to_copy_from_page = dst_end_addr - i;
    800102ac:	fc043703          	ld	a4,-64(s0)
    800102b0:	fe043783          	ld	a5,-32(s0)
    800102b4:	40f707b3          	sub	a5,a4,a5
    800102b8:	fcf43823          	sd	a5,-48(s0)
        }

        // Copy the data from the source to the destination.
        memcpy(physical_address + offset, src + bytes_copied, bytes_to_copy_from_page);
    800102bc:	fb043703          	ld	a4,-80(s0)
    800102c0:	fd843783          	ld	a5,-40(s0)
    800102c4:	00f706b3          	add	a3,a4,a5
    800102c8:	f8843703          	ld	a4,-120(s0)
    800102cc:	fe843783          	ld	a5,-24(s0)
    800102d0:	97ba                	add	a5,a5,a4
    800102d2:	fd043703          	ld	a4,-48(s0)
    800102d6:	2701                	sext.w	a4,a4
    800102d8:	863a                	mv	a2,a4
    800102da:	85be                	mv	a1,a5
    800102dc:	8536                	mv	a0,a3
    800102de:	060120ef          	jal	ra,8002233e <memcpy>

        // Increment the number of bytes copied.
        bytes_copied += bytes_to_copy_from_page;
    800102e2:	fe843703          	ld	a4,-24(s0)
    800102e6:	fd043783          	ld	a5,-48(s0)
    800102ea:	97ba                	add	a5,a5,a4
    800102ec:	fef43423          	sd	a5,-24(s0)
    for (unsigned long i = dst_first_page; i < dst_end_addr; i += PAGE_SIZE_4K) {
    800102f0:	fe043703          	ld	a4,-32(s0)
    800102f4:	6785                	lui	a5,0x1
    800102f6:	97ba                	add	a5,a5,a4
    800102f8:	fef43023          	sd	a5,-32(s0)
    800102fc:	fe043703          	ld	a4,-32(s0)
    80010300:	fc043783          	ld	a5,-64(s0)
    80010304:	f4f768e3          	bltu	a4,a5,80010254 <copy_to+0x48>
    }

    return bytes_copied;
    80010308:	fe843783          	ld	a5,-24(s0)
    8001030c:	853e                	mv	a0,a5
    8001030e:	70e6                	ld	ra,120(sp)
    80010310:	7446                	ld	s0,112(sp)
    80010312:	6109                	addi	sp,sp,128
    80010314:	8082                	ret

0000000080010316 <syscall_exit>:
    (void)hart;         \
    (void)epc;          \
    (void)scratch

SYSCALL(exit)
{
    80010316:	7139                	addi	sp,sp,-64
    80010318:	fc06                	sd	ra,56(sp)
    8001031a:	f822                	sd	s0,48(sp)
    8001031c:	0080                	addi	s0,sp,64
    8001031e:	87aa                	mv	a5,a0
    80010320:	fcb43823          	sd	a1,-48(s0)
    80010324:	fcc43423          	sd	a2,-56(s0)
    80010328:	fcf42e23          	sw	a5,-36(s0)
    SYSCALL_ENTER();
    // Kill the current process on this HART and schedule the next
    // one.
    debugf("HELLO\n");
    8001032c:	00016517          	auipc	a0,0x16
    80010330:	cd450513          	addi	a0,a0,-812 # 80026000 <_rodata_start>
    80010334:	2af0b0ef          	jal	ra,8001bde2 <debugf>
    
    // Get the current process running on hart
    Process *p = process_map_get(pid_harts_map_get(hart));
    80010338:	fdc42783          	lw	a5,-36(s0)
    8001033c:	853e                	mv	a0,a5
    8001033e:	0b50b0ef          	jal	ra,8001bbf2 <pid_harts_map_get>
    80010342:	87aa                	mv	a5,a0
    80010344:	853e                	mv	a0,a5
    80010346:	7fc0b0ef          	jal	ra,8001bb42 <process_map_get>
    8001034a:	fea43423          	sd	a0,-24(s0)
    
    // Kill process
    // ...

    // Free process
    if (process_free(p)) 
    8001034e:	fe843503          	ld	a0,-24(s0)
    80010352:	5180b0ef          	jal	ra,8001b86a <process_free>
    80010356:	87aa                	mv	a5,a0
    80010358:	c799                	beqz	a5,80010366 <syscall_exit+0x50>
        fatalf("syscall.c (exit): process_free failed\n");
    8001035a:	00016517          	auipc	a0,0x16
    8001035e:	cae50513          	addi	a0,a0,-850 # 80026008 <_rodata_start+0x8>
    80010362:	3db0b0ef          	jal	ra,8001bf3c <fatalf>
}
    80010366:	0001                	nop
    80010368:	70e2                	ld	ra,56(sp)
    8001036a:	7442                	ld	s0,48(sp)
    8001036c:	6121                	addi	sp,sp,64
    8001036e:	8082                	ret

0000000080010370 <syscall_putchar>:

SYSCALL(putchar)
{
    80010370:	7179                	addi	sp,sp,-48
    80010372:	f406                	sd	ra,40(sp)
    80010374:	f022                	sd	s0,32(sp)
    80010376:	1800                	addi	s0,sp,48
    80010378:	87aa                	mv	a5,a0
    8001037a:	feb43023          	sd	a1,-32(s0)
    8001037e:	fcc43c23          	sd	a2,-40(s0)
    80010382:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    sbi_putchar(XREG(A0));
    80010386:	fd843783          	ld	a5,-40(s0)
    8001038a:	05078793          	addi	a5,a5,80 # 1050 <i+0x1030>
    8001038e:	639c                	ld	a5,0(a5)
    80010390:	0ff7f793          	andi	a5,a5,255
    80010394:	853e                	mv	a0,a5
    80010396:	4690b0ef          	jal	ra,8001bffe <sbi_putchar>
}
    8001039a:	0001                	nop
    8001039c:	70a2                	ld	ra,40(sp)
    8001039e:	7402                	ld	s0,32(sp)
    800103a0:	6145                	addi	sp,sp,48
    800103a2:	8082                	ret

00000000800103a4 <syscall_getchar>:

SYSCALL(getchar)
{
    800103a4:	7179                	addi	sp,sp,-48
    800103a6:	f406                	sd	ra,40(sp)
    800103a8:	f022                	sd	s0,32(sp)
    800103aa:	1800                	addi	s0,sp,48
    800103ac:	87aa                	mv	a5,a0
    800103ae:	feb43023          	sd	a1,-32(s0)
    800103b2:	fcc43c23          	sd	a2,-40(s0)
    800103b6:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    XREG(A0) = sbi_getchar();
    800103ba:	4670b0ef          	jal	ra,8001c020 <sbi_getchar>
    800103be:	87aa                	mv	a5,a0
    800103c0:	873e                	mv	a4,a5
    800103c2:	fd843783          	ld	a5,-40(s0)
    800103c6:	05078793          	addi	a5,a5,80
    800103ca:	e398                	sd	a4,0(a5)
}
    800103cc:	0001                	nop
    800103ce:	70a2                	ld	ra,40(sp)
    800103d0:	7402                	ld	s0,32(sp)
    800103d2:	6145                	addi	sp,sp,48
    800103d4:	8082                	ret

00000000800103d6 <syscall_yield>:

SYSCALL(yield)
{
    800103d6:	7179                	addi	sp,sp,-48
    800103d8:	f422                	sd	s0,40(sp)
    800103da:	1800                	addi	s0,sp,48
    800103dc:	87aa                	mv	a5,a0
    800103de:	feb43023          	sd	a1,-32(s0)
    800103e2:	fcc43c23          	sd	a2,-40(s0)
    800103e6:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // sched_invoke(hart);
}
    800103ea:	0001                	nop
    800103ec:	7422                	ld	s0,40(sp)
    800103ee:	6145                	addi	sp,sp,48
    800103f0:	8082                	ret

00000000800103f2 <syscall_sleep>:

SYSCALL(sleep)
{
    800103f2:	7179                	addi	sp,sp,-48
    800103f4:	f422                	sd	s0,40(sp)
    800103f6:	1800                	addi	s0,sp,48
    800103f8:	87aa                	mv	a5,a0
    800103fa:	feb43023          	sd	a1,-32(s0)
    800103fe:	fcc43c23          	sd	a2,-40(s0)
    80010402:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Sleep the process. VIRT_TIMER_FREQ is 10MHz, divided by 1000, we get 10KHz
    //     p->sleep_until = sbi_get_time() + XREG(A0) * VIRT_TIMER_FREQ / 1000;
    //     p->state = PS_SLEEPING;
}
    80010406:	0001                	nop
    80010408:	7422                	ld	s0,40(sp)
    8001040a:	6145                	addi	sp,sp,48
    8001040c:	8082                	ret

000000008001040e <syscall_events>:

SYSCALL(events)
{
    8001040e:	7179                	addi	sp,sp,-48
    80010410:	f422                	sd	s0,40(sp)
    80010412:	1800                	addi	s0,sp,48
    80010414:	87aa                	mv	a5,a0
    80010416:	feb43023          	sd	a1,-32(s0)
    8001041a:	fcc43c23          	sd	a2,-40(s0)
    8001041e:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    
}
    80010422:	0001                	nop
    80010424:	7422                	ld	s0,40(sp)
    80010426:	6145                	addi	sp,sp,48
    80010428:	8082                	ret

000000008001042a <syscall_handle>:

static const int NUM_SYSCALLS = sizeof(SYSCALLS) / sizeof(SYSCALLS[0]);

// We get here from the trap.c if this is an ECALL from U-MODE
void syscall_handle(int hart, uint64_t epc, int64_t *scratch)
{
    8001042a:	7179                	addi	sp,sp,-48
    8001042c:	f406                	sd	ra,40(sp)
    8001042e:	f022                	sd	s0,32(sp)
    80010430:	1800                	addi	s0,sp,48
    80010432:	87aa                	mv	a5,a0
    80010434:	feb43023          	sd	a1,-32(s0)
    80010438:	fcc43c23          	sd	a2,-40(s0)
    8001043c:	fef42623          	sw	a5,-20(s0)
    // Sched invoke will save sepc, so we want it to resume
    // 4 bytes ahead, which will be the next instruction.
    CSR_WRITE("sepc", epc + 4);
    80010440:	fe043783          	ld	a5,-32(s0)
    80010444:	0791                	addi	a5,a5,4
    80010446:	14179073          	csrw	sepc,a5

    if (XREG(A7) >= NUM_SYSCALLS || SYSCALLS[XREG(A7)] == NULL) {
    8001044a:	fd843783          	ld	a5,-40(s0)
    8001044e:	08878793          	addi	a5,a5,136
    80010452:	639c                	ld	a5,0(a5)
    80010454:	4719                	li	a4,6
    80010456:	00e7df63          	bge	a5,a4,80010474 <syscall_handle+0x4a>
    8001045a:	fd843783          	ld	a5,-40(s0)
    8001045e:	08878793          	addi	a5,a5,136
    80010462:	639c                	ld	a5,0(a5)
    80010464:	00016717          	auipc	a4,0x16
    80010468:	bcc70713          	addi	a4,a4,-1076 # 80026030 <SYSCALLS>
    8001046c:	078e                	slli	a5,a5,0x3
    8001046e:	97ba                	add	a5,a5,a4
    80010470:	639c                	ld	a5,0(a5)
    80010472:	eb81                	bnez	a5,80010482 <syscall_handle+0x58>
        // Invalid syscall
        XREG(A0) = -EINVAL;
    80010474:	fd843783          	ld	a5,-40(s0)
    80010478:	05078793          	addi	a5,a5,80
    8001047c:	5729                	li	a4,-22
    8001047e:	e398                	sd	a4,0(a5)
    80010480:	a035                	j	800104ac <syscall_handle+0x82>
    }
    else {
        SYSCALL_EXEC(XREG(A7));
    80010482:	fd843783          	ld	a5,-40(s0)
    80010486:	08878793          	addi	a5,a5,136
    8001048a:	639c                	ld	a5,0(a5)
    8001048c:	00016717          	auipc	a4,0x16
    80010490:	ba470713          	addi	a4,a4,-1116 # 80026030 <SYSCALLS>
    80010494:	078e                	slli	a5,a5,0x3
    80010496:	97ba                	add	a5,a5,a4
    80010498:	6398                	ld	a4,0(a5)
    8001049a:	fec42783          	lw	a5,-20(s0)
    8001049e:	fd843603          	ld	a2,-40(s0)
    800104a2:	fe043583          	ld	a1,-32(s0)
    800104a6:	853e                	mv	a0,a5
    800104a8:	9702                	jalr	a4
    }
}
    800104aa:	0001                	nop
    800104ac:	0001                	nop
    800104ae:	70a2                	ld	ra,40(sp)
    800104b0:	7402                	ld	s0,32(sp)
    800104b2:	6145                	addi	sp,sp,48
    800104b4:	8082                	ret

00000000800104b6 <elf_is_little_endian>:
#define debugf(...) debugf(__VA_ARGS__)
#else
#define debugf(...)
#endif

bool elf_is_little_endian(Elf64_Ehdr header) {
    800104b6:	1141                	addi	sp,sp,-16
    800104b8:	e422                	sd	s0,8(sp)
    800104ba:	e026                	sd	s1,0(sp)
    800104bc:	0800                	addi	s0,sp,16
    800104be:	84aa                	mv	s1,a0
    return header.e_ident[EI_DATA] == 1;
    800104c0:	0054c783          	lbu	a5,5(s1)
    800104c4:	0007871b          	sext.w	a4,a5
    800104c8:	4785                	li	a5,1
    800104ca:	40f707b3          	sub	a5,a4,a5
    800104ce:	0017b793          	seqz	a5,a5
    800104d2:	0ff7f793          	andi	a5,a5,255
}
    800104d6:	853e                	mv	a0,a5
    800104d8:	6422                	ld	s0,8(sp)
    800104da:	6482                	ld	s1,0(sp)
    800104dc:	0141                	addi	sp,sp,16
    800104de:	8082                	ret

00000000800104e0 <elf_is_big_endian>:

bool elf_is_big_endian(Elf64_Ehdr header) {
    800104e0:	1141                	addi	sp,sp,-16
    800104e2:	e422                	sd	s0,8(sp)
    800104e4:	e026                	sd	s1,0(sp)
    800104e6:	0800                	addi	s0,sp,16
    800104e8:	84aa                	mv	s1,a0
    return header.e_ident[EI_DATA] == 2;
    800104ea:	0054c783          	lbu	a5,5(s1)
    800104ee:	0007871b          	sext.w	a4,a5
    800104f2:	4789                	li	a5,2
    800104f4:	40f707b3          	sub	a5,a4,a5
    800104f8:	0017b793          	seqz	a5,a5
    800104fc:	0ff7f793          	andi	a5,a5,255
}
    80010500:	853e                	mv	a0,a5
    80010502:	6422                	ld	s0,8(sp)
    80010504:	6482                	ld	s1,0(sp)
    80010506:	0141                	addi	sp,sp,16
    80010508:	8082                	ret

000000008001050a <elf_get_machine_name>:

char *elf_get_machine_name(Elf64_Ehdr header) {
    8001050a:	1141                	addi	sp,sp,-16
    8001050c:	e422                	sd	s0,8(sp)
    8001050e:	e026                	sd	s1,0(sp)
    80010510:	0800                	addi	s0,sp,16
    80010512:	84aa                	mv	s1,a0
    switch (header.e_machine) {
    80010514:	0124d783          	lhu	a5,18(s1)
    80010518:	2781                	sext.w	a5,a5
    8001051a:	86be                	mv	a3,a5
    8001051c:	06400713          	li	a4,100
    80010520:	38d76063          	bltu	a4,a3,800108a0 <elf_get_machine_name+0x396>
    80010524:	00279713          	slli	a4,a5,0x2
    80010528:	00016797          	auipc	a5,0x16
    8001052c:	46878793          	addi	a5,a5,1128 # 80026990 <SYSCALLS+0x960>
    80010530:	97ba                	add	a5,a5,a4
    80010532:	439c                	lw	a5,0(a5)
    80010534:	0007871b          	sext.w	a4,a5
    80010538:	00016797          	auipc	a5,0x16
    8001053c:	45878793          	addi	a5,a5,1112 # 80026990 <SYSCALLS+0x960>
    80010540:	97ba                	add	a5,a5,a4
    80010542:	8782                	jr	a5
    case 0: return "No machine";
    80010544:	00016797          	auipc	a5,0x16
    80010548:	b1c78793          	addi	a5,a5,-1252 # 80026060 <SYSCALLS+0x30>
    8001054c:	ae99                	j	800108a2 <elf_get_machine_name+0x398>
    case 1: return "AT&T WE 32100";
    8001054e:	00016797          	auipc	a5,0x16
    80010552:	b2278793          	addi	a5,a5,-1246 # 80026070 <SYSCALLS+0x40>
    80010556:	a6b1                	j	800108a2 <elf_get_machine_name+0x398>
    case 2: return "SPARC";
    80010558:	00016797          	auipc	a5,0x16
    8001055c:	b2878793          	addi	a5,a5,-1240 # 80026080 <SYSCALLS+0x50>
    80010560:	a689                	j	800108a2 <elf_get_machine_name+0x398>
    case 3: return "Intel 80386";
    80010562:	00016797          	auipc	a5,0x16
    80010566:	b2678793          	addi	a5,a5,-1242 # 80026088 <SYSCALLS+0x58>
    8001056a:	ae25                	j	800108a2 <elf_get_machine_name+0x398>
    case 4: return "Motorola 68000";
    8001056c:	00016797          	auipc	a5,0x16
    80010570:	b2c78793          	addi	a5,a5,-1236 # 80026098 <SYSCALLS+0x68>
    80010574:	a63d                	j	800108a2 <elf_get_machine_name+0x398>
    case 5: return "Motorola 88000";
    80010576:	00016797          	auipc	a5,0x16
    8001057a:	b3278793          	addi	a5,a5,-1230 # 800260a8 <SYSCALLS+0x78>
    8001057e:	a615                	j	800108a2 <elf_get_machine_name+0x398>
    case 6: return "(reserved for future use, was EM_486)";
    80010580:	00016797          	auipc	a5,0x16
    80010584:	b3878793          	addi	a5,a5,-1224 # 800260b8 <SYSCALLS+0x88>
    80010588:	ae29                	j	800108a2 <elf_get_machine_name+0x398>
    case 7: return "Intel 80860";
    8001058a:	00016797          	auipc	a5,0x16
    8001058e:	b5678793          	addi	a5,a5,-1194 # 800260e0 <SYSCALLS+0xb0>
    80010592:	ae01                	j	800108a2 <elf_get_machine_name+0x398>
    case 8: return "MIPS I Architecture";
    80010594:	00016797          	auipc	a5,0x16
    80010598:	b5c78793          	addi	a5,a5,-1188 # 800260f0 <SYSCALLS+0xc0>
    8001059c:	a619                	j	800108a2 <elf_get_machine_name+0x398>
    case 9: return "IBM System/370 Processor";
    8001059e:	00016797          	auipc	a5,0x16
    800105a2:	b6a78793          	addi	a5,a5,-1174 # 80026108 <SYSCALLS+0xd8>
    800105a6:	acf5                	j	800108a2 <elf_get_machine_name+0x398>
    case 10: return "MIPS RS3000 Little-endian";
    800105a8:	00016797          	auipc	a5,0x16
    800105ac:	b8078793          	addi	a5,a5,-1152 # 80026128 <SYSCALLS+0xf8>
    800105b0:	accd                	j	800108a2 <elf_get_machine_name+0x398>
    case 11:
    case 12:
    case 13:
    case 14:
        return "(reserved for future use)";
    800105b2:	00016797          	auipc	a5,0x16
    800105b6:	b9678793          	addi	a5,a5,-1130 # 80026148 <SYSCALLS+0x118>
    800105ba:	a4e5                	j	800108a2 <elf_get_machine_name+0x398>

    case 15: return "HPPA";
    800105bc:	00016797          	auipc	a5,0x16
    800105c0:	bac78793          	addi	a5,a5,-1108 # 80026168 <SYSCALLS+0x138>
    800105c4:	acf9                	j	800108a2 <elf_get_machine_name+0x398>
    case 16: return "(reserved for future use)";
    800105c6:	00016797          	auipc	a5,0x16
    800105ca:	b8278793          	addi	a5,a5,-1150 # 80026148 <SYSCALLS+0x118>
    800105ce:	acd1                	j	800108a2 <elf_get_machine_name+0x398>
    case 17: return "Fujitsu VPP500";
    800105d0:	00016797          	auipc	a5,0x16
    800105d4:	ba078793          	addi	a5,a5,-1120 # 80026170 <SYSCALLS+0x140>
    800105d8:	a4e9                	j	800108a2 <elf_get_machine_name+0x398>
    case 18: return "Enhanced SPARC";
    800105da:	00016797          	auipc	a5,0x16
    800105de:	ba678793          	addi	a5,a5,-1114 # 80026180 <SYSCALLS+0x150>
    800105e2:	a4c1                	j	800108a2 <elf_get_machine_name+0x398>
    case 19: return "Intel 80960";
    800105e4:	00016797          	auipc	a5,0x16
    800105e8:	bac78793          	addi	a5,a5,-1108 # 80026190 <SYSCALLS+0x160>
    800105ec:	ac5d                	j	800108a2 <elf_get_machine_name+0x398>
    case 20: return "PowerPC";
    800105ee:	00016797          	auipc	a5,0x16
    800105f2:	bb278793          	addi	a5,a5,-1102 # 800261a0 <SYSCALLS+0x170>
    800105f6:	a475                	j	800108a2 <elf_get_machine_name+0x398>
    case 21: return "64-bit PowerPC";
    800105f8:	00016797          	auipc	a5,0x16
    800105fc:	bb078793          	addi	a5,a5,-1104 # 800261a8 <SYSCALLS+0x178>
    80010600:	a44d                	j	800108a2 <elf_get_machine_name+0x398>
    case 22: return "IBM System/390 Processor";
    80010602:	00016797          	auipc	a5,0x16
    80010606:	bb678793          	addi	a5,a5,-1098 # 800261b8 <SYSCALLS+0x188>
    8001060a:	ac61                	j	800108a2 <elf_get_machine_name+0x398>
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
         return "(reserved for future use)";
    8001060c:	00016797          	auipc	a5,0x16
    80010610:	b3c78793          	addi	a5,a5,-1220 # 80026148 <SYSCALLS+0x118>
    80010614:	a479                	j	800108a2 <elf_get_machine_name+0x398>

    case 36: return "NEC V800";
    80010616:	00016797          	auipc	a5,0x16
    8001061a:	bc278793          	addi	a5,a5,-1086 # 800261d8 <SYSCALLS+0x1a8>
    8001061e:	a451                	j	800108a2 <elf_get_machine_name+0x398>
    case 37: return "Fujitsu FR20";
    80010620:	00016797          	auipc	a5,0x16
    80010624:	bc878793          	addi	a5,a5,-1080 # 800261e8 <SYSCALLS+0x1b8>
    80010628:	acad                	j	800108a2 <elf_get_machine_name+0x398>
    case 38: return "TRW RH-32";
    8001062a:	00016797          	auipc	a5,0x16
    8001062e:	bce78793          	addi	a5,a5,-1074 # 800261f8 <SYSCALLS+0x1c8>
    80010632:	ac85                	j	800108a2 <elf_get_machine_name+0x398>
    case 39: return "Motorola RCE";
    80010634:	00016797          	auipc	a5,0x16
    80010638:	bd478793          	addi	a5,a5,-1068 # 80026208 <SYSCALLS+0x1d8>
    8001063c:	a49d                	j	800108a2 <elf_get_machine_name+0x398>
    case 40: return "ARM 32-bit architecture (AARCH32)";
    8001063e:	00016797          	auipc	a5,0x16
    80010642:	bda78793          	addi	a5,a5,-1062 # 80026218 <SYSCALLS+0x1e8>
    80010646:	acb1                	j	800108a2 <elf_get_machine_name+0x398>
    case 41: return "Digital Alpha";
    80010648:	00016797          	auipc	a5,0x16
    8001064c:	bf878793          	addi	a5,a5,-1032 # 80026240 <SYSCALLS+0x210>
    80010650:	ac89                	j	800108a2 <elf_get_machine_name+0x398>
    case 42: return "Hitatchi SH";
    80010652:	00016797          	auipc	a5,0x16
    80010656:	bfe78793          	addi	a5,a5,-1026 # 80026250 <SYSCALLS+0x220>
    8001065a:	a4a1                	j	800108a2 <elf_get_machine_name+0x398>
    case 43: return "SPARC Version 9";
    8001065c:	00016797          	auipc	a5,0x16
    80010660:	c0478793          	addi	a5,a5,-1020 # 80026260 <SYSCALLS+0x230>
    80010664:	ac3d                	j	800108a2 <elf_get_machine_name+0x398>
    case 44: return "Siemens TriCore embedded processor";
    80010666:	00016797          	auipc	a5,0x16
    8001066a:	c0a78793          	addi	a5,a5,-1014 # 80026270 <SYSCALLS+0x240>
    8001066e:	ac15                	j	800108a2 <elf_get_machine_name+0x398>
    case 45: return "Argonaut RISC Core, Argonaut Technologies Inc.";
    80010670:	00016797          	auipc	a5,0x16
    80010674:	c2878793          	addi	a5,a5,-984 # 80026298 <SYSCALLS+0x268>
    80010678:	a42d                	j	800108a2 <elf_get_machine_name+0x398>
    case 46: return "Hitachi H8/300";
    8001067a:	00016797          	auipc	a5,0x16
    8001067e:	c4e78793          	addi	a5,a5,-946 # 800262c8 <SYSCALLS+0x298>
    80010682:	a405                	j	800108a2 <elf_get_machine_name+0x398>
    case 47: return "Hitachi H8/300H";
    80010684:	00016797          	auipc	a5,0x16
    80010688:	c5478793          	addi	a5,a5,-940 # 800262d8 <SYSCALLS+0x2a8>
    8001068c:	ac19                	j	800108a2 <elf_get_machine_name+0x398>
    case 48: return "Hitachi H8S";
    8001068e:	00016797          	auipc	a5,0x16
    80010692:	c5a78793          	addi	a5,a5,-934 # 800262e8 <SYSCALLS+0x2b8>
    80010696:	a431                	j	800108a2 <elf_get_machine_name+0x398>
    case 49: return "Hitachi H8/500";
    80010698:	00016797          	auipc	a5,0x16
    8001069c:	c6078793          	addi	a5,a5,-928 # 800262f8 <SYSCALLS+0x2c8>
    800106a0:	a409                	j	800108a2 <elf_get_machine_name+0x398>
    case 50: return "Intel IA-64 processor architecture";
    800106a2:	00016797          	auipc	a5,0x16
    800106a6:	c6678793          	addi	a5,a5,-922 # 80026308 <SYSCALLS+0x2d8>
    800106aa:	aae5                	j	800108a2 <elf_get_machine_name+0x398>
    case 51: return "Stanford MIPS-X";
    800106ac:	00016797          	auipc	a5,0x16
    800106b0:	c8478793          	addi	a5,a5,-892 # 80026330 <SYSCALLS+0x300>
    800106b4:	a2fd                	j	800108a2 <elf_get_machine_name+0x398>
    case 52: return "Motorola Coldfire";
    800106b6:	00016797          	auipc	a5,0x16
    800106ba:	c8a78793          	addi	a5,a5,-886 # 80026340 <SYSCALLS+0x310>
    800106be:	a2d5                	j	800108a2 <elf_get_machine_name+0x398>
    case 53: return "Motorola M68HC12";
    800106c0:	00016797          	auipc	a5,0x16
    800106c4:	c9878793          	addi	a5,a5,-872 # 80026358 <SYSCALLS+0x328>
    800106c8:	aae9                	j	800108a2 <elf_get_machine_name+0x398>
    case 54: return "Fujitsu MMA Multimedia Accelerator";
    800106ca:	00016797          	auipc	a5,0x16
    800106ce:	ca678793          	addi	a5,a5,-858 # 80026370 <SYSCALLS+0x340>
    800106d2:	aac1                	j	800108a2 <elf_get_machine_name+0x398>
    case 55: return "Siemens PCP";
    800106d4:	00016797          	auipc	a5,0x16
    800106d8:	cc478793          	addi	a5,a5,-828 # 80026398 <SYSCALLS+0x368>
    800106dc:	a2d9                	j	800108a2 <elf_get_machine_name+0x398>
    case 56: return "Sony nCPU embedded RISC processor";
    800106de:	00016797          	auipc	a5,0x16
    800106e2:	cca78793          	addi	a5,a5,-822 # 800263a8 <SYSCALLS+0x378>
    800106e6:	aa75                	j	800108a2 <elf_get_machine_name+0x398>
    case 57: return "Denso NDR1 microprocessor";
    800106e8:	00016797          	auipc	a5,0x16
    800106ec:	ce878793          	addi	a5,a5,-792 # 800263d0 <SYSCALLS+0x3a0>
    800106f0:	aa4d                	j	800108a2 <elf_get_machine_name+0x398>
    case 58: return "Motorola Star*Core processor";
    800106f2:	00016797          	auipc	a5,0x16
    800106f6:	cfe78793          	addi	a5,a5,-770 # 800263f0 <SYSCALLS+0x3c0>
    800106fa:	a265                	j	800108a2 <elf_get_machine_name+0x398>
    case 59: return "Toyota ME16 processor";
    800106fc:	00016797          	auipc	a5,0x16
    80010700:	d1478793          	addi	a5,a5,-748 # 80026410 <SYSCALLS+0x3e0>
    80010704:	aa79                	j	800108a2 <elf_get_machine_name+0x398>
    case 60: return "STMicroelectronics ST100 processor";
    80010706:	00016797          	auipc	a5,0x16
    8001070a:	d2278793          	addi	a5,a5,-734 # 80026428 <SYSCALLS+0x3f8>
    8001070e:	aa51                	j	800108a2 <elf_get_machine_name+0x398>
    case 61: return "Advanced Logic Corp. TinyJ embedded processor family";
    80010710:	00016797          	auipc	a5,0x16
    80010714:	d4078793          	addi	a5,a5,-704 # 80026450 <SYSCALLS+0x420>
    80010718:	a269                	j	800108a2 <elf_get_machine_name+0x398>
// EM_68HC11	70	Motorola MC68HC11 Microcontroller
// EM_68HC08	71	Motorola MC68HC08 Microcontroller
// EM_68HC05	72	Motorola MC68HC05 Microcontroller
    case 62: return "AMD x86-64 architecture";
    8001071a:	00016797          	auipc	a5,0x16
    8001071e:	d6e78793          	addi	a5,a5,-658 # 80026488 <SYSCALLS+0x458>
    80010722:	a241                	j	800108a2 <elf_get_machine_name+0x398>
    case 63: return "Sony DSP Processor";
    80010724:	00016797          	auipc	a5,0x16
    80010728:	d7c78793          	addi	a5,a5,-644 # 800264a0 <SYSCALLS+0x470>
    8001072c:	aa9d                	j	800108a2 <elf_get_machine_name+0x398>
    case 64: return "Digital Equipment Corp. PDP-10";
    8001072e:	00016797          	auipc	a5,0x16
    80010732:	d8a78793          	addi	a5,a5,-630 # 800264b8 <SYSCALLS+0x488>
    80010736:	a2b5                	j	800108a2 <elf_get_machine_name+0x398>
    case 65: return "Digital Equipment Corp. PDP-11";
    80010738:	00016797          	auipc	a5,0x16
    8001073c:	da078793          	addi	a5,a5,-608 # 800264d8 <SYSCALLS+0x4a8>
    80010740:	a28d                	j	800108a2 <elf_get_machine_name+0x398>
    case 66: return "Siemens FX66 microcontroller";
    80010742:	00016797          	auipc	a5,0x16
    80010746:	db678793          	addi	a5,a5,-586 # 800264f8 <SYSCALLS+0x4c8>
    8001074a:	aaa1                	j	800108a2 <elf_get_machine_name+0x398>
    case 67: return "STMicroelectronics ST9+ 8/16 bit microcontroller";
    8001074c:	00016797          	auipc	a5,0x16
    80010750:	dcc78793          	addi	a5,a5,-564 # 80026518 <SYSCALLS+0x4e8>
    80010754:	a2b9                	j	800108a2 <elf_get_machine_name+0x398>
    case 68: return "STMicroelectronics ST7 8-bit microcontroller";
    80010756:	00016797          	auipc	a5,0x16
    8001075a:	dfa78793          	addi	a5,a5,-518 # 80026550 <SYSCALLS+0x520>
    8001075e:	a291                	j	800108a2 <elf_get_machine_name+0x398>
    case 69: return "Motorola MC68HC16 Microcontroller";
    80010760:	00016797          	auipc	a5,0x16
    80010764:	e2078793          	addi	a5,a5,-480 # 80026580 <SYSCALLS+0x550>
    80010768:	aa2d                	j	800108a2 <elf_get_machine_name+0x398>
    case 70: return "Motorola MC68HC11 Microcontroller";
    8001076a:	00016797          	auipc	a5,0x16
    8001076e:	e3e78793          	addi	a5,a5,-450 # 800265a8 <SYSCALLS+0x578>
    80010772:	aa05                	j	800108a2 <elf_get_machine_name+0x398>
    case 71: return "Motorola MC68HC08 Microcontroller";
    80010774:	00016797          	auipc	a5,0x16
    80010778:	e5c78793          	addi	a5,a5,-420 # 800265d0 <SYSCALLS+0x5a0>
    8001077c:	a21d                	j	800108a2 <elf_get_machine_name+0x398>
    case 72: return "Motorola MC68HC05 Microcontroller";
    8001077e:	00016797          	auipc	a5,0x16
    80010782:	e7a78793          	addi	a5,a5,-390 # 800265f8 <SYSCALLS+0x5c8>
    80010786:	aa31                	j	800108a2 <elf_get_machine_name+0x398>
    case 73: return "Silicon Graphics SVx";
    80010788:	00016797          	auipc	a5,0x16
    8001078c:	e9878793          	addi	a5,a5,-360 # 80026620 <SYSCALLS+0x5f0>
    80010790:	aa09                	j	800108a2 <elf_get_machine_name+0x398>
    case 74: return "STMicroelectronics ST19 8-bit microcontroller";
    80010792:	00016797          	auipc	a5,0x16
    80010796:	ea678793          	addi	a5,a5,-346 # 80026638 <SYSCALLS+0x608>
    8001079a:	a221                	j	800108a2 <elf_get_machine_name+0x398>
    case 75: return "Digital VAX";
    8001079c:	00016797          	auipc	a5,0x16
    800107a0:	ecc78793          	addi	a5,a5,-308 # 80026668 <SYSCALLS+0x638>
    800107a4:	a8fd                	j	800108a2 <elf_get_machine_name+0x398>
    case 76: return "Axis Communications 32-bit embedded processor";
    800107a6:	00016797          	auipc	a5,0x16
    800107aa:	ed278793          	addi	a5,a5,-302 # 80026678 <SYSCALLS+0x648>
    800107ae:	a8d5                	j	800108a2 <elf_get_machine_name+0x398>
    case 77: return "Infineon Technologies 32-bit embedded processor";
    800107b0:	00016797          	auipc	a5,0x16
    800107b4:	ef878793          	addi	a5,a5,-264 # 800266a8 <SYSCALLS+0x678>
    800107b8:	a0ed                	j	800108a2 <elf_get_machine_name+0x398>
    case 78: return "Element 14 64-bit DSP Processor";
    800107ba:	00016797          	auipc	a5,0x16
    800107be:	f1e78793          	addi	a5,a5,-226 # 800266d8 <SYSCALLS+0x6a8>
    800107c2:	a0c5                	j	800108a2 <elf_get_machine_name+0x398>
    case 79: return "LSI Logic 16-bit DSP Processor";
    800107c4:	00016797          	auipc	a5,0x16
    800107c8:	f3478793          	addi	a5,a5,-204 # 800266f8 <SYSCALLS+0x6c8>
    800107cc:	a8d9                	j	800108a2 <elf_get_machine_name+0x398>
    case 80: return "Donald Knuth's educational 64-bit processor";
    800107ce:	00016797          	auipc	a5,0x16
    800107d2:	f4a78793          	addi	a5,a5,-182 # 80026718 <SYSCALLS+0x6e8>
    800107d6:	a0f1                	j	800108a2 <elf_get_machine_name+0x398>
    case 81: return "Harvard University machine-independent object files";
    800107d8:	00016797          	auipc	a5,0x16
    800107dc:	f7078793          	addi	a5,a5,-144 # 80026748 <SYSCALLS+0x718>
    800107e0:	a0c9                	j	800108a2 <elf_get_machine_name+0x398>
    case 82: return "SiTera Prism";
    800107e2:	00016797          	auipc	a5,0x16
    800107e6:	f9e78793          	addi	a5,a5,-98 # 80026780 <SYSCALLS+0x750>
    800107ea:	a865                	j	800108a2 <elf_get_machine_name+0x398>
    case 83: return "Atmel AVR 8-bit microcontroller";
    800107ec:	00016797          	auipc	a5,0x16
    800107f0:	fa478793          	addi	a5,a5,-92 # 80026790 <SYSCALLS+0x760>
    800107f4:	a07d                	j	800108a2 <elf_get_machine_name+0x398>
    case 84: return "Fujitsu FR30";
    800107f6:	00016797          	auipc	a5,0x16
    800107fa:	fba78793          	addi	a5,a5,-70 # 800267b0 <SYSCALLS+0x780>
    800107fe:	a055                	j	800108a2 <elf_get_machine_name+0x398>
    case 85: return "Mitsubishi D10V";
    80010800:	00016797          	auipc	a5,0x16
    80010804:	fc078793          	addi	a5,a5,-64 # 800267c0 <SYSCALLS+0x790>
    80010808:	a869                	j	800108a2 <elf_get_machine_name+0x398>
    case 86: return "Mitsubishi D30V";
    8001080a:	00016797          	auipc	a5,0x16
    8001080e:	fc678793          	addi	a5,a5,-58 # 800267d0 <SYSCALLS+0x7a0>
    80010812:	a841                	j	800108a2 <elf_get_machine_name+0x398>
    case 87: return "NEC v850";
    80010814:	00016797          	auipc	a5,0x16
    80010818:	fcc78793          	addi	a5,a5,-52 # 800267e0 <SYSCALLS+0x7b0>
    8001081c:	a059                	j	800108a2 <elf_get_machine_name+0x398>
    case 88: return "Mitsubishi M32R";
    8001081e:	00016797          	auipc	a5,0x16
    80010822:	fd278793          	addi	a5,a5,-46 # 800267f0 <SYSCALLS+0x7c0>
    80010826:	a8b5                	j	800108a2 <elf_get_machine_name+0x398>
    case 89: return "Matsushita MN10300";
    80010828:	00016797          	auipc	a5,0x16
    8001082c:	fd878793          	addi	a5,a5,-40 # 80026800 <SYSCALLS+0x7d0>
    80010830:	a88d                	j	800108a2 <elf_get_machine_name+0x398>
// EM_TMM_GPP	96	Thompson Multimedia General Purpose Processor
// EM_NS32K	97	National Semiconductor 32000 series
// EM_TPC	98	Tenor Network TPC processor
// EM_SNP1K	99	Trebia SNP 1000 processor
// EM_ST200	100	
    case 90: return "Matsushita MN10200";
    80010832:	00016797          	auipc	a5,0x16
    80010836:	fe678793          	addi	a5,a5,-26 # 80026818 <SYSCALLS+0x7e8>
    8001083a:	a0a5                	j	800108a2 <elf_get_machine_name+0x398>
    case 91: return "picoJava";
    8001083c:	00016797          	auipc	a5,0x16
    80010840:	ff478793          	addi	a5,a5,-12 # 80026830 <SYSCALLS+0x800>
    80010844:	a8b9                	j	800108a2 <elf_get_machine_name+0x398>
    case 92: return "OpenRISC 32-bit embedded processor";
    80010846:	00016797          	auipc	a5,0x16
    8001084a:	ffa78793          	addi	a5,a5,-6 # 80026840 <SYSCALLS+0x810>
    8001084e:	a891                	j	800108a2 <elf_get_machine_name+0x398>
    case 93: return "ARC Cores Tangent-A5";
    80010850:	00016797          	auipc	a5,0x16
    80010854:	01878793          	addi	a5,a5,24 # 80026868 <SYSCALLS+0x838>
    80010858:	a0a9                	j	800108a2 <elf_get_machine_name+0x398>
    case 94: return "Tensilica Xtensa Architecture";
    8001085a:	00016797          	auipc	a5,0x16
    8001085e:	02678793          	addi	a5,a5,38 # 80026880 <SYSCALLS+0x850>
    80010862:	a081                	j	800108a2 <elf_get_machine_name+0x398>
    case 95: return "Alphamosaic VideoCore processor";
    80010864:	00016797          	auipc	a5,0x16
    80010868:	03c78793          	addi	a5,a5,60 # 800268a0 <SYSCALLS+0x870>
    8001086c:	a81d                	j	800108a2 <elf_get_machine_name+0x398>
    case 96: return "Thompson Multimedia General Purpose Processor";
    8001086e:	00016797          	auipc	a5,0x16
    80010872:	05278793          	addi	a5,a5,82 # 800268c0 <SYSCALLS+0x890>
    80010876:	a035                	j	800108a2 <elf_get_machine_name+0x398>
    case 97: return "National Semiconductor 32000 series";
    80010878:	00016797          	auipc	a5,0x16
    8001087c:	07878793          	addi	a5,a5,120 # 800268f0 <SYSCALLS+0x8c0>
    80010880:	a00d                	j	800108a2 <elf_get_machine_name+0x398>
    case 98: return "Tenor Network TPC processor";
    80010882:	00016797          	auipc	a5,0x16
    80010886:	09678793          	addi	a5,a5,150 # 80026918 <SYSCALLS+0x8e8>
    8001088a:	a821                	j	800108a2 <elf_get_machine_name+0x398>
    case 99: return "Trebia SNP 1000 processor";
    8001088c:	00016797          	auipc	a5,0x16
    80010890:	0ac78793          	addi	a5,a5,172 # 80026938 <SYSCALLS+0x908>
    80010894:	a039                	j	800108a2 <elf_get_machine_name+0x398>
    case 100: return "STMicroelectronics (www.st.com) ST200 microcontroller";
    80010896:	00016797          	auipc	a5,0x16
    8001089a:	0c278793          	addi	a5,a5,194 # 80026958 <SYSCALLS+0x928>
    8001089e:	a011                	j	800108a2 <elf_get_machine_name+0x398>
    default: 
        return NULL;
    800108a0:	4781                	li	a5,0
    }

}
    800108a2:	853e                	mv	a0,a5
    800108a4:	6422                	ld	s0,8(sp)
    800108a6:	6482                	ld	s1,0(sp)
    800108a8:	0141                	addi	sp,sp,16
    800108aa:	8082                	ret

00000000800108ac <elf_get_os_abi>:

char *elf_get_os_abi(Elf64_Ehdr header) {
    800108ac:	1141                	addi	sp,sp,-16
    800108ae:	e422                	sd	s0,8(sp)
    800108b0:	e026                	sd	s1,0(sp)
    800108b2:	0800                	addi	s0,sp,16
    800108b4:	84aa                	mv	s1,a0
    switch (header.e_ident[EI_OSABI]) {
    800108b6:	0074c783          	lbu	a5,7(s1)
    800108ba:	2781                	sext.w	a5,a5
    800108bc:	86be                	mv	a3,a5
    800108be:	4739                	li	a4,14
    800108c0:	0ad76363          	bltu	a4,a3,80010966 <elf_get_os_abi+0xba>
    800108c4:	00279713          	slli	a4,a5,0x2
    800108c8:	00016797          	auipc	a5,0x16
    800108cc:	30478793          	addi	a5,a5,772 # 80026bcc <SYSCALLS+0xb9c>
    800108d0:	97ba                	add	a5,a5,a4
    800108d2:	439c                	lw	a5,0(a5)
    800108d4:	0007871b          	sext.w	a4,a5
    800108d8:	00016797          	auipc	a5,0x16
    800108dc:	2f478793          	addi	a5,a5,756 # 80026bcc <SYSCALLS+0xb9c>
    800108e0:	97ba                	add	a5,a5,a4
    800108e2:	8782                	jr	a5
    case 0:
        // System V
        return "System V";
    800108e4:	00016797          	auipc	a5,0x16
    800108e8:	24478793          	addi	a5,a5,580 # 80026b28 <SYSCALLS+0xaf8>
    800108ec:	a851                	j	80010980 <elf_get_os_abi+0xd4>
    case 1:
        // HP-UX
        return "HP-UX";
    800108ee:	00016797          	auipc	a5,0x16
    800108f2:	24a78793          	addi	a5,a5,586 # 80026b38 <SYSCALLS+0xb08>
    800108f6:	a069                	j	80010980 <elf_get_os_abi+0xd4>
    case 2:
        // NetBSD
        return "NetBSD";
    800108f8:	00016797          	auipc	a5,0x16
    800108fc:	24878793          	addi	a5,a5,584 # 80026b40 <SYSCALLS+0xb10>
    80010900:	a041                	j	80010980 <elf_get_os_abi+0xd4>
    case 3:
        // Linux
        return "Linux";
    80010902:	00016797          	auipc	a5,0x16
    80010906:	24678793          	addi	a5,a5,582 # 80026b48 <SYSCALLS+0xb18>
    8001090a:	a89d                	j	80010980 <elf_get_os_abi+0xd4>
    case 6:
        // Solaris
        return "Solaris";
    8001090c:	00016797          	auipc	a5,0x16
    80010910:	24478793          	addi	a5,a5,580 # 80026b50 <SYSCALLS+0xb20>
    80010914:	a0b5                	j	80010980 <elf_get_os_abi+0xd4>
    case 7:
        // AIX
        return "AIX";
    80010916:	00016797          	auipc	a5,0x16
    8001091a:	24278793          	addi	a5,a5,578 # 80026b58 <SYSCALLS+0xb28>
    8001091e:	a08d                	j	80010980 <elf_get_os_abi+0xd4>
    case 8:
        // IRIX
        return "IRIX";
    80010920:	00016797          	auipc	a5,0x16
    80010924:	24078793          	addi	a5,a5,576 # 80026b60 <SYSCALLS+0xb30>
    80010928:	a8a1                	j	80010980 <elf_get_os_abi+0xd4>
    case 9:
        // FreeBSD
        return "FreeBSD";
    8001092a:	00016797          	auipc	a5,0x16
    8001092e:	23e78793          	addi	a5,a5,574 # 80026b68 <SYSCALLS+0xb38>
    80010932:	a0b9                	j	80010980 <elf_get_os_abi+0xd4>
    case 10:
        // Tru64
        return "Tru64";
    80010934:	00016797          	auipc	a5,0x16
    80010938:	23c78793          	addi	a5,a5,572 # 80026b70 <SYSCALLS+0xb40>
    8001093c:	a091                	j	80010980 <elf_get_os_abi+0xd4>
    case 11:
        // Novell Modesto
        return "Novell Modesto";
    8001093e:	00016797          	auipc	a5,0x16
    80010942:	23a78793          	addi	a5,a5,570 # 80026b78 <SYSCALLS+0xb48>
    80010946:	a82d                	j	80010980 <elf_get_os_abi+0xd4>
    case 12:
        // OpenBSD
        return "OpenBSD";
    80010948:	00016797          	auipc	a5,0x16
    8001094c:	24078793          	addi	a5,a5,576 # 80026b88 <SYSCALLS+0xb58>
    80010950:	a805                	j	80010980 <elf_get_os_abi+0xd4>
    case 13:
        // OpenVMS
        return "OpenVMS";
    80010952:	00016797          	auipc	a5,0x16
    80010956:	23e78793          	addi	a5,a5,574 # 80026b90 <SYSCALLS+0xb60>
    8001095a:	a01d                	j	80010980 <elf_get_os_abi+0xd4>
    case 14:
        // NonStop Kernel
        return "HP NonStop Kernel";
    8001095c:	00016797          	auipc	a5,0x16
    80010960:	23c78793          	addi	a5,a5,572 # 80026b98 <SYSCALLS+0xb68>
    80010964:	a831                	j	80010980 <elf_get_os_abi+0xd4>
    default:
        if (header.e_ident[EI_OSABI] >= 64) {
    80010966:	0074c783          	lbu	a5,7(s1)
    8001096a:	873e                	mv	a4,a5
    8001096c:	03f00793          	li	a5,63
    80010970:	00e7f763          	bgeu	a5,a4,8001097e <elf_get_os_abi+0xd2>
            return "Architecture-specific value";
    80010974:	00016797          	auipc	a5,0x16
    80010978:	23c78793          	addi	a5,a5,572 # 80026bb0 <SYSCALLS+0xb80>
    8001097c:	a011                	j	80010980 <elf_get_os_abi+0xd4>
        } else {
            return NULL;
    8001097e:	4781                	li	a5,0
        }
    }
}
    80010980:	853e                	mv	a0,a5
    80010982:	6422                	ld	s0,8(sp)
    80010984:	6482                	ld	s1,0(sp)
    80010986:	0141                	addi	sp,sp,16
    80010988:	8082                	ret

000000008001098a <elf_is_valid_header>:

bool elf_is_valid_header(Elf64_Ehdr header) {
    8001098a:	7159                	addi	sp,sp,-112
    8001098c:	f486                	sd	ra,104(sp)
    8001098e:	f0a2                	sd	s0,96(sp)
    80010990:	eca6                	sd	s1,88(sp)
    80010992:	1880                	addi	s0,sp,112
    80010994:	84aa                	mv	s1,a0
    // Confirm magic number
    if (header.e_ident[EI_MAG0] != 0x7f ||
    80010996:	0004c783          	lbu	a5,0(s1)
    8001099a:	873e                	mv	a4,a5
    8001099c:	07f00793          	li	a5,127
    800109a0:	02f71763          	bne	a4,a5,800109ce <elf_is_valid_header+0x44>
        header.e_ident[EI_MAG1] != 'E' ||
    800109a4:	0014c783          	lbu	a5,1(s1)
    if (header.e_ident[EI_MAG0] != 0x7f ||
    800109a8:	873e                	mv	a4,a5
    800109aa:	04500793          	li	a5,69
    800109ae:	02f71063          	bne	a4,a5,800109ce <elf_is_valid_header+0x44>
        header.e_ident[EI_MAG2] != 'L' ||
    800109b2:	0024c783          	lbu	a5,2(s1)
        header.e_ident[EI_MAG1] != 'E' ||
    800109b6:	873e                	mv	a4,a5
    800109b8:	04c00793          	li	a5,76
    800109bc:	00f71963          	bne	a4,a5,800109ce <elf_is_valid_header+0x44>
        header.e_ident[EI_MAG3] != 'F') {
    800109c0:	0034c783          	lbu	a5,3(s1)
        header.e_ident[EI_MAG2] != 'L' ||
    800109c4:	873e                	mv	a4,a5
    800109c6:	04600793          	li	a5,70
    800109ca:	00f70463          	beq	a4,a5,800109d2 <elf_is_valid_header+0x48>
        return false;
    800109ce:	4781                	li	a5,0
    800109d0:	a045                	j	80010a70 <elf_is_valid_header+0xe6>
    }

    // Confirm class is valid
    switch (header.e_ident[EI_CLASS]) {
    800109d2:	0044c783          	lbu	a5,4(s1)
    800109d6:	0007871b          	sext.w	a4,a5
    800109da:	86ba                	mv	a3,a4
    800109dc:	4785                	li	a5,1
    800109de:	00f68763          	beq	a3,a5,800109ec <elf_is_valid_header+0x62>
    800109e2:	4789                	li	a5,2
    800109e4:	00f70663          	beq	a4,a5,800109f0 <elf_is_valid_header+0x66>
        // 64-bit
        break;
    default:
        // Invalid class
        // debugf("Invalid class (%u)\n", header.e_ident[EI_CLASS]);
        return false;
    800109e8:	4781                	li	a5,0
    800109ea:	a059                	j	80010a70 <elf_is_valid_header+0xe6>
        break;
    800109ec:	0001                	nop
    800109ee:	a011                	j	800109f2 <elf_is_valid_header+0x68>
        break;
    800109f0:	0001                	nop
    }

    // Confirm data encoding is valid
    switch (header.e_ident[EI_DATA]) {
    800109f2:	0054c783          	lbu	a5,5(s1)
    800109f6:	0007871b          	sext.w	a4,a5
    800109fa:	86ba                	mv	a3,a4
    800109fc:	4785                	li	a5,1
    800109fe:	00f68763          	beq	a3,a5,80010a0c <elf_is_valid_header+0x82>
    80010a02:	4789                	li	a5,2
    80010a04:	00f70663          	beq	a4,a5,80010a10 <elf_is_valid_header+0x86>
        // Big endian
        break;
    default:
        // Invalid data encoding
        // debugf("Invalid data encoding (%u)\n", header.e_ident[EI_DATA]);
        return false;
    80010a08:	4781                	li	a5,0
    80010a0a:	a09d                	j	80010a70 <elf_is_valid_header+0xe6>
        break;
    80010a0c:	0001                	nop
    80010a0e:	a011                	j	80010a12 <elf_is_valid_header+0x88>
        break;
    80010a10:	0001                	nop
    }

    // Confirm version is valid
    if (header.e_ident[EI_VERSION] != 1) { // EV_CURRENT
    80010a12:	0064c783          	lbu	a5,6(s1)
    80010a16:	873e                	mv	a4,a5
    80010a18:	4785                	li	a5,1
    80010a1a:	00f70463          	beq	a4,a5,80010a22 <elf_is_valid_header+0x98>
        // debugf("Invalid version (0=EV_NONE)\n");
        return false;
    80010a1e:	4781                	li	a5,0
    80010a20:	a881                	j	80010a70 <elf_is_valid_header+0xe6>
    }

    // Check the OS ABI
    char *os_abi = elf_get_os_abi(header);
    80010a22:	0004b883          	ld	a7,0(s1)
    80010a26:	0084b803          	ld	a6,8(s1)
    80010a2a:	6888                	ld	a0,16(s1)
    80010a2c:	6c8c                	ld	a1,24(s1)
    80010a2e:	7090                	ld	a2,32(s1)
    80010a30:	7494                	ld	a3,40(s1)
    80010a32:	7898                	ld	a4,48(s1)
    80010a34:	7c9c                	ld	a5,56(s1)
    80010a36:	f9143823          	sd	a7,-112(s0)
    80010a3a:	f9043c23          	sd	a6,-104(s0)
    80010a3e:	faa43023          	sd	a0,-96(s0)
    80010a42:	fab43423          	sd	a1,-88(s0)
    80010a46:	fac43823          	sd	a2,-80(s0)
    80010a4a:	fad43c23          	sd	a3,-72(s0)
    80010a4e:	fce43023          	sd	a4,-64(s0)
    80010a52:	fcf43423          	sd	a5,-56(s0)
    80010a56:	f9040793          	addi	a5,s0,-112
    80010a5a:	853e                	mv	a0,a5
    80010a5c:	e51ff0ef          	jal	ra,800108ac <elf_get_os_abi>
    80010a60:	fca43c23          	sd	a0,-40(s0)
    if (!os_abi) {
    80010a64:	fd843783          	ld	a5,-40(s0)
    80010a68:	e399                	bnez	a5,80010a6e <elf_is_valid_header+0xe4>
        // debugf("Invalid OS ABI\n");
        return false;
    80010a6a:	4781                	li	a5,0
    80010a6c:	a011                	j	80010a70 <elf_is_valid_header+0xe6>
    }
    return true;
    80010a6e:	4785                	li	a5,1
}
    80010a70:	853e                	mv	a0,a5
    80010a72:	70a6                	ld	ra,104(sp)
    80010a74:	7406                	ld	s0,96(sp)
    80010a76:	64e6                	ld	s1,88(sp)
    80010a78:	6165                	addi	sp,sp,112
    80010a7a:	8082                	ret

0000000080010a7c <elf_is_valid_program_header>:

bool elf_is_valid_program_header(Elf64_Phdr header) {
    80010a7c:	1141                	addi	sp,sp,-16
    80010a7e:	e422                	sd	s0,8(sp)
    80010a80:	e026                	sd	s1,0(sp)
    80010a82:	0800                	addi	s0,sp,16
    80010a84:	84aa                	mv	s1,a0
    switch (header.p_type) {
    80010a86:	409c                	lw	a5,0(s1)
    80010a88:	86be                	mv	a3,a5
    80010a8a:	80000737          	lui	a4,0x80000
    80010a8e:	fff74713          	not	a4,a4
    80010a92:	0ce68463          	beq	a3,a4,80010b5a <elf_is_valid_program_header+0xde>
    80010a96:	86be                	mv	a3,a5
    80010a98:	80000737          	lui	a4,0x80000
    80010a9c:	fff74713          	not	a4,a4
    80010aa0:	08d76463          	bltu	a4,a3,80010b28 <elf_is_valid_program_header+0xac>
    80010aa4:	86be                	mv	a3,a5
    80010aa6:	70000737          	lui	a4,0x70000
    80010aaa:	0ae68a63          	beq	a3,a4,80010b5e <elf_is_valid_program_header+0xe2>
    80010aae:	86be                	mv	a3,a5
    80010ab0:	70000737          	lui	a4,0x70000
    80010ab4:	06d76a63          	bltu	a4,a3,80010b28 <elf_is_valid_program_header+0xac>
    80010ab8:	86be                	mv	a3,a5
    80010aba:	70000737          	lui	a4,0x70000
    80010abe:	177d                	addi	a4,a4,-1
    80010ac0:	0ae68163          	beq	a3,a4,80010b62 <elf_is_valid_program_header+0xe6>
    80010ac4:	86be                	mv	a3,a5
    80010ac6:	70000737          	lui	a4,0x70000
    80010aca:	04e6ff63          	bgeu	a3,a4,80010b28 <elf_is_valid_program_header+0xac>
    80010ace:	86be                	mv	a3,a5
    80010ad0:	471d                	li	a4,7
    80010ad2:	02d76663          	bltu	a4,a3,80010afe <elf_is_valid_program_header+0x82>
    80010ad6:	86be                	mv	a3,a5
    80010ad8:	471d                	li	a4,7
    80010ada:	04d76763          	bltu	a4,a3,80010b28 <elf_is_valid_program_header+0xac>
    80010ade:	00279713          	slli	a4,a5,0x2
    80010ae2:	00016797          	auipc	a5,0x16
    80010ae6:	12678793          	addi	a5,a5,294 # 80026c08 <SYSCALLS+0xbd8>
    80010aea:	97ba                	add	a5,a5,a4
    80010aec:	439c                	lw	a5,0(a5)
    80010aee:	0007871b          	sext.w	a4,a5
    80010af2:	00016797          	auipc	a5,0x16
    80010af6:	11678793          	addi	a5,a5,278 # 80026c08 <SYSCALLS+0xbd8>
    80010afa:	97ba                	add	a5,a5,a4
    80010afc:	8782                	jr	a5
    80010afe:	873e                	mv	a4,a5
    80010b00:	600007b7          	lui	a5,0x60000
    80010b04:	06f70363          	beq	a4,a5,80010b6a <elf_is_valid_program_header+0xee>
    80010b08:	a005                	j	80010b28 <elf_is_valid_program_header+0xac>
        // Unused entry
        break;
    case PT_LOAD:
        // Loadable segment
        // Confirm that the memsize is not zero
        if (header.p_memsz == 0) {
    80010b0a:	749c                	ld	a5,40(s1)
    80010b0c:	e399                	bnez	a5,80010b12 <elf_is_valid_program_header+0x96>
            // debugf("Invalid memsize\n");
            return false;
    80010b0e:	4781                	li	a5,0
    80010b10:	a08d                	j	80010b72 <elf_is_valid_program_header+0xf6>
        }

        // Confirm that the alignment is a power of 2
        if ((header.p_align & (header.p_align - 1)) != 0) {
    80010b12:	7898                	ld	a4,48(s1)
    80010b14:	789c                	ld	a5,48(s1)
    80010b16:	17fd                	addi	a5,a5,-1
    80010b18:	8ff9                	and	a5,a5,a4
    80010b1a:	c399                	beqz	a5,80010b20 <elf_is_valid_program_header+0xa4>
            // debugf("Invalid alignment\n");
            return false;
    80010b1c:	4781                	li	a5,0
    80010b1e:	a891                	j	80010b72 <elf_is_valid_program_header+0xf6>
        }

        // Confirm that the alignment is not zero
        if (header.p_align == 0) {
    80010b20:	789c                	ld	a5,48(s1)
    80010b22:	e7b1                	bnez	a5,80010b6e <elf_is_valid_program_header+0xf2>
            // debugf("Invalid alignment\n");
            return false;
    80010b24:	4781                	li	a5,0
    80010b26:	a0b1                	j	80010b72 <elf_is_valid_program_header+0xf6>
    case PT_HIPROC:
        // End of processor-specific
        break;

    default:
        if (header.p_type >= PT_LOOS && header.p_type <= PT_HIOS) {
    80010b28:	409c                	lw	a5,0(s1)
    80010b2a:	873e                	mv	a4,a5
    80010b2c:	600007b7          	lui	a5,0x60000
    80010b30:	00f76863          	bltu	a4,a5,80010b40 <elf_is_valid_program_header+0xc4>
    80010b34:	409c                	lw	a5,0(s1)
    80010b36:	873e                	mv	a4,a5
    80010b38:	700007b7          	lui	a5,0x70000
    80010b3c:	00f76e63          	bltu	a4,a5,80010b58 <elf_is_valid_program_header+0xdc>
            // debugf("OS-specific\n");
        } else if (header.p_type >= PT_LOPROC && header.p_type <= PT_HIPROC) {
    80010b40:	409c                	lw	a5,0(s1)
    80010b42:	873e                	mv	a4,a5
    80010b44:	700007b7          	lui	a5,0x70000
    80010b48:	00f76663          	bltu	a4,a5,80010b54 <elf_is_valid_program_header+0xd8>
    80010b4c:	409c                	lw	a5,0(s1)
    80010b4e:	2781                	sext.w	a5,a5
    80010b50:	0007d463          	bgez	a5,80010b58 <elf_is_valid_program_header+0xdc>
            // debugf("Processor-specific\n");
        } else {
            // debugf("(unrecognized/invalid)\n");
            return false;
    80010b54:	4781                	li	a5,0
    80010b56:	a831                	j	80010b72 <elf_is_valid_program_header+0xf6>
        }
        break;
    80010b58:	a821                	j	80010b70 <elf_is_valid_program_header+0xf4>
        break;
    80010b5a:	0001                	nop
    80010b5c:	a811                	j	80010b70 <elf_is_valid_program_header+0xf4>
        break;
    80010b5e:	0001                	nop
    80010b60:	a801                	j	80010b70 <elf_is_valid_program_header+0xf4>
        break;
    80010b62:	0001                	nop
    80010b64:	a031                	j	80010b70 <elf_is_valid_program_header+0xf4>
        break;
    80010b66:	0001                	nop
    80010b68:	a021                	j	80010b70 <elf_is_valid_program_header+0xf4>
        break;
    80010b6a:	0001                	nop
    80010b6c:	a011                	j	80010b70 <elf_is_valid_program_header+0xf4>
        break;
    80010b6e:	0001                	nop
    }
    return true;
    80010b70:	4785                	li	a5,1
}
    80010b72:	853e                	mv	a0,a5
    80010b74:	6422                	ld	s0,8(sp)
    80010b76:	6482                	ld	s1,0(sp)
    80010b78:	0141                	addi	sp,sp,16
    80010b7a:	8082                	ret

0000000080010b7c <elf_debug_header>:

void elf_debug_header(Elf64_Ehdr header) {
    80010b7c:	7119                	addi	sp,sp,-128
    80010b7e:	fc86                	sd	ra,120(sp)
    80010b80:	f8a2                	sd	s0,112(sp)
    80010b82:	f4a6                	sd	s1,104(sp)
    80010b84:	0100                	addi	s0,sp,128
    80010b86:	84aa                	mv	s1,a0
    if (!elf_is_valid_header(header)) {
    80010b88:	0004b883          	ld	a7,0(s1)
    80010b8c:	0084b803          	ld	a6,8(s1)
    80010b90:	6888                	ld	a0,16(s1)
    80010b92:	6c8c                	ld	a1,24(s1)
    80010b94:	7090                	ld	a2,32(s1)
    80010b96:	7494                	ld	a3,40(s1)
    80010b98:	7898                	ld	a4,48(s1)
    80010b9a:	7c9c                	ld	a5,56(s1)
    80010b9c:	f9143023          	sd	a7,-128(s0)
    80010ba0:	f9043423          	sd	a6,-120(s0)
    80010ba4:	f8a43823          	sd	a0,-112(s0)
    80010ba8:	f8b43c23          	sd	a1,-104(s0)
    80010bac:	fac43023          	sd	a2,-96(s0)
    80010bb0:	fad43423          	sd	a3,-88(s0)
    80010bb4:	fae43823          	sd	a4,-80(s0)
    80010bb8:	faf43c23          	sd	a5,-72(s0)
    80010bbc:	f8040793          	addi	a5,s0,-128
    80010bc0:	853e                	mv	a0,a5
    80010bc2:	dc9ff0ef          	jal	ra,8001098a <elf_is_valid_header>
    80010bc6:	87aa                	mv	a5,a0
    80010bc8:	0017c793          	xori	a5,a5,1
    80010bcc:	0ff7f793          	andi	a5,a5,255
    80010bd0:	1a079863          	bnez	a5,80010d80 <elf_debug_header+0x204>
        debugf("Invalid ELF header\n");
        return;
    }
    debugf("ELF Header:\n");
    debugf("   Magic:   ");
    for (int i = 0; i < EI_NIDENT; i++) {
    80010bd4:	fc042e23          	sw	zero,-36(s0)
    80010bd8:	a031                	j	80010be4 <elf_debug_header+0x68>
    80010bda:	fdc42783          	lw	a5,-36(s0)
    80010bde:	2785                	addiw	a5,a5,1
    80010be0:	fcf42e23          	sw	a5,-36(s0)
    80010be4:	fdc42783          	lw	a5,-36(s0)
    80010be8:	0007871b          	sext.w	a4,a5
    80010bec:	47bd                	li	a5,15
    80010bee:	fee7d6e3          	bge	a5,a4,80010bda <elf_debug_header+0x5e>
        debugf("%02x ", header.e_ident[i]);
    }
    debugf("(valid)\n");
    debugf("   Class:                              ");
    switch (header.e_ident[EI_CLASS]) {
    80010bf2:	0044c783          	lbu	a5,4(s1)
    80010bf6:	2781                	sext.w	a5,a5
    80010bf8:	86be                	mv	a3,a5
    80010bfa:	4709                	li	a4,2
    80010bfc:	00e68c63          	beq	a3,a4,80010c14 <elf_debug_header+0x98>
    80010c00:	86be                	mv	a3,a5
    80010c02:	4709                	li	a4,2
    80010c04:	00d74a63          	blt	a4,a3,80010c18 <elf_debug_header+0x9c>
    80010c08:	cb91                	beqz	a5,80010c1c <elf_debug_header+0xa0>
    80010c0a:	873e                	mv	a4,a5
    80010c0c:	4785                	li	a5,1
    80010c0e:	00f70963          	beq	a4,a5,80010c20 <elf_debug_header+0xa4>
    case 2:
        debugf("ELF 64-bit\n");
        break;
    default:
        debugf("(unrecognized/invalid)\n");
        break;
    80010c12:	a019                	j	80010c18 <elf_debug_header+0x9c>
        break;
    80010c14:	0001                	nop
    80010c16:	a031                	j	80010c22 <elf_debug_header+0xa6>
        break;
    80010c18:	0001                	nop
    80010c1a:	a021                	j	80010c22 <elf_debug_header+0xa6>
        break;
    80010c1c:	0001                	nop
    80010c1e:	a011                	j	80010c22 <elf_debug_header+0xa6>
        break;
    80010c20:	0001                	nop
    }
    debugf("   Data:                               ");
    switch (header.e_ident[EI_DATA]) {
    80010c22:	0054c783          	lbu	a5,5(s1)
    80010c26:	0007871b          	sext.w	a4,a5
    80010c2a:	86ba                	mv	a3,a4
    80010c2c:	4785                	li	a5,1
    80010c2e:	00f68663          	beq	a3,a5,80010c3a <elf_debug_header+0xbe>
    80010c32:	4789                	li	a5,2
    80010c34:	00f70563          	beq	a4,a5,80010c3e <elf_debug_header+0xc2>
    case 2:
        debugf("(big endian)\n");
        break;
    default:
        debugf("(invalid)\n");
        break;
    80010c38:	a021                	j	80010c40 <elf_debug_header+0xc4>
        break;
    80010c3a:	0001                	nop
    80010c3c:	a011                	j	80010c40 <elf_debug_header+0xc4>
        break;
    80010c3e:	0001                	nop
    }
    debugf("   Version:                            ");
    switch (header.e_ident[EI_VERSION]) {
    80010c40:	0064c783          	lbu	a5,6(s1)
    80010c44:	2781                	sext.w	a5,a5
    80010c46:	c791                	beqz	a5,80010c52 <elf_debug_header+0xd6>
    80010c48:	873e                	mv	a4,a5
    80010c4a:	4785                	li	a5,1
    80010c4c:	00f70563          	beq	a4,a5,80010c56 <elf_debug_header+0xda>
    case 1:
        debugf("(current)\n");
        break;
    default:
        debugf("(unrecognized/invalid)\n");
        break;
    80010c50:	a021                	j	80010c58 <elf_debug_header+0xdc>
        break;
    80010c52:	0001                	nop
    80010c54:	a011                	j	80010c58 <elf_debug_header+0xdc>
        break;
    80010c56:	0001                	nop
    }
    debugf("   OS/ABI:                             ");
    char *os_abi = elf_get_os_abi(header);
    80010c58:	0004b883          	ld	a7,0(s1)
    80010c5c:	0084b803          	ld	a6,8(s1)
    80010c60:	6888                	ld	a0,16(s1)
    80010c62:	6c8c                	ld	a1,24(s1)
    80010c64:	7090                	ld	a2,32(s1)
    80010c66:	7494                	ld	a3,40(s1)
    80010c68:	7898                	ld	a4,48(s1)
    80010c6a:	7c9c                	ld	a5,56(s1)
    80010c6c:	f9143023          	sd	a7,-128(s0)
    80010c70:	f9043423          	sd	a6,-120(s0)
    80010c74:	f8a43823          	sd	a0,-112(s0)
    80010c78:	f8b43c23          	sd	a1,-104(s0)
    80010c7c:	fac43023          	sd	a2,-96(s0)
    80010c80:	fad43423          	sd	a3,-88(s0)
    80010c84:	fae43823          	sd	a4,-80(s0)
    80010c88:	faf43c23          	sd	a5,-72(s0)
    80010c8c:	f8040793          	addi	a5,s0,-128
    80010c90:	853e                	mv	a0,a5
    80010c92:	c1bff0ef          	jal	ra,800108ac <elf_get_os_abi>
    80010c96:	fca43823          	sd	a0,-48(s0)
    } else {
        debugf("(invalid)\n");
    }
    debugf("   ABI Version:                        %u\n", header.e_ident[EI_ABIVERSION]);
    debugf("   Type:                               ");
    switch (header.e_type) {
    80010c9a:	0104d783          	lhu	a5,16(s1)
    80010c9e:	2781                	sext.w	a5,a5
    80010ca0:	86be                	mv	a3,a5
    80010ca2:	6741                	lui	a4,0x10
    80010ca4:	177d                	addi	a4,a4,-1
    80010ca6:	08e68063          	beq	a3,a4,80010d26 <elf_debug_header+0x1aa>
    80010caa:	86be                	mv	a3,a5
    80010cac:	6741                	lui	a4,0x10
    80010cae:	06e6de63          	bge	a3,a4,80010d2a <elf_debug_header+0x1ae>
    80010cb2:	86be                	mv	a3,a5
    80010cb4:	6741                	lui	a4,0x10
    80010cb6:	f0070713          	addi	a4,a4,-256 # ff00 <i+0xfee0>
    80010cba:	06e68a63          	beq	a3,a4,80010d2e <elf_debug_header+0x1b2>
    80010cbe:	86be                	mv	a3,a5
    80010cc0:	6741                	lui	a4,0x10
    80010cc2:	f0070713          	addi	a4,a4,-256 # ff00 <i+0xfee0>
    80010cc6:	06d74263          	blt	a4,a3,80010d2a <elf_debug_header+0x1ae>
    80010cca:	86be                	mv	a3,a5
    80010ccc:	6741                	lui	a4,0x10
    80010cce:	eff70713          	addi	a4,a4,-257 # feff <i+0xfedf>
    80010cd2:	06e68063          	beq	a3,a4,80010d32 <elf_debug_header+0x1b6>
    80010cd6:	86be                	mv	a3,a5
    80010cd8:	6741                	lui	a4,0x10
    80010cda:	eff70713          	addi	a4,a4,-257 # feff <i+0xfedf>
    80010cde:	04d74663          	blt	a4,a3,80010d2a <elf_debug_header+0x1ae>
    80010ce2:	86be                	mv	a3,a5
    80010ce4:	4711                	li	a4,4
    80010ce6:	02d74963          	blt	a4,a3,80010d18 <elf_debug_header+0x19c>
    80010cea:	873e                	mv	a4,a5
    80010cec:	02074f63          	bltz	a4,80010d2a <elf_debug_header+0x1ae>
    80010cf0:	86be                	mv	a3,a5
    80010cf2:	4711                	li	a4,4
    80010cf4:	02d76b63          	bltu	a4,a3,80010d2a <elf_debug_header+0x1ae>
    80010cf8:	00279713          	slli	a4,a5,0x2
    80010cfc:	00016797          	auipc	a5,0x16
    80010d00:	f2c78793          	addi	a5,a5,-212 # 80026c28 <SYSCALLS+0xbf8>
    80010d04:	97ba                	add	a5,a5,a4
    80010d06:	439c                	lw	a5,0(a5)
    80010d08:	0007871b          	sext.w	a4,a5
    80010d0c:	00016797          	auipc	a5,0x16
    80010d10:	f1c78793          	addi	a5,a5,-228 # 80026c28 <SYSCALLS+0xbf8>
    80010d14:	97ba                	add	a5,a5,a4
    80010d16:	8782                	jr	a5
    80010d18:	873e                	mv	a4,a5
    80010d1a:	67c1                	lui	a5,0x10
    80010d1c:	e0078793          	addi	a5,a5,-512 # fe00 <i+0xfde0>
    80010d20:	00f70d63          	beq	a4,a5,80010d3a <elf_debug_header+0x1be>
    case ET_HIPROC:
        debugf("Processor-specific (HIPROC)\n");
        break;
    default:
        debugf("(unrecognized/invalid)\n");
        break;
    80010d24:	a019                	j	80010d2a <elf_debug_header+0x1ae>
        break;
    80010d26:	0001                	nop
    80010d28:	a811                	j	80010d3c <elf_debug_header+0x1c0>
        break;
    80010d2a:	0001                	nop
    80010d2c:	a801                	j	80010d3c <elf_debug_header+0x1c0>
        break;
    80010d2e:	0001                	nop
    80010d30:	a031                	j	80010d3c <elf_debug_header+0x1c0>
        break;
    80010d32:	0001                	nop
    80010d34:	a021                	j	80010d3c <elf_debug_header+0x1c0>
        break;
    80010d36:	0001                	nop
    80010d38:	a011                	j	80010d3c <elf_debug_header+0x1c0>
        break;
    80010d3a:	0001                	nop
    }

    debugf("   Machine:                            ");
    char *machine_name = elf_get_machine_name(header);
    80010d3c:	0004b883          	ld	a7,0(s1)
    80010d40:	0084b803          	ld	a6,8(s1)
    80010d44:	6888                	ld	a0,16(s1)
    80010d46:	6c8c                	ld	a1,24(s1)
    80010d48:	7090                	ld	a2,32(s1)
    80010d4a:	7494                	ld	a3,40(s1)
    80010d4c:	7898                	ld	a4,48(s1)
    80010d4e:	7c9c                	ld	a5,56(s1)
    80010d50:	f9143023          	sd	a7,-128(s0)
    80010d54:	f9043423          	sd	a6,-120(s0)
    80010d58:	f8a43823          	sd	a0,-112(s0)
    80010d5c:	f8b43c23          	sd	a1,-104(s0)
    80010d60:	fac43023          	sd	a2,-96(s0)
    80010d64:	fad43423          	sd	a3,-88(s0)
    80010d68:	fae43823          	sd	a4,-80(s0)
    80010d6c:	faf43c23          	sd	a5,-72(s0)
    80010d70:	f8040793          	addi	a5,s0,-128
    80010d74:	853e                	mv	a0,a5
    80010d76:	f94ff0ef          	jal	ra,8001050a <elf_get_machine_name>
    80010d7a:	fca43423          	sd	a0,-56(s0)
    80010d7e:	a011                	j	80010d82 <elf_debug_header+0x206>
        return;
    80010d80:	0001                	nop
    debugf("   Size of program headers:            %u\n", header.e_phentsize);
    debugf("   Number of program headers:          %u\n", header.e_phnum);
    debugf("   Size of section headers:            %u\n", header.e_shentsize);
    debugf("   Number of section headers:          %u\n", header.e_shnum);
    debugf("   Section header string table index:  %u\n", header.e_shstrndx);
}
    80010d82:	70e6                	ld	ra,120(sp)
    80010d84:	7446                	ld	s0,112(sp)
    80010d86:	74a6                	ld	s1,104(sp)
    80010d88:	6109                	addi	sp,sp,128
    80010d8a:	8082                	ret

0000000080010d8c <elf_debug_program_header>:

void elf_debug_program_header(Elf64_Phdr header) {
    80010d8c:	1141                	addi	sp,sp,-16
    80010d8e:	e422                	sd	s0,8(sp)
    80010d90:	e026                	sd	s1,0(sp)
    80010d92:	0800                	addi	s0,sp,16
    80010d94:	84aa                	mv	s1,a0
    debugf("Program Header:\n");
    // debugf("   Type:             0x%x\n", header.p_type);
    debugf("   Type:             ");
    switch (header.p_type) {
    80010d96:	409c                	lw	a5,0(s1)
    80010d98:	86be                	mv	a3,a5
    80010d9a:	80000737          	lui	a4,0x80000
    80010d9e:	fff74713          	not	a4,a4
    80010da2:	08e68663          	beq	a3,a4,80010e2e <elf_debug_program_header+0xa2>
    80010da6:	86be                	mv	a3,a5
    80010da8:	80000737          	lui	a4,0x80000
    80010dac:	fff74713          	not	a4,a4
    80010db0:	06d76463          	bltu	a4,a3,80010e18 <elf_debug_program_header+0x8c>
    80010db4:	86be                	mv	a3,a5
    80010db6:	70000737          	lui	a4,0x70000
    80010dba:	06e68c63          	beq	a3,a4,80010e32 <elf_debug_program_header+0xa6>
    80010dbe:	86be                	mv	a3,a5
    80010dc0:	70000737          	lui	a4,0x70000
    80010dc4:	04d76a63          	bltu	a4,a3,80010e18 <elf_debug_program_header+0x8c>
    80010dc8:	86be                	mv	a3,a5
    80010dca:	70000737          	lui	a4,0x70000
    80010dce:	177d                	addi	a4,a4,-1
    80010dd0:	06e68363          	beq	a3,a4,80010e36 <elf_debug_program_header+0xaa>
    80010dd4:	86be                	mv	a3,a5
    80010dd6:	70000737          	lui	a4,0x70000
    80010dda:	02e6ff63          	bgeu	a3,a4,80010e18 <elf_debug_program_header+0x8c>
    80010dde:	86be                	mv	a3,a5
    80010de0:	471d                	li	a4,7
    80010de2:	02d76663          	bltu	a4,a3,80010e0e <elf_debug_program_header+0x82>
    80010de6:	86be                	mv	a3,a5
    80010de8:	471d                	li	a4,7
    80010dea:	02d76763          	bltu	a4,a3,80010e18 <elf_debug_program_header+0x8c>
    80010dee:	00279713          	slli	a4,a5,0x2
    80010df2:	00016797          	auipc	a5,0x16
    80010df6:	e4a78793          	addi	a5,a5,-438 # 80026c3c <SYSCALLS+0xc0c>
    80010dfa:	97ba                	add	a5,a5,a4
    80010dfc:	439c                	lw	a5,0(a5)
    80010dfe:	0007871b          	sext.w	a4,a5
    80010e02:	00016797          	auipc	a5,0x16
    80010e06:	e3a78793          	addi	a5,a5,-454 # 80026c3c <SYSCALLS+0xc0c>
    80010e0a:	97ba                	add	a5,a5,a4
    80010e0c:	8782                	jr	a5
    80010e0e:	873e                	mv	a4,a5
    80010e10:	600007b7          	lui	a5,0x60000
    80010e14:	02f70563          	beq	a4,a5,80010e3e <elf_debug_program_header+0xb2>
        break;
    case PT_HIPROC:
        debugf("End of processor-specific\n");
        break;
    default:
        if (header.p_type >= PT_LOOS && header.p_type <= PT_HIOS) {
    80010e18:	409c                	lw	a5,0(s1)
    80010e1a:	873e                	mv	a4,a5
    80010e1c:	600007b7          	lui	a5,0x60000
    80010e20:	02f76163          	bltu	a4,a5,80010e42 <elf_debug_program_header+0xb6>
    80010e24:	409c                	lw	a5,0(s1)
    80010e26:	873e                	mv	a4,a5
    80010e28:	700007b7          	lui	a5,0x70000
    80010e2c:	a819                	j	80010e42 <elf_debug_program_header+0xb6>
        break;
    80010e2e:	0001                	nop
    80010e30:	a811                	j	80010e44 <elf_debug_program_header+0xb8>
        break;
    80010e32:	0001                	nop
    80010e34:	a801                	j	80010e44 <elf_debug_program_header+0xb8>
        break;
    80010e36:	0001                	nop
    80010e38:	a031                	j	80010e44 <elf_debug_program_header+0xb8>
        break;
    80010e3a:	0001                	nop
    80010e3c:	a021                	j	80010e44 <elf_debug_program_header+0xb8>
        break;
    80010e3e:	0001                	nop
    80010e40:	a011                	j	80010e44 <elf_debug_program_header+0xb8>
        } else if (header.p_type >= PT_LOPROC && header.p_type <= PT_HIPROC) {
            debugf("Processor-specific\n");
        } else {
            debugf("(unrecognized/invalid)\n");
        }
        break;
    80010e42:	0001                	nop
    debugf("   Virtual Address:  0x%lx\n", header.p_vaddr);
    debugf("   Physical Address: 0x%lx\n", header.p_paddr);
    debugf("   File Size:        0x%lx\n", header.p_filesz);
    debugf("   Memory Size:      0x%lx\n", header.p_memsz);
    debugf("   Alignment:        0x%lx\n", header.p_align);
}
    80010e44:	0001                	nop
    80010e46:	6422                	ld	s0,8(sp)
    80010e48:	6482                	ld	s1,0(sp)
    80010e4a:	0141                	addi	sp,sp,16
    80010e4c:	8082                	ret

0000000080010e4e <elf_get_text_section>:


Elf64_Phdr elf_get_text_section(Elf64_Ehdr elf_header, Elf64_Phdr *program_headers) {
    80010e4e:	7179                	addi	sp,sp,-48
    80010e50:	f422                	sd	s0,40(sp)
    80010e52:	f026                	sd	s1,32(sp)
    80010e54:	1800                	addi	s0,sp,48
    80010e56:	fca43c23          	sd	a0,-40(s0)
    80010e5a:	84ae                	mv	s1,a1
    80010e5c:	fcc43823          	sd	a2,-48(s0)
    // Find the `text` header
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    80010e60:	fe042623          	sw	zero,-20(s0)
    80010e64:	a051                	j	80010ee8 <elf_get_text_section+0x9a>
        if (program_headers[i].p_type == PT_LOAD && program_headers[i].p_flags & PF_X) {
    80010e66:	fec46703          	lwu	a4,-20(s0)
    80010e6a:	87ba                	mv	a5,a4
    80010e6c:	078e                	slli	a5,a5,0x3
    80010e6e:	8f99                	sub	a5,a5,a4
    80010e70:	078e                	slli	a5,a5,0x3
    80010e72:	873e                	mv	a4,a5
    80010e74:	fd043783          	ld	a5,-48(s0)
    80010e78:	97ba                	add	a5,a5,a4
    80010e7a:	439c                	lw	a5,0(a5)
    80010e7c:	873e                	mv	a4,a5
    80010e7e:	4785                	li	a5,1
    80010e80:	04f71f63          	bne	a4,a5,80010ede <elf_get_text_section+0x90>
    80010e84:	fec46703          	lwu	a4,-20(s0)
    80010e88:	87ba                	mv	a5,a4
    80010e8a:	078e                	slli	a5,a5,0x3
    80010e8c:	8f99                	sub	a5,a5,a4
    80010e8e:	078e                	slli	a5,a5,0x3
    80010e90:	873e                	mv	a4,a5
    80010e92:	fd043783          	ld	a5,-48(s0)
    80010e96:	97ba                	add	a5,a5,a4
    80010e98:	43dc                	lw	a5,4(a5)
    80010e9a:	8b85                	andi	a5,a5,1
    80010e9c:	2781                	sext.w	a5,a5
    80010e9e:	c3a1                	beqz	a5,80010ede <elf_get_text_section+0x90>
            return program_headers[i];
    80010ea0:	fec46703          	lwu	a4,-20(s0)
    80010ea4:	87ba                	mv	a5,a4
    80010ea6:	078e                	slli	a5,a5,0x3
    80010ea8:	8f99                	sub	a5,a5,a4
    80010eaa:	078e                	slli	a5,a5,0x3
    80010eac:	873e                	mv	a4,a5
    80010eae:	fd043783          	ld	a5,-48(s0)
    80010eb2:	973e                	add	a4,a4,a5
    80010eb4:	fd843783          	ld	a5,-40(s0)
    80010eb8:	00073883          	ld	a7,0(a4) # 70000000 <i+0x6fffffe0>
    80010ebc:	00873803          	ld	a6,8(a4)
    80010ec0:	6b08                	ld	a0,16(a4)
    80010ec2:	6f0c                	ld	a1,24(a4)
    80010ec4:	7310                	ld	a2,32(a4)
    80010ec6:	7714                	ld	a3,40(a4)
    80010ec8:	7b18                	ld	a4,48(a4)
    80010eca:	0117b023          	sd	a7,0(a5) # 70000000 <i+0x6fffffe0>
    80010ece:	0107b423          	sd	a6,8(a5)
    80010ed2:	eb88                	sd	a0,16(a5)
    80010ed4:	ef8c                	sd	a1,24(a5)
    80010ed6:	f390                	sd	a2,32(a5)
    80010ed8:	f794                	sd	a3,40(a5)
    80010eda:	fb98                	sd	a4,48(a5)
    80010edc:	a005                	j	80010efc <elf_get_text_section+0xae>
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    80010ede:	fec42783          	lw	a5,-20(s0)
    80010ee2:	2785                	addiw	a5,a5,1
    80010ee4:	fef42623          	sw	a5,-20(s0)
    80010ee8:	0384d783          	lhu	a5,56(s1)
    80010eec:	0007871b          	sext.w	a4,a5
    80010ef0:	fec42783          	lw	a5,-20(s0)
    80010ef4:	2781                	sext.w	a5,a5
    80010ef6:	f6e7e8e3          	bltu	a5,a4,80010e66 <elf_get_text_section+0x18>
        }
    }
}
    80010efa:	0001                	nop
    80010efc:	fd843503          	ld	a0,-40(s0)
    80010f00:	7422                	ld	s0,40(sp)
    80010f02:	7482                	ld	s1,32(sp)
    80010f04:	6145                	addi	sp,sp,48
    80010f06:	8082                	ret

0000000080010f08 <elf_get_bss_section>:

Elf64_Phdr elf_get_bss_section(Elf64_Ehdr elf_header, Elf64_Phdr *program_headers) {
    80010f08:	7179                	addi	sp,sp,-48
    80010f0a:	f422                	sd	s0,40(sp)
    80010f0c:	f026                	sd	s1,32(sp)
    80010f0e:	1800                	addi	s0,sp,48
    80010f10:	fca43c23          	sd	a0,-40(s0)
    80010f14:	84ae                	mv	s1,a1
    80010f16:	fcc43823          	sd	a2,-48(s0)
    // Find the `bss` header
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    80010f1a:	fe042623          	sw	zero,-20(s0)
    80010f1e:	a051                	j	80010fa2 <elf_get_bss_section+0x9a>
        if (program_headers[i].p_type == PT_LOAD && program_headers[i].p_flags & PF_W) {
    80010f20:	fec46703          	lwu	a4,-20(s0)
    80010f24:	87ba                	mv	a5,a4
    80010f26:	078e                	slli	a5,a5,0x3
    80010f28:	8f99                	sub	a5,a5,a4
    80010f2a:	078e                	slli	a5,a5,0x3
    80010f2c:	873e                	mv	a4,a5
    80010f2e:	fd043783          	ld	a5,-48(s0)
    80010f32:	97ba                	add	a5,a5,a4
    80010f34:	439c                	lw	a5,0(a5)
    80010f36:	873e                	mv	a4,a5
    80010f38:	4785                	li	a5,1
    80010f3a:	04f71f63          	bne	a4,a5,80010f98 <elf_get_bss_section+0x90>
    80010f3e:	fec46703          	lwu	a4,-20(s0)
    80010f42:	87ba                	mv	a5,a4
    80010f44:	078e                	slli	a5,a5,0x3
    80010f46:	8f99                	sub	a5,a5,a4
    80010f48:	078e                	slli	a5,a5,0x3
    80010f4a:	873e                	mv	a4,a5
    80010f4c:	fd043783          	ld	a5,-48(s0)
    80010f50:	97ba                	add	a5,a5,a4
    80010f52:	43dc                	lw	a5,4(a5)
    80010f54:	8b89                	andi	a5,a5,2
    80010f56:	2781                	sext.w	a5,a5
    80010f58:	c3a1                	beqz	a5,80010f98 <elf_get_bss_section+0x90>
            return program_headers[i];
    80010f5a:	fec46703          	lwu	a4,-20(s0)
    80010f5e:	87ba                	mv	a5,a4
    80010f60:	078e                	slli	a5,a5,0x3
    80010f62:	8f99                	sub	a5,a5,a4
    80010f64:	078e                	slli	a5,a5,0x3
    80010f66:	873e                	mv	a4,a5
    80010f68:	fd043783          	ld	a5,-48(s0)
    80010f6c:	973e                	add	a4,a4,a5
    80010f6e:	fd843783          	ld	a5,-40(s0)
    80010f72:	00073883          	ld	a7,0(a4)
    80010f76:	00873803          	ld	a6,8(a4)
    80010f7a:	6b08                	ld	a0,16(a4)
    80010f7c:	6f0c                	ld	a1,24(a4)
    80010f7e:	7310                	ld	a2,32(a4)
    80010f80:	7714                	ld	a3,40(a4)
    80010f82:	7b18                	ld	a4,48(a4)
    80010f84:	0117b023          	sd	a7,0(a5)
    80010f88:	0107b423          	sd	a6,8(a5)
    80010f8c:	eb88                	sd	a0,16(a5)
    80010f8e:	ef8c                	sd	a1,24(a5)
    80010f90:	f390                	sd	a2,32(a5)
    80010f92:	f794                	sd	a3,40(a5)
    80010f94:	fb98                	sd	a4,48(a5)
    80010f96:	a005                	j	80010fb6 <elf_get_bss_section+0xae>
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    80010f98:	fec42783          	lw	a5,-20(s0)
    80010f9c:	2785                	addiw	a5,a5,1
    80010f9e:	fef42623          	sw	a5,-20(s0)
    80010fa2:	0384d783          	lhu	a5,56(s1)
    80010fa6:	0007871b          	sext.w	a4,a5
    80010faa:	fec42783          	lw	a5,-20(s0)
    80010fae:	2781                	sext.w	a5,a5
    80010fb0:	f6e7e8e3          	bltu	a5,a4,80010f20 <elf_get_bss_section+0x18>
        }
    }
}
    80010fb4:	0001                	nop
    80010fb6:	fd843503          	ld	a0,-40(s0)
    80010fba:	7422                	ld	s0,40(sp)
    80010fbc:	7482                	ld	s1,32(sp)
    80010fbe:	6145                	addi	sp,sp,48
    80010fc0:	8082                	ret

0000000080010fc2 <elf_get_data_section>:

Elf64_Phdr elf_get_data_section(Elf64_Ehdr elf_header, Elf64_Phdr *program_headers) {
    80010fc2:	7179                	addi	sp,sp,-48
    80010fc4:	f422                	sd	s0,40(sp)
    80010fc6:	f026                	sd	s1,32(sp)
    80010fc8:	1800                	addi	s0,sp,48
    80010fca:	fca43c23          	sd	a0,-40(s0)
    80010fce:	84ae                	mv	s1,a1
    80010fd0:	fcc43823          	sd	a2,-48(s0)
    // Find the `data` header
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    80010fd4:	fe042623          	sw	zero,-20(s0)
    80010fd8:	a045                	j	80011078 <elf_get_data_section+0xb6>
        if (program_headers[i].p_type == PT_LOAD && program_headers[i].p_flags & PF_W && !(program_headers[i].p_flags & PF_X)) {
    80010fda:	fec46703          	lwu	a4,-20(s0)
    80010fde:	87ba                	mv	a5,a4
    80010fe0:	078e                	slli	a5,a5,0x3
    80010fe2:	8f99                	sub	a5,a5,a4
    80010fe4:	078e                	slli	a5,a5,0x3
    80010fe6:	873e                	mv	a4,a5
    80010fe8:	fd043783          	ld	a5,-48(s0)
    80010fec:	97ba                	add	a5,a5,a4
    80010fee:	439c                	lw	a5,0(a5)
    80010ff0:	873e                	mv	a4,a5
    80010ff2:	4785                	li	a5,1
    80010ff4:	06f71d63          	bne	a4,a5,8001106e <elf_get_data_section+0xac>
    80010ff8:	fec46703          	lwu	a4,-20(s0)
    80010ffc:	87ba                	mv	a5,a4
    80010ffe:	078e                	slli	a5,a5,0x3
    80011000:	8f99                	sub	a5,a5,a4
    80011002:	078e                	slli	a5,a5,0x3
    80011004:	873e                	mv	a4,a5
    80011006:	fd043783          	ld	a5,-48(s0)
    8001100a:	97ba                	add	a5,a5,a4
    8001100c:	43dc                	lw	a5,4(a5)
    8001100e:	8b89                	andi	a5,a5,2
    80011010:	2781                	sext.w	a5,a5
    80011012:	cfb1                	beqz	a5,8001106e <elf_get_data_section+0xac>
    80011014:	fec46703          	lwu	a4,-20(s0)
    80011018:	87ba                	mv	a5,a4
    8001101a:	078e                	slli	a5,a5,0x3
    8001101c:	8f99                	sub	a5,a5,a4
    8001101e:	078e                	slli	a5,a5,0x3
    80011020:	873e                	mv	a4,a5
    80011022:	fd043783          	ld	a5,-48(s0)
    80011026:	97ba                	add	a5,a5,a4
    80011028:	43dc                	lw	a5,4(a5)
    8001102a:	8b85                	andi	a5,a5,1
    8001102c:	2781                	sext.w	a5,a5
    8001102e:	e3a1                	bnez	a5,8001106e <elf_get_data_section+0xac>
            return program_headers[i];
    80011030:	fec46703          	lwu	a4,-20(s0)
    80011034:	87ba                	mv	a5,a4
    80011036:	078e                	slli	a5,a5,0x3
    80011038:	8f99                	sub	a5,a5,a4
    8001103a:	078e                	slli	a5,a5,0x3
    8001103c:	873e                	mv	a4,a5
    8001103e:	fd043783          	ld	a5,-48(s0)
    80011042:	973e                	add	a4,a4,a5
    80011044:	fd843783          	ld	a5,-40(s0)
    80011048:	00073883          	ld	a7,0(a4)
    8001104c:	00873803          	ld	a6,8(a4)
    80011050:	6b08                	ld	a0,16(a4)
    80011052:	6f0c                	ld	a1,24(a4)
    80011054:	7310                	ld	a2,32(a4)
    80011056:	7714                	ld	a3,40(a4)
    80011058:	7b18                	ld	a4,48(a4)
    8001105a:	0117b023          	sd	a7,0(a5)
    8001105e:	0107b423          	sd	a6,8(a5)
    80011062:	eb88                	sd	a0,16(a5)
    80011064:	ef8c                	sd	a1,24(a5)
    80011066:	f390                	sd	a2,32(a5)
    80011068:	f794                	sd	a3,40(a5)
    8001106a:	fb98                	sd	a4,48(a5)
    8001106c:	a005                	j	8001108c <elf_get_data_section+0xca>
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    8001106e:	fec42783          	lw	a5,-20(s0)
    80011072:	2785                	addiw	a5,a5,1
    80011074:	fef42623          	sw	a5,-20(s0)
    80011078:	0384d783          	lhu	a5,56(s1)
    8001107c:	0007871b          	sext.w	a4,a5
    80011080:	fec42783          	lw	a5,-20(s0)
    80011084:	2781                	sext.w	a5,a5
    80011086:	f4e7eae3          	bltu	a5,a4,80010fda <elf_get_data_section+0x18>
        }
    }
}
    8001108a:	0001                	nop
    8001108c:	fd843503          	ld	a0,-40(s0)
    80011090:	7422                	ld	s0,40(sp)
    80011092:	7482                	ld	s1,32(sp)
    80011094:	6145                	addi	sp,sp,48
    80011096:	8082                	ret

0000000080011098 <elf_get_rodata_section>:

Elf64_Phdr elf_get_rodata_section(Elf64_Ehdr elf_header, Elf64_Phdr *program_headers) {
    80011098:	7179                	addi	sp,sp,-48
    8001109a:	f422                	sd	s0,40(sp)
    8001109c:	f026                	sd	s1,32(sp)
    8001109e:	1800                	addi	s0,sp,48
    800110a0:	fca43c23          	sd	a0,-40(s0)
    800110a4:	84ae                	mv	s1,a1
    800110a6:	fcc43823          	sd	a2,-48(s0)
    // Find the `rodata` header
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    800110aa:	fe042623          	sw	zero,-20(s0)
    800110ae:	a045                	j	8001114e <elf_get_rodata_section+0xb6>
        if (program_headers[i].p_type == PT_LOAD && !(program_headers[i].p_flags & PF_W) && !(program_headers[i].p_flags & PF_X)) {
    800110b0:	fec46703          	lwu	a4,-20(s0)
    800110b4:	87ba                	mv	a5,a4
    800110b6:	078e                	slli	a5,a5,0x3
    800110b8:	8f99                	sub	a5,a5,a4
    800110ba:	078e                	slli	a5,a5,0x3
    800110bc:	873e                	mv	a4,a5
    800110be:	fd043783          	ld	a5,-48(s0)
    800110c2:	97ba                	add	a5,a5,a4
    800110c4:	439c                	lw	a5,0(a5)
    800110c6:	873e                	mv	a4,a5
    800110c8:	4785                	li	a5,1
    800110ca:	06f71d63          	bne	a4,a5,80011144 <elf_get_rodata_section+0xac>
    800110ce:	fec46703          	lwu	a4,-20(s0)
    800110d2:	87ba                	mv	a5,a4
    800110d4:	078e                	slli	a5,a5,0x3
    800110d6:	8f99                	sub	a5,a5,a4
    800110d8:	078e                	slli	a5,a5,0x3
    800110da:	873e                	mv	a4,a5
    800110dc:	fd043783          	ld	a5,-48(s0)
    800110e0:	97ba                	add	a5,a5,a4
    800110e2:	43dc                	lw	a5,4(a5)
    800110e4:	8b89                	andi	a5,a5,2
    800110e6:	2781                	sext.w	a5,a5
    800110e8:	efb1                	bnez	a5,80011144 <elf_get_rodata_section+0xac>
    800110ea:	fec46703          	lwu	a4,-20(s0)
    800110ee:	87ba                	mv	a5,a4
    800110f0:	078e                	slli	a5,a5,0x3
    800110f2:	8f99                	sub	a5,a5,a4
    800110f4:	078e                	slli	a5,a5,0x3
    800110f6:	873e                	mv	a4,a5
    800110f8:	fd043783          	ld	a5,-48(s0)
    800110fc:	97ba                	add	a5,a5,a4
    800110fe:	43dc                	lw	a5,4(a5)
    80011100:	8b85                	andi	a5,a5,1
    80011102:	2781                	sext.w	a5,a5
    80011104:	e3a1                	bnez	a5,80011144 <elf_get_rodata_section+0xac>
            return program_headers[i];
    80011106:	fec46703          	lwu	a4,-20(s0)
    8001110a:	87ba                	mv	a5,a4
    8001110c:	078e                	slli	a5,a5,0x3
    8001110e:	8f99                	sub	a5,a5,a4
    80011110:	078e                	slli	a5,a5,0x3
    80011112:	873e                	mv	a4,a5
    80011114:	fd043783          	ld	a5,-48(s0)
    80011118:	973e                	add	a4,a4,a5
    8001111a:	fd843783          	ld	a5,-40(s0)
    8001111e:	00073883          	ld	a7,0(a4)
    80011122:	00873803          	ld	a6,8(a4)
    80011126:	6b08                	ld	a0,16(a4)
    80011128:	6f0c                	ld	a1,24(a4)
    8001112a:	7310                	ld	a2,32(a4)
    8001112c:	7714                	ld	a3,40(a4)
    8001112e:	7b18                	ld	a4,48(a4)
    80011130:	0117b023          	sd	a7,0(a5)
    80011134:	0107b423          	sd	a6,8(a5)
    80011138:	eb88                	sd	a0,16(a5)
    8001113a:	ef8c                	sd	a1,24(a5)
    8001113c:	f390                	sd	a2,32(a5)
    8001113e:	f794                	sd	a3,40(a5)
    80011140:	fb98                	sd	a4,48(a5)
    80011142:	a005                	j	80011162 <elf_get_rodata_section+0xca>
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    80011144:	fec42783          	lw	a5,-20(s0)
    80011148:	2785                	addiw	a5,a5,1
    8001114a:	fef42623          	sw	a5,-20(s0)
    8001114e:	0384d783          	lhu	a5,56(s1)
    80011152:	0007871b          	sext.w	a4,a5
    80011156:	fec42783          	lw	a5,-20(s0)
    8001115a:	2781                	sext.w	a5,a5
    8001115c:	f4e7eae3          	bltu	a5,a4,800110b0 <elf_get_rodata_section+0x18>
        }
    }
}
    80011160:	0001                	nop
    80011162:	fd843503          	ld	a0,-40(s0)
    80011166:	7422                	ld	s0,40(sp)
    80011168:	7482                	ld	s1,32(sp)
    8001116a:	6145                	addi	sp,sp,48
    8001116c:	8082                	ret

000000008001116e <elf_get_dynamic_section>:

Elf64_Phdr elf_get_dynamic_section(Elf64_Ehdr elf_header, Elf64_Phdr *program_headers) {
    8001116e:	7179                	addi	sp,sp,-48
    80011170:	f422                	sd	s0,40(sp)
    80011172:	f026                	sd	s1,32(sp)
    80011174:	1800                	addi	s0,sp,48
    80011176:	fca43c23          	sd	a0,-40(s0)
    8001117a:	84ae                	mv	s1,a1
    8001117c:	fcc43823          	sd	a2,-48(s0)
    // Find the `dynamic` header
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    80011180:	fe042623          	sw	zero,-20(s0)
    80011184:	a0a5                	j	800111ec <elf_get_dynamic_section+0x7e>
        if (program_headers[i].p_type == PT_DYNAMIC) {
    80011186:	fec46703          	lwu	a4,-20(s0)
    8001118a:	87ba                	mv	a5,a4
    8001118c:	078e                	slli	a5,a5,0x3
    8001118e:	8f99                	sub	a5,a5,a4
    80011190:	078e                	slli	a5,a5,0x3
    80011192:	873e                	mv	a4,a5
    80011194:	fd043783          	ld	a5,-48(s0)
    80011198:	97ba                	add	a5,a5,a4
    8001119a:	439c                	lw	a5,0(a5)
    8001119c:	873e                	mv	a4,a5
    8001119e:	4789                	li	a5,2
    800111a0:	04f71163          	bne	a4,a5,800111e2 <elf_get_dynamic_section+0x74>
            return program_headers[i];
    800111a4:	fec46703          	lwu	a4,-20(s0)
    800111a8:	87ba                	mv	a5,a4
    800111aa:	078e                	slli	a5,a5,0x3
    800111ac:	8f99                	sub	a5,a5,a4
    800111ae:	078e                	slli	a5,a5,0x3
    800111b0:	873e                	mv	a4,a5
    800111b2:	fd043783          	ld	a5,-48(s0)
    800111b6:	973e                	add	a4,a4,a5
    800111b8:	fd843783          	ld	a5,-40(s0)
    800111bc:	00073883          	ld	a7,0(a4)
    800111c0:	00873803          	ld	a6,8(a4)
    800111c4:	6b08                	ld	a0,16(a4)
    800111c6:	6f0c                	ld	a1,24(a4)
    800111c8:	7310                	ld	a2,32(a4)
    800111ca:	7714                	ld	a3,40(a4)
    800111cc:	7b18                	ld	a4,48(a4)
    800111ce:	0117b023          	sd	a7,0(a5)
    800111d2:	0107b423          	sd	a6,8(a5)
    800111d6:	eb88                	sd	a0,16(a5)
    800111d8:	ef8c                	sd	a1,24(a5)
    800111da:	f390                	sd	a2,32(a5)
    800111dc:	f794                	sd	a3,40(a5)
    800111de:	fb98                	sd	a4,48(a5)
    800111e0:	a005                	j	80011200 <elf_get_dynamic_section+0x92>
    for (uint32_t i = 0; i < elf_header.e_phnum; i++) {
    800111e2:	fec42783          	lw	a5,-20(s0)
    800111e6:	2785                	addiw	a5,a5,1
    800111e8:	fef42623          	sw	a5,-20(s0)
    800111ec:	0384d783          	lhu	a5,56(s1)
    800111f0:	0007871b          	sext.w	a4,a5
    800111f4:	fec42783          	lw	a5,-20(s0)
    800111f8:	2781                	sext.w	a5,a5
    800111fa:	f8e7e6e3          	bltu	a5,a4,80011186 <elf_get_dynamic_section+0x18>
        }
    }
}
    800111fe:	0001                	nop
    80011200:	fd843503          	ld	a0,-40(s0)
    80011204:	7422                	ld	s0,40(sp)
    80011206:	7482                	ld	s1,32(sp)
    80011208:	6145                	addi	sp,sp,48
    8001120a:	8082                	ret

000000008001120c <elf_is_valid_rodata>:

bool elf_is_valid_rodata(Elf64_Phdr rodata) {
    8001120c:	1141                	addi	sp,sp,-16
    8001120e:	e422                	sd	s0,8(sp)
    80011210:	e026                	sd	s1,0(sp)
    80011212:	0800                	addi	s0,sp,16
    80011214:	84aa                	mv	s1,a0
    return rodata.p_type == PT_LOAD && !(rodata.p_flags & PF_W) && !(rodata.p_flags & PF_X);
    80011216:	409c                	lw	a5,0(s1)
    80011218:	873e                	mv	a4,a5
    8001121a:	4785                	li	a5,1
    8001121c:	00f71c63          	bne	a4,a5,80011234 <elf_is_valid_rodata+0x28>
    80011220:	40dc                	lw	a5,4(s1)
    80011222:	8b89                	andi	a5,a5,2
    80011224:	2781                	sext.w	a5,a5
    80011226:	e799                	bnez	a5,80011234 <elf_is_valid_rodata+0x28>
    80011228:	40dc                	lw	a5,4(s1)
    8001122a:	8b85                	andi	a5,a5,1
    8001122c:	2781                	sext.w	a5,a5
    8001122e:	e399                	bnez	a5,80011234 <elf_is_valid_rodata+0x28>
    80011230:	4785                	li	a5,1
    80011232:	a011                	j	80011236 <elf_is_valid_rodata+0x2a>
    80011234:	4781                	li	a5,0
    80011236:	8b85                	andi	a5,a5,1
    80011238:	0ff7f793          	andi	a5,a5,255
}
    8001123c:	853e                	mv	a0,a5
    8001123e:	6422                	ld	s0,8(sp)
    80011240:	6482                	ld	s1,0(sp)
    80011242:	0141                	addi	sp,sp,16
    80011244:	8082                	ret

0000000080011246 <elf_is_valid_bss>:

bool elf_is_valid_bss(Elf64_Phdr bss) {
    80011246:	1141                	addi	sp,sp,-16
    80011248:	e422                	sd	s0,8(sp)
    8001124a:	e026                	sd	s1,0(sp)
    8001124c:	0800                	addi	s0,sp,16
    8001124e:	84aa                	mv	s1,a0
    return bss.p_type == PT_LOAD && bss.p_flags & PF_W && !(bss.p_flags & PF_X);
    80011250:	409c                	lw	a5,0(s1)
    80011252:	873e                	mv	a4,a5
    80011254:	4785                	li	a5,1
    80011256:	00f71c63          	bne	a4,a5,8001126e <elf_is_valid_bss+0x28>
    8001125a:	40dc                	lw	a5,4(s1)
    8001125c:	8b89                	andi	a5,a5,2
    8001125e:	2781                	sext.w	a5,a5
    80011260:	c799                	beqz	a5,8001126e <elf_is_valid_bss+0x28>
    80011262:	40dc                	lw	a5,4(s1)
    80011264:	8b85                	andi	a5,a5,1
    80011266:	2781                	sext.w	a5,a5
    80011268:	e399                	bnez	a5,8001126e <elf_is_valid_bss+0x28>
    8001126a:	4785                	li	a5,1
    8001126c:	a011                	j	80011270 <elf_is_valid_bss+0x2a>
    8001126e:	4781                	li	a5,0
    80011270:	8b85                	andi	a5,a5,1
    80011272:	0ff7f793          	andi	a5,a5,255
}
    80011276:	853e                	mv	a0,a5
    80011278:	6422                	ld	s0,8(sp)
    8001127a:	6482                	ld	s1,0(sp)
    8001127c:	0141                	addi	sp,sp,16
    8001127e:	8082                	ret

0000000080011280 <elf_is_valid_data>:

bool elf_is_valid_data(Elf64_Phdr data) {
    80011280:	1141                	addi	sp,sp,-16
    80011282:	e422                	sd	s0,8(sp)
    80011284:	e026                	sd	s1,0(sp)
    80011286:	0800                	addi	s0,sp,16
    80011288:	84aa                	mv	s1,a0
    return data.p_type == PT_LOAD && data.p_flags & PF_W && !(data.p_flags & PF_X);
    8001128a:	409c                	lw	a5,0(s1)
    8001128c:	873e                	mv	a4,a5
    8001128e:	4785                	li	a5,1
    80011290:	00f71c63          	bne	a4,a5,800112a8 <elf_is_valid_data+0x28>
    80011294:	40dc                	lw	a5,4(s1)
    80011296:	8b89                	andi	a5,a5,2
    80011298:	2781                	sext.w	a5,a5
    8001129a:	c799                	beqz	a5,800112a8 <elf_is_valid_data+0x28>
    8001129c:	40dc                	lw	a5,4(s1)
    8001129e:	8b85                	andi	a5,a5,1
    800112a0:	2781                	sext.w	a5,a5
    800112a2:	e399                	bnez	a5,800112a8 <elf_is_valid_data+0x28>
    800112a4:	4785                	li	a5,1
    800112a6:	a011                	j	800112aa <elf_is_valid_data+0x2a>
    800112a8:	4781                	li	a5,0
    800112aa:	8b85                	andi	a5,a5,1
    800112ac:	0ff7f793          	andi	a5,a5,255
}
    800112b0:	853e                	mv	a0,a5
    800112b2:	6422                	ld	s0,8(sp)
    800112b4:	6482                	ld	s1,0(sp)
    800112b6:	0141                	addi	sp,sp,16
    800112b8:	8082                	ret

00000000800112ba <elf_is_valid_text>:

bool elf_is_valid_text(Elf64_Phdr text) {
    800112ba:	1141                	addi	sp,sp,-16
    800112bc:	e422                	sd	s0,8(sp)
    800112be:	e026                	sd	s1,0(sp)
    800112c0:	0800                	addi	s0,sp,16
    800112c2:	84aa                	mv	s1,a0
    return text.p_type == PT_LOAD && text.p_flags & PF_X;
    800112c4:	409c                	lw	a5,0(s1)
    800112c6:	873e                	mv	a4,a5
    800112c8:	4785                	li	a5,1
    800112ca:	00f71863          	bne	a4,a5,800112da <elf_is_valid_text+0x20>
    800112ce:	40dc                	lw	a5,4(s1)
    800112d0:	8b85                	andi	a5,a5,1
    800112d2:	2781                	sext.w	a5,a5
    800112d4:	c399                	beqz	a5,800112da <elf_is_valid_text+0x20>
    800112d6:	4785                	li	a5,1
    800112d8:	a011                	j	800112dc <elf_is_valid_text+0x22>
    800112da:	4781                	li	a5,0
    800112dc:	8b85                	andi	a5,a5,1
    800112de:	0ff7f793          	andi	a5,a5,255
}
    800112e2:	853e                	mv	a0,a5
    800112e4:	6422                	ld	s0,8(sp)
    800112e6:	6482                	ld	s1,0(sp)
    800112e8:	0141                	addi	sp,sp,16
    800112ea:	8082                	ret

00000000800112ec <elf_create_process>:

int elf_create_process(Process *p, const uint8_t *elf) {
    800112ec:	7101                	addi	sp,sp,-512
    800112ee:	ff86                	sd	ra,504(sp)
    800112f0:	fba2                	sd	s0,496(sp)
    800112f2:	0400                	addi	s0,sp,512
    800112f4:	e4a43423          	sd	a0,-440(s0)
    800112f8:	e4b43023          	sd	a1,-448(s0)
    // Check if the process has a page table
    if (p->rcb.ptable == NULL) {
    800112fc:	e4843783          	ld	a5,-440(s0)
    80011300:	3407b783          	ld	a5,832(a5)
    80011304:	e385                	bnez	a5,80011324 <elf_create_process+0x38>
        debugf("Process does not have a page table\n");
        // Create a page table
        p->rcb.ptable = mmu_table_create();
    80011306:	37c040ef          	jal	ra,80015682 <mmu_table_create>
    8001130a:	872a                	mv	a4,a0
    8001130c:	e4843783          	ld	a5,-440(s0)
    80011310:	34e7b023          	sd	a4,832(a5)
        if (p->rcb.ptable == NULL) {
    80011314:	e4843783          	ld	a5,-440(s0)
    80011318:	3407b783          	ld	a5,832(a5)
    8001131c:	e781                	bnez	a5,80011324 <elf_create_process+0x38>
            debugf("Failed to create page table\n");
            return 1;
    8001131e:	4785                	li	a5,1
    80011320:	1cf0006f          	j	80011cee <elf_create_process+0xa02>
        }
    }

    // Read the ELF header
    Elf64_Ehdr header;
    memcpy(&header, elf, sizeof(header));
    80011324:	f3040793          	addi	a5,s0,-208
    80011328:	04000613          	li	a2,64
    8001132c:	e4043583          	ld	a1,-448(s0)
    80011330:	853e                	mv	a0,a5
    80011332:	00c110ef          	jal	ra,8002233e <memcpy>
    if (!elf_is_valid_header(header)) {
    80011336:	f3043883          	ld	a7,-208(s0)
    8001133a:	f3843803          	ld	a6,-200(s0)
    8001133e:	f4043503          	ld	a0,-192(s0)
    80011342:	f4843583          	ld	a1,-184(s0)
    80011346:	f5043603          	ld	a2,-176(s0)
    8001134a:	f5843683          	ld	a3,-168(s0)
    8001134e:	f6043703          	ld	a4,-160(s0)
    80011352:	f6843783          	ld	a5,-152(s0)
    80011356:	e1143023          	sd	a7,-512(s0)
    8001135a:	e1043423          	sd	a6,-504(s0)
    8001135e:	e0a43823          	sd	a0,-496(s0)
    80011362:	e0b43c23          	sd	a1,-488(s0)
    80011366:	e2c43023          	sd	a2,-480(s0)
    8001136a:	e2d43423          	sd	a3,-472(s0)
    8001136e:	e2e43823          	sd	a4,-464(s0)
    80011372:	e2f43c23          	sd	a5,-456(s0)
    80011376:	e0040793          	addi	a5,s0,-512
    8001137a:	853e                	mv	a0,a5
    8001137c:	e0eff0ef          	jal	ra,8001098a <elf_is_valid_header>
    80011380:	87aa                	mv	a5,a0
    80011382:	0017c793          	xori	a5,a5,1
    80011386:	0ff7f793          	andi	a5,a5,255
    8001138a:	c781                	beqz	a5,80011392 <elf_create_process+0xa6>
        debugf("Invalid ELF header\n");
        return 1;
    8001138c:	4785                	li	a5,1
    8001138e:	1610006f          	j	80011cee <elf_create_process+0xa02>
    }
    elf_debug_header(header);
    80011392:	f3043883          	ld	a7,-208(s0)
    80011396:	f3843803          	ld	a6,-200(s0)
    8001139a:	f4043503          	ld	a0,-192(s0)
    8001139e:	f4843583          	ld	a1,-184(s0)
    800113a2:	f5043603          	ld	a2,-176(s0)
    800113a6:	f5843683          	ld	a3,-168(s0)
    800113aa:	f6043703          	ld	a4,-160(s0)
    800113ae:	f6843783          	ld	a5,-152(s0)
    800113b2:	e1143023          	sd	a7,-512(s0)
    800113b6:	e1043423          	sd	a6,-504(s0)
    800113ba:	e0a43823          	sd	a0,-496(s0)
    800113be:	e0b43c23          	sd	a1,-488(s0)
    800113c2:	e2c43023          	sd	a2,-480(s0)
    800113c6:	e2d43423          	sd	a3,-472(s0)
    800113ca:	e2e43823          	sd	a4,-464(s0)
    800113ce:	e2f43c23          	sd	a5,-456(s0)
    800113d2:	e0040793          	addi	a5,s0,-512
    800113d6:	853e                	mv	a0,a5
    800113d8:	fa4ff0ef          	jal	ra,80010b7c <elf_debug_header>
    
    // Read the program headers
    Elf64_Phdr *program_headers = kmalloc(header.e_phentsize * header.e_phnum);
    800113dc:	f6645783          	lhu	a5,-154(s0)
    800113e0:	0007871b          	sext.w	a4,a5
    800113e4:	f6845783          	lhu	a5,-152(s0)
    800113e8:	2781                	sext.w	a5,a5
    800113ea:	02f707bb          	mulw	a5,a4,a5
    800113ee:	2781                	sext.w	a5,a5
    800113f0:	853e                	mv	a0,a5
    800113f2:	140040ef          	jal	ra,80015532 <kmalloc>
    800113f6:	faa43423          	sd	a0,-88(s0)
    memcpy(program_headers, elf + header.e_phoff, header.e_phentsize * header.e_phnum);
    800113fa:	f5043783          	ld	a5,-176(s0)
    800113fe:	e4043703          	ld	a4,-448(s0)
    80011402:	00f706b3          	add	a3,a4,a5
    80011406:	f6645783          	lhu	a5,-154(s0)
    8001140a:	0007871b          	sext.w	a4,a5
    8001140e:	f6845783          	lhu	a5,-152(s0)
    80011412:	2781                	sext.w	a5,a5
    80011414:	02f707bb          	mulw	a5,a4,a5
    80011418:	2781                	sext.w	a5,a5
    8001141a:	863e                	mv	a2,a5
    8001141c:	85b6                	mv	a1,a3
    8001141e:	fa843503          	ld	a0,-88(s0)
    80011422:	71d100ef          	jal	ra,8002233e <memcpy>
    for (uint32_t i = 0; i < header.e_phnum; i++) {
    80011426:	fe042623          	sw	zero,-20(s0)
    8001142a:	a045                	j	800114ca <elf_create_process+0x1de>
        if (!elf_is_valid_program_header(program_headers[i])) {
    8001142c:	fec46703          	lwu	a4,-20(s0)
    80011430:	87ba                	mv	a5,a4
    80011432:	078e                	slli	a5,a5,0x3
    80011434:	8f99                	sub	a5,a5,a4
    80011436:	078e                	slli	a5,a5,0x3
    80011438:	873e                	mv	a4,a5
    8001143a:	fa843783          	ld	a5,-88(s0)
    8001143e:	97ba                	add	a5,a5,a4
    80011440:	0007b803          	ld	a6,0(a5)
    80011444:	6788                	ld	a0,8(a5)
    80011446:	6b8c                	ld	a1,16(a5)
    80011448:	6f90                	ld	a2,24(a5)
    8001144a:	7394                	ld	a3,32(a5)
    8001144c:	7798                	ld	a4,40(a5)
    8001144e:	7b9c                	ld	a5,48(a5)
    80011450:	e1043023          	sd	a6,-512(s0)
    80011454:	e0a43423          	sd	a0,-504(s0)
    80011458:	e0b43823          	sd	a1,-496(s0)
    8001145c:	e0c43c23          	sd	a2,-488(s0)
    80011460:	e2d43023          	sd	a3,-480(s0)
    80011464:	e2e43423          	sd	a4,-472(s0)
    80011468:	e2f43823          	sd	a5,-464(s0)
    8001146c:	e0040793          	addi	a5,s0,-512
    80011470:	853e                	mv	a0,a5
    80011472:	e0aff0ef          	jal	ra,80010a7c <elf_is_valid_program_header>
            debugf("Invalid program header #%u\n", i);
        }

        elf_debug_program_header(program_headers[i]);
    80011476:	fec46703          	lwu	a4,-20(s0)
    8001147a:	87ba                	mv	a5,a4
    8001147c:	078e                	slli	a5,a5,0x3
    8001147e:	8f99                	sub	a5,a5,a4
    80011480:	078e                	slli	a5,a5,0x3
    80011482:	873e                	mv	a4,a5
    80011484:	fa843783          	ld	a5,-88(s0)
    80011488:	97ba                	add	a5,a5,a4
    8001148a:	0007b803          	ld	a6,0(a5)
    8001148e:	6788                	ld	a0,8(a5)
    80011490:	6b8c                	ld	a1,16(a5)
    80011492:	6f90                	ld	a2,24(a5)
    80011494:	7394                	ld	a3,32(a5)
    80011496:	7798                	ld	a4,40(a5)
    80011498:	7b9c                	ld	a5,48(a5)
    8001149a:	e1043023          	sd	a6,-512(s0)
    8001149e:	e0a43423          	sd	a0,-504(s0)
    800114a2:	e0b43823          	sd	a1,-496(s0)
    800114a6:	e0c43c23          	sd	a2,-488(s0)
    800114aa:	e2d43023          	sd	a3,-480(s0)
    800114ae:	e2e43423          	sd	a4,-472(s0)
    800114b2:	e2f43823          	sd	a5,-464(s0)
    800114b6:	e0040793          	addi	a5,s0,-512
    800114ba:	853e                	mv	a0,a5
    800114bc:	8d1ff0ef          	jal	ra,80010d8c <elf_debug_program_header>
    for (uint32_t i = 0; i < header.e_phnum; i++) {
    800114c0:	fec42783          	lw	a5,-20(s0)
    800114c4:	2785                	addiw	a5,a5,1
    800114c6:	fef42623          	sw	a5,-20(s0)
    800114ca:	f6845783          	lhu	a5,-152(s0)
    800114ce:	0007871b          	sext.w	a4,a5
    800114d2:	fec42783          	lw	a5,-20(s0)
    800114d6:	2781                	sext.w	a5,a5
    800114d8:	f4e7eae3          	bltu	a5,a4,8001142c <elf_create_process+0x140>

    // Go through the program headers and find the text, bss, rodata, srodata, and data segments
    debugf("Text header:\n");


    uint64_t permission_bits = PB_READ | PB_EXECUTE | PB_WRITE | PB_USER;
    800114dc:	47f9                	li	a5,30
    800114de:	faf43023          	sd	a5,-96(s0)

    // Get sum of the sizes of all the segments
    Elf64_Phdr text_header = elf_get_text_section(header, program_headers);
    800114e2:	ef840313          	addi	t1,s0,-264
    800114e6:	f3043883          	ld	a7,-208(s0)
    800114ea:	f3843803          	ld	a6,-200(s0)
    800114ee:	f4043503          	ld	a0,-192(s0)
    800114f2:	f4843583          	ld	a1,-184(s0)
    800114f6:	f5043603          	ld	a2,-176(s0)
    800114fa:	f5843683          	ld	a3,-168(s0)
    800114fe:	f6043703          	ld	a4,-160(s0)
    80011502:	f6843783          	ld	a5,-152(s0)
    80011506:	e1143023          	sd	a7,-512(s0)
    8001150a:	e1043423          	sd	a6,-504(s0)
    8001150e:	e0a43823          	sd	a0,-496(s0)
    80011512:	e0b43c23          	sd	a1,-488(s0)
    80011516:	e2c43023          	sd	a2,-480(s0)
    8001151a:	e2d43423          	sd	a3,-472(s0)
    8001151e:	e2e43823          	sd	a4,-464(s0)
    80011522:	e2f43c23          	sd	a5,-456(s0)
    80011526:	e0040793          	addi	a5,s0,-512
    8001152a:	fa843603          	ld	a2,-88(s0)
    8001152e:	85be                	mv	a1,a5
    80011530:	851a                	mv	a0,t1
    80011532:	91dff0ef          	jal	ra,80010e4e <elf_get_text_section>
    Elf64_Phdr rodata_header = elf_get_rodata_section(header, program_headers);
    80011536:	ec040313          	addi	t1,s0,-320
    8001153a:	f3043883          	ld	a7,-208(s0)
    8001153e:	f3843803          	ld	a6,-200(s0)
    80011542:	f4043503          	ld	a0,-192(s0)
    80011546:	f4843583          	ld	a1,-184(s0)
    8001154a:	f5043603          	ld	a2,-176(s0)
    8001154e:	f5843683          	ld	a3,-168(s0)
    80011552:	f6043703          	ld	a4,-160(s0)
    80011556:	f6843783          	ld	a5,-152(s0)
    8001155a:	e1143023          	sd	a7,-512(s0)
    8001155e:	e1043423          	sd	a6,-504(s0)
    80011562:	e0a43823          	sd	a0,-496(s0)
    80011566:	e0b43c23          	sd	a1,-488(s0)
    8001156a:	e2c43023          	sd	a2,-480(s0)
    8001156e:	e2d43423          	sd	a3,-472(s0)
    80011572:	e2e43823          	sd	a4,-464(s0)
    80011576:	e2f43c23          	sd	a5,-456(s0)
    8001157a:	e0040793          	addi	a5,s0,-512
    8001157e:	fa843603          	ld	a2,-88(s0)
    80011582:	85be                	mv	a1,a5
    80011584:	851a                	mv	a0,t1
    80011586:	b13ff0ef          	jal	ra,80011098 <elf_get_rodata_section>
    Elf64_Phdr bss_header = elf_get_bss_section(header, program_headers);
    8001158a:	e8840313          	addi	t1,s0,-376
    8001158e:	f3043883          	ld	a7,-208(s0)
    80011592:	f3843803          	ld	a6,-200(s0)
    80011596:	f4043503          	ld	a0,-192(s0)
    8001159a:	f4843583          	ld	a1,-184(s0)
    8001159e:	f5043603          	ld	a2,-176(s0)
    800115a2:	f5843683          	ld	a3,-168(s0)
    800115a6:	f6043703          	ld	a4,-160(s0)
    800115aa:	f6843783          	ld	a5,-152(s0)
    800115ae:	e1143023          	sd	a7,-512(s0)
    800115b2:	e1043423          	sd	a6,-504(s0)
    800115b6:	e0a43823          	sd	a0,-496(s0)
    800115ba:	e0b43c23          	sd	a1,-488(s0)
    800115be:	e2c43023          	sd	a2,-480(s0)
    800115c2:	e2d43423          	sd	a3,-472(s0)
    800115c6:	e2e43823          	sd	a4,-464(s0)
    800115ca:	e2f43c23          	sd	a5,-456(s0)
    800115ce:	e0040793          	addi	a5,s0,-512
    800115d2:	fa843603          	ld	a2,-88(s0)
    800115d6:	85be                	mv	a1,a5
    800115d8:	851a                	mv	a0,t1
    800115da:	92fff0ef          	jal	ra,80010f08 <elf_get_bss_section>
    Elf64_Phdr data_header = elf_get_data_section(header, program_headers);
    800115de:	e5040313          	addi	t1,s0,-432
    800115e2:	f3043883          	ld	a7,-208(s0)
    800115e6:	f3843803          	ld	a6,-200(s0)
    800115ea:	f4043503          	ld	a0,-192(s0)
    800115ee:	f4843583          	ld	a1,-184(s0)
    800115f2:	f5043603          	ld	a2,-176(s0)
    800115f6:	f5843683          	ld	a3,-168(s0)
    800115fa:	f6043703          	ld	a4,-160(s0)
    800115fe:	f6843783          	ld	a5,-152(s0)
    80011602:	e1143023          	sd	a7,-512(s0)
    80011606:	e1043423          	sd	a6,-504(s0)
    8001160a:	e0a43823          	sd	a0,-496(s0)
    8001160e:	e0b43c23          	sd	a1,-488(s0)
    80011612:	e2c43023          	sd	a2,-480(s0)
    80011616:	e2d43423          	sd	a3,-472(s0)
    8001161a:	e2e43823          	sd	a4,-464(s0)
    8001161e:	e2f43c23          	sd	a5,-456(s0)
    80011622:	e0040793          	addi	a5,s0,-512
    80011626:	fa843603          	ld	a2,-88(s0)
    8001162a:	85be                	mv	a1,a5
    8001162c:	851a                	mv	a0,t1
    8001162e:	995ff0ef          	jal	ra,80010fc2 <elf_get_data_section>
    debugf("Text header:\n");
    elf_debug_program_header(text_header);
    80011632:	ef843803          	ld	a6,-264(s0)
    80011636:	f0043503          	ld	a0,-256(s0)
    8001163a:	f0843583          	ld	a1,-248(s0)
    8001163e:	f1043603          	ld	a2,-240(s0)
    80011642:	f1843683          	ld	a3,-232(s0)
    80011646:	f2043703          	ld	a4,-224(s0)
    8001164a:	f2843783          	ld	a5,-216(s0)
    8001164e:	e1043023          	sd	a6,-512(s0)
    80011652:	e0a43423          	sd	a0,-504(s0)
    80011656:	e0b43823          	sd	a1,-496(s0)
    8001165a:	e0c43c23          	sd	a2,-488(s0)
    8001165e:	e2d43023          	sd	a3,-480(s0)
    80011662:	e2e43423          	sd	a4,-472(s0)
    80011666:	e2f43823          	sd	a5,-464(s0)
    8001166a:	e0040793          	addi	a5,s0,-512
    8001166e:	853e                	mv	a0,a5
    80011670:	f1cff0ef          	jal	ra,80010d8c <elf_debug_program_header>
    debugf("RODATA header:\n");
    elf_debug_program_header(rodata_header);
    80011674:	ec043803          	ld	a6,-320(s0)
    80011678:	ec843503          	ld	a0,-312(s0)
    8001167c:	ed043583          	ld	a1,-304(s0)
    80011680:	ed843603          	ld	a2,-296(s0)
    80011684:	ee043683          	ld	a3,-288(s0)
    80011688:	ee843703          	ld	a4,-280(s0)
    8001168c:	ef043783          	ld	a5,-272(s0)
    80011690:	e1043023          	sd	a6,-512(s0)
    80011694:	e0a43423          	sd	a0,-504(s0)
    80011698:	e0b43823          	sd	a1,-496(s0)
    8001169c:	e0c43c23          	sd	a2,-488(s0)
    800116a0:	e2d43023          	sd	a3,-480(s0)
    800116a4:	e2e43423          	sd	a4,-472(s0)
    800116a8:	e2f43823          	sd	a5,-464(s0)
    800116ac:	e0040793          	addi	a5,s0,-512
    800116b0:	853e                	mv	a0,a5
    800116b2:	edaff0ef          	jal	ra,80010d8c <elf_debug_program_header>
    debugf("BSS header:\n");
    elf_debug_program_header(bss_header);
    800116b6:	e8843803          	ld	a6,-376(s0)
    800116ba:	e9043503          	ld	a0,-368(s0)
    800116be:	e9843583          	ld	a1,-360(s0)
    800116c2:	ea043603          	ld	a2,-352(s0)
    800116c6:	ea843683          	ld	a3,-344(s0)
    800116ca:	eb043703          	ld	a4,-336(s0)
    800116ce:	eb843783          	ld	a5,-328(s0)
    800116d2:	e1043023          	sd	a6,-512(s0)
    800116d6:	e0a43423          	sd	a0,-504(s0)
    800116da:	e0b43823          	sd	a1,-496(s0)
    800116de:	e0c43c23          	sd	a2,-488(s0)
    800116e2:	e2d43023          	sd	a3,-480(s0)
    800116e6:	e2e43423          	sd	a4,-472(s0)
    800116ea:	e2f43823          	sd	a5,-464(s0)
    800116ee:	e0040793          	addi	a5,s0,-512
    800116f2:	853e                	mv	a0,a5
    800116f4:	e98ff0ef          	jal	ra,80010d8c <elf_debug_program_header>
    debugf("DATA header:\n");
    elf_debug_program_header(data_header);
    800116f8:	e5043803          	ld	a6,-432(s0)
    800116fc:	e5843503          	ld	a0,-424(s0)
    80011700:	e6043583          	ld	a1,-416(s0)
    80011704:	e6843603          	ld	a2,-408(s0)
    80011708:	e7043683          	ld	a3,-400(s0)
    8001170c:	e7843703          	ld	a4,-392(s0)
    80011710:	e8043783          	ld	a5,-384(s0)
    80011714:	e1043023          	sd	a6,-512(s0)
    80011718:	e0a43423          	sd	a0,-504(s0)
    8001171c:	e0b43823          	sd	a1,-496(s0)
    80011720:	e0c43c23          	sd	a2,-488(s0)
    80011724:	e2d43023          	sd	a3,-480(s0)
    80011728:	e2e43423          	sd	a4,-472(s0)
    8001172c:	e2f43823          	sd	a5,-464(s0)
    80011730:	e0040793          	addi	a5,s0,-512
    80011734:	853e                	mv	a0,a5
    80011736:	e56ff0ef          	jal	ra,80010d8c <elf_debug_program_header>

    // Get the sizes of the segments
    debugf("Getting sizes of segments\n");
    uint64_t text_size = elf_is_valid_text(text_header)? text_header.p_memsz : 0;
    8001173a:	ef843803          	ld	a6,-264(s0)
    8001173e:	f0043503          	ld	a0,-256(s0)
    80011742:	f0843583          	ld	a1,-248(s0)
    80011746:	f1043603          	ld	a2,-240(s0)
    8001174a:	f1843683          	ld	a3,-232(s0)
    8001174e:	f2043703          	ld	a4,-224(s0)
    80011752:	f2843783          	ld	a5,-216(s0)
    80011756:	e1043023          	sd	a6,-512(s0)
    8001175a:	e0a43423          	sd	a0,-504(s0)
    8001175e:	e0b43823          	sd	a1,-496(s0)
    80011762:	e0c43c23          	sd	a2,-488(s0)
    80011766:	e2d43023          	sd	a3,-480(s0)
    8001176a:	e2e43423          	sd	a4,-472(s0)
    8001176e:	e2f43823          	sd	a5,-464(s0)
    80011772:	e0040793          	addi	a5,s0,-512
    80011776:	853e                	mv	a0,a5
    80011778:	b43ff0ef          	jal	ra,800112ba <elf_is_valid_text>
    8001177c:	87aa                	mv	a5,a0
    8001177e:	c781                	beqz	a5,80011786 <elf_create_process+0x49a>
    80011780:	f2043783          	ld	a5,-224(s0)
    80011784:	a011                	j	80011788 <elf_create_process+0x49c>
    80011786:	4781                	li	a5,0
    80011788:	f8f43c23          	sd	a5,-104(s0)
    debugf("Text size: %x\n", text_size);
    uint64_t rodata_size = elf_is_valid_rodata(rodata_header)? rodata_header.p_memsz : 0;
    8001178c:	ec043803          	ld	a6,-320(s0)
    80011790:	ec843503          	ld	a0,-312(s0)
    80011794:	ed043583          	ld	a1,-304(s0)
    80011798:	ed843603          	ld	a2,-296(s0)
    8001179c:	ee043683          	ld	a3,-288(s0)
    800117a0:	ee843703          	ld	a4,-280(s0)
    800117a4:	ef043783          	ld	a5,-272(s0)
    800117a8:	e1043023          	sd	a6,-512(s0)
    800117ac:	e0a43423          	sd	a0,-504(s0)
    800117b0:	e0b43823          	sd	a1,-496(s0)
    800117b4:	e0c43c23          	sd	a2,-488(s0)
    800117b8:	e2d43023          	sd	a3,-480(s0)
    800117bc:	e2e43423          	sd	a4,-472(s0)
    800117c0:	e2f43823          	sd	a5,-464(s0)
    800117c4:	e0040793          	addi	a5,s0,-512
    800117c8:	853e                	mv	a0,a5
    800117ca:	a43ff0ef          	jal	ra,8001120c <elf_is_valid_rodata>
    800117ce:	87aa                	mv	a5,a0
    800117d0:	c781                	beqz	a5,800117d8 <elf_create_process+0x4ec>
    800117d2:	ee843783          	ld	a5,-280(s0)
    800117d6:	a011                	j	800117da <elf_create_process+0x4ee>
    800117d8:	4781                	li	a5,0
    800117da:	f8f43823          	sd	a5,-112(s0)
    debugf("RODATA size: %x\n", rodata_size);
    uint64_t bss_size = elf_is_valid_bss(bss_header)? bss_header.p_memsz : 0;
    800117de:	e8843803          	ld	a6,-376(s0)
    800117e2:	e9043503          	ld	a0,-368(s0)
    800117e6:	e9843583          	ld	a1,-360(s0)
    800117ea:	ea043603          	ld	a2,-352(s0)
    800117ee:	ea843683          	ld	a3,-344(s0)
    800117f2:	eb043703          	ld	a4,-336(s0)
    800117f6:	eb843783          	ld	a5,-328(s0)
    800117fa:	e1043023          	sd	a6,-512(s0)
    800117fe:	e0a43423          	sd	a0,-504(s0)
    80011802:	e0b43823          	sd	a1,-496(s0)
    80011806:	e0c43c23          	sd	a2,-488(s0)
    8001180a:	e2d43023          	sd	a3,-480(s0)
    8001180e:	e2e43423          	sd	a4,-472(s0)
    80011812:	e2f43823          	sd	a5,-464(s0)
    80011816:	e0040793          	addi	a5,s0,-512
    8001181a:	853e                	mv	a0,a5
    8001181c:	a2bff0ef          	jal	ra,80011246 <elf_is_valid_bss>
    80011820:	87aa                	mv	a5,a0
    80011822:	c781                	beqz	a5,8001182a <elf_create_process+0x53e>
    80011824:	eb043783          	ld	a5,-336(s0)
    80011828:	a011                	j	8001182c <elf_create_process+0x540>
    8001182a:	4781                	li	a5,0
    8001182c:	f8f43423          	sd	a5,-120(s0)
    debugf("BSS size: %x\n", bss_size);
    uint64_t data_size = elf_is_valid_data(data_header)? data_header.p_memsz : 0;
    80011830:	e5043803          	ld	a6,-432(s0)
    80011834:	e5843503          	ld	a0,-424(s0)
    80011838:	e6043583          	ld	a1,-416(s0)
    8001183c:	e6843603          	ld	a2,-408(s0)
    80011840:	e7043683          	ld	a3,-400(s0)
    80011844:	e7843703          	ld	a4,-392(s0)
    80011848:	e8043783          	ld	a5,-384(s0)
    8001184c:	e1043023          	sd	a6,-512(s0)
    80011850:	e0a43423          	sd	a0,-504(s0)
    80011854:	e0b43823          	sd	a1,-496(s0)
    80011858:	e0c43c23          	sd	a2,-488(s0)
    8001185c:	e2d43023          	sd	a3,-480(s0)
    80011860:	e2e43423          	sd	a4,-472(s0)
    80011864:	e2f43823          	sd	a5,-464(s0)
    80011868:	e0040793          	addi	a5,s0,-512
    8001186c:	853e                	mv	a0,a5
    8001186e:	a13ff0ef          	jal	ra,80011280 <elf_is_valid_data>
    80011872:	87aa                	mv	a5,a0
    80011874:	c781                	beqz	a5,8001187c <elf_create_process+0x590>
    80011876:	e7843783          	ld	a5,-392(s0)
    8001187a:	a011                	j	8001187e <elf_create_process+0x592>
    8001187c:	4781                	li	a5,0
    8001187e:	f8f43023          	sd	a5,-128(s0)
    debugf("DATA size: %x\n", data_size);

    uint64_t total_size = text_size + rodata_size + bss_size + data_size;
    80011882:	f9843703          	ld	a4,-104(s0)
    80011886:	f9043783          	ld	a5,-112(s0)
    8001188a:	973e                	add	a4,a4,a5
    8001188c:	f8843783          	ld	a5,-120(s0)
    80011890:	97ba                	add	a5,a5,a4
    80011892:	f8043703          	ld	a4,-128(s0)
    80011896:	97ba                	add	a5,a5,a4
    80011898:	f6f43c23          	sd	a5,-136(s0)
    debugf("Total size: %x\n", total_size);
    // Allocate the memory for the segments
    uint8_t *segments = (uint8_t*)page_nalloc(ALIGN_UP_POT(total_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    8001189c:	f7843703          	ld	a4,-136(s0)
    800118a0:	6785                	lui	a5,0x1
    800118a2:	17fd                	addi	a5,a5,-1
    800118a4:	97ba                	add	a5,a5,a4
    800118a6:	83b1                	srli	a5,a5,0xc
    800118a8:	2781                	sext.w	a5,a5
    800118aa:	853e                	mv	a0,a5
    800118ac:	59e0c0ef          	jal	ra,8001de4a <page_nalloc>
    800118b0:	f6a43823          	sd	a0,-144(s0)
    memset(segments, 0, total_size);
    800118b4:	f7843783          	ld	a5,-136(s0)
    800118b8:	2781                	sext.w	a5,a5
    800118ba:	863e                	mv	a2,a5
    800118bc:	4581                	li	a1,0
    800118be:	f7043503          	ld	a0,-144(s0)
    800118c2:	17b100ef          	jal	ra,8002223c <memset>
    p->image = segments;
    800118c6:	e4843783          	ld	a5,-440(s0)
    800118ca:	f7043703          	ld	a4,-144(s0)
    800118ce:	26e7bc23          	sd	a4,632(a5) # 1278 <i+0x1258>
    p->image_size = total_size;
    800118d2:	e4843783          	ld	a5,-440(s0)
    800118d6:	f7843703          	ld	a4,-136(s0)
    800118da:	28e7b023          	sd	a4,640(a5)

    // Get the pointers to the segments
    uint8_t *text = segments;
    800118de:	f7043783          	ld	a5,-144(s0)
    800118e2:	fef43023          	sd	a5,-32(s0)
    uint8_t *rodata = text + text_size;
    800118e6:	fe043703          	ld	a4,-32(s0)
    800118ea:	f9843783          	ld	a5,-104(s0)
    800118ee:	97ba                	add	a5,a5,a4
    800118f0:	fcf43c23          	sd	a5,-40(s0)
    uint8_t *bss = rodata + rodata_size;
    800118f4:	fd843703          	ld	a4,-40(s0)
    800118f8:	f9043783          	ld	a5,-112(s0)
    800118fc:	97ba                	add	a5,a5,a4
    800118fe:	fcf43823          	sd	a5,-48(s0)
    uint8_t *data = bss + bss_size;
    80011902:	fd043703          	ld	a4,-48(s0)
    80011906:	f8843783          	ld	a5,-120(s0)
    8001190a:	97ba                	add	a5,a5,a4
    8001190c:	fcf43423          	sd	a5,-56(s0)
    if (!text_size) text = NULL;
    80011910:	f9843783          	ld	a5,-104(s0)
    80011914:	e399                	bnez	a5,8001191a <elf_create_process+0x62e>
    80011916:	fe043023          	sd	zero,-32(s0)
    if (!rodata_size) rodata = NULL;
    8001191a:	f9043783          	ld	a5,-112(s0)
    8001191e:	e399                	bnez	a5,80011924 <elf_create_process+0x638>
    80011920:	fc043c23          	sd	zero,-40(s0)
    if (!bss_size) bss = NULL;
    80011924:	f8843783          	ld	a5,-120(s0)
    80011928:	e399                	bnez	a5,8001192e <elf_create_process+0x642>
    8001192a:	fc043823          	sd	zero,-48(s0)
    if (!data_size || data_header.p_vaddr == bss_header.p_vaddr) data = NULL;
    8001192e:	f8043783          	ld	a5,-128(s0)
    80011932:	c799                	beqz	a5,80011940 <elf_create_process+0x654>
    80011934:	e6043703          	ld	a4,-416(s0)
    80011938:	e9843783          	ld	a5,-360(s0)
    8001193c:	00f71463          	bne	a4,a5,80011944 <elf_create_process+0x658>
    80011940:	fc043423          	sd	zero,-56(s0)

    // Copy the segments into the allocated memory
    if (text) {
    80011944:	fe043783          	ld	a5,-32(s0)
    80011948:	cf99                	beqz	a5,80011966 <elf_create_process+0x67a>
        debugf("Copying text segment\n");
        memcpy(text, elf + text_header.p_offset, text_header.p_filesz);
    8001194a:	f0043783          	ld	a5,-256(s0)
    8001194e:	e4043703          	ld	a4,-448(s0)
    80011952:	97ba                	add	a5,a5,a4
    80011954:	f1843703          	ld	a4,-232(s0)
    80011958:	2701                	sext.w	a4,a4
    8001195a:	863a                	mv	a2,a4
    8001195c:	85be                	mv	a1,a5
    8001195e:	fe043503          	ld	a0,-32(s0)
    80011962:	1dd100ef          	jal	ra,8002233e <memcpy>
    }
    if (rodata) {
    80011966:	fd843783          	ld	a5,-40(s0)
    8001196a:	cf99                	beqz	a5,80011988 <elf_create_process+0x69c>
        debugf("Copying rodata segment\n");
        memcpy(rodata, elf + rodata_header.p_offset, rodata_header.p_filesz);
    8001196c:	ec843783          	ld	a5,-312(s0)
    80011970:	e4043703          	ld	a4,-448(s0)
    80011974:	97ba                	add	a5,a5,a4
    80011976:	ee043703          	ld	a4,-288(s0)
    8001197a:	2701                	sext.w	a4,a4
    8001197c:	863a                	mv	a2,a4
    8001197e:	85be                	mv	a1,a5
    80011980:	fd843503          	ld	a0,-40(s0)
    80011984:	1bb100ef          	jal	ra,8002233e <memcpy>
    }
    if (data) {
    80011988:	fc843783          	ld	a5,-56(s0)
    8001198c:	cf99                	beqz	a5,800119aa <elf_create_process+0x6be>
        debugf("Copying data segment\n");
        memcpy(data, elf + data_header.p_offset, data_header.p_filesz);
    8001198e:	e5843783          	ld	a5,-424(s0)
    80011992:	e4043703          	ld	a4,-448(s0)
    80011996:	97ba                	add	a5,a5,a4
    80011998:	e7043703          	ld	a4,-400(s0)
    8001199c:	2701                	sext.w	a4,a4
    8001199e:	863a                	mv	a2,a4
    800119a0:	85be                	mv	a1,a5
    800119a2:	fc843503          	ld	a0,-56(s0)
    800119a6:	199100ef          	jal	ra,8002233e <memcpy>
    }

    // Map the segments into the page table
    if (text) {
    800119aa:	fe043783          	ld	a5,-32(s0)
    800119ae:	c785                	beqz	a5,800119d6 <elf_create_process+0x6ea>
        debugf("Mapping text segment\n");
        mmu_map_range(p->rcb.ptable, 
    800119b0:	e4843783          	ld	a5,-440(s0)
    800119b4:	3407b503          	ld	a0,832(a5)
    800119b8:	f0843583          	ld	a1,-248(s0)
                    text_header.p_vaddr, 
                    text_header.p_vaddr + text_size, 
    800119bc:	f0843703          	ld	a4,-248(s0)
        mmu_map_range(p->rcb.ptable, 
    800119c0:	f9843783          	ld	a5,-104(s0)
    800119c4:	00f70633          	add	a2,a4,a5
    800119c8:	fe043683          	ld	a3,-32(s0)
    800119cc:	fa043783          	ld	a5,-96(s0)
    800119d0:	4701                	li	a4,0
    800119d2:	0de040ef          	jal	ra,80015ab0 <mmu_map_range>
                    (uint64_t)text, 
                    MMU_LEVEL_4K,
                    permission_bits);
    }
    if (rodata) {
    800119d6:	fd843783          	ld	a5,-40(s0)
    800119da:	c785                	beqz	a5,80011a02 <elf_create_process+0x716>
        debugf("Mapping rodata segment\n");
        mmu_map_range(p->rcb.ptable, 
    800119dc:	e4843783          	ld	a5,-440(s0)
    800119e0:	3407b503          	ld	a0,832(a5)
    800119e4:	ed043583          	ld	a1,-304(s0)
                    rodata_header.p_vaddr, 
                    rodata_header.p_vaddr + rodata_size, 
    800119e8:	ed043703          	ld	a4,-304(s0)
        mmu_map_range(p->rcb.ptable, 
    800119ec:	f9043783          	ld	a5,-112(s0)
    800119f0:	00f70633          	add	a2,a4,a5
    800119f4:	fd843683          	ld	a3,-40(s0)
    800119f8:	fa043783          	ld	a5,-96(s0)
    800119fc:	4701                	li	a4,0
    800119fe:	0b2040ef          	jal	ra,80015ab0 <mmu_map_range>
                    (uint64_t)rodata, 
                    MMU_LEVEL_4K,
                    permission_bits);
    }
    if (bss) {
    80011a02:	fd043783          	ld	a5,-48(s0)
    80011a06:	c785                	beqz	a5,80011a2e <elf_create_process+0x742>
        debugf("Mapping bss segment\n");
        mmu_map_range(p->rcb.ptable, 
    80011a08:	e4843783          	ld	a5,-440(s0)
    80011a0c:	3407b503          	ld	a0,832(a5)
    80011a10:	e9843583          	ld	a1,-360(s0)
                    bss_header.p_vaddr, 
                    bss_header.p_vaddr + bss_size, 
    80011a14:	e9843703          	ld	a4,-360(s0)
        mmu_map_range(p->rcb.ptable, 
    80011a18:	f8843783          	ld	a5,-120(s0)
    80011a1c:	00f70633          	add	a2,a4,a5
    80011a20:	fd043683          	ld	a3,-48(s0)
    80011a24:	fa043783          	ld	a5,-96(s0)
    80011a28:	4701                	li	a4,0
    80011a2a:	086040ef          	jal	ra,80015ab0 <mmu_map_range>
                    (uint64_t)bss, 
                    MMU_LEVEL_4K,
                    permission_bits);
    }
    if (data) {
    80011a2e:	fc843783          	ld	a5,-56(s0)
    80011a32:	c785                	beqz	a5,80011a5a <elf_create_process+0x76e>
        debugf("Mapping data segment\n");
        mmu_map_range(p->rcb.ptable, 
    80011a34:	e4843783          	ld	a5,-440(s0)
    80011a38:	3407b503          	ld	a0,832(a5)
    80011a3c:	e6043583          	ld	a1,-416(s0)
                    data_header.p_vaddr, 
                    data_header.p_vaddr + data_size, 
    80011a40:	e6043703          	ld	a4,-416(s0)
        mmu_map_range(p->rcb.ptable, 
    80011a44:	f8043783          	ld	a5,-128(s0)
    80011a48:	00f70633          	add	a2,a4,a5
    80011a4c:	fc843683          	ld	a3,-56(s0)
    80011a50:	fa043783          	ld	a5,-96(s0)
    80011a54:	4701                	li	a4,0
    80011a56:	05a040ef          	jal	ra,80015ab0 <mmu_map_range>
                    (uint64_t)data, 
                    MMU_LEVEL_4K,
                    permission_bits);
    }
    // Create the process
    p->text = text;
    80011a5a:	e4843783          	ld	a5,-440(s0)
    80011a5e:	fe043703          	ld	a4,-32(s0)
    80011a62:	28e7b423          	sd	a4,648(a5)
    p->text_vaddr = text ? (uint8_t *)text_header.p_vaddr : NULL;
    80011a66:	fe043783          	ld	a5,-32(s0)
    80011a6a:	c789                	beqz	a5,80011a74 <elf_create_process+0x788>
    80011a6c:	f0843783          	ld	a5,-248(s0)
    80011a70:	873e                	mv	a4,a5
    80011a72:	a011                	j	80011a76 <elf_create_process+0x78a>
    80011a74:	4701                	li	a4,0
    80011a76:	e4843783          	ld	a5,-440(s0)
    80011a7a:	28e7b823          	sd	a4,656(a5)
    p->text_size = text_size;
    80011a7e:	e4843783          	ld	a5,-440(s0)
    80011a82:	f9843703          	ld	a4,-104(s0)
    80011a86:	28e7bc23          	sd	a4,664(a5)
    debugf("Text: %p\n", p->text);
    debugf("Text vaddr: %p\n", p->text_vaddr);
    debugf("Text size: %lu\n", p->text_size);
    
    p->bss = bss;
    80011a8a:	e4843783          	ld	a5,-440(s0)
    80011a8e:	fd043703          	ld	a4,-48(s0)
    80011a92:	2ae7b023          	sd	a4,672(a5)
    p->bss_vaddr = bss ? (uint8_t *)bss_header.p_vaddr : NULL;
    80011a96:	fd043783          	ld	a5,-48(s0)
    80011a9a:	c789                	beqz	a5,80011aa4 <elf_create_process+0x7b8>
    80011a9c:	e9843783          	ld	a5,-360(s0)
    80011aa0:	873e                	mv	a4,a5
    80011aa2:	a011                	j	80011aa6 <elf_create_process+0x7ba>
    80011aa4:	4701                	li	a4,0
    80011aa6:	e4843783          	ld	a5,-440(s0)
    80011aaa:	2ae7b423          	sd	a4,680(a5)
    p->bss_size = bss_size;
    80011aae:	e4843783          	ld	a5,-440(s0)
    80011ab2:	f8843703          	ld	a4,-120(s0)
    80011ab6:	2ae7b823          	sd	a4,688(a5)
    debugf("BSS: %p\n", p->bss);
    debugf("BSS vaddr: %p\n", p->bss_vaddr);
    debugf("BSS size: %lu\n", p->bss_size);
    

    p->rodata = rodata;
    80011aba:	e4843783          	ld	a5,-440(s0)
    80011abe:	fd843703          	ld	a4,-40(s0)
    80011ac2:	2ae7bc23          	sd	a4,696(a5)
    p->rodata_vaddr = rodata ? (uint8_t *)rodata_header.p_vaddr : NULL;
    80011ac6:	fd843783          	ld	a5,-40(s0)
    80011aca:	c789                	beqz	a5,80011ad4 <elf_create_process+0x7e8>
    80011acc:	ed043783          	ld	a5,-304(s0)
    80011ad0:	873e                	mv	a4,a5
    80011ad2:	a011                	j	80011ad6 <elf_create_process+0x7ea>
    80011ad4:	4701                	li	a4,0
    80011ad6:	e4843783          	ld	a5,-440(s0)
    80011ada:	2ce7b023          	sd	a4,704(a5)
    p->rodata_size = rodata_size;
    80011ade:	e4843783          	ld	a5,-440(s0)
    80011ae2:	f9043703          	ld	a4,-112(s0)
    80011ae6:	2ce7b423          	sd	a4,712(a5)
    debugf("RODATA: %p\n", p->rodata);
    debugf("RODATA vaddr: %p\n", p->rodata_vaddr);
    debugf("RODATA size: %lu\n", p->rodata_size);

    p->data = data;
    80011aea:	e4843783          	ld	a5,-440(s0)
    80011aee:	fc843703          	ld	a4,-56(s0)
    80011af2:	2ce7b823          	sd	a4,720(a5)
    p->data_vaddr = data ? (uint8_t *)data_header.p_vaddr : NULL;
    80011af6:	fc843783          	ld	a5,-56(s0)
    80011afa:	c789                	beqz	a5,80011b04 <elf_create_process+0x818>
    80011afc:	e6043783          	ld	a5,-416(s0)
    80011b00:	873e                	mv	a4,a5
    80011b02:	a011                	j	80011b06 <elf_create_process+0x81a>
    80011b04:	4701                	li	a4,0
    80011b06:	e4843783          	ld	a5,-440(s0)
    80011b0a:	2ce7bc23          	sd	a4,728(a5)
    p->data_size = data_size;
    80011b0e:	e4843783          	ld	a5,-440(s0)
    80011b12:	f8043703          	ld	a4,-128(s0)
    80011b16:	2ee7b023          	sd	a4,736(a5)
    debugf("DATA: %p\n", p->data);
    debugf("DATA vaddr: %p\n", p->data_vaddr);
    debugf("DATA size: %lu\n", p->data_size);

    // Set the fields of the RCB
    if (!p->rcb.image_pages) {
    80011b1a:	e4843783          	ld	a5,-440(s0)
    80011b1e:	3187b783          	ld	a5,792(a5)
    80011b22:	eb81                	bnez	a5,80011b32 <elf_create_process+0x846>
        p->rcb.image_pages = list_new();
    80011b24:	0e30e0ef          	jal	ra,80020406 <list_new>
    80011b28:	872a                	mv	a4,a0
    80011b2a:	e4843783          	ld	a5,-440(s0)
    80011b2e:	30e7bc23          	sd	a4,792(a5)
    }
    // Store all the pages in the `segments` array
    for (uint64_t i = 0; i < total_size / PAGE_SIZE; i++) {
    80011b32:	fc043023          	sd	zero,-64(s0)
    80011b36:	a025                	j	80011b5e <elf_create_process+0x872>
        list_add_ptr(p->rcb.image_pages, segments + i * PAGE_SIZE);
    80011b38:	e4843783          	ld	a5,-440(s0)
    80011b3c:	3187b683          	ld	a3,792(a5)
    80011b40:	fc043783          	ld	a5,-64(s0)
    80011b44:	07b2                	slli	a5,a5,0xc
    80011b46:	f7043703          	ld	a4,-144(s0)
    80011b4a:	97ba                	add	a5,a5,a4
    80011b4c:	85be                	mv	a1,a5
    80011b4e:	8536                	mv	a0,a3
    80011b50:	0e70e0ef          	jal	ra,80020436 <list_add>
    for (uint64_t i = 0; i < total_size / PAGE_SIZE; i++) {
    80011b54:	fc043783          	ld	a5,-64(s0)
    80011b58:	0785                	addi	a5,a5,1
    80011b5a:	fcf43023          	sd	a5,-64(s0)
    80011b5e:	f7843783          	ld	a5,-136(s0)
    80011b62:	83b1                	srli	a5,a5,0xc
    80011b64:	fc043703          	ld	a4,-64(s0)
    80011b68:	fcf768e3          	bltu	a4,a5,80011b38 <elf_create_process+0x84c>
    }

    // Allocate stack and heap
    if (!p->rcb.heap_pages) {
    80011b6c:	e4843783          	ld	a5,-440(s0)
    80011b70:	3287b783          	ld	a5,808(a5)
    80011b74:	eb81                	bnez	a5,80011b84 <elf_create_process+0x898>
        p->rcb.heap_pages = list_new();
    80011b76:	0910e0ef          	jal	ra,80020406 <list_new>
    80011b7a:	872a                	mv	a4,a0
    80011b7c:	e4843783          	ld	a5,-440(s0)
    80011b80:	32e7b423          	sd	a4,808(a5)
    }
    p->heap_size = DEFAULT_HEAP_SIZE;
    80011b84:	e4843783          	ld	a5,-440(s0)
    80011b88:	6741                	lui	a4,0x10
    80011b8a:	30e7b823          	sd	a4,784(a5)
    p->heap = page_nalloc(ALIGN_UP_POT(p->heap_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    80011b8e:	e4843783          	ld	a5,-440(s0)
    80011b92:	3107b703          	ld	a4,784(a5)
    80011b96:	6785                	lui	a5,0x1
    80011b98:	17fd                	addi	a5,a5,-1
    80011b9a:	97ba                	add	a5,a5,a4
    80011b9c:	83b1                	srli	a5,a5,0xc
    80011b9e:	2781                	sext.w	a5,a5
    80011ba0:	853e                	mv	a0,a5
    80011ba2:	2a80c0ef          	jal	ra,8001de4a <page_nalloc>
    80011ba6:	872a                	mv	a4,a0
    80011ba8:	e4843783          	ld	a5,-440(s0)
    80011bac:	30e7b023          	sd	a4,768(a5) # 1300 <i+0x12e0>
    
    memset(p->heap, 0, p->heap_size);
    80011bb0:	e4843783          	ld	a5,-440(s0)
    80011bb4:	3007b703          	ld	a4,768(a5)
    80011bb8:	e4843783          	ld	a5,-440(s0)
    80011bbc:	3107b783          	ld	a5,784(a5)
    80011bc0:	2781                	sext.w	a5,a5
    80011bc2:	863e                	mv	a2,a5
    80011bc4:	4581                	li	a1,0
    80011bc6:	853a                	mv	a0,a4
    80011bc8:	674100ef          	jal	ra,8002223c <memset>
    for (uint64_t i = 0; i < p->heap_size / PAGE_SIZE; i++) {
    80011bcc:	fa043c23          	sd	zero,-72(s0)
    80011bd0:	a035                	j	80011bfc <elf_create_process+0x910>
        list_add_ptr(p->rcb.heap_pages, p->heap + i * PAGE_SIZE);
    80011bd2:	e4843783          	ld	a5,-440(s0)
    80011bd6:	3287b683          	ld	a3,808(a5)
    80011bda:	e4843783          	ld	a5,-440(s0)
    80011bde:	3007b703          	ld	a4,768(a5)
    80011be2:	fb843783          	ld	a5,-72(s0)
    80011be6:	07b2                	slli	a5,a5,0xc
    80011be8:	97ba                	add	a5,a5,a4
    80011bea:	85be                	mv	a1,a5
    80011bec:	8536                	mv	a0,a3
    80011bee:	0490e0ef          	jal	ra,80020436 <list_add>
    for (uint64_t i = 0; i < p->heap_size / PAGE_SIZE; i++) {
    80011bf2:	fb843783          	ld	a5,-72(s0)
    80011bf6:	0785                	addi	a5,a5,1
    80011bf8:	faf43c23          	sd	a5,-72(s0)
    80011bfc:	e4843783          	ld	a5,-440(s0)
    80011c00:	3107b783          	ld	a5,784(a5)
    80011c04:	83b1                	srli	a5,a5,0xc
    80011c06:	fb843703          	ld	a4,-72(s0)
    80011c0a:	fcf764e3          	bltu	a4,a5,80011bd2 <elf_create_process+0x8e6>
    }

    if (!p->rcb.stack_pages) {
    80011c0e:	e4843783          	ld	a5,-440(s0)
    80011c12:	3207b783          	ld	a5,800(a5)
    80011c16:	eb81                	bnez	a5,80011c26 <elf_create_process+0x93a>
        p->rcb.stack_pages = list_new();
    80011c18:	7ee0e0ef          	jal	ra,80020406 <list_new>
    80011c1c:	872a                	mv	a4,a0
    80011c1e:	e4843783          	ld	a5,-440(s0)
    80011c22:	32e7b023          	sd	a4,800(a5)
    }
    p->stack_size = DEFAULT_STACK_SIZE;
    80011c26:	e4843783          	ld	a5,-440(s0)
    80011c2a:	6709                	lui	a4,0x2
    80011c2c:	2ee7bc23          	sd	a4,760(a5)
    p->stack = page_nalloc(ALIGN_UP_POT(p->stack_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    80011c30:	e4843783          	ld	a5,-440(s0)
    80011c34:	2f87b703          	ld	a4,760(a5)
    80011c38:	6785                	lui	a5,0x1
    80011c3a:	17fd                	addi	a5,a5,-1
    80011c3c:	97ba                	add	a5,a5,a4
    80011c3e:	83b1                	srli	a5,a5,0xc
    80011c40:	2781                	sext.w	a5,a5
    80011c42:	853e                	mv	a0,a5
    80011c44:	2060c0ef          	jal	ra,8001de4a <page_nalloc>
    80011c48:	872a                	mv	a4,a0
    80011c4a:	e4843783          	ld	a5,-440(s0)
    80011c4e:	2ee7b423          	sd	a4,744(a5) # 12e8 <i+0x12c8>
    memset(p->stack, 0, p->stack_size);
    80011c52:	e4843783          	ld	a5,-440(s0)
    80011c56:	2e87b703          	ld	a4,744(a5)
    80011c5a:	e4843783          	ld	a5,-440(s0)
    80011c5e:	2f87b783          	ld	a5,760(a5)
    80011c62:	2781                	sext.w	a5,a5
    80011c64:	863e                	mv	a2,a5
    80011c66:	4581                	li	a1,0
    80011c68:	853a                	mv	a0,a4
    80011c6a:	5d2100ef          	jal	ra,8002223c <memset>
    for (uint64_t i = 0; i < p->stack_size / PAGE_SIZE; i++) {
    80011c6e:	fa043823          	sd	zero,-80(s0)
    80011c72:	a035                	j	80011c9e <elf_create_process+0x9b2>
        list_add_ptr(p->rcb.stack_pages, p->stack + i * PAGE_SIZE);
    80011c74:	e4843783          	ld	a5,-440(s0)
    80011c78:	3207b683          	ld	a3,800(a5)
    80011c7c:	e4843783          	ld	a5,-440(s0)
    80011c80:	2e87b703          	ld	a4,744(a5)
    80011c84:	fb043783          	ld	a5,-80(s0)
    80011c88:	07b2                	slli	a5,a5,0xc
    80011c8a:	97ba                	add	a5,a5,a4
    80011c8c:	85be                	mv	a1,a5
    80011c8e:	8536                	mv	a0,a3
    80011c90:	7a60e0ef          	jal	ra,80020436 <list_add>
    for (uint64_t i = 0; i < p->stack_size / PAGE_SIZE; i++) {
    80011c94:	fb043783          	ld	a5,-80(s0)
    80011c98:	0785                	addi	a5,a5,1
    80011c9a:	faf43823          	sd	a5,-80(s0)
    80011c9e:	e4843783          	ld	a5,-440(s0)
    80011ca2:	2f87b783          	ld	a5,760(a5)
    80011ca6:	83b1                	srli	a5,a5,0xc
    80011ca8:	fb043703          	ld	a4,-80(s0)
    80011cac:	fcf764e3          	bltu	a4,a5,80011c74 <elf_create_process+0x988>
    }

    // Create the environment
    if (!p->rcb.environemnt) {
    80011cb0:	e4843783          	ld	a5,-440(s0)
    80011cb4:	3387b783          	ld	a5,824(a5)
    80011cb8:	eb81                	bnez	a5,80011cc8 <elf_create_process+0x9dc>
        p->rcb.environemnt = map_new();
    80011cba:	24c0f0ef          	jal	ra,80020f06 <map_new>
    80011cbe:	872a                	mv	a4,a0
    80011cc0:	e4843783          	ld	a5,-440(s0)
    80011cc4:	32e7bc23          	sd	a4,824(a5)
    }

    // Create the file descriptors
    if (!p->rcb.file_descriptors) {
    80011cc8:	e4843783          	ld	a5,-440(s0)
    80011ccc:	3307b783          	ld	a5,816(a5)
    80011cd0:	eb81                	bnez	a5,80011ce0 <elf_create_process+0x9f4>
        p->rcb.file_descriptors = list_new();
    80011cd2:	7340e0ef          	jal	ra,80020406 <list_new>
    80011cd6:	872a                	mv	a4,a0
    80011cd8:	e4843783          	ld	a5,-440(s0)
    80011cdc:	32e7b823          	sd	a4,816(a5)
    }

    // Set sepc of the process's trap frame
    p->frame.sepc = header.e_entry;
    80011ce0:	f4843703          	ld	a4,-184(s0)
    80011ce4:	e4843783          	ld	a5,-440(s0)
    80011ce8:	20e7b823          	sd	a4,528(a5)
    debugf("SEPC: %p\n", p->frame.sepc);
    return 0;
    80011cec:	4781                	li	a5,0
    80011cee:	853e                	mv	a0,a5
    80011cf0:	70fe                	ld	ra,504(sp)
    80011cf2:	745e                	ld	s0,496(sp)
    80011cf4:	20010113          	addi	sp,sp,512
    80011cf8:	8082                	ret

0000000080011cfa <_putchar>:
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#include "sbi.h"
void _putchar(char c) { sbi_putchar(c); }
    80011cfa:	1101                	addi	sp,sp,-32
    80011cfc:	ec06                	sd	ra,24(sp)
    80011cfe:	e822                	sd	s0,16(sp)
    80011d00:	1000                	addi	s0,sp,32
    80011d02:	87aa                	mv	a5,a0
    80011d04:	fef407a3          	sb	a5,-17(s0)
    80011d08:	fef44783          	lbu	a5,-17(s0)
    80011d0c:	853e                	mv	a0,a5
    80011d0e:	2f00a0ef          	jal	ra,8001bffe <sbi_putchar>
    80011d12:	0001                	nop
    80011d14:	60e2                	ld	ra,24(sp)
    80011d16:	6442                	ld	s0,16(sp)
    80011d18:	6105                	addi	sp,sp,32
    80011d1a:	8082                	ret

0000000080011d1c <_out_buffer>:
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx,
                               size_t maxlen)
{
    80011d1c:	7179                	addi	sp,sp,-48
    80011d1e:	f422                	sd	s0,40(sp)
    80011d20:	1800                	addi	s0,sp,48
    80011d22:	87aa                	mv	a5,a0
    80011d24:	feb43023          	sd	a1,-32(s0)
    80011d28:	fcc43c23          	sd	a2,-40(s0)
    80011d2c:	fcd43823          	sd	a3,-48(s0)
    80011d30:	fef407a3          	sb	a5,-17(s0)
    if (idx < maxlen) {
    80011d34:	fd843703          	ld	a4,-40(s0)
    80011d38:	fd043783          	ld	a5,-48(s0)
    80011d3c:	00f77b63          	bgeu	a4,a5,80011d52 <_out_buffer+0x36>
        ((char *)buffer)[idx] = character;
    80011d40:	fe043703          	ld	a4,-32(s0)
    80011d44:	fd843783          	ld	a5,-40(s0)
    80011d48:	97ba                	add	a5,a5,a4
    80011d4a:	fef44703          	lbu	a4,-17(s0)
    80011d4e:	00e78023          	sb	a4,0(a5)
    }
}
    80011d52:	0001                	nop
    80011d54:	7422                	ld	s0,40(sp)
    80011d56:	6145                	addi	sp,sp,48
    80011d58:	8082                	ret

0000000080011d5a <_out_null>:

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    80011d5a:	7179                	addi	sp,sp,-48
    80011d5c:	f422                	sd	s0,40(sp)
    80011d5e:	1800                	addi	s0,sp,48
    80011d60:	87aa                	mv	a5,a0
    80011d62:	feb43023          	sd	a1,-32(s0)
    80011d66:	fcc43c23          	sd	a2,-40(s0)
    80011d6a:	fcd43823          	sd	a3,-48(s0)
    80011d6e:	fef407a3          	sb	a5,-17(s0)
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}
    80011d72:	0001                	nop
    80011d74:	7422                	ld	s0,40(sp)
    80011d76:	6145                	addi	sp,sp,48
    80011d78:	8082                	ret

0000000080011d7a <_out_char>:

// internal _putchar wrapper
static inline void _out_char(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    80011d7a:	7179                	addi	sp,sp,-48
    80011d7c:	f406                	sd	ra,40(sp)
    80011d7e:	f022                	sd	s0,32(sp)
    80011d80:	1800                	addi	s0,sp,48
    80011d82:	87aa                	mv	a5,a0
    80011d84:	feb43023          	sd	a1,-32(s0)
    80011d88:	fcc43c23          	sd	a2,-40(s0)
    80011d8c:	fcd43823          	sd	a3,-48(s0)
    80011d90:	fef407a3          	sb	a5,-17(s0)
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
    80011d94:	fef44783          	lbu	a5,-17(s0)
    80011d98:	0ff7f793          	andi	a5,a5,255
    80011d9c:	c791                	beqz	a5,80011da8 <_out_char+0x2e>
        _putchar(character);
    80011d9e:	fef44783          	lbu	a5,-17(s0)
    80011da2:	853e                	mv	a0,a5
    80011da4:	f57ff0ef          	jal	ra,80011cfa <_putchar>
    }
}
    80011da8:	0001                	nop
    80011daa:	70a2                	ld	ra,40(sp)
    80011dac:	7402                	ld	s0,32(sp)
    80011dae:	6145                	addi	sp,sp,48
    80011db0:	8082                	ret

0000000080011db2 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx,
                            size_t maxlen)
{
    80011db2:	7179                	addi	sp,sp,-48
    80011db4:	f406                	sd	ra,40(sp)
    80011db6:	f022                	sd	s0,32(sp)
    80011db8:	1800                	addi	s0,sp,48
    80011dba:	87aa                	mv	a5,a0
    80011dbc:	feb43023          	sd	a1,-32(s0)
    80011dc0:	fcc43c23          	sd	a2,-40(s0)
    80011dc4:	fcd43823          	sd	a3,-48(s0)
    80011dc8:	fef407a3          	sb	a5,-17(s0)
    (void)idx;
    (void)maxlen;
    if (character) {
    80011dcc:	fef44783          	lbu	a5,-17(s0)
    80011dd0:	0ff7f793          	andi	a5,a5,255
    80011dd4:	cf81                	beqz	a5,80011dec <_out_fct+0x3a>
        // buffer is the output fct pointer
        ((out_fct_wrap_type *)buffer)
            ->fct(character, ((out_fct_wrap_type *)buffer)->arg);
    80011dd6:	fe043783          	ld	a5,-32(s0)
    80011dda:	6394                	ld	a3,0(a5)
        ((out_fct_wrap_type *)buffer)
    80011ddc:	fe043783          	ld	a5,-32(s0)
    80011de0:	6798                	ld	a4,8(a5)
    80011de2:	fef44783          	lbu	a5,-17(s0)
    80011de6:	85ba                	mv	a1,a4
    80011de8:	853e                	mv	a0,a5
    80011dea:	9682                	jalr	a3
    }
}
    80011dec:	0001                	nop
    80011dee:	70a2                	ld	ra,40(sp)
    80011df0:	7402                	ld	s0,32(sp)
    80011df2:	6145                	addi	sp,sp,48
    80011df4:	8082                	ret

0000000080011df6 <_strnlen_s>:

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize)
{
    80011df6:	7179                	addi	sp,sp,-48
    80011df8:	f422                	sd	s0,40(sp)
    80011dfa:	1800                	addi	s0,sp,48
    80011dfc:	fca43c23          	sd	a0,-40(s0)
    80011e00:	fcb43823          	sd	a1,-48(s0)
    const char *s;
    for (s = str; *s && maxsize--; ++s)
    80011e04:	fd843783          	ld	a5,-40(s0)
    80011e08:	fef43423          	sd	a5,-24(s0)
    80011e0c:	a031                	j	80011e18 <_strnlen_s+0x22>
    80011e0e:	fe843783          	ld	a5,-24(s0)
    80011e12:	0785                	addi	a5,a5,1
    80011e14:	fef43423          	sd	a5,-24(s0)
    80011e18:	fe843783          	ld	a5,-24(s0)
    80011e1c:	0007c783          	lbu	a5,0(a5)
    80011e20:	cb81                	beqz	a5,80011e30 <_strnlen_s+0x3a>
    80011e22:	fd043783          	ld	a5,-48(s0)
    80011e26:	fff78713          	addi	a4,a5,-1
    80011e2a:	fce43823          	sd	a4,-48(s0)
    80011e2e:	f3e5                	bnez	a5,80011e0e <_strnlen_s+0x18>
        ;
    return (unsigned int)(s - str);
    80011e30:	fe843703          	ld	a4,-24(s0)
    80011e34:	fd843783          	ld	a5,-40(s0)
    80011e38:	40f707b3          	sub	a5,a4,a5
    80011e3c:	2781                	sext.w	a5,a5
}
    80011e3e:	853e                	mv	a0,a5
    80011e40:	7422                	ld	s0,40(sp)
    80011e42:	6145                	addi	sp,sp,48
    80011e44:	8082                	ret

0000000080011e46 <_is_digit>:

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) { return (ch >= '0') && (ch <= '9'); }
    80011e46:	1101                	addi	sp,sp,-32
    80011e48:	ec22                	sd	s0,24(sp)
    80011e4a:	1000                	addi	s0,sp,32
    80011e4c:	87aa                	mv	a5,a0
    80011e4e:	fef407a3          	sb	a5,-17(s0)
    80011e52:	fef44783          	lbu	a5,-17(s0)
    80011e56:	0ff7f713          	andi	a4,a5,255
    80011e5a:	02f00793          	li	a5,47
    80011e5e:	00e7fc63          	bgeu	a5,a4,80011e76 <_is_digit+0x30>
    80011e62:	fef44783          	lbu	a5,-17(s0)
    80011e66:	0ff7f713          	andi	a4,a5,255
    80011e6a:	03900793          	li	a5,57
    80011e6e:	00e7e463          	bltu	a5,a4,80011e76 <_is_digit+0x30>
    80011e72:	4785                	li	a5,1
    80011e74:	a011                	j	80011e78 <_is_digit+0x32>
    80011e76:	4781                	li	a5,0
    80011e78:	8b85                	andi	a5,a5,1
    80011e7a:	0ff7f793          	andi	a5,a5,255
    80011e7e:	853e                	mv	a0,a5
    80011e80:	6462                	ld	s0,24(sp)
    80011e82:	6105                	addi	sp,sp,32
    80011e84:	8082                	ret

0000000080011e86 <_atoi>:

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str)
{
    80011e86:	7179                	addi	sp,sp,-48
    80011e88:	f406                	sd	ra,40(sp)
    80011e8a:	f022                	sd	s0,32(sp)
    80011e8c:	1800                	addi	s0,sp,48
    80011e8e:	fca43c23          	sd	a0,-40(s0)
    unsigned int i = 0U;
    80011e92:	fe042623          	sw	zero,-20(s0)
    while (_is_digit(**str)) {
    80011e96:	a825                	j	80011ece <_atoi+0x48>
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
    80011e98:	fec42703          	lw	a4,-20(s0)
    80011e9c:	87ba                	mv	a5,a4
    80011e9e:	0027979b          	slliw	a5,a5,0x2
    80011ea2:	9fb9                	addw	a5,a5,a4
    80011ea4:	0017979b          	slliw	a5,a5,0x1
    80011ea8:	0007871b          	sext.w	a4,a5
    80011eac:	fd843783          	ld	a5,-40(s0)
    80011eb0:	639c                	ld	a5,0(a5)
    80011eb2:	00178613          	addi	a2,a5,1
    80011eb6:	fd843683          	ld	a3,-40(s0)
    80011eba:	e290                	sd	a2,0(a3)
    80011ebc:	0007c783          	lbu	a5,0(a5)
    80011ec0:	2781                	sext.w	a5,a5
    80011ec2:	9fb9                	addw	a5,a5,a4
    80011ec4:	2781                	sext.w	a5,a5
    80011ec6:	fd07879b          	addiw	a5,a5,-48
    80011eca:	fef42623          	sw	a5,-20(s0)
    while (_is_digit(**str)) {
    80011ece:	fd843783          	ld	a5,-40(s0)
    80011ed2:	639c                	ld	a5,0(a5)
    80011ed4:	0007c783          	lbu	a5,0(a5)
    80011ed8:	853e                	mv	a0,a5
    80011eda:	f6dff0ef          	jal	ra,80011e46 <_is_digit>
    80011ede:	87aa                	mv	a5,a0
    80011ee0:	ffc5                	bnez	a5,80011e98 <_atoi+0x12>
    }
    return i;
    80011ee2:	fec42783          	lw	a5,-20(s0)
}
    80011ee6:	853e                	mv	a0,a5
    80011ee8:	70a2                	ld	ra,40(sp)
    80011eea:	7402                	ld	s0,32(sp)
    80011eec:	6145                	addi	sp,sp,48
    80011eee:	8082                	ret

0000000080011ef0 <_out_rev>:

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx,
                       size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags)
{
    80011ef0:	711d                	addi	sp,sp,-96
    80011ef2:	ec86                	sd	ra,88(sp)
    80011ef4:	e8a2                	sd	s0,80(sp)
    80011ef6:	1080                	addi	s0,sp,96
    80011ef8:	fca43c23          	sd	a0,-40(s0)
    80011efc:	fcb43823          	sd	a1,-48(s0)
    80011f00:	fcc43423          	sd	a2,-56(s0)
    80011f04:	fcd43023          	sd	a3,-64(s0)
    80011f08:	fae43c23          	sd	a4,-72(s0)
    80011f0c:	faf43823          	sd	a5,-80(s0)
    80011f10:	87c2                	mv	a5,a6
    80011f12:	8746                	mv	a4,a7
    80011f14:	faf42623          	sw	a5,-84(s0)
    80011f18:	87ba                	mv	a5,a4
    80011f1a:	faf42423          	sw	a5,-88(s0)
    const size_t start_idx = idx;
    80011f1e:	fc843783          	ld	a5,-56(s0)
    80011f22:	fef43023          	sd	a5,-32(s0)

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    80011f26:	fa842783          	lw	a5,-88(s0)
    80011f2a:	8b89                	andi	a5,a5,2
    80011f2c:	2781                	sext.w	a5,a5
    80011f2e:	e3c9                	bnez	a5,80011fb0 <_out_rev+0xc0>
    80011f30:	fa842783          	lw	a5,-88(s0)
    80011f34:	8b85                	andi	a5,a5,1
    80011f36:	2781                	sext.w	a5,a5
    80011f38:	efa5                	bnez	a5,80011fb0 <_out_rev+0xc0>
        for (size_t i = len; i < width; i++) {
    80011f3a:	fb043783          	ld	a5,-80(s0)
    80011f3e:	fef43423          	sd	a5,-24(s0)
    80011f42:	a035                	j	80011f6e <_out_rev+0x7e>
            out(' ', buffer, idx++, maxlen);
    80011f44:	fc843783          	ld	a5,-56(s0)
    80011f48:	00178713          	addi	a4,a5,1
    80011f4c:	fce43423          	sd	a4,-56(s0)
    80011f50:	fd843703          	ld	a4,-40(s0)
    80011f54:	fc043683          	ld	a3,-64(s0)
    80011f58:	863e                	mv	a2,a5
    80011f5a:	fd043583          	ld	a1,-48(s0)
    80011f5e:	02000513          	li	a0,32
    80011f62:	9702                	jalr	a4
        for (size_t i = len; i < width; i++) {
    80011f64:	fe843783          	ld	a5,-24(s0)
    80011f68:	0785                	addi	a5,a5,1
    80011f6a:	fef43423          	sd	a5,-24(s0)
    80011f6e:	fac46783          	lwu	a5,-84(s0)
    80011f72:	fe843703          	ld	a4,-24(s0)
    80011f76:	fcf767e3          	bltu	a4,a5,80011f44 <_out_rev+0x54>
        }
    }

    // reverse string
    while (len) {
    80011f7a:	a81d                	j	80011fb0 <_out_rev+0xc0>
        out(buf[--len], buffer, idx++, maxlen);
    80011f7c:	fb043783          	ld	a5,-80(s0)
    80011f80:	17fd                	addi	a5,a5,-1
    80011f82:	faf43823          	sd	a5,-80(s0)
    80011f86:	fb843703          	ld	a4,-72(s0)
    80011f8a:	fb043783          	ld	a5,-80(s0)
    80011f8e:	97ba                	add	a5,a5,a4
    80011f90:	0007c503          	lbu	a0,0(a5)
    80011f94:	fc843783          	ld	a5,-56(s0)
    80011f98:	00178713          	addi	a4,a5,1
    80011f9c:	fce43423          	sd	a4,-56(s0)
    80011fa0:	fd843703          	ld	a4,-40(s0)
    80011fa4:	fc043683          	ld	a3,-64(s0)
    80011fa8:	863e                	mv	a2,a5
    80011faa:	fd043583          	ld	a1,-48(s0)
    80011fae:	9702                	jalr	a4
    while (len) {
    80011fb0:	fb043783          	ld	a5,-80(s0)
    80011fb4:	f7e1                	bnez	a5,80011f7c <_out_rev+0x8c>
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
    80011fb6:	fa842783          	lw	a5,-88(s0)
    80011fba:	8b89                	andi	a5,a5,2
    80011fbc:	2781                	sext.w	a5,a5
    80011fbe:	cb9d                	beqz	a5,80011ff4 <_out_rev+0x104>
        while (idx - start_idx < width) {
    80011fc0:	a00d                	j	80011fe2 <_out_rev+0xf2>
            out(' ', buffer, idx++, maxlen);
    80011fc2:	fc843783          	ld	a5,-56(s0)
    80011fc6:	00178713          	addi	a4,a5,1
    80011fca:	fce43423          	sd	a4,-56(s0)
    80011fce:	fd843703          	ld	a4,-40(s0)
    80011fd2:	fc043683          	ld	a3,-64(s0)
    80011fd6:	863e                	mv	a2,a5
    80011fd8:	fd043583          	ld	a1,-48(s0)
    80011fdc:	02000513          	li	a0,32
    80011fe0:	9702                	jalr	a4
        while (idx - start_idx < width) {
    80011fe2:	fc843703          	ld	a4,-56(s0)
    80011fe6:	fe043783          	ld	a5,-32(s0)
    80011fea:	8f1d                	sub	a4,a4,a5
    80011fec:	fac46783          	lwu	a5,-84(s0)
    80011ff0:	fcf769e3          	bltu	a4,a5,80011fc2 <_out_rev+0xd2>
        }
    }

    return idx;
    80011ff4:	fc843783          	ld	a5,-56(s0)
}
    80011ff8:	853e                	mv	a0,a5
    80011ffa:	60e6                	ld	ra,88(sp)
    80011ffc:	6446                	ld	s0,80(sp)
    80011ffe:	6125                	addi	sp,sp,96
    80012000:	8082                	ret

0000000080012002 <_ntoa_format>:
// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx,
                           size_t maxlen, char *buf, size_t len, bool negative,
                           unsigned int base, unsigned int prec,
                           unsigned int width, unsigned int flags)
{
    80012002:	715d                	addi	sp,sp,-80
    80012004:	e486                	sd	ra,72(sp)
    80012006:	e0a2                	sd	s0,64(sp)
    80012008:	0880                	addi	s0,sp,80
    8001200a:	fea43423          	sd	a0,-24(s0)
    8001200e:	feb43023          	sd	a1,-32(s0)
    80012012:	fcc43c23          	sd	a2,-40(s0)
    80012016:	fcd43823          	sd	a3,-48(s0)
    8001201a:	fce43423          	sd	a4,-56(s0)
    8001201e:	fcf43023          	sd	a5,-64(s0)
    80012022:	87c2                	mv	a5,a6
    80012024:	8746                	mv	a4,a7
    80012026:	faf40fa3          	sb	a5,-65(s0)
    8001202a:	87ba                	mv	a5,a4
    8001202c:	faf42c23          	sw	a5,-72(s0)
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
    80012030:	481c                	lw	a5,16(s0)
    80012032:	8b89                	andi	a5,a5,2
    80012034:	2781                	sext.w	a5,a5
    80012036:	ebd1                	bnez	a5,800120ca <_ntoa_format+0xc8>
        if (width && (flags & FLAGS_ZEROPAD) &&
    80012038:	441c                	lw	a5,8(s0)
    8001203a:	2781                	sext.w	a5,a5
    8001203c:	cf9d                	beqz	a5,8001207a <_ntoa_format+0x78>
    8001203e:	481c                	lw	a5,16(s0)
    80012040:	8b85                	andi	a5,a5,1
    80012042:	2781                	sext.w	a5,a5
    80012044:	cb9d                	beqz	a5,8001207a <_ntoa_format+0x78>
    80012046:	fbf44783          	lbu	a5,-65(s0)
    8001204a:	0ff7f793          	andi	a5,a5,255
    8001204e:	e789                	bnez	a5,80012058 <_ntoa_format+0x56>
            (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80012050:	481c                	lw	a5,16(s0)
    80012052:	8bb1                	andi	a5,a5,12
    80012054:	2781                	sext.w	a5,a5
    80012056:	c395                	beqz	a5,8001207a <_ntoa_format+0x78>
            width--;
    80012058:	441c                	lw	a5,8(s0)
    8001205a:	37fd                	addiw	a5,a5,-1
    8001205c:	c41c                	sw	a5,8(s0)
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    8001205e:	a831                	j	8001207a <_ntoa_format+0x78>
            buf[len++] = '0';
    80012060:	fc043783          	ld	a5,-64(s0)
    80012064:	00178713          	addi	a4,a5,1
    80012068:	fce43023          	sd	a4,-64(s0)
    8001206c:	fc843703          	ld	a4,-56(s0)
    80012070:	97ba                	add	a5,a5,a4
    80012072:	03000713          	li	a4,48
    80012076:	00e78023          	sb	a4,0(a5)
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    8001207a:	00046783          	lwu	a5,0(s0)
    8001207e:	fc043703          	ld	a4,-64(s0)
    80012082:	02f77563          	bgeu	a4,a5,800120ac <_ntoa_format+0xaa>
    80012086:	fc043703          	ld	a4,-64(s0)
    8001208a:	47fd                	li	a5,31
    8001208c:	fce7fae3          	bgeu	a5,a4,80012060 <_ntoa_format+0x5e>
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    80012090:	a831                	j	800120ac <_ntoa_format+0xaa>
               (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
    80012092:	fc043783          	ld	a5,-64(s0)
    80012096:	00178713          	addi	a4,a5,1
    8001209a:	fce43023          	sd	a4,-64(s0)
    8001209e:	fc843703          	ld	a4,-56(s0)
    800120a2:	97ba                	add	a5,a5,a4
    800120a4:	03000713          	li	a4,48
    800120a8:	00e78023          	sb	a4,0(a5)
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    800120ac:	481c                	lw	a5,16(s0)
    800120ae:	8b85                	andi	a5,a5,1
    800120b0:	2781                	sext.w	a5,a5
    800120b2:	cf81                	beqz	a5,800120ca <_ntoa_format+0xc8>
    800120b4:	00846783          	lwu	a5,8(s0)
    800120b8:	fc043703          	ld	a4,-64(s0)
    800120bc:	00f77763          	bgeu	a4,a5,800120ca <_ntoa_format+0xc8>
    800120c0:	fc043703          	ld	a4,-64(s0)
    800120c4:	47fd                	li	a5,31
    800120c6:	fce7f6e3          	bgeu	a5,a4,80012092 <_ntoa_format+0x90>
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
    800120ca:	481c                	lw	a5,16(s0)
    800120cc:	8bc1                	andi	a5,a5,16
    800120ce:	2781                	sext.w	a5,a5
    800120d0:	12078363          	beqz	a5,800121f6 <_ntoa_format+0x1f4>
        if (!(flags & FLAGS_PRECISION) && len &&
    800120d4:	481c                	lw	a5,16(s0)
    800120d6:	4007f793          	andi	a5,a5,1024
    800120da:	2781                	sext.w	a5,a5
    800120dc:	e7a1                	bnez	a5,80012124 <_ntoa_format+0x122>
    800120de:	fc043783          	ld	a5,-64(s0)
    800120e2:	c3a9                	beqz	a5,80012124 <_ntoa_format+0x122>
            ((len == prec) || (len == width))) {
    800120e4:	00046783          	lwu	a5,0(s0)
        if (!(flags & FLAGS_PRECISION) && len &&
    800120e8:	fc043703          	ld	a4,-64(s0)
    800120ec:	00f70863          	beq	a4,a5,800120fc <_ntoa_format+0xfa>
            ((len == prec) || (len == width))) {
    800120f0:	00846783          	lwu	a5,8(s0)
    800120f4:	fc043703          	ld	a4,-64(s0)
    800120f8:	02f71663          	bne	a4,a5,80012124 <_ntoa_format+0x122>
            len--;
    800120fc:	fc043783          	ld	a5,-64(s0)
    80012100:	17fd                	addi	a5,a5,-1
    80012102:	fcf43023          	sd	a5,-64(s0)
            if (len && (base == 16U)) {
    80012106:	fc043783          	ld	a5,-64(s0)
    8001210a:	cf89                	beqz	a5,80012124 <_ntoa_format+0x122>
    8001210c:	fb842783          	lw	a5,-72(s0)
    80012110:	0007871b          	sext.w	a4,a5
    80012114:	47c1                	li	a5,16
    80012116:	00f71763          	bne	a4,a5,80012124 <_ntoa_format+0x122>
                len--;
    8001211a:	fc043783          	ld	a5,-64(s0)
    8001211e:	17fd                	addi	a5,a5,-1
    80012120:	fcf43023          	sd	a5,-64(s0)
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) &&
    80012124:	fb842783          	lw	a5,-72(s0)
    80012128:	0007871b          	sext.w	a4,a5
    8001212c:	47c1                	li	a5,16
    8001212e:	02f71a63          	bne	a4,a5,80012162 <_ntoa_format+0x160>
    80012132:	481c                	lw	a5,16(s0)
    80012134:	0207f793          	andi	a5,a5,32
    80012138:	2781                	sext.w	a5,a5
    8001213a:	e785                	bnez	a5,80012162 <_ntoa_format+0x160>
    8001213c:	fc043703          	ld	a4,-64(s0)
    80012140:	47fd                	li	a5,31
    80012142:	02e7e063          	bltu	a5,a4,80012162 <_ntoa_format+0x160>
            (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'x';
    80012146:	fc043783          	ld	a5,-64(s0)
    8001214a:	00178713          	addi	a4,a5,1
    8001214e:	fce43023          	sd	a4,-64(s0)
    80012152:	fc843703          	ld	a4,-56(s0)
    80012156:	97ba                	add	a5,a5,a4
    80012158:	07800713          	li	a4,120
    8001215c:	00e78023          	sb	a4,0(a5)
    80012160:	a88d                	j	800121d2 <_ntoa_format+0x1d0>
        }
        else if ((base == 16U) && (flags & FLAGS_UPPERCASE) &&
    80012162:	fb842783          	lw	a5,-72(s0)
    80012166:	0007871b          	sext.w	a4,a5
    8001216a:	47c1                	li	a5,16
    8001216c:	02f71a63          	bne	a4,a5,800121a0 <_ntoa_format+0x19e>
    80012170:	481c                	lw	a5,16(s0)
    80012172:	0207f793          	andi	a5,a5,32
    80012176:	2781                	sext.w	a5,a5
    80012178:	c785                	beqz	a5,800121a0 <_ntoa_format+0x19e>
    8001217a:	fc043703          	ld	a4,-64(s0)
    8001217e:	47fd                	li	a5,31
    80012180:	02e7e063          	bltu	a5,a4,800121a0 <_ntoa_format+0x19e>
                 (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'X';
    80012184:	fc043783          	ld	a5,-64(s0)
    80012188:	00178713          	addi	a4,a5,1
    8001218c:	fce43023          	sd	a4,-64(s0)
    80012190:	fc843703          	ld	a4,-56(s0)
    80012194:	97ba                	add	a5,a5,a4
    80012196:	05800713          	li	a4,88
    8001219a:	00e78023          	sb	a4,0(a5)
    8001219e:	a815                	j	800121d2 <_ntoa_format+0x1d0>
        }
        else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    800121a0:	fb842783          	lw	a5,-72(s0)
    800121a4:	0007871b          	sext.w	a4,a5
    800121a8:	4789                	li	a5,2
    800121aa:	02f71463          	bne	a4,a5,800121d2 <_ntoa_format+0x1d0>
    800121ae:	fc043703          	ld	a4,-64(s0)
    800121b2:	47fd                	li	a5,31
    800121b4:	00e7ef63          	bltu	a5,a4,800121d2 <_ntoa_format+0x1d0>
            buf[len++] = 'b';
    800121b8:	fc043783          	ld	a5,-64(s0)
    800121bc:	00178713          	addi	a4,a5,1
    800121c0:	fce43023          	sd	a4,-64(s0)
    800121c4:	fc843703          	ld	a4,-56(s0)
    800121c8:	97ba                	add	a5,a5,a4
    800121ca:	06200713          	li	a4,98
    800121ce:	00e78023          	sb	a4,0(a5)
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
    800121d2:	fc043703          	ld	a4,-64(s0)
    800121d6:	47fd                	li	a5,31
    800121d8:	00e7ef63          	bltu	a5,a4,800121f6 <_ntoa_format+0x1f4>
            buf[len++] = '0';
    800121dc:	fc043783          	ld	a5,-64(s0)
    800121e0:	00178713          	addi	a4,a5,1
    800121e4:	fce43023          	sd	a4,-64(s0)
    800121e8:	fc843703          	ld	a4,-56(s0)
    800121ec:	97ba                	add	a5,a5,a4
    800121ee:	03000713          	li	a4,48
    800121f2:	00e78023          	sb	a4,0(a5)
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
    800121f6:	fc043703          	ld	a4,-64(s0)
    800121fa:	47fd                	li	a5,31
    800121fc:	06e7e863          	bltu	a5,a4,8001226c <_ntoa_format+0x26a>
        if (negative) {
    80012200:	fbf44783          	lbu	a5,-65(s0)
    80012204:	0ff7f793          	andi	a5,a5,255
    80012208:	cf99                	beqz	a5,80012226 <_ntoa_format+0x224>
            buf[len++] = '-';
    8001220a:	fc043783          	ld	a5,-64(s0)
    8001220e:	00178713          	addi	a4,a5,1
    80012212:	fce43023          	sd	a4,-64(s0)
    80012216:	fc843703          	ld	a4,-56(s0)
    8001221a:	97ba                	add	a5,a5,a4
    8001221c:	02d00713          	li	a4,45
    80012220:	00e78023          	sb	a4,0(a5)
    80012224:	a0a1                	j	8001226c <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_PLUS) {
    80012226:	481c                	lw	a5,16(s0)
    80012228:	8b91                	andi	a5,a5,4
    8001222a:	2781                	sext.w	a5,a5
    8001222c:	cf99                	beqz	a5,8001224a <_ntoa_format+0x248>
            buf[len++] = '+';  // ignore the space if the '+' exists
    8001222e:	fc043783          	ld	a5,-64(s0)
    80012232:	00178713          	addi	a4,a5,1
    80012236:	fce43023          	sd	a4,-64(s0)
    8001223a:	fc843703          	ld	a4,-56(s0)
    8001223e:	97ba                	add	a5,a5,a4
    80012240:	02b00713          	li	a4,43
    80012244:	00e78023          	sb	a4,0(a5)
    80012248:	a015                	j	8001226c <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_SPACE) {
    8001224a:	481c                	lw	a5,16(s0)
    8001224c:	8ba1                	andi	a5,a5,8
    8001224e:	2781                	sext.w	a5,a5
    80012250:	cf91                	beqz	a5,8001226c <_ntoa_format+0x26a>
            buf[len++] = ' ';
    80012252:	fc043783          	ld	a5,-64(s0)
    80012256:	00178713          	addi	a4,a5,1
    8001225a:	fce43023          	sd	a4,-64(s0)
    8001225e:	fc843703          	ld	a4,-56(s0)
    80012262:	97ba                	add	a5,a5,a4
    80012264:	02000713          	li	a4,32
    80012268:	00e78023          	sb	a4,0(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    8001226c:	4818                	lw	a4,16(s0)
    8001226e:	441c                	lw	a5,8(s0)
    80012270:	88ba                	mv	a7,a4
    80012272:	883e                	mv	a6,a5
    80012274:	fc043783          	ld	a5,-64(s0)
    80012278:	fc843703          	ld	a4,-56(s0)
    8001227c:	fd043683          	ld	a3,-48(s0)
    80012280:	fd843603          	ld	a2,-40(s0)
    80012284:	fe043583          	ld	a1,-32(s0)
    80012288:	fe843503          	ld	a0,-24(s0)
    8001228c:	c65ff0ef          	jal	ra,80011ef0 <_out_rev>
    80012290:	87aa                	mv	a5,a0
}
    80012292:	853e                	mv	a0,a5
    80012294:	60a6                	ld	ra,72(sp)
    80012296:	6406                	ld	s0,64(sp)
    80012298:	6161                	addi	sp,sp,80
    8001229a:	8082                	ret

000000008001229c <_ntoa_long>:
// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
                         size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec,
                         unsigned int width, unsigned int flags)
{
    8001229c:	7135                	addi	sp,sp,-160
    8001229e:	ed06                	sd	ra,152(sp)
    800122a0:	e922                	sd	s0,144(sp)
    800122a2:	1100                	addi	s0,sp,160
    800122a4:	faa43c23          	sd	a0,-72(s0)
    800122a8:	fab43823          	sd	a1,-80(s0)
    800122ac:	fac43423          	sd	a2,-88(s0)
    800122b0:	fad43023          	sd	a3,-96(s0)
    800122b4:	f8e43c23          	sd	a4,-104(s0)
    800122b8:	f9043423          	sd	a6,-120(s0)
    800122bc:	8746                	mv	a4,a7
    800122be:	f8f40ba3          	sb	a5,-105(s0)
    800122c2:	87ba                	mv	a5,a4
    800122c4:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    800122c8:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    800122cc:	f9843783          	ld	a5,-104(s0)
    800122d0:	e781                	bnez	a5,800122d8 <_ntoa_long+0x3c>
        flags &= ~FLAGS_HASH;
    800122d2:	441c                	lw	a5,8(s0)
    800122d4:	9bbd                	andi	a5,a5,-17
    800122d6:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    800122d8:	441c                	lw	a5,8(s0)
    800122da:	4007f793          	andi	a5,a5,1024
    800122de:	2781                	sext.w	a5,a5
    800122e0:	c781                	beqz	a5,800122e8 <_ntoa_long+0x4c>
    800122e2:	f9843783          	ld	a5,-104(s0)
    800122e6:	c7c1                	beqz	a5,8001236e <_ntoa_long+0xd2>
        do {
            const char digit = (char)(value % base);
    800122e8:	f9843703          	ld	a4,-104(s0)
    800122ec:	f8843783          	ld	a5,-120(s0)
    800122f0:	02f777b3          	remu	a5,a4,a5
    800122f4:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    800122f8:	fe744783          	lbu	a5,-25(s0)
    800122fc:	0ff7f713          	andi	a4,a5,255
    80012300:	47a5                	li	a5,9
    80012302:	00e7e963          	bltu	a5,a4,80012314 <_ntoa_long+0x78>
    80012306:	fe744783          	lbu	a5,-25(s0)
    8001230a:	0307879b          	addiw	a5,a5,48
    8001230e:	0ff7f793          	andi	a5,a5,255
    80012312:	a01d                	j	80012338 <_ntoa_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    80012314:	441c                	lw	a5,8(s0)
    80012316:	0207f793          	andi	a5,a5,32
    8001231a:	2781                	sext.w	a5,a5
    8001231c:	c781                	beqz	a5,80012324 <_ntoa_long+0x88>
    8001231e:	04100793          	li	a5,65
    80012322:	a019                	j	80012328 <_ntoa_long+0x8c>
    80012324:	06100793          	li	a5,97
    80012328:	fe744703          	lbu	a4,-25(s0)
    8001232c:	9fb9                	addw	a5,a5,a4
    8001232e:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80012332:	37d9                	addiw	a5,a5,-10
    80012334:	0ff7f793          	andi	a5,a5,255
    80012338:	fe843703          	ld	a4,-24(s0)
    8001233c:	00170693          	addi	a3,a4,1 # 2001 <i+0x1fe1>
    80012340:	fed43423          	sd	a3,-24(s0)
    80012344:	ff040693          	addi	a3,s0,-16
    80012348:	9736                	add	a4,a4,a3
    8001234a:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    8001234e:	f9843703          	ld	a4,-104(s0)
    80012352:	f8843783          	ld	a5,-120(s0)
    80012356:	02f757b3          	divu	a5,a4,a5
    8001235a:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    8001235e:	f9843783          	ld	a5,-104(s0)
    80012362:	c791                	beqz	a5,8001236e <_ntoa_long+0xd2>
    80012364:	fe843703          	ld	a4,-24(s0)
    80012368:	47fd                	li	a5,31
    8001236a:	f6e7ffe3          	bgeu	a5,a4,800122e8 <_ntoa_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    8001236e:	f8843783          	ld	a5,-120(s0)
    80012372:	0007861b          	sext.w	a2,a5
    80012376:	f9744683          	lbu	a3,-105(s0)
    8001237a:	fc040713          	addi	a4,s0,-64
    8001237e:	441c                	lw	a5,8(s0)
    80012380:	e83e                	sd	a5,16(sp)
    80012382:	401c                	lw	a5,0(s0)
    80012384:	e43e                	sd	a5,8(sp)
    80012386:	f9042783          	lw	a5,-112(s0)
    8001238a:	e03e                	sd	a5,0(sp)
    8001238c:	88b2                	mv	a7,a2
    8001238e:	8836                	mv	a6,a3
    80012390:	fe843783          	ld	a5,-24(s0)
    80012394:	fa043683          	ld	a3,-96(s0)
    80012398:	fa843603          	ld	a2,-88(s0)
    8001239c:	fb043583          	ld	a1,-80(s0)
    800123a0:	fb843503          	ld	a0,-72(s0)
    800123a4:	c5fff0ef          	jal	ra,80012002 <_ntoa_format>
    800123a8:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    800123aa:	853e                	mv	a0,a5
    800123ac:	60ea                	ld	ra,152(sp)
    800123ae:	644a                	ld	s0,144(sp)
    800123b0:	610d                	addi	sp,sp,160
    800123b2:	8082                	ret

00000000800123b4 <_ntoa_long_long>:
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
                              size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base,
                              unsigned int prec, unsigned int width,
                              unsigned int flags)
{
    800123b4:	7135                	addi	sp,sp,-160
    800123b6:	ed06                	sd	ra,152(sp)
    800123b8:	e922                	sd	s0,144(sp)
    800123ba:	1100                	addi	s0,sp,160
    800123bc:	faa43c23          	sd	a0,-72(s0)
    800123c0:	fab43823          	sd	a1,-80(s0)
    800123c4:	fac43423          	sd	a2,-88(s0)
    800123c8:	fad43023          	sd	a3,-96(s0)
    800123cc:	f8e43c23          	sd	a4,-104(s0)
    800123d0:	f9043423          	sd	a6,-120(s0)
    800123d4:	8746                	mv	a4,a7
    800123d6:	f8f40ba3          	sb	a5,-105(s0)
    800123da:	87ba                	mv	a5,a4
    800123dc:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    800123e0:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    800123e4:	f9843783          	ld	a5,-104(s0)
    800123e8:	e781                	bnez	a5,800123f0 <_ntoa_long_long+0x3c>
        flags &= ~FLAGS_HASH;
    800123ea:	441c                	lw	a5,8(s0)
    800123ec:	9bbd                	andi	a5,a5,-17
    800123ee:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    800123f0:	441c                	lw	a5,8(s0)
    800123f2:	4007f793          	andi	a5,a5,1024
    800123f6:	2781                	sext.w	a5,a5
    800123f8:	c781                	beqz	a5,80012400 <_ntoa_long_long+0x4c>
    800123fa:	f9843783          	ld	a5,-104(s0)
    800123fe:	c7c1                	beqz	a5,80012486 <_ntoa_long_long+0xd2>
        do {
            const char digit = (char)(value % base);
    80012400:	f9843703          	ld	a4,-104(s0)
    80012404:	f8843783          	ld	a5,-120(s0)
    80012408:	02f777b3          	remu	a5,a4,a5
    8001240c:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    80012410:	fe744783          	lbu	a5,-25(s0)
    80012414:	0ff7f713          	andi	a4,a5,255
    80012418:	47a5                	li	a5,9
    8001241a:	00e7e963          	bltu	a5,a4,8001242c <_ntoa_long_long+0x78>
    8001241e:	fe744783          	lbu	a5,-25(s0)
    80012422:	0307879b          	addiw	a5,a5,48
    80012426:	0ff7f793          	andi	a5,a5,255
    8001242a:	a01d                	j	80012450 <_ntoa_long_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    8001242c:	441c                	lw	a5,8(s0)
    8001242e:	0207f793          	andi	a5,a5,32
    80012432:	2781                	sext.w	a5,a5
    80012434:	c781                	beqz	a5,8001243c <_ntoa_long_long+0x88>
    80012436:	04100793          	li	a5,65
    8001243a:	a019                	j	80012440 <_ntoa_long_long+0x8c>
    8001243c:	06100793          	li	a5,97
    80012440:	fe744703          	lbu	a4,-25(s0)
    80012444:	9fb9                	addw	a5,a5,a4
    80012446:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    8001244a:	37d9                	addiw	a5,a5,-10
    8001244c:	0ff7f793          	andi	a5,a5,255
    80012450:	fe843703          	ld	a4,-24(s0)
    80012454:	00170693          	addi	a3,a4,1
    80012458:	fed43423          	sd	a3,-24(s0)
    8001245c:	ff040693          	addi	a3,s0,-16
    80012460:	9736                	add	a4,a4,a3
    80012462:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80012466:	f9843703          	ld	a4,-104(s0)
    8001246a:	f8843783          	ld	a5,-120(s0)
    8001246e:	02f757b3          	divu	a5,a4,a5
    80012472:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80012476:	f9843783          	ld	a5,-104(s0)
    8001247a:	c791                	beqz	a5,80012486 <_ntoa_long_long+0xd2>
    8001247c:	fe843703          	ld	a4,-24(s0)
    80012480:	47fd                	li	a5,31
    80012482:	f6e7ffe3          	bgeu	a5,a4,80012400 <_ntoa_long_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80012486:	f8843783          	ld	a5,-120(s0)
    8001248a:	0007861b          	sext.w	a2,a5
    8001248e:	f9744683          	lbu	a3,-105(s0)
    80012492:	fc040713          	addi	a4,s0,-64
    80012496:	441c                	lw	a5,8(s0)
    80012498:	e83e                	sd	a5,16(sp)
    8001249a:	401c                	lw	a5,0(s0)
    8001249c:	e43e                	sd	a5,8(sp)
    8001249e:	f9042783          	lw	a5,-112(s0)
    800124a2:	e03e                	sd	a5,0(sp)
    800124a4:	88b2                	mv	a7,a2
    800124a6:	8836                	mv	a6,a3
    800124a8:	fe843783          	ld	a5,-24(s0)
    800124ac:	fa043683          	ld	a3,-96(s0)
    800124b0:	fa843603          	ld	a2,-88(s0)
    800124b4:	fb043583          	ld	a1,-80(s0)
    800124b8:	fb843503          	ld	a0,-72(s0)
    800124bc:	b47ff0ef          	jal	ra,80012002 <_ntoa_format>
    800124c0:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    800124c2:	853e                	mv	a0,a5
    800124c4:	60ea                	ld	ra,152(sp)
    800124c6:	644a                	ld	s0,144(sp)
    800124c8:	610d                	addi	sp,sp,160
    800124ca:	8082                	ret

00000000800124cc <_ftoa>:

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    800124cc:	7135                	addi	sp,sp,-160
    800124ce:	ed06                	sd	ra,152(sp)
    800124d0:	e922                	sd	s0,144(sp)
    800124d2:	1100                	addi	s0,sp,160
    800124d4:	f8a43c23          	sd	a0,-104(s0)
    800124d8:	f8b43823          	sd	a1,-112(s0)
    800124dc:	f8c43423          	sd	a2,-120(s0)
    800124e0:	f8d43023          	sd	a3,-128(s0)
    800124e4:	f6a43c27          	fsd	fa0,-136(s0)
    800124e8:	863a                	mv	a2,a4
    800124ea:	86be                	mv	a3,a5
    800124ec:	8742                	mv	a4,a6
    800124ee:	87b2                	mv	a5,a2
    800124f0:	f6f42a23          	sw	a5,-140(s0)
    800124f4:	87b6                	mv	a5,a3
    800124f6:	f6f42823          	sw	a5,-144(s0)
    800124fa:	87ba                	mv	a5,a4
    800124fc:	f6f42623          	sw	a5,-148(s0)
    char buf[PRINTF_FTOA_BUFFER_SIZE];
    size_t len                  = 0U;
    80012500:	fe043423          	sd	zero,-24(s0)
    double diff                 = 0.0;
    80012504:	fc043423          	sd	zero,-56(s0)
    static const double pow10[] = {1,         10,        100,     1000,
                                   10000,     100000,    1000000, 10000000,
                                   100000000, 1000000000};

    // test for special values
    if (value != value)
    80012508:	f7843707          	fld	fa4,-136(s0)
    8001250c:	f7843787          	fld	fa5,-136(s0)
    80012510:	a2f727d3          	feq.d	a5,fa4,fa5
    80012514:	eb85                	bnez	a5,80012544 <_ftoa+0x78>
        return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
    80012516:	f6c42703          	lw	a4,-148(s0)
    8001251a:	f7042783          	lw	a5,-144(s0)
    8001251e:	88ba                	mv	a7,a4
    80012520:	883e                	mv	a6,a5
    80012522:	478d                	li	a5,3
    80012524:	00014717          	auipc	a4,0x14
    80012528:	73c70713          	addi	a4,a4,1852 # 80026c60 <SYSCALLS+0xc30>
    8001252c:	f8043683          	ld	a3,-128(s0)
    80012530:	f8843603          	ld	a2,-120(s0)
    80012534:	f9043583          	ld	a1,-112(s0)
    80012538:	f9843503          	ld	a0,-104(s0)
    8001253c:	9b5ff0ef          	jal	ra,80011ef0 <_out_rev>
    80012540:	87aa                	mv	a5,a0
    80012542:	a1f1                	j	80012a0e <_ftoa+0x542>
    if (value < -DBL_MAX)
    80012544:	f7843707          	fld	fa4,-136(s0)
    80012548:	00015797          	auipc	a5,0x15
    8001254c:	96878793          	addi	a5,a5,-1688 # 80026eb0 <pow10.0+0x50>
    80012550:	239c                	fld	fa5,0(a5)
    80012552:	a2f717d3          	flt.d	a5,fa4,fa5
    80012556:	cb85                	beqz	a5,80012586 <_ftoa+0xba>
        return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    80012558:	f6c42703          	lw	a4,-148(s0)
    8001255c:	f7042783          	lw	a5,-144(s0)
    80012560:	88ba                	mv	a7,a4
    80012562:	883e                	mv	a6,a5
    80012564:	4791                	li	a5,4
    80012566:	00014717          	auipc	a4,0x14
    8001256a:	70270713          	addi	a4,a4,1794 # 80026c68 <SYSCALLS+0xc38>
    8001256e:	f8043683          	ld	a3,-128(s0)
    80012572:	f8843603          	ld	a2,-120(s0)
    80012576:	f9043583          	ld	a1,-112(s0)
    8001257a:	f9843503          	ld	a0,-104(s0)
    8001257e:	973ff0ef          	jal	ra,80011ef0 <_out_rev>
    80012582:	87aa                	mv	a5,a0
    80012584:	a169                	j	80012a0e <_ftoa+0x542>
    if (value > DBL_MAX)
    80012586:	f7843707          	fld	fa4,-136(s0)
    8001258a:	00015797          	auipc	a5,0x15
    8001258e:	92e78793          	addi	a5,a5,-1746 # 80026eb8 <pow10.0+0x58>
    80012592:	239c                	fld	fa5,0(a5)
    80012594:	a2e797d3          	flt.d	a5,fa5,fa4
    80012598:	cba9                	beqz	a5,800125ea <_ftoa+0x11e>
        return _out_rev(out, buffer, idx, maxlen,
                        (flags & FLAGS_PLUS) ? "fni+" : "fni",
    8001259a:	f6c42783          	lw	a5,-148(s0)
    8001259e:	8b91                	andi	a5,a5,4
    800125a0:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    800125a2:	c791                	beqz	a5,800125ae <_ftoa+0xe2>
    800125a4:	00014717          	auipc	a4,0x14
    800125a8:	6cc70713          	addi	a4,a4,1740 # 80026c70 <SYSCALLS+0xc40>
    800125ac:	a029                	j	800125b6 <_ftoa+0xea>
    800125ae:	00014717          	auipc	a4,0x14
    800125b2:	6ca70713          	addi	a4,a4,1738 # 80026c78 <SYSCALLS+0xc48>
                        (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
    800125b6:	f6c42783          	lw	a5,-148(s0)
    800125ba:	8b91                	andi	a5,a5,4
    800125bc:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    800125be:	c399                	beqz	a5,800125c4 <_ftoa+0xf8>
    800125c0:	4791                	li	a5,4
    800125c2:	a011                	j	800125c6 <_ftoa+0xfa>
    800125c4:	478d                	li	a5,3
    800125c6:	f6c42603          	lw	a2,-148(s0)
    800125ca:	f7042683          	lw	a3,-144(s0)
    800125ce:	88b2                	mv	a7,a2
    800125d0:	8836                	mv	a6,a3
    800125d2:	f8043683          	ld	a3,-128(s0)
    800125d6:	f8843603          	ld	a2,-120(s0)
    800125da:	f9043583          	ld	a1,-112(s0)
    800125de:	f9843503          	ld	a0,-104(s0)
    800125e2:	90fff0ef          	jal	ra,80011ef0 <_out_rev>
    800125e6:	87aa                	mv	a5,a0
    800125e8:	a11d                	j	80012a0e <_ftoa+0x542>

    // test for very large values
    // standard printf behavior is to print EVERY whole number digit -- which
    // could be 100s of characters overflowing your buffers == bad
    if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
    800125ea:	f7843707          	fld	fa4,-136(s0)
    800125ee:	00015797          	auipc	a5,0x15
    800125f2:	8d278793          	addi	a5,a5,-1838 # 80026ec0 <pow10.0+0x60>
    800125f6:	239c                	fld	fa5,0(a5)
    800125f8:	a2e797d3          	flt.d	a5,fa5,fa4
    800125fc:	eb99                	bnez	a5,80012612 <_ftoa+0x146>
    800125fe:	f7843707          	fld	fa4,-136(s0)
    80012602:	00015797          	auipc	a5,0x15
    80012606:	8c678793          	addi	a5,a5,-1850 # 80026ec8 <pow10.0+0x68>
    8001260a:	239c                	fld	fa5,0(a5)
    8001260c:	a2f717d3          	flt.d	a5,fa4,fa5
    80012610:	c795                	beqz	a5,8001263c <_ftoa+0x170>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80012612:	f6c42683          	lw	a3,-148(s0)
    80012616:	f7042783          	lw	a5,-144(s0)
    8001261a:	f7442703          	lw	a4,-140(s0)
    8001261e:	8836                	mv	a6,a3
    80012620:	f7843507          	fld	fa0,-136(s0)
    80012624:	f8043683          	ld	a3,-128(s0)
    80012628:	f8843603          	ld	a2,-120(s0)
    8001262c:	f9043583          	ld	a1,-112(s0)
    80012630:	f9843503          	ld	a0,-104(s0)
    80012634:	3e4000ef          	jal	ra,80012a18 <_etoa>
    80012638:	87aa                	mv	a5,a0
    8001263a:	aed1                	j	80012a0e <_ftoa+0x542>
        return 0U;
#endif
    }

    // test for negative
    bool negative = false;
    8001263c:	fe0403a3          	sb	zero,-25(s0)
    if (value < 0) {
    80012640:	f7843787          	fld	fa5,-136(s0)
    80012644:	f2000753          	fmv.d.x	fa4,zero
    80012648:	a2e797d3          	flt.d	a5,fa5,fa4
    8001264c:	cf81                	beqz	a5,80012664 <_ftoa+0x198>
        negative = true;
    8001264e:	4785                	li	a5,1
    80012650:	fef403a3          	sb	a5,-25(s0)
        value    = 0 - value;
    80012654:	f2000753          	fmv.d.x	fa4,zero
    80012658:	f7843787          	fld	fa5,-136(s0)
    8001265c:	0af777d3          	fsub.d	fa5,fa4,fa5
    80012660:	f6f43c27          	fsd	fa5,-136(s0)
    }

    // set default precision, if not set explicitly
    if (!(flags & FLAGS_PRECISION)) {
    80012664:	f6c42783          	lw	a5,-148(s0)
    80012668:	4007f793          	andi	a5,a5,1024
    8001266c:	2781                	sext.w	a5,a5
    8001266e:	e79d                	bnez	a5,8001269c <_ftoa+0x1d0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80012670:	4799                	li	a5,6
    80012672:	f6f42a23          	sw	a5,-140(s0)
    }
    // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80012676:	a01d                	j	8001269c <_ftoa+0x1d0>
        buf[len++] = '0';
    80012678:	fe843783          	ld	a5,-24(s0)
    8001267c:	00178713          	addi	a4,a5,1
    80012680:	fee43423          	sd	a4,-24(s0)
    80012684:	ff040713          	addi	a4,s0,-16
    80012688:	97ba                	add	a5,a5,a4
    8001268a:	03000713          	li	a4,48
    8001268e:	fae78823          	sb	a4,-80(a5)
        prec--;
    80012692:	f7442783          	lw	a5,-140(s0)
    80012696:	37fd                	addiw	a5,a5,-1
    80012698:	f6f42a23          	sw	a5,-140(s0)
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    8001269c:	fe843703          	ld	a4,-24(s0)
    800126a0:	47fd                	li	a5,31
    800126a2:	00e7e963          	bltu	a5,a4,800126b4 <_ftoa+0x1e8>
    800126a6:	f7442783          	lw	a5,-140(s0)
    800126aa:	0007871b          	sext.w	a4,a5
    800126ae:	47a5                	li	a5,9
    800126b0:	fce7e4e3          	bltu	a5,a4,80012678 <_ftoa+0x1ac>
    }

    int whole          = (int)value;
    800126b4:	f7843787          	fld	fa5,-136(s0)
    800126b8:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    800126bc:	fef42023          	sw	a5,-32(s0)
    double tmp         = (value - whole) * pow10[prec];
    800126c0:	fe042783          	lw	a5,-32(s0)
    800126c4:	d20787d3          	fcvt.d.w	fa5,a5
    800126c8:	f7843707          	fld	fa4,-136(s0)
    800126cc:	0af77753          	fsub.d	fa4,fa4,fa5
    800126d0:	00014717          	auipc	a4,0x14
    800126d4:	79070713          	addi	a4,a4,1936 # 80026e60 <pow10.0>
    800126d8:	f7446783          	lwu	a5,-140(s0)
    800126dc:	078e                	slli	a5,a5,0x3
    800126de:	97ba                	add	a5,a5,a4
    800126e0:	239c                	fld	fa5,0(a5)
    800126e2:	12f777d3          	fmul.d	fa5,fa4,fa5
    800126e6:	fcf43027          	fsd	fa5,-64(s0)
    unsigned long frac = (unsigned long)tmp;
    800126ea:	fc043787          	fld	fa5,-64(s0)
    800126ee:	c23797d3          	fcvt.lu.d	a5,fa5,rtz
    800126f2:	fcf43c23          	sd	a5,-40(s0)
    diff               = tmp - frac;
    800126f6:	fd843783          	ld	a5,-40(s0)
    800126fa:	d237f7d3          	fcvt.d.lu	fa5,a5
    800126fe:	fc043707          	fld	fa4,-64(s0)
    80012702:	0af777d3          	fsub.d	fa5,fa4,fa5
    80012706:	fcf43427          	fsd	fa5,-56(s0)

    if (diff > 0.5) {
    8001270a:	fc843707          	fld	fa4,-56(s0)
    8001270e:	00014797          	auipc	a5,0x14
    80012712:	7c278793          	addi	a5,a5,1986 # 80026ed0 <pow10.0+0x70>
    80012716:	239c                	fld	fa5,0(a5)
    80012718:	a2e797d3          	flt.d	a5,fa5,fa4
    8001271c:	cf95                	beqz	a5,80012758 <_ftoa+0x28c>
        ++frac;
    8001271e:	fd843783          	ld	a5,-40(s0)
    80012722:	0785                	addi	a5,a5,1
    80012724:	fcf43c23          	sd	a5,-40(s0)
        // handle rollover, e.g. case 0.99 with prec 1 is 1.0
        if (frac >= pow10[prec]) {
    80012728:	fd843783          	ld	a5,-40(s0)
    8001272c:	d237f753          	fcvt.d.lu	fa4,a5
    80012730:	00014717          	auipc	a4,0x14
    80012734:	73070713          	addi	a4,a4,1840 # 80026e60 <pow10.0>
    80012738:	f7446783          	lwu	a5,-140(s0)
    8001273c:	078e                	slli	a5,a5,0x3
    8001273e:	97ba                	add	a5,a5,a4
    80012740:	239c                	fld	fa5,0(a5)
    80012742:	a2e787d3          	fle.d	a5,fa5,fa4
    80012746:	cf9d                	beqz	a5,80012784 <_ftoa+0x2b8>
            frac = 0;
    80012748:	fc043c23          	sd	zero,-40(s0)
            ++whole;
    8001274c:	fe042783          	lw	a5,-32(s0)
    80012750:	2785                	addiw	a5,a5,1
    80012752:	fef42023          	sw	a5,-32(s0)
    80012756:	a03d                	j	80012784 <_ftoa+0x2b8>
        }
    }
    else if (diff < 0.5) {
    80012758:	fc843707          	fld	fa4,-56(s0)
    8001275c:	00014797          	auipc	a5,0x14
    80012760:	77478793          	addi	a5,a5,1908 # 80026ed0 <pow10.0+0x70>
    80012764:	239c                	fld	fa5,0(a5)
    80012766:	a2f717d3          	flt.d	a5,fa4,fa5
    8001276a:	ef89                	bnez	a5,80012784 <_ftoa+0x2b8>
    }
    else if ((frac == 0U) || (frac & 1U)) {
    8001276c:	fd843783          	ld	a5,-40(s0)
    80012770:	c789                	beqz	a5,8001277a <_ftoa+0x2ae>
    80012772:	fd843783          	ld	a5,-40(s0)
    80012776:	8b85                	andi	a5,a5,1
    80012778:	c791                	beqz	a5,80012784 <_ftoa+0x2b8>
        // if halfway, round up if odd OR if last digit is 0
        ++frac;
    8001277a:	fd843783          	ld	a5,-40(s0)
    8001277e:	0785                	addi	a5,a5,1
    80012780:	fcf43c23          	sd	a5,-40(s0)
    }

    if (prec == 0U) {
    80012784:	f7442783          	lw	a5,-140(s0)
    80012788:	2781                	sext.w	a5,a5
    8001278a:	e3bd                	bnez	a5,800127f0 <_ftoa+0x324>
        diff = value - (double)whole;
    8001278c:	fe042783          	lw	a5,-32(s0)
    80012790:	d20787d3          	fcvt.d.w	fa5,a5
    80012794:	f7843707          	fld	fa4,-136(s0)
    80012798:	0af777d3          	fsub.d	fa5,fa4,fa5
    8001279c:	fcf43427          	fsd	fa5,-56(s0)
        if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    800127a0:	fc843707          	fld	fa4,-56(s0)
    800127a4:	00014797          	auipc	a5,0x14
    800127a8:	72c78793          	addi	a5,a5,1836 # 80026ed0 <pow10.0+0x70>
    800127ac:	239c                	fld	fa5,0(a5)
    800127ae:	a2f717d3          	flt.d	a5,fa4,fa5
    800127b2:	00f037b3          	snez	a5,a5
    800127b6:	0ff7f793          	andi	a5,a5,255
    800127ba:	0017c793          	xori	a5,a5,1
    800127be:	0ff7f793          	andi	a5,a5,255
    800127c2:	eb99                	bnez	a5,800127d8 <_ftoa+0x30c>
    800127c4:	fc843707          	fld	fa4,-56(s0)
    800127c8:	00014797          	auipc	a5,0x14
    800127cc:	70878793          	addi	a5,a5,1800 # 80026ed0 <pow10.0+0x70>
    800127d0:	239c                	fld	fa5,0(a5)
    800127d2:	a2e797d3          	flt.d	a5,fa5,fa4
    800127d6:	cbf1                	beqz	a5,800128aa <_ftoa+0x3de>
    800127d8:	fe042783          	lw	a5,-32(s0)
    800127dc:	8b85                	andi	a5,a5,1
    800127de:	2781                	sext.w	a5,a5
    800127e0:	10078863          	beqz	a5,800128f0 <_ftoa+0x424>
            // exactly 0.5 and ODD, then round up
            // 1.5 -> 2, but 2.5 -> 2
            ++whole;
    800127e4:	fe042783          	lw	a5,-32(s0)
    800127e8:	2785                	addiw	a5,a5,1
    800127ea:	fef42023          	sw	a5,-32(s0)
    800127ee:	a209                	j	800128f0 <_ftoa+0x424>
        }
    }
    else {
        unsigned int count = prec;
    800127f0:	f7442783          	lw	a5,-140(s0)
    800127f4:	fcf42a23          	sw	a5,-44(s0)
        // now do fractional part, as an unsigned number
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    800127f8:	a0b1                	j	80012844 <_ftoa+0x378>
            --count;
    800127fa:	fd442783          	lw	a5,-44(s0)
    800127fe:	37fd                	addiw	a5,a5,-1
    80012800:	fcf42a23          	sw	a5,-44(s0)
            buf[len++] = (char)(48U + (frac % 10U));
    80012804:	fd843703          	ld	a4,-40(s0)
    80012808:	47a9                	li	a5,10
    8001280a:	02f777b3          	remu	a5,a4,a5
    8001280e:	0ff7f713          	andi	a4,a5,255
    80012812:	fe843783          	ld	a5,-24(s0)
    80012816:	00178693          	addi	a3,a5,1
    8001281a:	fed43423          	sd	a3,-24(s0)
    8001281e:	0307071b          	addiw	a4,a4,48
    80012822:	0ff77713          	andi	a4,a4,255
    80012826:	ff040693          	addi	a3,s0,-16
    8001282a:	97b6                	add	a5,a5,a3
    8001282c:	fae78823          	sb	a4,-80(a5)
            if (!(frac /= 10U)) {
    80012830:	fd843703          	ld	a4,-40(s0)
    80012834:	47a9                	li	a5,10
    80012836:	02f757b3          	divu	a5,a4,a5
    8001283a:	fcf43c23          	sd	a5,-40(s0)
    8001283e:	fd843783          	ld	a5,-40(s0)
    80012842:	c799                	beqz	a5,80012850 <_ftoa+0x384>
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80012844:	fe843703          	ld	a4,-24(s0)
    80012848:	47fd                	li	a5,31
    8001284a:	fae7f8e3          	bgeu	a5,a4,800127fa <_ftoa+0x32e>
    8001284e:	a005                	j	8001286e <_ftoa+0x3a2>
                break;
    80012850:	0001                	nop
            }
        }
        // add extra 0s
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80012852:	a831                	j	8001286e <_ftoa+0x3a2>
            buf[len++] = '0';
    80012854:	fe843783          	ld	a5,-24(s0)
    80012858:	00178713          	addi	a4,a5,1
    8001285c:	fee43423          	sd	a4,-24(s0)
    80012860:	ff040713          	addi	a4,s0,-16
    80012864:	97ba                	add	a5,a5,a4
    80012866:	03000713          	li	a4,48
    8001286a:	fae78823          	sb	a4,-80(a5)
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    8001286e:	fe843703          	ld	a4,-24(s0)
    80012872:	47fd                	li	a5,31
    80012874:	00e7e963          	bltu	a5,a4,80012886 <_ftoa+0x3ba>
    80012878:	fd442783          	lw	a5,-44(s0)
    8001287c:	fff7871b          	addiw	a4,a5,-1
    80012880:	fce42a23          	sw	a4,-44(s0)
    80012884:	fbe1                	bnez	a5,80012854 <_ftoa+0x388>
        }
        if (len < PRINTF_FTOA_BUFFER_SIZE) {
    80012886:	fe843703          	ld	a4,-24(s0)
    8001288a:	47fd                	li	a5,31
    8001288c:	06e7e263          	bltu	a5,a4,800128f0 <_ftoa+0x424>
            // add decimal
            buf[len++] = '.';
    80012890:	fe843783          	ld	a5,-24(s0)
    80012894:	00178713          	addi	a4,a5,1
    80012898:	fee43423          	sd	a4,-24(s0)
    8001289c:	ff040713          	addi	a4,s0,-16
    800128a0:	97ba                	add	a5,a5,a4
    800128a2:	02e00713          	li	a4,46
    800128a6:	fae78823          	sb	a4,-80(a5)
        }
    }

    // do whole part, number is reversed
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    800128aa:	a099                	j	800128f0 <_ftoa+0x424>
        buf[len++] = (char)(48 + (whole % 10));
    800128ac:	fe042703          	lw	a4,-32(s0)
    800128b0:	47a9                	li	a5,10
    800128b2:	02f767bb          	remw	a5,a4,a5
    800128b6:	2781                	sext.w	a5,a5
    800128b8:	0ff7f713          	andi	a4,a5,255
    800128bc:	fe843783          	ld	a5,-24(s0)
    800128c0:	00178693          	addi	a3,a5,1
    800128c4:	fed43423          	sd	a3,-24(s0)
    800128c8:	0307071b          	addiw	a4,a4,48
    800128cc:	0ff77713          	andi	a4,a4,255
    800128d0:	ff040693          	addi	a3,s0,-16
    800128d4:	97b6                	add	a5,a5,a3
    800128d6:	fae78823          	sb	a4,-80(a5)
        if (!(whole /= 10)) {
    800128da:	fe042703          	lw	a4,-32(s0)
    800128de:	47a9                	li	a5,10
    800128e0:	02f747bb          	divw	a5,a4,a5
    800128e4:	fef42023          	sw	a5,-32(s0)
    800128e8:	fe042783          	lw	a5,-32(s0)
    800128ec:	2781                	sext.w	a5,a5
    800128ee:	c799                	beqz	a5,800128fc <_ftoa+0x430>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    800128f0:	fe843703          	ld	a4,-24(s0)
    800128f4:	47fd                	li	a5,31
    800128f6:	fae7fbe3          	bgeu	a5,a4,800128ac <_ftoa+0x3e0>
    800128fa:	a011                	j	800128fe <_ftoa+0x432>
            break;
    800128fc:	0001                	nop
        }
    }

    // pad leading zeros
    if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    800128fe:	f6c42783          	lw	a5,-148(s0)
    80012902:	8b89                	andi	a5,a5,2
    80012904:	2781                	sext.w	a5,a5
    80012906:	e3b5                	bnez	a5,8001296a <_ftoa+0x49e>
    80012908:	f6c42783          	lw	a5,-148(s0)
    8001290c:	8b85                	andi	a5,a5,1
    8001290e:	2781                	sext.w	a5,a5
    80012910:	cfa9                	beqz	a5,8001296a <_ftoa+0x49e>
        if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80012912:	f7042783          	lw	a5,-144(s0)
    80012916:	2781                	sext.w	a5,a5
    80012918:	cf95                	beqz	a5,80012954 <_ftoa+0x488>
    8001291a:	fe744783          	lbu	a5,-25(s0)
    8001291e:	0ff7f793          	andi	a5,a5,255
    80012922:	e791                	bnez	a5,8001292e <_ftoa+0x462>
    80012924:	f6c42783          	lw	a5,-148(s0)
    80012928:	8bb1                	andi	a5,a5,12
    8001292a:	2781                	sext.w	a5,a5
    8001292c:	c785                	beqz	a5,80012954 <_ftoa+0x488>
            width--;
    8001292e:	f7042783          	lw	a5,-144(s0)
    80012932:	37fd                	addiw	a5,a5,-1
    80012934:	f6f42823          	sw	a5,-144(s0)
        }
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    80012938:	a831                	j	80012954 <_ftoa+0x488>
            buf[len++] = '0';
    8001293a:	fe843783          	ld	a5,-24(s0)
    8001293e:	00178713          	addi	a4,a5,1
    80012942:	fee43423          	sd	a4,-24(s0)
    80012946:	ff040713          	addi	a4,s0,-16
    8001294a:	97ba                	add	a5,a5,a4
    8001294c:	03000713          	li	a4,48
    80012950:	fae78823          	sb	a4,-80(a5)
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    80012954:	f7046783          	lwu	a5,-144(s0)
    80012958:	fe843703          	ld	a4,-24(s0)
    8001295c:	00f77763          	bgeu	a4,a5,8001296a <_ftoa+0x49e>
    80012960:	fe843703          	ld	a4,-24(s0)
    80012964:	47fd                	li	a5,31
    80012966:	fce7fae3          	bgeu	a5,a4,8001293a <_ftoa+0x46e>
        }
    }

    if (len < PRINTF_FTOA_BUFFER_SIZE) {
    8001296a:	fe843703          	ld	a4,-24(s0)
    8001296e:	47fd                	li	a5,31
    80012970:	06e7ea63          	bltu	a5,a4,800129e4 <_ftoa+0x518>
        if (negative) {
    80012974:	fe744783          	lbu	a5,-25(s0)
    80012978:	0ff7f793          	andi	a5,a5,255
    8001297c:	cf99                	beqz	a5,8001299a <_ftoa+0x4ce>
            buf[len++] = '-';
    8001297e:	fe843783          	ld	a5,-24(s0)
    80012982:	00178713          	addi	a4,a5,1
    80012986:	fee43423          	sd	a4,-24(s0)
    8001298a:	ff040713          	addi	a4,s0,-16
    8001298e:	97ba                	add	a5,a5,a4
    80012990:	02d00713          	li	a4,45
    80012994:	fae78823          	sb	a4,-80(a5)
    80012998:	a0b1                	j	800129e4 <_ftoa+0x518>
        }
        else if (flags & FLAGS_PLUS) {
    8001299a:	f6c42783          	lw	a5,-148(s0)
    8001299e:	8b91                	andi	a5,a5,4
    800129a0:	2781                	sext.w	a5,a5
    800129a2:	cf99                	beqz	a5,800129c0 <_ftoa+0x4f4>
            buf[len++] = '+';  // ignore the space if the '+' exists
    800129a4:	fe843783          	ld	a5,-24(s0)
    800129a8:	00178713          	addi	a4,a5,1
    800129ac:	fee43423          	sd	a4,-24(s0)
    800129b0:	ff040713          	addi	a4,s0,-16
    800129b4:	97ba                	add	a5,a5,a4
    800129b6:	02b00713          	li	a4,43
    800129ba:	fae78823          	sb	a4,-80(a5)
    800129be:	a01d                	j	800129e4 <_ftoa+0x518>
        }
        else if (flags & FLAGS_SPACE) {
    800129c0:	f6c42783          	lw	a5,-148(s0)
    800129c4:	8ba1                	andi	a5,a5,8
    800129c6:	2781                	sext.w	a5,a5
    800129c8:	cf91                	beqz	a5,800129e4 <_ftoa+0x518>
            buf[len++] = ' ';
    800129ca:	fe843783          	ld	a5,-24(s0)
    800129ce:	00178713          	addi	a4,a5,1
    800129d2:	fee43423          	sd	a4,-24(s0)
    800129d6:	ff040713          	addi	a4,s0,-16
    800129da:	97ba                	add	a5,a5,a4
    800129dc:	02000713          	li	a4,32
    800129e0:	fae78823          	sb	a4,-80(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    800129e4:	f6c42683          	lw	a3,-148(s0)
    800129e8:	f7042783          	lw	a5,-144(s0)
    800129ec:	fa040713          	addi	a4,s0,-96
    800129f0:	88b6                	mv	a7,a3
    800129f2:	883e                	mv	a6,a5
    800129f4:	fe843783          	ld	a5,-24(s0)
    800129f8:	f8043683          	ld	a3,-128(s0)
    800129fc:	f8843603          	ld	a2,-120(s0)
    80012a00:	f9043583          	ld	a1,-112(s0)
    80012a04:	f9843503          	ld	a0,-104(s0)
    80012a08:	ce8ff0ef          	jal	ra,80011ef0 <_out_rev>
    80012a0c:	87aa                	mv	a5,a0
}
    80012a0e:	853e                	mv	a0,a5
    80012a10:	60ea                	ld	ra,152(sp)
    80012a12:	644a                	ld	s0,144(sp)
    80012a14:	610d                	addi	sp,sp,160
    80012a16:	8082                	ret

0000000080012a18 <_etoa>:
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80012a18:	7135                	addi	sp,sp,-160
    80012a1a:	ed06                	sd	ra,152(sp)
    80012a1c:	e922                	sd	s0,144(sp)
    80012a1e:	1100                	addi	s0,sp,160
    80012a20:	faa43423          	sd	a0,-88(s0)
    80012a24:	fab43023          	sd	a1,-96(s0)
    80012a28:	f8c43c23          	sd	a2,-104(s0)
    80012a2c:	f8d43823          	sd	a3,-112(s0)
    80012a30:	f8a43427          	fsd	fa0,-120(s0)
    80012a34:	863a                	mv	a2,a4
    80012a36:	86be                	mv	a3,a5
    80012a38:	8742                	mv	a4,a6
    80012a3a:	87b2                	mv	a5,a2
    80012a3c:	f8f42223          	sw	a5,-124(s0)
    80012a40:	87b6                	mv	a5,a3
    80012a42:	f8f42023          	sw	a5,-128(s0)
    80012a46:	87ba                	mv	a5,a4
    80012a48:	f6f42e23          	sw	a5,-132(s0)
    // check for NaN and special values
    if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    80012a4c:	f8843707          	fld	fa4,-120(s0)
    80012a50:	f8843787          	fld	fa5,-120(s0)
    80012a54:	a2f727d3          	feq.d	a5,fa4,fa5
    80012a58:	c78d                	beqz	a5,80012a82 <_etoa+0x6a>
    80012a5a:	f8843707          	fld	fa4,-120(s0)
    80012a5e:	00014797          	auipc	a5,0x14
    80012a62:	45a78793          	addi	a5,a5,1114 # 80026eb8 <pow10.0+0x58>
    80012a66:	239c                	fld	fa5,0(a5)
    80012a68:	a2e797d3          	flt.d	a5,fa5,fa4
    80012a6c:	eb99                	bnez	a5,80012a82 <_etoa+0x6a>
    80012a6e:	f8843707          	fld	fa4,-120(s0)
    80012a72:	00014797          	auipc	a5,0x14
    80012a76:	43e78793          	addi	a5,a5,1086 # 80026eb0 <pow10.0+0x50>
    80012a7a:	239c                	fld	fa5,0(a5)
    80012a7c:	a2f717d3          	flt.d	a5,fa4,fa5
    80012a80:	c795                	beqz	a5,80012aac <_etoa+0x94>
        return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80012a82:	f7c42683          	lw	a3,-132(s0)
    80012a86:	f8042783          	lw	a5,-128(s0)
    80012a8a:	f8442703          	lw	a4,-124(s0)
    80012a8e:	8836                	mv	a6,a3
    80012a90:	f8843507          	fld	fa0,-120(s0)
    80012a94:	f9043683          	ld	a3,-112(s0)
    80012a98:	f9843603          	ld	a2,-104(s0)
    80012a9c:	fa043583          	ld	a1,-96(s0)
    80012aa0:	fa843503          	ld	a0,-88(s0)
    80012aa4:	a29ff0ef          	jal	ra,800124cc <_ftoa>
    80012aa8:	87aa                	mv	a5,a0
    80012aaa:	a11d                	j	80012ed0 <_etoa+0x4b8>
    }

    // determine the sign
    const bool negative = value < 0;
    80012aac:	f8843787          	fld	fa5,-120(s0)
    80012ab0:	f2000753          	fmv.d.x	fa4,zero
    80012ab4:	a2e797d3          	flt.d	a5,fa5,fa4
    80012ab8:	00f037b3          	snez	a5,a5
    80012abc:	fef401a3          	sb	a5,-29(s0)
    if (negative) {
    80012ac0:	fe344783          	lbu	a5,-29(s0)
    80012ac4:	0ff7f793          	andi	a5,a5,255
    80012ac8:	c799                	beqz	a5,80012ad6 <_etoa+0xbe>
        value = -value;
    80012aca:	f8843787          	fld	fa5,-120(s0)
    80012ace:	22f797d3          	fneg.d	fa5,fa5
    80012ad2:	f8f43427          	fsd	fa5,-120(s0)
    }

    // default precision
    if (!(flags & FLAGS_PRECISION)) {
    80012ad6:	f7c42783          	lw	a5,-132(s0)
    80012ada:	4007f793          	andi	a5,a5,1024
    80012ade:	2781                	sext.w	a5,a5
    80012ae0:	e781                	bnez	a5,80012ae8 <_etoa+0xd0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80012ae2:	4799                	li	a5,6
    80012ae4:	f8f42223          	sw	a5,-124(s0)
    union {
        uint64_t U;
        double F;
    } conv;

    conv.F   = value;
    80012ae8:	f8843787          	fld	fa5,-120(s0)
    80012aec:	faf43c27          	fsd	fa5,-72(s0)
    int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;  // effectively log2
    80012af0:	fb843783          	ld	a5,-72(s0)
    80012af4:	93d1                	srli	a5,a5,0x34
    80012af6:	2781                	sext.w	a5,a5
    80012af8:	7ff7f793          	andi	a5,a5,2047
    80012afc:	2781                	sext.w	a5,a5
    80012afe:	c017879b          	addiw	a5,a5,-1023
    80012b02:	fcf42e23          	sw	a5,-36(s0)
    conv.U   = (conv.U & ((1ULL << 52U) - 1U)) |
    80012b06:	fb843703          	ld	a4,-72(s0)
    80012b0a:	57fd                	li	a5,-1
    80012b0c:	83b1                	srli	a5,a5,0xc
    80012b0e:	8f7d                	and	a4,a4,a5
    80012b10:	3ff00793          	li	a5,1023
    80012b14:	17d2                	slli	a5,a5,0x34
    80012b16:	8fd9                	or	a5,a5,a4
    80012b18:	faf43c23          	sd	a5,-72(s0)
             (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    // now approximate log10 from the log2 integer part and an expansion of ln
    // around 1.5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    80012b1c:	fdc42783          	lw	a5,-36(s0)
    80012b20:	d2078753          	fcvt.d.w	fa4,a5
    80012b24:	00014797          	auipc	a5,0x14
    80012b28:	3b478793          	addi	a5,a5,948 # 80026ed8 <pow10.0+0x78>
    80012b2c:	239c                	fld	fa5,0(a5)
    80012b2e:	12f77753          	fmul.d	fa4,fa4,fa5
    80012b32:	00014797          	auipc	a5,0x14
    80012b36:	3ae78793          	addi	a5,a5,942 # 80026ee0 <pow10.0+0x80>
    80012b3a:	239c                	fld	fa5,0(a5)
    80012b3c:	02f77753          	fadd.d	fa4,fa4,fa5
                       (conv.F - 1.5) * 0.289529654602168);
    80012b40:	fb843687          	fld	fa3,-72(s0)
    80012b44:	00014797          	auipc	a5,0x14
    80012b48:	3a478793          	addi	a5,a5,932 # 80026ee8 <pow10.0+0x88>
    80012b4c:	239c                	fld	fa5,0(a5)
    80012b4e:	0af6f6d3          	fsub.d	fa3,fa3,fa5
    80012b52:	00014797          	auipc	a5,0x14
    80012b56:	39e78793          	addi	a5,a5,926 # 80026ef0 <pow10.0+0x90>
    80012b5a:	239c                	fld	fa5,0(a5)
    80012b5c:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    80012b60:	02f777d3          	fadd.d	fa5,fa4,fa5
    80012b64:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80012b68:	fef42623          	sw	a5,-20(s0)
    // now we want to compute 10^expval but we want to be sure it won't overflow
    exp2            = (int)(expval * 3.321928094887362 + 0.5);
    80012b6c:	fec42783          	lw	a5,-20(s0)
    80012b70:	d2078753          	fcvt.d.w	fa4,a5
    80012b74:	00014797          	auipc	a5,0x14
    80012b78:	38478793          	addi	a5,a5,900 # 80026ef8 <pow10.0+0x98>
    80012b7c:	239c                	fld	fa5,0(a5)
    80012b7e:	12f77753          	fmul.d	fa4,fa4,fa5
    80012b82:	00014797          	auipc	a5,0x14
    80012b86:	34e78793          	addi	a5,a5,846 # 80026ed0 <pow10.0+0x70>
    80012b8a:	239c                	fld	fa5,0(a5)
    80012b8c:	02f777d3          	fadd.d	fa5,fa4,fa5
    80012b90:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80012b94:	fcf42e23          	sw	a5,-36(s0)
    const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    80012b98:	fec42783          	lw	a5,-20(s0)
    80012b9c:	d2078753          	fcvt.d.w	fa4,a5
    80012ba0:	00014797          	auipc	a5,0x14
    80012ba4:	36078793          	addi	a5,a5,864 # 80026f00 <pow10.0+0xa0>
    80012ba8:	239c                	fld	fa5,0(a5)
    80012baa:	12f77753          	fmul.d	fa4,fa4,fa5
    80012bae:	fdc42783          	lw	a5,-36(s0)
    80012bb2:	d20786d3          	fcvt.d.w	fa3,a5
    80012bb6:	00014797          	auipc	a5,0x14
    80012bba:	35278793          	addi	a5,a5,850 # 80026f08 <pow10.0+0xa8>
    80012bbe:	239c                	fld	fa5,0(a5)
    80012bc0:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    80012bc4:	0af777d3          	fsub.d	fa5,fa4,fa5
    80012bc8:	fcf43827          	fsd	fa5,-48(s0)
    const double z2 = z * z;
    80012bcc:	fd043787          	fld	fa5,-48(s0)
    80012bd0:	12f7f7d3          	fmul.d	fa5,fa5,fa5
    80012bd4:	fcf43427          	fsd	fa5,-56(s0)
    conv.U          = (uint64_t)(exp2 + 1023) << 52U;
    80012bd8:	fdc42783          	lw	a5,-36(s0)
    80012bdc:	3ff7879b          	addiw	a5,a5,1023
    80012be0:	2781                	sext.w	a5,a5
    80012be2:	17d2                	slli	a5,a5,0x34
    80012be4:	faf43c23          	sd	a5,-72(s0)
    // compute exp(z) using continued fractions, see
    // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    80012be8:	fb843707          	fld	fa4,-72(s0)
    80012bec:	fd043787          	fld	fa5,-48(s0)
    80012bf0:	02f7f6d3          	fadd.d	fa3,fa5,fa5
    80012bf4:	00014797          	auipc	a5,0x14
    80012bf8:	31c78793          	addi	a5,a5,796 # 80026f10 <pow10.0+0xb0>
    80012bfc:	2390                	fld	fa2,0(a5)
    80012bfe:	fd043787          	fld	fa5,-48(s0)
    80012c02:	0af67653          	fsub.d	fa2,fa2,fa5
    80012c06:	fc843587          	fld	fa1,-56(s0)
    80012c0a:	00014797          	auipc	a5,0x14
    80012c0e:	30e78793          	addi	a5,a5,782 # 80026f18 <pow10.0+0xb8>
    80012c12:	239c                	fld	fa5,0(a5)
    80012c14:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    80012c18:	00014797          	auipc	a5,0x14
    80012c1c:	30878793          	addi	a5,a5,776 # 80026f20 <pow10.0+0xc0>
    80012c20:	239c                	fld	fa5,0(a5)
    80012c22:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    80012c26:	fc843587          	fld	fa1,-56(s0)
    80012c2a:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    80012c2e:	00014797          	auipc	a5,0x14
    80012c32:	2fa78793          	addi	a5,a5,762 # 80026f28 <pow10.0+0xc8>
    80012c36:	239c                	fld	fa5,0(a5)
    80012c38:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    80012c3c:	fc843587          	fld	fa1,-56(s0)
    80012c40:	1af5f7d3          	fdiv.d	fa5,fa1,fa5
    80012c44:	02f677d3          	fadd.d	fa5,fa2,fa5
    80012c48:	1af6f6d3          	fdiv.d	fa3,fa3,fa5
    80012c4c:	00014797          	auipc	a5,0x14
    80012c50:	2e478793          	addi	a5,a5,740 # 80026f30 <pow10.0+0xd0>
    80012c54:	239c                	fld	fa5,0(a5)
    80012c56:	02f6f7d3          	fadd.d	fa5,fa3,fa5
    80012c5a:	12f777d3          	fmul.d	fa5,fa4,fa5
    80012c5e:	faf43c27          	fsd	fa5,-72(s0)
    // correct for rounding errors
    if (value < conv.F) {
    80012c62:	fb843787          	fld	fa5,-72(s0)
    80012c66:	f8843707          	fld	fa4,-120(s0)
    80012c6a:	a2f717d3          	flt.d	a5,fa4,fa5
    80012c6e:	c38d                	beqz	a5,80012c90 <_etoa+0x278>
        expval--;
    80012c70:	fec42783          	lw	a5,-20(s0)
    80012c74:	37fd                	addiw	a5,a5,-1
    80012c76:	fef42623          	sw	a5,-20(s0)
        conv.F /= 10;
    80012c7a:	fb843707          	fld	fa4,-72(s0)
    80012c7e:	00014797          	auipc	a5,0x14
    80012c82:	2a278793          	addi	a5,a5,674 # 80026f20 <pow10.0+0xc0>
    80012c86:	239c                	fld	fa5,0(a5)
    80012c88:	1af777d3          	fdiv.d	fa5,fa4,fa5
    80012c8c:	faf43c27          	fsd	fa5,-72(s0)
    }

    // the exponent format is "%+03d" and largest value is "307", so set aside
    // 4-5 characters
    unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    80012c90:	fec42783          	lw	a5,-20(s0)
    80012c94:	0007871b          	sext.w	a4,a5
    80012c98:	06300793          	li	a5,99
    80012c9c:	00e7cc63          	blt	a5,a4,80012cb4 <_etoa+0x29c>
    80012ca0:	fec42783          	lw	a5,-20(s0)
    80012ca4:	0007871b          	sext.w	a4,a5
    80012ca8:	f9d00793          	li	a5,-99
    80012cac:	00f74463          	blt	a4,a5,80012cb4 <_etoa+0x29c>
    80012cb0:	4791                	li	a5,4
    80012cb2:	a011                	j	80012cb6 <_etoa+0x29e>
    80012cb4:	4795                	li	a5,5
    80012cb6:	fef42423          	sw	a5,-24(s0)

    // in "%g" mode, "prec" is the number of *significant figures* not decimals
    if (flags & FLAGS_ADAPT_EXP) {
    80012cba:	f7c42703          	lw	a4,-132(s0)
    80012cbe:	6785                	lui	a5,0x1
    80012cc0:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80012cc4:	8ff9                	and	a5,a5,a4
    80012cc6:	2781                	sext.w	a5,a5
    80012cc8:	c7c1                	beqz	a5,80012d50 <_etoa+0x338>
        // do we want to fall-back to "%f" mode?
        if ((value >= 1e-4) && (value < 1e6)) {
    80012cca:	f8843707          	fld	fa4,-120(s0)
    80012cce:	00014797          	auipc	a5,0x14
    80012cd2:	26a78793          	addi	a5,a5,618 # 80026f38 <pow10.0+0xd8>
    80012cd6:	239c                	fld	fa5,0(a5)
    80012cd8:	a2e787d3          	fle.d	a5,fa5,fa4
    80012cdc:	cbb9                	beqz	a5,80012d32 <_etoa+0x31a>
    80012cde:	f8843707          	fld	fa4,-120(s0)
    80012ce2:	00014797          	auipc	a5,0x14
    80012ce6:	25e78793          	addi	a5,a5,606 # 80026f40 <pow10.0+0xe0>
    80012cea:	239c                	fld	fa5,0(a5)
    80012cec:	a2f717d3          	flt.d	a5,fa4,fa5
    80012cf0:	c3a9                	beqz	a5,80012d32 <_etoa+0x31a>
            if ((int)prec > expval) {
    80012cf2:	f8442703          	lw	a4,-124(s0)
    80012cf6:	fec42783          	lw	a5,-20(s0)
    80012cfa:	2781                	sext.w	a5,a5
    80012cfc:	00e7de63          	bge	a5,a4,80012d18 <_etoa+0x300>
                prec = (unsigned)((int)prec - expval - 1);
    80012d00:	f8442703          	lw	a4,-124(s0)
    80012d04:	fec42783          	lw	a5,-20(s0)
    80012d08:	40f707bb          	subw	a5,a4,a5
    80012d0c:	2781                	sext.w	a5,a5
    80012d0e:	37fd                	addiw	a5,a5,-1
    80012d10:	2781                	sext.w	a5,a5
    80012d12:	f8f42223          	sw	a5,-124(s0)
    80012d16:	a019                	j	80012d1c <_etoa+0x304>
            }
            else {
                prec = 0;
    80012d18:	f8042223          	sw	zero,-124(s0)
            }
            flags |= FLAGS_PRECISION;  // make sure _ftoa respects precision
    80012d1c:	f7c42783          	lw	a5,-132(s0)
    80012d20:	4007e793          	ori	a5,a5,1024
    80012d24:	f6f42e23          	sw	a5,-132(s0)
            // no characters in exponent
            minwidth = 0U;
    80012d28:	fe042423          	sw	zero,-24(s0)
            expval   = 0;
    80012d2c:	fe042623          	sw	zero,-20(s0)
    80012d30:	a005                	j	80012d50 <_etoa+0x338>
        }
        else {
            // we use one sigfig for the whole part
            if ((prec > 0) && (flags & FLAGS_PRECISION)) {
    80012d32:	f8442783          	lw	a5,-124(s0)
    80012d36:	2781                	sext.w	a5,a5
    80012d38:	cf81                	beqz	a5,80012d50 <_etoa+0x338>
    80012d3a:	f7c42783          	lw	a5,-132(s0)
    80012d3e:	4007f793          	andi	a5,a5,1024
    80012d42:	2781                	sext.w	a5,a5
    80012d44:	c791                	beqz	a5,80012d50 <_etoa+0x338>
                --prec;
    80012d46:	f8442783          	lw	a5,-124(s0)
    80012d4a:	37fd                	addiw	a5,a5,-1
    80012d4c:	f8f42223          	sw	a5,-124(s0)
            }
        }
    }

    // will everything fit?
    unsigned int fwidth = width;
    80012d50:	f8042783          	lw	a5,-128(s0)
    80012d54:	fef42223          	sw	a5,-28(s0)
    if (width > minwidth) {
    80012d58:	f8042703          	lw	a4,-128(s0)
    80012d5c:	fe842783          	lw	a5,-24(s0)
    80012d60:	2701                	sext.w	a4,a4
    80012d62:	2781                	sext.w	a5,a5
    80012d64:	00e7fb63          	bgeu	a5,a4,80012d7a <_etoa+0x362>
        // we didn't fall-back so subtract the characters required for the
        // exponent
        fwidth -= minwidth;
    80012d68:	fe442703          	lw	a4,-28(s0)
    80012d6c:	fe842783          	lw	a5,-24(s0)
    80012d70:	40f707bb          	subw	a5,a4,a5
    80012d74:	fef42223          	sw	a5,-28(s0)
    80012d78:	a019                	j	80012d7e <_etoa+0x366>
    }
    else {
        // not enough characters, so go back to default sizing
        fwidth = 0U;
    80012d7a:	fe042223          	sw	zero,-28(s0)
    }
    if ((flags & FLAGS_LEFT) && minwidth) {
    80012d7e:	f7c42783          	lw	a5,-132(s0)
    80012d82:	8b89                	andi	a5,a5,2
    80012d84:	2781                	sext.w	a5,a5
    80012d86:	c799                	beqz	a5,80012d94 <_etoa+0x37c>
    80012d88:	fe842783          	lw	a5,-24(s0)
    80012d8c:	2781                	sext.w	a5,a5
    80012d8e:	c399                	beqz	a5,80012d94 <_etoa+0x37c>
        // if we're padding on the right, DON'T pad the floating part
        fwidth = 0U;
    80012d90:	fe042223          	sw	zero,-28(s0)
    }

    // rescale the float value
    if (expval) {
    80012d94:	fec42783          	lw	a5,-20(s0)
    80012d98:	2781                	sext.w	a5,a5
    80012d9a:	cb89                	beqz	a5,80012dac <_etoa+0x394>
        value /= conv.F;
    80012d9c:	fb843787          	fld	fa5,-72(s0)
    80012da0:	f8843707          	fld	fa4,-120(s0)
    80012da4:	1af777d3          	fdiv.d	fa5,fa4,fa5
    80012da8:	f8f43427          	fsd	fa5,-120(s0)
    }

    // output the floating part
    const size_t start_idx = idx;
    80012dac:	f9843783          	ld	a5,-104(s0)
    80012db0:	fcf43023          	sd	a5,-64(s0)
    idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec,
    80012db4:	fe344783          	lbu	a5,-29(s0)
    80012db8:	0ff7f793          	andi	a5,a5,255
    80012dbc:	c791                	beqz	a5,80012dc8 <_etoa+0x3b0>
    80012dbe:	f8843787          	fld	fa5,-120(s0)
    80012dc2:	22f797d3          	fneg.d	fa5,fa5
    80012dc6:	a019                	j	80012dcc <_etoa+0x3b4>
    80012dc8:	f8843787          	fld	fa5,-120(s0)
    80012dcc:	f7c42703          	lw	a4,-132(s0)
    80012dd0:	77fd                	lui	a5,0xfffff
    80012dd2:	7ff78793          	addi	a5,a5,2047 # fffffffffffff7ff <_heap_end+0xffffffff77fef7ff>
    80012dd6:	8ff9                	and	a5,a5,a4
    80012dd8:	0007869b          	sext.w	a3,a5
    80012ddc:	fe442783          	lw	a5,-28(s0)
    80012de0:	f8442703          	lw	a4,-124(s0)
    80012de4:	8836                	mv	a6,a3
    80012de6:	22f78553          	fmv.d	fa0,fa5
    80012dea:	f9043683          	ld	a3,-112(s0)
    80012dee:	f9843603          	ld	a2,-104(s0)
    80012df2:	fa043583          	ld	a1,-96(s0)
    80012df6:	fa843503          	ld	a0,-88(s0)
    80012dfa:	ed2ff0ef          	jal	ra,800124cc <_ftoa>
    80012dfe:	f8a43c23          	sd	a0,-104(s0)
                fwidth, flags & ~FLAGS_ADAPT_EXP);

    // output the exponent part
    if (minwidth) {
    80012e02:	fe842783          	lw	a5,-24(s0)
    80012e06:	2781                	sext.w	a5,a5
    80012e08:	c3f1                	beqz	a5,80012ecc <_etoa+0x4b4>
        // output the exponential symbol
        out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    80012e0a:	f7c42783          	lw	a5,-132(s0)
    80012e0e:	0207f793          	andi	a5,a5,32
    80012e12:	2781                	sext.w	a5,a5
    80012e14:	c781                	beqz	a5,80012e1c <_etoa+0x404>
    80012e16:	04500793          	li	a5,69
    80012e1a:	a019                	j	80012e20 <_etoa+0x408>
    80012e1c:	06500793          	li	a5,101
    80012e20:	f9843703          	ld	a4,-104(s0)
    80012e24:	00170693          	addi	a3,a4,1
    80012e28:	f8d43c23          	sd	a3,-104(s0)
    80012e2c:	fa843803          	ld	a6,-88(s0)
    80012e30:	f9043683          	ld	a3,-112(s0)
    80012e34:	863a                	mv	a2,a4
    80012e36:	fa043583          	ld	a1,-96(s0)
    80012e3a:	853e                	mv	a0,a5
    80012e3c:	9802                	jalr	a6
        // output the exponent value
        idx = _ntoa_long(out, buffer, idx, maxlen,
                         (expval < 0) ? -expval : expval, expval < 0, 10, 0,
    80012e3e:	fec42783          	lw	a5,-20(s0)
    80012e42:	41f7d79b          	sraiw	a5,a5,0x1f
    80012e46:	fec42703          	lw	a4,-20(s0)
    80012e4a:	8f3d                	xor	a4,a4,a5
    80012e4c:	40f707bb          	subw	a5,a4,a5
    80012e50:	2781                	sext.w	a5,a5
        idx = _ntoa_long(out, buffer, idx, maxlen,
    80012e52:	863e                	mv	a2,a5
    80012e54:	fec42783          	lw	a5,-20(s0)
    80012e58:	01f7d79b          	srliw	a5,a5,0x1f
    80012e5c:	0ff7f693          	andi	a3,a5,255
    80012e60:	fe842783          	lw	a5,-24(s0)
    80012e64:	37fd                	addiw	a5,a5,-1
    80012e66:	2781                	sext.w	a5,a5
    80012e68:	4715                	li	a4,5
    80012e6a:	e43a                	sd	a4,8(sp)
    80012e6c:	e03e                	sd	a5,0(sp)
    80012e6e:	4881                	li	a7,0
    80012e70:	4829                	li	a6,10
    80012e72:	87b6                	mv	a5,a3
    80012e74:	8732                	mv	a4,a2
    80012e76:	f9043683          	ld	a3,-112(s0)
    80012e7a:	f9843603          	ld	a2,-104(s0)
    80012e7e:	fa043583          	ld	a1,-96(s0)
    80012e82:	fa843503          	ld	a0,-88(s0)
    80012e86:	c16ff0ef          	jal	ra,8001229c <_ntoa_long>
    80012e8a:	f8a43c23          	sd	a0,-104(s0)
                         minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
        // might need to right-pad spaces
        if (flags & FLAGS_LEFT) {
    80012e8e:	f7c42783          	lw	a5,-132(s0)
    80012e92:	8b89                	andi	a5,a5,2
    80012e94:	2781                	sext.w	a5,a5
    80012e96:	cb9d                	beqz	a5,80012ecc <_etoa+0x4b4>
            while (idx - start_idx < width)
    80012e98:	a00d                	j	80012eba <_etoa+0x4a2>
                out(' ', buffer, idx++, maxlen);
    80012e9a:	f9843783          	ld	a5,-104(s0)
    80012e9e:	00178713          	addi	a4,a5,1
    80012ea2:	f8e43c23          	sd	a4,-104(s0)
    80012ea6:	fa843703          	ld	a4,-88(s0)
    80012eaa:	f9043683          	ld	a3,-112(s0)
    80012eae:	863e                	mv	a2,a5
    80012eb0:	fa043583          	ld	a1,-96(s0)
    80012eb4:	02000513          	li	a0,32
    80012eb8:	9702                	jalr	a4
            while (idx - start_idx < width)
    80012eba:	f9843703          	ld	a4,-104(s0)
    80012ebe:	fc043783          	ld	a5,-64(s0)
    80012ec2:	8f1d                	sub	a4,a4,a5
    80012ec4:	f8046783          	lwu	a5,-128(s0)
    80012ec8:	fcf769e3          	bltu	a4,a5,80012e9a <_etoa+0x482>
        }
    }
    return idx;
    80012ecc:	f9843783          	ld	a5,-104(s0)
}
    80012ed0:	853e                	mv	a0,a5
    80012ed2:	60ea                	ld	ra,152(sp)
    80012ed4:	644a                	ld	s0,144(sp)
    80012ed6:	610d                	addi	sp,sp,160
    80012ed8:	8082                	ret

0000000080012eda <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
                      const char *format, va_list va)
{
    80012eda:	7135                	addi	sp,sp,-160
    80012edc:	ed06                	sd	ra,152(sp)
    80012ede:	e922                	sd	s0,144(sp)
    80012ee0:	1100                	addi	s0,sp,160
    80012ee2:	f8a43c23          	sd	a0,-104(s0)
    80012ee6:	f8b43823          	sd	a1,-112(s0)
    80012eea:	f8c43423          	sd	a2,-120(s0)
    80012eee:	f8d43023          	sd	a3,-128(s0)
    80012ef2:	f6e43c23          	sd	a4,-136(s0)
    unsigned int flags, width, precision, n;
    size_t idx = 0U;
    80012ef6:	fc043c23          	sd	zero,-40(s0)

    if (!buffer) {
    80012efa:	f9043783          	ld	a5,-112(s0)
    80012efe:	380792e3          	bnez	a5,80013a82 <_vsnprintf+0xba8>
        // use null output function
        out = _out_null;
    80012f02:	fffff797          	auipc	a5,0xfffff
    80012f06:	e5878793          	addi	a5,a5,-424 # 80011d5a <_out_null>
    80012f0a:	f8f43c23          	sd	a5,-104(s0)
    }

    while (*format) {
    80012f0e:	3750006f          	j	80013a82 <_vsnprintf+0xba8>
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
    80012f12:	f8043783          	ld	a5,-128(s0)
    80012f16:	0007c783          	lbu	a5,0(a5)
    80012f1a:	873e                	mv	a4,a5
    80012f1c:	02500793          	li	a5,37
    80012f20:	02f70b63          	beq	a4,a5,80012f56 <_vsnprintf+0x7c>
            // no
            out(*format, buffer, idx++, maxlen);
    80012f24:	f8043783          	ld	a5,-128(s0)
    80012f28:	0007c503          	lbu	a0,0(a5)
    80012f2c:	fd843783          	ld	a5,-40(s0)
    80012f30:	00178713          	addi	a4,a5,1
    80012f34:	fce43c23          	sd	a4,-40(s0)
    80012f38:	f9843703          	ld	a4,-104(s0)
    80012f3c:	f8843683          	ld	a3,-120(s0)
    80012f40:	863e                	mv	a2,a5
    80012f42:	f9043583          	ld	a1,-112(s0)
    80012f46:	9702                	jalr	a4
            format++;
    80012f48:	f8043783          	ld	a5,-128(s0)
    80012f4c:	0785                	addi	a5,a5,1
    80012f4e:	f8f43023          	sd	a5,-128(s0)
            continue;
    80012f52:	3310006f          	j	80013a82 <_vsnprintf+0xba8>
        }
        else {
            // yes, evaluate it
            format++;
    80012f56:	f8043783          	ld	a5,-128(s0)
    80012f5a:	0785                	addi	a5,a5,1
    80012f5c:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate flags
        flags = 0U;
    80012f60:	fe042623          	sw	zero,-20(s0)
        do {
            switch (*format) {
    80012f64:	f8043783          	ld	a5,-128(s0)
    80012f68:	0007c783          	lbu	a5,0(a5)
    80012f6c:	2781                	sext.w	a5,a5
    80012f6e:	fe07869b          	addiw	a3,a5,-32
    80012f72:	0006871b          	sext.w	a4,a3
    80012f76:	47c1                	li	a5,16
    80012f78:	0ce7e063          	bltu	a5,a4,80013038 <_vsnprintf+0x15e>
    80012f7c:	02069793          	slli	a5,a3,0x20
    80012f80:	9381                	srli	a5,a5,0x20
    80012f82:	00279713          	slli	a4,a5,0x2
    80012f86:	00014797          	auipc	a5,0x14
    80012f8a:	cf678793          	addi	a5,a5,-778 # 80026c7c <SYSCALLS+0xc4c>
    80012f8e:	97ba                	add	a5,a5,a4
    80012f90:	439c                	lw	a5,0(a5)
    80012f92:	0007871b          	sext.w	a4,a5
    80012f96:	00014797          	auipc	a5,0x14
    80012f9a:	ce678793          	addi	a5,a5,-794 # 80026c7c <SYSCALLS+0xc4c>
    80012f9e:	97ba                	add	a5,a5,a4
    80012fa0:	8782                	jr	a5
                case '0':
                    flags |= FLAGS_ZEROPAD;
    80012fa2:	fec42783          	lw	a5,-20(s0)
    80012fa6:	0017e793          	ori	a5,a5,1
    80012faa:	fef42623          	sw	a5,-20(s0)
                    format++;
    80012fae:	f8043783          	ld	a5,-128(s0)
    80012fb2:	0785                	addi	a5,a5,1
    80012fb4:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80012fb8:	4785                	li	a5,1
    80012fba:	fef42023          	sw	a5,-32(s0)
                    break;
    80012fbe:	a041                	j	8001303e <_vsnprintf+0x164>
                case '-':
                    flags |= FLAGS_LEFT;
    80012fc0:	fec42783          	lw	a5,-20(s0)
    80012fc4:	0027e793          	ori	a5,a5,2
    80012fc8:	fef42623          	sw	a5,-20(s0)
                    format++;
    80012fcc:	f8043783          	ld	a5,-128(s0)
    80012fd0:	0785                	addi	a5,a5,1
    80012fd2:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80012fd6:	4785                	li	a5,1
    80012fd8:	fef42023          	sw	a5,-32(s0)
                    break;
    80012fdc:	a08d                	j	8001303e <_vsnprintf+0x164>
                case '+':
                    flags |= FLAGS_PLUS;
    80012fde:	fec42783          	lw	a5,-20(s0)
    80012fe2:	0047e793          	ori	a5,a5,4
    80012fe6:	fef42623          	sw	a5,-20(s0)
                    format++;
    80012fea:	f8043783          	ld	a5,-128(s0)
    80012fee:	0785                	addi	a5,a5,1
    80012ff0:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80012ff4:	4785                	li	a5,1
    80012ff6:	fef42023          	sw	a5,-32(s0)
                    break;
    80012ffa:	a091                	j	8001303e <_vsnprintf+0x164>
                case ' ':
                    flags |= FLAGS_SPACE;
    80012ffc:	fec42783          	lw	a5,-20(s0)
    80013000:	0087e793          	ori	a5,a5,8
    80013004:	fef42623          	sw	a5,-20(s0)
                    format++;
    80013008:	f8043783          	ld	a5,-128(s0)
    8001300c:	0785                	addi	a5,a5,1
    8001300e:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80013012:	4785                	li	a5,1
    80013014:	fef42023          	sw	a5,-32(s0)
                    break;
    80013018:	a01d                	j	8001303e <_vsnprintf+0x164>
                case '#':
                    flags |= FLAGS_HASH;
    8001301a:	fec42783          	lw	a5,-20(s0)
    8001301e:	0107e793          	ori	a5,a5,16
    80013022:	fef42623          	sw	a5,-20(s0)
                    format++;
    80013026:	f8043783          	ld	a5,-128(s0)
    8001302a:	0785                	addi	a5,a5,1
    8001302c:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    80013030:	4785                	li	a5,1
    80013032:	fef42023          	sw	a5,-32(s0)
                    break;
    80013036:	a021                	j	8001303e <_vsnprintf+0x164>
                default:
                    n = 0U;
    80013038:	fe042023          	sw	zero,-32(s0)
                    break;
    8001303c:	0001                	nop
            }
        } while (n);
    8001303e:	fe042783          	lw	a5,-32(s0)
    80013042:	2781                	sext.w	a5,a5
    80013044:	f385                	bnez	a5,80012f64 <_vsnprintf+0x8a>

        // evaluate width field
        width = 0U;
    80013046:	fe042423          	sw	zero,-24(s0)
        if (_is_digit(*format)) {
    8001304a:	f8043783          	ld	a5,-128(s0)
    8001304e:	0007c783          	lbu	a5,0(a5)
    80013052:	853e                	mv	a0,a5
    80013054:	df3fe0ef          	jal	ra,80011e46 <_is_digit>
    80013058:	87aa                	mv	a5,a0
    8001305a:	cb91                	beqz	a5,8001306e <_vsnprintf+0x194>
            width = _atoi(&format);
    8001305c:	f8040793          	addi	a5,s0,-128
    80013060:	853e                	mv	a0,a5
    80013062:	e25fe0ef          	jal	ra,80011e86 <_atoi>
    80013066:	87aa                	mv	a5,a0
    80013068:	fef42423          	sw	a5,-24(s0)
    8001306c:	a8b9                	j	800130ca <_vsnprintf+0x1f0>
        }
        else if (*format == '*') {
    8001306e:	f8043783          	ld	a5,-128(s0)
    80013072:	0007c783          	lbu	a5,0(a5)
    80013076:	873e                	mv	a4,a5
    80013078:	02a00793          	li	a5,42
    8001307c:	04f71763          	bne	a4,a5,800130ca <_vsnprintf+0x1f0>
            const int w = va_arg(va, int);
    80013080:	f7843783          	ld	a5,-136(s0)
    80013084:	00878713          	addi	a4,a5,8
    80013088:	f6e43c23          	sd	a4,-136(s0)
    8001308c:	439c                	lw	a5,0(a5)
    8001308e:	fcf42023          	sw	a5,-64(s0)
            if (w < 0) {
    80013092:	fc042783          	lw	a5,-64(s0)
    80013096:	2781                	sext.w	a5,a5
    80013098:	0207d063          	bgez	a5,800130b8 <_vsnprintf+0x1de>
                flags |= FLAGS_LEFT;  // reverse padding
    8001309c:	fec42783          	lw	a5,-20(s0)
    800130a0:	0027e793          	ori	a5,a5,2
    800130a4:	fef42623          	sw	a5,-20(s0)
                width = (unsigned int)-w;
    800130a8:	fc042783          	lw	a5,-64(s0)
    800130ac:	40f007bb          	negw	a5,a5
    800130b0:	2781                	sext.w	a5,a5
    800130b2:	fef42423          	sw	a5,-24(s0)
    800130b6:	a029                	j	800130c0 <_vsnprintf+0x1e6>
            }
            else {
                width = (unsigned int)w;
    800130b8:	fc042783          	lw	a5,-64(s0)
    800130bc:	fef42423          	sw	a5,-24(s0)
            }
            format++;
    800130c0:	f8043783          	ld	a5,-128(s0)
    800130c4:	0785                	addi	a5,a5,1
    800130c6:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate precision field
        precision = 0U;
    800130ca:	fe042223          	sw	zero,-28(s0)
        if (*format == '.') {
    800130ce:	f8043783          	ld	a5,-128(s0)
    800130d2:	0007c783          	lbu	a5,0(a5)
    800130d6:	873e                	mv	a4,a5
    800130d8:	02e00793          	li	a5,46
    800130dc:	08f71063          	bne	a4,a5,8001315c <_vsnprintf+0x282>
            flags |= FLAGS_PRECISION;
    800130e0:	fec42783          	lw	a5,-20(s0)
    800130e4:	4007e793          	ori	a5,a5,1024
    800130e8:	fef42623          	sw	a5,-20(s0)
            format++;
    800130ec:	f8043783          	ld	a5,-128(s0)
    800130f0:	0785                	addi	a5,a5,1
    800130f2:	f8f43023          	sd	a5,-128(s0)
            if (_is_digit(*format)) {
    800130f6:	f8043783          	ld	a5,-128(s0)
    800130fa:	0007c783          	lbu	a5,0(a5)
    800130fe:	853e                	mv	a0,a5
    80013100:	d47fe0ef          	jal	ra,80011e46 <_is_digit>
    80013104:	87aa                	mv	a5,a0
    80013106:	cb91                	beqz	a5,8001311a <_vsnprintf+0x240>
                precision = _atoi(&format);
    80013108:	f8040793          	addi	a5,s0,-128
    8001310c:	853e                	mv	a0,a5
    8001310e:	d79fe0ef          	jal	ra,80011e86 <_atoi>
    80013112:	87aa                	mv	a5,a0
    80013114:	fef42223          	sw	a5,-28(s0)
    80013118:	a091                	j	8001315c <_vsnprintf+0x282>
            }
            else if (*format == '*') {
    8001311a:	f8043783          	ld	a5,-128(s0)
    8001311e:	0007c783          	lbu	a5,0(a5)
    80013122:	873e                	mv	a4,a5
    80013124:	02a00793          	li	a5,42
    80013128:	02f71a63          	bne	a4,a5,8001315c <_vsnprintf+0x282>
                const int prec = (int)va_arg(va, int);
    8001312c:	f7843783          	ld	a5,-136(s0)
    80013130:	00878713          	addi	a4,a5,8
    80013134:	f6e43c23          	sd	a4,-136(s0)
    80013138:	439c                	lw	a5,0(a5)
    8001313a:	faf42e23          	sw	a5,-68(s0)
                precision      = prec > 0 ? (unsigned int)prec : 0U;
    8001313e:	fbc42783          	lw	a5,-68(s0)
    80013142:	0007871b          	sext.w	a4,a5
    80013146:	00075363          	bgez	a4,8001314c <_vsnprintf+0x272>
    8001314a:	4781                	li	a5,0
    8001314c:	2781                	sext.w	a5,a5
    8001314e:	fef42223          	sw	a5,-28(s0)
                format++;
    80013152:	f8043783          	ld	a5,-128(s0)
    80013156:	0785                	addi	a5,a5,1
    80013158:	f8f43023          	sd	a5,-128(s0)
            }
        }

        // evaluate length field
        switch (*format) {
    8001315c:	f8043783          	ld	a5,-128(s0)
    80013160:	0007c783          	lbu	a5,0(a5)
    80013164:	2781                	sext.w	a5,a5
    80013166:	f987869b          	addiw	a3,a5,-104
    8001316a:	0006871b          	sext.w	a4,a3
    8001316e:	47c9                	li	a5,18
    80013170:	0ee7e963          	bltu	a5,a4,80013262 <_vsnprintf+0x388>
    80013174:	02069793          	slli	a5,a3,0x20
    80013178:	9381                	srli	a5,a5,0x20
    8001317a:	00279713          	slli	a4,a5,0x2
    8001317e:	00014797          	auipc	a5,0x14
    80013182:	b4278793          	addi	a5,a5,-1214 # 80026cc0 <SYSCALLS+0xc90>
    80013186:	97ba                	add	a5,a5,a4
    80013188:	439c                	lw	a5,0(a5)
    8001318a:	0007871b          	sext.w	a4,a5
    8001318e:	00014797          	auipc	a5,0x14
    80013192:	b3278793          	addi	a5,a5,-1230 # 80026cc0 <SYSCALLS+0xc90>
    80013196:	97ba                	add	a5,a5,a4
    80013198:	8782                	jr	a5
            case 'l':
                flags |= FLAGS_LONG;
    8001319a:	fec42783          	lw	a5,-20(s0)
    8001319e:	1007e793          	ori	a5,a5,256
    800131a2:	fef42623          	sw	a5,-20(s0)
                format++;
    800131a6:	f8043783          	ld	a5,-128(s0)
    800131aa:	0785                	addi	a5,a5,1
    800131ac:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'l') {
    800131b0:	f8043783          	ld	a5,-128(s0)
    800131b4:	0007c783          	lbu	a5,0(a5)
    800131b8:	873e                	mv	a4,a5
    800131ba:	06c00793          	li	a5,108
    800131be:	0af71463          	bne	a4,a5,80013266 <_vsnprintf+0x38c>
                    flags |= FLAGS_LONG_LONG;
    800131c2:	fec42783          	lw	a5,-20(s0)
    800131c6:	2007e793          	ori	a5,a5,512
    800131ca:	fef42623          	sw	a5,-20(s0)
                    format++;
    800131ce:	f8043783          	ld	a5,-128(s0)
    800131d2:	0785                	addi	a5,a5,1
    800131d4:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    800131d8:	a079                	j	80013266 <_vsnprintf+0x38c>
            case 'h':
                flags |= FLAGS_SHORT;
    800131da:	fec42783          	lw	a5,-20(s0)
    800131de:	0807e793          	ori	a5,a5,128
    800131e2:	fef42623          	sw	a5,-20(s0)
                format++;
    800131e6:	f8043783          	ld	a5,-128(s0)
    800131ea:	0785                	addi	a5,a5,1
    800131ec:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'h') {
    800131f0:	f8043783          	ld	a5,-128(s0)
    800131f4:	0007c783          	lbu	a5,0(a5)
    800131f8:	873e                	mv	a4,a5
    800131fa:	06800793          	li	a5,104
    800131fe:	06f71663          	bne	a4,a5,8001326a <_vsnprintf+0x390>
                    flags |= FLAGS_CHAR;
    80013202:	fec42783          	lw	a5,-20(s0)
    80013206:	0407e793          	ori	a5,a5,64
    8001320a:	fef42623          	sw	a5,-20(s0)
                    format++;
    8001320e:	f8043783          	ld	a5,-128(s0)
    80013212:	0785                	addi	a5,a5,1
    80013214:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    80013218:	a889                	j	8001326a <_vsnprintf+0x390>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
            case 't':
                flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG
    8001321a:	fec42783          	lw	a5,-20(s0)
    8001321e:	1007e793          	ori	a5,a5,256
    80013222:	fef42623          	sw	a5,-20(s0)
                                                            : FLAGS_LONG_LONG);
                format++;
    80013226:	f8043783          	ld	a5,-128(s0)
    8001322a:	0785                	addi	a5,a5,1
    8001322c:	f8f43023          	sd	a5,-128(s0)
                break;
    80013230:	a835                	j	8001326c <_vsnprintf+0x392>
#endif
            case 'j':
                flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG
    80013232:	fec42783          	lw	a5,-20(s0)
    80013236:	1007e793          	ori	a5,a5,256
    8001323a:	fef42623          	sw	a5,-20(s0)
                                                           : FLAGS_LONG_LONG);
                format++;
    8001323e:	f8043783          	ld	a5,-128(s0)
    80013242:	0785                	addi	a5,a5,1
    80013244:	f8f43023          	sd	a5,-128(s0)
                break;
    80013248:	a015                	j	8001326c <_vsnprintf+0x392>
            case 'z':
                flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG
    8001324a:	fec42783          	lw	a5,-20(s0)
    8001324e:	1007e793          	ori	a5,a5,256
    80013252:	fef42623          	sw	a5,-20(s0)
                                                         : FLAGS_LONG_LONG);
                format++;
    80013256:	f8043783          	ld	a5,-128(s0)
    8001325a:	0785                	addi	a5,a5,1
    8001325c:	f8f43023          	sd	a5,-128(s0)
                break;
    80013260:	a031                	j	8001326c <_vsnprintf+0x392>
            default:
                break;
    80013262:	0001                	nop
    80013264:	a021                	j	8001326c <_vsnprintf+0x392>
                break;
    80013266:	0001                	nop
    80013268:	a011                	j	8001326c <_vsnprintf+0x392>
                break;
    8001326a:	0001                	nop
        }

        // evaluate specifier
        switch (*format) {
    8001326c:	f8043783          	ld	a5,-128(s0)
    80013270:	0007c783          	lbu	a5,0(a5)
    80013274:	2781                	sext.w	a5,a5
    80013276:	fdb7869b          	addiw	a3,a5,-37
    8001327a:	0006871b          	sext.w	a4,a3
    8001327e:	05300793          	li	a5,83
    80013282:	7ce7e863          	bltu	a5,a4,80013a52 <_vsnprintf+0xb78>
    80013286:	02069793          	slli	a5,a3,0x20
    8001328a:	9381                	srli	a5,a5,0x20
    8001328c:	00279713          	slli	a4,a5,0x2
    80013290:	00014797          	auipc	a5,0x14
    80013294:	a7c78793          	addi	a5,a5,-1412 # 80026d0c <SYSCALLS+0xcdc>
    80013298:	97ba                	add	a5,a5,a4
    8001329a:	439c                	lw	a5,0(a5)
    8001329c:	0007871b          	sext.w	a4,a5
    800132a0:	00014797          	auipc	a5,0x14
    800132a4:	a6c78793          	addi	a5,a5,-1428 # 80026d0c <SYSCALLS+0xcdc>
    800132a8:	97ba                	add	a5,a5,a4
    800132aa:	8782                	jr	a5
            case 'X':
            case 'o':
            case 'b': {
                // set the base
                unsigned int base;
                if (*format == 'x' || *format == 'X') {
    800132ac:	f8043783          	ld	a5,-128(s0)
    800132b0:	0007c783          	lbu	a5,0(a5)
    800132b4:	873e                	mv	a4,a5
    800132b6:	07800793          	li	a5,120
    800132ba:	00f70b63          	beq	a4,a5,800132d0 <_vsnprintf+0x3f6>
    800132be:	f8043783          	ld	a5,-128(s0)
    800132c2:	0007c783          	lbu	a5,0(a5)
    800132c6:	873e                	mv	a4,a5
    800132c8:	05800793          	li	a5,88
    800132cc:	00f71663          	bne	a4,a5,800132d8 <_vsnprintf+0x3fe>
                    base = 16U;
    800132d0:	47c1                	li	a5,16
    800132d2:	fcf42a23          	sw	a5,-44(s0)
    800132d6:	a099                	j	8001331c <_vsnprintf+0x442>
                }
                else if (*format == 'o') {
    800132d8:	f8043783          	ld	a5,-128(s0)
    800132dc:	0007c783          	lbu	a5,0(a5)
    800132e0:	873e                	mv	a4,a5
    800132e2:	06f00793          	li	a5,111
    800132e6:	00f71663          	bne	a4,a5,800132f2 <_vsnprintf+0x418>
                    base = 8U;
    800132ea:	47a1                	li	a5,8
    800132ec:	fcf42a23          	sw	a5,-44(s0)
    800132f0:	a035                	j	8001331c <_vsnprintf+0x442>
                }
                else if (*format == 'b') {
    800132f2:	f8043783          	ld	a5,-128(s0)
    800132f6:	0007c783          	lbu	a5,0(a5)
    800132fa:	873e                	mv	a4,a5
    800132fc:	06200793          	li	a5,98
    80013300:	00f71663          	bne	a4,a5,8001330c <_vsnprintf+0x432>
                    base = 2U;
    80013304:	4789                	li	a5,2
    80013306:	fcf42a23          	sw	a5,-44(s0)
    8001330a:	a809                	j	8001331c <_vsnprintf+0x442>
                }
                else {
                    base = 10U;
    8001330c:	47a9                	li	a5,10
    8001330e:	fcf42a23          	sw	a5,-44(s0)
                    flags &= ~FLAGS_HASH;  // no hash for dec format
    80013312:	fec42783          	lw	a5,-20(s0)
    80013316:	9bbd                	andi	a5,a5,-17
    80013318:	fef42623          	sw	a5,-20(s0)
                }
                // uppercase
                if (*format == 'X') {
    8001331c:	f8043783          	ld	a5,-128(s0)
    80013320:	0007c783          	lbu	a5,0(a5)
    80013324:	873e                	mv	a4,a5
    80013326:	05800793          	li	a5,88
    8001332a:	00f71863          	bne	a4,a5,8001333a <_vsnprintf+0x460>
                    flags |= FLAGS_UPPERCASE;
    8001332e:	fec42783          	lw	a5,-20(s0)
    80013332:	0207e793          	ori	a5,a5,32
    80013336:	fef42623          	sw	a5,-20(s0)
                }

                // no plus or space flag for u, x, X, o, b
                if ((*format != 'i') && (*format != 'd')) {
    8001333a:	f8043783          	ld	a5,-128(s0)
    8001333e:	0007c783          	lbu	a5,0(a5)
    80013342:	873e                	mv	a4,a5
    80013344:	06900793          	li	a5,105
    80013348:	02f70063          	beq	a4,a5,80013368 <_vsnprintf+0x48e>
    8001334c:	f8043783          	ld	a5,-128(s0)
    80013350:	0007c783          	lbu	a5,0(a5)
    80013354:	873e                	mv	a4,a5
    80013356:	06400793          	li	a5,100
    8001335a:	00f70763          	beq	a4,a5,80013368 <_vsnprintf+0x48e>
                    flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    8001335e:	fec42783          	lw	a5,-20(s0)
    80013362:	9bcd                	andi	a5,a5,-13
    80013364:	fef42623          	sw	a5,-20(s0)
                }

                // ignore '0' flag when precision is given
                if (flags & FLAGS_PRECISION) {
    80013368:	fec42783          	lw	a5,-20(s0)
    8001336c:	4007f793          	andi	a5,a5,1024
    80013370:	2781                	sext.w	a5,a5
    80013372:	c791                	beqz	a5,8001337e <_vsnprintf+0x4a4>
                    flags &= ~FLAGS_ZEROPAD;
    80013374:	fec42783          	lw	a5,-20(s0)
    80013378:	9bf9                	andi	a5,a5,-2
    8001337a:	fef42623          	sw	a5,-20(s0)
                }

                // convert the integer
                if ((*format == 'i') || (*format == 'd')) {
    8001337e:	f8043783          	ld	a5,-128(s0)
    80013382:	0007c783          	lbu	a5,0(a5)
    80013386:	873e                	mv	a4,a5
    80013388:	06900793          	li	a5,105
    8001338c:	00f70b63          	beq	a4,a5,800133a2 <_vsnprintf+0x4c8>
    80013390:	f8043783          	ld	a5,-128(s0)
    80013394:	0007c783          	lbu	a5,0(a5)
    80013398:	873e                	mv	a4,a5
    8001339a:	06400793          	li	a5,100
    8001339e:	18f71d63          	bne	a4,a5,80013538 <_vsnprintf+0x65e>
                    // signed
                    if (flags & FLAGS_LONG_LONG) {
    800133a2:	fec42783          	lw	a5,-20(s0)
    800133a6:	2007f793          	andi	a5,a5,512
    800133aa:	2781                	sext.w	a5,a5
    800133ac:	c3bd                	beqz	a5,80013412 <_vsnprintf+0x538>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        const long long value = va_arg(va, long long);
    800133ae:	f7843783          	ld	a5,-136(s0)
    800133b2:	00878713          	addi	a4,a5,8
    800133b6:	f6e43c23          	sd	a4,-136(s0)
    800133ba:	639c                	ld	a5,0(a5)
    800133bc:	faf43023          	sd	a5,-96(s0)
                        idx                   = _ntoa_long_long(
                                              out, buffer, idx, maxlen,
                                              (unsigned long long)(value > 0 ? value : 0 - value),
    800133c0:	fa043783          	ld	a5,-96(s0)
    800133c4:	43f7d713          	srai	a4,a5,0x3f
    800133c8:	fa043783          	ld	a5,-96(s0)
    800133cc:	8fb9                	xor	a5,a5,a4
    800133ce:	8f99                	sub	a5,a5,a4
                        idx                   = _ntoa_long_long(
    800133d0:	85be                	mv	a1,a5
    800133d2:	fa043783          	ld	a5,-96(s0)
    800133d6:	93fd                	srli	a5,a5,0x3f
    800133d8:	0ff7f713          	andi	a4,a5,255
    800133dc:	fd446683          	lwu	a3,-44(s0)
    800133e0:	fe442603          	lw	a2,-28(s0)
    800133e4:	fec42783          	lw	a5,-20(s0)
    800133e8:	e43e                	sd	a5,8(sp)
    800133ea:	fe842783          	lw	a5,-24(s0)
    800133ee:	e03e                	sd	a5,0(sp)
    800133f0:	88b2                	mv	a7,a2
    800133f2:	8836                	mv	a6,a3
    800133f4:	87ba                	mv	a5,a4
    800133f6:	872e                	mv	a4,a1
    800133f8:	f8843683          	ld	a3,-120(s0)
    800133fc:	fd843603          	ld	a2,-40(s0)
    80013400:	f9043583          	ld	a1,-112(s0)
    80013404:	f9843503          	ld	a0,-104(s0)
    80013408:	fadfe0ef          	jal	ra,800123b4 <_ntoa_long_long>
    8001340c:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80013410:	ac89                	j	80013662 <_vsnprintf+0x788>
                                              value < 0, base, precision, width, flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80013412:	fec42783          	lw	a5,-20(s0)
    80013416:	1007f793          	andi	a5,a5,256
    8001341a:	2781                	sext.w	a5,a5
    8001341c:	c3bd                	beqz	a5,80013482 <_vsnprintf+0x5a8>
                        const long value = va_arg(va, long);
    8001341e:	f7843783          	ld	a5,-136(s0)
    80013422:	00878713          	addi	a4,a5,8
    80013426:	f6e43c23          	sd	a4,-136(s0)
    8001342a:	639c                	ld	a5,0(a5)
    8001342c:	faf43423          	sd	a5,-88(s0)
                        idx              = _ntoa_long(
                                         out, buffer, idx, maxlen,
                                         (unsigned long)(value > 0 ? value : 0 - value),
    80013430:	fa843783          	ld	a5,-88(s0)
    80013434:	43f7d713          	srai	a4,a5,0x3f
    80013438:	fa843783          	ld	a5,-88(s0)
    8001343c:	8fb9                	xor	a5,a5,a4
    8001343e:	8f99                	sub	a5,a5,a4
                        idx              = _ntoa_long(
    80013440:	85be                	mv	a1,a5
    80013442:	fa843783          	ld	a5,-88(s0)
    80013446:	93fd                	srli	a5,a5,0x3f
    80013448:	0ff7f713          	andi	a4,a5,255
    8001344c:	fd446683          	lwu	a3,-44(s0)
    80013450:	fe442603          	lw	a2,-28(s0)
    80013454:	fec42783          	lw	a5,-20(s0)
    80013458:	e43e                	sd	a5,8(sp)
    8001345a:	fe842783          	lw	a5,-24(s0)
    8001345e:	e03e                	sd	a5,0(sp)
    80013460:	88b2                	mv	a7,a2
    80013462:	8836                	mv	a6,a3
    80013464:	87ba                	mv	a5,a4
    80013466:	872e                	mv	a4,a1
    80013468:	f8843683          	ld	a3,-120(s0)
    8001346c:	fd843603          	ld	a2,-40(s0)
    80013470:	f9043583          	ld	a1,-112(s0)
    80013474:	f9843503          	ld	a0,-104(s0)
    80013478:	e25fe0ef          	jal	ra,8001229c <_ntoa_long>
    8001347c:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80013480:	a2cd                	j	80013662 <_vsnprintf+0x788>
                                         value < 0, base, precision, width, flags);
                    }
                    else {
                        const int value =
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80013482:	fec42783          	lw	a5,-20(s0)
    80013486:	0407f793          	andi	a5,a5,64
    8001348a:	2781                	sext.w	a5,a5
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    8001348c:	cf81                	beqz	a5,800134a4 <_vsnprintf+0x5ca>
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    8001348e:	f7843783          	ld	a5,-136(s0)
    80013492:	00878713          	addi	a4,a5,8
    80013496:	f6e43c23          	sd	a4,-136(s0)
    8001349a:	439c                	lw	a5,0(a5)
    8001349c:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    800134a0:	2781                	sext.w	a5,a5
    800134a2:	a81d                	j	800134d8 <_vsnprintf+0x5fe>
    800134a4:	fec42783          	lw	a5,-20(s0)
    800134a8:	0807f793          	andi	a5,a5,128
    800134ac:	2781                	sext.w	a5,a5
                                                    : va_arg(va, int);
    800134ae:	cf91                	beqz	a5,800134ca <_vsnprintf+0x5f0>
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    800134b0:	f7843783          	ld	a5,-136(s0)
    800134b4:	00878713          	addi	a4,a5,8
    800134b8:	f6e43c23          	sd	a4,-136(s0)
    800134bc:	439c                	lw	a5,0(a5)
    800134be:	0107979b          	slliw	a5,a5,0x10
    800134c2:	4107d79b          	sraiw	a5,a5,0x10
                                                    : va_arg(va, int);
    800134c6:	2781                	sext.w	a5,a5
    800134c8:	a801                	j	800134d8 <_vsnprintf+0x5fe>
    800134ca:	f7843783          	ld	a5,-136(s0)
    800134ce:	00878713          	addi	a4,a5,8
    800134d2:	f6e43c23          	sd	a4,-136(s0)
    800134d6:	439c                	lw	a5,0(a5)
                        const int value =
    800134d8:	faf42823          	sw	a5,-80(s0)
                        idx = _ntoa_long(
                            out, buffer, idx, maxlen,
                            (unsigned int)(value > 0 ? value : 0 - value),
    800134dc:	fb042783          	lw	a5,-80(s0)
    800134e0:	41f7d79b          	sraiw	a5,a5,0x1f
    800134e4:	fb042703          	lw	a4,-80(s0)
    800134e8:	8f3d                	xor	a4,a4,a5
    800134ea:	40f707bb          	subw	a5,a4,a5
    800134ee:	2781                	sext.w	a5,a5
    800134f0:	2781                	sext.w	a5,a5
                        idx = _ntoa_long(
    800134f2:	02079713          	slli	a4,a5,0x20
    800134f6:	9301                	srli	a4,a4,0x20
    800134f8:	fb042783          	lw	a5,-80(s0)
    800134fc:	01f7d79b          	srliw	a5,a5,0x1f
    80013500:	0ff7f693          	andi	a3,a5,255
    80013504:	fd446603          	lwu	a2,-44(s0)
    80013508:	fe442583          	lw	a1,-28(s0)
    8001350c:	fec42783          	lw	a5,-20(s0)
    80013510:	e43e                	sd	a5,8(sp)
    80013512:	fe842783          	lw	a5,-24(s0)
    80013516:	e03e                	sd	a5,0(sp)
    80013518:	88ae                	mv	a7,a1
    8001351a:	8832                	mv	a6,a2
    8001351c:	87b6                	mv	a5,a3
    8001351e:	f8843683          	ld	a3,-120(s0)
    80013522:	fd843603          	ld	a2,-40(s0)
    80013526:	f9043583          	ld	a1,-112(s0)
    8001352a:	f9843503          	ld	a0,-104(s0)
    8001352e:	d6ffe0ef          	jal	ra,8001229c <_ntoa_long>
    80013532:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80013536:	a235                	j	80013662 <_vsnprintf+0x788>
                            value < 0, base, precision, width, flags);
                    }
                }
                else {
                    // unsigned
                    if (flags & FLAGS_LONG_LONG) {
    80013538:	fec42783          	lw	a5,-20(s0)
    8001353c:	2007f793          	andi	a5,a5,512
    80013540:	2781                	sext.w	a5,a5
    80013542:	c3b1                	beqz	a5,80013586 <_vsnprintf+0x6ac>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80013544:	f7843783          	ld	a5,-136(s0)
    80013548:	00878713          	addi	a4,a5,8
    8001354c:	f6e43c23          	sd	a4,-136(s0)
    80013550:	6398                	ld	a4,0(a5)
    80013552:	fd446683          	lwu	a3,-44(s0)
    80013556:	fe442603          	lw	a2,-28(s0)
    8001355a:	fec42783          	lw	a5,-20(s0)
    8001355e:	e43e                	sd	a5,8(sp)
    80013560:	fe842783          	lw	a5,-24(s0)
    80013564:	e03e                	sd	a5,0(sp)
    80013566:	88b2                	mv	a7,a2
    80013568:	8836                	mv	a6,a3
    8001356a:	4781                	li	a5,0
    8001356c:	f8843683          	ld	a3,-120(s0)
    80013570:	fd843603          	ld	a2,-40(s0)
    80013574:	f9043583          	ld	a1,-112(s0)
    80013578:	f9843503          	ld	a0,-104(s0)
    8001357c:	e39fe0ef          	jal	ra,800123b4 <_ntoa_long_long>
    80013580:	fca43c23          	sd	a0,-40(s0)
    80013584:	a8f9                	j	80013662 <_vsnprintf+0x788>
                                              va_arg(va, unsigned long long),
                                              false, base, precision, width,
                                              flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80013586:	fec42783          	lw	a5,-20(s0)
    8001358a:	1007f793          	andi	a5,a5,256
    8001358e:	2781                	sext.w	a5,a5
    80013590:	c3b1                	beqz	a5,800135d4 <_vsnprintf+0x6fa>
                        idx = _ntoa_long(out, buffer, idx, maxlen,
    80013592:	f7843783          	ld	a5,-136(s0)
    80013596:	00878713          	addi	a4,a5,8
    8001359a:	f6e43c23          	sd	a4,-136(s0)
    8001359e:	6398                	ld	a4,0(a5)
    800135a0:	fd446683          	lwu	a3,-44(s0)
    800135a4:	fe442603          	lw	a2,-28(s0)
    800135a8:	fec42783          	lw	a5,-20(s0)
    800135ac:	e43e                	sd	a5,8(sp)
    800135ae:	fe842783          	lw	a5,-24(s0)
    800135b2:	e03e                	sd	a5,0(sp)
    800135b4:	88b2                	mv	a7,a2
    800135b6:	8836                	mv	a6,a3
    800135b8:	4781                	li	a5,0
    800135ba:	f8843683          	ld	a3,-120(s0)
    800135be:	fd843603          	ld	a2,-40(s0)
    800135c2:	f9043583          	ld	a1,-112(s0)
    800135c6:	f9843503          	ld	a0,-104(s0)
    800135ca:	cd3fe0ef          	jal	ra,8001229c <_ntoa_long>
    800135ce:	fca43c23          	sd	a0,-40(s0)
    800135d2:	a841                	j	80013662 <_vsnprintf+0x788>
                                         va_arg(va, unsigned long), false, base,
                                         precision, width, flags);
                    }
                    else {
                        const unsigned int value =
                            (flags & FLAGS_CHAR)
    800135d4:	fec42783          	lw	a5,-20(s0)
    800135d8:	0407f793          	andi	a5,a5,64
    800135dc:	2781                	sext.w	a5,a5
                                ? (unsigned char)va_arg(va, unsigned int)
                            : (flags & FLAGS_SHORT)
    800135de:	cf81                	beqz	a5,800135f6 <_vsnprintf+0x71c>
                                ? (unsigned char)va_arg(va, unsigned int)
    800135e0:	f7843783          	ld	a5,-136(s0)
    800135e4:	00878713          	addi	a4,a5,8
    800135e8:	f6e43c23          	sd	a4,-136(s0)
    800135ec:	439c                	lw	a5,0(a5)
    800135ee:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT)
    800135f2:	2781                	sext.w	a5,a5
    800135f4:	a815                	j	80013628 <_vsnprintf+0x74e>
    800135f6:	fec42783          	lw	a5,-20(s0)
    800135fa:	0807f793          	andi	a5,a5,128
    800135fe:	2781                	sext.w	a5,a5
                                ? (unsigned short int)va_arg(va, unsigned int)
                                : va_arg(va, unsigned int);
    80013600:	cf81                	beqz	a5,80013618 <_vsnprintf+0x73e>
                                ? (unsigned short int)va_arg(va, unsigned int)
    80013602:	f7843783          	ld	a5,-136(s0)
    80013606:	00878713          	addi	a4,a5,8
    8001360a:	f6e43c23          	sd	a4,-136(s0)
    8001360e:	439c                	lw	a5,0(a5)
    80013610:	17c2                	slli	a5,a5,0x30
    80013612:	93c1                	srli	a5,a5,0x30
                                : va_arg(va, unsigned int);
    80013614:	2781                	sext.w	a5,a5
    80013616:	a801                	j	80013626 <_vsnprintf+0x74c>
    80013618:	f7843783          	ld	a5,-136(s0)
    8001361c:	00878713          	addi	a4,a5,8
    80013620:	f6e43c23          	sd	a4,-136(s0)
    80013624:	439c                	lw	a5,0(a5)
                            : (flags & FLAGS_SHORT)
    80013626:	2781                	sext.w	a5,a5
                        const unsigned int value =
    80013628:	faf42a23          	sw	a5,-76(s0)
                        idx = _ntoa_long(out, buffer, idx, maxlen, value, false,
    8001362c:	fb446703          	lwu	a4,-76(s0)
    80013630:	fd446683          	lwu	a3,-44(s0)
    80013634:	fe442603          	lw	a2,-28(s0)
    80013638:	fec42783          	lw	a5,-20(s0)
    8001363c:	e43e                	sd	a5,8(sp)
    8001363e:	fe842783          	lw	a5,-24(s0)
    80013642:	e03e                	sd	a5,0(sp)
    80013644:	88b2                	mv	a7,a2
    80013646:	8836                	mv	a6,a3
    80013648:	4781                	li	a5,0
    8001364a:	f8843683          	ld	a3,-120(s0)
    8001364e:	fd843603          	ld	a2,-40(s0)
    80013652:	f9043583          	ld	a1,-112(s0)
    80013656:	f9843503          	ld	a0,-104(s0)
    8001365a:	c43fe0ef          	jal	ra,8001229c <_ntoa_long>
    8001365e:	fca43c23          	sd	a0,-40(s0)
                                         base, precision, width, flags);
                    }
                }
                format++;
    80013662:	f8043783          	ld	a5,-128(s0)
    80013666:	0785                	addi	a5,a5,1
    80013668:	f8f43023          	sd	a5,-128(s0)
                break;
    8001366c:	a919                	j	80013a82 <_vsnprintf+0xba8>
            }
#if defined(PRINTF_SUPPORT_FLOAT)
            case 'f':
            case 'F':
                if (*format == 'F')
    8001366e:	f8043783          	ld	a5,-128(s0)
    80013672:	0007c783          	lbu	a5,0(a5)
    80013676:	873e                	mv	a4,a5
    80013678:	04600793          	li	a5,70
    8001367c:	00f71863          	bne	a4,a5,8001368c <_vsnprintf+0x7b2>
                    flags |= FLAGS_UPPERCASE;
    80013680:	fec42783          	lw	a5,-20(s0)
    80013684:	0207e793          	ori	a5,a5,32
    80013688:	fef42623          	sw	a5,-20(s0)
                idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double),
    8001368c:	f7843783          	ld	a5,-136(s0)
    80013690:	00878713          	addi	a4,a5,8
    80013694:	f6e43c23          	sd	a4,-136(s0)
    80013698:	239c                	fld	fa5,0(a5)
    8001369a:	fec42683          	lw	a3,-20(s0)
    8001369e:	fe842783          	lw	a5,-24(s0)
    800136a2:	fe442703          	lw	a4,-28(s0)
    800136a6:	8836                	mv	a6,a3
    800136a8:	22f78553          	fmv.d	fa0,fa5
    800136ac:	f8843683          	ld	a3,-120(s0)
    800136b0:	fd843603          	ld	a2,-40(s0)
    800136b4:	f9043583          	ld	a1,-112(s0)
    800136b8:	f9843503          	ld	a0,-104(s0)
    800136bc:	e11fe0ef          	jal	ra,800124cc <_ftoa>
    800136c0:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    800136c4:	f8043783          	ld	a5,-128(s0)
    800136c8:	0785                	addi	a5,a5,1
    800136ca:	f8f43023          	sd	a5,-128(s0)
                break;
    800136ce:	ae55                	j	80013a82 <_vsnprintf+0xba8>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
            case 'e':
            case 'E':
            case 'g':
            case 'G':
                if ((*format == 'g') || (*format == 'G'))
    800136d0:	f8043783          	ld	a5,-128(s0)
    800136d4:	0007c783          	lbu	a5,0(a5)
    800136d8:	873e                	mv	a4,a5
    800136da:	06700793          	li	a5,103
    800136de:	00f70b63          	beq	a4,a5,800136f4 <_vsnprintf+0x81a>
    800136e2:	f8043783          	ld	a5,-128(s0)
    800136e6:	0007c783          	lbu	a5,0(a5)
    800136ea:	873e                	mv	a4,a5
    800136ec:	04700793          	li	a5,71
    800136f0:	00f71a63          	bne	a4,a5,80013704 <_vsnprintf+0x82a>
                    flags |= FLAGS_ADAPT_EXP;
    800136f4:	fec42703          	lw	a4,-20(s0)
    800136f8:	6785                	lui	a5,0x1
    800136fa:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    800136fe:	8fd9                	or	a5,a5,a4
    80013700:	fef42623          	sw	a5,-20(s0)
                if ((*format == 'E') || (*format == 'G'))
    80013704:	f8043783          	ld	a5,-128(s0)
    80013708:	0007c783          	lbu	a5,0(a5)
    8001370c:	873e                	mv	a4,a5
    8001370e:	04500793          	li	a5,69
    80013712:	00f70b63          	beq	a4,a5,80013728 <_vsnprintf+0x84e>
    80013716:	f8043783          	ld	a5,-128(s0)
    8001371a:	0007c783          	lbu	a5,0(a5)
    8001371e:	873e                	mv	a4,a5
    80013720:	04700793          	li	a5,71
    80013724:	00f71863          	bne	a4,a5,80013734 <_vsnprintf+0x85a>
                    flags |= FLAGS_UPPERCASE;
    80013728:	fec42783          	lw	a5,-20(s0)
    8001372c:	0207e793          	ori	a5,a5,32
    80013730:	fef42623          	sw	a5,-20(s0)
                idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double),
    80013734:	f7843783          	ld	a5,-136(s0)
    80013738:	00878713          	addi	a4,a5,8
    8001373c:	f6e43c23          	sd	a4,-136(s0)
    80013740:	239c                	fld	fa5,0(a5)
    80013742:	fec42683          	lw	a3,-20(s0)
    80013746:	fe842783          	lw	a5,-24(s0)
    8001374a:	fe442703          	lw	a4,-28(s0)
    8001374e:	8836                	mv	a6,a3
    80013750:	22f78553          	fmv.d	fa0,fa5
    80013754:	f8843683          	ld	a3,-120(s0)
    80013758:	fd843603          	ld	a2,-40(s0)
    8001375c:	f9043583          	ld	a1,-112(s0)
    80013760:	f9843503          	ld	a0,-104(s0)
    80013764:	ab4ff0ef          	jal	ra,80012a18 <_etoa>
    80013768:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    8001376c:	f8043783          	ld	a5,-128(s0)
    80013770:	0785                	addi	a5,a5,1
    80013772:	f8f43023          	sd	a5,-128(s0)
                break;
    80013776:	a631                	j	80013a82 <_vsnprintf+0xba8>
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
            case 'c': {
                unsigned int l = 1U;
    80013778:	4785                	li	a5,1
    8001377a:	fcf42823          	sw	a5,-48(s0)
                // pre padding
                if (!(flags & FLAGS_LEFT)) {
    8001377e:	fec42783          	lw	a5,-20(s0)
    80013782:	8b89                	andi	a5,a5,2
    80013784:	2781                	sext.w	a5,a5
    80013786:	ef8d                	bnez	a5,800137c0 <_vsnprintf+0x8e6>
                    while (l++ < width) {
    80013788:	a00d                	j	800137aa <_vsnprintf+0x8d0>
                        out(' ', buffer, idx++, maxlen);
    8001378a:	fd843783          	ld	a5,-40(s0)
    8001378e:	00178713          	addi	a4,a5,1
    80013792:	fce43c23          	sd	a4,-40(s0)
    80013796:	f9843703          	ld	a4,-104(s0)
    8001379a:	f8843683          	ld	a3,-120(s0)
    8001379e:	863e                	mv	a2,a5
    800137a0:	f9043583          	ld	a1,-112(s0)
    800137a4:	02000513          	li	a0,32
    800137a8:	9702                	jalr	a4
                    while (l++ < width) {
    800137aa:	fd042783          	lw	a5,-48(s0)
    800137ae:	0017871b          	addiw	a4,a5,1
    800137b2:	fce42823          	sw	a4,-48(s0)
    800137b6:	fe842703          	lw	a4,-24(s0)
    800137ba:	2701                	sext.w	a4,a4
    800137bc:	fce7e7e3          	bltu	a5,a4,8001378a <_vsnprintf+0x8b0>
                    }
                }
                // char output
                out((char)va_arg(va, int), buffer, idx++, maxlen);
    800137c0:	f7843783          	ld	a5,-136(s0)
    800137c4:	00878713          	addi	a4,a5,8
    800137c8:	f6e43c23          	sd	a4,-136(s0)
    800137cc:	439c                	lw	a5,0(a5)
    800137ce:	0ff7f513          	andi	a0,a5,255
    800137d2:	fd843783          	ld	a5,-40(s0)
    800137d6:	00178713          	addi	a4,a5,1
    800137da:	fce43c23          	sd	a4,-40(s0)
    800137de:	f9843703          	ld	a4,-104(s0)
    800137e2:	f8843683          	ld	a3,-120(s0)
    800137e6:	863e                	mv	a2,a5
    800137e8:	f9043583          	ld	a1,-112(s0)
    800137ec:	9702                	jalr	a4
                // post padding
                if (flags & FLAGS_LEFT) {
    800137ee:	fec42783          	lw	a5,-20(s0)
    800137f2:	8b89                	andi	a5,a5,2
    800137f4:	2781                	sext.w	a5,a5
    800137f6:	cf8d                	beqz	a5,80013830 <_vsnprintf+0x956>
                    while (l++ < width) {
    800137f8:	a00d                	j	8001381a <_vsnprintf+0x940>
                        out(' ', buffer, idx++, maxlen);
    800137fa:	fd843783          	ld	a5,-40(s0)
    800137fe:	00178713          	addi	a4,a5,1
    80013802:	fce43c23          	sd	a4,-40(s0)
    80013806:	f9843703          	ld	a4,-104(s0)
    8001380a:	f8843683          	ld	a3,-120(s0)
    8001380e:	863e                	mv	a2,a5
    80013810:	f9043583          	ld	a1,-112(s0)
    80013814:	02000513          	li	a0,32
    80013818:	9702                	jalr	a4
                    while (l++ < width) {
    8001381a:	fd042783          	lw	a5,-48(s0)
    8001381e:	0017871b          	addiw	a4,a5,1
    80013822:	fce42823          	sw	a4,-48(s0)
    80013826:	fe842703          	lw	a4,-24(s0)
    8001382a:	2701                	sext.w	a4,a4
    8001382c:	fce7e7e3          	bltu	a5,a4,800137fa <_vsnprintf+0x920>
                    }
                }
                format++;
    80013830:	f8043783          	ld	a5,-128(s0)
    80013834:	0785                	addi	a5,a5,1
    80013836:	f8f43023          	sd	a5,-128(s0)
                break;
    8001383a:	a4a1                	j	80013a82 <_vsnprintf+0xba8>
            }

            case 's': {
                const char *p = va_arg(va, char *);
    8001383c:	f7843783          	ld	a5,-136(s0)
    80013840:	00878713          	addi	a4,a5,8
    80013844:	f6e43c23          	sd	a4,-136(s0)
    80013848:	639c                	ld	a5,0(a5)
    8001384a:	fcf43423          	sd	a5,-56(s0)
                unsigned int l =
                    _strnlen_s(p, precision ? precision : (size_t)-1);
    8001384e:	fe442783          	lw	a5,-28(s0)
    80013852:	2781                	sext.w	a5,a5
    80013854:	c781                	beqz	a5,8001385c <_vsnprintf+0x982>
    80013856:	fe446783          	lwu	a5,-28(s0)
    8001385a:	a011                	j	8001385e <_vsnprintf+0x984>
    8001385c:	57fd                	li	a5,-1
    8001385e:	85be                	mv	a1,a5
    80013860:	fc843503          	ld	a0,-56(s0)
    80013864:	d92fe0ef          	jal	ra,80011df6 <_strnlen_s>
    80013868:	87aa                	mv	a5,a0
    8001386a:	fcf42223          	sw	a5,-60(s0)
                // pre padding
                if (flags & FLAGS_PRECISION) {
    8001386e:	fec42783          	lw	a5,-20(s0)
    80013872:	4007f793          	andi	a5,a5,1024
    80013876:	2781                	sext.w	a5,a5
    80013878:	cf91                	beqz	a5,80013894 <_vsnprintf+0x9ba>
                    l = (l < precision ? l : precision);
    8001387a:	fc442603          	lw	a2,-60(s0)
    8001387e:	fe442783          	lw	a5,-28(s0)
    80013882:	0007869b          	sext.w	a3,a5
    80013886:	0006071b          	sext.w	a4,a2
    8001388a:	00d77363          	bgeu	a4,a3,80013890 <_vsnprintf+0x9b6>
    8001388e:	87b2                	mv	a5,a2
    80013890:	fcf42223          	sw	a5,-60(s0)
                }
                if (!(flags & FLAGS_LEFT)) {
    80013894:	fec42783          	lw	a5,-20(s0)
    80013898:	8b89                	andi	a5,a5,2
    8001389a:	2781                	sext.w	a5,a5
    8001389c:	e7a5                	bnez	a5,80013904 <_vsnprintf+0xa2a>
                    while (l++ < width) {
    8001389e:	a00d                	j	800138c0 <_vsnprintf+0x9e6>
                        out(' ', buffer, idx++, maxlen);
    800138a0:	fd843783          	ld	a5,-40(s0)
    800138a4:	00178713          	addi	a4,a5,1
    800138a8:	fce43c23          	sd	a4,-40(s0)
    800138ac:	f9843703          	ld	a4,-104(s0)
    800138b0:	f8843683          	ld	a3,-120(s0)
    800138b4:	863e                	mv	a2,a5
    800138b6:	f9043583          	ld	a1,-112(s0)
    800138ba:	02000513          	li	a0,32
    800138be:	9702                	jalr	a4
                    while (l++ < width) {
    800138c0:	fc442783          	lw	a5,-60(s0)
    800138c4:	0017871b          	addiw	a4,a5,1
    800138c8:	fce42223          	sw	a4,-60(s0)
    800138cc:	fe842703          	lw	a4,-24(s0)
    800138d0:	2701                	sext.w	a4,a4
    800138d2:	fce7e7e3          	bltu	a5,a4,800138a0 <_vsnprintf+0x9c6>
                    }
                }
                // string output
                while ((*p != 0) &&
    800138d6:	a03d                	j	80013904 <_vsnprintf+0xa2a>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
                    out(*(p++), buffer, idx++, maxlen);
    800138d8:	fc843783          	ld	a5,-56(s0)
    800138dc:	00178713          	addi	a4,a5,1
    800138e0:	fce43423          	sd	a4,-56(s0)
    800138e4:	0007c503          	lbu	a0,0(a5)
    800138e8:	fd843783          	ld	a5,-40(s0)
    800138ec:	00178713          	addi	a4,a5,1
    800138f0:	fce43c23          	sd	a4,-40(s0)
    800138f4:	f9843703          	ld	a4,-104(s0)
    800138f8:	f8843683          	ld	a3,-120(s0)
    800138fc:	863e                	mv	a2,a5
    800138fe:	f9043583          	ld	a1,-112(s0)
    80013902:	9702                	jalr	a4
                while ((*p != 0) &&
    80013904:	fc843783          	ld	a5,-56(s0)
    80013908:	0007c783          	lbu	a5,0(a5)
    8001390c:	cf91                	beqz	a5,80013928 <_vsnprintf+0xa4e>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    8001390e:	fec42783          	lw	a5,-20(s0)
    80013912:	4007f793          	andi	a5,a5,1024
    80013916:	2781                	sext.w	a5,a5
                while ((*p != 0) &&
    80013918:	d3e1                	beqz	a5,800138d8 <_vsnprintf+0x9fe>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    8001391a:	fe442783          	lw	a5,-28(s0)
    8001391e:	fff7871b          	addiw	a4,a5,-1
    80013922:	fee42223          	sw	a4,-28(s0)
    80013926:	fbcd                	bnez	a5,800138d8 <_vsnprintf+0x9fe>
                }
                // post padding
                if (flags & FLAGS_LEFT) {
    80013928:	fec42783          	lw	a5,-20(s0)
    8001392c:	8b89                	andi	a5,a5,2
    8001392e:	2781                	sext.w	a5,a5
    80013930:	cf8d                	beqz	a5,8001396a <_vsnprintf+0xa90>
                    while (l++ < width) {
    80013932:	a00d                	j	80013954 <_vsnprintf+0xa7a>
                        out(' ', buffer, idx++, maxlen);
    80013934:	fd843783          	ld	a5,-40(s0)
    80013938:	00178713          	addi	a4,a5,1
    8001393c:	fce43c23          	sd	a4,-40(s0)
    80013940:	f9843703          	ld	a4,-104(s0)
    80013944:	f8843683          	ld	a3,-120(s0)
    80013948:	863e                	mv	a2,a5
    8001394a:	f9043583          	ld	a1,-112(s0)
    8001394e:	02000513          	li	a0,32
    80013952:	9702                	jalr	a4
                    while (l++ < width) {
    80013954:	fc442783          	lw	a5,-60(s0)
    80013958:	0017871b          	addiw	a4,a5,1
    8001395c:	fce42223          	sw	a4,-60(s0)
    80013960:	fe842703          	lw	a4,-24(s0)
    80013964:	2701                	sext.w	a4,a4
    80013966:	fce7e7e3          	bltu	a5,a4,80013934 <_vsnprintf+0xa5a>
                    }
                }
                format++;
    8001396a:	f8043783          	ld	a5,-128(s0)
    8001396e:	0785                	addi	a5,a5,1
    80013970:	f8f43023          	sd	a5,-128(s0)
                break;
    80013974:	a239                	j	80013a82 <_vsnprintf+0xba8>
            }

            case 'p': {
                width = sizeof(void *) * 2U;
    80013976:	47c1                	li	a5,16
    80013978:	fef42423          	sw	a5,-24(s0)
                flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    8001397c:	fec42783          	lw	a5,-20(s0)
    80013980:	0217e793          	ori	a5,a5,33
    80013984:	fef42623          	sw	a5,-20(s0)
#if defined(PRINTF_SUPPORT_LONG_LONG)
                const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
    80013988:	4785                	li	a5,1
    8001398a:	faf40da3          	sb	a5,-69(s0)
                if (is_ll) {
    8001398e:	fbb44783          	lbu	a5,-69(s0)
    80013992:	0ff7f793          	andi	a5,a5,255
    80013996:	c3b1                	beqz	a5,800139da <_vsnprintf+0xb00>
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
                                          (uintptr_t)va_arg(va, void *), false,
    80013998:	f7843783          	ld	a5,-136(s0)
    8001399c:	00878713          	addi	a4,a5,8
    800139a0:	f6e43c23          	sd	a4,-136(s0)
    800139a4:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
    800139a6:	86be                	mv	a3,a5
    800139a8:	fe442703          	lw	a4,-28(s0)
    800139ac:	fec42783          	lw	a5,-20(s0)
    800139b0:	e43e                	sd	a5,8(sp)
    800139b2:	fe842783          	lw	a5,-24(s0)
    800139b6:	e03e                	sd	a5,0(sp)
    800139b8:	88ba                	mv	a7,a4
    800139ba:	4841                	li	a6,16
    800139bc:	4781                	li	a5,0
    800139be:	8736                	mv	a4,a3
    800139c0:	f8843683          	ld	a3,-120(s0)
    800139c4:	fd843603          	ld	a2,-40(s0)
    800139c8:	f9043583          	ld	a1,-112(s0)
    800139cc:	f9843503          	ld	a0,-104(s0)
    800139d0:	9e5fe0ef          	jal	ra,800123b4 <_ntoa_long_long>
    800139d4:	fca43c23          	sd	a0,-40(s0)
    800139d8:	a089                	j	80013a1a <_vsnprintf+0xb40>
                }
                else {
#endif
                    idx = _ntoa_long(
                        out, buffer, idx, maxlen,
                        (unsigned long)((uintptr_t)va_arg(va, void *)), false,
    800139da:	f7843783          	ld	a5,-136(s0)
    800139de:	00878713          	addi	a4,a5,8
    800139e2:	f6e43c23          	sd	a4,-136(s0)
    800139e6:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long(
    800139e8:	86be                	mv	a3,a5
    800139ea:	fe442703          	lw	a4,-28(s0)
    800139ee:	fec42783          	lw	a5,-20(s0)
    800139f2:	e43e                	sd	a5,8(sp)
    800139f4:	fe842783          	lw	a5,-24(s0)
    800139f8:	e03e                	sd	a5,0(sp)
    800139fa:	88ba                	mv	a7,a4
    800139fc:	4841                	li	a6,16
    800139fe:	4781                	li	a5,0
    80013a00:	8736                	mv	a4,a3
    80013a02:	f8843683          	ld	a3,-120(s0)
    80013a06:	fd843603          	ld	a2,-40(s0)
    80013a0a:	f9043583          	ld	a1,-112(s0)
    80013a0e:	f9843503          	ld	a0,-104(s0)
    80013a12:	88bfe0ef          	jal	ra,8001229c <_ntoa_long>
    80013a16:	fca43c23          	sd	a0,-40(s0)
                        16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
                }
#endif
                format++;
    80013a1a:	f8043783          	ld	a5,-128(s0)
    80013a1e:	0785                	addi	a5,a5,1
    80013a20:	f8f43023          	sd	a5,-128(s0)
                break;
    80013a24:	a8b9                	j	80013a82 <_vsnprintf+0xba8>
            }

            case '%':
                out('%', buffer, idx++, maxlen);
    80013a26:	fd843783          	ld	a5,-40(s0)
    80013a2a:	00178713          	addi	a4,a5,1
    80013a2e:	fce43c23          	sd	a4,-40(s0)
    80013a32:	f9843703          	ld	a4,-104(s0)
    80013a36:	f8843683          	ld	a3,-120(s0)
    80013a3a:	863e                	mv	a2,a5
    80013a3c:	f9043583          	ld	a1,-112(s0)
    80013a40:	02500513          	li	a0,37
    80013a44:	9702                	jalr	a4
                format++;
    80013a46:	f8043783          	ld	a5,-128(s0)
    80013a4a:	0785                	addi	a5,a5,1
    80013a4c:	f8f43023          	sd	a5,-128(s0)
                break;
    80013a50:	a80d                	j	80013a82 <_vsnprintf+0xba8>

            default:
                out(*format, buffer, idx++, maxlen);
    80013a52:	f8043783          	ld	a5,-128(s0)
    80013a56:	0007c503          	lbu	a0,0(a5)
    80013a5a:	fd843783          	ld	a5,-40(s0)
    80013a5e:	00178713          	addi	a4,a5,1
    80013a62:	fce43c23          	sd	a4,-40(s0)
    80013a66:	f9843703          	ld	a4,-104(s0)
    80013a6a:	f8843683          	ld	a3,-120(s0)
    80013a6e:	863e                	mv	a2,a5
    80013a70:	f9043583          	ld	a1,-112(s0)
    80013a74:	9702                	jalr	a4
                format++;
    80013a76:	f8043783          	ld	a5,-128(s0)
    80013a7a:	0785                	addi	a5,a5,1
    80013a7c:	f8f43023          	sd	a5,-128(s0)
                break;
    80013a80:	0001                	nop
    while (*format) {
    80013a82:	f8043783          	ld	a5,-128(s0)
    80013a86:	0007c783          	lbu	a5,0(a5)
    80013a8a:	c8079463          	bnez	a5,80012f12 <_vsnprintf+0x38>
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    80013a8e:	fd843703          	ld	a4,-40(s0)
    80013a92:	f8843783          	ld	a5,-120(s0)
    80013a96:	00f76663          	bltu	a4,a5,80013aa2 <_vsnprintf+0xbc8>
    80013a9a:	f8843783          	ld	a5,-120(s0)
    80013a9e:	17fd                	addi	a5,a5,-1
    80013aa0:	a019                	j	80013aa6 <_vsnprintf+0xbcc>
    80013aa2:	fd843783          	ld	a5,-40(s0)
    80013aa6:	f9843703          	ld	a4,-104(s0)
    80013aaa:	f8843683          	ld	a3,-120(s0)
    80013aae:	863e                	mv	a2,a5
    80013ab0:	f9043583          	ld	a1,-112(s0)
    80013ab4:	4501                	li	a0,0
    80013ab6:	9702                	jalr	a4

    // return written chars without terminating \0
    return (int)idx;
    80013ab8:	fd843783          	ld	a5,-40(s0)
    80013abc:	2781                	sext.w	a5,a5
}
    80013abe:	853e                	mv	a0,a5
    80013ac0:	60ea                	ld	ra,152(sp)
    80013ac2:	644a                	ld	s0,144(sp)
    80013ac4:	610d                	addi	sp,sp,160
    80013ac6:	8082                	ret

0000000080013ac8 <printf>:

///////////////////////////////////////////////////////////////////////////////

int printf(const char *format, ...)
{
    80013ac8:	7119                	addi	sp,sp,-128
    80013aca:	fc06                	sd	ra,56(sp)
    80013acc:	f822                	sd	s0,48(sp)
    80013ace:	0080                	addi	s0,sp,64
    80013ad0:	fca43423          	sd	a0,-56(s0)
    80013ad4:	e40c                	sd	a1,8(s0)
    80013ad6:	e810                	sd	a2,16(s0)
    80013ad8:	ec14                	sd	a3,24(s0)
    80013ada:	f018                	sd	a4,32(s0)
    80013adc:	f41c                	sd	a5,40(s0)
    80013ade:	03043823          	sd	a6,48(s0)
    80013ae2:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, format);
    80013ae6:	04040793          	addi	a5,s0,64
    80013aea:	fcf43023          	sd	a5,-64(s0)
    80013aee:	fc043783          	ld	a5,-64(s0)
    80013af2:	fc878793          	addi	a5,a5,-56
    80013af6:	fef43023          	sd	a5,-32(s0)
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80013afa:	fe043703          	ld	a4,-32(s0)
    80013afe:	fd840793          	addi	a5,s0,-40
    80013b02:	fc843683          	ld	a3,-56(s0)
    80013b06:	567d                	li	a2,-1
    80013b08:	85be                	mv	a1,a5
    80013b0a:	ffffe517          	auipc	a0,0xffffe
    80013b0e:	27050513          	addi	a0,a0,624 # 80011d7a <_out_char>
    80013b12:	bc8ff0ef          	jal	ra,80012eda <_vsnprintf>
    80013b16:	87aa                	mv	a5,a0
    80013b18:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80013b1c:	fec42783          	lw	a5,-20(s0)
}
    80013b20:	853e                	mv	a0,a5
    80013b22:	70e2                	ld	ra,56(sp)
    80013b24:	7442                	ld	s0,48(sp)
    80013b26:	6109                	addi	sp,sp,128
    80013b28:	8082                	ret

0000000080013b2a <sprintf>:

int sprintf(char *buffer, const char *format, ...)
{
    80013b2a:	7159                	addi	sp,sp,-112
    80013b2c:	fc06                	sd	ra,56(sp)
    80013b2e:	f822                	sd	s0,48(sp)
    80013b30:	0080                	addi	s0,sp,64
    80013b32:	fca43c23          	sd	a0,-40(s0)
    80013b36:	fcb43823          	sd	a1,-48(s0)
    80013b3a:	e010                	sd	a2,0(s0)
    80013b3c:	e414                	sd	a3,8(s0)
    80013b3e:	e818                	sd	a4,16(s0)
    80013b40:	ec1c                	sd	a5,24(s0)
    80013b42:	03043023          	sd	a6,32(s0)
    80013b46:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80013b4a:	03040793          	addi	a5,s0,48
    80013b4e:	fcf43423          	sd	a5,-56(s0)
    80013b52:	fc843783          	ld	a5,-56(s0)
    80013b56:	fd078793          	addi	a5,a5,-48
    80013b5a:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
    80013b5e:	fe043783          	ld	a5,-32(s0)
    80013b62:	873e                	mv	a4,a5
    80013b64:	fd043683          	ld	a3,-48(s0)
    80013b68:	567d                	li	a2,-1
    80013b6a:	fd843583          	ld	a1,-40(s0)
    80013b6e:	ffffe517          	auipc	a0,0xffffe
    80013b72:	1ae50513          	addi	a0,a0,430 # 80011d1c <_out_buffer>
    80013b76:	b64ff0ef          	jal	ra,80012eda <_vsnprintf>
    80013b7a:	87aa                	mv	a5,a0
    80013b7c:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80013b80:	fec42783          	lw	a5,-20(s0)
}
    80013b84:	853e                	mv	a0,a5
    80013b86:	70e2                	ld	ra,56(sp)
    80013b88:	7442                	ld	s0,48(sp)
    80013b8a:	6165                	addi	sp,sp,112
    80013b8c:	8082                	ret

0000000080013b8e <snprintf>:

int snprintf(char *buffer, size_t count, const char *format, ...)
{
    80013b8e:	7159                	addi	sp,sp,-112
    80013b90:	fc06                	sd	ra,56(sp)
    80013b92:	f822                	sd	s0,48(sp)
    80013b94:	0080                	addi	s0,sp,64
    80013b96:	fca43c23          	sd	a0,-40(s0)
    80013b9a:	fcb43823          	sd	a1,-48(s0)
    80013b9e:	fcc43423          	sd	a2,-56(s0)
    80013ba2:	e414                	sd	a3,8(s0)
    80013ba4:	e818                	sd	a4,16(s0)
    80013ba6:	ec1c                	sd	a5,24(s0)
    80013ba8:	03043023          	sd	a6,32(s0)
    80013bac:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80013bb0:	03040793          	addi	a5,s0,48
    80013bb4:	fcf43023          	sd	a5,-64(s0)
    80013bb8:	fc043783          	ld	a5,-64(s0)
    80013bbc:	fd878793          	addi	a5,a5,-40
    80013bc0:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    80013bc4:	fe043783          	ld	a5,-32(s0)
    80013bc8:	873e                	mv	a4,a5
    80013bca:	fc843683          	ld	a3,-56(s0)
    80013bce:	fd043603          	ld	a2,-48(s0)
    80013bd2:	fd843583          	ld	a1,-40(s0)
    80013bd6:	ffffe517          	auipc	a0,0xffffe
    80013bda:	14650513          	addi	a0,a0,326 # 80011d1c <_out_buffer>
    80013bde:	afcff0ef          	jal	ra,80012eda <_vsnprintf>
    80013be2:	87aa                	mv	a5,a0
    80013be4:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80013be8:	fec42783          	lw	a5,-20(s0)
}
    80013bec:	853e                	mv	a0,a5
    80013bee:	70e2                	ld	ra,56(sp)
    80013bf0:	7442                	ld	s0,48(sp)
    80013bf2:	6165                	addi	sp,sp,112
    80013bf4:	8082                	ret

0000000080013bf6 <vprintf_>:

int vprintf_(const char *format, va_list va)
{
    80013bf6:	7179                	addi	sp,sp,-48
    80013bf8:	f406                	sd	ra,40(sp)
    80013bfa:	f022                	sd	s0,32(sp)
    80013bfc:	1800                	addi	s0,sp,48
    80013bfe:	fca43c23          	sd	a0,-40(s0)
    80013c02:	fcb43823          	sd	a1,-48(s0)
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    80013c06:	fe840793          	addi	a5,s0,-24
    80013c0a:	fd043703          	ld	a4,-48(s0)
    80013c0e:	fd843683          	ld	a3,-40(s0)
    80013c12:	567d                	li	a2,-1
    80013c14:	85be                	mv	a1,a5
    80013c16:	ffffe517          	auipc	a0,0xffffe
    80013c1a:	16450513          	addi	a0,a0,356 # 80011d7a <_out_char>
    80013c1e:	abcff0ef          	jal	ra,80012eda <_vsnprintf>
    80013c22:	87aa                	mv	a5,a0
}
    80013c24:	853e                	mv	a0,a5
    80013c26:	70a2                	ld	ra,40(sp)
    80013c28:	7402                	ld	s0,32(sp)
    80013c2a:	6145                	addi	sp,sp,48
    80013c2c:	8082                	ret

0000000080013c2e <vsnprintf_>:

int vsnprintf_(char *buffer, size_t count, const char *format, va_list va)
{
    80013c2e:	7179                	addi	sp,sp,-48
    80013c30:	f406                	sd	ra,40(sp)
    80013c32:	f022                	sd	s0,32(sp)
    80013c34:	1800                	addi	s0,sp,48
    80013c36:	fea43423          	sd	a0,-24(s0)
    80013c3a:	feb43023          	sd	a1,-32(s0)
    80013c3e:	fcc43c23          	sd	a2,-40(s0)
    80013c42:	fcd43823          	sd	a3,-48(s0)
    return _vsnprintf(_out_buffer, buffer, count, format, va);
    80013c46:	fd043703          	ld	a4,-48(s0)
    80013c4a:	fd843683          	ld	a3,-40(s0)
    80013c4e:	fe043603          	ld	a2,-32(s0)
    80013c52:	fe843583          	ld	a1,-24(s0)
    80013c56:	ffffe517          	auipc	a0,0xffffe
    80013c5a:	0c650513          	addi	a0,a0,198 # 80011d1c <_out_buffer>
    80013c5e:	a7cff0ef          	jal	ra,80012eda <_vsnprintf>
    80013c62:	87aa                	mv	a5,a0
}
    80013c64:	853e                	mv	a0,a5
    80013c66:	70a2                	ld	ra,40(sp)
    80013c68:	7402                	ld	s0,32(sp)
    80013c6a:	6145                	addi	sp,sp,48
    80013c6c:	8082                	ret

0000000080013c6e <fctprintf>:

int fctprintf(void (*out)(char character, void *arg), void *arg,
              const char *format, ...)
{
    80013c6e:	7119                	addi	sp,sp,-128
    80013c70:	e486                	sd	ra,72(sp)
    80013c72:	e0a2                	sd	s0,64(sp)
    80013c74:	0880                	addi	s0,sp,80
    80013c76:	fca43423          	sd	a0,-56(s0)
    80013c7a:	fcb43023          	sd	a1,-64(s0)
    80013c7e:	fac43c23          	sd	a2,-72(s0)
    80013c82:	e414                	sd	a3,8(s0)
    80013c84:	e818                	sd	a4,16(s0)
    80013c86:	ec1c                	sd	a5,24(s0)
    80013c88:	03043023          	sd	a6,32(s0)
    80013c8c:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80013c90:	03040793          	addi	a5,s0,48
    80013c94:	faf43823          	sd	a5,-80(s0)
    80013c98:	fb043783          	ld	a5,-80(s0)
    80013c9c:	fd878793          	addi	a5,a5,-40
    80013ca0:	fef43023          	sd	a5,-32(s0)
    const out_fct_wrap_type out_fct_wrap = {out, arg};
    80013ca4:	fc843783          	ld	a5,-56(s0)
    80013ca8:	fcf43823          	sd	a5,-48(s0)
    80013cac:	fc043783          	ld	a5,-64(s0)
    80013cb0:	fcf43c23          	sd	a5,-40(s0)
    const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap,
    80013cb4:	fe043703          	ld	a4,-32(s0)
    80013cb8:	fd040793          	addi	a5,s0,-48
    80013cbc:	fb843683          	ld	a3,-72(s0)
    80013cc0:	567d                	li	a2,-1
    80013cc2:	85be                	mv	a1,a5
    80013cc4:	ffffe517          	auipc	a0,0xffffe
    80013cc8:	0ee50513          	addi	a0,a0,238 # 80011db2 <_out_fct>
    80013ccc:	a0eff0ef          	jal	ra,80012eda <_vsnprintf>
    80013cd0:	87aa                	mv	a5,a0
    80013cd2:	fef42623          	sw	a5,-20(s0)
                               (size_t)-1, format, va);
    va_end(va);
    return ret;
    80013cd6:	fec42783          	lw	a5,-20(s0)
}
    80013cda:	853e                	mv	a0,a5
    80013cdc:	60a6                	ld	ra,72(sp)
    80013cde:	6406                	ld	s0,64(sp)
    80013ce0:	6109                	addi	sp,sp,128
    80013ce2:	8082                	ret

0000000080013ce4 <os_trap_handler>:
// From src/syscall.c
void syscall_handle(int hart, uint64_t epc, int64_t *scratch);

// Called from asm/spawn.S: _spawn_kthread
void os_trap_handler(void)
{
    80013ce4:	7139                	addi	sp,sp,-64
    80013ce6:	fc06                	sd	ra,56(sp)
    80013ce8:	f822                	sd	s0,48(sp)
    80013cea:	0080                	addi	s0,sp,64
    unsigned long cause;
    long *scratch;
    unsigned long epc;
    unsigned long tval;
    unsigned long sie;
    CSR_READ(cause, "scause");
    80013cec:	142027f3          	csrr	a5,scause
    80013cf0:	fef43423          	sd	a5,-24(s0)
    CSR_READ(scratch, "sscratch");
    80013cf4:	140027f3          	csrr	a5,sscratch
    80013cf8:	fef43023          	sd	a5,-32(s0)
    CSR_READ(epc, "sepc");
    80013cfc:	141027f3          	csrr	a5,sepc
    80013d00:	fcf43c23          	sd	a5,-40(s0)
    CSR_READ(tval, "stval");
    80013d04:	143027f3          	csrr	a5,stval
    80013d08:	fcf43823          	sd	a5,-48(s0)
    CSR_READ(sie, "sie");
    80013d0c:	104027f3          	csrr	a5,sie
    80013d10:	fcf43423          	sd	a5,-56(s0)
    // debugf("SPP: %lx\n", status & SSTATUS_SPP_BIT);

    // debugf("Scause: %lx\n", cause);
    // debugf("Sscratch: %lx\n", scratch);

    int hart = sbi_whoami();
    80013d14:	480080ef          	jal	ra,8001c194 <sbi_whoami>
    80013d18:	87aa                	mv	a5,a0
    80013d1a:	fcf42223          	sw	a5,-60(s0)
    //                 "csrs sie, t1\n");


    debugf("Is async: %d\n", SCAUSE_IS_ASYNC(cause));

    if (SCAUSE_IS_ASYNC(cause)) {
    80013d1e:	fe843783          	ld	a5,-24(s0)
    80013d22:	0607d563          	bgez	a5,80013d8c <os_trap_handler+0xa8>
        debugf("os_trap_handler: Is async!\n");
        cause = SCAUSE_NUM(cause);
    80013d26:	fe843783          	ld	a5,-24(s0)
    80013d2a:	0ff7f793          	andi	a5,a5,255
    80013d2e:	fef43423          	sd	a5,-24(s0)
        switch (cause) {
    80013d32:	fe843703          	ld	a4,-24(s0)
    80013d36:	47a5                	li	a5,9
    80013d38:	02f70963          	beq	a4,a5,80013d6a <os_trap_handler+0x86>
    80013d3c:	fe843703          	ld	a4,-24(s0)
    80013d40:	47a5                	li	a5,9
    80013d42:	02e7ea63          	bltu	a5,a4,80013d76 <os_trap_handler+0x92>
    80013d46:	fe843703          	ld	a4,-24(s0)
    80013d4a:	4785                	li	a5,1
    80013d4c:	12f70063          	beq	a4,a5,80013e6c <os_trap_handler+0x188>
    80013d50:	fe843703          	ld	a4,-24(s0)
    80013d54:	4795                	li	a5,5
    80013d56:	02f71063          	bne	a4,a5,80013d76 <os_trap_handler+0x92>
            case CAUSE_STIP:
                // Ack timer will reset the timer to INFINITE
                // In src/sbi.c
                debugf("os_trap_handler: Supervisor timer interrupt!\n");
                // CSR_CLEAR("sip");
                sbi_ack_timer();
    80013d5a:	404080ef          	jal	ra,8001c15e <sbi_ack_timer>
                // We typically invoke our scheduler if we get a timer
                sched_handle_timer_interrupt(hart);
    80013d5e:	fc442783          	lw	a5,-60(s0)
    80013d62:	853e                	mv	a0,a5
    80013d64:	188020ef          	jal	ra,80015eec <sched_handle_timer_interrupt>
                break;
    80013d68:	a219                	j	80013e6e <os_trap_handler+0x18a>
            case CAUSE_SEIP:
                debugf("os_trap_handler: Supervisor external interrupt!\n");
                // Forward to src/plic.c
                plic_handle_irq(hart);
    80013d6a:	fc442783          	lw	a5,-60(s0)
    80013d6e:	853e                	mv	a0,a5
    80013d70:	6d8080ef          	jal	ra,8001c448 <plic_handle_irq>
                break;
    80013d74:	a8ed                	j	80013e6e <os_trap_handler+0x18a>
            default:
                fatalf("os_trap_handler: Unhandled Asynchronous interrupt %ld\n", cause);
    80013d76:	fe843583          	ld	a1,-24(s0)
    80013d7a:	00013517          	auipc	a0,0x13
    80013d7e:	1ce50513          	addi	a0,a0,462 # 80026f48 <pow10.0+0xe8>
    80013d82:	1ba080ef          	jal	ra,8001bf3c <fatalf>
                WFI_LOOP();
    80013d86:	10500073          	wfi
    80013d8a:	bff5                	j	80013d86 <os_trap_handler+0xa2>
    80013d8c:	fe843703          	ld	a4,-24(s0)
    80013d90:	47b5                	li	a5,13
    80013d92:	0ae7eb63          	bltu	a5,a4,80013e48 <os_trap_handler+0x164>
    80013d96:	fe843783          	ld	a5,-24(s0)
    80013d9a:	00279713          	slli	a4,a5,0x2
    80013d9e:	00013797          	auipc	a5,0x13
    80013da2:	2e678793          	addi	a5,a5,742 # 80027084 <pow10.0+0x224>
    80013da6:	97ba                	add	a5,a5,a4
    80013da8:	439c                	lw	a5,0(a5)
    80013daa:	0007871b          	sext.w	a4,a5
    80013dae:	00013797          	auipc	a5,0x13
    80013db2:	2d678793          	addi	a5,a5,726 # 80027084 <pow10.0+0x224>
    80013db6:	97ba                	add	a5,a5,a4
    80013db8:	8782                	jr	a5
        }
    } else {
        debugf("Is sync!\n");
        switch (cause) {
            case CAUSE_ILLEGAL_INSTRUCTION:
                fatalf("Illegal instruction \"%x\" at %p\n", *((uint64_t*)epc), epc);
    80013dba:	fd843783          	ld	a5,-40(s0)
    80013dbe:	639c                	ld	a5,0(a5)
    80013dc0:	fd843603          	ld	a2,-40(s0)
    80013dc4:	85be                	mv	a1,a5
    80013dc6:	00013517          	auipc	a0,0x13
    80013dca:	1ba50513          	addi	a0,a0,442 # 80026f80 <pow10.0+0x120>
    80013dce:	16e080ef          	jal	ra,8001bf3c <fatalf>
                CSR_WRITE("sepc", epc + 4);
    80013dd2:	fd843783          	ld	a5,-40(s0)
    80013dd6:	0791                	addi	a5,a5,4
    80013dd8:	14179073          	csrw	sepc,a5
                break;
    80013ddc:	a849                	j	80013e6e <os_trap_handler+0x18a>
            case CAUSE_INSTRUCTION_ACCESS_FAULT:
                fatalf("Couldn't access instruction=%p at instruction %p\n", tval, epc);
    80013dde:	fd843603          	ld	a2,-40(s0)
    80013de2:	fd043583          	ld	a1,-48(s0)
    80013de6:	00013517          	auipc	a0,0x13
    80013dea:	1ba50513          	addi	a0,a0,442 # 80026fa0 <pow10.0+0x140>
    80013dee:	14e080ef          	jal	ra,8001bf3c <fatalf>
                break;
    80013df2:	a8b5                	j	80013e6e <os_trap_handler+0x18a>
            case CAUSE_INSTRUCTION_PAGE_FAULT:
                fatalf("Instruction page fault at instruction %p accessing address %p\n", epc, tval);
    80013df4:	fd043603          	ld	a2,-48(s0)
    80013df8:	fd843583          	ld	a1,-40(s0)
    80013dfc:	00013517          	auipc	a0,0x13
    80013e00:	1dc50513          	addi	a0,a0,476 # 80026fd8 <pow10.0+0x178>
    80013e04:	138080ef          	jal	ra,8001bf3c <fatalf>
                break;
    80013e08:	a09d                	j	80013e6e <os_trap_handler+0x18a>
            case CAUSE_LOAD_PAGE_FAULT:
                fatalf("Load page fault at %p = %p", epc, tval);
    80013e0a:	fd043603          	ld	a2,-48(s0)
    80013e0e:	fd843583          	ld	a1,-40(s0)
    80013e12:	00013517          	auipc	a0,0x13
    80013e16:	20650513          	addi	a0,a0,518 # 80027018 <pow10.0+0x1b8>
    80013e1a:	122080ef          	jal	ra,8001bf3c <fatalf>
                break;
    80013e1e:	a881                	j	80013e6e <os_trap_handler+0x18a>
            case CAUSE_ECALL_U_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                debugf("Handling syscall\n");
                syscall_handle(hart, epc, scratch);
    80013e20:	fc442783          	lw	a5,-60(s0)
    80013e24:	fe043603          	ld	a2,-32(s0)
    80013e28:	fd843583          	ld	a1,-40(s0)
    80013e2c:	853e                	mv	a0,a5
    80013e2e:	dfcfc0ef          	jal	ra,8001042a <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    80013e32:	a835                	j	80013e6e <os_trap_handler+0x18a>
            case CAUSE_ECALL_S_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                debugf("Handling syscall\n");
                syscall_handle(hart, epc, scratch);
    80013e34:	fc442783          	lw	a5,-60(s0)
    80013e38:	fe043603          	ld	a2,-32(s0)
    80013e3c:	fd843583          	ld	a1,-40(s0)
    80013e40:	853e                	mv	a0,a5
    80013e42:	de8fc0ef          	jal	ra,8001042a <syscall_handle>
                // We have to move beyond the ECALL instruction, which is exactly 4 bytes.
                break;
    80013e46:	a025                	j	80013e6e <os_trap_handler+0x18a>
            default:
                fatalf(
    80013e48:	fc442783          	lw	a5,-60(s0)
    80013e4c:	873e                	mv	a4,a5
    80013e4e:	fd043683          	ld	a3,-48(s0)
    80013e52:	fd843603          	ld	a2,-40(s0)
    80013e56:	fe843583          	ld	a1,-24(s0)
    80013e5a:	00013517          	auipc	a0,0x13
    80013e5e:	1de50513          	addi	a0,a0,478 # 80027038 <pow10.0+0x1d8>
    80013e62:	0da080ef          	jal	ra,8001bf3c <fatalf>
                    "Unhandled Synchronous interrupt %ld @ 0x%08lx [0x%08lx]. "
                    "Hanging hart %d\n",
                    cause, epc, tval, hart);
                WFI_LOOP();
    80013e66:	10500073          	wfi
    80013e6a:	bff5                	j	80013e66 <os_trap_handler+0x182>
                break;
    80013e6c:	0001                	nop
    // __asm__ volatile ("savegp");

    // SRET();
    debugf("Leaving OS trap handler\n");
    // fatalf("Could not return from trap\n");
    80013e6e:	0001                	nop
    80013e70:	70e2                	ld	ra,56(sp)
    80013e72:	7442                	ld	s0,48(sp)
    80013e74:	6121                	addi	sp,sp,64
    80013e76:	8082                	ret

0000000080013e78 <rng_device_init>:

//use this like a queue
static Vector *rng_active_jobs;
static VirtioDevice *rng_device;

void rng_device_init() {
    80013e78:	1141                	addi	sp,sp,-16
    80013e7a:	e406                	sd	ra,8(sp)
    80013e7c:	e022                	sd	s0,0(sp)
    80013e7e:	0800                	addi	s0,sp,16
    rng_active_jobs = vector_new();
    80013e80:	60f0e0ef          	jal	ra,80022c8e <vector_new>
    80013e84:	872a                	mv	a4,a0
    80013e86:	00011797          	auipc	a5,0x11
    80013e8a:	1aa78793          	addi	a5,a5,426 # 80025030 <rng_active_jobs>
    80013e8e:	e398                	sd	a4,0(a5)
    rng_device = virtio_get_rng_device();
    80013e90:	64f080ef          	jal	ra,8001ccde <virtio_get_rng_device>
    80013e94:	872a                	mv	a4,a0
    80013e96:	00011797          	auipc	a5,0x11
    80013e9a:	1a278793          	addi	a5,a5,418 # 80025038 <rng_device>
    80013e9e:	e398                	sd	a4,0(a5)
    debugf("RNG init done for device at %p\n", rng_device->pcidev->ecam_header);
    80013ea0:	00011797          	auipc	a5,0x11
    80013ea4:	19878793          	addi	a5,a5,408 # 80025038 <rng_device>
    80013ea8:	639c                	ld	a5,0(a5)
    80013eaa:	63bc                	ld	a5,64(a5)
    80013eac:	639c                	ld	a5,0(a5)
    80013eae:	85be                	mv	a1,a5
    80013eb0:	00013517          	auipc	a0,0x13
    80013eb4:	21050513          	addi	a0,a0,528 # 800270c0 <pow10.0+0x260>
    80013eb8:	72b070ef          	jal	ra,8001bde2 <debugf>
    virtio_set_device_name(rng_device, "RNG Device");
    80013ebc:	00011797          	auipc	a5,0x11
    80013ec0:	17c78793          	addi	a5,a5,380 # 80025038 <rng_device>
    80013ec4:	639c                	ld	a5,0(a5)
    80013ec6:	00013597          	auipc	a1,0x13
    80013eca:	21a58593          	addi	a1,a1,538 # 800270e0 <pow10.0+0x280>
    80013ece:	853e                	mv	a0,a5
    80013ed0:	3fc090ef          	jal	ra,8001d2cc <virtio_set_device_name>
    rng_device->ready = true;
    80013ed4:	00011797          	auipc	a5,0x11
    80013ed8:	16478793          	addi	a5,a5,356 # 80025038 <rng_device>
    80013edc:	639c                	ld	a5,0(a5)
    80013ede:	4705                	li	a4,1
    80013ee0:	08e78723          	sb	a4,142(a5)
}
    80013ee4:	0001                	nop
    80013ee6:	60a2                	ld	ra,8(sp)
    80013ee8:	6402                	ld	s0,0(sp)
    80013eea:	0141                	addi	sp,sp,16
    80013eec:	8082                	ret

0000000080013eee <rng_fill>:


void rng_fill(void *virtual_buffer_address, uint16_t size) {
    80013eee:	7179                	addi	sp,sp,-48
    80013ef0:	f406                	sd	ra,40(sp)
    80013ef2:	f022                	sd	s0,32(sp)
    80013ef4:	1800                	addi	s0,sp,48
    80013ef6:	fca43c23          	sd	a0,-40(s0)
    80013efa:	87ae                	mv	a5,a1
    80013efc:	fcf41b23          	sh	a5,-42(s0)
    if (!virtio_is_rng_device(rng_device)) {
    80013f00:	00011797          	auipc	a5,0x11
    80013f04:	13878793          	addi	a5,a5,312 # 80025038 <rng_device>
    80013f08:	639c                	ld	a5,0(a5)
    80013f0a:	853e                	mv	a0,a5
    80013f0c:	425080ef          	jal	ra,8001cb30 <virtio_is_rng_device>
    80013f10:	87aa                	mv	a5,a0
    80013f12:	0017c793          	xori	a5,a5,1
    80013f16:	0ff7f793          	andi	a5,a5,255
    80013f1a:	c799                	beqz	a5,80013f28 <rng_fill+0x3a>
        fatalf("[RNG] Incorrect device provided\n");
    80013f1c:	00013517          	auipc	a0,0x13
    80013f20:	1d450513          	addi	a0,a0,468 # 800270f0 <pow10.0+0x290>
    80013f24:	018080ef          	jal	ra,8001bf3c <fatalf>
    }

    if (!rng_device->ready) {
    80013f28:	00011797          	auipc	a5,0x11
    80013f2c:	11078793          	addi	a5,a5,272 # 80025038 <rng_device>
    80013f30:	639c                	ld	a5,0(a5)
    80013f32:	08e7c783          	lbu	a5,142(a5)
    80013f36:	0017c793          	xori	a5,a5,1
    80013f3a:	0ff7f793          	andi	a5,a5,255
    80013f3e:	cb81                	beqz	a5,80013f4e <rng_fill+0x60>
        fatalf("RNG is not ready\n");
    80013f40:	00013517          	auipc	a0,0x13
    80013f44:	1d850513          	addi	a0,a0,472 # 80027118 <pow10.0+0x2b8>
    80013f48:	7f5070ef          	jal	ra,8001bf3c <fatalf>
    80013f4c:	a089                	j	80013f8e <rng_fill+0xa0>
        return;
    }

    VirtioDescriptor desc;
    desc.addr = kernel_mmu_translate((uintptr_t)virtual_buffer_address);
    80013f4e:	fd843783          	ld	a5,-40(s0)
    80013f52:	853e                	mv	a0,a5
    80013f54:	331010ef          	jal	ra,80015a84 <kernel_mmu_translate>
    80013f58:	87aa                	mv	a5,a0
    80013f5a:	fef43023          	sd	a5,-32(s0)
    desc.len = size;
    80013f5e:	fd645783          	lhu	a5,-42(s0)
    80013f62:	2781                	sext.w	a5,a5
    80013f64:	fef42423          	sw	a5,-24(s0)
    desc.flags = VIRTQ_DESC_F_WRITE;
    80013f68:	4789                	li	a5,2
    80013f6a:	fef41623          	sh	a5,-20(s0)
    desc.next = 0;
    80013f6e:	fe041723          	sh	zero,-18(s0)

    virtio_send_one_descriptor(rng_device, 0, desc, true);
    80013f72:	00011797          	auipc	a5,0x11
    80013f76:	0c678793          	addi	a5,a5,198 # 80025038 <rng_device>
    80013f7a:	639c                	ld	a5,0(a5)
    80013f7c:	4705                	li	a4,1
    80013f7e:	fe043603          	ld	a2,-32(s0)
    80013f82:	fe843683          	ld	a3,-24(s0)
    80013f86:	4581                	li	a1,0
    80013f88:	853e                	mv	a0,a5
    80013f8a:	528090ef          	jal	ra,8001d4b2 <virtio_send_one_descriptor>
}
    80013f8e:	70a2                	ld	ra,40(sp)
    80013f90:	7402                	ld	s0,32(sp)
    80013f92:	6145                	addi	sp,sp,48
    80013f94:	8082                	ret

0000000080013f96 <pci_device_exists>:
// `irq_pci_devices` vector contains devices that share an IRQ number (32, 33, 34, and 35).
// These vectors contain the pointers to the devices in the ECAM address space.
static struct Vector *all_pci_devices, *irq_pci_devices[4];

static inline bool pci_device_exists(uint16_t vendor_id)
{
    80013f96:	1101                	addi	sp,sp,-32
    80013f98:	ec22                	sd	s0,24(sp)
    80013f9a:	1000                	addi	s0,sp,32
    80013f9c:	87aa                	mv	a5,a0
    80013f9e:	fef41723          	sh	a5,-18(s0)
    return !((vendor_id == 0x0000) || (vendor_id == 0xFFFF));
    80013fa2:	fee45783          	lhu	a5,-18(s0)
    80013fa6:	2781                	sext.w	a5,a5
    80013fa8:	cb99                	beqz	a5,80013fbe <pci_device_exists+0x28>
    80013faa:	fee45783          	lhu	a5,-18(s0)
    80013fae:	0007871b          	sext.w	a4,a5
    80013fb2:	67c1                	lui	a5,0x10
    80013fb4:	17fd                	addi	a5,a5,-1
    80013fb6:	00f70463          	beq	a4,a5,80013fbe <pci_device_exists+0x28>
    80013fba:	4785                	li	a5,1
    80013fbc:	a011                	j	80013fc0 <pci_device_exists+0x2a>
    80013fbe:	4781                	li	a5,0
    80013fc0:	8b85                	andi	a5,a5,1
    80013fc2:	0ff7f793          	andi	a5,a5,255
}
    80013fc6:	853e                	mv	a0,a5
    80013fc8:	6462                	ld	s0,24(sp)
    80013fca:	6105                	addi	sp,sp,32
    80013fcc:	8082                	ret

0000000080013fce <pci_is_virtio_device>:

// Is this a virtio device?
bool pci_is_virtio_device(PCIDevice *dev) {
    80013fce:	1101                	addi	sp,sp,-32
    80013fd0:	ec22                	sd	s0,24(sp)
    80013fd2:	1000                	addi	s0,sp,32
    80013fd4:	fea43423          	sd	a0,-24(s0)
    return dev->ecam_header->vendor_id == 0x1AF4;
    80013fd8:	fe843783          	ld	a5,-24(s0)
    80013fdc:	639c                	ld	a5,0(a5)
    80013fde:	0007d783          	lhu	a5,0(a5) # 10000 <i+0xffe0>
    80013fe2:	17c2                	slli	a5,a5,0x30
    80013fe4:	93c1                	srli	a5,a5,0x30
    80013fe6:	0007871b          	sext.w	a4,a5
    80013fea:	6789                	lui	a5,0x2
    80013fec:	af478793          	addi	a5,a5,-1292 # 1af4 <i+0x1ad4>
    80013ff0:	40f707b3          	sub	a5,a4,a5
    80013ff4:	0017b793          	seqz	a5,a5
    80013ff8:	0ff7f793          	andi	a5,a5,255
}
    80013ffc:	853e                	mv	a0,a5
    80013ffe:	6462                	ld	s0,24(sp)
    80014000:	6105                	addi	sp,sp,32
    80014002:	8082                	ret

0000000080014004 <pci_find_saved_device>:

// Find the saved PCI device with the given vendor and device ID.
// This will retrieve the bookkeeping structure for the PCI device
// maintained by the OS.
PCIDevice *pci_find_saved_device(uint16_t vendor_id, uint16_t device_id) {
    80014004:	7179                	addi	sp,sp,-48
    80014006:	f406                	sd	ra,40(sp)
    80014008:	f022                	sd	s0,32(sp)
    8001400a:	1800                	addi	s0,sp,48
    8001400c:	87aa                	mv	a5,a0
    8001400e:	872e                	mv	a4,a1
    80014010:	fcf41f23          	sh	a5,-34(s0)
    80014014:	87ba                	mv	a5,a4
    80014016:	fcf41e23          	sh	a5,-36(s0)
    // debugf("Searching for device with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    // Iterate through the devices
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    8001401a:	fe042623          	sw	zero,-20(s0)
    8001401e:	a8a1                	j	80014076 <pci_find_saved_device+0x72>
        // Check if the device has the given vendor and device ID
        PCIDevice *pcidev = pci_get_nth_saved_device(i);
    80014020:	fec42783          	lw	a5,-20(s0)
    80014024:	17c2                	slli	a5,a5,0x30
    80014026:	93c1                	srli	a5,a5,0x30
    80014028:	853e                	mv	a0,a5
    8001402a:	32e000ef          	jal	ra,80014358 <pci_get_nth_saved_device>
    8001402e:	fea43023          	sd	a0,-32(s0)
        // debugf("Checking device with vendor ID: 0x%04x, device ID: 0x%04x\n", pcidev->ecam_header->vendor_id, pcidev->ecam_header->device_id);
        if (pcidev->ecam_header->vendor_id == vendor_id && pcidev->ecam_header->device_id == device_id) {
    80014032:	fe043783          	ld	a5,-32(s0)
    80014036:	639c                	ld	a5,0(a5)
    80014038:	0007d783          	lhu	a5,0(a5)
    8001403c:	17c2                	slli	a5,a5,0x30
    8001403e:	93c1                	srli	a5,a5,0x30
    80014040:	fde45703          	lhu	a4,-34(s0)
    80014044:	2701                	sext.w	a4,a4
    80014046:	2781                	sext.w	a5,a5
    80014048:	02f71263          	bne	a4,a5,8001406c <pci_find_saved_device+0x68>
    8001404c:	fe043783          	ld	a5,-32(s0)
    80014050:	639c                	ld	a5,0(a5)
    80014052:	0027d783          	lhu	a5,2(a5)
    80014056:	17c2                	slli	a5,a5,0x30
    80014058:	93c1                	srli	a5,a5,0x30
    8001405a:	fdc45703          	lhu	a4,-36(s0)
    8001405e:	2701                	sext.w	a4,a4
    80014060:	2781                	sext.w	a5,a5
    80014062:	00f71563          	bne	a4,a5,8001406c <pci_find_saved_device+0x68>
            return pcidev;
    80014066:	fe043783          	ld	a5,-32(s0)
    8001406a:	a03d                	j	80014098 <pci_find_saved_device+0x94>
    for (uint32_t i=0; i<vector_size(all_pci_devices); i++) {
    8001406c:	fec42783          	lw	a5,-20(s0)
    80014070:	2785                	addiw	a5,a5,1
    80014072:	fef42623          	sw	a5,-20(s0)
    80014076:	00011797          	auipc	a5,0x11
    8001407a:	fca78793          	addi	a5,a5,-54 # 80025040 <all_pci_devices>
    8001407e:	639c                	ld	a5,0(a5)
    80014080:	853e                	mv	a0,a5
    80014082:	56c0f0ef          	jal	ra,800235ee <vector_size>
    80014086:	87aa                	mv	a5,a0
    80014088:	0007871b          	sext.w	a4,a5
    8001408c:	fec42783          	lw	a5,-20(s0)
    80014090:	2781                	sext.w	a5,a5
    80014092:	f8e7e7e3          	bltu	a5,a4,80014020 <pci_find_saved_device+0x1c>
        }
    }
    // If we get here, we didn't find the device
    // debugf("No device found with vendor ID: 0x%04x, device ID: 0x%04x\n", vendor_id, device_id);
    return NULL;
    80014096:	4781                	li	a5,0
}
    80014098:	853e                	mv	a0,a5
    8001409a:	70a2                	ld	ra,40(sp)
    8001409c:	7402                	ld	s0,32(sp)
    8001409e:	6145                	addi	sp,sp,48
    800140a0:	8082                	ret

00000000800140a2 <pci_get_capability>:

// Get the nth PCI capability for the PCI device. This is used with `0x9` as the type
// to enumerate all of the several Virtio capabilities for a PCI device with the Virtio
// vendor ID.
volatile struct pci_cape *pci_get_capability(PCIDevice *device, uint8_t type, uint8_t nth) {
    800140a2:	7139                	addi	sp,sp,-64
    800140a4:	fc22                	sd	s0,56(sp)
    800140a6:	0080                	addi	s0,sp,64
    800140a8:	fca43423          	sd	a0,-56(s0)
    800140ac:	87ae                	mv	a5,a1
    800140ae:	8732                	mv	a4,a2
    800140b0:	fcf403a3          	sb	a5,-57(s0)
    800140b4:	87ba                	mv	a5,a4
    800140b6:	fcf40323          	sb	a5,-58(s0)
    // Get the header for the device
    volatile struct pci_ecam *header = device->ecam_header;
    800140ba:	fc843783          	ld	a5,-56(s0)
    800140be:	639c                	ld	a5,0(a5)
    800140c0:	fef43023          	sd	a5,-32(s0)
    if (!(header->status_reg & (1 << 4))) {
    800140c4:	fe043783          	ld	a5,-32(s0)
    800140c8:	0067d783          	lhu	a5,6(a5)
    800140cc:	17c2                	slli	a5,a5,0x30
    800140ce:	93c1                	srli	a5,a5,0x30
    800140d0:	2781                	sext.w	a5,a5
    800140d2:	8bc1                	andi	a5,a5,16
    800140d4:	2781                	sext.w	a5,a5
    800140d6:	e399                	bnez	a5,800140dc <pci_get_capability+0x3a>
        debugf("Status reg bit 4 not set; no capabilities for device\n");
        return NULL;
    800140d8:	4781                	li	a5,0
    800140da:	a055                	j	8001417e <pci_get_capability+0xdc>
    }
    
    // Get the offset of the first capability
    uint8_t cap_pointer = header->type0.capes_pointer;
    800140dc:	fe043783          	ld	a5,-32(s0)
    800140e0:	0347c783          	lbu	a5,52(a5)
    800140e4:	fef407a3          	sb	a5,-17(s0)
    // Count the number of capabilities we've seen
    uint8_t count = 0;
    800140e8:	fe040723          	sb	zero,-18(s0)
    
    // While the capability pointer is not zero
    while (cap_pointer) {
    800140ec:	a059                	j	80014172 <pci_get_capability+0xd0>
        // Get the capability at the offset
        volatile struct pci_cape* cape = (struct pci_cape*)((uintptr_t)header + cap_pointer);
    800140ee:	fef44703          	lbu	a4,-17(s0)
    800140f2:	fe043783          	ld	a5,-32(s0)
    800140f6:	97ba                	add	a5,a5,a4
    800140f8:	fcf43c23          	sd	a5,-40(s0)
        // If the capability ID matches the type we're looking for
        switch (cape->id) {
    800140fc:	fd843783          	ld	a5,-40(s0)
    80014100:	0007c783          	lbu	a5,0(a5)
    80014104:	0ff7f793          	andi	a5,a5,255
    80014108:	2781                	sext.w	a5,a5
    8001410a:	86be                	mv	a3,a5
    8001410c:	4725                	li	a4,9
    8001410e:	00e68e63          	beq	a3,a4,8001412a <pci_get_capability+0x88>
    80014112:	86be                	mv	a3,a5
    80014114:	4725                	li	a4,9
    80014116:	00e6cc63          	blt	a3,a4,8001412e <pci_get_capability+0x8c>
    8001411a:	2781                	sext.w	a5,a5
    8001411c:	37c1                	addiw	a5,a5,-16
    8001411e:	2781                	sext.w	a5,a5
    80014120:	873e                	mv	a4,a5
    80014122:	4785                	li	a5,1
    80014124:	00e7e563          	bltu	a5,a4,8001412e <pci_get_capability+0x8c>
            {
            }
            case 0x11: /* MSI-x */
            {
            }
            break;
    80014128:	a021                	j	80014130 <pci_get_capability+0x8e>
            break;
    8001412a:	0001                	nop
    8001412c:	a011                	j	80014130 <pci_get_capability+0x8e>
            default:
                debugf("Unknown capability ID 0x%02x (next: 0x%02x)\n", cape->id, cape->next);
            break;
    8001412e:	0001                	nop
        }

        if (cape->id == type) {
    80014130:	fd843783          	ld	a5,-40(s0)
    80014134:	0007c783          	lbu	a5,0(a5)
    80014138:	0ff7f713          	andi	a4,a5,255
    8001413c:	fc744783          	lbu	a5,-57(s0)
    80014140:	0ff7f793          	andi	a5,a5,255
    80014144:	02e79163          	bne	a5,a4,80014166 <pci_get_capability+0xc4>
            // If we've seen the nth capability, return it
            if (count++ == nth) {
    80014148:	fee44783          	lbu	a5,-18(s0)
    8001414c:	0017871b          	addiw	a4,a5,1
    80014150:	fee40723          	sb	a4,-18(s0)
    80014154:	fc644703          	lbu	a4,-58(s0)
    80014158:	0ff77713          	andi	a4,a4,255
    8001415c:	00f71563          	bne	a4,a5,80014166 <pci_get_capability+0xc4>
                return cape;
    80014160:	fd843783          	ld	a5,-40(s0)
    80014164:	a829                	j	8001417e <pci_get_capability+0xdc>
            }
        }
        // Otherwise, continue to the next capability
        cap_pointer = cape->next; 
    80014166:	fd843783          	ld	a5,-40(s0)
    8001416a:	0017c783          	lbu	a5,1(a5)
    8001416e:	fef407a3          	sb	a5,-17(s0)
    while (cap_pointer) {
    80014172:	fef44783          	lbu	a5,-17(s0)
    80014176:	0ff7f793          	andi	a5,a5,255
    8001417a:	fbb5                	bnez	a5,800140ee <pci_get_capability+0x4c>
    }
    return NULL;
    8001417c:	4781                	li	a5,0
}
    8001417e:	853e                	mv	a0,a5
    80014180:	7462                	ld	s0,56(sp)
    80014182:	6121                	addi	sp,sp,64
    80014184:	8082                	ret

0000000080014186 <pci_get_virtio_capability>:
// For the common configuration capability, use `VIRTIO_PCI_CAP_COMMON_CFG`.
// For the notify capability, use `VIRTIO_PCI_CAP_NOTIFY_CFG`.
// For the ISR capability, use `VIRTIO_PCI_CAP_ISR_CFG`.
// For the device configuration capability, use `VIRTIO_PCI_CAP_DEVICE_CFG`.
// For the PCI configuration access capability, use `VIRTIO_PCI_CAP_PCI_CFG`.
volatile struct VirtioCapability *pci_get_virtio_capability(PCIDevice *device, uint8_t virtio_cap_type) {
    80014186:	7139                	addi	sp,sp,-64
    80014188:	fc06                	sd	ra,56(sp)
    8001418a:	f822                	sd	s0,48(sp)
    8001418c:	0080                	addi	s0,sp,64
    8001418e:	fca43423          	sd	a0,-56(s0)
    80014192:	87ae                	mv	a5,a1
    80014194:	fcf403a3          	sb	a5,-57(s0)
    // Iterate through the first 10 capabilities
    for (uint8_t i=0; i<10; i++) {
    80014198:	fe0407a3          	sb	zero,-17(s0)
    8001419c:	a0b1                	j	800141e8 <pci_get_virtio_capability+0x62>
        // Get the capability
        volatile struct pci_cape *cape = pci_get_capability(device, 0x09, i);
    8001419e:	fef44783          	lbu	a5,-17(s0)
    800141a2:	863e                	mv	a2,a5
    800141a4:	45a5                	li	a1,9
    800141a6:	fc843503          	ld	a0,-56(s0)
    800141aa:	ef9ff0ef          	jal	ra,800140a2 <pci_get_capability>
    800141ae:	fea43023          	sd	a0,-32(s0)
        volatile struct VirtioCapability *virtio_cap = (struct VirtioCapability *)cape;
    800141b2:	fe043783          	ld	a5,-32(s0)
    800141b6:	fcf43c23          	sd	a5,-40(s0)
        // If the capability isnt NULL and the type matches, return it
        if (virtio_cap && virtio_cap->type == virtio_cap_type) {
    800141ba:	fd843783          	ld	a5,-40(s0)
    800141be:	c385                	beqz	a5,800141de <pci_get_virtio_capability+0x58>
    800141c0:	fd843783          	ld	a5,-40(s0)
    800141c4:	0037c783          	lbu	a5,3(a5)
    800141c8:	0ff7f713          	andi	a4,a5,255
    800141cc:	fc744783          	lbu	a5,-57(s0)
    800141d0:	0ff7f793          	andi	a5,a5,255
    800141d4:	00e79563          	bne	a5,a4,800141de <pci_get_virtio_capability+0x58>
            debugf("Got capability of type %x at %p\n", virtio_cap_type, virtio_cap);
            return virtio_cap;
    800141d8:	fd843783          	ld	a5,-40(s0)
    800141dc:	a831                	j	800141f8 <pci_get_virtio_capability+0x72>
    for (uint8_t i=0; i<10; i++) {
    800141de:	fef44783          	lbu	a5,-17(s0)
    800141e2:	2785                	addiw	a5,a5,1
    800141e4:	fef407a3          	sb	a5,-17(s0)
    800141e8:	fef44783          	lbu	a5,-17(s0)
    800141ec:	0ff7f713          	andi	a4,a5,255
    800141f0:	47a5                	li	a5,9
    800141f2:	fae7f6e3          	bgeu	a5,a4,8001419e <pci_get_virtio_capability+0x18>
        }
    }
    // If we get here, we didn't find the capability
    debugf("No virtio capability found with type %d\n", virtio_cap_type);
    return NULL;
    800141f6:	4781                	li	a5,0
}
    800141f8:	853e                	mv	a0,a5
    800141fa:	70e2                	ld	ra,56(sp)
    800141fc:	7442                	ld	s0,48(sp)
    800141fe:	6121                	addi	sp,sp,64
    80014200:	8082                	ret

0000000080014202 <pci_count_saved_devices>:

// Return the number of bookkeeping PCI devices saved by the OS.
uint64_t pci_count_saved_devices(void) {
    80014202:	1141                	addi	sp,sp,-16
    80014204:	e406                	sd	ra,8(sp)
    80014206:	e022                	sd	s0,0(sp)
    80014208:	0800                	addi	s0,sp,16
    return vector_size(all_pci_devices);
    8001420a:	00011797          	auipc	a5,0x11
    8001420e:	e3678793          	addi	a5,a5,-458 # 80025040 <all_pci_devices>
    80014212:	639c                	ld	a5,0(a5)
    80014214:	853e                	mv	a0,a5
    80014216:	3d80f0ef          	jal	ra,800235ee <vector_size>
    8001421a:	87aa                	mv	a5,a0
    8001421c:	2781                	sext.w	a5,a5
    8001421e:	1782                	slli	a5,a5,0x20
    80014220:	9381                	srli	a5,a5,0x20
}
    80014222:	853e                	mv	a0,a5
    80014224:	60a2                	ld	ra,8(sp)
    80014226:	6402                	ld	s0,0(sp)
    80014228:	0141                	addi	sp,sp,16
    8001422a:	8082                	ret

000000008001422c <pci_count_irq_listeners>:

// Count how many devices are listening for the given IRQ.
uint64_t pci_count_irq_listeners(uint8_t irq) {
    8001422c:	7179                	addi	sp,sp,-48
    8001422e:	f406                	sd	ra,40(sp)
    80014230:	f022                	sd	s0,32(sp)
    80014232:	1800                	addi	s0,sp,48
    80014234:	87aa                	mv	a5,a0
    80014236:	fcf40fa3          	sb	a5,-33(s0)
    uint32_t vector_idx = irq - 32;
    8001423a:	fdf44783          	lbu	a5,-33(s0)
    8001423e:	2781                	sext.w	a5,a5
    80014240:	3781                	addiw	a5,a5,-32
    80014242:	2781                	sext.w	a5,a5
    80014244:	fef42623          	sw	a5,-20(s0)
    return vector_size(irq_pci_devices[vector_idx]);
    80014248:	00011717          	auipc	a4,0x11
    8001424c:	e0070713          	addi	a4,a4,-512 # 80025048 <irq_pci_devices>
    80014250:	fec46783          	lwu	a5,-20(s0)
    80014254:	078e                	slli	a5,a5,0x3
    80014256:	97ba                	add	a5,a5,a4
    80014258:	639c                	ld	a5,0(a5)
    8001425a:	853e                	mv	a0,a5
    8001425c:	3920f0ef          	jal	ra,800235ee <vector_size>
    80014260:	87aa                	mv	a5,a0
    80014262:	2781                	sext.w	a5,a5
    80014264:	1782                	slli	a5,a5,0x20
    80014266:	9381                	srli	a5,a5,0x20
}
    80014268:	853e                	mv	a0,a5
    8001426a:	70a2                	ld	ra,40(sp)
    8001426c:	7402                	ld	s0,32(sp)
    8001426e:	6145                	addi	sp,sp,48
    80014270:	8082                	ret

0000000080014272 <pci_get_bus_number>:

// Get the bus number for the given PCI device.
uint8_t pci_get_bus_number(PCIDevice *dev) {
    80014272:	1101                	addi	sp,sp,-32
    80014274:	ec22                	sd	s0,24(sp)
    80014276:	1000                	addi	s0,sp,32
    80014278:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 20) & 0xF;
    8001427c:	fe843783          	ld	a5,-24(s0)
    80014280:	639c                	ld	a5,0(a5)
    80014282:	83d1                	srli	a5,a5,0x14
    80014284:	0ff7f793          	andi	a5,a5,255
    80014288:	8bbd                	andi	a5,a5,15
    8001428a:	0ff7f793          	andi	a5,a5,255
}
    8001428e:	853e                	mv	a0,a5
    80014290:	6462                	ld	s0,24(sp)
    80014292:	6105                	addi	sp,sp,32
    80014294:	8082                	ret

0000000080014296 <pci_get_slot_number>:

// Get the slot number for the given PCI device.
uint8_t pci_get_slot_number(PCIDevice *dev) {
    80014296:	1101                	addi	sp,sp,-32
    80014298:	ec22                	sd	s0,24(sp)
    8001429a:	1000                	addi	s0,sp,32
    8001429c:	fea43423          	sd	a0,-24(s0)
    return ((uintptr_t)dev->ecam_header >> 15) & 0x1F;
    800142a0:	fe843783          	ld	a5,-24(s0)
    800142a4:	639c                	ld	a5,0(a5)
    800142a6:	83bd                	srli	a5,a5,0xf
    800142a8:	0ff7f793          	andi	a5,a5,255
    800142ac:	8bfd                	andi	a5,a5,31
    800142ae:	0ff7f793          	andi	a5,a5,255
}
    800142b2:	853e                	mv	a0,a5
    800142b4:	6462                	ld	s0,24(sp)
    800142b6:	6105                	addi	sp,sp,32
    800142b8:	8082                	ret

00000000800142ba <pci_save_device>:

// Save the PCI device for bookkeeping. This will save some
// information about the device for quick access later.
PCIDevice *pci_save_device(PCIDevice device) {
    800142ba:	7179                	addi	sp,sp,-48
    800142bc:	f406                	sd	ra,40(sp)
    800142be:	f022                	sd	s0,32(sp)
    800142c0:	ec26                	sd	s1,24(sp)
    800142c2:	1800                	addi	s0,sp,48
    800142c4:	84aa                	mv	s1,a0
    // Allocate some memory for the device's bookkeeping structure
    PCIDevice *pcidev = (PCIDevice *)kzalloc(sizeof(PCIDevice));
    800142c6:	03800593          	li	a1,56
    800142ca:	4505                	li	a0,1
    800142cc:	286010ef          	jal	ra,80015552 <kcalloc>
    800142d0:	fca43c23          	sd	a0,-40(s0)
    // Record the device's ECAM header
    memcpy(pcidev, &device, sizeof(PCIDevice));
    800142d4:	03800613          	li	a2,56
    800142d8:	85a6                	mv	a1,s1
    800142da:	fd843503          	ld	a0,-40(s0)
    800142de:	0600e0ef          	jal	ra,8002233e <memcpy>
    // Store the device in the all devices vector
    vector_push_ptr(all_pci_devices, pcidev);
    800142e2:	00011797          	auipc	a5,0x11
    800142e6:	d5e78793          	addi	a5,a5,-674 # 80025040 <all_pci_devices>
    800142ea:	639c                	ld	a5,0(a5)
    800142ec:	fd843703          	ld	a4,-40(s0)
    800142f0:	85ba                	mv	a1,a4
    800142f2:	853e                	mv	a0,a5
    800142f4:	23b0e0ef          	jal	ra,80022d2e <vector_push>
    // Store the device in the appropriate IRQ vector
    uint8_t bus = pci_get_bus_number(pcidev);
    800142f8:	fd843503          	ld	a0,-40(s0)
    800142fc:	f77ff0ef          	jal	ra,80014272 <pci_get_bus_number>
    80014300:	87aa                	mv	a5,a0
    80014302:	fcf40ba3          	sb	a5,-41(s0)
    uint8_t slot = pci_get_slot_number(pcidev);
    80014306:	fd843503          	ld	a0,-40(s0)
    8001430a:	f8dff0ef          	jal	ra,80014296 <pci_get_slot_number>
    8001430e:	87aa                	mv	a5,a0
    80014310:	fcf40b23          	sb	a5,-42(s0)
    debugf("Saving device with vendor ID: 0x%04x, device ID: 0x%04x, class code: 0x%04x\n", device.ecam_header->vendor_id, device.ecam_header->device_id, device.ecam_header->class_code);
    debugf("  Bus: %d, slot: %d\n", bus, slot);
    uint32_t vector_idx = (bus + slot) % 4;
    80014314:	fd744703          	lbu	a4,-41(s0)
    80014318:	fd644783          	lbu	a5,-42(s0)
    8001431c:	9fb9                	addw	a5,a5,a4
    8001431e:	0ff7f793          	andi	a5,a5,255
    80014322:	2781                	sext.w	a5,a5
    80014324:	8b8d                	andi	a5,a5,3
    80014326:	fcf42823          	sw	a5,-48(s0)
    vector_push_ptr(irq_pci_devices[vector_idx], pcidev);
    8001432a:	00011717          	auipc	a4,0x11
    8001432e:	d1e70713          	addi	a4,a4,-738 # 80025048 <irq_pci_devices>
    80014332:	fd046783          	lwu	a5,-48(s0)
    80014336:	078e                	slli	a5,a5,0x3
    80014338:	97ba                	add	a5,a5,a4
    8001433a:	639c                	ld	a5,0(a5)
    8001433c:	fd843703          	ld	a4,-40(s0)
    80014340:	85ba                	mv	a1,a4
    80014342:	853e                	mv	a0,a5
    80014344:	1eb0e0ef          	jal	ra,80022d2e <vector_push>
    // Return the device's bookkeeping structure in memory
    return pcidev;
    80014348:	fd843783          	ld	a5,-40(s0)
}
    8001434c:	853e                	mv	a0,a5
    8001434e:	70a2                	ld	ra,40(sp)
    80014350:	7402                	ld	s0,32(sp)
    80014352:	64e2                	ld	s1,24(sp)
    80014354:	6145                	addi	sp,sp,48
    80014356:	8082                	ret

0000000080014358 <pci_get_nth_saved_device>:

// Get the nth saved PCI device structure kept by the OS.
PCIDevice *pci_get_nth_saved_device(uint16_t n) {
    80014358:	7179                	addi	sp,sp,-48
    8001435a:	f406                	sd	ra,40(sp)
    8001435c:	f022                	sd	s0,32(sp)
    8001435e:	1800                	addi	s0,sp,48
    80014360:	87aa                	mv	a5,a0
    80014362:	fcf41f23          	sh	a5,-34(s0)
    PCIDevice *pcidev;
    vector_get_ptr(all_pci_devices, n, &pcidev);
    80014366:	00011797          	auipc	a5,0x11
    8001436a:	cda78793          	addi	a5,a5,-806 # 80025040 <all_pci_devices>
    8001436e:	639c                	ld	a5,0(a5)
    80014370:	fde45703          	lhu	a4,-34(s0)
    80014374:	2701                	sext.w	a4,a4
    80014376:	fe840693          	addi	a3,s0,-24
    8001437a:	8636                	mv	a2,a3
    8001437c:	85ba                	mv	a1,a4
    8001437e:	853e                	mv	a0,a5
    80014380:	30f0e0ef          	jal	ra,80022e8e <vector_get>
    return pcidev;
    80014384:	fe843783          	ld	a5,-24(s0)
}
    80014388:	853e                	mv	a0,a5
    8001438a:	70a2                	ld	ra,40(sp)
    8001438c:	7402                	ld	s0,32(sp)
    8001438e:	6145                	addi	sp,sp,48
    80014390:	8082                	ret

0000000080014392 <pci_find_device_by_irq>:

// Get the device responsible for a given IRQ.
PCIDevice *pci_find_device_by_irq(uint8_t irq) {
    80014392:	7139                	addi	sp,sp,-64
    80014394:	fc06                	sd	ra,56(sp)
    80014396:	f822                	sd	s0,48(sp)
    80014398:	0080                	addi	s0,sp,64
    8001439a:	87aa                	mv	a5,a0
    8001439c:	fcf407a3          	sb	a5,-49(s0)
    uint32_t vector_idx = irq - 32;
    800143a0:	fcf44783          	lbu	a5,-49(s0)
    800143a4:	2781                	sext.w	a5,a5
    800143a6:	3781                	addiw	a5,a5,-32
    800143a8:	2781                	sext.w	a5,a5
    800143aa:	fef42423          	sw	a5,-24(s0)
    debugf("Finding device with IRQ %d\n", irq);

    // Check all devices in the vector
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    800143ae:	fe042623          	sw	zero,-20(s0)
    800143b2:	a875                	j	8001446e <pci_find_device_by_irq+0xdc>
        // Get the nth PCI device listening for the IRQ
        PCIDevice *device = NULL;
    800143b4:	fc043823          	sd	zero,-48(s0)
        vector_get_ptr(irq_pci_devices[vector_idx], i, &device);
    800143b8:	00011717          	auipc	a4,0x11
    800143bc:	c9070713          	addi	a4,a4,-880 # 80025048 <irq_pci_devices>
    800143c0:	fe846783          	lwu	a5,-24(s0)
    800143c4:	078e                	slli	a5,a5,0x3
    800143c6:	97ba                	add	a5,a5,a4
    800143c8:	639c                	ld	a5,0(a5)
    800143ca:	fd040693          	addi	a3,s0,-48
    800143ce:	fec42703          	lw	a4,-20(s0)
    800143d2:	8636                	mv	a2,a3
    800143d4:	85ba                	mv	a1,a4
    800143d6:	853e                	mv	a0,a5
    800143d8:	2b70e0ef          	jal	ra,80022e8e <vector_get>
        debugf("Device: %p\n", device->ecam_header);
        // If the device is a Virtio device, check the Virtio ISR status
        if (!pci_is_virtio_device(device)) {
    800143dc:	fd043783          	ld	a5,-48(s0)
    800143e0:	853e                	mv	a0,a5
    800143e2:	bedff0ef          	jal	ra,80013fce <pci_is_virtio_device>
    800143e6:	87aa                	mv	a5,a0
    800143e8:	0017c793          	xori	a5,a5,1
    800143ec:	0ff7f793          	andi	a5,a5,255
    800143f0:	e7bd                	bnez	a5,8001445e <pci_find_device_by_irq+0xcc>
            debugf("%p not a virtio device\n", device);
            continue;
        }
        
        // Confirm that the device exists
        if (!pci_device_exists(device->ecam_header->vendor_id)) {
    800143f2:	fd043783          	ld	a5,-48(s0)
    800143f6:	639c                	ld	a5,0(a5)
    800143f8:	0007d783          	lhu	a5,0(a5)
    800143fc:	17c2                	slli	a5,a5,0x30
    800143fe:	93c1                	srli	a5,a5,0x30
    80014400:	853e                	mv	a0,a5
    80014402:	b95ff0ef          	jal	ra,80013f96 <pci_device_exists>
    80014406:	87aa                	mv	a5,a0
    80014408:	0017c793          	xori	a5,a5,1
    8001440c:	0ff7f793          	andi	a5,a5,255
    80014410:	eba9                	bnez	a5,80014462 <pci_find_device_by_irq+0xd0>
            debugf("%p device doesn't exist\n", device);
            continue;
        }

        // Get the Virtio ISR status
        volatile struct VirtioPciIsrCfg *isr = pci_get_virtio_isr_status(device);
    80014412:	fd043783          	ld	a5,-48(s0)
    80014416:	853e                	mv	a0,a5
    80014418:	19e000ef          	jal	ra,800145b6 <pci_get_virtio_isr_status>
    8001441c:	fea43023          	sd	a0,-32(s0)
        int result = isr->isr_cap;
    80014420:	fe043783          	ld	a5,-32(s0)
    80014424:	439c                	lw	a5,0(a5)
    80014426:	2781                	sext.w	a5,a5
    80014428:	fcf42e23          	sw	a5,-36(s0)
        debugf("ISR at %p=0x%x\n", isr, result);
        if (result) {
    8001442c:	fdc42783          	lw	a5,-36(s0)
    80014430:	2781                	sext.w	a5,a5
    80014432:	c781                	beqz	a5,8001443a <pci_find_device_by_irq+0xa8>
            debugf("IRQ device responsible: %p\n", device);
            return device;
    80014434:	fd043783          	ld	a5,-48(s0)
    80014438:	a085                	j	80014498 <pci_find_device_by_irq+0x106>
        }

        // Check if the device's configuration has changed
        if (isr->isr_cap) {
    8001443a:	fe043783          	ld	a5,-32(s0)
    8001443e:	439c                	lw	a5,0(a5)
    80014440:	2781                	sext.w	a5,a5
    80014442:	c781                	beqz	a5,8001444a <pci_find_device_by_irq+0xb8>
            debugf("Device configuration interrupt from device 0x%04x\n", device->ecam_header->device_id);
            return device;
    80014444:	fd043783          	ld	a5,-48(s0)
    80014448:	a881                	j	80014498 <pci_find_device_by_irq+0x106>
        }

        // Check if the device's queue has an interrupt
        if (isr->queue_interrupt) {
    8001444a:	fe043783          	ld	a5,-32(s0)
    8001444e:	439c                	lw	a5,0(a5)
    80014450:	8b85                	andi	a5,a5,1
    80014452:	0ff7f793          	andi	a5,a5,255
    80014456:	c799                	beqz	a5,80014464 <pci_find_device_by_irq+0xd2>
            debugf("Device queue interrupt from device 0x%04x\n", device->ecam_header->device_id);
            return device;
    80014458:	fd043783          	ld	a5,-48(s0)
    8001445c:	a835                	j	80014498 <pci_find_device_by_irq+0x106>
            continue;
    8001445e:	0001                	nop
    80014460:	a011                	j	80014464 <pci_find_device_by_irq+0xd2>
            continue;
    80014462:	0001                	nop
    for (uint32_t i=0; i<vector_size(irq_pci_devices[vector_idx]); i++) {
    80014464:	fec42783          	lw	a5,-20(s0)
    80014468:	2785                	addiw	a5,a5,1
    8001446a:	fef42623          	sw	a5,-20(s0)
    8001446e:	00011717          	auipc	a4,0x11
    80014472:	bda70713          	addi	a4,a4,-1062 # 80025048 <irq_pci_devices>
    80014476:	fe846783          	lwu	a5,-24(s0)
    8001447a:	078e                	slli	a5,a5,0x3
    8001447c:	97ba                	add	a5,a5,a4
    8001447e:	639c                	ld	a5,0(a5)
    80014480:	853e                	mv	a0,a5
    80014482:	16c0f0ef          	jal	ra,800235ee <vector_size>
    80014486:	87aa                	mv	a5,a0
    80014488:	0007871b          	sext.w	a4,a5
    8001448c:	fec42783          	lw	a5,-20(s0)
    80014490:	2781                	sext.w	a5,a5
    80014492:	f2e7e1e3          	bltu	a5,a4,800143b4 <pci_find_device_by_irq+0x22>
        }
    }
    debugf("No device found with IRQ %d\n", irq);
    return NULL;
    80014496:	4781                	li	a5,0
}
    80014498:	853e                	mv	a0,a5
    8001449a:	70e2                	ld	ra,56(sp)
    8001449c:	7442                	ld	s0,48(sp)
    8001449e:	6121                	addi	sp,sp,64
    800144a0:	8082                	ret

00000000800144a2 <pci_get_device_specific_config>:


// Get the common configuration capability for the given virtio device.
volatile void *pci_get_device_specific_config(PCIDevice *device) {
    800144a2:	7179                	addi	sp,sp,-48
    800144a4:	f406                	sd	ra,40(sp)
    800144a6:	f022                	sd	s0,32(sp)
    800144a8:	1800                	addi	s0,sp,48
    800144aa:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_DEVICE_CFG);
    800144ae:	4591                	li	a1,4
    800144b0:	fd843503          	ld	a0,-40(s0)
    800144b4:	cd3ff0ef          	jal	ra,80014186 <pci_get_virtio_capability>
    800144b8:	fea43423          	sd	a0,-24(s0)
    debugf("Getting device specific config from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uint64_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uint64_t)vio_cap->offset);
    return (volatile void*)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    800144bc:	fd843783          	ld	a5,-40(s0)
    800144c0:	6398                	ld	a4,0(a5)
    800144c2:	fe843783          	ld	a5,-24(s0)
    800144c6:	0047c783          	lbu	a5,4(a5)
    800144ca:	0ff7f793          	andi	a5,a5,255
    800144ce:	2781                	sext.w	a5,a5
    800144d0:	0791                	addi	a5,a5,4
    800144d2:	078a                	slli	a5,a5,0x2
    800144d4:	97ba                	add	a5,a5,a4
    800144d6:	439c                	lw	a5,0(a5)
    800144d8:	2781                	sext.w	a5,a5
    800144da:	1782                	slli	a5,a5,0x20
    800144dc:	9381                	srli	a5,a5,0x20
    800144de:	ff07f713          	andi	a4,a5,-16
    800144e2:	fe843783          	ld	a5,-24(s0)
    800144e6:	479c                	lw	a5,8(a5)
    800144e8:	2781                	sext.w	a5,a5
    800144ea:	1782                	slli	a5,a5,0x20
    800144ec:	9381                	srli	a5,a5,0x20
    800144ee:	97ba                	add	a5,a5,a4
}
    800144f0:	853e                	mv	a0,a5
    800144f2:	70a2                	ld	ra,40(sp)
    800144f4:	7402                	ld	s0,32(sp)
    800144f6:	6145                	addi	sp,sp,48
    800144f8:	8082                	ret

00000000800144fa <pci_get_virtio_common_config>:

// Get the common configuration capability for the given virtio device.
volatile struct VirtioPciCommonCfg *pci_get_virtio_common_config(PCIDevice *device) {
    800144fa:	7179                	addi	sp,sp,-48
    800144fc:	f406                	sd	ra,40(sp)
    800144fe:	f022                	sd	s0,32(sp)
    80014500:	1800                	addi	s0,sp,48
    80014502:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_COMMON_CFG);
    80014506:	4585                	li	a1,1
    80014508:	fd843503          	ld	a0,-40(s0)
    8001450c:	c7bff0ef          	jal	ra,80014186 <pci_get_virtio_capability>
    80014510:	fea43423          	sd	a0,-24(s0)
    debugf("Getting common capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset);
    return (volatile struct VirtioPciCommonCfg *)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    80014514:	fd843783          	ld	a5,-40(s0)
    80014518:	6398                	ld	a4,0(a5)
    8001451a:	fe843783          	ld	a5,-24(s0)
    8001451e:	0047c783          	lbu	a5,4(a5)
    80014522:	0ff7f793          	andi	a5,a5,255
    80014526:	2781                	sext.w	a5,a5
    80014528:	0791                	addi	a5,a5,4
    8001452a:	078a                	slli	a5,a5,0x2
    8001452c:	97ba                	add	a5,a5,a4
    8001452e:	439c                	lw	a5,0(a5)
    80014530:	2781                	sext.w	a5,a5
    80014532:	1782                	slli	a5,a5,0x20
    80014534:	9381                	srli	a5,a5,0x20
    80014536:	ff07f713          	andi	a4,a5,-16
    8001453a:	fe843783          	ld	a5,-24(s0)
    8001453e:	479c                	lw	a5,8(a5)
    80014540:	2781                	sext.w	a5,a5
    80014542:	1782                	slli	a5,a5,0x20
    80014544:	9381                	srli	a5,a5,0x20
    80014546:	97ba                	add	a5,a5,a4
}
    80014548:	853e                	mv	a0,a5
    8001454a:	70a2                	ld	ra,40(sp)
    8001454c:	7402                	ld	s0,32(sp)
    8001454e:	6145                	addi	sp,sp,48
    80014550:	8082                	ret

0000000080014552 <pci_get_virtio_notify_capability>:

// Get the notify capability for the given virtio device.
volatile struct VirtioPciNotifyCfg *pci_get_virtio_notify_capability(PCIDevice *device) {
    80014552:	7179                	addi	sp,sp,-48
    80014554:	f406                	sd	ra,40(sp)
    80014556:	f022                	sd	s0,32(sp)
    80014558:	1800                	addi	s0,sp,48
    8001455a:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_NOTIFY_CFG);
    8001455e:	4589                	li	a1,2
    80014560:	fd843503          	ld	a0,-40(s0)
    80014564:	c23ff0ef          	jal	ra,80014186 <pci_get_virtio_capability>
    80014568:	fea43423          	sd	a0,-24(s0)
    debugf("Cap at %p\n", vio_cap);
    debugf("Getting notify capability from bar #%d = %p + 0x%x (len=%d) %d\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset, vio_cap->len, sizeof(VirtioPciNotifyCfg));
    return (volatile struct VirtioPciNotifyCfg*)vio_cap;
    8001456c:	fe843783          	ld	a5,-24(s0)
}
    80014570:	853e                	mv	a0,a5
    80014572:	70a2                	ld	ra,40(sp)
    80014574:	7402                	ld	s0,32(sp)
    80014576:	6145                	addi	sp,sp,48
    80014578:	8082                	ret

000000008001457a <pci_get_device_bar>:

volatile uint8_t *pci_get_device_bar(PCIDevice *device, uint8_t bar_num) {
    8001457a:	1101                	addi	sp,sp,-32
    8001457c:	ec22                	sd	s0,24(sp)
    8001457e:	1000                	addi	s0,sp,32
    80014580:	fea43423          	sd	a0,-24(s0)
    80014584:	87ae                	mv	a5,a1
    80014586:	fef403a3          	sb	a5,-25(s0)
    return (volatile uint8_t*)(uintptr_t)(device->ecam_header->type0.bar[bar_num] & ~0xf);
    8001458a:	fe843783          	ld	a5,-24(s0)
    8001458e:	6398                	ld	a4,0(a5)
    80014590:	fe744783          	lbu	a5,-25(s0)
    80014594:	2781                	sext.w	a5,a5
    80014596:	0791                	addi	a5,a5,4
    80014598:	078a                	slli	a5,a5,0x2
    8001459a:	97ba                	add	a5,a5,a4
    8001459c:	439c                	lw	a5,0(a5)
    8001459e:	2781                	sext.w	a5,a5
    800145a0:	02079713          	slli	a4,a5,0x20
    800145a4:	9301                	srli	a4,a4,0x20
    800145a6:	4785                	li	a5,1
    800145a8:	1782                	slli	a5,a5,0x20
    800145aa:	17c1                	addi	a5,a5,-16
    800145ac:	8ff9                	and	a5,a5,a4
}
    800145ae:	853e                	mv	a0,a5
    800145b0:	6462                	ld	s0,24(sp)
    800145b2:	6105                	addi	sp,sp,32
    800145b4:	8082                	ret

00000000800145b6 <pci_get_virtio_isr_status>:


// Get the ISR capability for the given virtio device.
volatile struct VirtioPciIsrCfg *pci_get_virtio_isr_status(PCIDevice *device) {
    800145b6:	7179                	addi	sp,sp,-48
    800145b8:	f406                	sd	ra,40(sp)
    800145ba:	f022                	sd	s0,32(sp)
    800145bc:	1800                	addi	s0,sp,48
    800145be:	fca43c23          	sd	a0,-40(s0)
    volatile struct VirtioCapability *vio_cap = pci_get_virtio_capability(device, VIRTIO_PCI_CAP_ISR_CFG);
    800145c2:	458d                	li	a1,3
    800145c4:	fd843503          	ld	a0,-40(s0)
    800145c8:	bbfff0ef          	jal	ra,80014186 <pci_get_virtio_capability>
    800145cc:	fea43423          	sd	a0,-24(s0)
    debugf("Getting ISR capability from bar #%d = %p + 0x%x\n", vio_cap->bar, ((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf), (uintptr_t)vio_cap->offset);
    return (volatile struct VirtioPciIsrCfg *)(((uintptr_t)device->ecam_header->type0.bar[vio_cap->bar] & ~0xf) + (uintptr_t)vio_cap->offset);
    800145d0:	fd843783          	ld	a5,-40(s0)
    800145d4:	6398                	ld	a4,0(a5)
    800145d6:	fe843783          	ld	a5,-24(s0)
    800145da:	0047c783          	lbu	a5,4(a5)
    800145de:	0ff7f793          	andi	a5,a5,255
    800145e2:	2781                	sext.w	a5,a5
    800145e4:	0791                	addi	a5,a5,4
    800145e6:	078a                	slli	a5,a5,0x2
    800145e8:	97ba                	add	a5,a5,a4
    800145ea:	439c                	lw	a5,0(a5)
    800145ec:	2781                	sext.w	a5,a5
    800145ee:	1782                	slli	a5,a5,0x20
    800145f0:	9381                	srli	a5,a5,0x20
    800145f2:	ff07f713          	andi	a4,a5,-16
    800145f6:	fe843783          	ld	a5,-24(s0)
    800145fa:	479c                	lw	a5,8(a5)
    800145fc:	2781                	sext.w	a5,a5
    800145fe:	1782                	slli	a5,a5,0x20
    80014600:	9381                	srli	a5,a5,0x20
    80014602:	97ba                	add	a5,a5,a4
}
    80014604:	853e                	mv	a0,a5
    80014606:	70a2                	ld	ra,40(sp)
    80014608:	7402                	ld	s0,32(sp)
    8001460a:	6145                	addi	sp,sp,48
    8001460c:	8082                	ret

000000008001460e <pci_get_ecam>:

static volatile struct pci_ecam *pci_get_ecam(uint8_t bus,
                                              uint8_t device,
                                              uint8_t function,
                                              uint16_t reg) 
{
    8001460e:	715d                	addi	sp,sp,-80
    80014610:	e486                	sd	ra,72(sp)
    80014612:	e0a2                	sd	s0,64(sp)
    80014614:	0880                	addi	s0,sp,80
    80014616:	87aa                	mv	a5,a0
    80014618:	8736                	mv	a4,a3
    8001461a:	faf40fa3          	sb	a5,-65(s0)
    8001461e:	87ae                	mv	a5,a1
    80014620:	faf40f23          	sb	a5,-66(s0)
    80014624:	87b2                	mv	a5,a2
    80014626:	faf40ea3          	sb	a5,-67(s0)
    8001462a:	87ba                	mv	a5,a4
    8001462c:	faf41d23          	sh	a5,-70(s0)
    // Since we're shifting, we need to make sure we
    // have enough space to shift into.
    uint64_t bus64 = bus & 0xff;
    80014630:	fbf44783          	lbu	a5,-65(s0)
    80014634:	fef43423          	sd	a5,-24(s0)
    uint64_t device64 = device & 0x1f;
    80014638:	fbe44783          	lbu	a5,-66(s0)
    8001463c:	8bfd                	andi	a5,a5,31
    8001463e:	fef43023          	sd	a5,-32(s0)
    uint64_t function64 = function & 0x7;
    80014642:	fbd44783          	lbu	a5,-67(s0)
    80014646:	8b9d                	andi	a5,a5,7
    80014648:	fcf43c23          	sd	a5,-40(s0)
    uint64_t reg64 = reg & 0x3ff; 
    8001464c:	fba45783          	lhu	a5,-70(s0)
    80014650:	3ff7f793          	andi	a5,a5,1023
    80014654:	fcf43823          	sd	a5,-48(s0)
    
    // Finally, put the address together
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    80014658:	fe843783          	ld	a5,-24(s0)
    8001465c:	01479713          	slli	a4,a5,0x14
                     (device64 << 15) |   // device number A[19:15]
    80014660:	fe043783          	ld	a5,-32(s0)
    80014664:	07be                	slli	a5,a5,0xf
                     (bus64 << 20) |      // bus number A[(20+n-1):20] (up to 8 bits)
    80014666:	8f5d                	or	a4,a4,a5
                     (function64 << 12) | // function number A[14:12]
    80014668:	fd843783          	ld	a5,-40(s0)
    8001466c:	07b2                	slli	a5,a5,0xc
                     (device64 << 15) |   // device number A[19:15]
    8001466e:	8f5d                	or	a4,a4,a5
                     (reg64 << 2));       // register number A[11:2]
    80014670:	fd043783          	ld	a5,-48(s0)
    80014674:	078a                	slli	a5,a5,0x2
                     (function64 << 12) | // function number A[14:12]
    80014676:	8f5d                	or	a4,a4,a5
    uint64_t addr = (PCIE_ECAM_BASE |     // base 0x3000_0000
    80014678:	300007b7          	lui	a5,0x30000
    8001467c:	8fd9                	or	a5,a5,a4
    8001467e:	fcf43423          	sd	a5,-56(s0)
        
    if (addr < PCIE_ECAM_BASE || addr > PCIE_ECAM_END) {
    80014682:	fc843703          	ld	a4,-56(s0)
    80014686:	300007b7          	lui	a5,0x30000
    8001468a:	00f76863          	bltu	a4,a5,8001469a <pci_get_ecam+0x8c>
    8001468e:	fc843703          	ld	a4,-56(s0)
    80014692:	400007b7          	lui	a5,0x40000
    80014696:	00f76c63          	bltu	a4,a5,800146ae <pci_get_ecam+0xa0>
        fatalf("pci_get_ecam: PCI address (0x%08x) out of bounds!\n", addr);
    8001469a:	fc843583          	ld	a1,-56(s0)
    8001469e:	00013517          	auipc	a0,0x13
    800146a2:	a9250513          	addi	a0,a0,-1390 # 80027130 <pow10.0+0x2d0>
    800146a6:	097070ef          	jal	ra,8001bf3c <fatalf>
        return 0; 
    800146aa:	4781                	li	a5,0
    800146ac:	a019                	j	800146b2 <pci_get_ecam+0xa4>
    }
    return (struct pci_ecam *)addr;
    800146ae:	fc843783          	ld	a5,-56(s0)
}
    800146b2:	853e                	mv	a0,a5
    800146b4:	60a6                	ld	ra,72(sp)
    800146b6:	6406                	ld	s0,64(sp)
    800146b8:	6161                	addi	sp,sp,80
    800146ba:	8082                	ret

00000000800146bc <pci_enumerate_bus>:

static uint64_t next_mmio_address;
static uint8_t subordinate = 1;

static void pci_enumerate_bus() 
{
    800146bc:	1101                	addi	sp,sp,-32
    800146be:	ec06                	sd	ra,24(sp)
    800146c0:	e822                	sd	s0,16(sp)
    800146c2:	1000                	addi	s0,sp,32
    for (int bus = 0; bus < 256; bus++) {
    800146c4:	fe042623          	sw	zero,-20(s0)
    800146c8:	a0f9                	j	80014796 <pci_enumerate_bus+0xda>
        for (int device = 0; device < 32; device++) {
    800146ca:	fe042423          	sw	zero,-24(s0)
    800146ce:	a845                	j	8001477e <pci_enumerate_bus+0xc2>
            volatile struct pci_ecam *ecam = pci_get_ecam(bus, device, 0, 0);
    800146d0:	fec42783          	lw	a5,-20(s0)
    800146d4:	0ff7f793          	andi	a5,a5,255
    800146d8:	fe842703          	lw	a4,-24(s0)
    800146dc:	0ff77713          	andi	a4,a4,255
    800146e0:	4681                	li	a3,0
    800146e2:	4601                	li	a2,0
    800146e4:	85ba                	mv	a1,a4
    800146e6:	853e                	mv	a0,a5
    800146e8:	f27ff0ef          	jal	ra,8001460e <pci_get_ecam>
    800146ec:	fea43023          	sd	a0,-32(s0)

            if (!pci_device_exists(ecam->vendor_id)) {
    800146f0:	fe043783          	ld	a5,-32(s0)
    800146f4:	0007d783          	lhu	a5,0(a5) # 40000000 <i+0x3fffffe0>
    800146f8:	17c2                	slli	a5,a5,0x30
    800146fa:	93c1                	srli	a5,a5,0x30
    800146fc:	853e                	mv	a0,a5
    800146fe:	899ff0ef          	jal	ra,80013f96 <pci_device_exists>
    80014702:	87aa                	mv	a5,a0
    80014704:	0017c793          	xori	a5,a5,1
    80014708:	0ff7f793          	andi	a5,a5,255
    8001470c:	e3bd                	bnez	a5,80014772 <pci_enumerate_bus+0xb6>
                // debugf("pci_enumerate_bus: No device found at bus %d, device %d\n", bus, device);
                continue;
            }

            if ((ecam->header_type & 0x7F) == 1) {
    8001470e:	fe043783          	ld	a5,-32(s0)
    80014712:	00e7c783          	lbu	a5,14(a5)
    80014716:	0ff7f793          	andi	a5,a5,255
    8001471a:	2781                	sext.w	a5,a5
    8001471c:	07f7f793          	andi	a5,a5,127
    80014720:	2781                	sext.w	a5,a5
    80014722:	873e                	mv	a4,a5
    80014724:	4785                	li	a5,1
    80014726:	00f71c63          	bne	a4,a5,8001473e <pci_enumerate_bus+0x82>
                // debugf("pci_enumerate_bus: Found bridge at bus %d, device %d, \n", bus, device);
                pci_configure_bridge(ecam, bus);
    8001472a:	fec42783          	lw	a5,-20(s0)
    8001472e:	0ff7f793          	andi	a5,a5,255
    80014732:	85be                	mv	a1,a5
    80014734:	fe043503          	ld	a0,-32(s0)
    80014738:	07a000ef          	jal	ra,800147b2 <pci_configure_bridge>
    8001473c:	a825                	j	80014774 <pci_enumerate_bus+0xb8>
            } else if ((ecam->header_type & 0x7F) == 0) {
    8001473e:	fe043783          	ld	a5,-32(s0)
    80014742:	00e7c783          	lbu	a5,14(a5)
    80014746:	0ff7f793          	andi	a5,a5,255
    8001474a:	2781                	sext.w	a5,a5
    8001474c:	07f7f793          	andi	a5,a5,127
    80014750:	2781                	sext.w	a5,a5
    80014752:	e38d                	bnez	a5,80014774 <pci_enumerate_bus+0xb8>
                // debugf("pci_enumerate_bus: Found device at bus %d, device %d, \n", bus, device);
                pci_configure_device(ecam, bus, device);
    80014754:	fec42783          	lw	a5,-20(s0)
    80014758:	0ff7f793          	andi	a5,a5,255
    8001475c:	fe842703          	lw	a4,-24(s0)
    80014760:	0ff77713          	andi	a4,a4,255
    80014764:	863a                	mv	a2,a4
    80014766:	85be                	mv	a1,a5
    80014768:	fe043503          	ld	a0,-32(s0)
    8001476c:	190000ef          	jal	ra,800148fc <pci_configure_device>
    80014770:	a011                	j	80014774 <pci_enumerate_bus+0xb8>
                continue;
    80014772:	0001                	nop
        for (int device = 0; device < 32; device++) {
    80014774:	fe842783          	lw	a5,-24(s0)
    80014778:	2785                	addiw	a5,a5,1
    8001477a:	fef42423          	sw	a5,-24(s0)
    8001477e:	fe842783          	lw	a5,-24(s0)
    80014782:	0007871b          	sext.w	a4,a5
    80014786:	47fd                	li	a5,31
    80014788:	f4e7d4e3          	bge	a5,a4,800146d0 <pci_enumerate_bus+0x14>
    for (int bus = 0; bus < 256; bus++) {
    8001478c:	fec42783          	lw	a5,-20(s0)
    80014790:	2785                	addiw	a5,a5,1
    80014792:	fef42623          	sw	a5,-20(s0)
    80014796:	fec42783          	lw	a5,-20(s0)
    8001479a:	0007871b          	sext.w	a4,a5
    8001479e:	0ff00793          	li	a5,255
    800147a2:	f2e7d4e3          	bge	a5,a4,800146ca <pci_enumerate_bus+0xe>
                // PCIDevice *device = pci_find_saved_device(ecam->vendor_id, ecam->device_id);
                // print_vendor_specific_capabilities(device);
            }
        }
    }
}
    800147a6:	0001                	nop
    800147a8:	0001                	nop
    800147aa:	60e2                	ld	ra,24(sp)
    800147ac:	6442                	ld	s0,16(sp)
    800147ae:	6105                	addi	sp,sp,32
    800147b0:	8082                	ret

00000000800147b2 <pci_configure_bridge>:


static void pci_configure_bridge(volatile struct pci_ecam *bridge, uint8_t bus_no)
{
    800147b2:	7179                	addi	sp,sp,-48
    800147b4:	f422                	sd	s0,40(sp)
    800147b6:	1800                	addi	s0,sp,48
    800147b8:	fca43c23          	sd	a0,-40(s0)
    800147bc:	87ae                	mv	a5,a1
    800147be:	fcf40ba3          	sb	a5,-41(s0)
    next_mmio_address += 0x01000000;
    */

    // Make sure to set the bus master (2) and memory space (1) bits and clear
    // I/O space bit (0) before configuring the bridges
    bridge->command_reg |= COMMAND_REG_BUSMASTER;
    800147c2:	fd843783          	ld	a5,-40(s0)
    800147c6:	0047d783          	lhu	a5,4(a5)
    800147ca:	17c2                	slli	a5,a5,0x30
    800147cc:	93c1                	srli	a5,a5,0x30
    800147ce:	0047e793          	ori	a5,a5,4
    800147d2:	03079713          	slli	a4,a5,0x30
    800147d6:	9341                	srli	a4,a4,0x30
    800147d8:	fd843783          	ld	a5,-40(s0)
    800147dc:	00e79223          	sh	a4,4(a5)
    bridge->command_reg |= COMMAND_REG_MMIO;
    800147e0:	fd843783          	ld	a5,-40(s0)
    800147e4:	0047d783          	lhu	a5,4(a5)
    800147e8:	17c2                	slli	a5,a5,0x30
    800147ea:	93c1                	srli	a5,a5,0x30
    800147ec:	0027e793          	ori	a5,a5,2
    800147f0:	03079713          	slli	a4,a5,0x30
    800147f4:	9341                	srli	a4,a4,0x30
    800147f6:	fd843783          	ld	a5,-40(s0)
    800147fa:	00e79223          	sh	a4,4(a5)
    bridge->command_reg &= ~COMMAND_REG_PIO;
    800147fe:	fd843783          	ld	a5,-40(s0)
    80014802:	0047d783          	lhu	a5,4(a5)
    80014806:	17c2                	slli	a5,a5,0x30
    80014808:	93c1                	srli	a5,a5,0x30
    8001480a:	9bf9                	andi	a5,a5,-2
    8001480c:	03079713          	slli	a4,a5,0x30
    80014810:	9341                	srli	a4,a4,0x30
    80014812:	fd843783          	ld	a5,-40(s0)
    80014816:	00e79223          	sh	a4,4(a5)

    uint64_t addrst = 0x40000000 | ((uint64_t)subordinate << 20);
    8001481a:	00015797          	auipc	a5,0x15
    8001481e:	7e678793          	addi	a5,a5,2022 # 8002a000 <subordinate>
    80014822:	0007c783          	lbu	a5,0(a5)
    80014826:	01479713          	slli	a4,a5,0x14
    8001482a:	400007b7          	lui	a5,0x40000
    8001482e:	8fd9                	or	a5,a5,a4
    80014830:	fef43423          	sd	a5,-24(s0)
    uint64_t addred = addrst + ((1 << 20) - 1);
    80014834:	fe843703          	ld	a4,-24(s0)
    80014838:	001007b7          	lui	a5,0x100
    8001483c:	17fd                	addi	a5,a5,-1
    8001483e:	97ba                	add	a5,a5,a4
    80014840:	fef43023          	sd	a5,-32(s0)
    next_mmio_address = addrst;
    80014844:	00011797          	auipc	a5,0x11
    80014848:	82478793          	addi	a5,a5,-2012 # 80025068 <next_mmio_address>
    8001484c:	fe843703          	ld	a4,-24(s0)
    80014850:	e398                	sd	a4,0(a5)
    
    bridge->type1.memory_base = addrst >> 16;
    80014852:	fe843783          	ld	a5,-24(s0)
    80014856:	83c1                	srli	a5,a5,0x10
    80014858:	03079713          	slli	a4,a5,0x30
    8001485c:	9341                	srli	a4,a4,0x30
    8001485e:	fd843783          	ld	a5,-40(s0)
    80014862:	02e79023          	sh	a4,32(a5)
    bridge->type1.memory_limit = addred >> 16;
    80014866:	fe043783          	ld	a5,-32(s0)
    8001486a:	83c1                	srli	a5,a5,0x10
    8001486c:	03079713          	slli	a4,a5,0x30
    80014870:	9341                	srli	a4,a4,0x30
    80014872:	fd843783          	ld	a5,-40(s0)
    80014876:	02e79123          	sh	a4,34(a5)
    bridge->type1.prefetch_memory_base = addrst >> 16;
    8001487a:	fe843783          	ld	a5,-24(s0)
    8001487e:	83c1                	srli	a5,a5,0x10
    80014880:	03079713          	slli	a4,a5,0x30
    80014884:	9341                	srli	a4,a4,0x30
    80014886:	fd843783          	ld	a5,-40(s0)
    8001488a:	02e79223          	sh	a4,36(a5)
    bridge->type1.prefetch_memory_limit = addred >> 16;
    8001488e:	fe043783          	ld	a5,-32(s0)
    80014892:	83c1                	srli	a5,a5,0x10
    80014894:	03079713          	slli	a4,a5,0x30
    80014898:	9341                	srli	a4,a4,0x30
    8001489a:	fd843783          	ld	a5,-40(s0)
    8001489e:	02e79323          	sh	a4,38(a5)
    bridge->type1.primary_bus_no = bus_no;
    800148a2:	fd843783          	ld	a5,-40(s0)
    800148a6:	fd744703          	lbu	a4,-41(s0)
    800148aa:	00e78c23          	sb	a4,24(a5)
    bridge->type1.secondary_bus_no = subordinate;
    800148ae:	00015797          	auipc	a5,0x15
    800148b2:	75278793          	addi	a5,a5,1874 # 8002a000 <subordinate>
    800148b6:	0007c703          	lbu	a4,0(a5)
    800148ba:	fd843783          	ld	a5,-40(s0)
    800148be:	00e78ca3          	sb	a4,25(a5)
    bridge->type1.subordinate_bus_no = subordinate;
    800148c2:	00015797          	auipc	a5,0x15
    800148c6:	73e78793          	addi	a5,a5,1854 # 8002a000 <subordinate>
    800148ca:	0007c703          	lbu	a4,0(a5)
    800148ce:	fd843783          	ld	a5,-40(s0)
    800148d2:	00e78d23          	sb	a4,26(a5)
    subordinate += 1;
    800148d6:	00015797          	auipc	a5,0x15
    800148da:	72a78793          	addi	a5,a5,1834 # 8002a000 <subordinate>
    800148de:	0007c783          	lbu	a5,0(a5)
    800148e2:	2785                	addiw	a5,a5,1
    800148e4:	0ff7f713          	andi	a4,a5,255
    800148e8:	00015797          	auipc	a5,0x15
    800148ec:	71878793          	addi	a5,a5,1816 # 8002a000 <subordinate>
    800148f0:	00e78023          	sb	a4,0(a5)
}
    800148f4:	0001                	nop
    800148f6:	7422                	ld	s0,40(sp)
    800148f8:	6145                	addi	sp,sp,48
    800148fa:	8082                	ret

00000000800148fc <pci_configure_device>:

static void pci_configure_device(volatile struct pci_ecam *device, uint8_t bus_no, uint8_t device_no)
{
    800148fc:	7171                	addi	sp,sp,-176
    800148fe:	f506                	sd	ra,168(sp)
    80014900:	f122                	sd	s0,160(sp)
    80014902:	1900                	addi	s0,sp,176
    80014904:	f8a43c23          	sd	a0,-104(s0)
    80014908:	87ae                	mv	a5,a1
    8001490a:	8732                	mv	a4,a2
    8001490c:	f8f40ba3          	sb	a5,-105(s0)
    80014910:	87ba                	mv	a5,a4
    80014912:	f8f40b23          	sb	a5,-106(s0)
    // vector_push(irq_pci_devices[vector_idx], (uint64_t)device);

    debugf("pci_configure_device: At bus %d, device %d = (%p)\n", bus_no, device_no, device);

    // Disable the device before modifying the BAR
    device->command_reg &= ~COMMAND_REG_MMIO; // Clear memory space bit
    80014916:	f9843783          	ld	a5,-104(s0)
    8001491a:	0047d783          	lhu	a5,4(a5)
    8001491e:	17c2                	slli	a5,a5,0x30
    80014920:	93c1                	srli	a5,a5,0x30
    80014922:	9bf5                	andi	a5,a5,-3
    80014924:	03079713          	slli	a4,a5,0x30
    80014928:	9341                	srli	a4,a4,0x30
    8001492a:	f9843783          	ld	a5,-104(s0)
    8001492e:	00e79223          	sh	a4,4(a5)
    device->command_reg &= ~COMMAND_REG_PIO; // Clear I/O space bit
    80014932:	f9843783          	ld	a5,-104(s0)
    80014936:	0047d783          	lhu	a5,4(a5)
    8001493a:	17c2                	slli	a5,a5,0x30
    8001493c:	93c1                	srli	a5,a5,0x30
    8001493e:	9bf9                	andi	a5,a5,-2
    80014940:	03079713          	slli	a4,a5,0x30
    80014944:	9341                	srli	a4,a4,0x30
    80014946:	f9843783          	ld	a5,-104(s0)
    8001494a:	00e79223          	sh	a4,4(a5)

    uint32_t addr = PCIE_MMIO_BASE + (bus_no << 20) + (device_no << 16);
    8001494e:	f9744783          	lbu	a5,-105(s0)
    80014952:	2781                	sext.w	a5,a5
    80014954:	0147979b          	slliw	a5,a5,0x14
    80014958:	0007871b          	sext.w	a4,a5
    8001495c:	400007b7          	lui	a5,0x40000
    80014960:	9fb9                	addw	a5,a5,a4
    80014962:	0007871b          	sext.w	a4,a5
    80014966:	f9644783          	lbu	a5,-106(s0)
    8001496a:	2781                	sext.w	a5,a5
    8001496c:	0107979b          	slliw	a5,a5,0x10
    80014970:	2781                	sext.w	a5,a5
    80014972:	9fb9                	addw	a5,a5,a4
    80014974:	2781                	sext.w	a5,a5
    80014976:	fef42623          	sw	a5,-20(s0)
    PCIDevice pcidev;
    pcidev.ecam_header = device;
    8001497a:	f9843783          	ld	a5,-104(s0)
    8001497e:	faf43023          	sd	a5,-96(s0)
    
    for (int i = 0; i < 6; i++) {
    80014982:	fe042423          	sw	zero,-24(s0)
    80014986:	aa5d                	j	80014b3c <pci_configure_device+0x240>
        device->type0.bar[i] = -1U;
    80014988:	f9843703          	ld	a4,-104(s0)
    8001498c:	fe842783          	lw	a5,-24(s0)
    80014990:	0791                	addi	a5,a5,4
    80014992:	078a                	slli	a5,a5,0x2
    80014994:	97ba                	add	a5,a5,a4
    80014996:	577d                	li	a4,-1
    80014998:	c398                	sw	a4,0(a5)
        pcidev.bars[i] = NULL;
    8001499a:	fe842783          	lw	a5,-24(s0)
    8001499e:	078e                	slli	a5,a5,0x3
    800149a0:	ff040713          	addi	a4,s0,-16
    800149a4:	97ba                	add	a5,a5,a4
    800149a6:	fa07bc23          	sd	zero,-72(a5) # 3fffffb8 <i+0x3fffff98>
        
        // BAR not writable
        if (device->type0.bar[i] == 0) {
    800149aa:	f9843703          	ld	a4,-104(s0)
    800149ae:	fe842783          	lw	a5,-24(s0)
    800149b2:	0791                	addi	a5,a5,4
    800149b4:	078a                	slli	a5,a5,0x2
    800149b6:	97ba                	add	a5,a5,a4
    800149b8:	439c                	lw	a5,0(a5)
    800149ba:	2781                	sext.w	a5,a5
    800149bc:	16078a63          	beqz	a5,80014b30 <pci_configure_device+0x234>
            continue;
        }

        uint64_t size;

        if ((device->type0.bar[i] & 0x6) == 0x4) {
    800149c0:	f9843703          	ld	a4,-104(s0)
    800149c4:	fe842783          	lw	a5,-24(s0)
    800149c8:	0791                	addi	a5,a5,4
    800149ca:	078a                	slli	a5,a5,0x2
    800149cc:	97ba                	add	a5,a5,a4
    800149ce:	439c                	lw	a5,0(a5)
    800149d0:	2781                	sext.w	a5,a5
    800149d2:	8b99                	andi	a5,a5,6
    800149d4:	2781                	sext.w	a5,a5
    800149d6:	873e                	mv	a4,a5
    800149d8:	4791                	li	a5,4
    800149da:	0ef71763          	bne	a4,a5,80014ac8 <pci_configure_device+0x1cc>
            debugf("  BAR[%d] is 64-bit\n", i);
            device->type0.bar[i+1] = -1U;
    800149de:	fe842783          	lw	a5,-24(s0)
    800149e2:	2785                	addiw	a5,a5,1
    800149e4:	2781                	sext.w	a5,a5
    800149e6:	f9843703          	ld	a4,-104(s0)
    800149ea:	0791                	addi	a5,a5,4
    800149ec:	078a                	slli	a5,a5,0x2
    800149ee:	97ba                	add	a5,a5,a4
    800149f0:	577d                	li	a4,-1
    800149f2:	c398                	sw	a4,0(a5)
            uint64_t bar_value = (uint64_t) device->type0.bar[i+1] << 32 | device->type0.bar[i];
    800149f4:	fe842783          	lw	a5,-24(s0)
    800149f8:	2785                	addiw	a5,a5,1
    800149fa:	2781                	sext.w	a5,a5
    800149fc:	f9843703          	ld	a4,-104(s0)
    80014a00:	0791                	addi	a5,a5,4
    80014a02:	078a                	slli	a5,a5,0x2
    80014a04:	97ba                	add	a5,a5,a4
    80014a06:	439c                	lw	a5,0(a5)
    80014a08:	2781                	sext.w	a5,a5
    80014a0a:	1782                	slli	a5,a5,0x20
    80014a0c:	9381                	srli	a5,a5,0x20
    80014a0e:	02079713          	slli	a4,a5,0x20
    80014a12:	f9843683          	ld	a3,-104(s0)
    80014a16:	fe842783          	lw	a5,-24(s0)
    80014a1a:	0791                	addi	a5,a5,4
    80014a1c:	078a                	slli	a5,a5,0x2
    80014a1e:	97b6                	add	a5,a5,a3
    80014a20:	439c                	lw	a5,0(a5)
    80014a22:	2781                	sext.w	a5,a5
    80014a24:	1782                	slli	a5,a5,0x20
    80014a26:	9381                	srli	a5,a5,0x20
    80014a28:	8fd9                	or	a5,a5,a4
    80014a2a:	fcf43c23          	sd	a5,-40(s0)
            size = ~(bar_value & ~0xF) + 1;
    80014a2e:	fd843783          	ld	a5,-40(s0)
    80014a32:	9bc1                	andi	a5,a5,-16
    80014a34:	40f007b3          	neg	a5,a5
    80014a38:	fef43023          	sd	a5,-32(s0)
            addr += size;
    80014a3c:	fe043783          	ld	a5,-32(s0)
    80014a40:	2781                	sext.w	a5,a5
    80014a42:	fec42703          	lw	a4,-20(s0)
    80014a46:	9fb9                	addw	a5,a5,a4
    80014a48:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    80014a4c:	f9843703          	ld	a4,-104(s0)
    80014a50:	fe842783          	lw	a5,-24(s0)
    80014a54:	0791                	addi	a5,a5,4
    80014a56:	078a                	slli	a5,a5,0x2
    80014a58:	97ba                	add	a5,a5,a4
    80014a5a:	fec42703          	lw	a4,-20(s0)
    80014a5e:	c398                	sw	a4,0(a5)
            device->type0.bar[i+1] = 0;
    80014a60:	fe842783          	lw	a5,-24(s0)
    80014a64:	2785                	addiw	a5,a5,1
    80014a66:	2781                	sext.w	a5,a5
    80014a68:	f9843703          	ld	a4,-104(s0)
    80014a6c:	0791                	addi	a5,a5,4
    80014a6e:	078a                	slli	a5,a5,0x2
    80014a70:	97ba                	add	a5,a5,a4
    80014a72:	0007a023          	sw	zero,0(a5)
            pcidev.bars[i] = (volatile void*)(uint64_t)(device->type0.bar[i] & ~0xf);
    80014a76:	f9843703          	ld	a4,-104(s0)
    80014a7a:	fe842783          	lw	a5,-24(s0)
    80014a7e:	0791                	addi	a5,a5,4
    80014a80:	078a                	slli	a5,a5,0x2
    80014a82:	97ba                	add	a5,a5,a4
    80014a84:	439c                	lw	a5,0(a5)
    80014a86:	2781                	sext.w	a5,a5
    80014a88:	02079713          	slli	a4,a5,0x20
    80014a8c:	9301                	srli	a4,a4,0x20
    80014a8e:	4785                	li	a5,1
    80014a90:	1782                	slli	a5,a5,0x20
    80014a92:	17c1                	addi	a5,a5,-16
    80014a94:	8ff9                	and	a5,a5,a4
    80014a96:	873e                	mv	a4,a5
    80014a98:	fe842783          	lw	a5,-24(s0)
    80014a9c:	078e                	slli	a5,a5,0x3
    80014a9e:	ff040693          	addi	a3,s0,-16
    80014aa2:	97b6                	add	a5,a5,a3
    80014aa4:	fae7bc23          	sd	a4,-72(a5)
            pcidev.bars[i+1] = 0;
    80014aa8:	fe842783          	lw	a5,-24(s0)
    80014aac:	2785                	addiw	a5,a5,1
    80014aae:	2781                	sext.w	a5,a5
    80014ab0:	078e                	slli	a5,a5,0x3
    80014ab2:	ff040713          	addi	a4,s0,-16
    80014ab6:	97ba                	add	a5,a5,a4
    80014ab8:	fa07bc23          	sd	zero,-72(a5)
            // pcidev.bars[i+1] = 0;
            debugf("    device->type0.bar[i] == 0x%08x\n", device->type0.bar[i]);
            debugf("    device->type0.bar[i+1] == 0x%08x\n", device->type0.bar[i+1]);
            debugf("    bar_value == 0x%016llx\n", bar_value);
            debugf("    size == %016llx\n", size);
            ++i;
    80014abc:	fe842783          	lw	a5,-24(s0)
    80014ac0:	2785                	addiw	a5,a5,1
    80014ac2:	fef42423          	sw	a5,-24(s0)
    80014ac6:	a0b5                	j	80014b32 <pci_configure_device+0x236>
        } else {
            debugf("  BAR[%d] is 32-bit\n", i);
            size = ~(device->type0.bar[i] & ~0xF) + 1;
    80014ac8:	f9843703          	ld	a4,-104(s0)
    80014acc:	fe842783          	lw	a5,-24(s0)
    80014ad0:	0791                	addi	a5,a5,4
    80014ad2:	078a                	slli	a5,a5,0x2
    80014ad4:	97ba                	add	a5,a5,a4
    80014ad6:	439c                	lw	a5,0(a5)
    80014ad8:	2781                	sext.w	a5,a5
    80014ada:	9bc1                	andi	a5,a5,-16
    80014adc:	2781                	sext.w	a5,a5
    80014ade:	40f007bb          	negw	a5,a5
    80014ae2:	2781                	sext.w	a5,a5
    80014ae4:	1782                	slli	a5,a5,0x20
    80014ae6:	9381                	srli	a5,a5,0x20
    80014ae8:	fef43023          	sd	a5,-32(s0)
            debugf("    size == %016llx\n", size);
            addr += size;
    80014aec:	fe043783          	ld	a5,-32(s0)
    80014af0:	2781                	sext.w	a5,a5
    80014af2:	fec42703          	lw	a4,-20(s0)
    80014af6:	9fb9                	addw	a5,a5,a4
    80014af8:	fef42623          	sw	a5,-20(s0)
            device->type0.bar[i] = addr;
    80014afc:	f9843703          	ld	a4,-104(s0)
    80014b00:	fe842783          	lw	a5,-24(s0)
    80014b04:	0791                	addi	a5,a5,4
    80014b06:	078a                	slli	a5,a5,0x2
    80014b08:	97ba                	add	a5,a5,a4
    80014b0a:	fec42703          	lw	a4,-20(s0)
    80014b0e:	c398                	sw	a4,0(a5)
            pcidev.bars[i] = (volatile void*)(uint64_t)(addr & ~0xf);
    80014b10:	fec46703          	lwu	a4,-20(s0)
    80014b14:	4785                	li	a5,1
    80014b16:	1782                	slli	a5,a5,0x20
    80014b18:	17c1                	addi	a5,a5,-16
    80014b1a:	8ff9                	and	a5,a5,a4
    80014b1c:	873e                	mv	a4,a5
    80014b1e:	fe842783          	lw	a5,-24(s0)
    80014b22:	078e                	slli	a5,a5,0x3
    80014b24:	ff040693          	addi	a3,s0,-16
    80014b28:	97b6                	add	a5,a5,a3
    80014b2a:	fae7bc23          	sd	a4,-72(a5)
    80014b2e:	a011                	j	80014b32 <pci_configure_device+0x236>
            continue;
    80014b30:	0001                	nop
    for (int i = 0; i < 6; i++) {
    80014b32:	fe842783          	lw	a5,-24(s0)
    80014b36:	2785                	addiw	a5,a5,1
    80014b38:	fef42423          	sw	a5,-24(s0)
    80014b3c:	fe842783          	lw	a5,-24(s0)
    80014b40:	0007871b          	sext.w	a4,a5
    80014b44:	4795                	li	a5,5
    80014b46:	e4e7d1e3          	bge	a5,a4,80014988 <pci_configure_device+0x8c>
        }
    }

    // Re-enable the device after modifying the BAR
    device->command_reg |= COMMAND_REG_MMIO;
    80014b4a:	f9843783          	ld	a5,-104(s0)
    80014b4e:	0047d783          	lhu	a5,4(a5)
    80014b52:	17c2                	slli	a5,a5,0x30
    80014b54:	93c1                	srli	a5,a5,0x30
    80014b56:	0027e793          	ori	a5,a5,2
    80014b5a:	03079713          	slli	a4,a5,0x30
    80014b5e:	9341                	srli	a4,a4,0x30
    80014b60:	f9843783          	ld	a5,-104(s0)
    80014b64:	00e79223          	sh	a4,4(a5)
    pcidev.ecam_header = device;
    80014b68:	f9843783          	ld	a5,-104(s0)
    80014b6c:	faf43023          	sd	a5,-96(s0)
    pci_save_device(pcidev);
    80014b70:	fa043803          	ld	a6,-96(s0)
    80014b74:	fa843503          	ld	a0,-88(s0)
    80014b78:	fb043583          	ld	a1,-80(s0)
    80014b7c:	fb843603          	ld	a2,-72(s0)
    80014b80:	fc043683          	ld	a3,-64(s0)
    80014b84:	fc843703          	ld	a4,-56(s0)
    80014b88:	fd043783          	ld	a5,-48(s0)
    80014b8c:	f5043823          	sd	a6,-176(s0)
    80014b90:	f4a43c23          	sd	a0,-168(s0)
    80014b94:	f6b43023          	sd	a1,-160(s0)
    80014b98:	f6c43423          	sd	a2,-152(s0)
    80014b9c:	f6d43823          	sd	a3,-144(s0)
    80014ba0:	f6e43c23          	sd	a4,-136(s0)
    80014ba4:	f8f43023          	sd	a5,-128(s0)
    80014ba8:	f5040793          	addi	a5,s0,-176
    80014bac:	853e                	mv	a0,a5
    80014bae:	f0cff0ef          	jal	ra,800142ba <pci_save_device>
}
    80014bb2:	0001                	nop
    80014bb4:	70aa                	ld	ra,168(sp)
    80014bb6:	740a                	ld	s0,160(sp)
    80014bb8:	614d                	addi	sp,sp,176
    80014bba:	8082                	ret

0000000080014bbc <print_vendor_specific_capabilities>:

void print_vendor_specific_capabilities(PCIDevice *pcidevice)
{
    80014bbc:	7179                	addi	sp,sp,-48
    80014bbe:	f406                	sd	ra,40(sp)
    80014bc0:	f022                	sd	s0,32(sp)
    80014bc2:	1800                	addi	s0,sp,48
    80014bc4:	fca43c23          	sd	a0,-40(s0)
    if (!pci_is_virtio_device(pcidevice)) return;
    80014bc8:	fd843503          	ld	a0,-40(s0)
    80014bcc:	c02ff0ef          	jal	ra,80013fce <pci_is_virtio_device>
    80014bd0:	87aa                	mv	a5,a0
    80014bd2:	0017c793          	xori	a5,a5,1
    80014bd6:	0ff7f793          	andi	a5,a5,255
    80014bda:	ef89                	bnez	a5,80014bf4 <print_vendor_specific_capabilities+0x38>
    volatile struct pci_ecam *header = pcidevice->ecam_header;
    80014bdc:	fd843783          	ld	a5,-40(s0)
    80014be0:	639c                	ld	a5,0(a5)
    80014be2:	fef43423          	sd	a5,-24(s0)

    uint8_t cap_pointer = header->type0.capes_pointer;
    80014be6:	fe843783          	ld	a5,-24(s0)
    80014bea:	0347c783          	lbu	a5,52(a5)
    80014bee:	fef403a3          	sb	a5,-25(s0)
    80014bf2:	a011                	j	80014bf6 <print_vendor_specific_capabilities+0x3a>
    if (!pci_is_virtio_device(pcidevice)) return;
    80014bf4:	0001                	nop
        }

        cap_pointer = cape->next;  
    }
    */
}
    80014bf6:	70a2                	ld	ra,40(sp)
    80014bf8:	7402                	ld	s0,32(sp)
    80014bfa:	6145                	addi	sp,sp,48
    80014bfc:	8082                	ret

0000000080014bfe <pci_init>:

void pci_init(void)
{
    80014bfe:	1101                	addi	sp,sp,-32
    80014c00:	ec06                	sd	ra,24(sp)
    80014c02:	e822                	sd	s0,16(sp)
    80014c04:	1000                	addi	s0,sp,32
    all_pci_devices = vector_new();
    80014c06:	0880e0ef          	jal	ra,80022c8e <vector_new>
    80014c0a:	872a                	mv	a4,a0
    80014c0c:	00010797          	auipc	a5,0x10
    80014c10:	43478793          	addi	a5,a5,1076 # 80025040 <all_pci_devices>
    80014c14:	e398                	sd	a4,0(a5)
    for (int i=0; i<4; i++) {
    80014c16:	fe042623          	sw	zero,-20(s0)
    80014c1a:	a015                	j	80014c3e <pci_init+0x40>
        irq_pci_devices[i] = vector_new();
    80014c1c:	0720e0ef          	jal	ra,80022c8e <vector_new>
    80014c20:	86aa                	mv	a3,a0
    80014c22:	00010717          	auipc	a4,0x10
    80014c26:	42670713          	addi	a4,a4,1062 # 80025048 <irq_pci_devices>
    80014c2a:	fec42783          	lw	a5,-20(s0)
    80014c2e:	078e                	slli	a5,a5,0x3
    80014c30:	97ba                	add	a5,a5,a4
    80014c32:	e394                	sd	a3,0(a5)
    for (int i=0; i<4; i++) {
    80014c34:	fec42783          	lw	a5,-20(s0)
    80014c38:	2785                	addiw	a5,a5,1
    80014c3a:	fef42623          	sw	a5,-20(s0)
    80014c3e:	fec42783          	lw	a5,-20(s0)
    80014c42:	0007871b          	sext.w	a4,a5
    80014c46:	478d                	li	a5,3
    80014c48:	fce7dae3          	bge	a5,a4,80014c1c <pci_init+0x1e>
    }

    pci_enumerate_bus();
    80014c4c:	a71ff0ef          	jal	ra,800146bc <pci_enumerate_bus>
    debugf("PCI devices: %d\n", pci_count_saved_devices());
    debugf("PCI devices sharing IRQ 32: %d\n", pci_count_irq_listeners(32));
    debugf("PCI devices sharing IRQ 33: %d\n", pci_count_irq_listeners(33));
    debugf("PCI devices sharing IRQ 34: %d\n", pci_count_irq_listeners(34));
    debugf("PCI devices sharing IRQ 35: %d\n", pci_count_irq_listeners(35));
}
    80014c50:	0001                	nop
    80014c52:	60e2                	ld	ra,24(sp)
    80014c54:	6442                	ld	s0,16(sp)
    80014c56:	6105                	addi	sp,sp,32
    80014c58:	8082                	ret

0000000080014c5a <pci_dispatch_irq>:
/**
 * @brief Dispatch an interrupt to the PCI subsystem
 * @param irq - the IRQ number that interrupted
 */
void pci_dispatch_irq(int irq)
{
    80014c5a:	7129                	addi	sp,sp,-320
    80014c5c:	fe06                	sd	ra,312(sp)
    80014c5e:	fa22                	sd	s0,304(sp)
    80014c60:	0280                	addi	s0,sp,320
    80014c62:	87aa                	mv	a5,a0
    80014c64:	ecf42623          	sw	a5,-308(s0)
    // device changed its configuration, and that was the reason
    // the interrupt occurred.

    // IRQ#=32+(bus+slot)mod4
    // uint32_t vector_idx = irq - 32;
    PCIDevice *pcidevice = pci_find_device_by_irq(irq);
    80014c68:	ecc42783          	lw	a5,-308(s0)
    80014c6c:	0ff7f793          	andi	a5,a5,255
    80014c70:	853e                	mv	a0,a5
    80014c72:	f20ff0ef          	jal	ra,80014392 <pci_find_device_by_irq>
    80014c76:	fea43423          	sd	a0,-24(s0)
    if (pcidevice == NULL) {
    80014c7a:	fe843783          	ld	a5,-24(s0)
    80014c7e:	eb99                	bnez	a5,80014c94 <pci_dispatch_irq+0x3a>
        warnf("No PCI device found with IRQ %d\n", irq);
    80014c80:	ecc42783          	lw	a5,-308(s0)
    80014c84:	85be                	mv	a1,a5
    80014c86:	00012517          	auipc	a0,0x12
    80014c8a:	4e250513          	addi	a0,a0,1250 # 80027168 <pow10.0+0x308>
    80014c8e:	1aa070ef          	jal	ra,8001be38 <warnf>
        return;
    80014c92:	a0d5                	j	80014d76 <pci_dispatch_irq+0x11c>
    }
    debugf("PCI device with IRQ %d: 0x%04x\n", irq, pcidevice->ecam_header->device_id);
    // Is this a virtio device?
    if (pci_is_virtio_device(pcidevice)) { 
    80014c94:	fe843503          	ld	a0,-24(s0)
    80014c98:	b36ff0ef          	jal	ra,80013fce <pci_is_virtio_device>
    80014c9c:	87aa                	mv	a5,a0
    80014c9e:	0c078c63          	beqz	a5,80014d76 <pci_dispatch_irq+0x11c>
        // Access through ecam_header
        VirtioDevice *virtdevice = virtio_from_pci_device(pcidevice);
    80014ca2:	fe843503          	ld	a0,-24(s0)
    80014ca6:	19a080ef          	jal	ra,8001ce40 <virtio_from_pci_device>
    80014caa:	fea43023          	sd	a0,-32(s0)
        debugf("Virtio device! %p\n", virtdevice->pcidev->ecam_header);

        if (virtio_is_rng_device(virtdevice)) {
    80014cae:	fe043503          	ld	a0,-32(s0)
    80014cb2:	67f070ef          	jal	ra,8001cb30 <virtio_is_rng_device>
    80014cb6:	87aa                	mv	a5,a0
    80014cb8:	cb8d                	beqz	a5,80014cea <pci_dispatch_irq+0x90>
            debugf("RNG sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 1, true);
    80014cba:	ed840793          	addi	a5,s0,-296
    80014cbe:	4705                	li	a4,1
    80014cc0:	4685                	li	a3,1
    80014cc2:	863e                	mv	a2,a5
    80014cc4:	4581                	li	a1,0
    80014cc6:	fe043503          	ld	a0,-32(s0)
    80014cca:	24f080ef          	jal	ra,8001d718 <virtio_receive_descriptor_chain>
    80014cce:	87aa                	mv	a5,a0
    80014cd0:	fcf41d23          	sh	a5,-38(s0)

            virtio_handle_interrupt(virtdevice, descriptors, received);
    80014cd4:	fda45703          	lhu	a4,-38(s0)
    80014cd8:	ed840793          	addi	a5,s0,-296
    80014cdc:	863a                	mv	a2,a4
    80014cde:	85be                	mv	a1,a5
    80014ce0:	fe043503          	ld	a0,-32(s0)
    80014ce4:	3ff070ef          	jal	ra,8001c8e2 <virtio_handle_interrupt>
    80014ce8:	a079                	j	80014d76 <pci_dispatch_irq+0x11c>
            debugf("Received %d descriptors\n", received);
        }

        else if (virtio_is_block_device(virtdevice)) {
    80014cea:	fe043503          	ld	a0,-32(s0)
    80014cee:	679070ef          	jal	ra,8001cb66 <virtio_is_block_device>
    80014cf2:	87aa                	mv	a5,a0
    80014cf4:	cb8d                	beqz	a5,80014d26 <pci_dispatch_irq+0xcc>
            debugf("Block device sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 3, true);
    80014cf6:	ed840793          	addi	a5,s0,-296
    80014cfa:	4705                	li	a4,1
    80014cfc:	468d                	li	a3,3
    80014cfe:	863e                	mv	a2,a5
    80014d00:	4581                	li	a1,0
    80014d02:	fe043503          	ld	a0,-32(s0)
    80014d06:	213080ef          	jal	ra,8001d718 <virtio_receive_descriptor_chain>
    80014d0a:	87aa                	mv	a5,a0
    80014d0c:	fcf41e23          	sh	a5,-36(s0)
            virtio_handle_interrupt(virtdevice, descriptors, received);
    80014d10:	fdc45703          	lhu	a4,-36(s0)
    80014d14:	ed840793          	addi	a5,s0,-296
    80014d18:	863a                	mv	a2,a4
    80014d1a:	85be                	mv	a1,a5
    80014d1c:	fe043503          	ld	a0,-32(s0)
    80014d20:	3c3070ef          	jal	ra,8001c8e2 <virtio_handle_interrupt>
    80014d24:	a889                	j	80014d76 <pci_dispatch_irq+0x11c>
            debugf("Received %d descriptors\n", received);
        }

        else if (virtio_is_input_device(virtdevice)) {
    80014d26:	fe043503          	ld	a0,-32(s0)
    80014d2a:	673070ef          	jal	ra,8001cb9c <virtio_is_input_device>
    80014d2e:	87aa                	mv	a5,a0
    80014d30:	c791                	beqz	a5,80014d3c <pci_dispatch_irq+0xe2>
            debugf("input device sent interrupt!\n");
            input_device_isr(virtdevice);
    80014d32:	fe043503          	ld	a0,-32(s0)
    80014d36:	724090ef          	jal	ra,8001e45a <input_device_isr>
    80014d3a:	a835                	j	80014d76 <pci_dispatch_irq+0x11c>
        //     VirtioDescriptor descriptors[16];
        //     uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 16, true);
        //     uint16_t received2 = virtio_receive_descriptor_chain(virtdevice, 1, descriptors, 16, true);
        //     debugf("Received %d descriptors\n", received);
        // }
        else if (virtio_is_gpu_device(virtdevice)) {
    80014d3c:	fe043503          	ld	a0,-32(s0)
    80014d40:	693070ef          	jal	ra,8001cbd2 <virtio_is_gpu_device>
    80014d44:	87aa                	mv	a5,a0
    80014d46:	cb85                	beqz	a5,80014d76 <pci_dispatch_irq+0x11c>
            debugf("GPU device sent interrupt!\n");
            VirtioDescriptor descriptors[16];
            uint16_t received = virtio_receive_descriptor_chain(virtdevice, 0, descriptors, 3, true);
    80014d48:	ed840793          	addi	a5,s0,-296
    80014d4c:	4705                	li	a4,1
    80014d4e:	468d                	li	a3,3
    80014d50:	863e                	mv	a2,a5
    80014d52:	4581                	li	a1,0
    80014d54:	fe043503          	ld	a0,-32(s0)
    80014d58:	1c1080ef          	jal	ra,8001d718 <virtio_receive_descriptor_chain>
    80014d5c:	87aa                	mv	a5,a0
    80014d5e:	fcf41f23          	sh	a5,-34(s0)
            debugf("Received %d descriptors\n", received);
            virtio_handle_interrupt(virtdevice, descriptors, received);
    80014d62:	fde45703          	lhu	a4,-34(s0)
    80014d66:	ed840793          	addi	a5,s0,-296
    80014d6a:	863a                	mv	a2,a4
    80014d6c:	85be                	mv	a1,a5
    80014d6e:	fe043503          	ld	a0,-32(s0)
    80014d72:	371070ef          	jal	ra,8001c8e2 <virtio_handle_interrupt>
            
        }
    }

    debugf("Leaving dispatch IRQ\n");
}
    80014d76:	70f2                	ld	ra,312(sp)
    80014d78:	7452                	ld	s0,304(sp)
    80014d7a:	6131                	addi	sp,sp,320
    80014d7c:	8082                	ret

0000000080014d7e <insert_block>:
 * into free list, sorted by addr.
 * If disabled, add block has new head of
 * the free list.
 */
static void insert_block(Block *block)
{
    80014d7e:	7179                	addi	sp,sp,-48
    80014d80:	f422                	sd	s0,40(sp)
    80014d82:	1800                	addi	s0,sp,48
    80014d84:	fca43c23          	sd	a0,-40(s0)
    Block *ptr  = heap->free;
    80014d88:	00010797          	auipc	a5,0x10
    80014d8c:	2e878793          	addi	a5,a5,744 # 80025070 <heap>
    80014d90:	639c                	ld	a5,0(a5)
    80014d92:	639c                	ld	a5,0(a5)
    80014d94:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    80014d98:	fe043023          	sd	zero,-32(s0)
    while (ptr != NULL) {
    80014d9c:	a01d                	j	80014dc2 <insert_block+0x44>
        if ((size_t)block->addr <= (size_t)ptr->addr) {
    80014d9e:	fd843783          	ld	a5,-40(s0)
    80014da2:	639c                	ld	a5,0(a5)
    80014da4:	873e                	mv	a4,a5
    80014da6:	fe843783          	ld	a5,-24(s0)
    80014daa:	639c                	ld	a5,0(a5)
    80014dac:	00e7ff63          	bgeu	a5,a4,80014dca <insert_block+0x4c>
            break;
        }
        prev = ptr;
    80014db0:	fe843783          	ld	a5,-24(s0)
    80014db4:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    80014db8:	fe843783          	ld	a5,-24(s0)
    80014dbc:	679c                	ld	a5,8(a5)
    80014dbe:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80014dc2:	fe843783          	ld	a5,-24(s0)
    80014dc6:	ffe1                	bnez	a5,80014d9e <insert_block+0x20>
    80014dc8:	a011                	j	80014dcc <insert_block+0x4e>
            break;
    80014dca:	0001                	nop
    }
    if (prev != NULL) {
    80014dcc:	fe043783          	ld	a5,-32(s0)
    80014dd0:	c799                	beqz	a5,80014dde <insert_block+0x60>
        prev->next = block;
    80014dd2:	fe043783          	ld	a5,-32(s0)
    80014dd6:	fd843703          	ld	a4,-40(s0)
    80014dda:	e798                	sd	a4,8(a5)
    80014ddc:	a809                	j	80014dee <insert_block+0x70>
    }
    else {
        heap->free = block;
    80014dde:	00010797          	auipc	a5,0x10
    80014de2:	29278793          	addi	a5,a5,658 # 80025070 <heap>
    80014de6:	639c                	ld	a5,0(a5)
    80014de8:	fd843703          	ld	a4,-40(s0)
    80014dec:	e398                	sd	a4,0(a5)
    }
    block->next = ptr;
    80014dee:	fd843783          	ld	a5,-40(s0)
    80014df2:	fe843703          	ld	a4,-24(s0)
    80014df6:	e798                	sd	a4,8(a5)
}
    80014df8:	0001                	nop
    80014dfa:	7422                	ld	s0,40(sp)
    80014dfc:	6145                	addi	sp,sp,48
    80014dfe:	8082                	ret

0000000080014e00 <release_blocks>:

#ifndef TA_DISABLE_COMPACT
static void release_blocks(Block *scan, Block *to)
{
    80014e00:	7179                	addi	sp,sp,-48
    80014e02:	f422                	sd	s0,40(sp)
    80014e04:	1800                	addi	s0,sp,48
    80014e06:	fca43c23          	sd	a0,-40(s0)
    80014e0a:	fcb43823          	sd	a1,-48(s0)
    Block *scan_next;
    while (scan != to) {
    80014e0e:	a099                	j	80014e54 <release_blocks+0x54>
        scan_next   = scan->next;
    80014e10:	fd843783          	ld	a5,-40(s0)
    80014e14:	679c                	ld	a5,8(a5)
    80014e16:	fef43423          	sd	a5,-24(s0)
        scan->next  = heap->fresh;
    80014e1a:	00010797          	auipc	a5,0x10
    80014e1e:	25678793          	addi	a5,a5,598 # 80025070 <heap>
    80014e22:	639c                	ld	a5,0(a5)
    80014e24:	6b98                	ld	a4,16(a5)
    80014e26:	fd843783          	ld	a5,-40(s0)
    80014e2a:	e798                	sd	a4,8(a5)
        heap->fresh = scan;
    80014e2c:	00010797          	auipc	a5,0x10
    80014e30:	24478793          	addi	a5,a5,580 # 80025070 <heap>
    80014e34:	639c                	ld	a5,0(a5)
    80014e36:	fd843703          	ld	a4,-40(s0)
    80014e3a:	eb98                	sd	a4,16(a5)
        scan->addr  = 0;
    80014e3c:	fd843783          	ld	a5,-40(s0)
    80014e40:	0007b023          	sd	zero,0(a5)
        scan->size  = 0;
    80014e44:	fd843783          	ld	a5,-40(s0)
    80014e48:	0007b823          	sd	zero,16(a5)
        scan        = scan_next;
    80014e4c:	fe843783          	ld	a5,-24(s0)
    80014e50:	fcf43c23          	sd	a5,-40(s0)
    while (scan != to) {
    80014e54:	fd843703          	ld	a4,-40(s0)
    80014e58:	fd043783          	ld	a5,-48(s0)
    80014e5c:	faf71ae3          	bne	a4,a5,80014e10 <release_blocks+0x10>
    }
}
    80014e60:	0001                	nop
    80014e62:	0001                	nop
    80014e64:	7422                	ld	s0,40(sp)
    80014e66:	6145                	addi	sp,sp,48
    80014e68:	8082                	ret

0000000080014e6a <compact>:

static void compact()
{
    80014e6a:	7139                	addi	sp,sp,-64
    80014e6c:	fc06                	sd	ra,56(sp)
    80014e6e:	f822                	sd	s0,48(sp)
    80014e70:	0080                	addi	s0,sp,64
    Block *ptr = heap->free;
    80014e72:	00010797          	auipc	a5,0x10
    80014e76:	1fe78793          	addi	a5,a5,510 # 80025070 <heap>
    80014e7a:	639c                	ld	a5,0(a5)
    80014e7c:	639c                	ld	a5,0(a5)
    80014e7e:	fef43423          	sd	a5,-24(s0)
    Block *prev;
    Block *scan;
    while (ptr != NULL) {
    80014e82:	a075                	j	80014f2e <compact+0xc4>
        prev = ptr;
    80014e84:	fe843783          	ld	a5,-24(s0)
    80014e88:	fef43023          	sd	a5,-32(s0)
        scan = ptr->next;
    80014e8c:	fe843783          	ld	a5,-24(s0)
    80014e90:	679c                	ld	a5,8(a5)
    80014e92:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    80014e96:	a811                	j	80014eaa <compact+0x40>
            prev = scan;
    80014e98:	fd843783          	ld	a5,-40(s0)
    80014e9c:	fef43023          	sd	a5,-32(s0)
            scan = scan->next;
    80014ea0:	fd843783          	ld	a5,-40(s0)
    80014ea4:	679c                	ld	a5,8(a5)
    80014ea6:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    80014eaa:	fd843783          	ld	a5,-40(s0)
    80014eae:	cf91                	beqz	a5,80014eca <compact+0x60>
    80014eb0:	fe043783          	ld	a5,-32(s0)
    80014eb4:	639c                	ld	a5,0(a5)
    80014eb6:	873e                	mv	a4,a5
    80014eb8:	fe043783          	ld	a5,-32(s0)
    80014ebc:	6b9c                	ld	a5,16(a5)
    80014ebe:	97ba                	add	a5,a5,a4
    80014ec0:	fd843703          	ld	a4,-40(s0)
    80014ec4:	6318                	ld	a4,0(a4)
    80014ec6:	fce789e3          	beq	a5,a4,80014e98 <compact+0x2e>
        }
        if (prev != ptr) {
    80014eca:	fe043703          	ld	a4,-32(s0)
    80014ece:	fe843783          	ld	a5,-24(s0)
    80014ed2:	04f70963          	beq	a4,a5,80014f24 <compact+0xba>
            size_t new_size = (size_t)prev->addr - (size_t)ptr->addr + prev->size;
    80014ed6:	fe043783          	ld	a5,-32(s0)
    80014eda:	639c                	ld	a5,0(a5)
    80014edc:	873e                	mv	a4,a5
    80014ede:	fe843783          	ld	a5,-24(s0)
    80014ee2:	639c                	ld	a5,0(a5)
    80014ee4:	8f1d                	sub	a4,a4,a5
    80014ee6:	fe043783          	ld	a5,-32(s0)
    80014eea:	6b9c                	ld	a5,16(a5)
    80014eec:	97ba                	add	a5,a5,a4
    80014eee:	fcf43823          	sd	a5,-48(s0)
            ptr->size       = new_size;
    80014ef2:	fe843783          	ld	a5,-24(s0)
    80014ef6:	fd043703          	ld	a4,-48(s0)
    80014efa:	eb98                	sd	a4,16(a5)
            Block *next     = prev->next;
    80014efc:	fe043783          	ld	a5,-32(s0)
    80014f00:	679c                	ld	a5,8(a5)
    80014f02:	fcf43423          	sd	a5,-56(s0)
            // make merged blocks available
            release_blocks(ptr->next, prev->next);
    80014f06:	fe843783          	ld	a5,-24(s0)
    80014f0a:	6798                	ld	a4,8(a5)
    80014f0c:	fe043783          	ld	a5,-32(s0)
    80014f10:	679c                	ld	a5,8(a5)
    80014f12:	85be                	mv	a1,a5
    80014f14:	853a                	mv	a0,a4
    80014f16:	eebff0ef          	jal	ra,80014e00 <release_blocks>
            // relink
            ptr->next = next;
    80014f1a:	fe843783          	ld	a5,-24(s0)
    80014f1e:	fc843703          	ld	a4,-56(s0)
    80014f22:	e798                	sd	a4,8(a5)
        }
        ptr = ptr->next;
    80014f24:	fe843783          	ld	a5,-24(s0)
    80014f28:	679c                	ld	a5,8(a5)
    80014f2a:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80014f2e:	fe843783          	ld	a5,-24(s0)
    80014f32:	fba9                	bnez	a5,80014e84 <compact+0x1a>
    }
}
    80014f34:	0001                	nop
    80014f36:	0001                	nop
    80014f38:	70e2                	ld	ra,56(sp)
    80014f3a:	7442                	ld	s0,48(sp)
    80014f3c:	6121                	addi	sp,sp,64
    80014f3e:	8082                	ret

0000000080014f40 <init>:
#endif

static bool init(const void *base, const void *limit, const size_t heap_blocks,
                 const size_t split_thresh, const size_t alignment)
{
    80014f40:	715d                	addi	sp,sp,-80
    80014f42:	e4a2                	sd	s0,72(sp)
    80014f44:	0880                	addi	s0,sp,80
    80014f46:	fca43c23          	sd	a0,-40(s0)
    80014f4a:	fcb43823          	sd	a1,-48(s0)
    80014f4e:	fcc43423          	sd	a2,-56(s0)
    80014f52:	fcd43023          	sd	a3,-64(s0)
    80014f56:	fae43c23          	sd	a4,-72(s0)
    heap              = (Heap *)base;
    80014f5a:	00010797          	auipc	a5,0x10
    80014f5e:	11678793          	addi	a5,a5,278 # 80025070 <heap>
    80014f62:	fd843703          	ld	a4,-40(s0)
    80014f66:	e398                	sd	a4,0(a5)
    heap_limit        = limit;
    80014f68:	00010797          	auipc	a5,0x10
    80014f6c:	11078793          	addi	a5,a5,272 # 80025078 <heap_limit>
    80014f70:	fd043703          	ld	a4,-48(s0)
    80014f74:	e398                	sd	a4,0(a5)
    heap_split_thresh = split_thresh;
    80014f76:	00010797          	auipc	a5,0x10
    80014f7a:	10a78793          	addi	a5,a5,266 # 80025080 <heap_split_thresh>
    80014f7e:	fc043703          	ld	a4,-64(s0)
    80014f82:	e398                	sd	a4,0(a5)
    heap_alignment    = alignment;
    80014f84:	00010797          	auipc	a5,0x10
    80014f88:	10478793          	addi	a5,a5,260 # 80025088 <heap_alignment>
    80014f8c:	fb843703          	ld	a4,-72(s0)
    80014f90:	e398                	sd	a4,0(a5)
    heap_max_blocks   = heap_blocks;
    80014f92:	00010797          	auipc	a5,0x10
    80014f96:	0fe78793          	addi	a5,a5,254 # 80025090 <heap_max_blocks>
    80014f9a:	fc843703          	ld	a4,-56(s0)
    80014f9e:	e398                	sd	a4,0(a5)

    heap->free        = NULL;
    80014fa0:	00010797          	auipc	a5,0x10
    80014fa4:	0d078793          	addi	a5,a5,208 # 80025070 <heap>
    80014fa8:	639c                	ld	a5,0(a5)
    80014faa:	0007b023          	sd	zero,0(a5)
    heap->used        = NULL;
    80014fae:	00010797          	auipc	a5,0x10
    80014fb2:	0c278793          	addi	a5,a5,194 # 80025070 <heap>
    80014fb6:	639c                	ld	a5,0(a5)
    80014fb8:	0007b423          	sd	zero,8(a5)
    heap->fresh       = (Block *)(heap + 1);
    80014fbc:	00010797          	auipc	a5,0x10
    80014fc0:	0b478793          	addi	a5,a5,180 # 80025070 <heap>
    80014fc4:	6398                	ld	a4,0(a5)
    80014fc6:	00010797          	auipc	a5,0x10
    80014fca:	0aa78793          	addi	a5,a5,170 # 80025070 <heap>
    80014fce:	639c                	ld	a5,0(a5)
    80014fd0:	02070713          	addi	a4,a4,32
    80014fd4:	eb98                	sd	a4,16(a5)
    heap->top         = (size_t)(heap->fresh + heap_blocks);
    80014fd6:	00010797          	auipc	a5,0x10
    80014fda:	09a78793          	addi	a5,a5,154 # 80025070 <heap>
    80014fde:	639c                	ld	a5,0(a5)
    80014fe0:	6b94                	ld	a3,16(a5)
    80014fe2:	fc843703          	ld	a4,-56(s0)
    80014fe6:	87ba                	mv	a5,a4
    80014fe8:	0786                	slli	a5,a5,0x1
    80014fea:	97ba                	add	a5,a5,a4
    80014fec:	078e                	slli	a5,a5,0x3
    80014fee:	00f68733          	add	a4,a3,a5
    80014ff2:	00010797          	auipc	a5,0x10
    80014ff6:	07e78793          	addi	a5,a5,126 # 80025070 <heap>
    80014ffa:	639c                	ld	a5,0(a5)
    80014ffc:	ef98                	sd	a4,24(a5)

    Block *block      = heap->fresh;
    80014ffe:	00010797          	auipc	a5,0x10
    80015002:	07278793          	addi	a5,a5,114 # 80025070 <heap>
    80015006:	639c                	ld	a5,0(a5)
    80015008:	6b9c                	ld	a5,16(a5)
    8001500a:	fef43423          	sd	a5,-24(s0)
    size_t i          = heap_max_blocks - 1;
    8001500e:	00010797          	auipc	a5,0x10
    80015012:	08278793          	addi	a5,a5,130 # 80025090 <heap_max_blocks>
    80015016:	639c                	ld	a5,0(a5)
    80015018:	17fd                	addi	a5,a5,-1
    8001501a:	fef43023          	sd	a5,-32(s0)
    while (i--) {
    8001501e:	a829                	j	80015038 <init+0xf8>
        block->next = block + 1;
    80015020:	fe843783          	ld	a5,-24(s0)
    80015024:	01878713          	addi	a4,a5,24
    80015028:	fe843783          	ld	a5,-24(s0)
    8001502c:	e798                	sd	a4,8(a5)
        block++;
    8001502e:	fe843783          	ld	a5,-24(s0)
    80015032:	07e1                	addi	a5,a5,24
    80015034:	fef43423          	sd	a5,-24(s0)
    while (i--) {
    80015038:	fe043783          	ld	a5,-32(s0)
    8001503c:	fff78713          	addi	a4,a5,-1
    80015040:	fee43023          	sd	a4,-32(s0)
    80015044:	fff1                	bnez	a5,80015020 <init+0xe0>
    }
    block->next = NULL;
    80015046:	fe843783          	ld	a5,-24(s0)
    8001504a:	0007b423          	sd	zero,8(a5)
    return true;
    8001504e:	4785                	li	a5,1
}
    80015050:	853e                	mv	a0,a5
    80015052:	6426                	ld	s0,72(sp)
    80015054:	6161                	addi	sp,sp,80
    80015056:	8082                	ret

0000000080015058 <free>:

static bool free(const void *free)
{
    80015058:	7179                	addi	sp,sp,-48
    8001505a:	f406                	sd	ra,40(sp)
    8001505c:	f022                	sd	s0,32(sp)
    8001505e:	1800                	addi	s0,sp,48
    80015060:	fca43c23          	sd	a0,-40(s0)
    Block *block = heap->used;
    80015064:	00010797          	auipc	a5,0x10
    80015068:	00c78793          	addi	a5,a5,12 # 80025070 <heap>
    8001506c:	639c                	ld	a5,0(a5)
    8001506e:	679c                	ld	a5,8(a5)
    80015070:	fef43423          	sd	a5,-24(s0)
    Block *prev  = NULL;
    80015074:	fe043023          	sd	zero,-32(s0)
    while (block != NULL) {
    80015078:	a8a1                	j	800150d0 <free+0x78>
        if (free == block->addr) {
    8001507a:	fe843783          	ld	a5,-24(s0)
    8001507e:	639c                	ld	a5,0(a5)
    80015080:	fd843703          	ld	a4,-40(s0)
    80015084:	02f71d63          	bne	a4,a5,800150be <free+0x66>
            if (prev) {
    80015088:	fe043783          	ld	a5,-32(s0)
    8001508c:	cb81                	beqz	a5,8001509c <free+0x44>
                prev->next = block->next;
    8001508e:	fe843783          	ld	a5,-24(s0)
    80015092:	6798                	ld	a4,8(a5)
    80015094:	fe043783          	ld	a5,-32(s0)
    80015098:	e798                	sd	a4,8(a5)
    8001509a:	a811                	j	800150ae <free+0x56>
            }
            else {
                heap->used = block->next;
    8001509c:	00010797          	auipc	a5,0x10
    800150a0:	fd478793          	addi	a5,a5,-44 # 80025070 <heap>
    800150a4:	639c                	ld	a5,0(a5)
    800150a6:	fe843703          	ld	a4,-24(s0)
    800150aa:	6718                	ld	a4,8(a4)
    800150ac:	e798                	sd	a4,8(a5)
            }
            insert_block(block);
    800150ae:	fe843503          	ld	a0,-24(s0)
    800150b2:	ccdff0ef          	jal	ra,80014d7e <insert_block>
            compact();
    800150b6:	db5ff0ef          	jal	ra,80014e6a <compact>
            return true;
    800150ba:	4785                	li	a5,1
    800150bc:	a831                	j	800150d8 <free+0x80>
        }
        prev  = block;
    800150be:	fe843783          	ld	a5,-24(s0)
    800150c2:	fef43023          	sd	a5,-32(s0)
        block = block->next;
    800150c6:	fe843783          	ld	a5,-24(s0)
    800150ca:	679c                	ld	a5,8(a5)
    800150cc:	fef43423          	sd	a5,-24(s0)
    while (block != NULL) {
    800150d0:	fe843783          	ld	a5,-24(s0)
    800150d4:	f3dd                	bnez	a5,8001507a <free+0x22>
    }
    return false;
    800150d6:	4781                	li	a5,0
}
    800150d8:	853e                	mv	a0,a5
    800150da:	70a2                	ld	ra,40(sp)
    800150dc:	7402                	ld	s0,32(sp)
    800150de:	6145                	addi	sp,sp,48
    800150e0:	8082                	ret

00000000800150e2 <alloc_block>:

static Block *alloc_block(size_t num)
{
    800150e2:	711d                	addi	sp,sp,-96
    800150e4:	ec86                	sd	ra,88(sp)
    800150e6:	e8a2                	sd	s0,80(sp)
    800150e8:	1080                	addi	s0,sp,96
    800150ea:	faa43423          	sd	a0,-88(s0)
    Block *ptr  = heap->free;
    800150ee:	00010797          	auipc	a5,0x10
    800150f2:	f8278793          	addi	a5,a5,-126 # 80025070 <heap>
    800150f6:	639c                	ld	a5,0(a5)
    800150f8:	639c                	ld	a5,0(a5)
    800150fa:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    800150fe:	fe043023          	sd	zero,-32(s0)
    size_t top  = heap->top;
    80015102:	00010797          	auipc	a5,0x10
    80015106:	f6e78793          	addi	a5,a5,-146 # 80025070 <heap>
    8001510a:	639c                	ld	a5,0(a5)
    8001510c:	6f9c                	ld	a5,24(a5)
    8001510e:	fcf43c23          	sd	a5,-40(s0)
    num         = (num + heap_alignment - 1) & -heap_alignment;
    80015112:	00010797          	auipc	a5,0x10
    80015116:	f7678793          	addi	a5,a5,-138 # 80025088 <heap_alignment>
    8001511a:	6398                	ld	a4,0(a5)
    8001511c:	fa843783          	ld	a5,-88(s0)
    80015120:	97ba                	add	a5,a5,a4
    80015122:	fff78713          	addi	a4,a5,-1
    80015126:	00010797          	auipc	a5,0x10
    8001512a:	f6278793          	addi	a5,a5,-158 # 80025088 <heap_alignment>
    8001512e:	639c                	ld	a5,0(a5)
    80015130:	40f007b3          	neg	a5,a5
    80015134:	8ff9                	and	a5,a5,a4
    80015136:	faf43423          	sd	a5,-88(s0)
    while (ptr != NULL) {
    8001513a:	a2bd                	j	800152a8 <alloc_block+0x1c6>
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    8001513c:	fe843783          	ld	a5,-24(s0)
    80015140:	639c                	ld	a5,0(a5)
    80015142:	873e                	mv	a4,a5
    80015144:	fe843783          	ld	a5,-24(s0)
    80015148:	6b9c                	ld	a5,16(a5)
    8001514a:	97ba                	add	a5,a5,a4
    8001514c:	fd843703          	ld	a4,-40(s0)
    80015150:	02e7e263          	bltu	a5,a4,80015174 <alloc_block+0x92>
                           ((size_t)ptr->addr + num <= (size_t)heap_limit);
    80015154:	fe843783          	ld	a5,-24(s0)
    80015158:	639c                	ld	a5,0(a5)
    8001515a:	873e                	mv	a4,a5
    8001515c:	fa843783          	ld	a5,-88(s0)
    80015160:	97ba                	add	a5,a5,a4
    80015162:	00010717          	auipc	a4,0x10
    80015166:	f1670713          	addi	a4,a4,-234 # 80025078 <heap_limit>
    8001516a:	6318                	ld	a4,0(a4)
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    8001516c:	00f76463          	bltu	a4,a5,80015174 <alloc_block+0x92>
    80015170:	4785                	li	a5,1
    80015172:	a011                	j	80015176 <alloc_block+0x94>
    80015174:	4781                	li	a5,0
    80015176:	fcf42623          	sw	a5,-52(s0)
        if (is_top || ptr->size >= num) {
    8001517a:	fcc42783          	lw	a5,-52(s0)
    8001517e:	2781                	sext.w	a5,a5
    80015180:	eb81                	bnez	a5,80015190 <alloc_block+0xae>
    80015182:	fe843783          	ld	a5,-24(s0)
    80015186:	6b9c                	ld	a5,16(a5)
    80015188:	fa843703          	ld	a4,-88(s0)
    8001518c:	10e7e563          	bltu	a5,a4,80015296 <alloc_block+0x1b4>
            if (prev != NULL) {
    80015190:	fe043783          	ld	a5,-32(s0)
    80015194:	cb81                	beqz	a5,800151a4 <alloc_block+0xc2>
                prev->next = ptr->next;
    80015196:	fe843783          	ld	a5,-24(s0)
    8001519a:	6798                	ld	a4,8(a5)
    8001519c:	fe043783          	ld	a5,-32(s0)
    800151a0:	e798                	sd	a4,8(a5)
    800151a2:	a811                	j	800151b6 <alloc_block+0xd4>
            }
            else {
                heap->free = ptr->next;
    800151a4:	00010797          	auipc	a5,0x10
    800151a8:	ecc78793          	addi	a5,a5,-308 # 80025070 <heap>
    800151ac:	639c                	ld	a5,0(a5)
    800151ae:	fe843703          	ld	a4,-24(s0)
    800151b2:	6718                	ld	a4,8(a4)
    800151b4:	e398                	sd	a4,0(a5)
            }
            ptr->next  = heap->used;
    800151b6:	00010797          	auipc	a5,0x10
    800151ba:	eba78793          	addi	a5,a5,-326 # 80025070 <heap>
    800151be:	639c                	ld	a5,0(a5)
    800151c0:	6798                	ld	a4,8(a5)
    800151c2:	fe843783          	ld	a5,-24(s0)
    800151c6:	e798                	sd	a4,8(a5)
            heap->used = ptr;
    800151c8:	00010797          	auipc	a5,0x10
    800151cc:	ea878793          	addi	a5,a5,-344 # 80025070 <heap>
    800151d0:	639c                	ld	a5,0(a5)
    800151d2:	fe843703          	ld	a4,-24(s0)
    800151d6:	e798                	sd	a4,8(a5)
            if (is_top) {
    800151d8:	fcc42783          	lw	a5,-52(s0)
    800151dc:	2781                	sext.w	a5,a5
    800151de:	c785                	beqz	a5,80015206 <alloc_block+0x124>
                ptr->size = num;
    800151e0:	fe843783          	ld	a5,-24(s0)
    800151e4:	fa843703          	ld	a4,-88(s0)
    800151e8:	eb98                	sd	a4,16(a5)
                heap->top = (size_t)ptr->addr + num;
    800151ea:	fe843783          	ld	a5,-24(s0)
    800151ee:	639c                	ld	a5,0(a5)
    800151f0:	86be                	mv	a3,a5
    800151f2:	00010797          	auipc	a5,0x10
    800151f6:	e7e78793          	addi	a5,a5,-386 # 80025070 <heap>
    800151fa:	639c                	ld	a5,0(a5)
    800151fc:	fa843703          	ld	a4,-88(s0)
    80015200:	9736                	add	a4,a4,a3
    80015202:	ef98                	sd	a4,24(a5)
    80015204:	a071                	j	80015290 <alloc_block+0x1ae>
            }
            else if (heap->fresh != NULL) {
    80015206:	00010797          	auipc	a5,0x10
    8001520a:	e6a78793          	addi	a5,a5,-406 # 80025070 <heap>
    8001520e:	639c                	ld	a5,0(a5)
    80015210:	6b9c                	ld	a5,16(a5)
    80015212:	cfbd                	beqz	a5,80015290 <alloc_block+0x1ae>
                size_t excess = ptr->size - num;
    80015214:	fe843783          	ld	a5,-24(s0)
    80015218:	6b98                	ld	a4,16(a5)
    8001521a:	fa843783          	ld	a5,-88(s0)
    8001521e:	40f707b3          	sub	a5,a4,a5
    80015222:	fcf43023          	sd	a5,-64(s0)
                if (excess >= heap_split_thresh) {
    80015226:	00010797          	auipc	a5,0x10
    8001522a:	e5a78793          	addi	a5,a5,-422 # 80025080 <heap_split_thresh>
    8001522e:	639c                	ld	a5,0(a5)
    80015230:	fc043703          	ld	a4,-64(s0)
    80015234:	04f76e63          	bltu	a4,a5,80015290 <alloc_block+0x1ae>
                    ptr->size    = num;
    80015238:	fe843783          	ld	a5,-24(s0)
    8001523c:	fa843703          	ld	a4,-88(s0)
    80015240:	eb98                	sd	a4,16(a5)
                    Block *split = heap->fresh;
    80015242:	00010797          	auipc	a5,0x10
    80015246:	e2e78793          	addi	a5,a5,-466 # 80025070 <heap>
    8001524a:	639c                	ld	a5,0(a5)
    8001524c:	6b9c                	ld	a5,16(a5)
    8001524e:	faf43c23          	sd	a5,-72(s0)
                    heap->fresh  = split->next;
    80015252:	00010797          	auipc	a5,0x10
    80015256:	e1e78793          	addi	a5,a5,-482 # 80025070 <heap>
    8001525a:	639c                	ld	a5,0(a5)
    8001525c:	fb843703          	ld	a4,-72(s0)
    80015260:	6718                	ld	a4,8(a4)
    80015262:	eb98                	sd	a4,16(a5)
                    split->addr  = (void *)((size_t)ptr->addr + num);
    80015264:	fe843783          	ld	a5,-24(s0)
    80015268:	639c                	ld	a5,0(a5)
    8001526a:	873e                	mv	a4,a5
    8001526c:	fa843783          	ld	a5,-88(s0)
    80015270:	97ba                	add	a5,a5,a4
    80015272:	873e                	mv	a4,a5
    80015274:	fb843783          	ld	a5,-72(s0)
    80015278:	e398                	sd	a4,0(a5)
                    split->size  = excess;
    8001527a:	fb843783          	ld	a5,-72(s0)
    8001527e:	fc043703          	ld	a4,-64(s0)
    80015282:	eb98                	sd	a4,16(a5)
                    insert_block(split);
    80015284:	fb843503          	ld	a0,-72(s0)
    80015288:	af7ff0ef          	jal	ra,80014d7e <insert_block>
                    compact();
    8001528c:	bdfff0ef          	jal	ra,80014e6a <compact>
                }
            }
            return ptr;
    80015290:	fe843783          	ld	a5,-24(s0)
    80015294:	a875                	j	80015350 <alloc_block+0x26e>
        }
        prev = ptr;
    80015296:	fe843783          	ld	a5,-24(s0)
    8001529a:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    8001529e:	fe843783          	ld	a5,-24(s0)
    800152a2:	679c                	ld	a5,8(a5)
    800152a4:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    800152a8:	fe843783          	ld	a5,-24(s0)
    800152ac:	e80798e3          	bnez	a5,8001513c <alloc_block+0x5a>
    }
    // no matching free blocks
    // see if any other blocks available
    size_t new_top = top + num;
    800152b0:	fd843703          	ld	a4,-40(s0)
    800152b4:	fa843783          	ld	a5,-88(s0)
    800152b8:	97ba                	add	a5,a5,a4
    800152ba:	fcf43823          	sd	a5,-48(s0)
    if (heap->fresh != NULL && new_top <= (size_t)heap_limit) {
    800152be:	00010797          	auipc	a5,0x10
    800152c2:	db278793          	addi	a5,a5,-590 # 80025070 <heap>
    800152c6:	639c                	ld	a5,0(a5)
    800152c8:	6b9c                	ld	a5,16(a5)
    800152ca:	c3d1                	beqz	a5,8001534e <alloc_block+0x26c>
    800152cc:	00010797          	auipc	a5,0x10
    800152d0:	dac78793          	addi	a5,a5,-596 # 80025078 <heap_limit>
    800152d4:	639c                	ld	a5,0(a5)
    800152d6:	873e                	mv	a4,a5
    800152d8:	fd043783          	ld	a5,-48(s0)
    800152dc:	06f76963          	bltu	a4,a5,8001534e <alloc_block+0x26c>
        ptr         = heap->fresh;
    800152e0:	00010797          	auipc	a5,0x10
    800152e4:	d9078793          	addi	a5,a5,-624 # 80025070 <heap>
    800152e8:	639c                	ld	a5,0(a5)
    800152ea:	6b9c                	ld	a5,16(a5)
    800152ec:	fef43423          	sd	a5,-24(s0)
        heap->fresh = ptr->next;
    800152f0:	00010797          	auipc	a5,0x10
    800152f4:	d8078793          	addi	a5,a5,-640 # 80025070 <heap>
    800152f8:	639c                	ld	a5,0(a5)
    800152fa:	fe843703          	ld	a4,-24(s0)
    800152fe:	6718                	ld	a4,8(a4)
    80015300:	eb98                	sd	a4,16(a5)
        ptr->addr   = (void *)top;
    80015302:	fd843703          	ld	a4,-40(s0)
    80015306:	fe843783          	ld	a5,-24(s0)
    8001530a:	e398                	sd	a4,0(a5)
        ptr->next   = heap->used;
    8001530c:	00010797          	auipc	a5,0x10
    80015310:	d6478793          	addi	a5,a5,-668 # 80025070 <heap>
    80015314:	639c                	ld	a5,0(a5)
    80015316:	6798                	ld	a4,8(a5)
    80015318:	fe843783          	ld	a5,-24(s0)
    8001531c:	e798                	sd	a4,8(a5)
        ptr->size   = num;
    8001531e:	fe843783          	ld	a5,-24(s0)
    80015322:	fa843703          	ld	a4,-88(s0)
    80015326:	eb98                	sd	a4,16(a5)
        heap->used  = ptr;
    80015328:	00010797          	auipc	a5,0x10
    8001532c:	d4878793          	addi	a5,a5,-696 # 80025070 <heap>
    80015330:	639c                	ld	a5,0(a5)
    80015332:	fe843703          	ld	a4,-24(s0)
    80015336:	e798                	sd	a4,8(a5)
        heap->top   = new_top;
    80015338:	00010797          	auipc	a5,0x10
    8001533c:	d3878793          	addi	a5,a5,-712 # 80025070 <heap>
    80015340:	639c                	ld	a5,0(a5)
    80015342:	fd043703          	ld	a4,-48(s0)
    80015346:	ef98                	sd	a4,24(a5)
        return ptr;
    80015348:	fe843783          	ld	a5,-24(s0)
    8001534c:	a011                	j	80015350 <alloc_block+0x26e>
    }
    return NULL;
    8001534e:	4781                	li	a5,0
}
    80015350:	853e                	mv	a0,a5
    80015352:	60e6                	ld	ra,88(sp)
    80015354:	6446                	ld	s0,80(sp)
    80015356:	6125                	addi	sp,sp,96
    80015358:	8082                	ret

000000008001535a <alloc>:

static void *alloc(size_t num)
{
    8001535a:	7179                	addi	sp,sp,-48
    8001535c:	f406                	sd	ra,40(sp)
    8001535e:	f022                	sd	s0,32(sp)
    80015360:	1800                	addi	s0,sp,48
    80015362:	fca43c23          	sd	a0,-40(s0)
    Block *block = alloc_block(num);
    80015366:	fd843503          	ld	a0,-40(s0)
    8001536a:	d79ff0ef          	jal	ra,800150e2 <alloc_block>
    8001536e:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80015372:	fe843783          	ld	a5,-24(s0)
    80015376:	c789                	beqz	a5,80015380 <alloc+0x26>
        return block->addr;
    80015378:	fe843783          	ld	a5,-24(s0)
    8001537c:	639c                	ld	a5,0(a5)
    8001537e:	a011                	j	80015382 <alloc+0x28>
    }
    return NULL;
    80015380:	4781                	li	a5,0
}
    80015382:	853e                	mv	a0,a5
    80015384:	70a2                	ld	ra,40(sp)
    80015386:	7402                	ld	s0,32(sp)
    80015388:	6145                	addi	sp,sp,48
    8001538a:	8082                	ret

000000008001538c <calloc>:

static void *calloc(size_t num, size_t size)
{
    8001538c:	7179                	addi	sp,sp,-48
    8001538e:	f406                	sd	ra,40(sp)
    80015390:	f022                	sd	s0,32(sp)
    80015392:	1800                	addi	s0,sp,48
    80015394:	fca43c23          	sd	a0,-40(s0)
    80015398:	fcb43823          	sd	a1,-48(s0)
    num *= size;
    8001539c:	fd843703          	ld	a4,-40(s0)
    800153a0:	fd043783          	ld	a5,-48(s0)
    800153a4:	02f707b3          	mul	a5,a4,a5
    800153a8:	fcf43c23          	sd	a5,-40(s0)
    Block *block = alloc_block(num);
    800153ac:	fd843503          	ld	a0,-40(s0)
    800153b0:	d33ff0ef          	jal	ra,800150e2 <alloc_block>
    800153b4:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    800153b8:	fe843783          	ld	a5,-24(s0)
    800153bc:	c385                	beqz	a5,800153dc <calloc+0x50>
        memset(block->addr, 0, num);
    800153be:	fe843783          	ld	a5,-24(s0)
    800153c2:	639c                	ld	a5,0(a5)
    800153c4:	fd843703          	ld	a4,-40(s0)
    800153c8:	2701                	sext.w	a4,a4
    800153ca:	863a                	mv	a2,a4
    800153cc:	4581                	li	a1,0
    800153ce:	853e                	mv	a0,a5
    800153d0:	66d0c0ef          	jal	ra,8002223c <memset>
        return block->addr;
    800153d4:	fe843783          	ld	a5,-24(s0)
    800153d8:	639c                	ld	a5,0(a5)
    800153da:	a011                	j	800153de <calloc+0x52>
    }
    return NULL;
    800153dc:	4781                	li	a5,0
}
    800153de:	853e                	mv	a0,a5
    800153e0:	70a2                	ld	ra,40(sp)
    800153e2:	7402                	ld	s0,32(sp)
    800153e4:	6145                	addi	sp,sp,48
    800153e6:	8082                	ret

00000000800153e8 <count_blocks>:

static size_t count_blocks(Block *ptr)
{
    800153e8:	7179                	addi	sp,sp,-48
    800153ea:	f422                	sd	s0,40(sp)
    800153ec:	1800                	addi	s0,sp,48
    800153ee:	fca43c23          	sd	a0,-40(s0)
    size_t num = 0;
    800153f2:	fe043423          	sd	zero,-24(s0)
    while (ptr != NULL) {
    800153f6:	a819                	j	8001540c <count_blocks+0x24>
        num++;
    800153f8:	fe843783          	ld	a5,-24(s0)
    800153fc:	0785                	addi	a5,a5,1
    800153fe:	fef43423          	sd	a5,-24(s0)
        ptr = ptr->next;
    80015402:	fd843783          	ld	a5,-40(s0)
    80015406:	679c                	ld	a5,8(a5)
    80015408:	fcf43c23          	sd	a5,-40(s0)
    while (ptr != NULL) {
    8001540c:	fd843783          	ld	a5,-40(s0)
    80015410:	f7e5                	bnez	a5,800153f8 <count_blocks+0x10>
    }
    return num;
    80015412:	fe843783          	ld	a5,-24(s0)
}
    80015416:	853e                	mv	a0,a5
    80015418:	7422                	ld	s0,40(sp)
    8001541a:	6145                	addi	sp,sp,48
    8001541c:	8082                	ret

000000008001541e <heap_num_free>:
static size_t heap_num_free()
{
    8001541e:	1141                	addi	sp,sp,-16
    80015420:	e406                	sd	ra,8(sp)
    80015422:	e022                	sd	s0,0(sp)
    80015424:	0800                	addi	s0,sp,16
    return count_blocks(heap->free);
    80015426:	00010797          	auipc	a5,0x10
    8001542a:	c4a78793          	addi	a5,a5,-950 # 80025070 <heap>
    8001542e:	639c                	ld	a5,0(a5)
    80015430:	639c                	ld	a5,0(a5)
    80015432:	853e                	mv	a0,a5
    80015434:	fb5ff0ef          	jal	ra,800153e8 <count_blocks>
    80015438:	87aa                	mv	a5,a0
}
    8001543a:	853e                	mv	a0,a5
    8001543c:	60a2                	ld	ra,8(sp)
    8001543e:	6402                	ld	s0,0(sp)
    80015440:	0141                	addi	sp,sp,16
    80015442:	8082                	ret

0000000080015444 <heap_num_used>:
static size_t heap_num_used()
{
    80015444:	1141                	addi	sp,sp,-16
    80015446:	e406                	sd	ra,8(sp)
    80015448:	e022                	sd	s0,0(sp)
    8001544a:	0800                	addi	s0,sp,16
    return count_blocks(heap->used);
    8001544c:	00010797          	auipc	a5,0x10
    80015450:	c2478793          	addi	a5,a5,-988 # 80025070 <heap>
    80015454:	639c                	ld	a5,0(a5)
    80015456:	679c                	ld	a5,8(a5)
    80015458:	853e                	mv	a0,a5
    8001545a:	f8fff0ef          	jal	ra,800153e8 <count_blocks>
    8001545e:	87aa                	mv	a5,a0
}
    80015460:	853e                	mv	a0,a5
    80015462:	60a2                	ld	ra,8(sp)
    80015464:	6402                	ld	s0,0(sp)
    80015466:	0141                	addi	sp,sp,16
    80015468:	8082                	ret

000000008001546a <heap_num_fresh>:
static size_t heap_num_fresh()
{
    8001546a:	1141                	addi	sp,sp,-16
    8001546c:	e406                	sd	ra,8(sp)
    8001546e:	e022                	sd	s0,0(sp)
    80015470:	0800                	addi	s0,sp,16
    return count_blocks(heap->fresh);
    80015472:	00010797          	auipc	a5,0x10
    80015476:	bfe78793          	addi	a5,a5,-1026 # 80025070 <heap>
    8001547a:	639c                	ld	a5,0(a5)
    8001547c:	6b9c                	ld	a5,16(a5)
    8001547e:	853e                	mv	a0,a5
    80015480:	f69ff0ef          	jal	ra,800153e8 <count_blocks>
    80015484:	87aa                	mv	a5,a0
}
    80015486:	853e                	mv	a0,a5
    80015488:	60a2                	ld	ra,8(sp)
    8001548a:	6402                	ld	s0,0(sp)
    8001548c:	0141                	addi	sp,sp,16
    8001548e:	8082                	ret

0000000080015490 <heap_check>:
static bool heap_check()
{
    80015490:	1101                	addi	sp,sp,-32
    80015492:	ec06                	sd	ra,24(sp)
    80015494:	e822                	sd	s0,16(sp)
    80015496:	e426                	sd	s1,8(sp)
    80015498:	1000                	addi	s0,sp,32
    return heap_max_blocks == heap_num_free() + heap_num_used() + heap_num_fresh();
    8001549a:	f85ff0ef          	jal	ra,8001541e <heap_num_free>
    8001549e:	84aa                	mv	s1,a0
    800154a0:	fa5ff0ef          	jal	ra,80015444 <heap_num_used>
    800154a4:	87aa                	mv	a5,a0
    800154a6:	94be                	add	s1,s1,a5
    800154a8:	fc3ff0ef          	jal	ra,8001546a <heap_num_fresh>
    800154ac:	87aa                	mv	a5,a0
    800154ae:	00f48733          	add	a4,s1,a5
    800154b2:	00010797          	auipc	a5,0x10
    800154b6:	bde78793          	addi	a5,a5,-1058 # 80025090 <heap_max_blocks>
    800154ba:	639c                	ld	a5,0(a5)
    800154bc:	40f707b3          	sub	a5,a4,a5
    800154c0:	0017b793          	seqz	a5,a5
    800154c4:	0ff7f793          	andi	a5,a5,255
}
    800154c8:	853e                	mv	a0,a5
    800154ca:	60e2                	ld	ra,24(sp)
    800154cc:	6442                	ld	s0,16(sp)
    800154ce:	64a2                	ld	s1,8(sp)
    800154d0:	6105                	addi	sp,sp,32
    800154d2:	8082                	ret

00000000800154d4 <heap_print_stats>:

void heap_print_stats(void)
{
    800154d4:	7179                	addi	sp,sp,-48
    800154d6:	f406                	sd	ra,40(sp)
    800154d8:	f022                	sd	s0,32(sp)
    800154da:	ec26                	sd	s1,24(sp)
    800154dc:	e84a                	sd	s2,16(sp)
    800154de:	e44e                	sd	s3,8(sp)
    800154e0:	1800                	addi	s0,sp,48
    debugf(
    800154e2:	f3dff0ef          	jal	ra,8001541e <heap_num_free>
    800154e6:	84aa                	mv	s1,a0
    800154e8:	f5dff0ef          	jal	ra,80015444 <heap_num_used>
    800154ec:	892a                	mv	s2,a0
    800154ee:	f7dff0ef          	jal	ra,8001546a <heap_num_fresh>
    800154f2:	89aa                	mv	s3,a0
        "HEAP\n~~~~\nFree blocks:    %lu\nUsed blocks:    %lu\nFresh blocks:   %lu\nHeap "
        "check:     %s\n",
        heap_num_free(), heap_num_used(), heap_num_fresh(), heap_check() ? "good" : "bad");
    800154f4:	f9dff0ef          	jal	ra,80015490 <heap_check>
    800154f8:	87aa                	mv	a5,a0
    debugf(
    800154fa:	c791                	beqz	a5,80015506 <heap_print_stats+0x32>
    800154fc:	00012797          	auipc	a5,0x12
    80015500:	c9478793          	addi	a5,a5,-876 # 80027190 <pow10.0+0x330>
    80015504:	a029                	j	8001550e <heap_print_stats+0x3a>
    80015506:	00012797          	auipc	a5,0x12
    8001550a:	c9278793          	addi	a5,a5,-878 # 80027198 <pow10.0+0x338>
    8001550e:	873e                	mv	a4,a5
    80015510:	86ce                	mv	a3,s3
    80015512:	864a                	mv	a2,s2
    80015514:	85a6                	mv	a1,s1
    80015516:	00012517          	auipc	a0,0x12
    8001551a:	c8a50513          	addi	a0,a0,-886 # 800271a0 <pow10.0+0x340>
    8001551e:	0c5060ef          	jal	ra,8001bde2 <debugf>
}
    80015522:	0001                	nop
    80015524:	70a2                	ld	ra,40(sp)
    80015526:	7402                	ld	s0,32(sp)
    80015528:	64e2                	ld	s1,24(sp)
    8001552a:	6942                	ld	s2,16(sp)
    8001552c:	69a2                	ld	s3,8(sp)
    8001552e:	6145                	addi	sp,sp,48
    80015530:	8082                	ret

0000000080015532 <kmalloc>:
void *kmalloc(size_t sz)
{
    80015532:	1101                	addi	sp,sp,-32
    80015534:	ec06                	sd	ra,24(sp)
    80015536:	e822                	sd	s0,16(sp)
    80015538:	1000                	addi	s0,sp,32
    8001553a:	fea43423          	sd	a0,-24(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kmalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return alloc(sz);
    8001553e:	fe843503          	ld	a0,-24(s0)
    80015542:	e19ff0ef          	jal	ra,8001535a <alloc>
    80015546:	87aa                	mv	a5,a0
}
    80015548:	853e                	mv	a0,a5
    8001554a:	60e2                	ld	ra,24(sp)
    8001554c:	6442                	ld	s0,16(sp)
    8001554e:	6105                	addi	sp,sp,32
    80015550:	8082                	ret

0000000080015552 <kcalloc>:
void *kcalloc(size_t n, size_t sz)
{
    80015552:	1101                	addi	sp,sp,-32
    80015554:	ec06                	sd	ra,24(sp)
    80015556:	e822                	sd	s0,16(sp)
    80015558:	1000                	addi	s0,sp,32
    8001555a:	fea43423          	sd	a0,-24(s0)
    8001555e:	feb43023          	sd	a1,-32(s0)
#ifdef DEBUG_KMALLOC
    debugf("[kcalloc]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return calloc(n, sz);
    80015562:	fe043583          	ld	a1,-32(s0)
    80015566:	fe843503          	ld	a0,-24(s0)
    8001556a:	e23ff0ef          	jal	ra,8001538c <calloc>
    8001556e:	87aa                	mv	a5,a0
}
    80015570:	853e                	mv	a0,a5
    80015572:	60e2                	ld	ra,24(sp)
    80015574:	6442                	ld	s0,16(sp)
    80015576:	6105                	addi	sp,sp,32
    80015578:	8082                	ret

000000008001557a <kfree>:
void kfree(void *m)
{
    8001557a:	1101                	addi	sp,sp,-32
    8001557c:	ec06                	sd	ra,24(sp)
    8001557e:	e822                	sd	s0,16(sp)
    80015580:	1000                	addi	s0,sp,32
    80015582:	fea43423          	sd	a0,-24(s0)
    if (m != NULL) {
    80015586:	fe843783          	ld	a5,-24(s0)
    8001558a:	c789                	beqz	a5,80015594 <kfree+0x1a>
        free(m);
    8001558c:	fe843503          	ld	a0,-24(s0)
    80015590:	ac9ff0ef          	jal	ra,80015058 <free>
    }
#ifdef DEBUG_KMALLOC
    debugf("[kfree]: %lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
}
    80015594:	0001                	nop
    80015596:	60e2                	ld	ra,24(sp)
    80015598:	6442                	ld	s0,16(sp)
    8001559a:	6105                	addi	sp,sp,32
    8001559c:	8082                	ret

000000008001559e <heap_init>:

void heap_init(void)
{
    8001559e:	1101                	addi	sp,sp,-32
    800155a0:	ec06                	sd	ra,24(sp)
    800155a2:	e822                	sd	s0,16(sp)
    800155a4:	1000                	addi	s0,sp,32
#ifdef DEBUG_HEAP
    debugf("[heap_init]: Prior to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif
    void *start = page_znalloc(KERNEL_HEAP_PAGES);
    800155a6:	6505                	lui	a0,0x1
    800155a8:	1df080ef          	jal	ra,8001df86 <page_znalloc>
    800155ac:	fea43423          	sd	a0,-24(s0)
    debugf("[heap_init]: Heap start at 0x%08lx\n", start);
    debugf("[heap_init]: After to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif

    mmu_map_range(kernel_mmu_table, KERNEL_HEAP_START_VADDR, KERNEL_HEAP_END_VADDR, (uint64_t)start,
    800155b0:	00010797          	auipc	a5,0x10
    800155b4:	a5878793          	addi	a5,a5,-1448 # 80025008 <kernel_mmu_table>
    800155b8:	6388                	ld	a0,0(a5)
    800155ba:	fe843683          	ld	a3,-24(s0)
    800155be:	4799                	li	a5,6
    800155c0:	4701                	li	a4,0
    800155c2:	00e08637          	lui	a2,0xe08
    800155c6:	7f760613          	addi	a2,a2,2039 # e087f7 <i+0xe087d7>
    800155ca:	0636                	slli	a2,a2,0xd
    800155cc:	00e085b7          	lui	a1,0xe08
    800155d0:	15dd                	addi	a1,a1,-9
    800155d2:	05b6                	slli	a1,a1,0xd
    800155d4:	4dc000ef          	jal	ra,80015ab0 <mmu_map_range>
                  MMU_LEVEL_4K, PB_READ | PB_WRITE);
    init((void *)KERNEL_HEAP_START_VADDR, (void *)KERNEL_HEAP_END_VADDR, KERNEL_HEAP_PAGES / 4, 16,
    800155d8:	4721                	li	a4,8
    800155da:	46c1                	li	a3,16
    800155dc:	40000613          	li	a2,1024
    800155e0:	00e087b7          	lui	a5,0xe08
    800155e4:	7f778793          	addi	a5,a5,2039 # e087f7 <i+0xe087d7>
    800155e8:	00d79593          	slli	a1,a5,0xd
    800155ec:	00e087b7          	lui	a5,0xe08
    800155f0:	17dd                	addi	a5,a5,-9
    800155f2:	00d79513          	slli	a0,a5,0xd
    800155f6:	94bff0ef          	jal	ra,80014f40 <init>
         8);

}
    800155fa:	0001                	nop
    800155fc:	60e2                	ld	ra,24(sp)
    800155fe:	6442                	ld	s0,16(sp)
    80015600:	6105                	addi	sp,sp,32
    80015602:	8082                	ret

0000000080015604 <mutex_trylock>:
#include <config.h>
#include <lock.h>
#include <compiler.h>

bool mutex_trylock(Mutex *mutex)
{
    80015604:	7179                	addi	sp,sp,-48
    80015606:	f422                	sd	s0,40(sp)
    80015608:	1800                	addi	s0,sp,48
    8001560a:	fca43c23          	sd	a0,-40(s0)
    int old;
    asm volatile("amoswap.w.aq %0, %1, (%2)" : "=r"(old) : "r"(MUTEX_LOCKED), "r"(mutex));
    8001560e:	4785                	li	a5,1
    80015610:	fd843703          	ld	a4,-40(s0)
    80015614:	0cf727af          	amoswap.w.aq	a5,a5,(a4)
    80015618:	fef42623          	sw	a5,-20(s0)
    // If old == MUTEX_LOCKED, that means the mutex was already
    // locked when we tried to lock it. That means we didn't acquire
    // it.
    return old != MUTEX_LOCKED;
    8001561c:	fec42783          	lw	a5,-20(s0)
    80015620:	0007871b          	sext.w	a4,a5
    80015624:	4785                	li	a5,1
    80015626:	40f707b3          	sub	a5,a4,a5
    8001562a:	00f037b3          	snez	a5,a5
    8001562e:	0ff7f793          	andi	a5,a5,255
}
    80015632:	853e                	mv	a0,a5
    80015634:	7422                	ld	s0,40(sp)
    80015636:	6145                	addi	sp,sp,48
    80015638:	8082                	ret

000000008001563a <mutex_spinlock>:

void mutex_spinlock(Mutex *mutex)
{
    8001563a:	1101                	addi	sp,sp,-32
    8001563c:	ec06                	sd	ra,24(sp)
    8001563e:	e822                	sd	s0,16(sp)
    80015640:	1000                	addi	s0,sp,32
    80015642:	fea43423          	sd	a0,-24(s0)
    while (!mutex_trylock(mutex))
    80015646:	0001                	nop
    80015648:	fe843503          	ld	a0,-24(s0)
    8001564c:	fb9ff0ef          	jal	ra,80015604 <mutex_trylock>
    80015650:	87aa                	mv	a5,a0
    80015652:	0017c793          	xori	a5,a5,1
    80015656:	0ff7f793          	andi	a5,a5,255
    8001565a:	f7fd                	bnez	a5,80015648 <mutex_spinlock+0xe>
        ;
}
    8001565c:	0001                	nop
    8001565e:	0001                	nop
    80015660:	60e2                	ld	ra,24(sp)
    80015662:	6442                	ld	s0,16(sp)
    80015664:	6105                	addi	sp,sp,32
    80015666:	8082                	ret

0000000080015668 <mutex_unlock>:

void mutex_unlock(Mutex *mutex)
{
    80015668:	1101                	addi	sp,sp,-32
    8001566a:	ec22                	sd	s0,24(sp)
    8001566c:	1000                	addi	s0,sp,32
    8001566e:	fea43423          	sd	a0,-24(s0)
    asm volatile("amoswap.w.rl zero, zero, (%0)" : : "r"(mutex));
    80015672:	fe843783          	ld	a5,-24(s0)
    80015676:	0a07a02f          	amoswap.w.rl	zero,zero,(a5)
}
    8001567a:	0001                	nop
    8001567c:	6462                	ld	s0,24(sp)
    8001567e:	6105                	addi	sp,sp,32
    80015680:	8082                	ret

0000000080015682 <mmu_table_create>:
#endif



PageTable *mmu_table_create(void)
{
    80015682:	1141                	addi	sp,sp,-16
    80015684:	e406                	sd	ra,8(sp)
    80015686:	e022                	sd	s0,0(sp)
    80015688:	0800                	addi	s0,sp,16
    return page_zalloc();
    8001568a:	4505                	li	a0,1
    8001568c:	0fb080ef          	jal	ra,8001df86 <page_znalloc>
    80015690:	87aa                	mv	a5,a0
}
    80015692:	853e                	mv	a0,a5
    80015694:	60a2                	ld	ra,8(sp)
    80015696:	6402                	ld	s0,0(sp)
    80015698:	0141                	addi	sp,sp,16
    8001569a:	8082                	ret

000000008001569c <is_valid>:

// Check the valid bit of a page table entry.
static inline bool is_valid(unsigned long pte)
{
    8001569c:	1101                	addi	sp,sp,-32
    8001569e:	ec22                	sd	s0,24(sp)
    800156a0:	1000                	addi	s0,sp,32
    800156a2:	fea43423          	sd	a0,-24(s0)
    return pte & 1UL;
    800156a6:	fe843783          	ld	a5,-24(s0)
    800156aa:	8b85                	andi	a5,a5,1
    800156ac:	00f037b3          	snez	a5,a5
    800156b0:	0ff7f793          	andi	a5,a5,255
}
    800156b4:	853e                	mv	a0,a5
    800156b6:	6462                	ld	s0,24(sp)
    800156b8:	6105                	addi	sp,sp,32
    800156ba:	8082                	ret

00000000800156bc <is_leaf>:

// Check if a page table entry is a leaf, return false if it's a branch.
static inline bool is_leaf(unsigned long pte)
{
    800156bc:	1101                	addi	sp,sp,-32
    800156be:	ec22                	sd	s0,24(sp)
    800156c0:	1000                	addi	s0,sp,32
    800156c2:	fea43423          	sd	a0,-24(s0)
    return (pte & 0xE) != 0;
    800156c6:	fe843783          	ld	a5,-24(s0)
    800156ca:	8bb9                	andi	a5,a5,14
    800156cc:	00f037b3          	snez	a5,a5
    800156d0:	0ff7f793          	andi	a5,a5,255
}
    800156d4:	853e                	mv	a0,a5
    800156d6:	6462                	ld	s0,24(sp)
    800156d8:	6105                	addi	sp,sp,32
    800156da:	8082                	ret

00000000800156dc <mmu_map>:

bool mmu_map(PageTable *tab, uint64_t vaddr, uint64_t paddr, uint8_t lvl, uint64_t bits)
{
    800156dc:	7135                	addi	sp,sp,-160
    800156de:	ed06                	sd	ra,152(sp)
    800156e0:	e922                	sd	s0,144(sp)
    800156e2:	1100                	addi	s0,sp,160
    800156e4:	f8a43423          	sd	a0,-120(s0)
    800156e8:	f8b43023          	sd	a1,-128(s0)
    800156ec:	f6c43c23          	sd	a2,-136(s0)
    800156f0:	87b6                	mv	a5,a3
    800156f2:	f6e43423          	sd	a4,-152(s0)
    800156f6:	f6f40ba3          	sb	a5,-137(s0)
    if (tab == NULL || lvl > MMU_LEVEL_1G || (bits & 0xE) == 0) {
    800156fa:	f8843783          	ld	a5,-120(s0)
    800156fe:	cf81                	beqz	a5,80015716 <mmu_map+0x3a>
    80015700:	f7744783          	lbu	a5,-137(s0)
    80015704:	0ff7f713          	andi	a4,a5,255
    80015708:	4789                	li	a5,2
    8001570a:	00e7e663          	bltu	a5,a4,80015716 <mmu_map+0x3a>
    8001570e:	f6843783          	ld	a5,-152(s0)
    80015712:	8bb9                	andi	a5,a5,14
    80015714:	e399                	bnez	a5,8001571a <mmu_map+0x3e>
        debugf("mmu_map: invalid argument");
        return false;
    80015716:	4781                	li	a5,0
    80015718:	aab9                	j	80015876 <mmu_map+0x19a>

    debugf("mmu_map: page table at 0x%08lx\n", tab);
    debugf("mmu_map: vaddr == 0x%08lx\n", vaddr);
    debugf("mmu_map: paddr == 0x%08lx\n", paddr);

    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    8001571a:	f8043783          	ld	a5,-128(s0)
    8001571e:	83b1                	srli	a5,a5,0xc
    80015720:	1ff7f793          	andi	a5,a5,511
    80015724:	faf43823          	sd	a5,-80(s0)
    80015728:	f8043783          	ld	a5,-128(s0)
    8001572c:	83d5                	srli	a5,a5,0x15
    8001572e:	1ff7f793          	andi	a5,a5,511
    80015732:	faf43c23          	sd	a5,-72(s0)
                            (vaddr >> ADDR_2_BIT) & 0x1FF};
    80015736:	f8043783          	ld	a5,-128(s0)
    8001573a:	83f9                	srli	a5,a5,0x1e
    8001573c:	1ff7f793          	andi	a5,a5,511
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80015740:	fcf43023          	sd	a5,-64(s0)
    debugf("mmu_map: vpn = {%d, %d, %d}\n", vpn[0], vpn[1], vpn[2]);
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80015744:	f7843783          	ld	a5,-136(s0)
    80015748:	83b1                	srli	a5,a5,0xc
    8001574a:	1ff7f793          	andi	a5,a5,511
    8001574e:	f8f43c23          	sd	a5,-104(s0)
    80015752:	f7843783          	ld	a5,-136(s0)
    80015756:	83d5                	srli	a5,a5,0x15
    80015758:	1ff7f793          	andi	a5,a5,511
    8001575c:	faf43023          	sd	a5,-96(s0)
                            (paddr >> ADDR_2_BIT) & 0x3FFFFFF};
    80015760:	f7843783          	ld	a5,-136(s0)
    80015764:	01e7d713          	srli	a4,a5,0x1e
    80015768:	040007b7          	lui	a5,0x4000
    8001576c:	17fd                	addi	a5,a5,-1
    8001576e:	8ff9                	and	a5,a5,a4
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80015770:	faf43423          	sd	a5,-88(s0)

    int i;
    PageTable *pt = tab;
    80015774:	f8843783          	ld	a5,-120(s0)
    80015778:	fef43023          	sd	a5,-32(s0)

    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    8001577c:	4789                	li	a5,2
    8001577e:	fef42623          	sw	a5,-20(s0)
    80015782:	a871                	j	8001581e <mmu_map+0x142>
        unsigned long pte = pt->entries[vpn[i]];
    80015784:	fec42783          	lw	a5,-20(s0)
    80015788:	078e                	slli	a5,a5,0x3
    8001578a:	ff040713          	addi	a4,s0,-16
    8001578e:	97ba                	add	a5,a5,a4
    80015790:	fc07b783          	ld	a5,-64(a5) # 3ffffc0 <i+0x3ffffa0>
    80015794:	fe043703          	ld	a4,-32(s0)
    80015798:	078e                	slli	a5,a5,0x3
    8001579a:	97ba                	add	a5,a5,a4
    8001579c:	639c                	ld	a5,0(a5)
    8001579e:	fcf43823          	sd	a5,-48(s0)

        if (!is_valid(pte)) {
    800157a2:	fd043503          	ld	a0,-48(s0)
    800157a6:	ef7ff0ef          	jal	ra,8001569c <is_valid>
    800157aa:	87aa                	mv	a5,a0
    800157ac:	0017c793          	xori	a5,a5,1
    800157b0:	0ff7f793          	andi	a5,a5,255
    800157b4:	cf8d                	beqz	a5,800157ee <mmu_map+0x112>
            debugf("mmu_map: entry %d in page table at 0x%08lx is invalid\n", vpn[i], pt);
            PageTable *new_pt = mmu_table_create();
    800157b6:	ecdff0ef          	jal	ra,80015682 <mmu_table_create>
    800157ba:	fca43423          	sd	a0,-56(s0)
            if (new_pt == NULL) {
    800157be:	fc843783          	ld	a5,-56(s0)
    800157c2:	e399                	bnez	a5,800157c8 <mmu_map+0xec>
                debugf("mmu_map: mmu_table_create returned null");
                return false;
    800157c4:	4781                	li	a5,0
    800157c6:	a845                	j	80015876 <mmu_map+0x19a>
            }
            debugf("mmu_map: create a new page table at 0x%08lx\n", new_pt);
            if (pt->entries[vpn[i]]) {
                debugf("Warning: overwriting page table entry at 0x%08lx = %p\n", &pt->entries[vpn[i]], pt->entries[vpn[i]]);
            }
            pt->entries[vpn[i]] = (unsigned long)new_pt >> 2 | PB_VALID;
    800157c8:	fc843783          	ld	a5,-56(s0)
    800157cc:	0027d713          	srli	a4,a5,0x2
    800157d0:	fec42783          	lw	a5,-20(s0)
    800157d4:	078e                	slli	a5,a5,0x3
    800157d6:	ff040693          	addi	a3,s0,-16
    800157da:	97b6                	add	a5,a5,a3
    800157dc:	fc07b783          	ld	a5,-64(a5)
    800157e0:	00176713          	ori	a4,a4,1
    800157e4:	fe043683          	ld	a3,-32(s0)
    800157e8:	078e                	slli	a5,a5,0x3
    800157ea:	97b6                	add	a5,a5,a3
    800157ec:	e398                	sd	a4,0(a5)
            debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d branch to 0x%08lx\n", vpn[i], pt, i, new_pt);
        } else {
            debugf("mmu_map: entry %d in page table at 0x%08lx is valid\n", vpn[i], pt);
        }
        pt = (PageTable*)((pt->entries[vpn[i]] & ~0x3FF) << 2);
    800157ee:	fec42783          	lw	a5,-20(s0)
    800157f2:	078e                	slli	a5,a5,0x3
    800157f4:	ff040713          	addi	a4,s0,-16
    800157f8:	97ba                	add	a5,a5,a4
    800157fa:	fc07b783          	ld	a5,-64(a5)
    800157fe:	fe043703          	ld	a4,-32(s0)
    80015802:	078e                	slli	a5,a5,0x3
    80015804:	97ba                	add	a5,a5,a4
    80015806:	639c                	ld	a5,0(a5)
    80015808:	00279713          	slli	a4,a5,0x2
    8001580c:	77fd                	lui	a5,0xfffff
    8001580e:	8ff9                	and	a5,a5,a4
    80015810:	fef43023          	sd	a5,-32(s0)
    for (i = MMU_LEVEL_1G; i > lvl; i--) {
    80015814:	fec42783          	lw	a5,-20(s0)
    80015818:	37fd                	addiw	a5,a5,-1
    8001581a:	fef42623          	sw	a5,-20(s0)
    8001581e:	f7744783          	lbu	a5,-137(s0)
    80015822:	0007871b          	sext.w	a4,a5
    80015826:	fec42783          	lw	a5,-20(s0)
    8001582a:	2781                	sext.w	a5,a5
    8001582c:	f4f74ce3          	blt	a4,a5,80015784 <mmu_map+0xa8>
    }

    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80015830:	fa843783          	ld	a5,-88(s0)
    80015834:	01c79713          	slli	a4,a5,0x1c
                             ppn[1] << PTE_PPN1_BIT |
    80015838:	fa043783          	ld	a5,-96(s0)
    8001583c:	07ce                	slli	a5,a5,0x13
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    8001583e:	8f5d                	or	a4,a4,a5
                             ppn[0] << PTE_PPN0_BIT;
    80015840:	f9843783          	ld	a5,-104(s0)
    80015844:	07aa                	slli	a5,a5,0xa
    unsigned long ppn_leaf = ppn[2] << PTE_PPN2_BIT |
    80015846:	8fd9                	or	a5,a5,a4
    80015848:	fcf43c23          	sd	a5,-40(s0)
    
    debugf("mmu_map: ppn_leaf == 0x%x\n", (ppn_leaf << 2));
    if (pt->entries[vpn[i]] != (ppn_leaf | bits | PB_VALID) && pt->entries[vpn[i]] != 0) {
        debugf("Warning: overwriting page table entry at 0x%08lx (was %p, now %p)\n", &pt->entries[vpn[i]], pt->entries[vpn[i]], ppn_leaf | bits | PB_VALID);
    }
    pt->entries[vpn[i]] = ppn_leaf | bits | PB_VALID;
    8001584c:	fd843703          	ld	a4,-40(s0)
    80015850:	f6843783          	ld	a5,-152(s0)
    80015854:	8f5d                	or	a4,a4,a5
    80015856:	fec42783          	lw	a5,-20(s0)
    8001585a:	078e                	slli	a5,a5,0x3
    8001585c:	ff040693          	addi	a3,s0,-16
    80015860:	97b6                	add	a5,a5,a3
    80015862:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    80015866:	00176713          	ori	a4,a4,1
    8001586a:	fe043683          	ld	a3,-32(s0)
    8001586e:	078e                	slli	a5,a5,0x3
    80015870:	97b6                	add	a5,a5,a3
    80015872:	e398                	sd	a4,0(a5)

    debugf("mmu_map: set bits of address 0x%08lx to 0x%08lx\n", &pt->entries[vpn[i]], ppn_leaf | bits | PB_VALID);

    debugf("mmu_map: set entry %d in page table at 0x%08lx as lvl %d leaf to 0x%08lx\n", vpn[i], pt, i, ppn_leaf << 2);
    return true;
    80015874:	4785                	li	a5,1
}
    80015876:	853e                	mv	a0,a5
    80015878:	60ea                	ld	ra,152(sp)
    8001587a:	644a                	ld	s0,144(sp)
    8001587c:	610d                	addi	sp,sp,160
    8001587e:	8082                	ret

0000000080015880 <mmu_free>:

void mmu_free(PageTable *tab) 
{ 
    80015880:	7179                	addi	sp,sp,-48
    80015882:	f406                	sd	ra,40(sp)
    80015884:	f022                	sd	s0,32(sp)
    80015886:	1800                	addi	s0,sp,48
    80015888:	fca43c23          	sd	a0,-40(s0)
    uint64_t entry; 
    int i; 

    if (tab == NULL) { 
    8001588c:	fd843783          	ld	a5,-40(s0)
    80015890:	c7b5                	beqz	a5,800158fc <mmu_free+0x7c>
        return; 
    } 

    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    80015892:	fe042623          	sw	zero,-20(s0)
    80015896:	a0a1                	j	800158de <mmu_free+0x5e>
        entry = tab->entries[i]; 
    80015898:	fd843703          	ld	a4,-40(s0)
    8001589c:	fec42783          	lw	a5,-20(s0)
    800158a0:	078e                	slli	a5,a5,0x3
    800158a2:	97ba                	add	a5,a5,a4
    800158a4:	639c                	ld	a5,0(a5)
    800158a6:	fef43023          	sd	a5,-32(s0)
        if (entry & PB_VALID) {
    800158aa:	fe043783          	ld	a5,-32(s0)
    800158ae:	8b85                	andi	a5,a5,1
    800158b0:	cb91                	beqz	a5,800158c4 <mmu_free+0x44>
            mmu_free((PageTable *)((entry & ~0x3FF) << 2)); // Recurse into the next level
    800158b2:	fe043783          	ld	a5,-32(s0)
    800158b6:	00279713          	slli	a4,a5,0x2
    800158ba:	77fd                	lui	a5,0xfffff
    800158bc:	8ff9                	and	a5,a5,a4
    800158be:	853e                	mv	a0,a5
    800158c0:	fc1ff0ef          	jal	ra,80015880 <mmu_free>
        }
        tab->entries[i] = 0; 
    800158c4:	fd843703          	ld	a4,-40(s0)
    800158c8:	fec42783          	lw	a5,-20(s0)
    800158cc:	078e                	slli	a5,a5,0x3
    800158ce:	97ba                	add	a5,a5,a4
    800158d0:	0007b023          	sd	zero,0(a5) # fffffffffffff000 <_heap_end+0xffffffff77fef000>
    for (i = 0; i < (PAGE_SIZE / 8); i++) { 
    800158d4:	fec42783          	lw	a5,-20(s0)
    800158d8:	2785                	addiw	a5,a5,1
    800158da:	fef42623          	sw	a5,-20(s0)
    800158de:	fec42783          	lw	a5,-20(s0)
    800158e2:	0007871b          	sext.w	a4,a5
    800158e6:	1ff00793          	li	a5,511
    800158ea:	fae7d7e3          	bge	a5,a4,80015898 <mmu_free+0x18>
    } 

    page_free(tab); 
    800158ee:	fd843503          	ld	a0,-40(s0)
    800158f2:	730080ef          	jal	ra,8001e022 <page_free>
    SFENCE_ALL();
    800158f6:	12000073          	sfence.vma
    800158fa:	a011                	j	800158fe <mmu_free+0x7e>
        return; 
    800158fc:	0001                	nop
}
    800158fe:	70a2                	ld	ra,40(sp)
    80015900:	7402                	ld	s0,32(sp)
    80015902:	6145                	addi	sp,sp,48
    80015904:	8082                	ret

0000000080015906 <mmu_translate>:

uint64_t mmu_translate(const PageTable *tab, uint64_t vaddr) 
{ 
    80015906:	711d                	addi	sp,sp,-96
    80015908:	ec86                	sd	ra,88(sp)
    8001590a:	e8a2                	sd	s0,80(sp)
    8001590c:	1080                	addi	s0,sp,96
    8001590e:	faa43423          	sd	a0,-88(s0)
    80015912:	fab43023          	sd	a1,-96(s0)

    debugf("mmu_translate: page table at 0x%016lx\n", tab);
    debugf("mmu_translate: vaddr == 0x%016lx\n", vaddr);

    if (tab == NULL) { 
    80015916:	fa843783          	ld	a5,-88(s0)
    8001591a:	e399                	bnez	a5,80015920 <mmu_translate+0x1a>
        debugf("mmu_translate: tab == NULL\n");
        return MMU_TRANSLATE_PAGE_FAULT; 
    8001591c:	57fd                	li	a5,-1
    8001591e:	aab1                	j	80015a7a <mmu_translate+0x174>
    } 

    // Extract the virtual page numbers
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80015920:	fa043783          	ld	a5,-96(s0)
    80015924:	83b1                	srli	a5,a5,0xc
    80015926:	1ff7f793          	andi	a5,a5,511
    8001592a:	faf43823          	sd	a5,-80(s0)
                      (vaddr >> ADDR_1_BIT) & 0x1FF, 
    8001592e:	fa043783          	ld	a5,-96(s0)
    80015932:	83d5                	srli	a5,a5,0x15
    80015934:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80015938:	faf43c23          	sd	a5,-72(s0)
                      (vaddr >> ADDR_2_BIT) & 0x1FF};
    8001593c:	fa043783          	ld	a5,-96(s0)
    80015940:	83f9                	srli	a5,a5,0x1e
    80015942:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, 
    80015946:	fcf43023          	sd	a5,-64(s0)
    debugf("mmu_translate: vpn[0] == 0x%03lx\n", vpn[0]);
    debugf("mmu_translate: vpn[1] == 0x%03lx\n", vpn[1]);
    debugf("mmu_translate: vpn[2] == 0x%03lx\n", vpn[2]);

    uint64_t lvl = MMU_LEVEL_1G;
    8001594a:	4789                	li	a5,2
    8001594c:	fef43423          	sd	a5,-24(s0)
    // Traverse the page table hierarchy using the virtual page numbers
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    80015950:	4789                	li	a5,2
    80015952:	fef42223          	sw	a5,-28(s0)
    80015956:	a075                	j	80015a02 <mmu_translate+0xfc>
        // Iterate through and print the page table entries
        debugf("mmu_translate: tab->entries == 0x%08lx\n", tab->entries);
        for (int j = 0; j < (PAGE_SIZE / 8); j++) {
    80015958:	fe042023          	sw	zero,-32(s0)
    8001595c:	a031                	j	80015968 <mmu_translate+0x62>
    8001595e:	fe042783          	lw	a5,-32(s0)
    80015962:	2785                	addiw	a5,a5,1
    80015964:	fef42023          	sw	a5,-32(s0)
    80015968:	fe042783          	lw	a5,-32(s0)
    8001596c:	0007871b          	sext.w	a4,a5
    80015970:	1ff00793          	li	a5,511
    80015974:	fee7d5e3          	bge	a5,a4,8001595e <mmu_translate+0x58>
            if (tab->entries[j] & PB_VALID) {
                debugf("mmu_translate: tab->entries[%x] == 0x%0lx\n", j, tab->entries[j]);
            }
        }

        if (!(tab->entries[vpn[i]] & PB_VALID)) {
    80015978:	fe442783          	lw	a5,-28(s0)
    8001597c:	078e                	slli	a5,a5,0x3
    8001597e:	ff040713          	addi	a4,s0,-16
    80015982:	97ba                	add	a5,a5,a4
    80015984:	fc07b783          	ld	a5,-64(a5)
    80015988:	fa843703          	ld	a4,-88(s0)
    8001598c:	078e                	slli	a5,a5,0x3
    8001598e:	97ba                	add	a5,a5,a4
    80015990:	639c                	ld	a5,0(a5)
    80015992:	8b85                	andi	a5,a5,1
    80015994:	e399                	bnez	a5,8001599a <mmu_translate+0x94>
            debugf("mmu_translate: entry %x in page table at 0x%08lx is invalid\n", vpn[i], tab);
            return MMU_TRANSLATE_PAGE_FAULT; // Entry is not valid
    80015996:	57fd                	li	a5,-1
    80015998:	a0cd                	j	80015a7a <mmu_translate+0x174>
        } else if (!is_leaf(tab->entries[vpn[i]])) {
    8001599a:	fe442783          	lw	a5,-28(s0)
    8001599e:	078e                	slli	a5,a5,0x3
    800159a0:	ff040713          	addi	a4,s0,-16
    800159a4:	97ba                	add	a5,a5,a4
    800159a6:	fc07b783          	ld	a5,-64(a5)
    800159aa:	fa843703          	ld	a4,-88(s0)
    800159ae:	078e                	slli	a5,a5,0x3
    800159b0:	97ba                	add	a5,a5,a4
    800159b2:	639c                	ld	a5,0(a5)
    800159b4:	853e                	mv	a0,a5
    800159b6:	d07ff0ef          	jal	ra,800156bc <is_leaf>
    800159ba:	87aa                	mv	a5,a0
    800159bc:	0017c793          	xori	a5,a5,1
    800159c0:	0ff7f793          	andi	a5,a5,255
    800159c4:	c78d                	beqz	a5,800159ee <mmu_translate+0xe8>
            debugf("mmu_translate: entry %x in page table at 0x%08lx is a branch to 0x%08lx\n", vpn[i], tab, (tab->entries[vpn[i]] & ~0x3FF) << 2);
            tab = (PageTable *)((tab->entries[vpn[i]] & ~0x3FF) << 2);
    800159c6:	fe442783          	lw	a5,-28(s0)
    800159ca:	078e                	slli	a5,a5,0x3
    800159cc:	ff040713          	addi	a4,s0,-16
    800159d0:	97ba                	add	a5,a5,a4
    800159d2:	fc07b783          	ld	a5,-64(a5)
    800159d6:	fa843703          	ld	a4,-88(s0)
    800159da:	078e                	slli	a5,a5,0x3
    800159dc:	97ba                	add	a5,a5,a4
    800159de:	639c                	ld	a5,0(a5)
    800159e0:	00279713          	slli	a4,a5,0x2
    800159e4:	77fd                	lui	a5,0xfffff
    800159e6:	8ff9                	and	a5,a5,a4
    800159e8:	faf43423          	sd	a5,-88(s0)
    800159ec:	a031                	j	800159f8 <mmu_translate+0xf2>
        } else {
            debugf("mmu_translate: entry %x in page table at 0x%08lx is a leaf\n", vpn[i], tab);
            lvl = i;
    800159ee:	fe442783          	lw	a5,-28(s0)
    800159f2:	fef43423          	sd	a5,-24(s0)
            break; // Entry is a leaf
    800159f6:	a819                	j	80015a0c <mmu_translate+0x106>
    for (int i = MMU_LEVEL_1G; i >= MMU_LEVEL_4K; i--) {
    800159f8:	fe442783          	lw	a5,-28(s0)
    800159fc:	37fd                	addiw	a5,a5,-1
    800159fe:	fef42223          	sw	a5,-28(s0)
    80015a02:	fe442783          	lw	a5,-28(s0)
    80015a06:	2781                	sext.w	a5,a5
    80015a08:	f407d8e3          	bgez	a5,80015958 <mmu_translate+0x52>
        }
    }

    debugf("mmu_translate: vaddr == 0x%08lx\n", vaddr);

    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    80015a0c:	fe843783          	ld	a5,-24(s0)
    80015a10:	2781                	sext.w	a5,a5
    80015a12:	873e                	mv	a4,a5
    80015a14:	87ba                	mv	a5,a4
    80015a16:	0037979b          	slliw	a5,a5,0x3
    80015a1a:	9fb9                	addw	a5,a5,a4
    80015a1c:	2781                	sext.w	a5,a5
    80015a1e:	27b1                	addiw	a5,a5,12
    80015a20:	2781                	sext.w	a5,a5
    80015a22:	4705                	li	a4,1
    80015a24:	00f717bb          	sllw	a5,a4,a5
    80015a28:	2781                	sext.w	a5,a5
    80015a2a:	37fd                	addiw	a5,a5,-1
    80015a2c:	2781                	sext.w	a5,a5
    80015a2e:	fcf43c23          	sd	a5,-40(s0)
    
    // Extract the physical address from the final page table entry
    uint64_t paddr = ((tab->entries[vpn[lvl]] & ~0x3FF) << 2) & ~page_mask;
    80015a32:	fe843783          	ld	a5,-24(s0)
    80015a36:	078e                	slli	a5,a5,0x3
    80015a38:	ff040713          	addi	a4,s0,-16
    80015a3c:	97ba                	add	a5,a5,a4
    80015a3e:	fc07b783          	ld	a5,-64(a5) # ffffffffffffefc0 <_heap_end+0xffffffff77feefc0>
    80015a42:	fa843703          	ld	a4,-88(s0)
    80015a46:	078e                	slli	a5,a5,0x3
    80015a48:	97ba                	add	a5,a5,a4
    80015a4a:	639c                	ld	a5,0(a5)
    80015a4c:	00279713          	slli	a4,a5,0x2
    80015a50:	fd843783          	ld	a5,-40(s0)
    80015a54:	fff7c793          	not	a5,a5
    80015a58:	8f7d                	and	a4,a4,a5
    80015a5a:	77fd                	lui	a5,0xfffff
    80015a5c:	8ff9                	and	a5,a5,a4
    80015a5e:	fcf43823          	sd	a5,-48(s0)

    uint64_t result = paddr | (vaddr & page_mask);
    80015a62:	fa043703          	ld	a4,-96(s0)
    80015a66:	fd843783          	ld	a5,-40(s0)
    80015a6a:	8ff9                	and	a5,a5,a4
    80015a6c:	fd043703          	ld	a4,-48(s0)
    80015a70:	8fd9                	or	a5,a5,a4
    80015a72:	fcf43423          	sd	a5,-56(s0)
    debugf("mmu_translate: paddr == 0x%08lx\n", result);

    return result; // Combine with the offset within the page
    80015a76:	fc843783          	ld	a5,-56(s0)
}
    80015a7a:	853e                	mv	a0,a5
    80015a7c:	60e6                	ld	ra,88(sp)
    80015a7e:	6446                	ld	s0,80(sp)
    80015a80:	6125                	addi	sp,sp,96
    80015a82:	8082                	ret

0000000080015a84 <kernel_mmu_translate>:

uint64_t kernel_mmu_translate(uint64_t vaddr) 
{ 
    80015a84:	1101                	addi	sp,sp,-32
    80015a86:	ec06                	sd	ra,24(sp)
    80015a88:	e822                	sd	s0,16(sp)
    80015a8a:	1000                	addi	s0,sp,32
    80015a8c:	fea43423          	sd	a0,-24(s0)
    return mmu_translate(kernel_mmu_table, vaddr); 
    80015a90:	0000f797          	auipc	a5,0xf
    80015a94:	57878793          	addi	a5,a5,1400 # 80025008 <kernel_mmu_table>
    80015a98:	639c                	ld	a5,0(a5)
    80015a9a:	fe843583          	ld	a1,-24(s0)
    80015a9e:	853e                	mv	a0,a5
    80015aa0:	e67ff0ef          	jal	ra,80015906 <mmu_translate>
    80015aa4:	87aa                	mv	a5,a0
}
    80015aa6:	853e                	mv	a0,a5
    80015aa8:	60e2                	ld	ra,24(sp)
    80015aaa:	6442                	ld	s0,16(sp)
    80015aac:	6105                	addi	sp,sp,32
    80015aae:	8082                	ret

0000000080015ab0 <mmu_map_range>:
                       uint64_t start_virt, 
                       uint64_t end_virt, 
                       uint64_t start_phys,
                       uint8_t lvl, 
                       uint64_t bits)
{
    80015ab0:	711d                	addi	sp,sp,-96
    80015ab2:	ec86                	sd	ra,88(sp)
    80015ab4:	e8a2                	sd	s0,80(sp)
    80015ab6:	1080                	addi	s0,sp,96
    80015ab8:	fca43423          	sd	a0,-56(s0)
    80015abc:	fcb43023          	sd	a1,-64(s0)
    80015ac0:	fac43c23          	sd	a2,-72(s0)
    80015ac4:	fad43823          	sd	a3,-80(s0)
    80015ac8:	faf43023          	sd	a5,-96(s0)
    80015acc:	87ba                	mv	a5,a4
    80015ace:	faf407a3          	sb	a5,-81(s0)
    debugf("mmu_map_range: page table at 0x%08lx\n", tab);
    debugf("mmu_map_range: start_virt = 0x%08lx\n", start_virt);
    debugf("mmu_map_range: start_phys = 0x%08lx\n", start_phys);
    
    start_virt            = ALIGN_DOWN_POT(start_virt, PAGE_SIZE_AT_LVL(lvl));
    80015ad2:	faf44783          	lbu	a5,-81(s0)
    80015ad6:	2781                	sext.w	a5,a5
    80015ad8:	873e                	mv	a4,a5
    80015ada:	87ba                	mv	a5,a4
    80015adc:	0037979b          	slliw	a5,a5,0x3
    80015ae0:	9fb9                	addw	a5,a5,a4
    80015ae2:	2781                	sext.w	a5,a5
    80015ae4:	27b1                	addiw	a5,a5,12
    80015ae6:	2781                	sext.w	a5,a5
    80015ae8:	4705                	li	a4,1
    80015aea:	00f717bb          	sllw	a5,a4,a5
    80015aee:	2781                	sext.w	a5,a5
    80015af0:	40f007bb          	negw	a5,a5
    80015af4:	2781                	sext.w	a5,a5
    80015af6:	873e                	mv	a4,a5
    80015af8:	fc043783          	ld	a5,-64(s0)
    80015afc:	8ff9                	and	a5,a5,a4
    80015afe:	fcf43023          	sd	a5,-64(s0)
    debugf("mmu_map_range: start_virt = 0x%08lx\n", start_virt);
    start_phys            = ALIGN_DOWN_POT(start_phys, PAGE_SIZE_AT_LVL(lvl));
    80015b02:	faf44783          	lbu	a5,-81(s0)
    80015b06:	2781                	sext.w	a5,a5
    80015b08:	873e                	mv	a4,a5
    80015b0a:	87ba                	mv	a5,a4
    80015b0c:	0037979b          	slliw	a5,a5,0x3
    80015b10:	9fb9                	addw	a5,a5,a4
    80015b12:	2781                	sext.w	a5,a5
    80015b14:	27b1                	addiw	a5,a5,12
    80015b16:	2781                	sext.w	a5,a5
    80015b18:	4705                	li	a4,1
    80015b1a:	00f717bb          	sllw	a5,a4,a5
    80015b1e:	2781                	sext.w	a5,a5
    80015b20:	40f007bb          	negw	a5,a5
    80015b24:	2781                	sext.w	a5,a5
    80015b26:	873e                	mv	a4,a5
    80015b28:	fb043783          	ld	a5,-80(s0)
    80015b2c:	8ff9                	and	a5,a5,a4
    80015b2e:	faf43823          	sd	a5,-80(s0)
    debugf("mmu_map_range: start_phys = 0x%08lx\n", start_phys);
    end_virt              = ALIGN_UP_POT(end_virt, PAGE_SIZE_AT_LVL(lvl));
    80015b32:	faf44783          	lbu	a5,-81(s0)
    80015b36:	2781                	sext.w	a5,a5
    80015b38:	873e                	mv	a4,a5
    80015b3a:	87ba                	mv	a5,a4
    80015b3c:	0037979b          	slliw	a5,a5,0x3
    80015b40:	9fb9                	addw	a5,a5,a4
    80015b42:	2781                	sext.w	a5,a5
    80015b44:	27b1                	addiw	a5,a5,12
    80015b46:	2781                	sext.w	a5,a5
    80015b48:	4705                	li	a4,1
    80015b4a:	00f717bb          	sllw	a5,a4,a5
    80015b4e:	2781                	sext.w	a5,a5
    80015b50:	873e                	mv	a4,a5
    80015b52:	fb843783          	ld	a5,-72(s0)
    80015b56:	97ba                	add	a5,a5,a4
    80015b58:	fff78713          	addi	a4,a5,-1
    80015b5c:	faf44783          	lbu	a5,-81(s0)
    80015b60:	2781                	sext.w	a5,a5
    80015b62:	86be                	mv	a3,a5
    80015b64:	87b6                	mv	a5,a3
    80015b66:	0037979b          	slliw	a5,a5,0x3
    80015b6a:	9fb5                	addw	a5,a5,a3
    80015b6c:	2781                	sext.w	a5,a5
    80015b6e:	27b1                	addiw	a5,a5,12
    80015b70:	2781                	sext.w	a5,a5
    80015b72:	4685                	li	a3,1
    80015b74:	00f697bb          	sllw	a5,a3,a5
    80015b78:	2781                	sext.w	a5,a5
    80015b7a:	40f007bb          	negw	a5,a5
    80015b7e:	2781                	sext.w	a5,a5
    80015b80:	8ff9                	and	a5,a5,a4
    80015b82:	faf43c23          	sd	a5,-72(s0)
    uint64_t num_bytes    = end_virt - start_virt;
    80015b86:	fb843703          	ld	a4,-72(s0)
    80015b8a:	fc043783          	ld	a5,-64(s0)
    80015b8e:	40f707b3          	sub	a5,a4,a5
    80015b92:	fcf43c23          	sd	a5,-40(s0)
    debugf("mmu_map_range: mapping = %d bytes\n", num_bytes);
    uint64_t pages_mapped = 0;
    80015b96:	fe043423          	sd	zero,-24(s0)

    uint64_t i;
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80015b9a:	fe043023          	sd	zero,-32(s0)
    80015b9e:	a0ad                	j	80015c08 <mmu_map_range+0x158>
        debugf("mmu_map_range: mapping %d bytes for page %d\n", PAGE_SIZE_AT_LVL(lvl), i / PAGE_SIZE_AT_LVL(lvl));
        if (!mmu_map(tab, start_virt + i, start_phys + i, lvl, bits)) {
    80015ba0:	fc043703          	ld	a4,-64(s0)
    80015ba4:	fe043783          	ld	a5,-32(s0)
    80015ba8:	00f705b3          	add	a1,a4,a5
    80015bac:	fb043703          	ld	a4,-80(s0)
    80015bb0:	fe043783          	ld	a5,-32(s0)
    80015bb4:	97ba                	add	a5,a5,a4
    80015bb6:	faf44683          	lbu	a3,-81(s0)
    80015bba:	fa043703          	ld	a4,-96(s0)
    80015bbe:	863e                	mv	a2,a5
    80015bc0:	fc843503          	ld	a0,-56(s0)
    80015bc4:	b19ff0ef          	jal	ra,800156dc <mmu_map>
    80015bc8:	87aa                	mv	a5,a0
    80015bca:	0017c793          	xori	a5,a5,1
    80015bce:	0ff7f793          	andi	a5,a5,255
    80015bd2:	e3b1                	bnez	a5,80015c16 <mmu_map_range+0x166>
            debugf("mmu_map_range: failed to map page %d\n", i / PAGE_SIZE_AT_LVL(lvl));
            break;
        }
        pages_mapped += 1;
    80015bd4:	fe843783          	ld	a5,-24(s0)
    80015bd8:	0785                	addi	a5,a5,1
    80015bda:	fef43423          	sd	a5,-24(s0)
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    80015bde:	faf44783          	lbu	a5,-81(s0)
    80015be2:	2781                	sext.w	a5,a5
    80015be4:	873e                	mv	a4,a5
    80015be6:	87ba                	mv	a5,a4
    80015be8:	0037979b          	slliw	a5,a5,0x3
    80015bec:	9fb9                	addw	a5,a5,a4
    80015bee:	2781                	sext.w	a5,a5
    80015bf0:	27b1                	addiw	a5,a5,12
    80015bf2:	2781                	sext.w	a5,a5
    80015bf4:	4705                	li	a4,1
    80015bf6:	00f717bb          	sllw	a5,a4,a5
    80015bfa:	2781                	sext.w	a5,a5
    80015bfc:	873e                	mv	a4,a5
    80015bfe:	fe043783          	ld	a5,-32(s0)
    80015c02:	97ba                	add	a5,a5,a4
    80015c04:	fef43023          	sd	a5,-32(s0)
    80015c08:	fe043703          	ld	a4,-32(s0)
    80015c0c:	fd843783          	ld	a5,-40(s0)
    80015c10:	f8f768e3          	bltu	a4,a5,80015ba0 <mmu_map_range+0xf0>
    80015c14:	a011                	j	80015c18 <mmu_map_range+0x168>
            break;
    80015c16:	0001                	nop
    }
    debugf("mmu_map_range: mapped %d pages\n", pages_mapped);
    debugf("mmu_map_range: mapped %d pages\n", pages_mapped);
    SFENCE_ALL();
    80015c18:	12000073          	sfence.vma
    return pages_mapped;
    80015c1c:	fe843783          	ld	a5,-24(s0)
} 
    80015c20:	853e                	mv	a0,a5
    80015c22:	60e6                	ld	ra,88(sp)
    80015c24:	6446                	ld	s0,80(sp)
    80015c26:	6125                	addi	sp,sp,96
    80015c28:	8082                	ret

0000000080015c2a <debug_page_table>:

// This function performs some basic sanity checks on the page table.
// For each level of the page table, it prints out the entries that are valid.
void debug_page_table(PageTable *tab, uint8_t lvl) {
    80015c2a:	715d                	addi	sp,sp,-80
    80015c2c:	e486                	sd	ra,72(sp)
    80015c2e:	e0a2                	sd	s0,64(sp)
    80015c30:	0880                	addi	s0,sp,80
    80015c32:	faa43c23          	sd	a0,-72(s0)
    80015c36:	87ae                	mv	a5,a1
    80015c38:	faf40ba3          	sb	a5,-73(s0)
    debugf("debug_page_table: debugging page table at 0x%016lx\n", tab);
    uint64_t page_mask = PAGE_SIZE_AT_LVL(lvl) - 1;
    80015c3c:	fb744783          	lbu	a5,-73(s0)
    80015c40:	2781                	sext.w	a5,a5
    80015c42:	873e                	mv	a4,a5
    80015c44:	87ba                	mv	a5,a4
    80015c46:	0037979b          	slliw	a5,a5,0x3
    80015c4a:	9fb9                	addw	a5,a5,a4
    80015c4c:	2781                	sext.w	a5,a5
    80015c4e:	27b1                	addiw	a5,a5,12
    80015c50:	2781                	sext.w	a5,a5
    80015c52:	4705                	li	a4,1
    80015c54:	00f717bb          	sllw	a5,a4,a5
    80015c58:	2781                	sext.w	a5,a5
    80015c5a:	37fd                	addiw	a5,a5,-1
    80015c5c:	2781                	sext.w	a5,a5
    80015c5e:	fef43023          	sd	a5,-32(s0)

    for (uint64_t i=0; i < 512; i++) {
    80015c62:	fe043423          	sd	zero,-24(s0)
    80015c66:	aa89                	j	80015db8 <debug_page_table+0x18e>
        // Is the entry a leaf?
        bool is_leaf = (tab->entries[i] & 0xE) != 0;
    80015c68:	fb843703          	ld	a4,-72(s0)
    80015c6c:	fe843783          	ld	a5,-24(s0)
    80015c70:	078e                	slli	a5,a5,0x3
    80015c72:	97ba                	add	a5,a5,a4
    80015c74:	639c                	ld	a5,0(a5)
    80015c76:	8bb9                	andi	a5,a5,14
    80015c78:	00f037b3          	snez	a5,a5
    80015c7c:	fcf40fa3          	sb	a5,-33(s0)

        // Is the entry valid?
        bool is_valid = tab->entries[i] & PB_VALID;
    80015c80:	fb843703          	ld	a4,-72(s0)
    80015c84:	fe843783          	ld	a5,-24(s0)
    80015c88:	078e                	slli	a5,a5,0x3
    80015c8a:	97ba                	add	a5,a5,a4
    80015c8c:	639c                	ld	a5,0(a5)
    80015c8e:	8b85                	andi	a5,a5,1
    80015c90:	00f037b3          	snez	a5,a5
    80015c94:	fcf40f23          	sb	a5,-34(s0)

        // Is the entry a branch?
        bool is_branch = is_valid && !is_leaf;
    80015c98:	fde44783          	lbu	a5,-34(s0)
    80015c9c:	0ff7f793          	andi	a5,a5,255
    80015ca0:	cb91                	beqz	a5,80015cb4 <debug_page_table+0x8a>
    80015ca2:	fdf44783          	lbu	a5,-33(s0)
    80015ca6:	0017c793          	xori	a5,a5,1
    80015caa:	0ff7f793          	andi	a5,a5,255
    80015cae:	c399                	beqz	a5,80015cb4 <debug_page_table+0x8a>
    80015cb0:	4785                	li	a5,1
    80015cb2:	a011                	j	80015cb6 <debug_page_table+0x8c>
    80015cb4:	4781                	li	a5,0
    80015cb6:	fcf40ea3          	sb	a5,-35(s0)
    80015cba:	fdd44783          	lbu	a5,-35(s0)
    80015cbe:	8b85                	andi	a5,a5,1
    80015cc0:	fcf40ea3          	sb	a5,-35(s0)

        uint64_t paddr = ((tab->entries[i] & ~0x3FF) << 2) & ~page_mask;
    80015cc4:	fb843703          	ld	a4,-72(s0)
    80015cc8:	fe843783          	ld	a5,-24(s0)
    80015ccc:	078e                	slli	a5,a5,0x3
    80015cce:	97ba                	add	a5,a5,a4
    80015cd0:	639c                	ld	a5,0(a5)
    80015cd2:	00279713          	slli	a4,a5,0x2
    80015cd6:	fe043783          	ld	a5,-32(s0)
    80015cda:	fff7c793          	not	a5,a5
    80015cde:	8f7d                	and	a4,a4,a5
    80015ce0:	77fd                	lui	a5,0xfffff
    80015ce2:	8ff9                	and	a5,a5,a4
    80015ce4:	fcf43823          	sd	a5,-48(s0)
        if (paddr == (uint64_t)tab) {
    80015ce8:	fb843783          	ld	a5,-72(s0)
    80015cec:	fd043703          	ld	a4,-48(s0)
    80015cf0:	0af70c63          	beq	a4,a5,80015da8 <debug_page_table+0x17e>
            continue;
        }

        uint64_t vaddr = paddr;
    80015cf4:	fd043783          	ld	a5,-48(s0)
    80015cf8:	fcf43423          	sd	a5,-56(s0)
        if (is_valid && is_leaf) {
    80015cfc:	fde44783          	lbu	a5,-34(s0)
    80015d00:	0ff7f793          	andi	a5,a5,255
    80015d04:	cf9d                	beqz	a5,80015d42 <debug_page_table+0x118>
    80015d06:	fdf44783          	lbu	a5,-33(s0)
    80015d0a:	0ff7f793          	andi	a5,a5,255
    80015d0e:	cb95                	beqz	a5,80015d42 <debug_page_table+0x118>
            // Confirm that we can translate the address
            uint64_t translated = mmu_translate(tab, vaddr);
    80015d10:	fc843583          	ld	a1,-56(s0)
    80015d14:	fb843503          	ld	a0,-72(s0)
    80015d18:	befff0ef          	jal	ra,80015906 <mmu_translate>
    80015d1c:	fca43023          	sd	a0,-64(s0)
            if (translated != paddr) {
    80015d20:	fc043703          	ld	a4,-64(s0)
    80015d24:	fd043783          	ld	a5,-48(s0)
    80015d28:	08f70263          	beq	a4,a5,80015dac <debug_page_table+0x182>
                debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                debugf("debug_page_table: expected 0x%08lx, got 0x%08lx\n", paddr, translated);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    80015d2c:	fb843603          	ld	a2,-72(s0)
    80015d30:	fe843583          	ld	a1,-24(s0)
    80015d34:	00011517          	auipc	a0,0x11
    80015d38:	4cc50513          	addi	a0,a0,1228 # 80027200 <pow10.0+0x3a0>
    80015d3c:	200060ef          	jal	ra,8001bf3c <fatalf>
        if (is_valid && is_leaf) {
    80015d40:	a0b5                	j	80015dac <debug_page_table+0x182>
            } else {
                debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
            }
        } else if (is_branch && lvl > MMU_LEVEL_4K) {
    80015d42:	fdd44783          	lbu	a5,-35(s0)
    80015d46:	0ff7f793          	andi	a5,a5,255
    80015d4a:	cf85                	beqz	a5,80015d82 <debug_page_table+0x158>
    80015d4c:	fb744783          	lbu	a5,-73(s0)
    80015d50:	0ff7f793          	andi	a5,a5,255
    80015d54:	c79d                	beqz	a5,80015d82 <debug_page_table+0x158>
            // Recurse into the next level
            debugf("debug_page_table: entry %d in page table at 0x%08lx is a branch to 0x%08lx\n", i, tab, (tab->entries[i] & ~0x3FF) << 2);
            debug_page_table((PageTable *)((tab->entries[i] & ~0x3FF) << 2), lvl - 1);
    80015d56:	fb843703          	ld	a4,-72(s0)
    80015d5a:	fe843783          	ld	a5,-24(s0)
    80015d5e:	078e                	slli	a5,a5,0x3
    80015d60:	97ba                	add	a5,a5,a4
    80015d62:	639c                	ld	a5,0(a5)
    80015d64:	00279713          	slli	a4,a5,0x2
    80015d68:	77fd                	lui	a5,0xfffff
    80015d6a:	8ff9                	and	a5,a5,a4
    80015d6c:	873e                	mv	a4,a5
    80015d6e:	fb744783          	lbu	a5,-73(s0)
    80015d72:	37fd                	addiw	a5,a5,-1
    80015d74:	0ff7f793          	andi	a5,a5,255
    80015d78:	85be                	mv	a1,a5
    80015d7a:	853a                	mv	a0,a4
    80015d7c:	eafff0ef          	jal	ra,80015c2a <debug_page_table>
    80015d80:	a03d                	j	80015dae <debug_page_table+0x184>
        } else {
            // Invalid entry, confirm that it's all zeroes
            if (tab->entries[i] != 0) {
    80015d82:	fb843703          	ld	a4,-72(s0)
    80015d86:	fe843783          	ld	a5,-24(s0)
    80015d8a:	078e                	slli	a5,a5,0x3
    80015d8c:	97ba                	add	a5,a5,a4
    80015d8e:	639c                	ld	a5,0(a5)
    80015d90:	cf99                	beqz	a5,80015dae <debug_page_table+0x184>
                debugf("debug_page_table: page table at 0x%08lx is invalid\n", tab);
                debugf("debug_page_table: expected all zeroes, got 0x%08lx\n", tab->entries[i]);
                fatalf("debug_page_table: entry 0x%x in page table at 0x%08lx is invalid\n", i, tab);
    80015d92:	fb843603          	ld	a2,-72(s0)
    80015d96:	fe843583          	ld	a1,-24(s0)
    80015d9a:	00011517          	auipc	a0,0x11
    80015d9e:	46650513          	addi	a0,a0,1126 # 80027200 <pow10.0+0x3a0>
    80015da2:	19a060ef          	jal	ra,8001bf3c <fatalf>
    80015da6:	a021                	j	80015dae <debug_page_table+0x184>
            continue;
    80015da8:	0001                	nop
    80015daa:	a011                	j	80015dae <debug_page_table+0x184>
        if (is_valid && is_leaf) {
    80015dac:	0001                	nop
    for (uint64_t i=0; i < 512; i++) {
    80015dae:	fe843783          	ld	a5,-24(s0)
    80015db2:	0785                	addi	a5,a5,1
    80015db4:	fef43423          	sd	a5,-24(s0)
    80015db8:	fe843703          	ld	a4,-24(s0)
    80015dbc:	1ff00793          	li	a5,511
    80015dc0:	eae7f4e3          	bgeu	a5,a4,80015c68 <debug_page_table+0x3e>
            }
        }
    }

    debugf("debug_page_table: page table at 0x%08lx is valid\n", tab);
}
    80015dc4:	0001                	nop
    80015dc6:	0001                	nop
    80015dc8:	60a6                	ld	ra,72(sp)
    80015dca:	6406                	ld	s0,64(sp)
    80015dcc:	6161                	addi	sp,sp,80
    80015dce:	8082                	ret

0000000080015dd0 <sched_init>:
static RBTree *sched_tree;
Mutex sched_lock;


//initialize scheduler tree
void sched_init() {
    80015dd0:	1141                	addi	sp,sp,-16
    80015dd2:	e406                	sd	ra,8(sp)
    80015dd4:	e022                	sd	s0,0(sp)
    80015dd6:	0800                	addi	s0,sp,16
    sched_tree = rb_new();
    80015dd8:	3640c0ef          	jal	ra,8002213c <rb_new>
    80015ddc:	872a                	mv	a4,a0
    80015dde:	0000f797          	auipc	a5,0xf
    80015de2:	2ba78793          	addi	a5,a5,698 # 80025098 <sched_tree>
    80015de6:	e398                	sd	a4,0(a5)
}
    80015de8:	0001                	nop
    80015dea:	60a2                	ld	ra,8(sp)
    80015dec:	6402                	ld	s0,0(sp)
    80015dee:	0141                	addi	sp,sp,16
    80015df0:	8082                	ret

0000000080015df2 <sched_add>:

//adds node to scheduler tree
void sched_add(Process *p) {  
    80015df2:	1101                	addi	sp,sp,-32
    80015df4:	ec06                	sd	ra,24(sp)
    80015df6:	e822                	sd	s0,16(sp)
    80015df8:	1000                	addi	s0,sp,32
    80015dfa:	fea43423          	sd	a0,-24(s0)
    mutex_spinlock(&sched_lock);  
    80015dfe:	0000f517          	auipc	a0,0xf
    80015e02:	20250513          	addi	a0,a0,514 # 80025000 <sched_lock>
    80015e06:	835ff0ef          	jal	ra,8001563a <mutex_spinlock>
    //NOTE: Process key is runtime * priority
    rb_insert_ptr(sched_tree, p->runtime * p->priority, p);
    80015e0a:	0000f797          	auipc	a5,0xf
    80015e0e:	28e78793          	addi	a5,a5,654 # 80025098 <sched_tree>
    80015e12:	6394                	ld	a3,0(a5)
    80015e14:	fe843783          	ld	a5,-24(s0)
    80015e18:	2587b783          	ld	a5,600(a5)
    80015e1c:	0007871b          	sext.w	a4,a5
    80015e20:	fe843783          	ld	a5,-24(s0)
    80015e24:	2687b783          	ld	a5,616(a5)
    80015e28:	2781                	sext.w	a5,a5
    80015e2a:	02f707bb          	mulw	a5,a4,a5
    80015e2e:	2781                	sext.w	a5,a5
    80015e30:	2781                	sext.w	a5,a5
    80015e32:	fe843703          	ld	a4,-24(s0)
    80015e36:	863a                	mv	a2,a4
    80015e38:	85be                	mv	a1,a5
    80015e3a:	8536                	mv	a0,a3
    80015e3c:	5f30b0ef          	jal	ra,80021c2e <rb_insert>
    mutex_unlock(&sched_lock);
    80015e40:	0000f517          	auipc	a0,0xf
    80015e44:	1c050513          	addi	a0,a0,448 # 80025000 <sched_lock>
    80015e48:	821ff0ef          	jal	ra,80015668 <mutex_unlock>
}
    80015e4c:	0001                	nop
    80015e4e:	60e2                	ld	ra,24(sp)
    80015e50:	6442                	ld	s0,16(sp)
    80015e52:	6105                	addi	sp,sp,32
    80015e54:	8082                	ret

0000000080015e56 <sched_get_next>:

//get (pop) Process with the lowest vruntime
Process *sched_get_next() {
    80015e56:	1101                	addi	sp,sp,-32
    80015e58:	ec06                	sd	ra,24(sp)
    80015e5a:	e822                	sd	s0,16(sp)
    80015e5c:	1000                	addi	s0,sp,32
    mutex_spinlock(&sched_lock);
    80015e5e:	0000f517          	auipc	a0,0xf
    80015e62:	1a250513          	addi	a0,a0,418 # 80025000 <sched_lock>
    80015e66:	fd4ff0ef          	jal	ra,8001563a <mutex_spinlock>
    Process *min_process;
    //implementation of async Process freeing
    while (min_process->state != PS_DEAD) {
    80015e6a:	a085                	j	80015eca <sched_get_next+0x74>
        bool search_success = rb_min_val_ptr(sched_tree, min_process);
    80015e6c:	0000f797          	auipc	a5,0xf
    80015e70:	22c78793          	addi	a5,a5,556 # 80025098 <sched_tree>
    80015e74:	639c                	ld	a5,0(a5)
    80015e76:	fe843583          	ld	a1,-24(s0)
    80015e7a:	853e                	mv	a0,a5
    80015e7c:	24d0b0ef          	jal	ra,800218c8 <rb_min_val>
    80015e80:	87aa                	mv	a5,a0
    80015e82:	fef403a3          	sb	a5,-25(s0)
        rb_delete(sched_tree, min_process->runtime * min_process->priority);
    80015e86:	0000f797          	auipc	a5,0xf
    80015e8a:	21278793          	addi	a5,a5,530 # 80025098 <sched_tree>
    80015e8e:	6394                	ld	a3,0(a5)
    80015e90:	fe843783          	ld	a5,-24(s0)
    80015e94:	2587b783          	ld	a5,600(a5)
    80015e98:	0007871b          	sext.w	a4,a5
    80015e9c:	fe843783          	ld	a5,-24(s0)
    80015ea0:	2687b783          	ld	a5,616(a5)
    80015ea4:	2781                	sext.w	a5,a5
    80015ea6:	02f707bb          	mulw	a5,a4,a5
    80015eaa:	2781                	sext.w	a5,a5
    80015eac:	2781                	sext.w	a5,a5
    80015eae:	85be                	mv	a1,a5
    80015eb0:	8536                	mv	a0,a3
    80015eb2:	11e0c0ef          	jal	ra,80021fd0 <rb_delete>
        if (!search_success) {
    80015eb6:	fe744783          	lbu	a5,-25(s0)
    80015eba:	0017c793          	xori	a5,a5,1
    80015ebe:	0ff7f793          	andi	a5,a5,255
    80015ec2:	c781                	beqz	a5,80015eca <sched_get_next+0x74>
            min_process = NULL;
    80015ec4:	fe043423          	sd	zero,-24(s0)
            break;
    80015ec8:	a029                	j	80015ed2 <sched_get_next+0x7c>
    while (min_process->state != PS_DEAD) {
    80015eca:	fe843783          	ld	a5,-24(s0)
    80015ece:	47dc                	lw	a5,12(a5)
    80015ed0:	ffd1                	bnez	a5,80015e6c <sched_get_next+0x16>
        }
    }
    mutex_unlock(&sched_lock);
    80015ed2:	0000f517          	auipc	a0,0xf
    80015ed6:	12e50513          	addi	a0,a0,302 # 80025000 <sched_lock>
    80015eda:	f8eff0ef          	jal	ra,80015668 <mutex_unlock>
    return min_process;
    80015ede:	fe843783          	ld	a5,-24(s0)
}
    80015ee2:	853e                	mv	a0,a5
    80015ee4:	60e2                	ld	ra,24(sp)
    80015ee6:	6442                	ld	s0,16(sp)
    80015ee8:	6105                	addi	sp,sp,32
    80015eea:	8082                	ret

0000000080015eec <sched_handle_timer_interrupt>:
//     rb_delete(sched_tree, p->runtime);
//     rb_insert(sched_tree, p->runtime, (uint64_t)p);
// }

// Function to handle the timer interrupt for context switching
void sched_handle_timer_interrupt(int hart) {
    80015eec:	7139                	addi	sp,sp,-64
    80015eee:	fc06                	sd	ra,56(sp)
    80015ef0:	f822                	sd	s0,48(sp)
    80015ef2:	0080                	addi	s0,sp,64
    80015ef4:	87aa                	mv	a5,a0
    80015ef6:	fcf42623          	sw	a5,-52(s0)

    //put Process currently on the hart back in the scheduler to recalc priority
    uint16_t pid = pid_harts_map_get(hart);
    80015efa:	fcc42783          	lw	a5,-52(s0)
    80015efe:	853e                	mv	a0,a5
    80015f00:	4f3050ef          	jal	ra,8001bbf2 <pid_harts_map_get>
    80015f04:	87aa                	mv	a5,a0
    80015f06:	fef41723          	sh	a5,-18(s0)
    Process *current_proc = process_map_get(pid);
    80015f0a:	fee45783          	lhu	a5,-18(s0)
    80015f0e:	853e                	mv	a0,a5
    80015f10:	433050ef          	jal	ra,8001bb42 <process_map_get>
    80015f14:	fea43023          	sd	a0,-32(s0)
    sched_add(current_proc);
    80015f18:	fe043503          	ld	a0,-32(s0)
    80015f1c:	ed7ff0ef          	jal	ra,80015df2 <sched_add>

    //get an idle Process
    Process *next_process = sched_get_next(); // Implement this function to get the currently running Process
    80015f20:	f37ff0ef          	jal	ra,80015e56 <sched_get_next>
    80015f24:	fca43c23          	sd	a0,-40(s0)

    //execute Process until next interrupt
    if (next_process != NULL) {
    80015f28:	fd843783          	ld	a5,-40(s0)
    80015f2c:	cb85                	beqz	a5,80015f5c <sched_handle_timer_interrupt+0x70>
        //set timer
        sbi_add_timer(hart, CONTEXT_SWITCH_TIMER * next_process->quantum);
    80015f2e:	fcc42683          	lw	a3,-52(s0)
    80015f32:	fd843783          	ld	a5,-40(s0)
    80015f36:	2707b703          	ld	a4,624(a5)
    80015f3a:	67b1                	lui	a5,0xc
    80015f3c:	35078793          	addi	a5,a5,848 # c350 <i+0xc330>
    80015f40:	02f707b3          	mul	a5,a4,a5
    80015f44:	85be                	mv	a1,a5
    80015f46:	8536                	mv	a0,a3
    80015f48:	1ea060ef          	jal	ra,8001c132 <sbi_add_timer>
        process_run(next_process, hart);
    80015f4c:	fcc42783          	lw	a5,-52(s0)
    80015f50:	85be                	mv	a1,a5
    80015f52:	fd843503          	ld	a0,-40(s0)
    80015f56:	309050ef          	jal	ra,8001ba5e <process_run>
    // sched_update_vruntime(current_process, time_slice);
    // Process *next_process = sched_choose_next();
    // if (next_process != current_process) {
    //     context_switch(current_process, next_process); // Implement context_switch function
    // }
}
    80015f5a:	a805                	j	80015f8a <sched_handle_timer_interrupt+0x9e>
        if (hart == 0) {
    80015f5c:	fcc42783          	lw	a5,-52(s0)
    80015f60:	2781                	sext.w	a5,a5
    80015f62:	e395                	bnez	a5,80015f86 <sched_handle_timer_interrupt+0x9a>
            sbi_add_timer(hart, CONTEXT_SWITCH_TIMER);
    80015f64:	fcc42703          	lw	a4,-52(s0)
    80015f68:	67b1                	lui	a5,0xc
    80015f6a:	35078593          	addi	a1,a5,848 # c350 <i+0xc330>
    80015f6e:	853a                	mv	a0,a4
    80015f70:	1c2060ef          	jal	ra,8001c132 <sbi_add_timer>
            debugf("sched_handle_timer_interrupt: Running idle process\n");
    80015f74:	00011517          	auipc	a0,0x11
    80015f78:	2d450513          	addi	a0,a0,724 # 80027248 <pow10.0+0x3e8>
    80015f7c:	667050ef          	jal	ra,8001bde2 <debugf>
            WFI_LOOP();
    80015f80:	10500073          	wfi
    80015f84:	bff5                	j	80015f80 <sched_handle_timer_interrupt+0x94>
            sbi_hart_stop();
    80015f86:	130060ef          	jal	ra,8001c0b6 <sbi_hart_stop>
}
    80015f8a:	0001                	nop
    80015f8c:	70e2                	ld	ra,56(sp)
    80015f8e:	7442                	ld	s0,48(sp)
    80015f90:	6121                	addi	sp,sp,64
    80015f92:	8082                	ret

0000000080015f94 <context_switch>:

void context_switch(Process *from, Process *to) {
    80015f94:	1101                	addi	sp,sp,-32
    80015f96:	ec06                	sd	ra,24(sp)
    80015f98:	e822                	sd	s0,16(sp)
    80015f9a:	1000                	addi	s0,sp,32
    80015f9c:	fea43423          	sd	a0,-24(s0)
    80015fa0:	feb43023          	sd	a1,-32(s0)
    // Save the state of the current Process
    save_state(&from->frame);
    80015fa4:	fe843783          	ld	a5,-24(s0)
    80015fa8:	07c1                	addi	a5,a5,16
    80015faa:	853e                	mv	a0,a5
    80015fac:	02e000ef          	jal	ra,80015fda <save_state>

    // Load the state of the next Process
    load_state(&to->frame);
    80015fb0:	fe043783          	ld	a5,-32(s0)
    80015fb4:	07c1                	addi	a5,a5,16
    80015fb6:	853e                	mv	a0,a5
    80015fb8:	034000ef          	jal	ra,80015fec <load_state>

    // Update the current Process pointer
    set_current_process(to);
    80015fbc:	fe043503          	ld	a0,-32(s0)
    80015fc0:	070000ef          	jal	ra,80016030 <set_current_process>

    // Perform the actual switch
    switch_to(&to->frame);
    80015fc4:	fe043783          	ld	a5,-32(s0)
    80015fc8:	07c1                	addi	a5,a5,16
    80015fca:	853e                	mv	a0,a5
    80015fcc:	032000ef          	jal	ra,80015ffe <switch_to>
}
    80015fd0:	0001                	nop
    80015fd2:	60e2                	ld	ra,24(sp)
    80015fd4:	6442                	ld	s0,16(sp)
    80015fd6:	6105                	addi	sp,sp,32
    80015fd8:	8082                	ret

0000000080015fda <save_state>:


void save_state(TrapFrame *state) {
    80015fda:	1101                	addi	sp,sp,-32
    80015fdc:	ec22                	sd	s0,24(sp)
    80015fde:	1000                	addi	s0,sp,32
    80015fe0:	fea43423          	sd	a0,-24(s0)
}
    80015fe4:	0001                	nop
    80015fe6:	6462                	ld	s0,24(sp)
    80015fe8:	6105                	addi	sp,sp,32
    80015fea:	8082                	ret

0000000080015fec <load_state>:

void load_state(TrapFrame *state) {
    80015fec:	1101                	addi	sp,sp,-32
    80015fee:	ec22                	sd	s0,24(sp)
    80015ff0:	1000                	addi	s0,sp,32
    80015ff2:	fea43423          	sd	a0,-24(s0)
}
    80015ff6:	0001                	nop
    80015ff8:	6462                	ld	s0,24(sp)
    80015ffa:	6105                	addi	sp,sp,32
    80015ffc:	8082                	ret

0000000080015ffe <switch_to>:

void switch_to(TrapFrame *state) {
    80015ffe:	1101                	addi	sp,sp,-32
    80016000:	ec22                	sd	s0,24(sp)
    80016002:	1000                	addi	s0,sp,32
    80016004:	fea43423          	sd	a0,-24(s0)
}
    80016008:	0001                	nop
    8001600a:	6462                	ld	s0,24(sp)
    8001600c:	6105                	addi	sp,sp,32
    8001600e:	8082                	ret

0000000080016010 <sched_get_current>:

Process *sched_get_current(void) {
    80016010:	1141                	addi	sp,sp,-16
    80016012:	e422                	sd	s0,8(sp)
    80016014:	0800                	addi	s0,sp,16
}
    80016016:	0001                	nop
    80016018:	853e                	mv	a0,a5
    8001601a:	6422                	ld	s0,8(sp)
    8001601c:	0141                	addi	sp,sp,16
    8001601e:	8082                	ret

0000000080016020 <get_time_slice>:

//amount of time before hart is interrupted
unsigned long get_time_slice(void) {
    80016020:	1141                	addi	sp,sp,-16
    80016022:	e422                	sd	s0,8(sp)
    80016024:	0800                	addi	s0,sp,16
}
    80016026:	0001                	nop
    80016028:	853e                	mv	a0,a5
    8001602a:	6422                	ld	s0,8(sp)
    8001602c:	0141                	addi	sp,sp,16
    8001602e:	8082                	ret

0000000080016030 <set_current_process>:

void set_current_process(Process *proc) {
    80016030:	1101                	addi	sp,sp,-32
    80016032:	ec22                	sd	s0,24(sp)
    80016034:	1000                	addi	s0,sp,32
    80016036:	fea43423          	sd	a0,-24(s0)
}
    8001603a:	0001                	nop
    8001603c:	6462                	ld	s0,24(sp)
    8001603e:	6105                	addi	sp,sp,32
    80016040:	8082                	ret

0000000080016042 <gpu_test>:

static Vector *device_active_jobs;
static VirtioDevice *gpu_device;
static Console console; // NOTE: Figure how this is supposed to be interfaced, allocate appropriately

bool gpu_test() {
    80016042:	1141                	addi	sp,sp,-16
    80016044:	e406                	sd	ra,8(sp)
    80016046:	e022                	sd	s0,0(sp)
    80016048:	0800                	addi	s0,sp,16
    return gpu_init(gpu_device);
    8001604a:	0000f797          	auipc	a5,0xf
    8001604e:	05e78793          	addi	a5,a5,94 # 800250a8 <gpu_device>
    80016052:	639c                	ld	a5,0(a5)
    80016054:	853e                	mv	a0,a5
    80016056:	1fc000ef          	jal	ra,80016252 <gpu_init>
    8001605a:	87aa                	mv	a5,a0
}
    8001605c:	853e                	mv	a0,a5
    8001605e:	60a2                	ld	ra,8(sp)
    80016060:	6402                	ld	s0,0(sp)
    80016062:	0141                	addi	sp,sp,16
    80016064:	8082                	ret

0000000080016066 <gpu_device_init>:

void gpu_device_init() {
    80016066:	1101                	addi	sp,sp,-32
    80016068:	ec06                	sd	ra,24(sp)
    8001606a:	e822                	sd	s0,16(sp)
    8001606c:	1000                	addi	s0,sp,32
    device_active_jobs = vector_new();
    8001606e:	4210c0ef          	jal	ra,80022c8e <vector_new>
    80016072:	872a                	mv	a4,a0
    80016074:	0000f797          	auipc	a5,0xf
    80016078:	02c78793          	addi	a5,a5,44 # 800250a0 <device_active_jobs>
    8001607c:	e398                	sd	a4,0(a5)
    gpu_device = virtio_get_gpu_device();
    8001607e:	509060ef          	jal	ra,8001cd86 <virtio_get_gpu_device>
    80016082:	872a                	mv	a4,a0
    80016084:	0000f797          	auipc	a5,0xf
    80016088:	02478793          	addi	a5,a5,36 # 800250a8 <gpu_device>
    8001608c:	e398                	sd	a4,0(a5)
    // debugf("GPU device init done for device at %p\n", gpu_device->pcidev->ecam_header);
    virtio_set_device_name(gpu_device, "GPU Device");
    8001608e:	0000f797          	auipc	a5,0xf
    80016092:	01a78793          	addi	a5,a5,26 # 800250a8 <gpu_device>
    80016096:	639c                	ld	a5,0(a5)
    80016098:	00011597          	auipc	a1,0x11
    8001609c:	1e858593          	addi	a1,a1,488 # 80027280 <pow10.0+0x420>
    800160a0:	853e                	mv	a0,a5
    800160a2:	22a070ef          	jal	ra,8001d2cc <virtio_set_device_name>
    gpu_device->ready = true;
    800160a6:	0000f797          	auipc	a5,0xf
    800160aa:	00278793          	addi	a5,a5,2 # 800250a8 <gpu_device>
    800160ae:	639c                	ld	a5,0(a5)
    800160b0:	4705                	li	a4,1
    800160b2:	08e78723          	sb	a4,142(a5)
    volatile VirtioGpuConfig *config = virtio_get_gpu_config(gpu_device);
    800160b6:	0000f797          	auipc	a5,0xf
    800160ba:	ff278793          	addi	a5,a5,-14 # 800250a8 <gpu_device>
    800160be:	639c                	ld	a5,0(a5)
    800160c0:	853e                	mv	a0,a5
    800160c2:	229060ef          	jal	ra,8001caea <virtio_get_gpu_config>
    800160c6:	fea43423          	sd	a0,-24(s0)
    debugf("GPU device has %d events that needs to be read\n", config->events_read);
    800160ca:	fe843783          	ld	a5,-24(s0)
    800160ce:	439c                	lw	a5,0(a5)
    800160d0:	2781                	sext.w	a5,a5
    800160d2:	85be                	mv	a1,a5
    800160d4:	00011517          	auipc	a0,0x11
    800160d8:	1bc50513          	addi	a0,a0,444 # 80027290 <pow10.0+0x430>
    800160dc:	507050ef          	jal	ra,8001bde2 <debugf>
    debugf("GPU device has %d scanouts\n", config->num_scanouts);
    800160e0:	fe843783          	ld	a5,-24(s0)
    800160e4:	479c                	lw	a5,8(a5)
    800160e6:	2781                	sext.w	a5,a5
    800160e8:	85be                	mv	a1,a5
    800160ea:	00011517          	auipc	a0,0x11
    800160ee:	1d650513          	addi	a0,a0,470 # 800272c0 <pow10.0+0x460>
    800160f2:	4f1050ef          	jal	ra,8001bde2 <debugf>
}
    800160f6:	0001                	nop
    800160f8:	60e2                	ld	ra,24(sp)
    800160fa:	6442                	ld	s0,16(sp)
    800160fc:	6105                	addi	sp,sp,32
    800160fe:	8082                	ret

0000000080016100 <gpu_get_resp_string>:

// Return the respective response message string
static char *gpu_get_resp_string(VirtioGpuCtrlType type) {
    80016100:	1101                	addi	sp,sp,-32
    80016102:	ec22                	sd	s0,24(sp)
    80016104:	1000                	addi	s0,sp,32
    80016106:	87aa                	mv	a5,a0
    80016108:	fef42623          	sw	a5,-20(s0)
    switch (type) {
    8001610c:	fec42783          	lw	a5,-20(s0)
    80016110:	0007871b          	sext.w	a4,a5
    80016114:	6785                	lui	a5,0x1
    80016116:	10478793          	addi	a5,a5,260 # 1104 <i+0x10e4>
    8001611a:	08e7ea63          	bltu	a5,a4,800161ae <gpu_get_resp_string+0xae>
    8001611e:	fec42783          	lw	a5,-20(s0)
    80016122:	0007871b          	sext.w	a4,a5
    80016126:	6785                	lui	a5,0x1
    80016128:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    8001612c:	04f77263          	bgeu	a4,a5,80016170 <gpu_get_resp_string+0x70>
    80016130:	aa09                	j	80016242 <gpu_get_resp_string+0x142>
    80016132:	fec42703          	lw	a4,-20(s0)
    80016136:	77fd                	lui	a5,0xfffff
    80016138:	e007879b          	addiw	a5,a5,-512
    8001613c:	00f706bb          	addw	a3,a4,a5
    80016140:	0006871b          	sext.w	a4,a3
    80016144:	4795                	li	a5,5
    80016146:	0ee7ee63          	bltu	a5,a4,80016242 <gpu_get_resp_string+0x142>
    8001614a:	02069793          	slli	a5,a3,0x20
    8001614e:	9381                	srli	a5,a5,0x20
    80016150:	00279713          	slli	a4,a5,0x2
    80016154:	00011797          	auipc	a5,0x11
    80016158:	33c78793          	addi	a5,a5,828 # 80027490 <pow10.0+0x630>
    8001615c:	97ba                	add	a5,a5,a4
    8001615e:	439c                	lw	a5,0(a5)
    80016160:	0007871b          	sext.w	a4,a5
    80016164:	00011797          	auipc	a5,0x11
    80016168:	32c78793          	addi	a5,a5,812 # 80027490 <pow10.0+0x630>
    8001616c:	97ba                	add	a5,a5,a4
    8001616e:	8782                	jr	a5
    80016170:	fec42703          	lw	a4,-20(s0)
    80016174:	77fd                	lui	a5,0xfffff
    80016176:	f007879b          	addiw	a5,a5,-256
    8001617a:	00f706bb          	addw	a3,a4,a5
    8001617e:	0006871b          	sext.w	a4,a3
    80016182:	4791                	li	a5,4
    80016184:	0ae7ef63          	bltu	a5,a4,80016242 <gpu_get_resp_string+0x142>
    80016188:	02069793          	slli	a5,a3,0x20
    8001618c:	9381                	srli	a5,a5,0x20
    8001618e:	00279713          	slli	a4,a5,0x2
    80016192:	00011797          	auipc	a5,0x11
    80016196:	31678793          	addi	a5,a5,790 # 800274a8 <pow10.0+0x648>
    8001619a:	97ba                	add	a5,a5,a4
    8001619c:	439c                	lw	a5,0(a5)
    8001619e:	0007871b          	sext.w	a4,a5
    800161a2:	00011797          	auipc	a5,0x11
    800161a6:	30678793          	addi	a5,a5,774 # 800274a8 <pow10.0+0x648>
    800161aa:	97ba                	add	a5,a5,a4
    800161ac:	8782                	jr	a5
    800161ae:	fec42783          	lw	a5,-20(s0)
    800161b2:	0007871b          	sext.w	a4,a5
    800161b6:	6785                	lui	a5,0x1
    800161b8:	20578793          	addi	a5,a5,517 # 1205 <i+0x11e5>
    800161bc:	08e7e363          	bltu	a5,a4,80016242 <gpu_get_resp_string+0x142>
    800161c0:	fec42783          	lw	a5,-20(s0)
    800161c4:	0007871b          	sext.w	a4,a5
    800161c8:	6785                	lui	a5,0x1
    800161ca:	20078793          	addi	a5,a5,512 # 1200 <i+0x11e0>
    800161ce:	f6f772e3          	bgeu	a4,a5,80016132 <gpu_get_resp_string+0x32>
    800161d2:	a885                	j	80016242 <gpu_get_resp_string+0x142>
        // Success responses
        case VIRTIO_GPU_RESP_OK_NODATA: return "VIRTIO_GPU_RESP_OK_NODATA";
    800161d4:	00011797          	auipc	a5,0x11
    800161d8:	10c78793          	addi	a5,a5,268 # 800272e0 <pow10.0+0x480>
    800161dc:	a0bd                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_DISPLAY_INFO: return "VIRTIO_GPU_RESP_OK_DISPLAY_INFO";
    800161de:	00011797          	auipc	a5,0x11
    800161e2:	12278793          	addi	a5,a5,290 # 80027300 <pow10.0+0x4a0>
    800161e6:	a095                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_CAPSET_INFO: return "VIRTIO_GPU_RESP_OK_CAPSET_INFO";
    800161e8:	00011797          	auipc	a5,0x11
    800161ec:	13878793          	addi	a5,a5,312 # 80027320 <pow10.0+0x4c0>
    800161f0:	a8a9                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_CAPSET: return "VIRTIO_GPU_RESP_OK_CAPSET";
    800161f2:	00011797          	auipc	a5,0x11
    800161f6:	14e78793          	addi	a5,a5,334 # 80027340 <pow10.0+0x4e0>
    800161fa:	a881                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_OK_EDID: return "VIRTIO_GPU_RESP_OK_EDID";
    800161fc:	00011797          	auipc	a5,0x11
    80016200:	16478793          	addi	a5,a5,356 # 80027360 <pow10.0+0x500>
    80016204:	a099                	j	8001624a <gpu_get_resp_string+0x14a>
        // Error responses
        case VIRTIO_GPU_RESP_ERR_UNSPEC: return "VIRTIO_GPU_RESP_ERR_UNSPEC";
    80016206:	00011797          	auipc	a5,0x11
    8001620a:	17278793          	addi	a5,a5,370 # 80027378 <pow10.0+0x518>
    8001620e:	a835                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY: return "VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY";
    80016210:	00011797          	auipc	a5,0x11
    80016214:	18878793          	addi	a5,a5,392 # 80027398 <pow10.0+0x538>
    80016218:	a80d                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID";
    8001621a:	00011797          	auipc	a5,0x11
    8001621e:	1a678793          	addi	a5,a5,422 # 800273c0 <pow10.0+0x560>
    80016222:	a025                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID";
    80016224:	00011797          	auipc	a5,0x11
    80016228:	1c478793          	addi	a5,a5,452 # 800273e8 <pow10.0+0x588>
    8001622c:	a839                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID: return "VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID";
    8001622e:	00011797          	auipc	a5,0x11
    80016232:	1e278793          	addi	a5,a5,482 # 80027410 <pow10.0+0x5b0>
    80016236:	a811                	j	8001624a <gpu_get_resp_string+0x14a>
        case VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER: return "VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER";
    80016238:	00011797          	auipc	a5,0x11
    8001623c:	20078793          	addi	a5,a5,512 # 80027438 <pow10.0+0x5d8>
    80016240:	a029                	j	8001624a <gpu_get_resp_string+0x14a>
        default: return "Invalid type argument to gpu_get_resp_string"; break;
    80016242:	00011797          	auipc	a5,0x11
    80016246:	21e78793          	addi	a5,a5,542 # 80027460 <pow10.0+0x600>
    }
}
    8001624a:	853e                	mv	a0,a5
    8001624c:	6462                	ld	s0,24(sp)
    8001624e:	6105                	addi	sp,sp,32
    80016250:	8082                	ret

0000000080016252 <gpu_init>:

// TODO: Implement checking for error responses
bool gpu_init(VirtioDevice *gpu_device) {
    80016252:	d1010113          	addi	sp,sp,-752
    80016256:	2e113423          	sd	ra,744(sp)
    8001625a:	2e813023          	sd	s0,736(sp)
    8001625e:	1d80                	addi	s0,sp,752
    80016260:	d0a43c23          	sd	a0,-744(s0)
    VirtioGpuDispInfoResp disp_info;
    gpu_get_display_info(gpu_device, &disp_info);
    80016264:	e5840793          	addi	a5,s0,-424
    80016268:	85be                	mv	a1,a5
    8001626a:	d1843503          	ld	a0,-744(s0)
    8001626e:	53a000ef          	jal	ra,800167a8 <gpu_get_display_info>
    
    // Allocate memory for frame buffer
    console.width = disp_info.displays[0].rect.width;
    80016272:	e7842703          	lw	a4,-392(s0)
    80016276:	0000f797          	auipc	a5,0xf
    8001627a:	e3a78793          	addi	a5,a5,-454 # 800250b0 <console>
    8001627e:	c398                	sw	a4,0(a5)
    console.height = disp_info.displays[0].rect.height;
    80016280:	e7c42703          	lw	a4,-388(s0)
    80016284:	0000f797          	auipc	a5,0xf
    80016288:	e2c78793          	addi	a5,a5,-468 # 800250b0 <console>
    8001628c:	c3d8                	sw	a4,4(a5)
    console.frame_buf = kcalloc(console.width * console.height, sizeof(Pixel));
    8001628e:	0000f797          	auipc	a5,0xf
    80016292:	e2278793          	addi	a5,a5,-478 # 800250b0 <console>
    80016296:	4398                	lw	a4,0(a5)
    80016298:	0000f797          	auipc	a5,0xf
    8001629c:	e1878793          	addi	a5,a5,-488 # 800250b0 <console>
    800162a0:	43dc                	lw	a5,4(a5)
    800162a2:	02f707bb          	mulw	a5,a4,a5
    800162a6:	2781                	sext.w	a5,a5
    800162a8:	1782                	slli	a5,a5,0x20
    800162aa:	9381                	srli	a5,a5,0x20
    800162ac:	4591                	li	a1,4
    800162ae:	853e                	mv	a0,a5
    800162b0:	aa2ff0ef          	jal	ra,80015552 <kcalloc>
    800162b4:	872a                	mv	a4,a0
    800162b6:	0000f797          	auipc	a5,0xf
    800162ba:	dfa78793          	addi	a5,a5,-518 # 800250b0 <console>
    800162be:	e798                	sd	a4,8(a5)
    debugf("gpu_init: Allocated frame buffer of (%d * %d) bytes at %p\n",
           sizeof(Pixel), console.width * console.height, console.frame_buf);
    800162c0:	0000f797          	auipc	a5,0xf
    800162c4:	df078793          	addi	a5,a5,-528 # 800250b0 <console>
    800162c8:	4398                	lw	a4,0(a5)
    800162ca:	0000f797          	auipc	a5,0xf
    800162ce:	de678793          	addi	a5,a5,-538 # 800250b0 <console>
    800162d2:	43dc                	lw	a5,4(a5)
    debugf("gpu_init: Allocated frame buffer of (%d * %d) bytes at %p\n",
    800162d4:	02f707bb          	mulw	a5,a4,a5
    800162d8:	0007871b          	sext.w	a4,a5
    800162dc:	0000f797          	auipc	a5,0xf
    800162e0:	dd478793          	addi	a5,a5,-556 # 800250b0 <console>
    800162e4:	679c                	ld	a5,8(a5)
    800162e6:	86be                	mv	a3,a5
    800162e8:	863a                	mv	a2,a4
    800162ea:	4591                	li	a1,4
    800162ec:	00011517          	auipc	a0,0x11
    800162f0:	1d450513          	addi	a0,a0,468 # 800274c0 <pow10.0+0x660>
    800162f4:	2ef050ef          	jal	ra,8001bde2 <debugf>

    VirtioGpuResCreate2d res2d;
    res2d.hdr.type = VIRTIO_GPU_CMD_RESOURCE_CREATE_2D;
    800162f8:	10100793          	li	a5,257
    800162fc:	e2f42823          	sw	a5,-464(s0)
    res2d.resource_id = 1; // Give an arbitrary unique number
    80016300:	4785                	li	a5,1
    80016302:	e4f42423          	sw	a5,-440(s0)
    res2d.format = R8G8B8A8_UNORM;
    80016306:	04300793          	li	a5,67
    8001630a:	e4f42623          	sw	a5,-436(s0)
    res2d.width = console.width;
    8001630e:	0000f797          	auipc	a5,0xf
    80016312:	da278793          	addi	a5,a5,-606 # 800250b0 <console>
    80016316:	439c                	lw	a5,0(a5)
    80016318:	e4f42823          	sw	a5,-432(s0)
    res2d.height = console.height;
    8001631c:	0000f797          	auipc	a5,0xf
    80016320:	d9478793          	addi	a5,a5,-620 # 800250b0 <console>
    80016324:	43dc                	lw	a5,4(a5)
    80016326:	e4f42a23          	sw	a5,-428(s0)

    VirtioGpuCtrlHdr resp_hdr;
    resp_hdr.type = 0;
    8001632a:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &res2d, sizeof(res2d), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    8001632e:	e1840793          	addi	a5,s0,-488
    80016332:	e3040613          	addi	a2,s0,-464
    80016336:	48e1                	li	a7,24
    80016338:	883e                	mv	a6,a5
    8001633a:	4781                	li	a5,0
    8001633c:	4701                	li	a4,0
    8001633e:	02800693          	li	a3,40
    80016342:	4581                	li	a1,0
    80016344:	d1843503          	ld	a0,-744(s0)
    80016348:	302000ef          	jal	ra,8001664a <gpu_send_command>
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    8001634c:	e1842783          	lw	a5,-488(s0)
    80016350:	873e                	mv	a4,a5
    80016352:	6785                	lui	a5,0x1
    80016354:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    80016358:	00f71863          	bne	a4,a5,80016368 <gpu_init+0x116>
        debugf("gpu_init: Create 2D resource OK\n");
    8001635c:	00011517          	auipc	a0,0x11
    80016360:	1a450513          	addi	a0,a0,420 # 80027500 <pow10.0+0x6a0>
    80016364:	27f050ef          	jal	ra,8001bde2 <debugf>
        // return false;
    }

    // Attach resource 2D
    VirtioGpuResourceAttachBacking attach_backing;
    attach_backing.hdr.type = VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING;
    80016368:	10600793          	li	a5,262
    8001636c:	def42c23          	sw	a5,-520(s0)
    attach_backing.resource_id = 1;
    80016370:	4785                	li	a5,1
    80016372:	e0f42823          	sw	a5,-496(s0)
    attach_backing.nr_entries = 1;
    80016376:	4785                	li	a5,1
    80016378:	e0f42a23          	sw	a5,-492(s0)
    VirtioGpuMemEntry mem;
    // mem.addr = kernel_mmu_translate((uintptr_t)console.frame_buf
    mem.addr = kernel_mmu_translate((uintptr_t)console.frame_buf);
    8001637c:	0000f797          	auipc	a5,0xf
    80016380:	d3478793          	addi	a5,a5,-716 # 800250b0 <console>
    80016384:	679c                	ld	a5,8(a5)
    80016386:	853e                	mv	a0,a5
    80016388:	efcff0ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001638c:	87aa                	mv	a5,a0
    8001638e:	def43423          	sd	a5,-536(s0)
    mem.length = console.width * console.width * sizeof(Pixel);
    80016392:	0000f797          	auipc	a5,0xf
    80016396:	d1e78793          	addi	a5,a5,-738 # 800250b0 <console>
    8001639a:	4398                	lw	a4,0(a5)
    8001639c:	0000f797          	auipc	a5,0xf
    800163a0:	d1478793          	addi	a5,a5,-748 # 800250b0 <console>
    800163a4:	439c                	lw	a5,0(a5)
    800163a6:	02f707bb          	mulw	a5,a4,a5
    800163aa:	2781                	sext.w	a5,a5
    800163ac:	0027979b          	slliw	a5,a5,0x2
    800163b0:	2781                	sext.w	a5,a5
    800163b2:	def42823          	sw	a5,-528(s0)
    mem.padding = 0;
    800163b6:	de042a23          	sw	zero,-524(s0)
    resp_hdr.type = 0;
    800163ba:	e0042c23          	sw	zero,-488(s0)
    
    gpu_send_command(gpu_device, 0, &attach_backing, sizeof(attach_backing), &mem, sizeof(mem), &resp_hdr, sizeof(resp_hdr));
    800163be:	e1840793          	addi	a5,s0,-488
    800163c2:	de840713          	addi	a4,s0,-536
    800163c6:	df840613          	addi	a2,s0,-520
    800163ca:	48e1                	li	a7,24
    800163cc:	883e                	mv	a6,a5
    800163ce:	47c1                	li	a5,16
    800163d0:	02000693          	li	a3,32
    800163d4:	4581                	li	a1,0
    800163d6:	d1843503          	ld	a0,-744(s0)
    800163da:	270000ef          	jal	ra,8001664a <gpu_send_command>
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    800163de:	e1842783          	lw	a5,-488(s0)
    800163e2:	873e                	mv	a4,a5
    800163e4:	6785                	lui	a5,0x1
    800163e6:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    800163ea:	00f71f63          	bne	a4,a5,80016408 <gpu_init+0x1b6>
        debugf("gpu_init: Attach backing OK (%s)\n", gpu_get_resp_string(resp_hdr.type));
    800163ee:	e1842783          	lw	a5,-488(s0)
    800163f2:	853e                	mv	a0,a5
    800163f4:	d0dff0ef          	jal	ra,80016100 <gpu_get_resp_string>
    800163f8:	87aa                	mv	a5,a0
    800163fa:	85be                	mv	a1,a5
    800163fc:	00011517          	auipc	a0,0x11
    80016400:	12c50513          	addi	a0,a0,300 # 80027528 <pow10.0+0x6c8>
    80016404:	1df050ef          	jal	ra,8001bde2 <debugf>
        // debugf("gpu_init: Attach backing failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    VirtioGpuSetScanout scan;
    scan.hdr.type = VIRTIO_GPU_CMD_SET_SCANOUT;
    80016408:	10300793          	li	a5,259
    8001640c:	daf42c23          	sw	a5,-584(s0)
    scan.rect.x = 0;
    80016410:	dc042823          	sw	zero,-560(s0)
    scan.rect.y = 0;
    80016414:	dc042a23          	sw	zero,-556(s0)
    scan.rect.width = console.width;
    80016418:	0000f797          	auipc	a5,0xf
    8001641c:	c9878793          	addi	a5,a5,-872 # 800250b0 <console>
    80016420:	439c                	lw	a5,0(a5)
    80016422:	dcf42c23          	sw	a5,-552(s0)
    scan.rect.height = console.height;
    80016426:	0000f797          	auipc	a5,0xf
    8001642a:	c8a78793          	addi	a5,a5,-886 # 800250b0 <console>
    8001642e:	43dc                	lw	a5,4(a5)
    80016430:	dcf42e23          	sw	a5,-548(s0)
    scan.resource_id = 1;
    80016434:	4785                	li	a5,1
    80016436:	def42223          	sw	a5,-540(s0)
    scan.scanout_id = 0;
    8001643a:	de042023          	sw	zero,-544(s0)
    resp_hdr.type = 0;
    8001643e:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &scan, sizeof(scan), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    80016442:	e1840793          	addi	a5,s0,-488
    80016446:	db840613          	addi	a2,s0,-584
    8001644a:	48e1                	li	a7,24
    8001644c:	883e                	mv	a6,a5
    8001644e:	4781                	li	a5,0
    80016450:	4701                	li	a4,0
    80016452:	03000693          	li	a3,48
    80016456:	4581                	li	a1,0
    80016458:	d1843503          	ld	a0,-744(s0)
    8001645c:	1ee000ef          	jal	ra,8001664a <gpu_send_command>

    Rectangle r1 = {0, 0, console.width, console.height};
    80016460:	da042423          	sw	zero,-600(s0)
    80016464:	da042623          	sw	zero,-596(s0)
    80016468:	0000f797          	auipc	a5,0xf
    8001646c:	c4878793          	addi	a5,a5,-952 # 800250b0 <console>
    80016470:	439c                	lw	a5,0(a5)
    80016472:	daf42823          	sw	a5,-592(s0)
    80016476:	0000f797          	auipc	a5,0xf
    8001647a:	c3a78793          	addi	a5,a5,-966 # 800250b0 <console>
    8001647e:	43dc                	lw	a5,4(a5)
    80016480:	daf42a23          	sw	a5,-588(s0)
    Rectangle r2 = {100, 100, console.width - 150, console.height - 150};
    80016484:	06400793          	li	a5,100
    80016488:	d8f42c23          	sw	a5,-616(s0)
    8001648c:	06400793          	li	a5,100
    80016490:	d8f42e23          	sw	a5,-612(s0)
    80016494:	0000f797          	auipc	a5,0xf
    80016498:	c1c78793          	addi	a5,a5,-996 # 800250b0 <console>
    8001649c:	439c                	lw	a5,0(a5)
    8001649e:	f6a7879b          	addiw	a5,a5,-150
    800164a2:	2781                	sext.w	a5,a5
    800164a4:	daf42023          	sw	a5,-608(s0)
    800164a8:	0000f797          	auipc	a5,0xf
    800164ac:	c0878793          	addi	a5,a5,-1016 # 800250b0 <console>
    800164b0:	43dc                	lw	a5,4(a5)
    800164b2:	f6a7879b          	addiw	a5,a5,-150
    800164b6:	2781                	sext.w	a5,a5
    800164b8:	daf42223          	sw	a5,-604(s0)
    Pixel p1 = {255, 100, 50, 255};
    800164bc:	00013797          	auipc	a5,0x13
    800164c0:	3d478793          	addi	a5,a5,980 # 80029890 <NUM_SYSCALLS+0x8>
    800164c4:	439c                	lw	a5,0(a5)
    800164c6:	d8f42823          	sw	a5,-624(s0)
    Pixel p2 = {88, 89, 91, 255};
    800164ca:	00013797          	auipc	a5,0x13
    800164ce:	3ce78793          	addi	a5,a5,974 # 80029898 <NUM_SYSCALLS+0x10>
    800164d2:	439c                	lw	a5,0(a5)
    800164d4:	d8f42423          	sw	a5,-632(s0)

    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    800164d8:	e1842783          	lw	a5,-488(s0)
    800164dc:	873e                	mv	a4,a5
    800164de:	6785                	lui	a5,0x1
    800164e0:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    800164e4:	00f71863          	bne	a4,a5,800164f4 <gpu_init+0x2a2>
        debugf("gpu_init: Set scanout OK\n");
    800164e8:	00011517          	auipc	a0,0x11
    800164ec:	06850513          	addi	a0,a0,104 # 80027550 <pow10.0+0x6f0>
    800164f0:	0f3050ef          	jal	ra,8001bde2 <debugf>
    } else {
        // debugf("gpu_init: Set scanout failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    fill_rect(console.width, console.height, console.frame_buf, &r1, &p1);
    800164f4:	0000f797          	auipc	a5,0xf
    800164f8:	bbc78793          	addi	a5,a5,-1092 # 800250b0 <console>
    800164fc:	4388                	lw	a0,0(a5)
    800164fe:	0000f797          	auipc	a5,0xf
    80016502:	bb278793          	addi	a5,a5,-1102 # 800250b0 <console>
    80016506:	43cc                	lw	a1,4(a5)
    80016508:	0000f797          	auipc	a5,0xf
    8001650c:	ba878793          	addi	a5,a5,-1112 # 800250b0 <console>
    80016510:	679c                	ld	a5,8(a5)
    80016512:	d9040713          	addi	a4,s0,-624
    80016516:	da840693          	addi	a3,s0,-600
    8001651a:	863e                	mv	a2,a5
    8001651c:	448000ef          	jal	ra,80016964 <fill_rect>
    stroke_rect(console.width, console.height, console.frame_buf, &r2, &p2, 10);
    80016520:	0000f797          	auipc	a5,0xf
    80016524:	b9078793          	addi	a5,a5,-1136 # 800250b0 <console>
    80016528:	4388                	lw	a0,0(a5)
    8001652a:	0000f797          	auipc	a5,0xf
    8001652e:	b8678793          	addi	a5,a5,-1146 # 800250b0 <console>
    80016532:	43cc                	lw	a1,4(a5)
    80016534:	0000f797          	auipc	a5,0xf
    80016538:	b7c78793          	addi	a5,a5,-1156 # 800250b0 <console>
    8001653c:	6790                	ld	a2,8(a5)
    8001653e:	d8840713          	addi	a4,s0,-632
    80016542:	d9840693          	addi	a3,s0,-616
    80016546:	47a9                	li	a5,10
    80016548:	58c000ef          	jal	ra,80016ad4 <stroke_rect>

    VirtioGpuTransferToHost2d tx;
    tx.hdr.type = VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D;
    8001654c:	10500793          	li	a5,261
    80016550:	d4f42823          	sw	a5,-688(s0)
    tx.rect.x = 0;
    80016554:	d6042423          	sw	zero,-664(s0)
    tx.rect.y = 0;
    80016558:	d6042623          	sw	zero,-660(s0)
    tx.rect.width = console.width;
    8001655c:	0000f797          	auipc	a5,0xf
    80016560:	b5478793          	addi	a5,a5,-1196 # 800250b0 <console>
    80016564:	439c                	lw	a5,0(a5)
    80016566:	d6f42823          	sw	a5,-656(s0)
    tx.rect.height = console.height;
    8001656a:	0000f797          	auipc	a5,0xf
    8001656e:	b4678793          	addi	a5,a5,-1210 # 800250b0 <console>
    80016572:	43dc                	lw	a5,4(a5)
    80016574:	d6f42a23          	sw	a5,-652(s0)
    tx.offset = 0;
    80016578:	d6043c23          	sd	zero,-648(s0)
    tx.resource_id = 1;
    8001657c:	4785                	li	a5,1
    8001657e:	d8f42023          	sw	a5,-640(s0)
    tx.padding = 0;
    80016582:	d8042223          	sw	zero,-636(s0)
    resp_hdr.type = 0;
    80016586:	e0042c23          	sw	zero,-488(s0)

    gpu_send_command(gpu_device, 0, &tx, sizeof(tx), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    8001658a:	e1840793          	addi	a5,s0,-488
    8001658e:	d5040613          	addi	a2,s0,-688
    80016592:	48e1                	li	a7,24
    80016594:	883e                	mv	a6,a5
    80016596:	4781                	li	a5,0
    80016598:	4701                	li	a4,0
    8001659a:	03800693          	li	a3,56
    8001659e:	4581                	li	a1,0
    800165a0:	d1843503          	ld	a0,-744(s0)
    800165a4:	0a6000ef          	jal	ra,8001664a <gpu_send_command>
    
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    800165a8:	e1842783          	lw	a5,-488(s0)
    800165ac:	873e                	mv	a4,a5
    800165ae:	6785                	lui	a5,0x1
    800165b0:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    800165b4:	00f71863          	bne	a4,a5,800165c4 <gpu_init+0x372>
        debugf("gpu_init: Transfer OK\n");
    800165b8:	00011517          	auipc	a0,0x11
    800165bc:	fb850513          	addi	a0,a0,-72 # 80027570 <pow10.0+0x710>
    800165c0:	023050ef          	jal	ra,8001bde2 <debugf>
        // debugf("gpu_init: Transfer failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    VirtioGpuResourceFlush flush;
    flush.hdr.type = VIRTIO_GPU_CMD_RESOURCE_FLUSH;
    800165c4:	10400793          	li	a5,260
    800165c8:	d2f42023          	sw	a5,-736(s0)
    flush.rect.x = 0;
    800165cc:	d2042c23          	sw	zero,-712(s0)
    flush.rect.y = 0;
    800165d0:	d2042e23          	sw	zero,-708(s0)
    flush.rect.width = console.width;
    800165d4:	0000f797          	auipc	a5,0xf
    800165d8:	adc78793          	addi	a5,a5,-1316 # 800250b0 <console>
    800165dc:	439c                	lw	a5,0(a5)
    800165de:	d4f42023          	sw	a5,-704(s0)
    flush.rect.height = console.height;
    800165e2:	0000f797          	auipc	a5,0xf
    800165e6:	ace78793          	addi	a5,a5,-1330 # 800250b0 <console>
    800165ea:	43dc                	lw	a5,4(a5)
    800165ec:	d4f42223          	sw	a5,-700(s0)
    flush.resource_id = 1;
    800165f0:	4785                	li	a5,1
    800165f2:	d4f42423          	sw	a5,-696(s0)
    flush.padding = 0;
    800165f6:	d4042623          	sw	zero,-692(s0)
    resp_hdr.type = 0;
    800165fa:	e0042c23          	sw	zero,-488(s0)
    gpu_send_command(gpu_device, 0, &flush, sizeof(flush), NULL, 0, &resp_hdr, sizeof(resp_hdr));
    800165fe:	e1840793          	addi	a5,s0,-488
    80016602:	d2040613          	addi	a2,s0,-736
    80016606:	48e1                	li	a7,24
    80016608:	883e                	mv	a6,a5
    8001660a:	4781                	li	a5,0
    8001660c:	4701                	li	a4,0
    8001660e:	03000693          	li	a3,48
    80016612:	4581                	li	a1,0
    80016614:	d1843503          	ld	a0,-744(s0)
    80016618:	032000ef          	jal	ra,8001664a <gpu_send_command>
    
    if (resp_hdr.type == VIRTIO_GPU_RESP_OK_NODATA) {
    8001661c:	e1842783          	lw	a5,-488(s0)
    80016620:	873e                	mv	a4,a5
    80016622:	6785                	lui	a5,0x1
    80016624:	10078793          	addi	a5,a5,256 # 1100 <i+0x10e0>
    80016628:	00f71863          	bne	a4,a5,80016638 <gpu_init+0x3e6>
        debugf("gpu_init: Flush OK\n");
    8001662c:	00011517          	auipc	a0,0x11
    80016630:	f5c50513          	addi	a0,a0,-164 # 80027588 <pow10.0+0x728>
    80016634:	7ae050ef          	jal	ra,8001bde2 <debugf>
    } else {
        // debugf("gpu_init: Flush failed with %s\n", gpu_get_resp_string(resp_hdr.type));
        // return false;
    }

    return true;
    80016638:	4785                	li	a5,1
}
    8001663a:	853e                	mv	a0,a5
    8001663c:	2e813083          	ld	ra,744(sp)
    80016640:	2e013403          	ld	s0,736(sp)
    80016644:	2f010113          	addi	sp,sp,752
    80016648:	8082                	ret

000000008001664a <gpu_send_command>:
                      void *cmd,
                      size_t cmd_size,
                      void *resp0,
                      size_t resp0_size,
                      void *resp1,
                      size_t resp1_size) {
    8001664a:	7115                	addi	sp,sp,-224
    8001664c:	ed86                	sd	ra,216(sp)
    8001664e:	e9a2                	sd	s0,208(sp)
    80016650:	1180                	addi	s0,sp,224
    80016652:	f4a43c23          	sd	a0,-168(s0)
    80016656:	f4c43423          	sd	a2,-184(s0)
    8001665a:	f4d43023          	sd	a3,-192(s0)
    8001665e:	f2e43c23          	sd	a4,-200(s0)
    80016662:	f2f43823          	sd	a5,-208(s0)
    80016666:	f3043423          	sd	a6,-216(s0)
    8001666a:	f3143023          	sd	a7,-224(s0)
    8001666e:	87ae                	mv	a5,a1
    80016670:	f4f41b23          	sh	a5,-170(s0)
    VirtioDescriptor cmd_desc;
    cmd_desc.addr = kernel_mmu_translate((uintptr_t)cmd);
    80016674:	f4843783          	ld	a5,-184(s0)
    80016678:	853e                	mv	a0,a5
    8001667a:	c0aff0ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001667e:	87aa                	mv	a5,a0
    80016680:	fcf43823          	sd	a5,-48(s0)
    cmd_desc.len = cmd_size;
    80016684:	f4043783          	ld	a5,-192(s0)
    80016688:	2781                	sext.w	a5,a5
    8001668a:	fcf42c23          	sw	a5,-40(s0)
    cmd_desc.flags = VIRTQ_DESC_F_NEXT;
    8001668e:	4785                	li	a5,1
    80016690:	fcf41e23          	sh	a5,-36(s0)

    VirtioDescriptor resp0_desc;
    resp0_desc.addr = kernel_mmu_translate((uintptr_t)resp0);
    80016694:	f3843783          	ld	a5,-200(s0)
    80016698:	853e                	mv	a0,a5
    8001669a:	beaff0ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001669e:	87aa                	mv	a5,a0
    800166a0:	fcf43023          	sd	a5,-64(s0)
    resp0_desc.len = resp0_size;
    800166a4:	f3043783          	ld	a5,-208(s0)
    800166a8:	2781                	sext.w	a5,a5
    800166aa:	fcf42423          	sw	a5,-56(s0)
    resp0_desc.flags = VIRTQ_DESC_F_NEXT;
    800166ae:	4785                	li	a5,1
    800166b0:	fcf41623          	sh	a5,-52(s0)
    
    VirtioDescriptor resp1_desc;
    resp1_desc.addr = kernel_mmu_translate((uintptr_t)resp1);
    800166b4:	f2843783          	ld	a5,-216(s0)
    800166b8:	853e                	mv	a0,a5
    800166ba:	bcaff0ef          	jal	ra,80015a84 <kernel_mmu_translate>
    800166be:	87aa                	mv	a5,a0
    800166c0:	faf43823          	sd	a5,-80(s0)
    resp1_desc.len = resp1_size;
    800166c4:	f2043783          	ld	a5,-224(s0)
    800166c8:	2781                	sext.w	a5,a5
    800166ca:	faf42c23          	sw	a5,-72(s0)
    resp1_desc.flags = VIRTQ_DESC_F_WRITE;
    800166ce:	4789                	li	a5,2
    800166d0:	faf41e23          	sh	a5,-68(s0)

    VirtioDescriptor chain0[2] = {cmd_desc, resp1_desc};
    800166d4:	fd043783          	ld	a5,-48(s0)
    800166d8:	f8f43823          	sd	a5,-112(s0)
    800166dc:	fd843783          	ld	a5,-40(s0)
    800166e0:	f8f43c23          	sd	a5,-104(s0)
    800166e4:	fb043783          	ld	a5,-80(s0)
    800166e8:	faf43023          	sd	a5,-96(s0)
    800166ec:	fb843783          	ld	a5,-72(s0)
    800166f0:	faf43423          	sd	a5,-88(s0)
    VirtioDescriptor chain1[3] = {cmd_desc, resp0_desc, resp1_desc};
    800166f4:	fd043783          	ld	a5,-48(s0)
    800166f8:	f6f43023          	sd	a5,-160(s0)
    800166fc:	fd843783          	ld	a5,-40(s0)
    80016700:	f6f43423          	sd	a5,-152(s0)
    80016704:	fc043783          	ld	a5,-64(s0)
    80016708:	f6f43823          	sd	a5,-144(s0)
    8001670c:	fc843783          	ld	a5,-56(s0)
    80016710:	f6f43c23          	sd	a5,-136(s0)
    80016714:	fb043783          	ld	a5,-80(s0)
    80016718:	f8f43023          	sd	a5,-128(s0)
    8001671c:	fb843783          	ld	a5,-72(s0)
    80016720:	f8f43423          	sd	a5,-120(s0)
    VirtioDescriptor *chain = resp0 == NULL ? chain0 : chain1;
    80016724:	f3843783          	ld	a5,-200(s0)
    80016728:	e781                	bnez	a5,80016730 <gpu_send_command+0xe6>
    8001672a:	f9040793          	addi	a5,s0,-112
    8001672e:	a019                	j	80016734 <gpu_send_command+0xea>
    80016730:	f6040793          	addi	a5,s0,-160
    80016734:	fef43423          	sd	a5,-24(s0)
    unsigned num_descriptors = resp0 == NULL ? 2 : 3;
    80016738:	f3843783          	ld	a5,-200(s0)
    8001673c:	e399                	bnez	a5,80016742 <gpu_send_command+0xf8>
    8001673e:	4789                	li	a5,2
    80016740:	a011                	j	80016744 <gpu_send_command+0xfa>
    80016742:	478d                	li	a5,3
    80016744:	fef42223          	sw	a5,-28(s0)
    virtio_send_descriptor_chain(gpu_device, which_queue, chain, num_descriptors, true);
    80016748:	fe442783          	lw	a5,-28(s0)
    8001674c:	03079693          	slli	a3,a5,0x30
    80016750:	92c1                	srli	a3,a3,0x30
    80016752:	f5645783          	lhu	a5,-170(s0)
    80016756:	4705                	li	a4,1
    80016758:	fe843603          	ld	a2,-24(s0)
    8001675c:	85be                	mv	a1,a5
    8001675e:	f5843503          	ld	a0,-168(s0)
    80016762:	593060ef          	jal	ra,8001d4f4 <virtio_send_descriptor_chain>
    
    // Wait until device_idx catches up 
    while (gpu_device->device_idx != gpu_device->device->idx) {
    80016766:	a039                	j	80016774 <gpu_send_command+0x12a>
        debugf("GPU WAITING\n");
    80016768:	00011517          	auipc	a0,0x11
    8001676c:	e3850513          	addi	a0,a0,-456 # 800275a0 <pow10.0+0x740>
    80016770:	672050ef          	jal	ra,8001bde2 <debugf>
    while (gpu_device->device_idx != gpu_device->device->idx) {
    80016774:	f5843783          	ld	a5,-168(s0)
    80016778:	08c7d703          	lhu	a4,140(a5)
    8001677c:	f5843783          	ld	a5,-168(s0)
    80016780:	7bbc                	ld	a5,112(a5)
    80016782:	0027d783          	lhu	a5,2(a5)
    80016786:	17c2                	slli	a5,a5,0x30
    80016788:	93c1                	srli	a5,a5,0x30
    8001678a:	2701                	sext.w	a4,a4
    8001678c:	2781                	sext.w	a5,a5
    8001678e:	fcf71de3          	bne	a4,a5,80016768 <gpu_send_command+0x11e>
    }
    debugf("gpu_send_command: device_idx caught up\n");
    80016792:	00011517          	auipc	a0,0x11
    80016796:	e1e50513          	addi	a0,a0,-482 # 800275b0 <pow10.0+0x750>
    8001679a:	648050ef          	jal	ra,8001bde2 <debugf>
}
    8001679e:	0001                	nop
    800167a0:	60ee                	ld	ra,216(sp)
    800167a2:	644e                	ld	s0,208(sp)
    800167a4:	612d                	addi	sp,sp,224
    800167a6:	8082                	ret

00000000800167a8 <gpu_get_display_info>:

// Get display info and set frame buffer's info.
// Return true if display is enabled. Return false if not.
bool gpu_get_display_info(VirtioDevice *gpu_device,
                          VirtioGpuDispInfoResp *disp_resp) {
    800167a8:	7119                	addi	sp,sp,-128
    800167aa:	fc86                	sd	ra,120(sp)
    800167ac:	f8a2                	sd	s0,112(sp)
    800167ae:	0100                	addi	s0,sp,128
    800167b0:	f8a43423          	sd	a0,-120(s0)
    800167b4:	f8b43023          	sd	a1,-128(s0)
    VirtioGpuCtrlHdr hdr;
    hdr.type = VIRTIO_GPU_CMD_GET_DISPLAY_INFO;
    800167b8:	10000793          	li	a5,256
    800167bc:	fcf42c23          	sw	a5,-40(s0)
    hdr.flags = 0;
    800167c0:	fc042e23          	sw	zero,-36(s0)
    hdr.fence_id = 0;
    800167c4:	fe043023          	sd	zero,-32(s0)
    hdr.context_id = 0;
    800167c8:	fe042423          	sw	zero,-24(s0)
    hdr.padding = 0;
    800167cc:	fe042623          	sw	zero,-20(s0)

    VirtioDescriptor hdr_desc;
    hdr_desc.addr = kernel_mmu_translate((uintptr_t)&hdr);
    800167d0:	fd840793          	addi	a5,s0,-40
    800167d4:	853e                	mv	a0,a5
    800167d6:	aaeff0ef          	jal	ra,80015a84 <kernel_mmu_translate>
    800167da:	87aa                	mv	a5,a0
    800167dc:	fcf43423          	sd	a5,-56(s0)
    hdr_desc.len = sizeof(hdr);
    800167e0:	47e1                	li	a5,24
    800167e2:	fcf42823          	sw	a5,-48(s0)
    hdr_desc.flags = VIRTQ_DESC_F_NEXT;
    800167e6:	4785                	li	a5,1
    800167e8:	fcf41a23          	sh	a5,-44(s0)

    VirtioDescriptor disp_resp_desc;
    disp_resp_desc.addr = kernel_mmu_translate((uintptr_t)disp_resp);
    800167ec:	f8043783          	ld	a5,-128(s0)
    800167f0:	853e                	mv	a0,a5
    800167f2:	a92ff0ef          	jal	ra,80015a84 <kernel_mmu_translate>
    800167f6:	87aa                	mv	a5,a0
    800167f8:	faf43c23          	sd	a5,-72(s0)
    disp_resp_desc.len = sizeof(VirtioGpuDispInfoResp);
    800167fc:	19800793          	li	a5,408
    80016800:	fcf42023          	sw	a5,-64(s0)
    disp_resp_desc.flags = VIRTQ_DESC_F_WRITE;
    80016804:	4789                	li	a5,2
    80016806:	fcf41223          	sh	a5,-60(s0)

    VirtioDescriptor chain[2] = {hdr_desc, disp_resp_desc};
    8001680a:	fc843783          	ld	a5,-56(s0)
    8001680e:	f8f43c23          	sd	a5,-104(s0)
    80016812:	fd043783          	ld	a5,-48(s0)
    80016816:	faf43023          	sd	a5,-96(s0)
    8001681a:	fb843783          	ld	a5,-72(s0)
    8001681e:	faf43423          	sd	a5,-88(s0)
    80016822:	fc043783          	ld	a5,-64(s0)
    80016826:	faf43823          	sd	a5,-80(s0)

    virtio_send_descriptor_chain(gpu_device, 0, chain, 2, true);
    8001682a:	f9840793          	addi	a5,s0,-104
    8001682e:	4705                	li	a4,1
    80016830:	4689                	li	a3,2
    80016832:	863e                	mv	a2,a5
    80016834:	4581                	li	a1,0
    80016836:	f8843503          	ld	a0,-120(s0)
    8001683a:	4bb060ef          	jal	ra,8001d4f4 <virtio_send_descriptor_chain>

    debugf("Internal desc_idx: %d\n", gpu_device->desc_idx);
    8001683e:	f8843783          	ld	a5,-120(s0)
    80016842:	0887d783          	lhu	a5,136(a5)
    80016846:	2781                	sext.w	a5,a5
    80016848:	85be                	mv	a1,a5
    8001684a:	00011517          	auipc	a0,0x11
    8001684e:	d8e50513          	addi	a0,a0,-626 # 800275d8 <pow10.0+0x778>
    80016852:	590050ef          	jal	ra,8001bde2 <debugf>
    debugf("Internal driver_idx: %d\n", gpu_device->driver_idx);
    80016856:	f8843783          	ld	a5,-120(s0)
    8001685a:	08a7d783          	lhu	a5,138(a5)
    8001685e:	2781                	sext.w	a5,a5
    80016860:	85be                	mv	a1,a5
    80016862:	00011517          	auipc	a0,0x11
    80016866:	d8e50513          	addi	a0,a0,-626 # 800275f0 <pow10.0+0x790>
    8001686a:	578050ef          	jal	ra,8001bde2 <debugf>
    debugf("Internal device_idx: %d\n", gpu_device->device_idx);
    8001686e:	f8843783          	ld	a5,-120(s0)
    80016872:	08c7d783          	lhu	a5,140(a5)
    80016876:	2781                	sext.w	a5,a5
    80016878:	85be                	mv	a1,a5
    8001687a:	00011517          	auipc	a0,0x11
    8001687e:	d9650513          	addi	a0,a0,-618 # 80027610 <pow10.0+0x7b0>
    80016882:	560050ef          	jal	ra,8001bde2 <debugf>
    debugf("Driver ring index: %d\n", gpu_device->driver->idx);
    80016886:	f8843783          	ld	a5,-120(s0)
    8001688a:	77bc                	ld	a5,104(a5)
    8001688c:	0027d783          	lhu	a5,2(a5)
    80016890:	17c2                	slli	a5,a5,0x30
    80016892:	93c1                	srli	a5,a5,0x30
    80016894:	2781                	sext.w	a5,a5
    80016896:	85be                	mv	a1,a5
    80016898:	00011517          	auipc	a0,0x11
    8001689c:	d9850513          	addi	a0,a0,-616 # 80027630 <pow10.0+0x7d0>
    800168a0:	542050ef          	jal	ra,8001bde2 <debugf>
    debugf("Device ring index: %d\n", gpu_device->device->idx);
    800168a4:	f8843783          	ld	a5,-120(s0)
    800168a8:	7bbc                	ld	a5,112(a5)
    800168aa:	0027d783          	lhu	a5,2(a5)
    800168ae:	17c2                	slli	a5,a5,0x30
    800168b0:	93c1                	srli	a5,a5,0x30
    800168b2:	2781                	sext.w	a5,a5
    800168b4:	85be                	mv	a1,a5
    800168b6:	00011517          	auipc	a0,0x11
    800168ba:	d9250513          	addi	a0,a0,-622 # 80027648 <pow10.0+0x7e8>
    800168be:	524050ef          	jal	ra,8001bde2 <debugf>

    debugf("used element id: %d\n", gpu_device->device->ring[0].id);
    800168c2:	f8843783          	ld	a5,-120(s0)
    800168c6:	7bbc                	ld	a5,112(a5)
    800168c8:	43dc                	lw	a5,4(a5)
    800168ca:	2781                	sext.w	a5,a5
    800168cc:	85be                	mv	a1,a5
    800168ce:	00011517          	auipc	a0,0x11
    800168d2:	d9250513          	addi	a0,a0,-622 # 80027660 <pow10.0+0x800>
    800168d6:	50c050ef          	jal	ra,8001bde2 <debugf>
    debugf("used element len: %d\n", gpu_device->device->ring[0].len);
    800168da:	f8843783          	ld	a5,-120(s0)
    800168de:	7bbc                	ld	a5,112(a5)
    800168e0:	479c                	lw	a5,8(a5)
    800168e2:	2781                	sext.w	a5,a5
    800168e4:	85be                	mv	a1,a5
    800168e6:	00011517          	auipc	a0,0x11
    800168ea:	d9250513          	addi	a0,a0,-622 # 80027678 <pow10.0+0x818>
    800168ee:	4f4050ef          	jal	ra,8001bde2 <debugf>
    debugf("used element id: %d\n", gpu_device->device->ring[1].id);
    800168f2:	f8843783          	ld	a5,-120(s0)
    800168f6:	7bbc                	ld	a5,112(a5)
    800168f8:	47dc                	lw	a5,12(a5)
    800168fa:	2781                	sext.w	a5,a5
    800168fc:	85be                	mv	a1,a5
    800168fe:	00011517          	auipc	a0,0x11
    80016902:	d6250513          	addi	a0,a0,-670 # 80027660 <pow10.0+0x800>
    80016906:	4dc050ef          	jal	ra,8001bde2 <debugf>
    debugf("used element len: %d\n", gpu_device->device->ring[1].len);
    8001690a:	f8843783          	ld	a5,-120(s0)
    8001690e:	7bbc                	ld	a5,112(a5)
    80016910:	4b9c                	lw	a5,16(a5)
    80016912:	2781                	sext.w	a5,a5
    80016914:	85be                	mv	a1,a5
    80016916:	00011517          	auipc	a0,0x11
    8001691a:	d6250513          	addi	a0,a0,-670 # 80027678 <pow10.0+0x818>
    8001691e:	4c4050ef          	jal	ra,8001bde2 <debugf>

    if (disp_resp->hdr.type == VIRTIO_GPU_RESP_OK_DISPLAY_INFO)
    80016922:	f8043783          	ld	a5,-128(s0)
    80016926:	439c                	lw	a5,0(a5)
    80016928:	873e                	mv	a4,a5
    8001692a:	6785                	lui	a5,0x1
    8001692c:	10178793          	addi	a5,a5,257 # 1101 <i+0x10e1>
    80016930:	00f71863          	bne	a4,a5,80016940 <gpu_get_display_info+0x198>
        debugf("gpu_get_display_info: Received display info\n");
    80016934:	00011517          	auipc	a0,0x11
    80016938:	d5c50513          	addi	a0,a0,-676 # 80027690 <pow10.0+0x830>
    8001693c:	4a6050ef          	jal	ra,8001bde2 <debugf>

    if (!disp_resp->displays[0].enabled)
    80016940:	f8043783          	ld	a5,-128(s0)
    80016944:	579c                	lw	a5,40(a5)
    80016946:	e399                	bnez	a5,8001694c <gpu_get_display_info+0x1a4>
        return false;
    80016948:	4781                	li	a5,0
    8001694a:	a801                	j	8001695a <gpu_get_display_info+0x1b2>
    debugf("gpu_get_display_info: Display 0 enabled\n");
    8001694c:	00011517          	auipc	a0,0x11
    80016950:	d7450513          	addi	a0,a0,-652 # 800276c0 <pow10.0+0x860>
    80016954:	48e050ef          	jal	ra,8001bde2 <debugf>

    return true;
    80016958:	4785                	li	a5,1
}
    8001695a:	853e                	mv	a0,a5
    8001695c:	70e6                	ld	ra,120(sp)
    8001695e:	7446                	ld	s0,112(sp)
    80016960:	6109                	addi	sp,sp,128
    80016962:	8082                	ret

0000000080016964 <fill_rect>:
void fill_rect(uint32_t screen_width,
               uint32_t screen_height,
               Pixel *frame_buf,
               const Rectangle *rect,
               const Pixel *fill_color)
               {
    80016964:	715d                	addi	sp,sp,-80
    80016966:	e4a2                	sd	s0,72(sp)
    80016968:	0880                	addi	s0,sp,80
    8001696a:	87aa                	mv	a5,a0
    8001696c:	fcc43023          	sd	a2,-64(s0)
    80016970:	fad43c23          	sd	a3,-72(s0)
    80016974:	fae43823          	sd	a4,-80(s0)
    80016978:	fcf42623          	sw	a5,-52(s0)
    8001697c:	87ae                	mv	a5,a1
    8001697e:	fcf42423          	sw	a5,-56(s0)
    uint32_t top = rect->y;
    80016982:	fb843783          	ld	a5,-72(s0)
    80016986:	43dc                	lw	a5,4(a5)
    80016988:	fcf42e23          	sw	a5,-36(s0)
    uint32_t bottom = rect->y + rect->height;
    8001698c:	fb843783          	ld	a5,-72(s0)
    80016990:	43d8                	lw	a4,4(a5)
    80016992:	fb843783          	ld	a5,-72(s0)
    80016996:	47dc                	lw	a5,12(a5)
    80016998:	9fb9                	addw	a5,a5,a4
    8001699a:	fef42623          	sw	a5,-20(s0)
    uint32_t left = rect->x;
    8001699e:	fb843783          	ld	a5,-72(s0)
    800169a2:	439c                	lw	a5,0(a5)
    800169a4:	fcf42c23          	sw	a5,-40(s0)
    uint32_t right = rect->x + rect->width;
    800169a8:	fb843783          	ld	a5,-72(s0)
    800169ac:	4398                	lw	a4,0(a5)
    800169ae:	fb843783          	ld	a5,-72(s0)
    800169b2:	479c                	lw	a5,8(a5)
    800169b4:	9fb9                	addw	a5,a5,a4
    800169b6:	fef42423          	sw	a5,-24(s0)
    uint32_t row;
    uint32_t col;
    // uint32_t offset;

    if (bottom > screen_height) {
    800169ba:	fec42703          	lw	a4,-20(s0)
    800169be:	fc842783          	lw	a5,-56(s0)
    800169c2:	2701                	sext.w	a4,a4
    800169c4:	2781                	sext.w	a5,a5
    800169c6:	00e7f663          	bgeu	a5,a4,800169d2 <fill_rect+0x6e>
        bottom = screen_height;
    800169ca:	fc842783          	lw	a5,-56(s0)
    800169ce:	fef42623          	sw	a5,-20(s0)
    }
    if (right > screen_width) {
    800169d2:	fe842703          	lw	a4,-24(s0)
    800169d6:	fcc42783          	lw	a5,-52(s0)
    800169da:	2701                	sext.w	a4,a4
    800169dc:	2781                	sext.w	a5,a5
    800169de:	00e7f663          	bgeu	a5,a4,800169ea <fill_rect+0x86>
        right = screen_width;
    800169e2:	fcc42783          	lw	a5,-52(s0)
    800169e6:	fef42423          	sw	a5,-24(s0)
    }

    for (row = top; row < bottom; row++) {
    800169ea:	fdc42783          	lw	a5,-36(s0)
    800169ee:	fef42223          	sw	a5,-28(s0)
    800169f2:	a89d                	j	80016a68 <fill_rect+0x104>
        for (col = left;col < right;col++) {
    800169f4:	fd842783          	lw	a5,-40(s0)
    800169f8:	fef42023          	sw	a5,-32(s0)
    800169fc:	a889                	j	80016a4e <fill_rect+0xea>
            frame_buf[row * screen_width + col] = *fill_color;
    800169fe:	fe442703          	lw	a4,-28(s0)
    80016a02:	fcc42783          	lw	a5,-52(s0)
    80016a06:	02f707bb          	mulw	a5,a4,a5
    80016a0a:	2781                	sext.w	a5,a5
    80016a0c:	fe042703          	lw	a4,-32(s0)
    80016a10:	9fb9                	addw	a5,a5,a4
    80016a12:	2781                	sext.w	a5,a5
    80016a14:	1782                	slli	a5,a5,0x20
    80016a16:	9381                	srli	a5,a5,0x20
    80016a18:	078a                	slli	a5,a5,0x2
    80016a1a:	fc043703          	ld	a4,-64(s0)
    80016a1e:	97ba                	add	a5,a5,a4
    80016a20:	fb043703          	ld	a4,-80(s0)
    80016a24:	00074583          	lbu	a1,0(a4)
    80016a28:	00174603          	lbu	a2,1(a4)
    80016a2c:	00274683          	lbu	a3,2(a4)
    80016a30:	00374703          	lbu	a4,3(a4)
    80016a34:	00b78023          	sb	a1,0(a5)
    80016a38:	00c780a3          	sb	a2,1(a5)
    80016a3c:	00d78123          	sb	a3,2(a5)
    80016a40:	00e781a3          	sb	a4,3(a5)
        for (col = left;col < right;col++) {
    80016a44:	fe042783          	lw	a5,-32(s0)
    80016a48:	2785                	addiw	a5,a5,1
    80016a4a:	fef42023          	sw	a5,-32(s0)
    80016a4e:	fe042703          	lw	a4,-32(s0)
    80016a52:	fe842783          	lw	a5,-24(s0)
    80016a56:	2701                	sext.w	a4,a4
    80016a58:	2781                	sext.w	a5,a5
    80016a5a:	faf762e3          	bltu	a4,a5,800169fe <fill_rect+0x9a>
    for (row = top; row < bottom; row++) {
    80016a5e:	fe442783          	lw	a5,-28(s0)
    80016a62:	2785                	addiw	a5,a5,1
    80016a64:	fef42223          	sw	a5,-28(s0)
    80016a68:	fe442703          	lw	a4,-28(s0)
    80016a6c:	fec42783          	lw	a5,-20(s0)
    80016a70:	2701                	sext.w	a4,a4
    80016a72:	2781                	sext.w	a5,a5
    80016a74:	f8f760e3          	bltu	a4,a5,800169f4 <fill_rect+0x90>
        }
   }
}
    80016a78:	0001                	nop
    80016a7a:	0001                	nop
    80016a7c:	6426                	ld	s0,72(sp)
    80016a7e:	6161                	addi	sp,sp,80
    80016a80:	8082                	ret

0000000080016a82 <RVALS>:
static inline void RVALS(Rectangle *r,
                         uint32_t x,
                         uint32_t y,
                         uint32_t width,
                         uint32_t height)
{
    80016a82:	7179                	addi	sp,sp,-48
    80016a84:	f422                	sd	s0,40(sp)
    80016a86:	1800                	addi	s0,sp,48
    80016a88:	fea43423          	sd	a0,-24(s0)
    80016a8c:	87ae                	mv	a5,a1
    80016a8e:	fef42223          	sw	a5,-28(s0)
    80016a92:	87b2                	mv	a5,a2
    80016a94:	fef42023          	sw	a5,-32(s0)
    80016a98:	87b6                	mv	a5,a3
    80016a9a:	fcf42e23          	sw	a5,-36(s0)
    80016a9e:	87ba                	mv	a5,a4
    80016aa0:	fcf42c23          	sw	a5,-40(s0)
    r->x = x;
    80016aa4:	fe843783          	ld	a5,-24(s0)
    80016aa8:	fe442703          	lw	a4,-28(s0)
    80016aac:	c398                	sw	a4,0(a5)
    r->y = y;
    80016aae:	fe843783          	ld	a5,-24(s0)
    80016ab2:	fe042703          	lw	a4,-32(s0)
    80016ab6:	c3d8                	sw	a4,4(a5)
    r->width = width;
    80016ab8:	fe843783          	ld	a5,-24(s0)
    80016abc:	fdc42703          	lw	a4,-36(s0)
    80016ac0:	c798                	sw	a4,8(a5)
    r->height = height;
    80016ac2:	fe843783          	ld	a5,-24(s0)
    80016ac6:	fd842703          	lw	a4,-40(s0)
    80016aca:	c7d8                	sw	a4,12(a5)
}
    80016acc:	0001                	nop
    80016ace:	7422                	ld	s0,40(sp)
    80016ad0:	6145                	addi	sp,sp,48
    80016ad2:	8082                	ret

0000000080016ad4 <stroke_rect>:
                 uint32_t screen_height,
                 Pixel *frame_buf,
                 const Rectangle *rect,
                 const Pixel *line_color,
                 uint32_t line_size)
{
    80016ad4:	715d                	addi	sp,sp,-80
    80016ad6:	e486                	sd	ra,72(sp)
    80016ad8:	e0a2                	sd	s0,64(sp)
    80016ada:	0880                	addi	s0,sp,80
    80016adc:	fcc43823          	sd	a2,-48(s0)
    80016ae0:	fcd43423          	sd	a3,-56(s0)
    80016ae4:	fce43023          	sd	a4,-64(s0)
    80016ae8:	873e                	mv	a4,a5
    80016aea:	87aa                	mv	a5,a0
    80016aec:	fcf42e23          	sw	a5,-36(s0)
    80016af0:	87ae                	mv	a5,a1
    80016af2:	fcf42c23          	sw	a5,-40(s0)
    80016af6:	87ba                	mv	a5,a4
    80016af8:	faf42e23          	sw	a5,-68(s0)
    struct Rectangle r;
    // Top
    RVALS(&r, rect->x, rect->y,
    80016afc:	fc843783          	ld	a5,-56(s0)
    80016b00:	438c                	lw	a1,0(a5)
    80016b02:	fc843783          	ld	a5,-56(s0)
    80016b06:	43d0                	lw	a2,4(a5)
    80016b08:	fc843783          	ld	a5,-56(s0)
    80016b0c:	4794                	lw	a3,8(a5)
    80016b0e:	fbc42703          	lw	a4,-68(s0)
    80016b12:	fe040793          	addi	a5,s0,-32
    80016b16:	853e                	mv	a0,a5
    80016b18:	f6bff0ef          	jal	ra,80016a82 <RVALS>
              rect->width, line_size);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80016b1c:	fe040693          	addi	a3,s0,-32
    80016b20:	fd842583          	lw	a1,-40(s0)
    80016b24:	fdc42783          	lw	a5,-36(s0)
    80016b28:	fc043703          	ld	a4,-64(s0)
    80016b2c:	fd043603          	ld	a2,-48(s0)
    80016b30:	853e                	mv	a0,a5
    80016b32:	e33ff0ef          	jal	ra,80016964 <fill_rect>

    // Bottom
    RVALS(&r, rect->x, rect->height + rect->y,
    80016b36:	fc843783          	ld	a5,-56(s0)
    80016b3a:	438c                	lw	a1,0(a5)
    80016b3c:	fc843783          	ld	a5,-56(s0)
    80016b40:	47d8                	lw	a4,12(a5)
    80016b42:	fc843783          	ld	a5,-56(s0)
    80016b46:	43dc                	lw	a5,4(a5)
    80016b48:	9fb9                	addw	a5,a5,a4
    80016b4a:	0007861b          	sext.w	a2,a5
    80016b4e:	fc843783          	ld	a5,-56(s0)
    80016b52:	4794                	lw	a3,8(a5)
    80016b54:	fbc42703          	lw	a4,-68(s0)
    80016b58:	fe040793          	addi	a5,s0,-32
    80016b5c:	853e                	mv	a0,a5
    80016b5e:	f25ff0ef          	jal	ra,80016a82 <RVALS>
              rect->width, line_size);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80016b62:	fe040693          	addi	a3,s0,-32
    80016b66:	fd842583          	lw	a1,-40(s0)
    80016b6a:	fdc42783          	lw	a5,-36(s0)
    80016b6e:	fc043703          	ld	a4,-64(s0)
    80016b72:	fd043603          	ld	a2,-48(s0)
    80016b76:	853e                	mv	a0,a5
    80016b78:	dedff0ef          	jal	ra,80016964 <fill_rect>

    // Left
    RVALS(&r, rect->x, rect->y,
    80016b7c:	fc843783          	ld	a5,-56(s0)
    80016b80:	438c                	lw	a1,0(a5)
    80016b82:	fc843783          	ld	a5,-56(s0)
    80016b86:	43d0                	lw	a2,4(a5)
    80016b88:	fc843783          	ld	a5,-56(s0)
    80016b8c:	47d8                	lw	a4,12(a5)
    80016b8e:	fbc42683          	lw	a3,-68(s0)
    80016b92:	fe040793          	addi	a5,s0,-32
    80016b96:	853e                	mv	a0,a5
    80016b98:	eebff0ef          	jal	ra,80016a82 <RVALS>
              line_size, rect->height);
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80016b9c:	fe040693          	addi	a3,s0,-32
    80016ba0:	fd842583          	lw	a1,-40(s0)
    80016ba4:	fdc42783          	lw	a5,-36(s0)
    80016ba8:	fc043703          	ld	a4,-64(s0)
    80016bac:	fd043603          	ld	a2,-48(s0)
    80016bb0:	853e                	mv	a0,a5
    80016bb2:	db3ff0ef          	jal	ra,80016964 <fill_rect>

    // Right
    RVALS(&r, rect->x + rect->width, rect->y,
    80016bb6:	fc843783          	ld	a5,-56(s0)
    80016bba:	4398                	lw	a4,0(a5)
    80016bbc:	fc843783          	ld	a5,-56(s0)
    80016bc0:	479c                	lw	a5,8(a5)
    80016bc2:	9fb9                	addw	a5,a5,a4
    80016bc4:	0007859b          	sext.w	a1,a5
    80016bc8:	fc843783          	ld	a5,-56(s0)
    80016bcc:	43d0                	lw	a2,4(a5)
              line_size, rect->height + line_size);
    80016bce:	fc843783          	ld	a5,-56(s0)
    80016bd2:	47dc                	lw	a5,12(a5)
    RVALS(&r, rect->x + rect->width, rect->y,
    80016bd4:	fbc42703          	lw	a4,-68(s0)
    80016bd8:	9fb9                	addw	a5,a5,a4
    80016bda:	0007871b          	sext.w	a4,a5
    80016bde:	fbc42683          	lw	a3,-68(s0)
    80016be2:	fe040793          	addi	a5,s0,-32
    80016be6:	853e                	mv	a0,a5
    80016be8:	e9bff0ef          	jal	ra,80016a82 <RVALS>
    fill_rect(screen_width, screen_height, frame_buf, &r, line_color);
    80016bec:	fe040693          	addi	a3,s0,-32
    80016bf0:	fd842583          	lw	a1,-40(s0)
    80016bf4:	fdc42783          	lw	a5,-36(s0)
    80016bf8:	fc043703          	ld	a4,-64(s0)
    80016bfc:	fd043603          	ld	a2,-48(s0)
    80016c00:	853e                	mv	a0,a5
    80016c02:	d63ff0ef          	jal	ra,80016964 <fill_rect>
}
    80016c06:	0001                	nop
    80016c08:	60a6                	ld	ra,72(sp)
    80016c0a:	6406                	ld	s0,64(sp)
    80016c0c:	6161                	addi	sp,sp,80
    80016c0e:	8082                	ret

0000000080016c10 <init_systems>:
// the kernel.
// Defined in src/include/mmu.h
PageTable *kernel_mmu_table;

static void init_systems(void)
{
    80016c10:	711d                	addi	sp,sp,-96
    80016c12:	ec86                	sd	ra,88(sp)
    80016c14:	e8a2                	sd	s0,80(sp)
    80016c16:	1080                	addi	s0,sp,96
    void plic_init(void);
    plic_init();
    80016c18:	087050ef          	jal	ra,8001c49e <plic_init>
    debugf("plic_init() done\n");
    80016c1c:	00011517          	auipc	a0,0x11
    80016c20:	ad450513          	addi	a0,a0,-1324 # 800276f0 <pow10.0+0x890>
    80016c24:	1be050ef          	jal	ra,8001bde2 <debugf>
    void page_init(void);
    page_init();
    80016c28:	7dd060ef          	jal	ra,8001dc04 <page_init>
    debugf("page_init() done\n");
    80016c2c:	00011517          	auipc	a0,0x11
    80016c30:	adc50513          	addi	a0,a0,-1316 # 80027708 <pow10.0+0x8a8>
    80016c34:	1ae050ef          	jal	ra,8001bde2 <debugf>

#ifdef USE_MMU
    PageTable *pt = mmu_table_create();
    80016c38:	a4bfe0ef          	jal	ra,80015682 <mmu_table_create>
    80016c3c:	fca43823          	sd	a0,-48(s0)
    kernel_mmu_table = pt;
    80016c40:	0000e797          	auipc	a5,0xe
    80016c44:	3c878793          	addi	a5,a5,968 # 80025008 <kernel_mmu_table>
    80016c48:	fd043703          	ld	a4,-48(s0)
    80016c4c:	e398                	sd	a4,0(a5)

    debugf("Kernel page table at %p\n", pt);
    80016c4e:	fd043583          	ld	a1,-48(s0)
    80016c52:	00011517          	auipc	a0,0x11
    80016c56:	ace50513          	addi	a0,a0,-1330 # 80027720 <pow10.0+0x8c0>
    80016c5a:	188050ef          	jal	ra,8001bde2 <debugf>
    // Map memory segments for our kernel
    debugf("Mapping kernel segments\n");
    80016c5e:	00011517          	auipc	a0,0x11
    80016c62:	ae250513          	addi	a0,a0,-1310 # 80027740 <pow10.0+0x8e0>
    80016c66:	17c050ef          	jal	ra,8001bde2 <debugf>
    mmu_map_range(pt, sym_start(text), sym_end(heap), sym_start(text), MMU_LEVEL_1G,
    80016c6a:	ffff9597          	auipc	a1,0xffff9
    80016c6e:	39658593          	addi	a1,a1,918 # 80010000 <_memory_start>
    80016c72:	07ff9617          	auipc	a2,0x7ff9
    80016c76:	38e60613          	addi	a2,a2,910 # 88010000 <_heap_end>
    80016c7a:	ffff9697          	auipc	a3,0xffff9
    80016c7e:	38668693          	addi	a3,a3,902 # 80010000 <_memory_start>
    80016c82:	47b9                	li	a5,14
    80016c84:	4709                	li	a4,2
    80016c86:	fd043503          	ld	a0,-48(s0)
    80016c8a:	e27fe0ef          	jal	ra,80015ab0 <mmu_map_range>
                  PB_READ | PB_WRITE | PB_EXECUTE);
    // PLIC
    debugf("Mapping PLIC\n");
    80016c8e:	00011517          	auipc	a0,0x11
    80016c92:	ad250513          	addi	a0,a0,-1326 # 80027760 <pow10.0+0x900>
    80016c96:	14c050ef          	jal	ra,8001bde2 <debugf>
    mmu_map_range(pt, 0x0C000000, 0x0C2FFFFF, 0x0C000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80016c9a:	4799                	li	a5,6
    80016c9c:	4705                	li	a4,1
    80016c9e:	0c0006b7          	lui	a3,0xc000
    80016ca2:	0c300637          	lui	a2,0xc300
    80016ca6:	167d                	addi	a2,a2,-1
    80016ca8:	0c0005b7          	lui	a1,0xc000
    80016cac:	fd043503          	ld	a0,-48(s0)
    80016cb0:	e01fe0ef          	jal	ra,80015ab0 <mmu_map_range>
    // PCIe ECAM
    debugf("Mapping PCIe ECAM\n");
    80016cb4:	00011517          	auipc	a0,0x11
    80016cb8:	abc50513          	addi	a0,a0,-1348 # 80027770 <pow10.0+0x910>
    80016cbc:	126050ef          	jal	ra,8001bde2 <debugf>
    mmu_map_range(pt, 0x30000000, 0x3FFFFFFF, 0x30000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80016cc0:	4799                	li	a5,6
    80016cc2:	4705                	li	a4,1
    80016cc4:	300006b7          	lui	a3,0x30000
    80016cc8:	40000637          	lui	a2,0x40000
    80016ccc:	167d                	addi	a2,a2,-1
    80016cce:	300005b7          	lui	a1,0x30000
    80016cd2:	fd043503          	ld	a0,-48(s0)
    80016cd6:	ddbfe0ef          	jal	ra,80015ab0 <mmu_map_range>
    // PCIe MMIO
    debugf("Mapping PCIe MMIO\n");
    80016cda:	00011517          	auipc	a0,0x11
    80016cde:	aae50513          	addi	a0,a0,-1362 # 80027788 <pow10.0+0x928>
    80016ce2:	100050ef          	jal	ra,8001bde2 <debugf>
    mmu_map_range(pt, 0x40000000, 0x5FFFFFFF, 0x40000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80016ce6:	4799                	li	a5,6
    80016ce8:	4705                	li	a4,1
    80016cea:	400006b7          	lui	a3,0x40000
    80016cee:	60000637          	lui	a2,0x60000
    80016cf2:	167d                	addi	a2,a2,-1
    80016cf4:	400005b7          	lui	a1,0x40000
    80016cf8:	fd043503          	ld	a0,-48(s0)
    80016cfc:	db5fe0ef          	jal	ra,80015ab0 <mmu_map_range>
    //                    uint64_t start_virt, 
    //                    uint64_t end_virt, 
    //                    uint64_t start_phys)
    // debug_page_table(pt, MMU_LEVEL_1G);

    debugf("About to set SATP to %016lx\n", SATP_KERNEL);
    80016d00:	0000e797          	auipc	a5,0xe
    80016d04:	30878793          	addi	a5,a5,776 # 80025008 <kernel_mmu_table>
    80016d08:	639c                	ld	a5,0(a5)
    80016d0a:	00c7d713          	srli	a4,a5,0xc
    80016d0e:	57fd                	li	a5,-1
    80016d10:	83d1                	srli	a5,a5,0x14
    80016d12:	8f7d                	and	a4,a4,a5
    80016d14:	8ffff7b7          	lui	a5,0x8ffff
    80016d18:	1782                	slli	a5,a5,0x20
    80016d1a:	8fd9                	or	a5,a5,a4
    80016d1c:	85be                	mv	a1,a5
    80016d1e:	00011517          	auipc	a0,0x11
    80016d22:	a8250513          	addi	a0,a0,-1406 # 800277a0 <pow10.0+0x940>
    80016d26:	0bc050ef          	jal	ra,8001bde2 <debugf>
    // TODO: turn on the MMU when you've written the src/mmu.c functions
    CSR_WRITE("satp", SATP_KERNEL); 
    80016d2a:	0000e797          	auipc	a5,0xe
    80016d2e:	2de78793          	addi	a5,a5,734 # 80025008 <kernel_mmu_table>
    80016d32:	639c                	ld	a5,0(a5)
    80016d34:	00c7d713          	srli	a4,a5,0xc
    80016d38:	57fd                	li	a5,-1
    80016d3a:	83d1                	srli	a5,a5,0x14
    80016d3c:	8f7d                	and	a4,a4,a5
    80016d3e:	8ffff7b7          	lui	a5,0x8ffff
    80016d42:	1782                	slli	a5,a5,0x20
    80016d44:	8fd9                	or	a5,a5,a4
    80016d46:	18079073          	csrw	satp,a5
    SFENCE_ALL();
    80016d4a:	12000073          	sfence.vma
    debugf("MMU enabled\n");
    80016d4e:	00011517          	auipc	a0,0x11
    80016d52:	a7250513          	addi	a0,a0,-1422 # 800277c0 <pow10.0+0x960>
    80016d56:	08c050ef          	jal	ra,8001bde2 <debugf>
    void *kcalloc(uint64_t elem, uint64_t size);
    void kfree(void *ptr);
    void util_connect_galloc(void *(*malloc)(uint64_t size),
                             void *(*calloc)(uint64_t elem, uint64_t size),
                             void (*free)(void *ptr));
    util_connect_galloc(kmalloc, kcalloc, kfree);
    80016d5a:	fffff617          	auipc	a2,0xfffff
    80016d5e:	82060613          	addi	a2,a2,-2016 # 8001557a <kfree>
    80016d62:	ffffe597          	auipc	a1,0xffffe
    80016d66:	7f058593          	addi	a1,a1,2032 # 80015552 <kcalloc>
    80016d6a:	ffffe517          	auipc	a0,0xffffe
    80016d6e:	7c850513          	addi	a0,a0,1992 # 80015532 <kmalloc>
    80016d72:	626090ef          	jal	ra,80020398 <util_connect_galloc>
    heap_init();
    80016d76:	829fe0ef          	jal	ra,8001559e <heap_init>
    debugf("heap_init() done\n");
    80016d7a:	00011517          	auipc	a0,0x11
    80016d7e:	a5650513          	addi	a0,a0,-1450 # 800277d0 <pow10.0+0x970>
    80016d82:	060050ef          	jal	ra,8001bde2 <debugf>

    // Call kmalloc() here to ensure it works.
    void *ptr = kmalloc(1024);
    80016d86:	40000513          	li	a0,1024
    80016d8a:	fa8fe0ef          	jal	ra,80015532 <kmalloc>
    80016d8e:	fca43423          	sd	a0,-56(s0)
    strcpy(ptr, "Hello, world!");
    80016d92:	00011597          	auipc	a1,0x11
    80016d96:	a5658593          	addi	a1,a1,-1450 # 800277e8 <pow10.0+0x988>
    80016d9a:	fc843503          	ld	a0,-56(s0)
    80016d9e:	46b0b0ef          	jal	ra,80022a08 <strcpy>
    debugf("kmalloc(1024) = %p\n", ptr);
    80016da2:	fc843583          	ld	a1,-56(s0)
    80016da6:	00011517          	auipc	a0,0x11
    80016daa:	a5250513          	addi	a0,a0,-1454 # 800277f8 <pow10.0+0x998>
    80016dae:	034050ef          	jal	ra,8001bde2 <debugf>
    debugf("kmalloc(1024) = %s\n", ptr);
    80016db2:	fc843583          	ld	a1,-56(s0)
    80016db6:	00011517          	auipc	a0,0x11
    80016dba:	a5a50513          	addi	a0,a0,-1446 # 80027810 <pow10.0+0x9b0>
    80016dbe:	024050ef          	jal	ra,8001bde2 <debugf>
    kfree(ptr);
    80016dc2:	fc843503          	ld	a0,-56(s0)
    80016dc6:	fb4fe0ef          	jal	ra,8001557a <kfree>
#endif
#ifdef USE_PCI
    pci_init();
    80016dca:	e35fd0ef          	jal	ra,80014bfe <pci_init>
#endif
#ifdef USE_VIRTIO
    uint64_t stvec = trampoline_trap_start;
    80016dce:	00013797          	auipc	a5,0x13
    80016dd2:	a9378793          	addi	a5,a5,-1389 # 80029861 <trampoline_trap_start>
    80016dd6:	639c                	ld	a5,0(a5)
    80016dd8:	fcf43023          	sd	a5,-64(s0)
    // # 552  - stvec
    // # 560  - trap_satp
    // # 568  - trap_stack
    // trampoline_thread_start();

    stvec &= ~0x3;
    80016ddc:	fc043783          	ld	a5,-64(s0)
    80016de0:	9bf1                	andi	a5,a5,-4
    80016de2:	fcf43023          	sd	a5,-64(s0)
    CSR_WRITE("stvec", trampoline_trap_start);
    80016de6:	00013797          	auipc	a5,0x13
    80016dea:	a7b78793          	addi	a5,a5,-1413 # 80029861 <trampoline_trap_start>
    80016dee:	639c                	ld	a5,0(a5)
    80016df0:	10579073          	csrw	stvec,a5
    debugf("STVEC: 0x%p, 0x%p\n", stvec, trampoline_trap_start);
    80016df4:	00013797          	auipc	a5,0x13
    80016df8:	a6d78793          	addi	a5,a5,-1427 # 80029861 <trampoline_trap_start>
    80016dfc:	639c                	ld	a5,0(a5)
    80016dfe:	863e                	mv	a2,a5
    80016e00:	fc043583          	ld	a1,-64(s0)
    80016e04:	00011517          	auipc	a0,0x11
    80016e08:	a2450513          	addi	a0,a0,-1500 # 80027828 <pow10.0+0x9c8>
    80016e0c:	7d7040ef          	jal	ra,8001bde2 <debugf>

    Trapframe *sscratch = kzalloc(sizeof(Trapframe) * 4);
    80016e10:	6785                	lui	a5,0x1
    80016e12:	90078593          	addi	a1,a5,-1792 # 900 <i+0x8e0>
    80016e16:	4505                	li	a0,1
    80016e18:	f3afe0ef          	jal	ra,80015552 <kcalloc>
    80016e1c:	faa43c23          	sd	a0,-72(s0)
    
    CSR_READ(sscratch->sepc, "sepc");
    80016e20:	14102773          	csrr	a4,sepc
    80016e24:	fb843783          	ld	a5,-72(s0)
    80016e28:	20e7b023          	sd	a4,512(a5)
    CSR_READ(sscratch->sstatus, "sstatus");
    80016e2c:	10002773          	csrr	a4,sstatus
    80016e30:	fb843783          	ld	a5,-72(s0)
    80016e34:	20e7b423          	sd	a4,520(a5)
    CSR_READ(sscratch->sie, "sie");
    80016e38:	10402773          	csrr	a4,sie
    80016e3c:	fb843783          	ld	a5,-72(s0)
    80016e40:	20e7b823          	sd	a4,528(a5)
    CSR_READ(sscratch->satp, "satp");
    80016e44:	18002773          	csrr	a4,satp
    80016e48:	fb843783          	ld	a5,-72(s0)
    80016e4c:	20e7bc23          	sd	a4,536(a5)
    CSR_READ(sscratch->stvec, "stvec");
    80016e50:	10502773          	csrr	a4,stvec
    80016e54:	fb843783          	ld	a5,-72(s0)
    80016e58:	22e7b423          	sd	a4,552(a5)
    CSR_READ(sscratch->trap_satp, "satp");
    80016e5c:	18002773          	csrr	a4,satp
    80016e60:	fb843783          	ld	a5,-72(s0)
    80016e64:	22e7b823          	sd	a4,560(a5)
    sscratch->trap_stack = (uint64_t)kmalloc(0x10000);
    80016e68:	6541                	lui	a0,0x10
    80016e6a:	ec8fe0ef          	jal	ra,80015532 <kmalloc>
    80016e6e:	87aa                	mv	a5,a0
    80016e70:	873e                	mv	a4,a5
    80016e72:	fb843783          	ld	a5,-72(s0)
    80016e76:	22e7bc23          	sd	a4,568(a5)
    CSR_WRITE("sscratch", sscratch);
    80016e7a:	fb843783          	ld	a5,-72(s0)
    80016e7e:	14079073          	csrw	sscratch,a5

    virtio_init();
    80016e82:	094060ef          	jal	ra,8001cf16 <virtio_init>
    uint8_t buffer[16] = {0};
    80016e86:	fa043423          	sd	zero,-88(s0)
    80016e8a:	fa043823          	sd	zero,-80(s0)
    debugf("RNG State Before:");
    80016e8e:	00011517          	auipc	a0,0x11
    80016e92:	9b250513          	addi	a0,a0,-1614 # 80027840 <pow10.0+0x9e0>
    80016e96:	74d040ef          	jal	ra,8001bde2 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80016e9a:	fe043423          	sd	zero,-24(s0)
    80016e9e:	a02d                	j	80016ec8 <init_systems+0x2b8>
        debugf(" %d ", buffer[i]);
    80016ea0:	fe843783          	ld	a5,-24(s0)
    80016ea4:	ff040713          	addi	a4,s0,-16
    80016ea8:	97ba                	add	a5,a5,a4
    80016eaa:	fb87c783          	lbu	a5,-72(a5)
    80016eae:	2781                	sext.w	a5,a5
    80016eb0:	85be                	mv	a1,a5
    80016eb2:	00011517          	auipc	a0,0x11
    80016eb6:	9a650513          	addi	a0,a0,-1626 # 80027858 <pow10.0+0x9f8>
    80016eba:	729040ef          	jal	ra,8001bde2 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80016ebe:	fe843783          	ld	a5,-24(s0)
    80016ec2:	0785                	addi	a5,a5,1
    80016ec4:	fef43423          	sd	a5,-24(s0)
    80016ec8:	fe843703          	ld	a4,-24(s0)
    80016ecc:	47bd                	li	a5,15
    80016ece:	fce7f9e3          	bgeu	a5,a4,80016ea0 <init_systems+0x290>
    }
    debugf("\n");
    80016ed2:	00011517          	auipc	a0,0x11
    80016ed6:	98e50513          	addi	a0,a0,-1650 # 80027860 <pow10.0+0xa00>
    80016eda:	709040ef          	jal	ra,8001bde2 <debugf>

    debugf("RNG init done; about to fill\n");
    80016ede:	00011517          	auipc	a0,0x11
    80016ee2:	98a50513          	addi	a0,a0,-1654 # 80027868 <pow10.0+0xa08>
    80016ee6:	6fd040ef          	jal	ra,8001bde2 <debugf>
    rng_fill(buffer, 16);
    80016eea:	fa840793          	addi	a5,s0,-88
    80016eee:	45c1                	li	a1,16
    80016ef0:	853e                	mv	a0,a5
    80016ef2:	ffdfc0ef          	jal	ra,80013eee <rng_fill>
    debugf("RNG State After:");
    80016ef6:	00011517          	auipc	a0,0x11
    80016efa:	99250513          	addi	a0,a0,-1646 # 80027888 <pow10.0+0xa28>
    80016efe:	6e5040ef          	jal	ra,8001bde2 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80016f02:	fe043023          	sd	zero,-32(s0)
    80016f06:	a02d                	j	80016f30 <init_systems+0x320>
        debugf(" %d ", buffer[i]);
    80016f08:	fe043783          	ld	a5,-32(s0)
    80016f0c:	ff040713          	addi	a4,s0,-16
    80016f10:	97ba                	add	a5,a5,a4
    80016f12:	fb87c783          	lbu	a5,-72(a5)
    80016f16:	2781                	sext.w	a5,a5
    80016f18:	85be                	mv	a1,a5
    80016f1a:	00011517          	auipc	a0,0x11
    80016f1e:	93e50513          	addi	a0,a0,-1730 # 80027858 <pow10.0+0x9f8>
    80016f22:	6c1040ef          	jal	ra,8001bde2 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80016f26:	fe043783          	ld	a5,-32(s0)
    80016f2a:	0785                	addi	a5,a5,1
    80016f2c:	fef43023          	sd	a5,-32(s0)
    80016f30:	fe043703          	ld	a4,-32(s0)
    80016f34:	47bd                	li	a5,15
    80016f36:	fce7f9e3          	bgeu	a5,a4,80016f08 <init_systems+0x2f8>
    }
    
    rng_fill(buffer, 16);
    80016f3a:	fa840793          	addi	a5,s0,-88
    80016f3e:	45c1                	li	a1,16
    80016f40:	853e                	mv	a0,a5
    80016f42:	fadfc0ef          	jal	ra,80013eee <rng_fill>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80016f46:	fc043c23          	sd	zero,-40(s0)
    80016f4a:	a02d                	j	80016f74 <init_systems+0x364>
        debugf(" %d ", buffer[i]);
    80016f4c:	fd843783          	ld	a5,-40(s0)
    80016f50:	ff040713          	addi	a4,s0,-16
    80016f54:	97ba                	add	a5,a5,a4
    80016f56:	fb87c783          	lbu	a5,-72(a5)
    80016f5a:	2781                	sext.w	a5,a5
    80016f5c:	85be                	mv	a1,a5
    80016f5e:	00011517          	auipc	a0,0x11
    80016f62:	8fa50513          	addi	a0,a0,-1798 # 80027858 <pow10.0+0x9f8>
    80016f66:	67d040ef          	jal	ra,8001bde2 <debugf>
    for (uint64_t i=0; i<sizeof(buffer)/sizeof(buffer[0]); i++) {
    80016f6a:	fd843783          	ld	a5,-40(s0)
    80016f6e:	0785                	addi	a5,a5,1
    80016f70:	fcf43c23          	sd	a5,-40(s0)
    80016f74:	fd843703          	ld	a4,-40(s0)
    80016f78:	47bd                	li	a5,15
    80016f7a:	fce7f9e3          	bgeu	a5,a4,80016f4c <init_systems+0x33c>
            buf[i], buf[i+1], buf[i+2], buf[i+3],
            buf[i+4], buf[i+5], buf[i+6], buf[i+7]);
    }
    */
    // TEST GPU
    debugf("GPU init %s\n", gpu_test() ? "successful" : "failed");
    80016f7e:	8c4ff0ef          	jal	ra,80016042 <gpu_test>
    80016f82:	87aa                	mv	a5,a0
    80016f84:	c791                	beqz	a5,80016f90 <init_systems+0x380>
    80016f86:	00011797          	auipc	a5,0x11
    80016f8a:	91a78793          	addi	a5,a5,-1766 # 800278a0 <pow10.0+0xa40>
    80016f8e:	a029                	j	80016f98 <init_systems+0x388>
    80016f90:	00011797          	auipc	a5,0x11
    80016f94:	92078793          	addi	a5,a5,-1760 # 800278b0 <pow10.0+0xa50>
    80016f98:	85be                	mv	a1,a5
    80016f9a:	00011517          	auipc	a0,0x11
    80016f9e:	91e50513          	addi	a0,a0,-1762 # 800278b8 <pow10.0+0xa58>
    80016fa2:	641040ef          	jal	ra,8001bde2 <debugf>

    // Process init
    process_map_init();
    80016fa6:	343040ef          	jal	ra,8001bae8 <process_map_init>
    pid_harts_map_init();
    80016faa:	3d1040ef          	jal	ra,8001bb7a <pid_harts_map_init>
    sched_init();
    80016fae:	e23fe0ef          	jal	ra,80015dd0 <sched_init>
#endif
}
    80016fb2:	0001                	nop
    80016fb4:	60e6                	ld	ra,88(sp)
    80016fb6:	6446                	ld	s0,80(sp)
    80016fb8:	6125                	addi	sp,sp,96
    80016fba:	8082                	ret

0000000080016fbc <main>:
static const char *hart_status_values[] = {"NOT PRESENT", "STOPPED", "STARTING", "RUNNING"};
#ifdef RUN_INTERNAL_CONSOLE
static void console(void);
#endif
void main(unsigned int hart)
{
    80016fbc:	7119                	addi	sp,sp,-128
    80016fbe:	fc86                	sd	ra,120(sp)
    80016fc0:	f8a2                	sd	s0,112(sp)
    80016fc2:	0100                	addi	s0,sp,128
    80016fc4:	87aa                	mv	a5,a0
    80016fc6:	f8f42623          	sw	a5,-116(s0)
    // Initialize the page allocator
    // Allocate and zero the kernel's page table.

    // Kind of neat to see our memory mappings to ensure they make sense.
    logf(LOG_INFO, "[[ MEMORY MAPPINGS ]]\n");
    80016fca:	00011597          	auipc	a1,0x11
    80016fce:	92e58593          	addi	a1,a1,-1746 # 800278f8 <pow10.0+0xa98>
    80016fd2:	4511                	li	a0,4
    80016fd4:	5b1040ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  [TEXT]  : 0x%08lx -> 0x%08lx\n", sym_start(text), sym_end(text));
    80016fd8:	ffff9797          	auipc	a5,0xffff9
    80016fdc:	02878793          	addi	a5,a5,40 # 80010000 <_memory_start>
    80016fe0:	0000c717          	auipc	a4,0xc
    80016fe4:	78c70713          	addi	a4,a4,1932 # 8002376c <_text_end>
    80016fe8:	86ba                	mv	a3,a4
    80016fea:	863e                	mv	a2,a5
    80016fec:	00011597          	auipc	a1,0x11
    80016ff0:	92458593          	addi	a1,a1,-1756 # 80027910 <pow10.0+0xab0>
    80016ff4:	4511                	li	a0,4
    80016ff6:	58f040ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  [BSS]   : 0x%08lx -> 0x%08lx\n", sym_start(bss), sym_end(bss));
    80016ffa:	0000e797          	auipc	a5,0xe
    80016ffe:	00678793          	addi	a5,a5,6 # 80025000 <sched_lock>
    80017002:	0000e717          	auipc	a4,0xe
    80017006:	5d670713          	addi	a4,a4,1494 # 800255d8 <_bss_end>
    8001700a:	86ba                	mv	a3,a4
    8001700c:	863e                	mv	a2,a5
    8001700e:	00011597          	auipc	a1,0x11
    80017012:	92258593          	addi	a1,a1,-1758 # 80027930 <pow10.0+0xad0>
    80017016:	4511                	li	a0,4
    80017018:	56d040ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  [RODATA]: 0x%08lx -> 0x%08lx\n", sym_start(rodata), sym_end(rodata));
    8001701c:	0000f797          	auipc	a5,0xf
    80017020:	fe478793          	addi	a5,a5,-28 # 80026000 <_rodata_start>
    80017024:	00013717          	auipc	a4,0x13
    80017028:	86470713          	addi	a4,a4,-1948 # 80029888 <NUM_SYSCALLS>
    8001702c:	86ba                	mv	a3,a4
    8001702e:	863e                	mv	a2,a5
    80017030:	00011597          	auipc	a1,0x11
    80017034:	92058593          	addi	a1,a1,-1760 # 80027950 <pow10.0+0xaf0>
    80017038:	4511                	li	a0,4
    8001703a:	54b040ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  [DATA]  : 0x%08lx -> 0x%08lx\n", sym_start(data), sym_end(data));
    8001703e:	00013797          	auipc	a5,0x13
    80017042:	fc278793          	addi	a5,a5,-62 # 8002a000 <subordinate>
    80017046:	00013717          	auipc	a4,0x13
    8001704a:	fea70713          	addi	a4,a4,-22 # 8002a030 <_data_end>
    8001704e:	86ba                	mv	a3,a4
    80017050:	863e                	mv	a2,a5
    80017052:	00011597          	auipc	a1,0x11
    80017056:	91e58593          	addi	a1,a1,-1762 # 80027970 <pow10.0+0xb10>
    8001705a:	4511                	li	a0,4
    8001705c:	529040ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  [STACK] : 0x%08lx -> 0x%08lx\n", sym_start(stack), sym_end(stack));
    80017060:	00014797          	auipc	a5,0x14
    80017064:	fa078793          	addi	a5,a5,-96 # 8002b000 <_stack_start>
    80017068:	0001c717          	auipc	a4,0x1c
    8001706c:	f9870713          	addi	a4,a4,-104 # 80033000 <_heap_start>
    80017070:	86ba                	mv	a3,a4
    80017072:	863e                	mv	a2,a5
    80017074:	00011597          	auipc	a1,0x11
    80017078:	91c58593          	addi	a1,a1,-1764 # 80027990 <pow10.0+0xb30>
    8001707c:	4511                	li	a0,4
    8001707e:	507040ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  [HEAP]  : 0x%08lx -> 0x%08lx\n", sym_start(heap), sym_end(heap));
    80017082:	0001c797          	auipc	a5,0x1c
    80017086:	f7e78793          	addi	a5,a5,-130 # 80033000 <_heap_start>
    8001708a:	07ff9717          	auipc	a4,0x7ff9
    8001708e:	f7670713          	addi	a4,a4,-138 # 88010000 <_heap_end>
    80017092:	86ba                	mv	a3,a4
    80017094:	863e                	mv	a2,a5
    80017096:	00011597          	auipc	a1,0x11
    8001709a:	91a58593          	addi	a1,a1,-1766 # 800279b0 <pow10.0+0xb50>
    8001709e:	4511                	li	a0,4
    800170a0:	4e5040ef          	jal	ra,8001bd84 <logf>

    logf(LOG_INFO, "[[ HART MAPPINGS ]]\n");
    800170a4:	00011597          	auipc	a1,0x11
    800170a8:	92c58593          	addi	a1,a1,-1748 # 800279d0 <pow10.0+0xb70>
    800170ac:	4511                	li	a0,4
    800170ae:	4d7040ef          	jal	ra,8001bd84 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800170b2:	fe042623          	sw	zero,-20(s0)
    800170b6:	a8bd                	j	80017134 <main+0x178>
        if (i == hart) {
    800170b8:	fec42703          	lw	a4,-20(s0)
    800170bc:	f8c42783          	lw	a5,-116(s0)
    800170c0:	2701                	sext.w	a4,a4
    800170c2:	2781                	sext.w	a5,a5
    800170c4:	02f71b63          	bne	a4,a5,800170fa <main+0x13e>
            logf(LOG_INFO, "  [HART#%d]: %s (this HART).\n", i, hart_status_values[sbi_hart_get_status(i)]);
    800170c8:	fec42783          	lw	a5,-20(s0)
    800170cc:	853e                	mv	a0,a5
    800170ce:	773040ef          	jal	ra,8001c040 <sbi_hart_get_status>
    800170d2:	87aa                	mv	a5,a0
    800170d4:	00013717          	auipc	a4,0x13
    800170d8:	f3c70713          	addi	a4,a4,-196 # 8002a010 <hart_status_values>
    800170dc:	078e                	slli	a5,a5,0x3
    800170de:	97ba                	add	a5,a5,a4
    800170e0:	6398                	ld	a4,0(a5)
    800170e2:	fec42783          	lw	a5,-20(s0)
    800170e6:	86ba                	mv	a3,a4
    800170e8:	863e                	mv	a2,a5
    800170ea:	00011597          	auipc	a1,0x11
    800170ee:	8fe58593          	addi	a1,a1,-1794 # 800279e8 <pow10.0+0xb88>
    800170f2:	4511                	li	a0,4
    800170f4:	491040ef          	jal	ra,8001bd84 <logf>
    800170f8:	a80d                	j	8001712a <main+0x16e>
        }
        else {
            logf(LOG_INFO, "  [HART#%d]: %s.\n", i, hart_status_values[sbi_hart_get_status(i)]);
    800170fa:	fec42783          	lw	a5,-20(s0)
    800170fe:	853e                	mv	a0,a5
    80017100:	741040ef          	jal	ra,8001c040 <sbi_hart_get_status>
    80017104:	87aa                	mv	a5,a0
    80017106:	00013717          	auipc	a4,0x13
    8001710a:	f0a70713          	addi	a4,a4,-246 # 8002a010 <hart_status_values>
    8001710e:	078e                	slli	a5,a5,0x3
    80017110:	97ba                	add	a5,a5,a4
    80017112:	6398                	ld	a4,0(a5)
    80017114:	fec42783          	lw	a5,-20(s0)
    80017118:	86ba                	mv	a3,a4
    8001711a:	863e                	mv	a2,a5
    8001711c:	00011597          	auipc	a1,0x11
    80017120:	8ec58593          	addi	a1,a1,-1812 # 80027a08 <pow10.0+0xba8>
    80017124:	4511                	li	a0,4
    80017126:	45f040ef          	jal	ra,8001bd84 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    8001712a:	fec42783          	lw	a5,-20(s0)
    8001712e:	2785                	addiw	a5,a5,1
    80017130:	fef42623          	sw	a5,-20(s0)
    80017134:	fec42783          	lw	a5,-20(s0)
    80017138:	0007871b          	sext.w	a4,a5
    8001713c:	478d                	li	a5,3
    8001713e:	f6e7fde3          	bgeu	a5,a4,800170b8 <main+0xfc>
        }
    }

    // Initialize all submodules here, including PCI, VirtIO, Heap, etc.
    // Many will require the MMU, so write those functions first.
    init_systems();
    80017142:	acfff0ef          	jal	ra,80016c10 <init_systems>

    // Now that all submodules are initialized, you need to schedule the init process
    // and the idle processes for each HART.
    logf(LOG_INFO, "Congratulations! You made it to the OS! Going back to sleep.\n");
    80017146:	00011597          	auipc	a1,0x11
    8001714a:	8da58593          	addi	a1,a1,-1830 # 80027a20 <pow10.0+0xbc0>
    8001714e:	4511                	li	a0,4
    80017150:	435040ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, 
    80017154:	00011597          	auipc	a1,0x11
    80017158:	90c58593          	addi	a1,a1,-1780 # 80027a60 <pow10.0+0xc00>
    8001715c:	4511                	li	a0,4
    8001715e:	427040ef          	jal	ra,8001bd84 <logf>
        "The logf function in the OS uses sbi_putchar(), so this means ECALLs from S-mode are "
        "working!\n");
    logf(LOG_INFO, 
    80017162:	00011597          	auipc	a1,0x11
    80017166:	95e58593          	addi	a1,a1,-1698 # 80027ac0 <pow10.0+0xc60>
    8001716a:	4511                	li	a0,4
    8001716c:	419040ef          	jal	ra,8001bd84 <logf>
    // Below is just a little shell that demonstrates the sbi_getchar and
    // how the console works.

    // This is defined above main()
#ifdef RUN_INTERNAL_CONSOLE
    VirtioDevice *block_device = virtio_get_block_device(0);
    80017170:	4501                	li	a0,0
    80017172:	389050ef          	jal	ra,8001ccfa <virtio_get_block_device>
    80017176:	fea43023          	sd	a0,-32(s0)
    // minix3_init(block_device, "/");
    vfs_init();
    8001717a:	0ba080ef          	jal	ra,8001f234 <vfs_init>

    File *file = vfs_open("/dev/sda/root.txt", 0, O_RDONLY, VFS_TYPE_FILE);
    8001717e:	4685                	li	a3,1
    80017180:	4601                	li	a2,0
    80017182:	4581                	li	a1,0
    80017184:	00011517          	auipc	a0,0x11
    80017188:	99c50513          	addi	a0,a0,-1636 # 80027b20 <pow10.0+0xcc0>
    8001718c:	5f0080ef          	jal	ra,8001f77c <vfs_open>
    80017190:	fca43c23          	sd	a0,-40(s0)
    uint8_t *buffer = kzalloc(2048);
    80017194:	6785                	lui	a5,0x1
    80017196:	80078593          	addi	a1,a5,-2048 # 800 <i+0x7e0>
    8001719a:	4505                	li	a0,1
    8001719c:	bb6fe0ef          	jal	ra,80015552 <kcalloc>
    800171a0:	fca43823          	sd	a0,-48(s0)
    vfs_read(file, buffer, 1024);
    800171a4:	40000613          	li	a2,1024
    800171a8:	fd043583          	ld	a1,-48(s0)
    800171ac:	fd843503          	ld	a0,-40(s0)
    800171b0:	2f5070ef          	jal	ra,8001eca4 <vfs_read>
    logf(LOG_INFO, "Read from file /dev/sda/root.txt: %1024s\n", buffer);
    800171b4:	fd043603          	ld	a2,-48(s0)
    800171b8:	00011597          	auipc	a1,0x11
    800171bc:	98058593          	addi	a1,a1,-1664 # 80027b38 <pow10.0+0xcd8>
    800171c0:	4511                	li	a0,4
    800171c2:	3c3040ef          	jal	ra,8001bd84 <logf>
    // vfs_print_mounted_devices();


    File *file2 = vfs_open("/home/cosc562/subdir1/subdir2/subdir3/subdir4/subdir5/book1.txt", 0, O_RDONLY, VFS_TYPE_FILE);
    800171c6:	4685                	li	a3,1
    800171c8:	4601                	li	a2,0
    800171ca:	4581                	li	a1,0
    800171cc:	00011517          	auipc	a0,0x11
    800171d0:	99c50513          	addi	a0,a0,-1636 # 80027b68 <pow10.0+0xd08>
    800171d4:	5a8080ef          	jal	ra,8001f77c <vfs_open>
    800171d8:	fca43423          	sd	a0,-56(s0)
    vfs_read(file2, buffer, 1024);
    800171dc:	40000613          	li	a2,1024
    800171e0:	fd043583          	ld	a1,-48(s0)
    800171e4:	fc843503          	ld	a0,-56(s0)
    800171e8:	2bd070ef          	jal	ra,8001eca4 <vfs_read>
    logf(LOG_INFO, "Read 1024 bytes from file /home/cosc562/subdir1/subdir2/subdir3/subdir4/subdir5/book1.txt: %1024s\n", buffer);
    800171ec:	fd043603          	ld	a2,-48(s0)
    800171f0:	00011597          	auipc	a1,0x11
    800171f4:	9b858593          	addi	a1,a1,-1608 # 80027ba8 <pow10.0+0xd48>
    800171f8:	4511                	li	a0,4
    800171fa:	38b040ef          	jal	ra,8001bd84 <logf>
    vfs_read(file2, buffer, 1024);
    800171fe:	40000613          	li	a2,1024
    80017202:	fd043583          	ld	a1,-48(s0)
    80017206:	fc843503          	ld	a0,-56(s0)
    8001720a:	29b070ef          	jal	ra,8001eca4 <vfs_read>
    logf(LOG_INFO, "Read another 1024 bytes from file /home/cosc562/subdir1/subdir2/subdir3/subdir4/subdir5/book1.txt: %1024s\n", buffer);
    8001720e:	fd043603          	ld	a2,-48(s0)
    80017212:	00011597          	auipc	a1,0x11
    80017216:	9fe58593          	addi	a1,a1,-1538 # 80027c10 <pow10.0+0xdb0>
    8001721a:	4511                	li	a0,4
    8001721c:	369040ef          	jal	ra,8001bd84 <logf>

    vfs_close(file);
    80017220:	fd843503          	ld	a0,-40(s0)
    80017224:	577080ef          	jal	ra,8001ff9a <vfs_close>
    vfs_close(file2);
    80017228:	fc843503          	ld	a0,-56(s0)
    8001722c:	56f080ef          	jal	ra,8001ff9a <vfs_close>

    // Read in /home/cosc562/console.elf
    File *elf_file = vfs_open("/home/cosc562/console.elf", 0, O_RDONLY, VFS_TYPE_FILE);
    80017230:	4685                	li	a3,1
    80017232:	4601                	li	a2,0
    80017234:	4581                	li	a1,0
    80017236:	00011517          	auipc	a0,0x11
    8001723a:	a4a50513          	addi	a0,a0,-1462 # 80027c80 <pow10.0+0xe20>
    8001723e:	53e080ef          	jal	ra,8001f77c <vfs_open>
    80017242:	fca43023          	sd	a0,-64(s0)
    Stat stat;
    vfs_stat(elf_file, &stat);
    80017246:	f9040793          	addi	a5,s0,-112
    8001724a:	85be                	mv	a1,a5
    8001724c:	fc043503          	ld	a0,-64(s0)
    80017250:	5d3080ef          	jal	ra,80020022 <vfs_stat>
    logf(LOG_INFO, "Console file size: %lu\n", stat.size);
    80017254:	fa042783          	lw	a5,-96(s0)
    80017258:	863e                	mv	a2,a5
    8001725a:	00011597          	auipc	a1,0x11
    8001725e:	a4658593          	addi	a1,a1,-1466 # 80027ca0 <pow10.0+0xe40>
    80017262:	4511                	li	a0,4
    80017264:	321040ef          	jal	ra,8001bd84 <logf>
    uint8_t *elfcon = kzalloc(elf_file->size);
    80017268:	fc043783          	ld	a5,-64(s0)
    8001726c:	73bc                	ld	a5,96(a5)
    8001726e:	85be                	mv	a1,a5
    80017270:	4505                	li	a0,1
    80017272:	ae0fe0ef          	jal	ra,80015552 <kcalloc>
    80017276:	faa43c23          	sd	a0,-72(s0)
    vfs_read(elf_file, elfcon, elf_file->size);
    8001727a:	fc043783          	ld	a5,-64(s0)
    8001727e:	73bc                	ld	a5,96(a5)
    80017280:	2781                	sext.w	a5,a5
    80017282:	863e                	mv	a2,a5
    80017284:	fb843583          	ld	a1,-72(s0)
    80017288:	fc043503          	ld	a0,-64(s0)
    8001728c:	219070ef          	jal	ra,8001eca4 <vfs_read>
    vfs_close(elf_file);
    80017290:	fc043503          	ld	a0,-64(s0)
    80017294:	507080ef          	jal	ra,8001ff9a <vfs_close>


    Process *p = process_new(PM_USER);
    80017298:	4501                	li	a0,0
    8001729a:	330040ef          	jal	ra,8001b5ca <process_new>
    8001729e:	faa43823          	sd	a0,-80(s0)
    elf_create_process(p, elfcon);
    800172a2:	fb843583          	ld	a1,-72(s0)
    800172a6:	fb043503          	ld	a0,-80(s0)
    800172aa:	842fa0ef          	jal	ra,800112ec <elf_create_process>
    process_debug(p);
    800172ae:	fb043503          	ld	a0,-80(s0)
    800172b2:	7f9030ef          	jal	ra,8001b2aa <process_debug>
    sched_add(p);
    800172b6:	fb043503          	ld	a0,-80(s0)
    800172ba:	b39fe0ef          	jal	ra,80015df2 <sched_add>
    process_run(p, 0);
    800172be:	4581                	li	a1,0
    800172c0:	fb043503          	ld	a0,-80(s0)
    800172c4:	79a040ef          	jal	ra,8001ba5e <process_run>

    console();
    800172c8:	004000ef          	jal	ra,800172cc <console>

00000000800172cc <console>:
#endif
}

#ifdef RUN_INTERNAL_CONSOLE
ATTR_NORET static void console(void)
{
    800172cc:	7179                	addi	sp,sp,-48
    800172ce:	f406                	sd	ra,40(sp)
    800172d0:	f022                	sd	s0,32(sp)
    800172d2:	1800                	addi	s0,sp,48
    const int BUFFER_SIZE = 56;
    800172d4:	03800313          	li	t1,56
    800172d8:	fe642423          	sw	t1,-24(s0)
    int at                = 0;
    800172dc:	fe042623          	sw	zero,-20(s0)
    char input[BUFFER_SIZE];
    800172e0:	fe842303          	lw	t1,-24(s0)
    800172e4:	137d                	addi	t1,t1,-1
    800172e6:	fe643023          	sd	t1,-32(s0)
    800172ea:	fe842303          	lw	t1,-24(s0)
    800172ee:	881a                	mv	a6,t1
    800172f0:	4881                	li	a7,0
    800172f2:	03d85313          	srli	t1,a6,0x3d
    800172f6:	00389693          	slli	a3,a7,0x3
    800172fa:	00d366b3          	or	a3,t1,a3
    800172fe:	00381613          	slli	a2,a6,0x3
    80017302:	fe842683          	lw	a3,-24(s0)
    80017306:	8536                	mv	a0,a3
    80017308:	4581                	li	a1,0
    8001730a:	03d55693          	srli	a3,a0,0x3d
    8001730e:	00359793          	slli	a5,a1,0x3
    80017312:	8fd5                	or	a5,a5,a3
    80017314:	00351713          	slli	a4,a0,0x3
    80017318:	fe842783          	lw	a5,-24(s0)
    8001731c:	07bd                	addi	a5,a5,15
    8001731e:	8391                	srli	a5,a5,0x4
    80017320:	0792                	slli	a5,a5,0x4
    80017322:	40f10133          	sub	sp,sp,a5
    80017326:	878a                	mv	a5,sp
    80017328:	00078793          	mv	a5,a5
    8001732c:	fcf43c23          	sd	a5,-40(s0)
    logf(LOG_TEXT, "> ");
    80017330:	00011597          	auipc	a1,0x11
    80017334:	98858593          	addi	a1,a1,-1656 # 80027cb8 <pow10.0+0xe58>
    80017338:	02000513          	li	a0,32
    8001733c:	249040ef          	jal	ra,8001bd84 <logf>
    do {
        char c;
        // Recall that sbi_getchar() will return -1, 0xff, 255
        // if the receiver is empty.
        if ((c = sbi_getchar()) != 0xff) {
    80017340:	4e1040ef          	jal	ra,8001c020 <sbi_getchar>
    80017344:	87aa                	mv	a5,a0
    80017346:	fcf40ba3          	sb	a5,-41(s0)
    8001734a:	fd744783          	lbu	a5,-41(s0)
    8001734e:	0ff7f713          	andi	a4,a5,255
    80017352:	0ff00793          	li	a5,255
    80017356:	22f70963          	beq	a4,a5,80017588 <console+0x2bc>
            if (c == '\r' || c == '\n') {
    8001735a:	fd744783          	lbu	a5,-41(s0)
    8001735e:	0ff7f713          	andi	a4,a5,255
    80017362:	47b5                	li	a5,13
    80017364:	00f70963          	beq	a4,a5,80017376 <console+0xaa>
    80017368:	fd744783          	lbu	a5,-41(s0)
    8001736c:	0ff7f713          	andi	a4,a5,255
    80017370:	47a9                	li	a5,10
    80017372:	0ef71163          	bne	a4,a5,80017454 <console+0x188>
                if (at > 0) {
    80017376:	fec42783          	lw	a5,-20(s0)
    8001737a:	2781                	sext.w	a5,a5
    8001737c:	0cf05363          	blez	a5,80017442 <console+0x176>
                    input[at] = '\0';
    80017380:	fd843703          	ld	a4,-40(s0)
    80017384:	fec42783          	lw	a5,-20(s0)
    80017388:	97ba                	add	a5,a5,a4
    8001738a:	00078023          	sb	zero,0(a5)
                    if (!strcmp(input, "quit")) {
    8001738e:	00011597          	auipc	a1,0x11
    80017392:	93258593          	addi	a1,a1,-1742 # 80027cc0 <pow10.0+0xe60>
    80017396:	fd843503          	ld	a0,-40(s0)
    8001739a:	3320b0ef          	jal	ra,800226cc <strcmp>
    8001739e:	87aa                	mv	a5,a0
    800173a0:	ef81                	bnez	a5,800173b8 <console+0xec>
                        logf(LOG_TEXT, "\nShutting down...\n\n");
    800173a2:	00011597          	auipc	a1,0x11
    800173a6:	92658593          	addi	a1,a1,-1754 # 80027cc8 <pow10.0+0xe68>
    800173aa:	02000513          	li	a0,32
    800173ae:	1d7040ef          	jal	ra,8001bd84 <logf>
                        sbi_poweroff();
    800173b2:	51f040ef          	jal	ra,8001c0d0 <sbi_poweroff>
    800173b6:	a061                	j	8001743e <console+0x172>
                    }
                    else if (!strcmp(input, "fatal")) {
    800173b8:	00011597          	auipc	a1,0x11
    800173bc:	92858593          	addi	a1,a1,-1752 # 80027ce0 <pow10.0+0xe80>
    800173c0:	fd843503          	ld	a0,-40(s0)
    800173c4:	3080b0ef          	jal	ra,800226cc <strcmp>
    800173c8:	87aa                	mv	a5,a0
    800173ca:	eb9d                	bnez	a5,80017400 <console+0x134>
                        logf(LOG_TEXT, "\n");
    800173cc:	00010597          	auipc	a1,0x10
    800173d0:	49458593          	addi	a1,a1,1172 # 80027860 <pow10.0+0xa00>
    800173d4:	02000513          	li	a0,32
    800173d8:	1ad040ef          	jal	ra,8001bd84 <logf>
                        fatalf("Testing fatal error @ %lu.\nHanging HART...\n", sbi_rtc_get_time());
    800173dc:	599040ef          	jal	ra,8001c174 <sbi_rtc_get_time>
    800173e0:	87aa                	mv	a5,a0
    800173e2:	85be                	mv	a1,a5
    800173e4:	00011517          	auipc	a0,0x11
    800173e8:	90450513          	addi	a0,a0,-1788 # 80027ce8 <pow10.0+0xe88>
    800173ec:	351040ef          	jal	ra,8001bf3c <fatalf>
                        logf(LOG_ERROR, "If I get here, fatal didn't work :'(.\n");
    800173f0:	00011597          	auipc	a1,0x11
    800173f4:	92858593          	addi	a1,a1,-1752 # 80027d18 <pow10.0+0xeb8>
    800173f8:	4505                	li	a0,1
    800173fa:	18b040ef          	jal	ra,8001bd84 <logf>
    800173fe:	a081                	j	8001743e <console+0x172>
                    }
                    else if (!strcmp(input, "heap")) {
    80017400:	00011597          	auipc	a1,0x11
    80017404:	94058593          	addi	a1,a1,-1728 # 80027d40 <pow10.0+0xee0>
    80017408:	fd843503          	ld	a0,-40(s0)
    8001740c:	2c00b0ef          	jal	ra,800226cc <strcmp>
    80017410:	87aa                	mv	a5,a0
    80017412:	ef81                	bnez	a5,8001742a <console+0x15e>
                        logf(LOG_TEXT, "\n");
    80017414:	00010597          	auipc	a1,0x10
    80017418:	44c58593          	addi	a1,a1,1100 # 80027860 <pow10.0+0xa00>
    8001741c:	02000513          	li	a0,32
    80017420:	165040ef          	jal	ra,8001bd84 <logf>
                        void heap_print_stats(void);
                        heap_print_stats();
    80017424:	8b0fe0ef          	jal	ra,800154d4 <heap_print_stats>
    80017428:	a819                	j	8001743e <console+0x172>
                    }
                    else {
                        logf(LOG_TEXT, "\nUnknown command '%s'\n", input);
    8001742a:	fd843603          	ld	a2,-40(s0)
    8001742e:	00011597          	auipc	a1,0x11
    80017432:	91a58593          	addi	a1,a1,-1766 # 80027d48 <pow10.0+0xee8>
    80017436:	02000513          	li	a0,32
    8001743a:	14b040ef          	jal	ra,8001bd84 <logf>
                    }
                    at = 0;
    8001743e:	fe042623          	sw	zero,-20(s0)
                }
                logf(LOG_TEXT, "\n> ");
    80017442:	00011597          	auipc	a1,0x11
    80017446:	91e58593          	addi	a1,a1,-1762 # 80027d60 <pow10.0+0xf00>
    8001744a:	02000513          	li	a0,32
    8001744e:	137040ef          	jal	ra,8001bd84 <logf>
    80017452:	aa3d                	j	80017590 <console+0x2c4>
            }
            else if (c == 127) {
    80017454:	fd744783          	lbu	a5,-41(s0)
    80017458:	0ff7f713          	andi	a4,a5,255
    8001745c:	07f00793          	li	a5,127
    80017460:	02f71563          	bne	a4,a5,8001748a <console+0x1be>
                // BACKSPACE
                if (at > 0) {
    80017464:	fec42783          	lw	a5,-20(s0)
    80017468:	2781                	sext.w	a5,a5
    8001746a:	ecf05be3          	blez	a5,80017340 <console+0x74>
                    logf(LOG_TEXT, "\b \b");
    8001746e:	00011597          	auipc	a1,0x11
    80017472:	8fa58593          	addi	a1,a1,-1798 # 80027d68 <pow10.0+0xf08>
    80017476:	02000513          	li	a0,32
    8001747a:	10b040ef          	jal	ra,8001bd84 <logf>
                    at -= 1;
    8001747e:	fec42783          	lw	a5,-20(s0)
    80017482:	37fd                	addiw	a5,a5,-1
    80017484:	fef42623          	sw	a5,-20(s0)
    80017488:	bd65                	j	80017340 <console+0x74>
                }
            }
            else if (c == 0x1B) {
    8001748a:	fd744783          	lbu	a5,-41(s0)
    8001748e:	0ff7f713          	andi	a4,a5,255
    80017492:	47ed                	li	a5,27
    80017494:	0af71663          	bne	a4,a5,80017540 <console+0x274>
                // Escape sequence
                char esc1 = sbi_getchar();
    80017498:	389040ef          	jal	ra,8001c020 <sbi_getchar>
    8001749c:	87aa                	mv	a5,a0
    8001749e:	fcf40b23          	sb	a5,-42(s0)
                char esc2 = sbi_getchar();
    800174a2:	37f040ef          	jal	ra,8001c020 <sbi_getchar>
    800174a6:	87aa                	mv	a5,a0
    800174a8:	fcf40aa3          	sb	a5,-43(s0)
                if (esc1 == 0x5B) {
    800174ac:	fd644783          	lbu	a5,-42(s0)
    800174b0:	0ff7f713          	andi	a4,a5,255
    800174b4:	05b00793          	li	a5,91
    800174b8:	0cf71b63          	bne	a4,a5,8001758e <console+0x2c2>
                    switch (esc2) {
    800174bc:	fd544783          	lbu	a5,-43(s0)
    800174c0:	2781                	sext.w	a5,a5
    800174c2:	86be                	mv	a3,a5
    800174c4:	04400713          	li	a4,68
    800174c8:	06e68463          	beq	a3,a4,80017530 <console+0x264>
    800174cc:	86be                	mv	a3,a5
    800174ce:	04400713          	li	a4,68
    800174d2:	e6d747e3          	blt	a4,a3,80017340 <console+0x74>
    800174d6:	86be                	mv	a3,a5
    800174d8:	04300713          	li	a4,67
    800174dc:	04e68263          	beq	a3,a4,80017520 <console+0x254>
    800174e0:	86be                	mv	a3,a5
    800174e2:	04300713          	li	a4,67
    800174e6:	e4d74de3          	blt	a4,a3,80017340 <console+0x74>
    800174ea:	86be                	mv	a3,a5
    800174ec:	04100713          	li	a4,65
    800174f0:	00e68863          	beq	a3,a4,80017500 <console+0x234>
    800174f4:	873e                	mv	a4,a5
    800174f6:	04200793          	li	a5,66
    800174fa:	00f70b63          	beq	a4,a5,80017510 <console+0x244>
    800174fe:	a849                	j	80017590 <console+0x2c4>
                        case 0x41:
                            logf(LOG_INFO, "UP\n");
    80017500:	00011597          	auipc	a1,0x11
    80017504:	87058593          	addi	a1,a1,-1936 # 80027d70 <pow10.0+0xf10>
    80017508:	4511                	li	a0,4
    8001750a:	07b040ef          	jal	ra,8001bd84 <logf>
                            break;
    8001750e:	a049                	j	80017590 <console+0x2c4>
                        case 0x42:
                            logf(LOG_INFO, "DOWN\n");
    80017510:	00011597          	auipc	a1,0x11
    80017514:	86858593          	addi	a1,a1,-1944 # 80027d78 <pow10.0+0xf18>
    80017518:	4511                	li	a0,4
    8001751a:	06b040ef          	jal	ra,8001bd84 <logf>
                            break;
    8001751e:	a88d                	j	80017590 <console+0x2c4>
                        case 0x43:
                            logf(LOG_INFO, "RIGHT\n");
    80017520:	00011597          	auipc	a1,0x11
    80017524:	86058593          	addi	a1,a1,-1952 # 80027d80 <pow10.0+0xf20>
    80017528:	4511                	li	a0,4
    8001752a:	05b040ef          	jal	ra,8001bd84 <logf>
                            break;
    8001752e:	a08d                	j	80017590 <console+0x2c4>
                        case 0x44:
                            logf(LOG_INFO, "LEFT\n");
    80017530:	00011597          	auipc	a1,0x11
    80017534:	85858593          	addi	a1,a1,-1960 # 80027d88 <pow10.0+0xf28>
    80017538:	4511                	li	a0,4
    8001753a:	04b040ef          	jal	ra,8001bd84 <logf>
                            break;
    8001753e:	a889                	j	80017590 <console+0x2c4>
                    }
                }
            }
            else {
                if (at < (BUFFER_SIZE - 1)) {
    80017540:	fe842783          	lw	a5,-24(s0)
    80017544:	37fd                	addiw	a5,a5,-1
    80017546:	0007871b          	sext.w	a4,a5
    8001754a:	fec42783          	lw	a5,-20(s0)
    8001754e:	2781                	sext.w	a5,a5
    80017550:	dee7d8e3          	bge	a5,a4,80017340 <console+0x74>
                    input[at++] = c;
    80017554:	fec42783          	lw	a5,-20(s0)
    80017558:	0017871b          	addiw	a4,a5,1
    8001755c:	fee42623          	sw	a4,-20(s0)
    80017560:	fd843703          	ld	a4,-40(s0)
    80017564:	97ba                	add	a5,a5,a4
    80017566:	fd744703          	lbu	a4,-41(s0)
    8001756a:	00e78023          	sb	a4,0(a5)
                    logf(LOG_TEXT, "%c", c);
    8001756e:	fd744783          	lbu	a5,-41(s0)
    80017572:	2781                	sext.w	a5,a5
    80017574:	863e                	mv	a2,a5
    80017576:	00011597          	auipc	a1,0x11
    8001757a:	81a58593          	addi	a1,a1,-2022 # 80027d90 <pow10.0+0xf30>
    8001757e:	02000513          	li	a0,32
    80017582:	003040ef          	jal	ra,8001bd84 <logf>
    80017586:	bb6d                	j	80017340 <console+0x74>
            }
        }
        else {
            // We can WFI here since interrupts are enabled
            // for the UART.
            WFI();
    80017588:	10500073          	wfi
    8001758c:	bb55                	j	80017340 <console+0x74>
                }
    8001758e:	0001                	nop
    do {
    80017590:	bb45                	j	80017340 <console+0x74>

0000000080017592 <debug_dir_entry>:
// static VirtioDevice *block_device;
static VirtioDevice *loaded_block_device;
static uint8_t *inode_bitmap;
static uint8_t *zone_bitmap;

void debug_dir_entry(DirEntry entry) {
    80017592:	1101                	addi	sp,sp,-32
    80017594:	ec22                	sd	s0,24(sp)
    80017596:	1000                	addi	s0,sp,32
    debugf("Entry: %u `", entry.inode);
    for (uint8_t i=0; i<60; i++) {
    80017598:	fe0407a3          	sb	zero,-17(s0)
    8001759c:	a031                	j	800175a8 <debug_dir_entry+0x16>
    8001759e:	fef44783          	lbu	a5,-17(s0)
    800175a2:	2785                	addiw	a5,a5,1
    800175a4:	fef407a3          	sb	a5,-17(s0)
    800175a8:	fef44783          	lbu	a5,-17(s0)
    800175ac:	0ff7f713          	andi	a4,a5,255
    800175b0:	03b00793          	li	a5,59
    800175b4:	fee7f5e3          	bgeu	a5,a4,8001759e <debug_dir_entry+0xc>
        #endif
    }
    #ifdef minix3_DEBUG
    infof("`\n");
    #endif
}
    800175b8:	0001                	nop
    800175ba:	0001                	nop
    800175bc:	6462                	ld	s0,24(sp)
    800175be:	6105                	addi	sp,sp,32
    800175c0:	8082                	ret

00000000800175c2 <minix3_get_inode_from_path>:

// Return the inode number from path.
// If get_parent is true, return the inode number of the parent.
// If given path /dir0/dir1file, return inode of /dir0/dir1/
uint32_t minix3_get_inode_from_path(VirtioDevice *block_device, const char *path, bool get_parent) {
    800175c2:	711d                	addi	sp,sp,-96
    800175c4:	ec86                	sd	ra,88(sp)
    800175c6:	e8a2                	sd	s0,80(sp)
    800175c8:	1080                	addi	s0,sp,96
    800175ca:	faa43c23          	sd	a0,-72(s0)
    800175ce:	fab43823          	sd	a1,-80(s0)
    800175d2:	87b2                	mv	a5,a2
    800175d4:	faf407a3          	sb	a5,-81(s0)
    // TODO: Add support for relative path.
    debugf("Getting inode from path %s\n", path);
    List *path_items = path_split(path);
    800175d8:	fb043503          	ld	a0,-80(s0)
    800175dc:	765090ef          	jal	ra,80021540 <path_split>
    800175e0:	fca43c23          	sd	a0,-40(s0)

    uint32_t parent = 1; // Root inode
    800175e4:	4785                	li	a5,1
    800175e6:	fef42623          	sw	a5,-20(s0)

    uint32_t i = 0, num_items = list_size(path_items);
    800175ea:	fe042423          	sw	zero,-24(s0)
    800175ee:	fd843503          	ld	a0,-40(s0)
    800175f2:	12c090ef          	jal	ra,8002071e <list_size>
    800175f6:	87aa                	mv	a5,a0
    800175f8:	fcf42a23          	sw	a5,-44(s0)
    ListElem *elem;
    list_for_each(path_items, elem) {
    800175fc:	fd843503          	ld	a0,-40(s0)
    80017600:	256090ef          	jal	ra,80020856 <list_elem_start_ascending>
    80017604:	fea43023          	sd	a0,-32(s0)
    80017608:	a861                	j	800176a0 <minix3_get_inode_from_path+0xde>

        char *name = (char *)list_elem_value(elem);
    8001760a:	fe043503          	ld	a0,-32(s0)
    8001760e:	2a8090ef          	jal	ra,800208b6 <list_elem_value>
    80017612:	87aa                	mv	a5,a0
    80017614:	fcf43423          	sd	a5,-56(s0)
        debugf("Getting inode from relative path %s, num_items = %u\n", name, num_items);
        if (strcmp(name, "/") == 0 || strcmp(name, "") == 0) {
    80017618:	00010597          	auipc	a1,0x10
    8001761c:	78058593          	addi	a1,a1,1920 # 80027d98 <pow10.0+0xf38>
    80017620:	fc843503          	ld	a0,-56(s0)
    80017624:	0a80b0ef          	jal	ra,800226cc <strcmp>
    80017628:	87aa                	mv	a5,a0
    8001762a:	cb99                	beqz	a5,80017640 <minix3_get_inode_from_path+0x7e>
    8001762c:	00010597          	auipc	a1,0x10
    80017630:	77458593          	addi	a1,a1,1908 # 80027da0 <pow10.0+0xf40>
    80017634:	fc843503          	ld	a0,-56(s0)
    80017638:	0940b0ef          	jal	ra,800226cc <strcmp>
    8001763c:	87aa                	mv	a5,a0
    8001763e:	e781                	bnez	a5,80017646 <minix3_get_inode_from_path+0x84>
            return parent;
    80017640:	fec42783          	lw	a5,-20(s0)
    80017644:	a885                	j	800176b4 <minix3_get_inode_from_path+0xf2>
        }
        debugf("i = %u, num_items = %u\n", i, num_items);
        if (get_parent && i == num_items - 1) {
    80017646:	faf44783          	lbu	a5,-81(s0)
    8001764a:	0ff7f793          	andi	a5,a5,255
    8001764e:	cf91                	beqz	a5,8001766a <minix3_get_inode_from_path+0xa8>
    80017650:	fd442783          	lw	a5,-44(s0)
    80017654:	37fd                	addiw	a5,a5,-1
    80017656:	0007871b          	sext.w	a4,a5
    8001765a:	fe842783          	lw	a5,-24(s0)
    8001765e:	2781                	sext.w	a5,a5
    80017660:	00e79563          	bne	a5,a4,8001766a <minix3_get_inode_from_path+0xa8>
            debugf("Returning parent inode %u\n", parent);
            return parent;
    80017664:	fec42783          	lw	a5,-20(s0)
    80017668:	a0b1                	j	800176b4 <minix3_get_inode_from_path+0xf2>
        }
        uint32_t child = minix3_find_dir_entry(block_device, parent, name);
    8001766a:	fec42783          	lw	a5,-20(s0)
    8001766e:	fc843603          	ld	a2,-56(s0)
    80017672:	85be                	mv	a1,a5
    80017674:	fb843503          	ld	a0,-72(s0)
    80017678:	3cc030ef          	jal	ra,8001aa44 <minix3_find_dir_entry>
    8001767c:	87aa                	mv	a5,a0
    8001767e:	fcf42223          	sw	a5,-60(s0)
        parent = child;
    80017682:	fc442783          	lw	a5,-60(s0)
    80017686:	fef42623          	sw	a5,-20(s0)
        debugf("Got child %u\n", child);
        i++;
    8001768a:	fe842783          	lw	a5,-24(s0)
    8001768e:	2785                	addiw	a5,a5,1
    80017690:	fef42423          	sw	a5,-24(s0)
    list_for_each(path_items, elem) {
    80017694:	fe043503          	ld	a0,-32(s0)
    80017698:	206090ef          	jal	ra,8002089e <list_elem_prev>
    8001769c:	fea43023          	sd	a0,-32(s0)
    800176a0:	fe043583          	ld	a1,-32(s0)
    800176a4:	fd843503          	ld	a0,-40(s0)
    800176a8:	120090ef          	jal	ra,800207c8 <list_elem_valid>
    800176ac:	87aa                	mv	a5,a0
    800176ae:	ffb1                	bnez	a5,8001760a <minix3_get_inode_from_path+0x48>
    }

    return parent;
    800176b0:	fec42783          	lw	a5,-20(s0)
}
    800176b4:	853e                	mv	a0,a5
    800176b6:	60e6                	ld	ra,88(sp)
    800176b8:	6446                	ld	s0,80(sp)
    800176ba:	6125                	addi	sp,sp,96
    800176bc:	8082                	ret

00000000800176be <minix3_get_min_inode>:

uint32_t minix3_get_min_inode(VirtioDevice *block_device) {
    800176be:	1101                	addi	sp,sp,-32
    800176c0:	ec22                	sd	s0,24(sp)
    800176c2:	1000                	addi	s0,sp,32
    800176c4:	fea43423          	sd	a0,-24(s0)
    return 1;
    800176c8:	4785                	li	a5,1
}
    800176ca:	853e                	mv	a0,a5
    800176cc:	6462                	ld	s0,24(sp)
    800176ce:	6105                	addi	sp,sp,32
    800176d0:	8082                	ret

00000000800176d2 <minix3_get_max_inode>:

uint32_t minix3_get_max_inode(VirtioDevice *block_device) {
    800176d2:	715d                	addi	sp,sp,-80
    800176d4:	e486                	sd	ra,72(sp)
    800176d6:	e0a2                	sd	s0,64(sp)
    800176d8:	fc26                	sd	s1,56(sp)
    800176da:	0880                	addi	s0,sp,80
    800176dc:	faa43c23          	sd	a0,-72(s0)
    return minix3_get_block_size(block_device) * minix3_get_superblock(block_device).imap_blocks * 8;
    800176e0:	fb843503          	ld	a0,-72(s0)
    800176e4:	7ee000ef          	jal	ra,80017ed2 <minix3_get_block_size>
    800176e8:	87aa                	mv	a5,a0
    800176ea:	0007849b          	sext.w	s1,a5
    800176ee:	fc040793          	addi	a5,s0,-64
    800176f2:	fb843583          	ld	a1,-72(s0)
    800176f6:	853e                	mv	a0,a5
    800176f8:	72a000ef          	jal	ra,80017e22 <minix3_get_superblock>
    800176fc:	fc645783          	lhu	a5,-58(s0)
    80017700:	2781                	sext.w	a5,a5
    80017702:	02f487bb          	mulw	a5,s1,a5
    80017706:	2781                	sext.w	a5,a5
    80017708:	0037979b          	slliw	a5,a5,0x3
    8001770c:	2781                	sext.w	a5,a5
    8001770e:	2781                	sext.w	a5,a5
}
    80017710:	853e                	mv	a0,a5
    80017712:	60a6                	ld	ra,72(sp)
    80017714:	6406                	ld	s0,64(sp)
    80017716:	74e2                	ld	s1,56(sp)
    80017718:	6161                	addi	sp,sp,80
    8001771a:	8082                	ret

000000008001771c <minix3_get_inode_byte_offset>:

uintptr_t minix3_get_inode_byte_offset(VirtioDevice *block_device, SuperBlock sb, uint32_t inode) {
    8001771c:	7179                	addi	sp,sp,-48
    8001771e:	f406                	sd	ra,40(sp)
    80017720:	f022                	sd	s0,32(sp)
    80017722:	ec26                	sd	s1,24(sp)
    80017724:	1800                	addi	s0,sp,48
    80017726:	fca43c23          	sd	a0,-40(s0)
    8001772a:	80ae                	mv	ra,a1
    8001772c:	87b2                	mv	a5,a2
    8001772e:	fcf42a23          	sw	a5,-44(s0)
    if (inode == INVALID_INODE) {
    80017732:	fd442783          	lw	a5,-44(s0)
    80017736:	2781                	sext.w	a5,a5
    80017738:	ef81                	bnez	a5,80017750 <minix3_get_inode_byte_offset+0x34>
        fatalf("Invalid inode %u\n", inode);
    8001773a:	fd442783          	lw	a5,-44(s0)
    8001773e:	85be                	mv	a1,a5
    80017740:	00010517          	auipc	a0,0x10
    80017744:	66850513          	addi	a0,a0,1640 # 80027da8 <pow10.0+0xf48>
    80017748:	7f4040ef          	jal	ra,8001bf3c <fatalf>
        return 0;
    8001774c:	4781                	li	a5,0
    8001774e:	a83d                	j	8001778c <minix3_get_inode_byte_offset+0x70>
    }
    return (FS_IMAP_IDX + sb.imap_blocks + sb.zmap_blocks) * minix3_get_block_size(block_device) + (inode - 1) * sizeof(Inode);
    80017750:	0060d783          	lhu	a5,6(ra)
    80017754:	2781                	sext.w	a5,a5
    80017756:	2789                	addiw	a5,a5,2
    80017758:	0007871b          	sext.w	a4,a5
    8001775c:	0080d783          	lhu	a5,8(ra)
    80017760:	2781                	sext.w	a5,a5
    80017762:	9fb9                	addw	a5,a5,a4
    80017764:	0007849b          	sext.w	s1,a5
    80017768:	fd843503          	ld	a0,-40(s0)
    8001776c:	766000ef          	jal	ra,80017ed2 <minix3_get_block_size>
    80017770:	87aa                	mv	a5,a0
    80017772:	2781                	sext.w	a5,a5
    80017774:	02f487bb          	mulw	a5,s1,a5
    80017778:	2781                	sext.w	a5,a5
    8001777a:	873e                	mv	a4,a5
    8001777c:	fd442783          	lw	a5,-44(s0)
    80017780:	37fd                	addiw	a5,a5,-1
    80017782:	2781                	sext.w	a5,a5
    80017784:	1782                	slli	a5,a5,0x20
    80017786:	9381                	srli	a5,a5,0x20
    80017788:	079a                	slli	a5,a5,0x6
    8001778a:	97ba                	add	a5,a5,a4
}
    8001778c:	853e                	mv	a0,a5
    8001778e:	70a2                	ld	ra,40(sp)
    80017790:	7402                	ld	s0,32(sp)
    80017792:	64e2                	ld	s1,24(sp)
    80017794:	6145                	addi	sp,sp,48
    80017796:	8082                	ret

0000000080017798 <minix3_superblock_init>:
// uintptr_t minix3_get_inode_bitmap_byte_offset(SuperBlock sb, uint32_t inode) {
//     return FS_IMAP_IDX * minix3_get_block_size(block_device) + inode / 8;
// }


void minix3_superblock_init(VirtioDevice *block_device) {
    80017798:	7119                	addi	sp,sp,-128
    8001779a:	fc86                	sd	ra,120(sp)
    8001779c:	f8a2                	sd	s0,112(sp)
    8001779e:	0100                	addi	s0,sp,128
    800177a0:	faa43423          	sd	a0,-88(s0)
    // uint64_t sector_size = block_device_get_sector_size();
    // Initialize the superblock
    // uint64_t num_sectors = block_device_get_sector_count();
    uint64_t device_bytes = block_device_get_bytes(block_device);
    800177a4:	fa843503          	ld	a0,-88(s0)
    800177a8:	7db060ef          	jal	ra,8001e782 <block_device_get_bytes>
    800177ac:	fea43423          	sd	a0,-24(s0)
    uint64_t bytes_per_block = 1024;
    800177b0:	40000793          	li	a5,1024
    800177b4:	fef43023          	sd	a5,-32(s0)
    uint64_t num_blocks = device_bytes / bytes_per_block / 2;
    800177b8:	fe843703          	ld	a4,-24(s0)
    800177bc:	fe043783          	ld	a5,-32(s0)
    800177c0:	02f757b3          	divu	a5,a4,a5
    800177c4:	8385                	srli	a5,a5,0x1
    800177c6:	fcf43c23          	sd	a5,-40(s0)
    SuperBlock superblock;
    superblock.magic = 0x4d5a;
    800177ca:	6795                	lui	a5,0x5
    800177cc:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    800177d0:	fcf41823          	sh	a5,-48(s0)
    superblock.log_zone_size = 0;
    800177d4:	fc041223          	sh	zero,-60(s0)
    superblock.max_size = num_blocks * bytes_per_block;
    800177d8:	fd843783          	ld	a5,-40(s0)
    800177dc:	0007871b          	sext.w	a4,a5
    800177e0:	fe043783          	ld	a5,-32(s0)
    800177e4:	2781                	sext.w	a5,a5
    800177e6:	02f707bb          	mulw	a5,a4,a5
    800177ea:	2781                	sext.w	a5,a5
    800177ec:	fcf42423          	sw	a5,-56(s0)
    superblock.num_zones = num_blocks;
    800177f0:	fd843783          	ld	a5,-40(s0)
    800177f4:	2781                	sext.w	a5,a5
    800177f6:	fcf42623          	sw	a5,-52(s0)
    superblock.block_size = bytes_per_block;
    800177fa:	fe043783          	ld	a5,-32(s0)
    800177fe:	17c2                	slli	a5,a5,0x30
    80017800:	93c1                	srli	a5,a5,0x30
    80017802:	fcf41a23          	sh	a5,-44(s0)
    superblock.disk_version = 0;
    80017806:	fc040b23          	sb	zero,-42(s0)
    superblock.num_inodes = num_blocks / 8;
    8001780a:	fd843783          	ld	a5,-40(s0)
    8001780e:	838d                	srli	a5,a5,0x3
    80017810:	2781                	sext.w	a5,a5
    80017812:	faf42c23          	sw	a5,-72(s0)
    superblock.imap_blocks = superblock.num_inodes / (bytes_per_block * 8);
    80017816:	fb842783          	lw	a5,-72(s0)
    8001781a:	02079713          	slli	a4,a5,0x20
    8001781e:	9301                	srli	a4,a4,0x20
    80017820:	fe043783          	ld	a5,-32(s0)
    80017824:	078e                	slli	a5,a5,0x3
    80017826:	02f757b3          	divu	a5,a4,a5
    8001782a:	17c2                	slli	a5,a5,0x30
    8001782c:	93c1                	srli	a5,a5,0x30
    8001782e:	faf41f23          	sh	a5,-66(s0)
    superblock.zmap_blocks = superblock.num_zones / (bytes_per_block * 8);
    80017832:	fcc42783          	lw	a5,-52(s0)
    80017836:	02079713          	slli	a4,a5,0x20
    8001783a:	9301                	srli	a4,a4,0x20
    8001783c:	fe043783          	ld	a5,-32(s0)
    80017840:	078e                	slli	a5,a5,0x3
    80017842:	02f757b3          	divu	a5,a4,a5
    80017846:	17c2                	slli	a5,a5,0x30
    80017848:	93c1                	srli	a5,a5,0x30
    8001784a:	fcf41023          	sh	a5,-64(s0)
    superblock.first_data_zone = 0;
    8001784e:	fc041123          	sh	zero,-62(s0)
    minix3_put_superblock(block_device, superblock);
    80017852:	fb843603          	ld	a2,-72(s0)
    80017856:	fc043683          	ld	a3,-64(s0)
    8001785a:	fc843703          	ld	a4,-56(s0)
    8001785e:	fd043783          	ld	a5,-48(s0)
    80017862:	f8c43023          	sd	a2,-128(s0)
    80017866:	f8d43423          	sd	a3,-120(s0)
    8001786a:	f8e43823          	sd	a4,-112(s0)
    8001786e:	f8f43c23          	sd	a5,-104(s0)
    80017872:	f8040793          	addi	a5,s0,-128
    80017876:	85be                	mv	a1,a5
    80017878:	fa843503          	ld	a0,-88(s0)
    8001787c:	62c000ef          	jal	ra,80017ea8 <minix3_put_superblock>
}
    80017880:	0001                	nop
    80017882:	70e6                	ld	ra,120(sp)
    80017884:	7446                	ld	s0,112(sp)
    80017886:	6109                	addi	sp,sp,128
    80017888:	8082                	ret

000000008001788a <minix3_has_zone>:

bool minix3_has_zone(VirtioDevice *block_device, uint32_t zone) {
    8001788a:	1101                	addi	sp,sp,-32
    8001788c:	ec22                	sd	s0,24(sp)
    8001788e:	1000                	addi	s0,sp,32
    80017890:	fea43423          	sd	a0,-24(s0)
    80017894:	87ae                	mv	a5,a1
    80017896:	fef42223          	sw	a5,-28(s0)
    return inode_bitmap[zone / 8] & (1 << zone % 8);
    8001789a:	0000e797          	auipc	a5,0xe
    8001789e:	84e78793          	addi	a5,a5,-1970 # 800250e8 <inode_bitmap>
    800178a2:	6398                	ld	a4,0(a5)
    800178a4:	fe442783          	lw	a5,-28(s0)
    800178a8:	0037d79b          	srliw	a5,a5,0x3
    800178ac:	2781                	sext.w	a5,a5
    800178ae:	1782                	slli	a5,a5,0x20
    800178b0:	9381                	srli	a5,a5,0x20
    800178b2:	97ba                	add	a5,a5,a4
    800178b4:	0007c783          	lbu	a5,0(a5)
    800178b8:	0007871b          	sext.w	a4,a5
    800178bc:	fe442783          	lw	a5,-28(s0)
    800178c0:	8b9d                	andi	a5,a5,7
    800178c2:	2781                	sext.w	a5,a5
    800178c4:	4685                	li	a3,1
    800178c6:	00f697bb          	sllw	a5,a3,a5
    800178ca:	2781                	sext.w	a5,a5
    800178cc:	8ff9                	and	a5,a5,a4
    800178ce:	2781                	sext.w	a5,a5
    800178d0:	00f037b3          	snez	a5,a5
    800178d4:	0ff7f793          	andi	a5,a5,255
}
    800178d8:	853e                	mv	a0,a5
    800178da:	6462                	ld	s0,24(sp)
    800178dc:	6105                	addi	sp,sp,32
    800178de:	8082                	ret

00000000800178e0 <minix3_take_zone>:

bool minix3_take_zone(VirtioDevice *block_device, uint32_t zone) {
    800178e0:	1101                	addi	sp,sp,-32
    800178e2:	ec06                	sd	ra,24(sp)
    800178e4:	e822                	sd	s0,16(sp)
    800178e6:	1000                	addi	s0,sp,32
    800178e8:	fea43423          	sd	a0,-24(s0)
    800178ec:	87ae                	mv	a5,a1
    800178ee:	fef42223          	sw	a5,-28(s0)
    minix3_load_device(block_device);
    800178f2:	fe843503          	ld	a0,-24(s0)
    800178f6:	7f8000ef          	jal	ra,800180ee <minix3_load_device>
    if (minix3_has_zone(block_device, zone)) {
    800178fa:	fe442783          	lw	a5,-28(s0)
    800178fe:	85be                	mv	a1,a5
    80017900:	fe843503          	ld	a0,-24(s0)
    80017904:	f87ff0ef          	jal	ra,8001788a <minix3_has_zone>
    80017908:	87aa                	mv	a5,a0
    8001790a:	cf81                	beqz	a5,80017922 <minix3_take_zone+0x42>
        warnf("minix3_take_zone: zone %u is already taken\n", zone);
    8001790c:	fe442783          	lw	a5,-28(s0)
    80017910:	85be                	mv	a1,a5
    80017912:	00010517          	auipc	a0,0x10
    80017916:	4ae50513          	addi	a0,a0,1198 # 80027dc0 <pow10.0+0xf60>
    8001791a:	51e040ef          	jal	ra,8001be38 <warnf>
        return false;
    8001791e:	4781                	li	a5,0
    80017920:	a8bd                	j	8001799e <minix3_take_zone+0xbe>
    }

    zone_bitmap[zone / 8] |= (1 << zone % 8);
    80017922:	0000d797          	auipc	a5,0xd
    80017926:	7ce78793          	addi	a5,a5,1998 # 800250f0 <zone_bitmap>
    8001792a:	6398                	ld	a4,0(a5)
    8001792c:	fe442783          	lw	a5,-28(s0)
    80017930:	0037d79b          	srliw	a5,a5,0x3
    80017934:	0007861b          	sext.w	a2,a5
    80017938:	02061793          	slli	a5,a2,0x20
    8001793c:	9381                	srli	a5,a5,0x20
    8001793e:	97ba                	add	a5,a5,a4
    80017940:	0007c783          	lbu	a5,0(a5)
    80017944:	0187971b          	slliw	a4,a5,0x18
    80017948:	4187571b          	sraiw	a4,a4,0x18
    8001794c:	fe442783          	lw	a5,-28(s0)
    80017950:	8b9d                	andi	a5,a5,7
    80017952:	2781                	sext.w	a5,a5
    80017954:	4685                	li	a3,1
    80017956:	00f697bb          	sllw	a5,a3,a5
    8001795a:	2781                	sext.w	a5,a5
    8001795c:	0187979b          	slliw	a5,a5,0x18
    80017960:	4187d79b          	sraiw	a5,a5,0x18
    80017964:	8fd9                	or	a5,a5,a4
    80017966:	0187969b          	slliw	a3,a5,0x18
    8001796a:	4186d69b          	sraiw	a3,a3,0x18
    8001796e:	0000d797          	auipc	a5,0xd
    80017972:	78278793          	addi	a5,a5,1922 # 800250f0 <zone_bitmap>
    80017976:	6398                	ld	a4,0(a5)
    80017978:	02061793          	slli	a5,a2,0x20
    8001797c:	9381                	srli	a5,a5,0x20
    8001797e:	97ba                	add	a5,a5,a4
    80017980:	0ff6f713          	andi	a4,a3,255
    80017984:	00e78023          	sb	a4,0(a5)
    minix3_put_zone_bitmap(block_device, zone_bitmap);
    80017988:	0000d797          	auipc	a5,0xd
    8001798c:	76878793          	addi	a5,a5,1896 # 800250f0 <zone_bitmap>
    80017990:	639c                	ld	a5,0(a5)
    80017992:	85be                	mv	a1,a5
    80017994:	fe843503          	ld	a0,-24(s0)
    80017998:	70e000ef          	jal	ra,800180a6 <minix3_put_zone_bitmap>
    // Inode inode_data = minix3_get_zone(block_device, zone);
    // inode_data.num_links = 1;
    // minix3_put_inode(block_device, inode, inode_data);

    return true;
    8001799c:	4785                	li	a5,1
}
    8001799e:	853e                	mv	a0,a5
    800179a0:	60e2                	ld	ra,24(sp)
    800179a2:	6442                	ld	s0,16(sp)
    800179a4:	6105                	addi	sp,sp,32
    800179a6:	8082                	ret

00000000800179a8 <minix3_get_next_free_zone>:

uint32_t minix3_get_next_free_zone(VirtioDevice *block_device) {
    800179a8:	7139                	addi	sp,sp,-64
    800179aa:	fc06                	sd	ra,56(sp)
    800179ac:	f822                	sd	s0,48(sp)
    800179ae:	0080                	addi	s0,sp,64
    800179b0:	fca43423          	sd	a0,-56(s0)
    size_t zone_bitmap_size = minix3_get_zone_size(block_device);
    800179b4:	fc843503          	ld	a0,-56(s0)
    800179b8:	552000ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800179bc:	87aa                	mv	a5,a0
    800179be:	fef43023          	sd	a5,-32(s0)
    for (int i = 0; i < zone_bitmap_size; i++) {
    800179c2:	fe042623          	sw	zero,-20(s0)
    800179c6:	a8bd                	j	80017a44 <minix3_get_next_free_zone+0x9c>
        if (zone_bitmap[i] != 0xFF) {
    800179c8:	0000d797          	auipc	a5,0xd
    800179cc:	72878793          	addi	a5,a5,1832 # 800250f0 <zone_bitmap>
    800179d0:	6398                	ld	a4,0(a5)
    800179d2:	fec42783          	lw	a5,-20(s0)
    800179d6:	97ba                	add	a5,a5,a4
    800179d8:	0007c783          	lbu	a5,0(a5)
    800179dc:	873e                	mv	a4,a5
    800179de:	0ff00793          	li	a5,255
    800179e2:	04f70c63          	beq	a4,a5,80017a3a <minix3_get_next_free_zone+0x92>
            for (int j = 0; j < 8; j++) {
    800179e6:	fe042423          	sw	zero,-24(s0)
    800179ea:	a089                	j	80017a2c <minix3_get_next_free_zone+0x84>
                uint32_t zone = 8 * i + j;
    800179ec:	fec42783          	lw	a5,-20(s0)
    800179f0:	0037979b          	slliw	a5,a5,0x3
    800179f4:	2781                	sext.w	a5,a5
    800179f6:	fe842703          	lw	a4,-24(s0)
    800179fa:	9fb9                	addw	a5,a5,a4
    800179fc:	2781                	sext.w	a5,a5
    800179fe:	fcf42e23          	sw	a5,-36(s0)
                if (!minix3_has_zone(block_device, zone))
    80017a02:	fdc42783          	lw	a5,-36(s0)
    80017a06:	85be                	mv	a1,a5
    80017a08:	fc843503          	ld	a0,-56(s0)
    80017a0c:	e7fff0ef          	jal	ra,8001788a <minix3_has_zone>
    80017a10:	87aa                	mv	a5,a0
    80017a12:	0017c793          	xori	a5,a5,1
    80017a16:	0ff7f793          	andi	a5,a5,255
    80017a1a:	c781                	beqz	a5,80017a22 <minix3_get_next_free_zone+0x7a>
                    return zone;
    80017a1c:	fdc42783          	lw	a5,-36(s0)
    80017a20:	a83d                	j	80017a5e <minix3_get_next_free_zone+0xb6>
            for (int j = 0; j < 8; j++) {
    80017a22:	fe842783          	lw	a5,-24(s0)
    80017a26:	2785                	addiw	a5,a5,1
    80017a28:	fef42423          	sw	a5,-24(s0)
    80017a2c:	fe842783          	lw	a5,-24(s0)
    80017a30:	0007871b          	sext.w	a4,a5
    80017a34:	479d                	li	a5,7
    80017a36:	fae7dbe3          	bge	a5,a4,800179ec <minix3_get_next_free_zone+0x44>
    for (int i = 0; i < zone_bitmap_size; i++) {
    80017a3a:	fec42783          	lw	a5,-20(s0)
    80017a3e:	2785                	addiw	a5,a5,1
    80017a40:	fef42623          	sw	a5,-20(s0)
    80017a44:	fec42783          	lw	a5,-20(s0)
    80017a48:	fe043703          	ld	a4,-32(s0)
    80017a4c:	f6e7eee3          	bltu	a5,a4,800179c8 <minix3_get_next_free_zone+0x20>
            }
        }
    }
    warnf("minix3_get_next_free_zone: Couldn't find free zone\n");
    80017a50:	00010517          	auipc	a0,0x10
    80017a54:	3a050513          	addi	a0,a0,928 # 80027df0 <pow10.0+0xf90>
    80017a58:	3e0040ef          	jal	ra,8001be38 <warnf>
    return 0;
    80017a5c:	4781                	li	a5,0
}
    80017a5e:	853e                	mv	a0,a5
    80017a60:	70e2                	ld	ra,56(sp)
    80017a62:	7442                	ld	s0,48(sp)
    80017a64:	6121                	addi	sp,sp,64
    80017a66:	8082                	ret

0000000080017a68 <minix3_get_zone>:

void minix3_get_zone(VirtioDevice *block_device, uint32_t zone, uint8_t *data) {
    80017a68:	715d                	addi	sp,sp,-80
    80017a6a:	e486                	sd	ra,72(sp)
    80017a6c:	e0a2                	sd	s0,64(sp)
    80017a6e:	0880                	addi	s0,sp,80
    80017a70:	fca43423          	sd	a0,-56(s0)
    80017a74:	87ae                	mv	a5,a1
    80017a76:	fac43c23          	sd	a2,-72(s0)
    80017a7a:	fcf42223          	sw	a5,-60(s0)
    SuperBlock sb = minix3_get_superblock(block_device);
    80017a7e:	fd040793          	addi	a5,s0,-48
    80017a82:	fc843583          	ld	a1,-56(s0)
    80017a86:	853e                	mv	a0,a5
    80017a88:	39a000ef          	jal	ra,80017e22 <minix3_get_superblock>
    if (zone > sb.num_zones + sb.first_data_zone) {
    80017a8c:	fe442703          	lw	a4,-28(s0)
    80017a90:	fda45783          	lhu	a5,-38(s0)
    80017a94:	2781                	sext.w	a5,a5
    80017a96:	9fb9                	addw	a5,a5,a4
    80017a98:	0007871b          	sext.w	a4,a5
    80017a9c:	fc442783          	lw	a5,-60(s0)
    80017aa0:	2781                	sext.w	a5,a5
    80017aa2:	00f77f63          	bgeu	a4,a5,80017ac0 <minix3_get_zone+0x58>
        warnf("Zone %u (%x) is out of bounds\n", zone, zone);
    80017aa6:	fc442703          	lw	a4,-60(s0)
    80017aaa:	fc442783          	lw	a5,-60(s0)
    80017aae:	863a                	mv	a2,a4
    80017ab0:	85be                	mv	a1,a5
    80017ab2:	00010517          	auipc	a0,0x10
    80017ab6:	37650513          	addi	a0,a0,886 # 80027e28 <pow10.0+0xfc8>
    80017aba:	37e040ef          	jal	ra,8001be38 <warnf>
        return;
    80017abe:	a0b9                	j	80017b0c <minix3_get_zone+0xa4>
    }

    if (zone < sb.first_data_zone) {
    80017ac0:	fda45783          	lhu	a5,-38(s0)
    80017ac4:	0007871b          	sext.w	a4,a5
    80017ac8:	fc442783          	lw	a5,-60(s0)
    80017acc:	2781                	sext.w	a5,a5
    80017ace:	02e7f663          	bgeu	a5,a4,80017afa <minix3_get_zone+0x92>
        warnf("Zone %u (%x) is before the first data zone %u (%x)\n", zone, zone, sb.first_data_zone, sb.first_data_zone);
    80017ad2:	fda45783          	lhu	a5,-38(s0)
    80017ad6:	0007869b          	sext.w	a3,a5
    80017ada:	fda45783          	lhu	a5,-38(s0)
    80017ade:	0007871b          	sext.w	a4,a5
    80017ae2:	fc442603          	lw	a2,-60(s0)
    80017ae6:	fc442783          	lw	a5,-60(s0)
    80017aea:	85be                	mv	a1,a5
    80017aec:	00010517          	auipc	a0,0x10
    80017af0:	35c50513          	addi	a0,a0,860 # 80027e48 <pow10.0+0xfe8>
    80017af4:	344040ef          	jal	ra,8001be38 <warnf>
        return;
    80017af8:	a811                	j	80017b0c <minix3_get_zone+0xa4>
    }
    
    // minix3_get_block(minix3_get_superblock().first_data_zone + zone, data);
    minix3_get_block(block_device, zone, data);
    80017afa:	fc442783          	lw	a5,-60(s0)
    80017afe:	fb843603          	ld	a2,-72(s0)
    80017b02:	85be                	mv	a1,a5
    80017b04:	fc843503          	ld	a0,-56(s0)
    80017b08:	7a4000ef          	jal	ra,800182ac <minix3_get_block>
}
    80017b0c:	60a6                	ld	ra,72(sp)
    80017b0e:	6406                	ld	s0,64(sp)
    80017b10:	6161                	addi	sp,sp,80
    80017b12:	8082                	ret

0000000080017b14 <minix3_put_zone>:
void minix3_put_zone(VirtioDevice *block_device, uint32_t zone, uint8_t *data) {
    80017b14:	715d                	addi	sp,sp,-80
    80017b16:	e486                	sd	ra,72(sp)
    80017b18:	e0a2                	sd	s0,64(sp)
    80017b1a:	0880                	addi	s0,sp,80
    80017b1c:	fca43423          	sd	a0,-56(s0)
    80017b20:	87ae                	mv	a5,a1
    80017b22:	fac43c23          	sd	a2,-72(s0)
    80017b26:	fcf42223          	sw	a5,-60(s0)
    SuperBlock sb = minix3_get_superblock(block_device);
    80017b2a:	fd040793          	addi	a5,s0,-48
    80017b2e:	fc843583          	ld	a1,-56(s0)
    80017b32:	853e                	mv	a0,a5
    80017b34:	2ee000ef          	jal	ra,80017e22 <minix3_get_superblock>
    if (zone > sb.num_zones + sb.first_data_zone) {
    80017b38:	fe442703          	lw	a4,-28(s0)
    80017b3c:	fda45783          	lhu	a5,-38(s0)
    80017b40:	2781                	sext.w	a5,a5
    80017b42:	9fb9                	addw	a5,a5,a4
    80017b44:	0007871b          	sext.w	a4,a5
    80017b48:	fc442783          	lw	a5,-60(s0)
    80017b4c:	2781                	sext.w	a5,a5
    80017b4e:	00f77f63          	bgeu	a4,a5,80017b6c <minix3_put_zone+0x58>
        warnf("Zone %u (%x) is out of bounds\n", zone, zone);
    80017b52:	fc442703          	lw	a4,-60(s0)
    80017b56:	fc442783          	lw	a5,-60(s0)
    80017b5a:	863a                	mv	a2,a4
    80017b5c:	85be                	mv	a1,a5
    80017b5e:	00010517          	auipc	a0,0x10
    80017b62:	2ca50513          	addi	a0,a0,714 # 80027e28 <pow10.0+0xfc8>
    80017b66:	2d2040ef          	jal	ra,8001be38 <warnf>
        return;
    80017b6a:	a0b9                	j	80017bb8 <minix3_put_zone+0xa4>
    }

    if (zone < sb.first_data_zone) {
    80017b6c:	fda45783          	lhu	a5,-38(s0)
    80017b70:	0007871b          	sext.w	a4,a5
    80017b74:	fc442783          	lw	a5,-60(s0)
    80017b78:	2781                	sext.w	a5,a5
    80017b7a:	02e7f663          	bgeu	a5,a4,80017ba6 <minix3_put_zone+0x92>
        warnf("Zone %u (%x) is before the first data zone %u (%x)\n", zone, zone, sb.first_data_zone, sb.first_data_zone);
    80017b7e:	fda45783          	lhu	a5,-38(s0)
    80017b82:	0007869b          	sext.w	a3,a5
    80017b86:	fda45783          	lhu	a5,-38(s0)
    80017b8a:	0007871b          	sext.w	a4,a5
    80017b8e:	fc442603          	lw	a2,-60(s0)
    80017b92:	fc442783          	lw	a5,-60(s0)
    80017b96:	85be                	mv	a1,a5
    80017b98:	00010517          	auipc	a0,0x10
    80017b9c:	2b050513          	addi	a0,a0,688 # 80027e48 <pow10.0+0xfe8>
    80017ba0:	298040ef          	jal	ra,8001be38 <warnf>
        return;
    80017ba4:	a811                	j	80017bb8 <minix3_put_zone+0xa4>
    }

    minix3_put_block(block_device, zone, data);
    80017ba6:	fc442783          	lw	a5,-60(s0)
    80017baa:	fb843603          	ld	a2,-72(s0)
    80017bae:	85be                	mv	a1,a5
    80017bb0:	fc843503          	ld	a0,-56(s0)
    80017bb4:	72c000ef          	jal	ra,800182e0 <minix3_put_block>
}
    80017bb8:	60a6                	ld	ra,72(sp)
    80017bba:	6406                	ld	s0,64(sp)
    80017bbc:	6161                	addi	sp,sp,80
    80017bbe:	8082                	ret

0000000080017bc0 <minix3_get_file_size>:

uint64_t minix3_get_file_size(VirtioDevice *block_device, uint32_t inode) {
    80017bc0:	711d                	addi	sp,sp,-96
    80017bc2:	ec86                	sd	ra,88(sp)
    80017bc4:	e8a2                	sd	s0,80(sp)
    80017bc6:	1080                	addi	s0,sp,96
    80017bc8:	faa43423          	sd	a0,-88(s0)
    80017bcc:	87ae                	mv	a5,a1
    80017bce:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    80017bd2:	fb040793          	addi	a5,s0,-80
    80017bd6:	fa442703          	lw	a4,-92(s0)
    80017bda:	863a                	mv	a2,a4
    80017bdc:	fa843583          	ld	a1,-88(s0)
    80017be0:	853e                	mv	a0,a5
    80017be2:	1a9000ef          	jal	ra,8001858a <minix3_get_inode>
    if (S_ISREG(inode_data.mode)) {
    80017be6:	fb045783          	lhu	a5,-80(s0)
    80017bea:	0007871b          	sext.w	a4,a5
    80017bee:	67bd                	lui	a5,0xf
    80017bf0:	8ff9                	and	a5,a5,a4
    80017bf2:	2781                	sext.w	a5,a5
    80017bf4:	873e                	mv	a4,a5
    80017bf6:	67a1                	lui	a5,0x8
    80017bf8:	00f71763          	bne	a4,a5,80017c06 <minix3_get_file_size+0x46>
        return inode_data.size;
    80017bfc:	fb842783          	lw	a5,-72(s0)
    80017c00:	1782                	slli	a5,a5,0x20
    80017c02:	9381                	srli	a5,a5,0x20
    80017c04:	a0b1                	j	80017c50 <minix3_get_file_size+0x90>
    } else if (S_ISDIR(inode_data.mode)) {
    80017c06:	fb045783          	lhu	a5,-80(s0)
    80017c0a:	0007871b          	sext.w	a4,a5
    80017c0e:	67bd                	lui	a5,0xf
    80017c10:	8ff9                	and	a5,a5,a4
    80017c12:	2781                	sext.w	a5,a5
    80017c14:	873e                	mv	a4,a5
    80017c16:	6791                	lui	a5,0x4
    80017c18:	00f71463          	bne	a4,a5,80017c20 <minix3_get_file_size+0x60>
        return 0;
    80017c1c:	4781                	li	a5,0
    80017c1e:	a80d                	j	80017c50 <minix3_get_file_size+0x90>
    } else if (S_ISBLK(inode_data.mode)) {
    80017c20:	fb045783          	lhu	a5,-80(s0)
    80017c24:	0007871b          	sext.w	a4,a5
    80017c28:	67bd                	lui	a5,0xf
    80017c2a:	8ff9                	and	a5,a5,a4
    80017c2c:	2781                	sext.w	a5,a5
    80017c2e:	873e                	mv	a4,a5
    80017c30:	6799                	lui	a5,0x6
    80017c32:	00f71463          	bne	a4,a5,80017c3a <minix3_get_file_size+0x7a>
        return 0;
    80017c36:	4781                	li	a5,0
    80017c38:	a821                	j	80017c50 <minix3_get_file_size+0x90>
    } else {
        fatalf("Unknown inode type %x\n", inode_data.mode);
    80017c3a:	fb045783          	lhu	a5,-80(s0)
    80017c3e:	2781                	sext.w	a5,a5
    80017c40:	85be                	mv	a1,a5
    80017c42:	00010517          	auipc	a0,0x10
    80017c46:	23e50513          	addi	a0,a0,574 # 80027e80 <pow10.0+0x1020>
    80017c4a:	2f2040ef          	jal	ra,8001bf3c <fatalf>
        return 0;
    80017c4e:	4781                	li	a5,0
    }
}
    80017c50:	853e                	mv	a0,a5
    80017c52:	60e6                	ld	ra,88(sp)
    80017c54:	6446                	ld	s0,80(sp)
    80017c56:	6125                	addi	sp,sp,96
    80017c58:	8082                	ret

0000000080017c5a <debug_inode>:

void debug_inode(VirtioDevice *block_device, uint32_t i) {
    80017c5a:	7159                	addi	sp,sp,-112
    80017c5c:	f486                	sd	ra,104(sp)
    80017c5e:	f0a2                	sd	s0,96(sp)
    80017c60:	1880                	addi	s0,sp,112
    80017c62:	f8a43c23          	sd	a0,-104(s0)
    80017c66:	87ae                	mv	a5,a1
    80017c68:	f8f42a23          	sw	a5,-108(s0)
    Inode inode = minix3_get_inode(block_device, i);
    80017c6c:	fa840793          	addi	a5,s0,-88
    80017c70:	f9442703          	lw	a4,-108(s0)
    80017c74:	863a                	mv	a2,a4
    80017c76:	f9843583          	ld	a1,-104(s0)
    80017c7a:	853e                	mv	a0,a5
    80017c7c:	10f000ef          	jal	ra,8001858a <minix3_get_inode>
    debugf("   size: %d\n", inode.size);
    debugf("   atime: %d\n", inode.atime);
    debugf("   mtime: %d\n", inode.mtime);
    debugf("   ctime: %d\n", inode.ctime);
    debugf("   zones[]:\n");
    for (uint8_t j=0; j<10; j++) {
    80017c80:	fe0407a3          	sb	zero,-17(s0)
    80017c84:	a031                	j	80017c90 <debug_inode+0x36>
    80017c86:	fef44783          	lbu	a5,-17(s0)
    80017c8a:	2785                	addiw	a5,a5,1
    80017c8c:	fef407a3          	sb	a5,-17(s0)
    80017c90:	fef44783          	lbu	a5,-17(s0)
    80017c94:	0ff7f713          	andi	a4,a5,255
    80017c98:	47a5                	li	a5,9
    80017c9a:	fee7f6e3          	bgeu	a5,a4,80017c86 <debug_inode+0x2c>
        debugf("   zones[%d] = %x (*1024 = %x)\n", j, inode.zones[j], inode.zones[j] * 1024);
    }
}
    80017c9e:	0001                	nop
    80017ca0:	0001                	nop
    80017ca2:	70a6                	ld	ra,104(sp)
    80017ca4:	7406                	ld	s0,96(sp)
    80017ca6:	6165                	addi	sp,sp,112
    80017ca8:	8082                	ret

0000000080017caa <minix3_init_callback>:
    uint32_t file_count;
    uint32_t dir_count;
} CallbackData;

// A callback function for counting up the files and printing them out
void minix3_init_callback(VirtioDevice *block_device, uint32_t inode, const char *path, char *name, void *data, uint32_t depth) {
    80017caa:	715d                	addi	sp,sp,-80
    80017cac:	e486                	sd	ra,72(sp)
    80017cae:	e0a2                	sd	s0,64(sp)
    80017cb0:	0880                	addi	s0,sp,80
    80017cb2:	fca43c23          	sd	a0,-40(s0)
    80017cb6:	fcc43423          	sd	a2,-56(s0)
    80017cba:	fcd43023          	sd	a3,-64(s0)
    80017cbe:	fae43c23          	sd	a4,-72(s0)
    80017cc2:	873e                	mv	a4,a5
    80017cc4:	87ae                	mv	a5,a1
    80017cc6:	fcf42a23          	sw	a5,-44(s0)
    80017cca:	87ba                	mv	a5,a4
    80017ccc:	fcf42823          	sw	a5,-48(s0)
    CallbackData *cb_data = (CallbackData *)data;
    80017cd0:	fb843783          	ld	a5,-72(s0)
    80017cd4:	fef43023          	sd	a5,-32(s0)

    for (uint32_t i=0; i<depth; i++) {
    80017cd8:	fe042623          	sw	zero,-20(s0)
    80017cdc:	a821                	j	80017cf4 <minix3_init_callback+0x4a>
        infof("   ");
    80017cde:	00010517          	auipc	a0,0x10
    80017ce2:	1ba50513          	addi	a0,a0,442 # 80027e98 <pow10.0+0x1038>
    80017ce6:	200040ef          	jal	ra,8001bee6 <infof>
    for (uint32_t i=0; i<depth; i++) {
    80017cea:	fec42783          	lw	a5,-20(s0)
    80017cee:	2785                	addiw	a5,a5,1
    80017cf0:	fef42623          	sw	a5,-20(s0)
    80017cf4:	fec42703          	lw	a4,-20(s0)
    80017cf8:	fd042783          	lw	a5,-48(s0)
    80017cfc:	2701                	sext.w	a4,a4
    80017cfe:	2781                	sext.w	a5,a5
    80017d00:	fcf76fe3          	bltu	a4,a5,80017cde <minix3_init_callback+0x34>
    }
    if (cb_data->mounted_path) {
    80017d04:	fe043783          	ld	a5,-32(s0)
    80017d08:	639c                	ld	a5,0(a5)
    80017d0a:	c385                	beqz	a5,80017d2a <minix3_init_callback+0x80>
        infof("%s\n", cb_data->mounted_path);
    80017d0c:	fe043783          	ld	a5,-32(s0)
    80017d10:	639c                	ld	a5,0(a5)
    80017d12:	85be                	mv	a1,a5
    80017d14:	00010517          	auipc	a0,0x10
    80017d18:	18c50513          	addi	a0,a0,396 # 80027ea0 <pow10.0+0x1040>
    80017d1c:	1ca040ef          	jal	ra,8001bee6 <infof>
        cb_data->mounted_path = NULL;
    80017d20:	fe043783          	ld	a5,-32(s0)
    80017d24:	0007b023          	sd	zero,0(a5) # 6000 <i+0x5fe0>
        return;
    80017d28:	a08d                	j	80017d8a <minix3_init_callback+0xe0>
    } else {
        infof("%s", name);
    80017d2a:	fc043583          	ld	a1,-64(s0)
    80017d2e:	00010517          	auipc	a0,0x10
    80017d32:	17a50513          	addi	a0,a0,378 # 80027ea8 <pow10.0+0x1048>
    80017d36:	1b0040ef          	jal	ra,8001bee6 <infof>
    }
    // infof("%s", name);
    // infof("name: %s", name);
    
    if (minix3_is_dir(block_device, inode)) {
    80017d3a:	fd442783          	lw	a5,-44(s0)
    80017d3e:	85be                	mv	a1,a5
    80017d40:	fd843503          	ld	a0,-40(s0)
    80017d44:	379000ef          	jal	ra,800188bc <minix3_is_dir>
    80017d48:	87aa                	mv	a5,a0
    80017d4a:	c38d                	beqz	a5,80017d6c <minix3_init_callback+0xc2>
        infof("/\n");
    80017d4c:	00010517          	auipc	a0,0x10
    80017d50:	16450513          	addi	a0,a0,356 # 80027eb0 <pow10.0+0x1050>
    80017d54:	192040ef          	jal	ra,8001bee6 <infof>
        cb_data->dir_count++;
    80017d58:	fe043783          	ld	a5,-32(s0)
    80017d5c:	47dc                	lw	a5,12(a5)
    80017d5e:	2785                	addiw	a5,a5,1
    80017d60:	0007871b          	sext.w	a4,a5
    80017d64:	fe043783          	ld	a5,-32(s0)
    80017d68:	c7d8                	sw	a4,12(a5)
    80017d6a:	a005                	j	80017d8a <minix3_init_callback+0xe0>
    } else {
        infof("\n");
    80017d6c:	00010517          	auipc	a0,0x10
    80017d70:	14c50513          	addi	a0,a0,332 # 80027eb8 <pow10.0+0x1058>
    80017d74:	172040ef          	jal	ra,8001bee6 <infof>
        cb_data->file_count++;
    80017d78:	fe043783          	ld	a5,-32(s0)
    80017d7c:	479c                	lw	a5,8(a5)
    80017d7e:	2785                	addiw	a5,a5,1
    80017d80:	0007871b          	sext.w	a4,a5
    80017d84:	fe043783          	ld	a5,-32(s0)
    80017d88:	c798                	sw	a4,8(a5)

    // for (uint32_t i=0; i<depth; i++) {
    //     infof("   ");
    // }
    // infof("path: %s\n\n", path);
}
    80017d8a:	60a6                	ld	ra,72(sp)
    80017d8c:	6406                	ld	s0,64(sp)
    80017d8e:	6161                	addi	sp,sp,80
    80017d90:	8082                	ret

0000000080017d92 <minix3_init>:

void minix3_init(VirtioDevice *block_device, const char *path)
{
    80017d92:	715d                	addi	sp,sp,-80
    80017d94:	e486                	sd	ra,72(sp)
    80017d96:	e0a2                	sd	s0,64(sp)
    80017d98:	0880                	addi	s0,sp,80
    80017d9a:	fca43c23          	sd	a0,-40(s0)
    80017d9e:	fcb43823          	sd	a1,-48(s0)
    // Initialize the filesystem
    debugf("Initializing Minix3 filesystem on device %p at %s\n", block_device, path);
    minix3_get_superblock(block_device);
    80017da2:	fb040793          	addi	a5,s0,-80
    80017da6:	fd843583          	ld	a1,-40(s0)
    80017daa:	853e                	mv	a0,a5
    80017dac:	076000ef          	jal	ra,80017e22 <minix3_get_superblock>
    debugf("   num_zones: 0x%x (%d)\n", sb.num_zones, sb.num_zones);
    debugf("   magic: 0x%x\n", sb.magic);
    debugf("   block_size: %d\n", sb.block_size);
    debugf("   disk_version: %d\n", sb.disk_version);

    if (sb.magic != MINIX3_MAGIC) {
    80017db0:	0000d797          	auipc	a5,0xd
    80017db4:	31078793          	addi	a5,a5,784 # 800250c0 <sb>
    80017db8:	0187d783          	lhu	a5,24(a5)
    80017dbc:	0007871b          	sext.w	a4,a5
    80017dc0:	6795                	lui	a5,0x5
    80017dc2:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    80017dc6:	00f70c63          	beq	a4,a5,80017dde <minix3_init+0x4c>
        // We need to initialize the superblock
        warnf("Minix3 magic is not correct, initializing superblock ourselves...\n");
    80017dca:	00010517          	auipc	a0,0x10
    80017dce:	0f650513          	addi	a0,a0,246 # 80027ec0 <pow10.0+0x1060>
    80017dd2:	066040ef          	jal	ra,8001be38 <warnf>
        minix3_superblock_init(block_device);
    80017dd6:	fd843503          	ld	a0,-40(s0)
    80017dda:	9bfff0ef          	jal	ra,80017798 <minix3_superblock_init>
    // // Copy the zone bitmap into memory
    // minix3_get_zone_bitmap(zone_bitmap);

    // inode_bitmap = (uint8_t *)kmalloc(minix3_get_inode_bitmap_size());
    // zone_bitmap = (uint8_t*)kmalloc(minix3_get_zone_bitmap_size(block_device));
    minix3_load_device(block_device);
    80017dde:	fd843503          	ld	a0,-40(s0)
    80017de2:	30c000ef          	jal	ra,800180ee <minix3_load_device>
    }
    */

    // const char *path = "/home/cosc562";

    CallbackData cb_data = {0};
    80017de6:	fe043023          	sd	zero,-32(s0)
    80017dea:	fe043423          	sd	zero,-24(s0)
    cb_data.mounted_path = path;
    80017dee:	fd043783          	ld	a5,-48(s0)
    80017df2:	fef43023          	sd	a5,-32(s0)
    // uint32_t inode = minix3_get_inode_from_path(block_device, path, false);
    // infof("%s has inode %u\n", path, inode);
    

    minix3_traverse(block_device, 1, "/", &cb_data, 0, 10, minix3_init_callback);
    80017df6:	fe040693          	addi	a3,s0,-32
    80017dfa:	00000817          	auipc	a6,0x0
    80017dfe:	eb080813          	addi	a6,a6,-336 # 80017caa <minix3_init_callback>
    80017e02:	47a9                	li	a5,10
    80017e04:	4701                	li	a4,0
    80017e06:	00010617          	auipc	a2,0x10
    80017e0a:	f9260613          	addi	a2,a2,-110 # 80027d98 <pow10.0+0xf38>
    80017e0e:	4585                	li	a1,1
    80017e10:	fd843503          	ld	a0,-40(s0)
    80017e14:	5d7020ef          	jal	ra,8001abea <minix3_traverse>
    
    // infof("Files:\n");
    // CallbackData cb_data = {0};
    // minix3_traverse(block_device, 1, "/", &cb_data, 0, 10, callback);
    // infof("Found %u files and %u directories in /\n", cb_data.file_count, cb_data.dir_count);
}
    80017e18:	0001                	nop
    80017e1a:	60a6                	ld	ra,72(sp)
    80017e1c:	6406                	ld	s0,64(sp)
    80017e1e:	6161                	addi	sp,sp,80
    80017e20:	8082                	ret

0000000080017e22 <minix3_get_superblock>:

SuperBlock minix3_get_superblock(VirtioDevice *block_device) {
    80017e22:	1101                	addi	sp,sp,-32
    80017e24:	ec06                	sd	ra,24(sp)
    80017e26:	e822                	sd	s0,16(sp)
    80017e28:	1000                	addi	s0,sp,32
    80017e2a:	fea43423          	sd	a0,-24(s0)
    80017e2e:	feb43023          	sd	a1,-32(s0)
    // Get the superblock
    // SuperBlock superblock;
    // Superblock begins at bytes 1024
    if (sb.magic != MINIX3_MAGIC) {
    80017e32:	0000d797          	auipc	a5,0xd
    80017e36:	28e78793          	addi	a5,a5,654 # 800250c0 <sb>
    80017e3a:	0187d783          	lhu	a5,24(a5)
    80017e3e:	0007871b          	sext.w	a4,a5
    80017e42:	6795                	lui	a5,0x5
    80017e44:	d5a78793          	addi	a5,a5,-678 # 4d5a <i+0x4d3a>
    80017e48:	00f70e63          	beq	a4,a5,80017e64 <minix3_get_superblock+0x42>
        block_device_read_bytes(block_device, 1024, (uint8_t *)&sb, sizeof(SuperBlock));
    80017e4c:	02000693          	li	a3,32
    80017e50:	0000d617          	auipc	a2,0xd
    80017e54:	27060613          	addi	a2,a2,624 # 800250c0 <sb>
    80017e58:	40000593          	li	a1,1024
    80017e5c:	fe043503          	ld	a0,-32(s0)
    80017e60:	41f060ef          	jal	ra,8001ea7e <block_device_read_bytes>
    }
    return sb;
    80017e64:	fe843783          	ld	a5,-24(s0)
    80017e68:	0000d717          	auipc	a4,0xd
    80017e6c:	25870713          	addi	a4,a4,600 # 800250c0 <sb>
    80017e70:	00072303          	lw	t1,0(a4)
    80017e74:	00472883          	lw	a7,4(a4)
    80017e78:	00872803          	lw	a6,8(a4)
    80017e7c:	4748                	lw	a0,12(a4)
    80017e7e:	4b0c                	lw	a1,16(a4)
    80017e80:	4b50                	lw	a2,20(a4)
    80017e82:	4f14                	lw	a3,24(a4)
    80017e84:	4f58                	lw	a4,28(a4)
    80017e86:	0067a023          	sw	t1,0(a5)
    80017e8a:	0117a223          	sw	a7,4(a5)
    80017e8e:	0107a423          	sw	a6,8(a5)
    80017e92:	c7c8                	sw	a0,12(a5)
    80017e94:	cb8c                	sw	a1,16(a5)
    80017e96:	cbd0                	sw	a2,20(a5)
    80017e98:	cf94                	sw	a3,24(a5)
    80017e9a:	cfd8                	sw	a4,28(a5)
}
    80017e9c:	fe843503          	ld	a0,-24(s0)
    80017ea0:	60e2                	ld	ra,24(sp)
    80017ea2:	6442                	ld	s0,16(sp)
    80017ea4:	6105                	addi	sp,sp,32
    80017ea6:	8082                	ret

0000000080017ea8 <minix3_put_superblock>:

void minix3_put_superblock(VirtioDevice *block_device, SuperBlock superblock) {
    80017ea8:	1101                	addi	sp,sp,-32
    80017eaa:	ec06                	sd	ra,24(sp)
    80017eac:	e822                	sd	s0,16(sp)
    80017eae:	1000                	addi	s0,sp,32
    80017eb0:	fea43423          	sd	a0,-24(s0)
    80017eb4:	80ae                	mv	ra,a1
    // Put the superblock
    block_device_write_bytes(block_device, 1024, (uint8_t *)&superblock, sizeof(SuperBlock));
    80017eb6:	02000693          	li	a3,32
    80017eba:	8606                	mv	a2,ra
    80017ebc:	40000593          	li	a1,1024
    80017ec0:	fe843503          	ld	a0,-24(s0)
    80017ec4:	4bb060ef          	jal	ra,8001eb7e <block_device_write_bytes>
}
    80017ec8:	0001                	nop
    80017eca:	60e2                	ld	ra,24(sp)
    80017ecc:	6442                	ld	s0,16(sp)
    80017ece:	6105                	addi	sp,sp,32
    80017ed0:	8082                	ret

0000000080017ed2 <minix3_get_block_size>:


uint16_t minix3_get_block_size(VirtioDevice *block_device) {
    80017ed2:	7139                	addi	sp,sp,-64
    80017ed4:	fc06                	sd	ra,56(sp)
    80017ed6:	f822                	sd	s0,48(sp)
    80017ed8:	0080                	addi	s0,sp,64
    80017eda:	fca43423          	sd	a0,-56(s0)
    SuperBlock superblock = minix3_get_superblock(block_device);
    80017ede:	fd040793          	addi	a5,s0,-48
    80017ee2:	fc843583          	ld	a1,-56(s0)
    80017ee6:	853e                	mv	a0,a5
    80017ee8:	f3bff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    return 1024 << superblock.log_zone_size;
    80017eec:	fdc45783          	lhu	a5,-36(s0)
    80017ef0:	2781                	sext.w	a5,a5
    80017ef2:	40000713          	li	a4,1024
    80017ef6:	00f717bb          	sllw	a5,a4,a5
    80017efa:	2781                	sext.w	a5,a5
    80017efc:	17c2                	slli	a5,a5,0x30
    80017efe:	93c1                	srli	a5,a5,0x30
}
    80017f00:	853e                	mv	a0,a5
    80017f02:	70e2                	ld	ra,56(sp)
    80017f04:	7442                	ld	s0,48(sp)
    80017f06:	6121                	addi	sp,sp,64
    80017f08:	8082                	ret

0000000080017f0a <minix3_get_zone_size>:

uint16_t minix3_get_zone_size(VirtioDevice *block_device) {
    80017f0a:	1101                	addi	sp,sp,-32
    80017f0c:	ec06                	sd	ra,24(sp)
    80017f0e:	e822                	sd	s0,16(sp)
    80017f10:	1000                	addi	s0,sp,32
    80017f12:	fea43423          	sd	a0,-24(s0)
    return minix3_get_block_size(block_device);
    80017f16:	fe843503          	ld	a0,-24(s0)
    80017f1a:	fb9ff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    80017f1e:	87aa                	mv	a5,a0
}
    80017f20:	853e                	mv	a0,a5
    80017f22:	60e2                	ld	ra,24(sp)
    80017f24:	6442                	ld	s0,16(sp)
    80017f26:	6105                	addi	sp,sp,32
    80017f28:	8082                	ret

0000000080017f2a <minix3_sectors_per_block>:

uint16_t minix3_sectors_per_block(VirtioDevice *block_device) {
    80017f2a:	7179                	addi	sp,sp,-48
    80017f2c:	f406                	sd	ra,40(sp)
    80017f2e:	f022                	sd	s0,32(sp)
    80017f30:	ec26                	sd	s1,24(sp)
    80017f32:	1800                	addi	s0,sp,48
    80017f34:	fca43c23          	sd	a0,-40(s0)
    return minix3_get_block_size(block_device) / block_device_get_sector_size(block_device);
    80017f38:	fd843503          	ld	a0,-40(s0)
    80017f3c:	f97ff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    80017f40:	87aa                	mv	a5,a0
    80017f42:	84be                	mv	s1,a5
    80017f44:	fd843503          	ld	a0,-40(s0)
    80017f48:	7e4060ef          	jal	ra,8001e72c <block_device_get_sector_size>
    80017f4c:	87aa                	mv	a5,a0
    80017f4e:	02f4d7b3          	divu	a5,s1,a5
    80017f52:	17c2                	slli	a5,a5,0x30
    80017f54:	93c1                	srli	a5,a5,0x30
}
    80017f56:	853e                	mv	a0,a5
    80017f58:	70a2                	ld	ra,40(sp)
    80017f5a:	7402                	ld	s0,32(sp)
    80017f5c:	64e2                	ld	s1,24(sp)
    80017f5e:	6145                	addi	sp,sp,48
    80017f60:	8082                	ret

0000000080017f62 <minix3_get_inode_bitmap_size>:

size_t minix3_get_inode_bitmap_size(VirtioDevice *block_device) {
    80017f62:	715d                	addi	sp,sp,-80
    80017f64:	e486                	sd	ra,72(sp)
    80017f66:	e0a2                	sd	s0,64(sp)
    80017f68:	fc26                	sd	s1,56(sp)
    80017f6a:	0880                	addi	s0,sp,80
    80017f6c:	faa43c23          	sd	a0,-72(s0)
    return minix3_get_superblock(block_device).imap_blocks * minix3_get_block_size(block_device);
    80017f70:	fc040793          	addi	a5,s0,-64
    80017f74:	fb843583          	ld	a1,-72(s0)
    80017f78:	853e                	mv	a0,a5
    80017f7a:	ea9ff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    80017f7e:	fc645783          	lhu	a5,-58(s0)
    80017f82:	0007849b          	sext.w	s1,a5
    80017f86:	fb843503          	ld	a0,-72(s0)
    80017f8a:	f49ff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    80017f8e:	87aa                	mv	a5,a0
    80017f90:	2781                	sext.w	a5,a5
    80017f92:	02f487bb          	mulw	a5,s1,a5
    80017f96:	2781                	sext.w	a5,a5
}
    80017f98:	853e                	mv	a0,a5
    80017f9a:	60a6                	ld	ra,72(sp)
    80017f9c:	6406                	ld	s0,64(sp)
    80017f9e:	74e2                	ld	s1,56(sp)
    80017fa0:	6161                	addi	sp,sp,80
    80017fa2:	8082                	ret

0000000080017fa4 <minix3_get_zone_bitmap_size>:

size_t minix3_get_zone_bitmap_size(VirtioDevice *block_device) {
    80017fa4:	715d                	addi	sp,sp,-80
    80017fa6:	e486                	sd	ra,72(sp)
    80017fa8:	e0a2                	sd	s0,64(sp)
    80017faa:	fc26                	sd	s1,56(sp)
    80017fac:	0880                	addi	s0,sp,80
    80017fae:	faa43c23          	sd	a0,-72(s0)
    return minix3_get_superblock(block_device).zmap_blocks * minix3_get_block_size(block_device);
    80017fb2:	fc040793          	addi	a5,s0,-64
    80017fb6:	fb843583          	ld	a1,-72(s0)
    80017fba:	853e                	mv	a0,a5
    80017fbc:	e67ff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    80017fc0:	fc845783          	lhu	a5,-56(s0)
    80017fc4:	0007849b          	sext.w	s1,a5
    80017fc8:	fb843503          	ld	a0,-72(s0)
    80017fcc:	f07ff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    80017fd0:	87aa                	mv	a5,a0
    80017fd2:	2781                	sext.w	a5,a5
    80017fd4:	02f487bb          	mulw	a5,s1,a5
    80017fd8:	2781                	sext.w	a5,a5
}
    80017fda:	853e                	mv	a0,a5
    80017fdc:	60a6                	ld	ra,72(sp)
    80017fde:	6406                	ld	s0,64(sp)
    80017fe0:	74e2                	ld	s1,56(sp)
    80017fe2:	6161                	addi	sp,sp,80
    80017fe4:	8082                	ret

0000000080017fe6 <minix3_get_inode_bitmap>:

// Read the inode bitmap into the given buffer
void minix3_get_inode_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    80017fe6:	7139                	addi	sp,sp,-64
    80017fe8:	fc06                	sd	ra,56(sp)
    80017fea:	f822                	sd	s0,48(sp)
    80017fec:	0080                	addi	s0,sp,64
    80017fee:	fca43423          	sd	a0,-56(s0)
    80017ff2:	fcb43023          	sd	a1,-64(s0)
    debugf("Getting inode bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    80017ff6:	fd040793          	addi	a5,s0,-48
    80017ffa:	fc843583          	ld	a1,-56(s0)
    80017ffe:	853e                	mv	a0,a5
    80018000:	e23ff0ef          	jal	ra,80017e22 <minix3_get_superblock>

    minix3_get_blocks(block_device, FS_IMAP_IDX, bitmap_buf, sb.imap_blocks);
    80018004:	fd645783          	lhu	a5,-42(s0)
    80018008:	86be                	mv	a3,a5
    8001800a:	fc043603          	ld	a2,-64(s0)
    8001800e:	4589                	li	a1,2
    80018010:	fc843503          	ld	a0,-56(s0)
    80018014:	1b4000ef          	jal	ra,800181c8 <minix3_get_blocks>
    // debugf("About to read inode byte at %u (%x)...\n", byte_offset, byte_offset);
    // block_device_read_bytes(byte_offset, &inode_byte, 1);
    // debugf("Inode byte: %x\n", inode_byte);
    // return inode_byte & (1 << inode % 8);
    // block_device_read_bytes(FS_IMAP_IDX * minix3_get_block_size(block_device), bitmap_buf, minix3_get_block_size(block_device) * sb.imap_blocks);
}
    80018018:	0001                	nop
    8001801a:	70e2                	ld	ra,56(sp)
    8001801c:	7442                	ld	s0,48(sp)
    8001801e:	6121                	addi	sp,sp,64
    80018020:	8082                	ret

0000000080018022 <minix3_put_inode_bitmap>:
// Write the inode bitmap from the given buffer
void minix3_put_inode_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    80018022:	7139                	addi	sp,sp,-64
    80018024:	fc06                	sd	ra,56(sp)
    80018026:	f822                	sd	s0,48(sp)
    80018028:	0080                	addi	s0,sp,64
    8001802a:	fca43423          	sd	a0,-56(s0)
    8001802e:	fcb43023          	sd	a1,-64(s0)
    debugf("Setting inode bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    80018032:	fd040793          	addi	a5,s0,-48
    80018036:	fc843583          	ld	a1,-56(s0)
    8001803a:	853e                	mv	a0,a5
    8001803c:	de7ff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    minix3_put_blocks(block_device, FS_IMAP_IDX, bitmap_buf, sb.imap_blocks);
    80018040:	fd645783          	lhu	a5,-42(s0)
    80018044:	86be                	mv	a3,a5
    80018046:	fc043603          	ld	a2,-64(s0)
    8001804a:	4589                	li	a1,2
    8001804c:	fc843503          	ld	a0,-56(s0)
    80018050:	1ea000ef          	jal	ra,8001823a <minix3_put_blocks>
    // block_device_write_bytes(FS_IMAP_IDX * minix3_get_block_size(block_device), bitmap_buf, minix3_get_block_size(block_device) * sb.imap_blocks);
}
    80018054:	0001                	nop
    80018056:	70e2                	ld	ra,56(sp)
    80018058:	7442                	ld	s0,48(sp)
    8001805a:	6121                	addi	sp,sp,64
    8001805c:	8082                	ret

000000008001805e <minix3_get_zone_bitmap>:
// Read the zone bitmap into the given buffer
void minix3_get_zone_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    8001805e:	7139                	addi	sp,sp,-64
    80018060:	fc06                	sd	ra,56(sp)
    80018062:	f822                	sd	s0,48(sp)
    80018064:	0080                	addi	s0,sp,64
    80018066:	fca43423          	sd	a0,-56(s0)
    8001806a:	fcb43023          	sd	a1,-64(s0)
    debugf("Getting zone bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    8001806e:	fd040793          	addi	a5,s0,-48
    80018072:	fc843583          	ld	a1,-56(s0)
    80018076:	853e                	mv	a0,a5
    80018078:	dabff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    minix3_get_blocks(block_device, FS_IMAP_IDX + sb.imap_blocks, bitmap_buf, sb.zmap_blocks);
    8001807c:	fd645783          	lhu	a5,-42(s0)
    80018080:	2781                	sext.w	a5,a5
    80018082:	2789                	addiw	a5,a5,2
    80018084:	2781                	sext.w	a5,a5
    80018086:	2781                	sext.w	a5,a5
    80018088:	fd845703          	lhu	a4,-40(s0)
    8001808c:	86ba                	mv	a3,a4
    8001808e:	fc043603          	ld	a2,-64(s0)
    80018092:	85be                	mv	a1,a5
    80018094:	fc843503          	ld	a0,-56(s0)
    80018098:	130000ef          	jal	ra,800181c8 <minix3_get_blocks>
    // block_device_read_bytes((FS_IMAP_IDX + sb.imap_blocks) * minix3_get_block_size(block_device), bitmap_buf, minix3_get_block_size(block_device) * sb.zmap_blocks);
}
    8001809c:	0001                	nop
    8001809e:	70e2                	ld	ra,56(sp)
    800180a0:	7442                	ld	s0,48(sp)
    800180a2:	6121                	addi	sp,sp,64
    800180a4:	8082                	ret

00000000800180a6 <minix3_put_zone_bitmap>:
// Write the zone bitmap from the given buffer
void minix3_put_zone_bitmap(VirtioDevice *block_device, uint8_t *bitmap_buf) {
    800180a6:	7139                	addi	sp,sp,-64
    800180a8:	fc06                	sd	ra,56(sp)
    800180aa:	f822                	sd	s0,48(sp)
    800180ac:	0080                	addi	s0,sp,64
    800180ae:	fca43423          	sd	a0,-56(s0)
    800180b2:	fcb43023          	sd	a1,-64(s0)
    debugf("Setting zone bitmap...\n");
    SuperBlock sb = minix3_get_superblock(block_device);
    800180b6:	fd040793          	addi	a5,s0,-48
    800180ba:	fc843583          	ld	a1,-56(s0)
    800180be:	853e                	mv	a0,a5
    800180c0:	d63ff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    minix3_put_blocks(block_device, FS_IMAP_IDX + sb.imap_blocks, bitmap_buf, sb.zmap_blocks);
    800180c4:	fd645783          	lhu	a5,-42(s0)
    800180c8:	2781                	sext.w	a5,a5
    800180ca:	2789                	addiw	a5,a5,2
    800180cc:	2781                	sext.w	a5,a5
    800180ce:	2781                	sext.w	a5,a5
    800180d0:	fd845703          	lhu	a4,-40(s0)
    800180d4:	86ba                	mv	a3,a4
    800180d6:	fc043603          	ld	a2,-64(s0)
    800180da:	85be                	mv	a1,a5
    800180dc:	fc843503          	ld	a0,-56(s0)
    800180e0:	15a000ef          	jal	ra,8001823a <minix3_put_blocks>
}
    800180e4:	0001                	nop
    800180e6:	70e2                	ld	ra,56(sp)
    800180e8:	7442                	ld	s0,48(sp)
    800180ea:	6121                	addi	sp,sp,64
    800180ec:	8082                	ret

00000000800180ee <minix3_load_device>:

void minix3_load_device(VirtioDevice *block_device) {
    800180ee:	1101                	addi	sp,sp,-32
    800180f0:	ec06                	sd	ra,24(sp)
    800180f2:	e822                	sd	s0,16(sp)
    800180f4:	1000                	addi	s0,sp,32
    800180f6:	fea43423          	sd	a0,-24(s0)
    if (loaded_block_device == block_device) {
    800180fa:	0000d797          	auipc	a5,0xd
    800180fe:	fe678793          	addi	a5,a5,-26 # 800250e0 <loaded_block_device>
    80018102:	639c                	ld	a5,0(a5)
    80018104:	fe843703          	ld	a4,-24(s0)
    80018108:	0af70b63          	beq	a4,a5,800181be <minix3_load_device+0xd0>
        return;
    } else {
        loaded_block_device = block_device;
    8001810c:	0000d797          	auipc	a5,0xd
    80018110:	fd478793          	addi	a5,a5,-44 # 800250e0 <loaded_block_device>
    80018114:	fe843703          	ld	a4,-24(s0)
    80018118:	e398                	sd	a4,0(a5)
    }

    if (inode_bitmap && zone_bitmap) {
    8001811a:	0000d797          	auipc	a5,0xd
    8001811e:	fce78793          	addi	a5,a5,-50 # 800250e8 <inode_bitmap>
    80018122:	639c                	ld	a5,0(a5)
    80018124:	cf85                	beqz	a5,8001815c <minix3_load_device+0x6e>
    80018126:	0000d797          	auipc	a5,0xd
    8001812a:	fca78793          	addi	a5,a5,-54 # 800250f0 <zone_bitmap>
    8001812e:	639c                	ld	a5,0(a5)
    80018130:	c795                	beqz	a5,8001815c <minix3_load_device+0x6e>
        minix3_get_inode_bitmap(block_device, inode_bitmap);
    80018132:	0000d797          	auipc	a5,0xd
    80018136:	fb678793          	addi	a5,a5,-74 # 800250e8 <inode_bitmap>
    8001813a:	639c                	ld	a5,0(a5)
    8001813c:	85be                	mv	a1,a5
    8001813e:	fe843503          	ld	a0,-24(s0)
    80018142:	ea5ff0ef          	jal	ra,80017fe6 <minix3_get_inode_bitmap>
        minix3_get_zone_bitmap(block_device, zone_bitmap);
    80018146:	0000d797          	auipc	a5,0xd
    8001814a:	faa78793          	addi	a5,a5,-86 # 800250f0 <zone_bitmap>
    8001814e:	639c                	ld	a5,0(a5)
    80018150:	85be                	mv	a1,a5
    80018152:	fe843503          	ld	a0,-24(s0)
    80018156:	f09ff0ef          	jal	ra,8001805e <minix3_get_zone_bitmap>
    8001815a:	a09d                	j	800181c0 <minix3_load_device+0xd2>
    } else {
        inode_bitmap = (uint8_t *)kmalloc(minix3_get_inode_bitmap_size(block_device));
    8001815c:	fe843503          	ld	a0,-24(s0)
    80018160:	e03ff0ef          	jal	ra,80017f62 <minix3_get_inode_bitmap_size>
    80018164:	87aa                	mv	a5,a0
    80018166:	853e                	mv	a0,a5
    80018168:	bcafd0ef          	jal	ra,80015532 <kmalloc>
    8001816c:	872a                	mv	a4,a0
    8001816e:	0000d797          	auipc	a5,0xd
    80018172:	f7a78793          	addi	a5,a5,-134 # 800250e8 <inode_bitmap>
    80018176:	e398                	sd	a4,0(a5)
        zone_bitmap = (uint8_t *)kmalloc(minix3_get_zone_bitmap_size(block_device));
    80018178:	fe843503          	ld	a0,-24(s0)
    8001817c:	e29ff0ef          	jal	ra,80017fa4 <minix3_get_zone_bitmap_size>
    80018180:	87aa                	mv	a5,a0
    80018182:	853e                	mv	a0,a5
    80018184:	baefd0ef          	jal	ra,80015532 <kmalloc>
    80018188:	872a                	mv	a4,a0
    8001818a:	0000d797          	auipc	a5,0xd
    8001818e:	f6678793          	addi	a5,a5,-154 # 800250f0 <zone_bitmap>
    80018192:	e398                	sd	a4,0(a5)
        minix3_get_inode_bitmap(block_device, inode_bitmap);
    80018194:	0000d797          	auipc	a5,0xd
    80018198:	f5478793          	addi	a5,a5,-172 # 800250e8 <inode_bitmap>
    8001819c:	639c                	ld	a5,0(a5)
    8001819e:	85be                	mv	a1,a5
    800181a0:	fe843503          	ld	a0,-24(s0)
    800181a4:	e43ff0ef          	jal	ra,80017fe6 <minix3_get_inode_bitmap>
        minix3_get_zone_bitmap(block_device, zone_bitmap);
    800181a8:	0000d797          	auipc	a5,0xd
    800181ac:	f4878793          	addi	a5,a5,-184 # 800250f0 <zone_bitmap>
    800181b0:	639c                	ld	a5,0(a5)
    800181b2:	85be                	mv	a1,a5
    800181b4:	fe843503          	ld	a0,-24(s0)
    800181b8:	ea7ff0ef          	jal	ra,8001805e <minix3_get_zone_bitmap>
    800181bc:	a011                	j	800181c0 <minix3_load_device+0xd2>
        return;
    800181be:	0001                	nop
    }
}
    800181c0:	60e2                	ld	ra,24(sp)
    800181c2:	6442                	ld	s0,16(sp)
    800181c4:	6105                	addi	sp,sp,32
    800181c6:	8082                	ret

00000000800181c8 <minix3_get_blocks>:

void minix3_get_blocks(VirtioDevice *block_device, uint32_t start_block, uint8_t *data, uint16_t count) {
    800181c8:	7139                	addi	sp,sp,-64
    800181ca:	fc06                	sd	ra,56(sp)
    800181cc:	f822                	sd	s0,48(sp)
    800181ce:	f426                	sd	s1,40(sp)
    800181d0:	0080                	addi	s0,sp,64
    800181d2:	fca43c23          	sd	a0,-40(s0)
    800181d6:	87ae                	mv	a5,a1
    800181d8:	fcc43423          	sd	a2,-56(s0)
    800181dc:	8736                	mv	a4,a3
    800181de:	fcf42a23          	sw	a5,-44(s0)
    800181e2:	87ba                	mv	a5,a4
    800181e4:	fcf41923          	sh	a5,-46(s0)
    // SuperBlock sb = minix3_get_superblock();
    block_device_read_bytes(block_device, start_block * minix3_get_block_size(block_device), data, minix3_get_block_size(block_device) * count);
    800181e8:	fd843503          	ld	a0,-40(s0)
    800181ec:	ce7ff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    800181f0:	87aa                	mv	a5,a0
    800181f2:	2781                	sext.w	a5,a5
    800181f4:	fd442703          	lw	a4,-44(s0)
    800181f8:	02f707bb          	mulw	a5,a4,a5
    800181fc:	2781                	sext.w	a5,a5
    800181fe:	02079493          	slli	s1,a5,0x20
    80018202:	9081                	srli	s1,s1,0x20
    80018204:	fd843503          	ld	a0,-40(s0)
    80018208:	ccbff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    8001820c:	87aa                	mv	a5,a0
    8001820e:	0007871b          	sext.w	a4,a5
    80018212:	fd245783          	lhu	a5,-46(s0)
    80018216:	2781                	sext.w	a5,a5
    80018218:	02f707bb          	mulw	a5,a4,a5
    8001821c:	2781                	sext.w	a5,a5
    8001821e:	86be                	mv	a3,a5
    80018220:	fc843603          	ld	a2,-56(s0)
    80018224:	85a6                	mv	a1,s1
    80018226:	fd843503          	ld	a0,-40(s0)
    8001822a:	055060ef          	jal	ra,8001ea7e <block_device_read_bytes>
}
    8001822e:	0001                	nop
    80018230:	70e2                	ld	ra,56(sp)
    80018232:	7442                	ld	s0,48(sp)
    80018234:	74a2                	ld	s1,40(sp)
    80018236:	6121                	addi	sp,sp,64
    80018238:	8082                	ret

000000008001823a <minix3_put_blocks>:
void minix3_put_blocks(VirtioDevice *block_device, uint32_t start_block, uint8_t *data, uint16_t count) {
    8001823a:	7139                	addi	sp,sp,-64
    8001823c:	fc06                	sd	ra,56(sp)
    8001823e:	f822                	sd	s0,48(sp)
    80018240:	f426                	sd	s1,40(sp)
    80018242:	0080                	addi	s0,sp,64
    80018244:	fca43c23          	sd	a0,-40(s0)
    80018248:	87ae                	mv	a5,a1
    8001824a:	fcc43423          	sd	a2,-56(s0)
    8001824e:	8736                	mv	a4,a3
    80018250:	fcf42a23          	sw	a5,-44(s0)
    80018254:	87ba                	mv	a5,a4
    80018256:	fcf41923          	sh	a5,-46(s0)
    // SuperBlock sb = minix3_get_superblock();
    block_device_write_bytes(block_device, start_block * minix3_get_block_size(block_device), data, minix3_get_block_size(block_device) * count);
    8001825a:	fd843503          	ld	a0,-40(s0)
    8001825e:	c75ff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    80018262:	87aa                	mv	a5,a0
    80018264:	2781                	sext.w	a5,a5
    80018266:	fd442703          	lw	a4,-44(s0)
    8001826a:	02f707bb          	mulw	a5,a4,a5
    8001826e:	2781                	sext.w	a5,a5
    80018270:	02079493          	slli	s1,a5,0x20
    80018274:	9081                	srli	s1,s1,0x20
    80018276:	fd843503          	ld	a0,-40(s0)
    8001827a:	c59ff0ef          	jal	ra,80017ed2 <minix3_get_block_size>
    8001827e:	87aa                	mv	a5,a0
    80018280:	0007871b          	sext.w	a4,a5
    80018284:	fd245783          	lhu	a5,-46(s0)
    80018288:	2781                	sext.w	a5,a5
    8001828a:	02f707bb          	mulw	a5,a4,a5
    8001828e:	2781                	sext.w	a5,a5
    80018290:	86be                	mv	a3,a5
    80018292:	fc843603          	ld	a2,-56(s0)
    80018296:	85a6                	mv	a1,s1
    80018298:	fd843503          	ld	a0,-40(s0)
    8001829c:	0e3060ef          	jal	ra,8001eb7e <block_device_write_bytes>
}
    800182a0:	0001                	nop
    800182a2:	70e2                	ld	ra,56(sp)
    800182a4:	7442                	ld	s0,48(sp)
    800182a6:	74a2                	ld	s1,40(sp)
    800182a8:	6121                	addi	sp,sp,64
    800182aa:	8082                	ret

00000000800182ac <minix3_get_block>:

void minix3_get_block(VirtioDevice *block_device, uint32_t block, uint8_t *data) {
    800182ac:	7179                	addi	sp,sp,-48
    800182ae:	f406                	sd	ra,40(sp)
    800182b0:	f022                	sd	s0,32(sp)
    800182b2:	1800                	addi	s0,sp,48
    800182b4:	fea43423          	sd	a0,-24(s0)
    800182b8:	87ae                	mv	a5,a1
    800182ba:	fcc43c23          	sd	a2,-40(s0)
    800182be:	fef42223          	sw	a5,-28(s0)
    minix3_get_blocks(block_device, block, data, 1);
    800182c2:	fe442783          	lw	a5,-28(s0)
    800182c6:	4685                	li	a3,1
    800182c8:	fd843603          	ld	a2,-40(s0)
    800182cc:	85be                	mv	a1,a5
    800182ce:	fe843503          	ld	a0,-24(s0)
    800182d2:	ef7ff0ef          	jal	ra,800181c8 <minix3_get_blocks>
}
    800182d6:	0001                	nop
    800182d8:	70a2                	ld	ra,40(sp)
    800182da:	7402                	ld	s0,32(sp)
    800182dc:	6145                	addi	sp,sp,48
    800182de:	8082                	ret

00000000800182e0 <minix3_put_block>:

void minix3_put_block(VirtioDevice *block_device, uint32_t block, uint8_t *data) {
    800182e0:	7179                	addi	sp,sp,-48
    800182e2:	f406                	sd	ra,40(sp)
    800182e4:	f022                	sd	s0,32(sp)
    800182e6:	1800                	addi	s0,sp,48
    800182e8:	fea43423          	sd	a0,-24(s0)
    800182ec:	87ae                	mv	a5,a1
    800182ee:	fcc43c23          	sd	a2,-40(s0)
    800182f2:	fef42223          	sw	a5,-28(s0)
    minix3_put_blocks(block_device, block, data, 1);
    800182f6:	fe442783          	lw	a5,-28(s0)
    800182fa:	4685                	li	a3,1
    800182fc:	fd843603          	ld	a2,-40(s0)
    80018300:	85be                	mv	a1,a5
    80018302:	fe843503          	ld	a0,-24(s0)
    80018306:	f35ff0ef          	jal	ra,8001823a <minix3_put_blocks>
}
    8001830a:	0001                	nop
    8001830c:	70a2                	ld	ra,40(sp)
    8001830e:	7402                	ld	s0,32(sp)
    80018310:	6145                	addi	sp,sp,48
    80018312:	8082                	ret

0000000080018314 <minix3_has_inode>:

bool minix3_has_inode(VirtioDevice *block_device, uint32_t inode) {
    80018314:	1101                	addi	sp,sp,-32
    80018316:	ec06                	sd	ra,24(sp)
    80018318:	e822                	sd	s0,16(sp)
    8001831a:	1000                	addi	s0,sp,32
    8001831c:	fea43423          	sd	a0,-24(s0)
    80018320:	87ae                	mv	a5,a1
    80018322:	fef42223          	sw	a5,-28(s0)
    minix3_load_device(block_device);
    80018326:	fe843503          	ld	a0,-24(s0)
    8001832a:	dc5ff0ef          	jal	ra,800180ee <minix3_load_device>

    if (inode == INVALID_INODE) {
    8001832e:	fe442783          	lw	a5,-28(s0)
    80018332:	2781                	sext.w	a5,a5
    80018334:	e399                	bnez	a5,8001833a <minix3_has_inode+0x26>
        debugf("minix3_has_inode: Invalid inode %u\n", inode);
        return false;
    80018336:	4781                	li	a5,0
    80018338:	a081                	j	80018378 <minix3_has_inode+0x64>
    }
    return inode_bitmap[inode / 8] & (1 << inode % 8);
    8001833a:	0000d797          	auipc	a5,0xd
    8001833e:	dae78793          	addi	a5,a5,-594 # 800250e8 <inode_bitmap>
    80018342:	6398                	ld	a4,0(a5)
    80018344:	fe442783          	lw	a5,-28(s0)
    80018348:	0037d79b          	srliw	a5,a5,0x3
    8001834c:	2781                	sext.w	a5,a5
    8001834e:	1782                	slli	a5,a5,0x20
    80018350:	9381                	srli	a5,a5,0x20
    80018352:	97ba                	add	a5,a5,a4
    80018354:	0007c783          	lbu	a5,0(a5)
    80018358:	0007871b          	sext.w	a4,a5
    8001835c:	fe442783          	lw	a5,-28(s0)
    80018360:	8b9d                	andi	a5,a5,7
    80018362:	2781                	sext.w	a5,a5
    80018364:	4685                	li	a3,1
    80018366:	00f697bb          	sllw	a5,a3,a5
    8001836a:	2781                	sext.w	a5,a5
    8001836c:	8ff9                	and	a5,a5,a4
    8001836e:	2781                	sext.w	a5,a5
    80018370:	00f037b3          	snez	a5,a5
    80018374:	0ff7f793          	andi	a5,a5,255
}
    80018378:	853e                	mv	a0,a5
    8001837a:	60e2                	ld	ra,24(sp)
    8001837c:	6442                	ld	s0,16(sp)
    8001837e:	6105                	addi	sp,sp,32
    80018380:	8082                	ret

0000000080018382 <minix3_take_inode>:

// Mark the inode taken in the inode map.
bool minix3_take_inode(VirtioDevice *block_device, uint32_t inode) {
    80018382:	7135                	addi	sp,sp,-160
    80018384:	ed06                	sd	ra,152(sp)
    80018386:	e922                	sd	s0,144(sp)
    80018388:	1100                	addi	s0,sp,160
    8001838a:	faa43423          	sd	a0,-88(s0)
    8001838e:	87ae                	mv	a5,a1
    80018390:	faf42223          	sw	a5,-92(s0)
    minix3_load_device(block_device);
    80018394:	fa843503          	ld	a0,-88(s0)
    80018398:	d57ff0ef          	jal	ra,800180ee <minix3_load_device>
    if (inode == INVALID_INODE) {
    8001839c:	fa442783          	lw	a5,-92(s0)
    800183a0:	2781                	sext.w	a5,a5
    800183a2:	e399                	bnez	a5,800183a8 <minix3_take_inode+0x26>
        debugf("minix3_has_inode: Invalid inode %u\n", inode);
        return false;
    800183a4:	4781                	li	a5,0
    800183a6:	aa11                	j	800184ba <minix3_take_inode+0x138>
    }
    if (minix3_has_inode(block_device, inode)) {
    800183a8:	fa442783          	lw	a5,-92(s0)
    800183ac:	85be                	mv	a1,a5
    800183ae:	fa843503          	ld	a0,-88(s0)
    800183b2:	f63ff0ef          	jal	ra,80018314 <minix3_has_inode>
    800183b6:	87aa                	mv	a5,a0
    800183b8:	cf81                	beqz	a5,800183d0 <minix3_take_inode+0x4e>
        warnf("minix3_take_inode: Inode %u is already taken\n", inode);
    800183ba:	fa442783          	lw	a5,-92(s0)
    800183be:	85be                	mv	a1,a5
    800183c0:	00010517          	auipc	a0,0x10
    800183c4:	b4850513          	addi	a0,a0,-1208 # 80027f08 <pow10.0+0x10a8>
    800183c8:	271030ef          	jal	ra,8001be38 <warnf>
        return false;
    800183cc:	4781                	li	a5,0
    800183ce:	a0f5                	j	800184ba <minix3_take_inode+0x138>
    }

    inode_bitmap[inode / 8] |= (1 << inode % 8);
    800183d0:	0000d797          	auipc	a5,0xd
    800183d4:	d1878793          	addi	a5,a5,-744 # 800250e8 <inode_bitmap>
    800183d8:	6398                	ld	a4,0(a5)
    800183da:	fa442783          	lw	a5,-92(s0)
    800183de:	0037d79b          	srliw	a5,a5,0x3
    800183e2:	0007861b          	sext.w	a2,a5
    800183e6:	02061793          	slli	a5,a2,0x20
    800183ea:	9381                	srli	a5,a5,0x20
    800183ec:	97ba                	add	a5,a5,a4
    800183ee:	0007c783          	lbu	a5,0(a5)
    800183f2:	0187971b          	slliw	a4,a5,0x18
    800183f6:	4187571b          	sraiw	a4,a4,0x18
    800183fa:	fa442783          	lw	a5,-92(s0)
    800183fe:	8b9d                	andi	a5,a5,7
    80018400:	2781                	sext.w	a5,a5
    80018402:	4685                	li	a3,1
    80018404:	00f697bb          	sllw	a5,a3,a5
    80018408:	2781                	sext.w	a5,a5
    8001840a:	0187979b          	slliw	a5,a5,0x18
    8001840e:	4187d79b          	sraiw	a5,a5,0x18
    80018412:	8fd9                	or	a5,a5,a4
    80018414:	0187969b          	slliw	a3,a5,0x18
    80018418:	4186d69b          	sraiw	a3,a3,0x18
    8001841c:	0000d797          	auipc	a5,0xd
    80018420:	ccc78793          	addi	a5,a5,-820 # 800250e8 <inode_bitmap>
    80018424:	6398                	ld	a4,0(a5)
    80018426:	02061793          	slli	a5,a2,0x20
    8001842a:	9381                	srli	a5,a5,0x20
    8001842c:	97ba                	add	a5,a5,a4
    8001842e:	0ff6f713          	andi	a4,a3,255
    80018432:	00e78023          	sb	a4,0(a5)
    minix3_put_inode_bitmap(block_device, inode_bitmap);
    80018436:	0000d797          	auipc	a5,0xd
    8001843a:	cb278793          	addi	a5,a5,-846 # 800250e8 <inode_bitmap>
    8001843e:	639c                	ld	a5,0(a5)
    80018440:	85be                	mv	a1,a5
    80018442:	fa843503          	ld	a0,-88(s0)
    80018446:	bddff0ef          	jal	ra,80018022 <minix3_put_inode_bitmap>
    Inode inode_data = minix3_get_inode(block_device, inode);
    8001844a:	fb040793          	addi	a5,s0,-80
    8001844e:	fa442703          	lw	a4,-92(s0)
    80018452:	863a                	mv	a2,a4
    80018454:	fa843583          	ld	a1,-88(s0)
    80018458:	853e                	mv	a0,a5
    8001845a:	130000ef          	jal	ra,8001858a <minix3_get_inode>
    inode_data.num_links = 1;
    8001845e:	4785                	li	a5,1
    80018460:	faf41923          	sh	a5,-78(s0)
    minix3_put_inode(block_device, inode, inode_data);
    80018464:	fb043883          	ld	a7,-80(s0)
    80018468:	fb843803          	ld	a6,-72(s0)
    8001846c:	fc043503          	ld	a0,-64(s0)
    80018470:	fc843583          	ld	a1,-56(s0)
    80018474:	fd043603          	ld	a2,-48(s0)
    80018478:	fd843683          	ld	a3,-40(s0)
    8001847c:	fe043703          	ld	a4,-32(s0)
    80018480:	fe843783          	ld	a5,-24(s0)
    80018484:	f7143023          	sd	a7,-160(s0)
    80018488:	f7043423          	sd	a6,-152(s0)
    8001848c:	f6a43823          	sd	a0,-144(s0)
    80018490:	f6b43c23          	sd	a1,-136(s0)
    80018494:	f8c43023          	sd	a2,-128(s0)
    80018498:	f8d43423          	sd	a3,-120(s0)
    8001849c:	f8e43823          	sd	a4,-112(s0)
    800184a0:	f8f43c23          	sd	a5,-104(s0)
    800184a4:	f6040713          	addi	a4,s0,-160
    800184a8:	fa442783          	lw	a5,-92(s0)
    800184ac:	863a                	mv	a2,a4
    800184ae:	85be                	mv	a1,a5
    800184b0:	fa843503          	ld	a0,-88(s0)
    800184b4:	222000ef          	jal	ra,800186d6 <minix3_put_inode>

    return true;
    800184b8:	4785                	li	a5,1
}
    800184ba:	853e                	mv	a0,a5
    800184bc:	60ea                	ld	ra,152(sp)
    800184be:	644a                	ld	s0,144(sp)
    800184c0:	610d                	addi	sp,sp,160
    800184c2:	8082                	ret

00000000800184c4 <minix3_get_next_free_inode>:

uint32_t minix3_get_next_free_inode(VirtioDevice *block_device) {
    800184c4:	7139                	addi	sp,sp,-64
    800184c6:	fc06                	sd	ra,56(sp)
    800184c8:	f822                	sd	s0,48(sp)
    800184ca:	0080                	addi	s0,sp,64
    800184cc:	fca43423          	sd	a0,-56(s0)
    debugf("Getting next free inode...\n");
    minix3_load_device(block_device);
    800184d0:	fc843503          	ld	a0,-56(s0)
    800184d4:	c1bff0ef          	jal	ra,800180ee <minix3_load_device>
    size_t inode_bitmap_size = minix3_get_inode_bitmap_size(block_device);
    800184d8:	fc843503          	ld	a0,-56(s0)
    800184dc:	a87ff0ef          	jal	ra,80017f62 <minix3_get_inode_bitmap_size>
    800184e0:	fca43c23          	sd	a0,-40(s0)

    for (size_t i = 0; i < inode_bitmap_size; i++) {
    800184e4:	fe043423          	sd	zero,-24(s0)
    800184e8:	a8bd                	j	80018566 <minix3_get_next_free_inode+0xa2>
        if (inode_bitmap[i] != 0xFF) {
    800184ea:	0000d797          	auipc	a5,0xd
    800184ee:	bfe78793          	addi	a5,a5,-1026 # 800250e8 <inode_bitmap>
    800184f2:	6398                	ld	a4,0(a5)
    800184f4:	fe843783          	ld	a5,-24(s0)
    800184f8:	97ba                	add	a5,a5,a4
    800184fa:	0007c783          	lbu	a5,0(a5)
    800184fe:	873e                	mv	a4,a5
    80018500:	0ff00793          	li	a5,255
    80018504:	04f70c63          	beq	a4,a5,8001855c <minix3_get_next_free_inode+0x98>
            for (size_t j = 0; j < 8; j++) {
    80018508:	fe043023          	sd	zero,-32(s0)
    8001850c:	a099                	j	80018552 <minix3_get_next_free_inode+0x8e>
                uint32_t inode = 8 * i + j;
    8001850e:	fe843783          	ld	a5,-24(s0)
    80018512:	2781                	sext.w	a5,a5
    80018514:	0037979b          	slliw	a5,a5,0x3
    80018518:	0007871b          	sext.w	a4,a5
    8001851c:	fe043783          	ld	a5,-32(s0)
    80018520:	2781                	sext.w	a5,a5
    80018522:	9fb9                	addw	a5,a5,a4
    80018524:	fcf42a23          	sw	a5,-44(s0)
                if (!minix3_has_inode(block_device, inode)) {
    80018528:	fd442783          	lw	a5,-44(s0)
    8001852c:	85be                	mv	a1,a5
    8001852e:	fc843503          	ld	a0,-56(s0)
    80018532:	de3ff0ef          	jal	ra,80018314 <minix3_has_inode>
    80018536:	87aa                	mv	a5,a0
    80018538:	0017c793          	xori	a5,a5,1
    8001853c:	0ff7f793          	andi	a5,a5,255
    80018540:	c781                	beqz	a5,80018548 <minix3_get_next_free_inode+0x84>
                    return inode;
    80018542:	fd442783          	lw	a5,-44(s0)
    80018546:	a82d                	j	80018580 <minix3_get_next_free_inode+0xbc>
            for (size_t j = 0; j < 8; j++) {
    80018548:	fe043783          	ld	a5,-32(s0)
    8001854c:	0785                	addi	a5,a5,1
    8001854e:	fef43023          	sd	a5,-32(s0)
    80018552:	fe043703          	ld	a4,-32(s0)
    80018556:	479d                	li	a5,7
    80018558:	fae7fbe3          	bgeu	a5,a4,8001850e <minix3_get_next_free_inode+0x4a>
    for (size_t i = 0; i < inode_bitmap_size; i++) {
    8001855c:	fe843783          	ld	a5,-24(s0)
    80018560:	0785                	addi	a5,a5,1
    80018562:	fef43423          	sd	a5,-24(s0)
    80018566:	fe843703          	ld	a4,-24(s0)
    8001856a:	fd843783          	ld	a5,-40(s0)
    8001856e:	f6f76ee3          	bltu	a4,a5,800184ea <minix3_get_next_free_inode+0x26>
                }
            }
        }
    }

    warnf("minix3_get_next_free_inode: Couldn't find free inode\n");
    80018572:	00010517          	auipc	a0,0x10
    80018576:	9c650513          	addi	a0,a0,-1594 # 80027f38 <pow10.0+0x10d8>
    8001857a:	0bf030ef          	jal	ra,8001be38 <warnf>
    return 0;
    8001857e:	4781                	li	a5,0
}
    80018580:	853e                	mv	a0,a5
    80018582:	70e2                	ld	ra,56(sp)
    80018584:	7442                	ld	s0,48(sp)
    80018586:	6121                	addi	sp,sp,64
    80018588:	8082                	ret

000000008001858a <minix3_get_inode>:

static uint32_t last_inode = 0; // Last inode number we looked up
static Inode last_inode_data; // Data of the last inode

Inode minix3_get_inode(VirtioDevice *block_device, uint32_t inode) {
    8001858a:	7111                	addi	sp,sp,-256
    8001858c:	fd86                	sd	ra,248(sp)
    8001858e:	f9a2                	sd	s0,240(sp)
    80018590:	0200                	addi	s0,sp,256
    80018592:	f2a43c23          	sd	a0,-200(s0)
    80018596:	f2b43823          	sd	a1,-208(s0)
    8001859a:	87b2                	mv	a5,a2
    8001859c:	f2f42623          	sw	a5,-212(s0)
    minix3_load_device(block_device);
    800185a0:	f3043503          	ld	a0,-208(s0)
    800185a4:	b4bff0ef          	jal	ra,800180ee <minix3_load_device>
    if (inode == INVALID_INODE) {
    800185a8:	f2c42783          	lw	a5,-212(s0)
    800185ac:	2781                	sext.w	a5,a5
    800185ae:	e78d                	bnez	a5,800185d8 <minix3_get_inode+0x4e>
        warnf("minix3_get_inode: Invalid inode %u\n", inode);
    800185b0:	f2c42783          	lw	a5,-212(s0)
    800185b4:	85be                	mv	a1,a5
    800185b6:	00010517          	auipc	a0,0x10
    800185ba:	9ba50513          	addi	a0,a0,-1606 # 80027f70 <pow10.0+0x1110>
    800185be:	07b030ef          	jal	ra,8001be38 <warnf>
        return (Inode){0};
    800185c2:	f3843783          	ld	a5,-200(s0)
    800185c6:	873e                	mv	a4,a5
    800185c8:	04000793          	li	a5,64
    800185cc:	863e                	mv	a2,a5
    800185ce:	4581                	li	a1,0
    800185d0:	853a                	mv	a0,a4
    800185d2:	46b090ef          	jal	ra,8002223c <memset>
    // block_device_read_bytes(offset, (uint8_t*)&data, sizeof(Inode));
    block_device_read_bytes(block_device, offset, (uint8_t*)&data, sizeof(Inode));
    last_inode_data = data;
    last_inode = inode;
    return data;
}
    800185d6:	a8d5                	j	800186ca <minix3_get_inode+0x140>
    else if (inode == last_inode) {
    800185d8:	0000d797          	auipc	a5,0xd
    800185dc:	b2078793          	addi	a5,a5,-1248 # 800250f8 <last_inode>
    800185e0:	4398                	lw	a4,0(a5)
    800185e2:	f2c42783          	lw	a5,-212(s0)
    800185e6:	2781                	sext.w	a5,a5
    800185e8:	02e79163          	bne	a5,a4,8001860a <minix3_get_inode+0x80>
        return last_inode_data;
    800185ec:	f3843703          	ld	a4,-200(s0)
    800185f0:	0000d797          	auipc	a5,0xd
    800185f4:	b1078793          	addi	a5,a5,-1264 # 80025100 <last_inode_data>
    800185f8:	86be                	mv	a3,a5
    800185fa:	04000793          	li	a5,64
    800185fe:	863e                	mv	a2,a5
    80018600:	85b6                	mv	a1,a3
    80018602:	853a                	mv	a0,a4
    80018604:	53b090ef          	jal	ra,8002233e <memcpy>
    80018608:	a0c9                	j	800186ca <minix3_get_inode+0x140>
    SuperBlock sb = minix3_get_superblock(block_device);
    8001860a:	fc840793          	addi	a5,s0,-56
    8001860e:	f3043583          	ld	a1,-208(s0)
    80018612:	853e                	mv	a0,a5
    80018614:	80fff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    uint64_t offset = minix3_get_inode_byte_offset(block_device, sb, inode);
    80018618:	fc843603          	ld	a2,-56(s0)
    8001861c:	fd043683          	ld	a3,-48(s0)
    80018620:	fd843703          	ld	a4,-40(s0)
    80018624:	fe043783          	ld	a5,-32(s0)
    80018628:	f0c43023          	sd	a2,-256(s0)
    8001862c:	f0d43423          	sd	a3,-248(s0)
    80018630:	f0e43823          	sd	a4,-240(s0)
    80018634:	f0f43c23          	sd	a5,-232(s0)
    80018638:	f2c42703          	lw	a4,-212(s0)
    8001863c:	f0040793          	addi	a5,s0,-256
    80018640:	863a                	mv	a2,a4
    80018642:	85be                	mv	a1,a5
    80018644:	f3043503          	ld	a0,-208(s0)
    80018648:	8d4ff0ef          	jal	ra,8001771c <minix3_get_inode_byte_offset>
    8001864c:	fea43423          	sd	a0,-24(s0)
    block_device_read_bytes(block_device, offset, (uint8_t*)&data, sizeof(Inode));
    80018650:	f8840793          	addi	a5,s0,-120
    80018654:	04000693          	li	a3,64
    80018658:	863e                	mv	a2,a5
    8001865a:	fe843583          	ld	a1,-24(s0)
    8001865e:	f3043503          	ld	a0,-208(s0)
    80018662:	41c060ef          	jal	ra,8001ea7e <block_device_read_bytes>
    last_inode_data = data;
    80018666:	0000d797          	auipc	a5,0xd
    8001866a:	a9a78793          	addi	a5,a5,-1382 # 80025100 <last_inode_data>
    8001866e:	f8843303          	ld	t1,-120(s0)
    80018672:	f9043883          	ld	a7,-112(s0)
    80018676:	f9843803          	ld	a6,-104(s0)
    8001867a:	fa043503          	ld	a0,-96(s0)
    8001867e:	fa843583          	ld	a1,-88(s0)
    80018682:	fb043603          	ld	a2,-80(s0)
    80018686:	fb843683          	ld	a3,-72(s0)
    8001868a:	fc043703          	ld	a4,-64(s0)
    8001868e:	0067b023          	sd	t1,0(a5)
    80018692:	0117b423          	sd	a7,8(a5)
    80018696:	0107b823          	sd	a6,16(a5)
    8001869a:	ef88                	sd	a0,24(a5)
    8001869c:	f38c                	sd	a1,32(a5)
    8001869e:	f790                	sd	a2,40(a5)
    800186a0:	fb94                	sd	a3,48(a5)
    800186a2:	ff98                	sd	a4,56(a5)
    last_inode = inode;
    800186a4:	0000d797          	auipc	a5,0xd
    800186a8:	a5478793          	addi	a5,a5,-1452 # 800250f8 <last_inode>
    800186ac:	f2c42703          	lw	a4,-212(s0)
    800186b0:	c398                	sw	a4,0(a5)
    return data;
    800186b2:	f3843783          	ld	a5,-200(s0)
    800186b6:	86be                	mv	a3,a5
    800186b8:	f8840793          	addi	a5,s0,-120
    800186bc:	04000713          	li	a4,64
    800186c0:	863a                	mv	a2,a4
    800186c2:	85be                	mv	a1,a5
    800186c4:	8536                	mv	a0,a3
    800186c6:	479090ef          	jal	ra,8002233e <memcpy>
}
    800186ca:	f3843503          	ld	a0,-200(s0)
    800186ce:	70ee                	ld	ra,248(sp)
    800186d0:	744e                	ld	s0,240(sp)
    800186d2:	6111                	addi	sp,sp,256
    800186d4:	8082                	ret

00000000800186d6 <minix3_put_inode>:

void minix3_put_inode(VirtioDevice *block_device, uint32_t inode, Inode data) {
    800186d6:	7119                	addi	sp,sp,-128
    800186d8:	fc86                	sd	ra,120(sp)
    800186da:	f8a2                	sd	s0,112(sp)
    800186dc:	f4a6                	sd	s1,104(sp)
    800186de:	0100                	addi	s0,sp,128
    800186e0:	faa43423          	sd	a0,-88(s0)
    800186e4:	87ae                	mv	a5,a1
    800186e6:	84b2                	mv	s1,a2
    800186e8:	faf42223          	sw	a5,-92(s0)
    minix3_load_device(block_device);
    800186ec:	fa843503          	ld	a0,-88(s0)
    800186f0:	9ffff0ef          	jal	ra,800180ee <minix3_load_device>
    if (inode == INVALID_INODE) {
    800186f4:	fa442783          	lw	a5,-92(s0)
    800186f8:	2781                	sext.w	a5,a5
    800186fa:	eb99                	bnez	a5,80018710 <minix3_put_inode+0x3a>
        warnf("minix3_put_inode: Invalid inode %u\n", inode);
    800186fc:	fa442783          	lw	a5,-92(s0)
    80018700:	85be                	mv	a1,a5
    80018702:	00010517          	auipc	a0,0x10
    80018706:	89650513          	addi	a0,a0,-1898 # 80027f98 <pow10.0+0x1138>
    8001870a:	72e030ef          	jal	ra,8001be38 <warnf>
    8001870e:	a8a9                	j	80018768 <minix3_put_inode+0x92>
        return;
    }
    SuperBlock sb = minix3_get_superblock(block_device);
    80018710:	fb840793          	addi	a5,s0,-72
    80018714:	fa843583          	ld	a1,-88(s0)
    80018718:	853e                	mv	a0,a5
    8001871a:	f08ff0ef          	jal	ra,80017e22 <minix3_get_superblock>
    uint64_t offset = minix3_get_inode_byte_offset(block_device, sb, inode);
    8001871e:	fb843603          	ld	a2,-72(s0)
    80018722:	fc043683          	ld	a3,-64(s0)
    80018726:	fc843703          	ld	a4,-56(s0)
    8001872a:	fd043783          	ld	a5,-48(s0)
    8001872e:	f8c43023          	sd	a2,-128(s0)
    80018732:	f8d43423          	sd	a3,-120(s0)
    80018736:	f8e43823          	sd	a4,-112(s0)
    8001873a:	f8f43c23          	sd	a5,-104(s0)
    8001873e:	fa442703          	lw	a4,-92(s0)
    80018742:	f8040793          	addi	a5,s0,-128
    80018746:	863a                	mv	a2,a4
    80018748:	85be                	mv	a1,a5
    8001874a:	fa843503          	ld	a0,-88(s0)
    8001874e:	fcffe0ef          	jal	ra,8001771c <minix3_get_inode_byte_offset>
    80018752:	fca43c23          	sd	a0,-40(s0)

    // debugf("Putting inode %u at offset %u (%x)...\n", inode, offset, offset);
    block_device_write_bytes(block_device, offset, (uint8_t*)&data, sizeof(Inode));
    80018756:	04000693          	li	a3,64
    8001875a:	8626                	mv	a2,s1
    8001875c:	fd843583          	ld	a1,-40(s0)
    80018760:	fa843503          	ld	a0,-88(s0)
    80018764:	41a060ef          	jal	ra,8001eb7e <block_device_write_bytes>
}
    80018768:	70e6                	ld	ra,120(sp)
    8001876a:	7446                	ld	s0,112(sp)
    8001876c:	74a6                	ld	s1,104(sp)
    8001876e:	6109                	addi	sp,sp,128
    80018770:	8082                	ret

0000000080018772 <minix3_alloc_inode>:

// Allocate a free inode.
// Return the allocated zero'd inode. 
uint32_t minix3_alloc_inode(VirtioDevice *block_device) {
    80018772:	7171                	addi	sp,sp,-176
    80018774:	f506                	sd	ra,168(sp)
    80018776:	f122                	sd	s0,160(sp)
    80018778:	1900                	addi	s0,sp,176
    8001877a:	f8a43c23          	sd	a0,-104(s0)
    uint32_t free_inode = minix3_get_next_free_inode(block_device);
    8001877e:	f9843503          	ld	a0,-104(s0)
    80018782:	d43ff0ef          	jal	ra,800184c4 <minix3_get_next_free_inode>
    80018786:	87aa                	mv	a5,a0
    80018788:	fef42623          	sw	a5,-20(s0)
    if (!free_inode) {
    8001878c:	fec42783          	lw	a5,-20(s0)
    80018790:	2781                	sext.w	a5,a5
    80018792:	eb89                	bnez	a5,800187a4 <minix3_alloc_inode+0x32>
        warnf("minix3_alloc_inode: Couldn't find free inode\n");
    80018794:	00010517          	auipc	a0,0x10
    80018798:	82c50513          	addi	a0,a0,-2004 # 80027fc0 <pow10.0+0x1160>
    8001879c:	69c030ef          	jal	ra,8001be38 <warnf>
        return 0;
    800187a0:	4781                	li	a5,0
    800187a2:	a045                	j	80018842 <minix3_alloc_inode+0xd0>
    } else {
        debugf("minix3_alloc_inode: Found free inode %u\n", free_inode);
    }
    if (!minix3_take_inode(block_device, free_inode)) {
    800187a4:	fec42783          	lw	a5,-20(s0)
    800187a8:	85be                	mv	a1,a5
    800187aa:	f9843503          	ld	a0,-104(s0)
    800187ae:	bd5ff0ef          	jal	ra,80018382 <minix3_take_inode>
    800187b2:	87aa                	mv	a5,a0
    800187b4:	0017c793          	xori	a5,a5,1
    800187b8:	0ff7f793          	andi	a5,a5,255
    800187bc:	cf81                	beqz	a5,800187d4 <minix3_alloc_inode+0x62>
        warnf("minix3_alloc_inode: Couldn't take inode %u\n", free_inode);
    800187be:	fec42783          	lw	a5,-20(s0)
    800187c2:	85be                	mv	a1,a5
    800187c4:	00010517          	auipc	a0,0x10
    800187c8:	82c50513          	addi	a0,a0,-2004 # 80027ff0 <pow10.0+0x1190>
    800187cc:	66c030ef          	jal	ra,8001be38 <warnf>
        return 0;
    800187d0:	4781                	li	a5,0
    800187d2:	a885                	j	80018842 <minix3_alloc_inode+0xd0>
    }

    Inode data;
    memset(&data, 0, sizeof(data));
    800187d4:	fa840793          	addi	a5,s0,-88
    800187d8:	04000613          	li	a2,64
    800187dc:	4581                	li	a1,0
    800187de:	853e                	mv	a0,a5
    800187e0:	25d090ef          	jal	ra,8002223c <memset>
    data.num_links = 1;
    800187e4:	4785                	li	a5,1
    800187e6:	faf41523          	sh	a5,-86(s0)
    minix3_put_inode(block_device, free_inode, data);
    800187ea:	fa843883          	ld	a7,-88(s0)
    800187ee:	fb043803          	ld	a6,-80(s0)
    800187f2:	fb843503          	ld	a0,-72(s0)
    800187f6:	fc043583          	ld	a1,-64(s0)
    800187fa:	fc843603          	ld	a2,-56(s0)
    800187fe:	fd043683          	ld	a3,-48(s0)
    80018802:	fd843703          	ld	a4,-40(s0)
    80018806:	fe043783          	ld	a5,-32(s0)
    8001880a:	f5143823          	sd	a7,-176(s0)
    8001880e:	f5043c23          	sd	a6,-168(s0)
    80018812:	f6a43023          	sd	a0,-160(s0)
    80018816:	f6b43423          	sd	a1,-152(s0)
    8001881a:	f6c43823          	sd	a2,-144(s0)
    8001881e:	f6d43c23          	sd	a3,-136(s0)
    80018822:	f8e43023          	sd	a4,-128(s0)
    80018826:	f8f43423          	sd	a5,-120(s0)
    8001882a:	f5040713          	addi	a4,s0,-176
    8001882e:	fec42783          	lw	a5,-20(s0)
    80018832:	863a                	mv	a2,a4
    80018834:	85be                	mv	a1,a5
    80018836:	f9843503          	ld	a0,-104(s0)
    8001883a:	e9dff0ef          	jal	ra,800186d6 <minix3_put_inode>
    // infof("minix3_alloc_inode %p\n", minix3_get_inode_byte_offset(sb, free_inode)); // TODO: REMOVE
    return free_inode;
    8001883e:	fec42783          	lw	a5,-20(s0)
}
    80018842:	853e                	mv	a0,a5
    80018844:	70aa                	ld	ra,168(sp)
    80018846:	740a                	ld	s0,160(sp)
    80018848:	614d                	addi	sp,sp,176
    8001884a:	8082                	ret

000000008001884c <minix3_alloc_zone>:

uint32_t minix3_alloc_zone(VirtioDevice *block_device) {
    8001884c:	7179                	addi	sp,sp,-48
    8001884e:	f406                	sd	ra,40(sp)
    80018850:	f022                	sd	s0,32(sp)
    80018852:	1800                	addi	s0,sp,48
    80018854:	fca43c23          	sd	a0,-40(s0)
    uint32_t free_zone = minix3_get_next_free_zone(block_device);
    80018858:	fd843503          	ld	a0,-40(s0)
    8001885c:	94cff0ef          	jal	ra,800179a8 <minix3_get_next_free_zone>
    80018860:	87aa                	mv	a5,a0
    80018862:	fef42623          	sw	a5,-20(s0)
    if (!free_zone) {
    80018866:	fec42783          	lw	a5,-20(s0)
    8001886a:	2781                	sext.w	a5,a5
    8001886c:	eb89                	bnez	a5,8001887e <minix3_alloc_zone+0x32>
        warnf("minix3_alloc_zone: Couldn't find free zone\n");
    8001886e:	0000f517          	auipc	a0,0xf
    80018872:	7b250513          	addi	a0,a0,1970 # 80028020 <pow10.0+0x11c0>
    80018876:	5c2030ef          	jal	ra,8001be38 <warnf>
        return 0;
    8001887a:	4781                	li	a5,0
    8001887c:	a81d                	j	800188b2 <minix3_alloc_zone+0x66>
    } else {
        debugf("minix3_alloc_zone: Found free zone %u\n", free_zone);
    }
    if (!minix3_take_zone(block_device, free_zone)) {
    8001887e:	fec42783          	lw	a5,-20(s0)
    80018882:	85be                	mv	a1,a5
    80018884:	fd843503          	ld	a0,-40(s0)
    80018888:	858ff0ef          	jal	ra,800178e0 <minix3_take_zone>
    8001888c:	87aa                	mv	a5,a0
    8001888e:	0017c793          	xori	a5,a5,1
    80018892:	0ff7f793          	andi	a5,a5,255
    80018896:	cf81                	beqz	a5,800188ae <minix3_alloc_zone+0x62>
        warnf("minix3_alloc_zone: Couldn't take zone %u\n", free_zone);
    80018898:	fec42783          	lw	a5,-20(s0)
    8001889c:	85be                	mv	a1,a5
    8001889e:	0000f517          	auipc	a0,0xf
    800188a2:	7b250513          	addi	a0,a0,1970 # 80028050 <pow10.0+0x11f0>
    800188a6:	592030ef          	jal	ra,8001be38 <warnf>
        return 0;
    800188aa:	4781                	li	a5,0
    800188ac:	a019                	j	800188b2 <minix3_alloc_zone+0x66>
    }
    return free_zone;
    800188ae:	fec42783          	lw	a5,-20(s0)
}
    800188b2:	853e                	mv	a0,a5
    800188b4:	70a2                	ld	ra,40(sp)
    800188b6:	7402                	ld	s0,32(sp)
    800188b8:	6145                	addi	sp,sp,48
    800188ba:	8082                	ret

00000000800188bc <minix3_is_dir>:

bool minix3_is_dir(VirtioDevice *block_device, uint32_t inode) {
    800188bc:	711d                	addi	sp,sp,-96
    800188be:	ec86                	sd	ra,88(sp)
    800188c0:	e8a2                	sd	s0,80(sp)
    800188c2:	1080                	addi	s0,sp,96
    800188c4:	faa43423          	sd	a0,-88(s0)
    800188c8:	87ae                	mv	a5,a1
    800188ca:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    800188ce:	fb040793          	addi	a5,s0,-80
    800188d2:	fa442703          	lw	a4,-92(s0)
    800188d6:	863a                	mv	a2,a4
    800188d8:	fa843583          	ld	a1,-88(s0)
    800188dc:	853e                	mv	a0,a5
    800188de:	cadff0ef          	jal	ra,8001858a <minix3_get_inode>
    if (inode_data.num_links == 0) {
    800188e2:	fb245783          	lhu	a5,-78(s0)
    800188e6:	eb91                	bnez	a5,800188fa <minix3_is_dir+0x3e>
        warnf("minix3_is_dir: Inode %u has no links\n", inode);
    800188e8:	fa442783          	lw	a5,-92(s0)
    800188ec:	85be                	mv	a1,a5
    800188ee:	0000f517          	auipc	a0,0xf
    800188f2:	79250513          	addi	a0,a0,1938 # 80028080 <pow10.0+0x1220>
    800188f6:	542030ef          	jal	ra,8001be38 <warnf>
    }
    return S_ISDIR(inode_data.mode) && inode_data.num_links > 0;
    800188fa:	fb045783          	lhu	a5,-80(s0)
    800188fe:	0007871b          	sext.w	a4,a5
    80018902:	67bd                	lui	a5,0xf
    80018904:	8ff9                	and	a5,a5,a4
    80018906:	2781                	sext.w	a5,a5
    80018908:	873e                	mv	a4,a5
    8001890a:	6791                	lui	a5,0x4
    8001890c:	00f71763          	bne	a4,a5,8001891a <minix3_is_dir+0x5e>
    80018910:	fb245783          	lhu	a5,-78(s0)
    80018914:	c399                	beqz	a5,8001891a <minix3_is_dir+0x5e>
    80018916:	4785                	li	a5,1
    80018918:	a011                	j	8001891c <minix3_is_dir+0x60>
    8001891a:	4781                	li	a5,0
    8001891c:	8b85                	andi	a5,a5,1
    8001891e:	0ff7f793          	andi	a5,a5,255
}
    80018922:	853e                	mv	a0,a5
    80018924:	60e6                	ld	ra,88(sp)
    80018926:	6446                	ld	s0,80(sp)
    80018928:	6125                	addi	sp,sp,96
    8001892a:	8082                	ret

000000008001892c <minix3_is_file>:

bool minix3_is_file(VirtioDevice *block_device, uint32_t inode) {
    8001892c:	711d                	addi	sp,sp,-96
    8001892e:	ec86                	sd	ra,88(sp)
    80018930:	e8a2                	sd	s0,80(sp)
    80018932:	1080                	addi	s0,sp,96
    80018934:	faa43423          	sd	a0,-88(s0)
    80018938:	87ae                	mv	a5,a1
    8001893a:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    8001893e:	fb040793          	addi	a5,s0,-80
    80018942:	fa442703          	lw	a4,-92(s0)
    80018946:	863a                	mv	a2,a4
    80018948:	fa843583          	ld	a1,-88(s0)
    8001894c:	853e                	mv	a0,a5
    8001894e:	c3dff0ef          	jal	ra,8001858a <minix3_get_inode>
    if (inode_data.num_links == 0) {
    80018952:	fb245783          	lhu	a5,-78(s0)
    80018956:	eb91                	bnez	a5,8001896a <minix3_is_file+0x3e>
        warnf("minix3_is_file: Inode %u has no links\n", inode);
    80018958:	fa442783          	lw	a5,-92(s0)
    8001895c:	85be                	mv	a1,a5
    8001895e:	0000f517          	auipc	a0,0xf
    80018962:	74a50513          	addi	a0,a0,1866 # 800280a8 <pow10.0+0x1248>
    80018966:	4d2030ef          	jal	ra,8001be38 <warnf>
    }
    return S_ISREG(inode_data.mode) && inode_data.num_links > 0;
    8001896a:	fb045783          	lhu	a5,-80(s0)
    8001896e:	0007871b          	sext.w	a4,a5
    80018972:	67bd                	lui	a5,0xf
    80018974:	8ff9                	and	a5,a5,a4
    80018976:	2781                	sext.w	a5,a5
    80018978:	873e                	mv	a4,a5
    8001897a:	67a1                	lui	a5,0x8
    8001897c:	00f71763          	bne	a4,a5,8001898a <minix3_is_file+0x5e>
    80018980:	fb245783          	lhu	a5,-78(s0)
    80018984:	c399                	beqz	a5,8001898a <minix3_is_file+0x5e>
    80018986:	4785                	li	a5,1
    80018988:	a011                	j	8001898c <minix3_is_file+0x60>
    8001898a:	4781                	li	a5,0
    8001898c:	8b85                	andi	a5,a5,1
    8001898e:	0ff7f793          	andi	a5,a5,255
}
    80018992:	853e                	mv	a0,a5
    80018994:	60e6                	ld	ra,88(sp)
    80018996:	6446                	ld	s0,80(sp)
    80018998:	6125                	addi	sp,sp,96
    8001899a:	8082                	ret

000000008001899c <minix3_is_block_device>:

bool minix3_is_block_device(VirtioDevice *block_device, uint32_t inode) {
    8001899c:	711d                	addi	sp,sp,-96
    8001899e:	ec86                	sd	ra,88(sp)
    800189a0:	e8a2                	sd	s0,80(sp)
    800189a2:	1080                	addi	s0,sp,96
    800189a4:	faa43423          	sd	a0,-88(s0)
    800189a8:	87ae                	mv	a5,a1
    800189aa:	faf42223          	sw	a5,-92(s0)
    Inode inode_data = minix3_get_inode(block_device, inode);
    800189ae:	fb040793          	addi	a5,s0,-80
    800189b2:	fa442703          	lw	a4,-92(s0)
    800189b6:	863a                	mv	a2,a4
    800189b8:	fa843583          	ld	a1,-88(s0)
    800189bc:	853e                	mv	a0,a5
    800189be:	bcdff0ef          	jal	ra,8001858a <minix3_get_inode>
    if (inode_data.num_links == 0) {
    800189c2:	fb245783          	lhu	a5,-78(s0)
    800189c6:	eb91                	bnez	a5,800189da <minix3_is_block_device+0x3e>
        warnf("minix3_is_block_device: Inode %u has no links\n", inode);
    800189c8:	fa442783          	lw	a5,-92(s0)
    800189cc:	85be                	mv	a1,a5
    800189ce:	0000f517          	auipc	a0,0xf
    800189d2:	70250513          	addi	a0,a0,1794 # 800280d0 <pow10.0+0x1270>
    800189d6:	462030ef          	jal	ra,8001be38 <warnf>
    }
    return S_ISBLK(inode_data.mode) && inode_data.num_links > 0;
    800189da:	fb045783          	lhu	a5,-80(s0)
    800189de:	0007871b          	sext.w	a4,a5
    800189e2:	67bd                	lui	a5,0xf
    800189e4:	8ff9                	and	a5,a5,a4
    800189e6:	2781                	sext.w	a5,a5
    800189e8:	873e                	mv	a4,a5
    800189ea:	6799                	lui	a5,0x6
    800189ec:	00f71763          	bne	a4,a5,800189fa <minix3_is_block_device+0x5e>
    800189f0:	fb245783          	lhu	a5,-78(s0)
    800189f4:	c399                	beqz	a5,800189fa <minix3_is_block_device+0x5e>
    800189f6:	4785                	li	a5,1
    800189f8:	a011                	j	800189fc <minix3_is_block_device+0x60>
    800189fa:	4781                	li	a5,0
    800189fc:	8b85                	andi	a5,a5,1
    800189fe:	0ff7f793          	andi	a5,a5,255
}
    80018a02:	853e                	mv	a0,a5
    80018a04:	60e6                	ld	ra,88(sp)
    80018a06:	6446                	ld	s0,80(sp)
    80018a08:	6125                	addi	sp,sp,96
    80018a0a:	8082                	ret

0000000080018a0c <minix3_read_file>:

void minix3_read_file(VirtioDevice *block_device, uint32_t inode, uint8_t *data, uint32_t count) {
    80018a0c:	7179                	addi	sp,sp,-48
    80018a0e:	f406                	sd	ra,40(sp)
    80018a10:	f022                	sd	s0,32(sp)
    80018a12:	1800                	addi	s0,sp,48
    80018a14:	fea43423          	sd	a0,-24(s0)
    80018a18:	87ae                	mv	a5,a1
    80018a1a:	fcc43c23          	sd	a2,-40(s0)
    80018a1e:	8736                	mv	a4,a3
    80018a20:	fef42223          	sw	a5,-28(s0)
    80018a24:	87ba                	mv	a5,a4
    80018a26:	fef42023          	sw	a5,-32(s0)
    minix3_get_data(block_device, inode, data, 0, count);
    80018a2a:	fe042703          	lw	a4,-32(s0)
    80018a2e:	fe442783          	lw	a5,-28(s0)
    80018a32:	4681                	li	a3,0
    80018a34:	fd843603          	ld	a2,-40(s0)
    80018a38:	85be                	mv	a1,a5
    80018a3a:	fe843503          	ld	a0,-24(s0)
    80018a3e:	00e000ef          	jal	ra,80018a4c <minix3_get_data>
}
    80018a42:	0001                	nop
    80018a44:	70a2                	ld	ra,40(sp)
    80018a46:	7402                	ld	s0,32(sp)
    80018a48:	6145                	addi	sp,sp,48
    80018a4a:	8082                	ret

0000000080018a4c <minix3_get_data>:

void minix3_get_data(VirtioDevice *block_device, uint32_t inode, uint8_t *data, uint32_t offset, uint32_t count) {
    80018a4c:	cd010113          	addi	sp,sp,-816
    80018a50:	32113423          	sd	ra,808(sp)
    80018a54:	32813023          	sd	s0,800(sp)
    80018a58:	30913c23          	sd	s1,792(sp)
    80018a5c:	31213823          	sd	s2,784(sp)
    80018a60:	31313423          	sd	s3,776(sp)
    80018a64:	31413023          	sd	s4,768(sp)
    80018a68:	2f513c23          	sd	s5,760(sp)
    80018a6c:	2f613823          	sd	s6,752(sp)
    80018a70:	2f713423          	sd	s7,744(sp)
    80018a74:	2f813023          	sd	s8,736(sp)
    80018a78:	2d913c23          	sd	s9,728(sp)
    80018a7c:	2da13823          	sd	s10,720(sp)
    80018a80:	2db13423          	sd	s11,712(sp)
    80018a84:	1e00                	addi	s0,sp,816
    80018a86:	e6a43423          	sd	a0,-408(s0)
    80018a8a:	87ae                	mv	a5,a1
    80018a8c:	e4c43c23          	sd	a2,-424(s0)
    80018a90:	e6f42223          	sw	a5,-412(s0)
    80018a94:	87b6                	mv	a5,a3
    80018a96:	e6f42023          	sw	a5,-416(s0)
    80018a9a:	87ba                	mv	a5,a4
    80018a9c:	e4f42a23          	sw	a5,-428(s0)
    80018aa0:	878a                	mv	a5,sp
    80018aa2:	ccf43c23          	sd	a5,-808(s0)
    debugf("minix3_get_data: Getting data from inode %u, offset %u, count %u\n", inode, offset, count);
    // First, get the inode
    Inode inode_data = minix3_get_inode(block_device, inode);
    80018aa6:	e7840713          	addi	a4,s0,-392
    80018aaa:	e6442783          	lw	a5,-412(s0)
    80018aae:	863e                	mv	a2,a5
    80018ab0:	e6843583          	ld	a1,-408(s0)
    80018ab4:	853a                	mv	a0,a4
    80018ab6:	ad5ff0ef          	jal	ra,8001858a <minix3_get_inode>
    

    uint8_t zone_data[minix3_get_zone_size(block_device)];
    80018aba:	e6843503          	ld	a0,-408(s0)
    80018abe:	c4cff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018ac2:	87aa                	mv	a5,a0
    80018ac4:	873e                	mv	a4,a5
    80018ac6:	87ba                	mv	a5,a4
    80018ac8:	17fd                	addi	a5,a5,-1
    80018aca:	f6f43c23          	sd	a5,-136(s0)
    80018ace:	e4e43023          	sd	a4,-448(s0)
    80018ad2:	e4043423          	sd	zero,-440(s0)
    80018ad6:	e4043783          	ld	a5,-448(s0)
    80018ada:	93f5                	srli	a5,a5,0x3d
    80018adc:	e4843683          	ld	a3,-440(s0)
    80018ae0:	068e                	slli	a3,a3,0x3
    80018ae2:	d6d43423          	sd	a3,-664(s0)
    80018ae6:	d6843683          	ld	a3,-664(s0)
    80018aea:	8fd5                	or	a5,a5,a3
    80018aec:	d6f43423          	sd	a5,-664(s0)
    80018af0:	e4043783          	ld	a5,-448(s0)
    80018af4:	078e                	slli	a5,a5,0x3
    80018af6:	d6f43023          	sd	a5,-672(s0)
    80018afa:	e2e43823          	sd	a4,-464(s0)
    80018afe:	e2043c23          	sd	zero,-456(s0)
    80018b02:	e3043783          	ld	a5,-464(s0)
    80018b06:	93f5                	srli	a5,a5,0x3d
    80018b08:	e3843683          	ld	a3,-456(s0)
    80018b0c:	00369993          	slli	s3,a3,0x3
    80018b10:	0137e9b3          	or	s3,a5,s3
    80018b14:	e3043783          	ld	a5,-464(s0)
    80018b18:	00379913          	slli	s2,a5,0x3
    80018b1c:	87ba                	mv	a5,a4
    80018b1e:	07bd                	addi	a5,a5,15
    80018b20:	8391                	srli	a5,a5,0x4
    80018b22:	0792                	slli	a5,a5,0x4
    80018b24:	40f10133          	sub	sp,sp,a5
    80018b28:	878a                	mv	a5,sp
    80018b2a:	00078793          	mv	a5,a5
    80018b2e:	f6f43823          	sd	a5,-144(s0)

    // The cursor is the current position in the data buffer
    uint32_t buffer_cursor = 0;
    80018b32:	f8042223          	sw	zero,-124(s0)
    uint32_t file_cursor = 0;
    80018b36:	f8042423          	sw	zero,-120(s0)

    // Now, get the data
    // The first 7 zones are direct zones
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80018b3a:	f80406a3          	sb	zero,-115(s0)
    80018b3e:	aaf1                	j	80018d1a <minix3_get_data+0x2ce>
        uint32_t zone = inode_data.zones[direct_zone];
    80018b40:	f8d44783          	lbu	a5,-115(s0)
    80018b44:	2781                	sext.w	a5,a5
    80018b46:	0791                	addi	a5,a5,4
    80018b48:	078a                	slli	a5,a5,0x2
    80018b4a:	f9040713          	addi	a4,s0,-112
    80018b4e:	97ba                	add	a5,a5,a4
    80018b50:	ef07a783          	lw	a5,-272(a5) # 5ef0 <i+0x5ed0>
    80018b54:	ecf42223          	sw	a5,-316(s0)
        if (zone == 0) {
    80018b58:	ec442783          	lw	a5,-316(s0)
    80018b5c:	2781                	sext.w	a5,a5
    80018b5e:	1a078863          	beqz	a5,80018d0e <minix3_get_data+0x2c2>
            debugf("No direct zone %d\n", zone);
            continue;
        } else {
            debugf("Direct zone %d\n", zone);
        }
        memset(zone_data, 0, minix3_get_zone_size(block_device));
    80018b62:	e6843503          	ld	a0,-408(s0)
    80018b66:	ba4ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018b6a:	87aa                	mv	a5,a0
    80018b6c:	2781                	sext.w	a5,a5
    80018b6e:	863e                	mv	a2,a5
    80018b70:	4581                	li	a1,0
    80018b72:	f7043503          	ld	a0,-144(s0)
    80018b76:	6c6090ef          	jal	ra,8002223c <memset>

        if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80018b7a:	e6843503          	ld	a0,-408(s0)
    80018b7e:	b8cff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018b82:	87aa                	mv	a5,a0
    80018b84:	2781                	sext.w	a5,a5
    80018b86:	f8842703          	lw	a4,-120(s0)
    80018b8a:	9fb9                	addw	a5,a5,a4
    80018b8c:	0007871b          	sext.w	a4,a5
    80018b90:	e6042783          	lw	a5,-416(s0)
    80018b94:	2781                	sext.w	a5,a5
    80018b96:	00f77e63          	bgeu	a4,a5,80018bb2 <minix3_get_data+0x166>
            // We're not at the offset yet
            file_cursor += minix3_get_zone_size(block_device);
    80018b9a:	e6843503          	ld	a0,-408(s0)
    80018b9e:	b6cff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018ba2:	87aa                	mv	a5,a0
    80018ba4:	2781                	sext.w	a5,a5
    80018ba6:	f8842703          	lw	a4,-120(s0)
    80018baa:	9fb9                	addw	a5,a5,a4
    80018bac:	f8f42423          	sw	a5,-120(s0)
            continue;
    80018bb0:	a285                	j	80018d10 <minix3_get_data+0x2c4>
        } else if (file_cursor < offset) {
    80018bb2:	f8842703          	lw	a4,-120(s0)
    80018bb6:	e6042783          	lw	a5,-416(s0)
    80018bba:	2701                	sext.w	a4,a4
    80018bbc:	2781                	sext.w	a5,a5
    80018bbe:	0af77b63          	bgeu	a4,a5,80018c74 <minix3_get_data+0x228>
            // We're in the middle of the offset
            // Read the zone into the buffer
            debugf("Reading first direct zone %d\n", zone);
            minix3_get_zone(block_device, zone, zone_data);
    80018bc2:	ec442783          	lw	a5,-316(s0)
    80018bc6:	f7043603          	ld	a2,-144(s0)
    80018bca:	85be                	mv	a1,a5
    80018bcc:	e6843503          	ld	a0,-408(s0)
    80018bd0:	e99fe0ef          	jal	ra,80017a68 <minix3_get_zone>
            // Copy the remaining data into the buffer
            size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80018bd4:	e6843503          	ld	a0,-408(s0)
    80018bd8:	b32ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018bdc:	87aa                	mv	a5,a0
    80018bde:	0007871b          	sext.w	a4,a5
    80018be2:	f8842683          	lw	a3,-120(s0)
    80018be6:	e6042783          	lw	a5,-416(s0)
    80018bea:	40f687bb          	subw	a5,a3,a5
    80018bee:	2781                	sext.w	a5,a5
    80018bf0:	9fb9                	addw	a5,a5,a4
    80018bf2:	0007871b          	sext.w	a4,a5
    80018bf6:	e5442783          	lw	a5,-428(s0)
    80018bfa:	2781                	sext.w	a5,a5
    80018bfc:	02e7e563          	bltu	a5,a4,80018c26 <minix3_get_data+0x1da>
    80018c00:	e6843503          	ld	a0,-408(s0)
    80018c04:	b06ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018c08:	87aa                	mv	a5,a0
    80018c0a:	0007871b          	sext.w	a4,a5
    80018c0e:	f8842683          	lw	a3,-120(s0)
    80018c12:	e6042783          	lw	a5,-416(s0)
    80018c16:	40f687bb          	subw	a5,a3,a5
    80018c1a:	2781                	sext.w	a5,a5
    80018c1c:	9fb9                	addw	a5,a5,a4
    80018c1e:	2781                	sext.w	a5,a5
    80018c20:	1782                	slli	a5,a5,0x20
    80018c22:	9381                	srli	a5,a5,0x20
    80018c24:	a019                	j	80018c2a <minix3_get_data+0x1de>
    80018c26:	e5446783          	lwu	a5,-428(s0)
    80018c2a:	eaf43c23          	sd	a5,-328(s0)
            memcpy(data, zone_data + offset - file_cursor, remaining);
    80018c2e:	e6046703          	lwu	a4,-416(s0)
    80018c32:	f8846783          	lwu	a5,-120(s0)
    80018c36:	40f707b3          	sub	a5,a4,a5
    80018c3a:	f7043703          	ld	a4,-144(s0)
    80018c3e:	97ba                	add	a5,a5,a4
    80018c40:	eb843703          	ld	a4,-328(s0)
    80018c44:	2701                	sext.w	a4,a4
    80018c46:	863a                	mv	a2,a4
    80018c48:	85be                	mv	a1,a5
    80018c4a:	e5843503          	ld	a0,-424(s0)
    80018c4e:	6f0090ef          	jal	ra,8002233e <memcpy>
            buffer_cursor += remaining;
    80018c52:	eb843783          	ld	a5,-328(s0)
    80018c56:	2781                	sext.w	a5,a5
    80018c58:	f8442703          	lw	a4,-124(s0)
    80018c5c:	9fb9                	addw	a5,a5,a4
    80018c5e:	f8f42223          	sw	a5,-124(s0)
            file_cursor = offset + remaining;
    80018c62:	eb843783          	ld	a5,-328(s0)
    80018c66:	2781                	sext.w	a5,a5
    80018c68:	e6042703          	lw	a4,-416(s0)
    80018c6c:	9fb9                	addw	a5,a5,a4
    80018c6e:	f8f42423          	sw	a5,-120(s0)
            continue;
    80018c72:	a879                	j	80018d10 <minix3_get_data+0x2c4>
        }

        // Read the zone into the buffer
        minix3_get_zone(block_device, zone, zone_data);
    80018c74:	ec442783          	lw	a5,-316(s0)
    80018c78:	f7043603          	ld	a2,-144(s0)
    80018c7c:	85be                	mv	a1,a5
    80018c7e:	e6843503          	ld	a0,-408(s0)
    80018c82:	de7fe0ef          	jal	ra,80017a68 <minix3_get_zone>

        // If the cursor is past the amount of data we want, we're done
        if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80018c86:	e6843503          	ld	a0,-408(s0)
    80018c8a:	a80ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018c8e:	87aa                	mv	a5,a0
    80018c90:	2781                	sext.w	a5,a5
    80018c92:	f8442703          	lw	a4,-124(s0)
    80018c96:	9fb9                	addw	a5,a5,a4
    80018c98:	0007871b          	sext.w	a4,a5
    80018c9c:	e5442783          	lw	a5,-428(s0)
    80018ca0:	2781                	sext.w	a5,a5
    80018ca2:	02e7f863          	bgeu	a5,a4,80018cd2 <minix3_get_data+0x286>
            debugf("Reading last direct zone %d\n", zone);
            // Copy the remaining data into the buffer
            memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    80018ca6:	f8446783          	lwu	a5,-124(s0)
    80018caa:	e5843703          	ld	a4,-424(s0)
    80018cae:	00f706b3          	add	a3,a4,a5
    80018cb2:	e5442703          	lw	a4,-428(s0)
    80018cb6:	f8442783          	lw	a5,-124(s0)
    80018cba:	40f707bb          	subw	a5,a4,a5
    80018cbe:	2781                	sext.w	a5,a5
    80018cc0:	2781                	sext.w	a5,a5
    80018cc2:	863e                	mv	a2,a5
    80018cc4:	f7043583          	ld	a1,-144(s0)
    80018cc8:	8536                	mv	a0,a3
    80018cca:	674090ef          	jal	ra,8002233e <memcpy>
            // We're done
            return;
    80018cce:	32f0006f          	j	800197fc <minix3_get_data+0xdb0>
        } else {
            debugf("Reading direct zone %d\n", zone);
            // Copy the entire zone into the buffer
            memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    80018cd2:	f8446783          	lwu	a5,-124(s0)
    80018cd6:	e5843703          	ld	a4,-424(s0)
    80018cda:	00f704b3          	add	s1,a4,a5
    80018cde:	e6843503          	ld	a0,-408(s0)
    80018ce2:	a28ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018ce6:	87aa                	mv	a5,a0
    80018ce8:	2781                	sext.w	a5,a5
    80018cea:	863e                	mv	a2,a5
    80018cec:	f7043583          	ld	a1,-144(s0)
    80018cf0:	8526                	mv	a0,s1
    80018cf2:	64c090ef          	jal	ra,8002233e <memcpy>
        }
        buffer_cursor += minix3_get_zone_size(block_device);
    80018cf6:	e6843503          	ld	a0,-408(s0)
    80018cfa:	a10ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018cfe:	87aa                	mv	a5,a0
    80018d00:	2781                	sext.w	a5,a5
    80018d02:	f8442703          	lw	a4,-124(s0)
    80018d06:	9fb9                	addw	a5,a5,a4
    80018d08:	f8f42223          	sw	a5,-124(s0)
    80018d0c:	a011                	j	80018d10 <minix3_get_data+0x2c4>
            continue;
    80018d0e:	0001                	nop
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80018d10:	f8d44783          	lbu	a5,-115(s0)
    80018d14:	2785                	addiw	a5,a5,1
    80018d16:	f8f406a3          	sb	a5,-115(s0)
    80018d1a:	f8d44783          	lbu	a5,-115(s0)
    80018d1e:	0ff7f713          	andi	a4,a5,255
    80018d22:	4799                	li	a5,6
    80018d24:	e0e7fee3          	bgeu	a5,a4,80018b40 <minix3_get_data+0xf4>
    }

    debugf("Done with direct zones\n");
    // The next zone is an indirect zone
    if (inode_data.zones[7] != 0) {
    80018d28:	eac42783          	lw	a5,-340(s0)
    80018d2c:	2a078563          	beqz	a5,80018fd6 <minix3_get_data+0x58a>
    80018d30:	878a                	mv	a5,sp
    80018d32:	893e                	mv	s2,a5
        debugf("Reading indirect zone %d\n", inode_data.zones[7]);
        uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80018d34:	e6843503          	ld	a0,-408(s0)
    80018d38:	9d2ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018d3c:	87aa                	mv	a5,a0
    80018d3e:	0027d79b          	srliw	a5,a5,0x2
    80018d42:	17c2                	slli	a5,a5,0x30
    80018d44:	93c1                	srli	a5,a5,0x30
    80018d46:	873e                	mv	a4,a5
    80018d48:	177d                	addi	a4,a4,-1
    80018d4a:	f6e43423          	sd	a4,-152(s0)
    80018d4e:	e2f43023          	sd	a5,-480(s0)
    80018d52:	e2043423          	sd	zero,-472(s0)
    80018d56:	e2043703          	ld	a4,-480(s0)
    80018d5a:	936d                	srli	a4,a4,0x3b
    80018d5c:	e2843683          	ld	a3,-472(s0)
    80018d60:	0696                	slli	a3,a3,0x5
    80018d62:	d4d43c23          	sd	a3,-680(s0)
    80018d66:	d5843683          	ld	a3,-680(s0)
    80018d6a:	8f55                	or	a4,a4,a3
    80018d6c:	d4e43c23          	sd	a4,-680(s0)
    80018d70:	e2043703          	ld	a4,-480(s0)
    80018d74:	0716                	slli	a4,a4,0x5
    80018d76:	d4e43823          	sd	a4,-688(s0)
    80018d7a:	e0f43823          	sd	a5,-496(s0)
    80018d7e:	e0043c23          	sd	zero,-488(s0)
    80018d82:	e1043703          	ld	a4,-496(s0)
    80018d86:	936d                	srli	a4,a4,0x3b
    80018d88:	e1843683          	ld	a3,-488(s0)
    80018d8c:	0696                	slli	a3,a3,0x5
    80018d8e:	d4d43423          	sd	a3,-696(s0)
    80018d92:	d4843683          	ld	a3,-696(s0)
    80018d96:	8f55                	or	a4,a4,a3
    80018d98:	d4e43423          	sd	a4,-696(s0)
    80018d9c:	e1043703          	ld	a4,-496(s0)
    80018da0:	0716                	slli	a4,a4,0x5
    80018da2:	d4e43023          	sd	a4,-704(s0)
    80018da6:	078a                	slli	a5,a5,0x2
    80018da8:	07bd                	addi	a5,a5,15
    80018daa:	8391                	srli	a5,a5,0x4
    80018dac:	0792                	slli	a5,a5,0x4
    80018dae:	40f10133          	sub	sp,sp,a5
    80018db2:	878a                	mv	a5,sp
    80018db4:	078d                	addi	a5,a5,3
    80018db6:	8389                	srli	a5,a5,0x2
    80018db8:	078a                	slli	a5,a5,0x2
    80018dba:	f6f43023          	sd	a5,-160(s0)
        minix3_get_zone(block_device, inode_data.zones[7], (uint8_t*)indirect_zones);
    80018dbe:	eac42783          	lw	a5,-340(s0)
    80018dc2:	f6043603          	ld	a2,-160(s0)
    80018dc6:	85be                	mv	a1,a5
    80018dc8:	e6843503          	ld	a0,-408(s0)
    80018dcc:	c9dfe0ef          	jal	ra,80017a68 <minix3_get_zone>
        

        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80018dd0:	f8040723          	sb	zero,-114(s0)
    80018dd4:	aae9                	j	80018fae <minix3_get_data+0x562>
            uint32_t zone = indirect_zones[indirect_zone];
    80018dd6:	f8e44783          	lbu	a5,-114(s0)
    80018dda:	2781                	sext.w	a5,a5
    80018ddc:	f6043703          	ld	a4,-160(s0)
    80018de0:	078a                	slli	a5,a5,0x2
    80018de2:	97ba                	add	a5,a5,a4
    80018de4:	439c                	lw	a5,0(a5)
    80018de6:	f4f42e23          	sw	a5,-164(s0)
            debugf("Reading indirect zone %d\n", zone);
            if (zone == 0) continue;
    80018dea:	f5c42783          	lw	a5,-164(s0)
    80018dee:	2781                	sext.w	a5,a5
    80018df0:	1a078963          	beqz	a5,80018fa2 <minix3_get_data+0x556>
            

            if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80018df4:	e6843503          	ld	a0,-408(s0)
    80018df8:	912ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018dfc:	87aa                	mv	a5,a0
    80018dfe:	2781                	sext.w	a5,a5
    80018e00:	f8842703          	lw	a4,-120(s0)
    80018e04:	9fb9                	addw	a5,a5,a4
    80018e06:	0007871b          	sext.w	a4,a5
    80018e0a:	e6042783          	lw	a5,-416(s0)
    80018e0e:	2781                	sext.w	a5,a5
    80018e10:	00f77e63          	bgeu	a4,a5,80018e2c <minix3_get_data+0x3e0>
                // We're not at the offset yet
                file_cursor += minix3_get_zone_size(block_device);
    80018e14:	e6843503          	ld	a0,-408(s0)
    80018e18:	8f2ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018e1c:	87aa                	mv	a5,a0
    80018e1e:	2781                	sext.w	a5,a5
    80018e20:	f8842703          	lw	a4,-120(s0)
    80018e24:	9fb9                	addw	a5,a5,a4
    80018e26:	f8f42423          	sw	a5,-120(s0)
                continue;
    80018e2a:	aaad                	j	80018fa4 <minix3_get_data+0x558>
            } else if (file_cursor < offset) {
    80018e2c:	f8842703          	lw	a4,-120(s0)
    80018e30:	e6042783          	lw	a5,-416(s0)
    80018e34:	2701                	sext.w	a4,a4
    80018e36:	2781                	sext.w	a5,a5
    80018e38:	0af77b63          	bgeu	a4,a5,80018eee <minix3_get_data+0x4a2>
                // We're in the middle of the offset
                // Read the zone into the buffer
                minix3_get_zone(block_device, zone, zone_data);
    80018e3c:	f5c42783          	lw	a5,-164(s0)
    80018e40:	f7043603          	ld	a2,-144(s0)
    80018e44:	85be                	mv	a1,a5
    80018e46:	e6843503          	ld	a0,-408(s0)
    80018e4a:	c1ffe0ef          	jal	ra,80017a68 <minix3_get_zone>
                // Copy the remaining data into the buffer
                size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80018e4e:	e6843503          	ld	a0,-408(s0)
    80018e52:	8b8ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018e56:	87aa                	mv	a5,a0
    80018e58:	0007871b          	sext.w	a4,a5
    80018e5c:	f8842683          	lw	a3,-120(s0)
    80018e60:	e6042783          	lw	a5,-416(s0)
    80018e64:	40f687bb          	subw	a5,a3,a5
    80018e68:	2781                	sext.w	a5,a5
    80018e6a:	9fb9                	addw	a5,a5,a4
    80018e6c:	0007871b          	sext.w	a4,a5
    80018e70:	e5442783          	lw	a5,-428(s0)
    80018e74:	2781                	sext.w	a5,a5
    80018e76:	02e7e563          	bltu	a5,a4,80018ea0 <minix3_get_data+0x454>
    80018e7a:	e6843503          	ld	a0,-408(s0)
    80018e7e:	88cff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018e82:	87aa                	mv	a5,a0
    80018e84:	0007871b          	sext.w	a4,a5
    80018e88:	f8842683          	lw	a3,-120(s0)
    80018e8c:	e6042783          	lw	a5,-416(s0)
    80018e90:	40f687bb          	subw	a5,a3,a5
    80018e94:	2781                	sext.w	a5,a5
    80018e96:	9fb9                	addw	a5,a5,a4
    80018e98:	2781                	sext.w	a5,a5
    80018e9a:	1782                	slli	a5,a5,0x20
    80018e9c:	9381                	srli	a5,a5,0x20
    80018e9e:	a019                	j	80018ea4 <minix3_get_data+0x458>
    80018ea0:	e5446783          	lwu	a5,-428(s0)
    80018ea4:	f4f43823          	sd	a5,-176(s0)
                memcpy(data, zone_data + offset - file_cursor, remaining);
    80018ea8:	e6046703          	lwu	a4,-416(s0)
    80018eac:	f8846783          	lwu	a5,-120(s0)
    80018eb0:	40f707b3          	sub	a5,a4,a5
    80018eb4:	f7043703          	ld	a4,-144(s0)
    80018eb8:	97ba                	add	a5,a5,a4
    80018eba:	f5043703          	ld	a4,-176(s0)
    80018ebe:	2701                	sext.w	a4,a4
    80018ec0:	863a                	mv	a2,a4
    80018ec2:	85be                	mv	a1,a5
    80018ec4:	e5843503          	ld	a0,-424(s0)
    80018ec8:	476090ef          	jal	ra,8002233e <memcpy>
                buffer_cursor += remaining;
    80018ecc:	f5043783          	ld	a5,-176(s0)
    80018ed0:	2781                	sext.w	a5,a5
    80018ed2:	f8442703          	lw	a4,-124(s0)
    80018ed6:	9fb9                	addw	a5,a5,a4
    80018ed8:	f8f42223          	sw	a5,-124(s0)
                file_cursor = offset + remaining;
    80018edc:	f5043783          	ld	a5,-176(s0)
    80018ee0:	2781                	sext.w	a5,a5
    80018ee2:	e6042703          	lw	a4,-416(s0)
    80018ee6:	9fb9                	addw	a5,a5,a4
    80018ee8:	f8f42423          	sw	a5,-120(s0)
                continue;
    80018eec:	a865                	j	80018fa4 <minix3_get_data+0x558>
            }
            
            memset(zone_data, 0, minix3_get_zone_size(block_device));
    80018eee:	e6843503          	ld	a0,-408(s0)
    80018ef2:	818ff0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018ef6:	87aa                	mv	a5,a0
    80018ef8:	2781                	sext.w	a5,a5
    80018efa:	863e                	mv	a2,a5
    80018efc:	4581                	li	a1,0
    80018efe:	f7043503          	ld	a0,-144(s0)
    80018f02:	33a090ef          	jal	ra,8002223c <memset>

            // Read the zone into the buffer
            minix3_get_zone(block_device, zone, zone_data);
    80018f06:	f5c42783          	lw	a5,-164(s0)
    80018f0a:	f7043603          	ld	a2,-144(s0)
    80018f0e:	85be                	mv	a1,a5
    80018f10:	e6843503          	ld	a0,-408(s0)
    80018f14:	b55fe0ef          	jal	ra,80017a68 <minix3_get_zone>
            // If the cursor is past the amount of data we want, we're done
            if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80018f18:	e6843503          	ld	a0,-408(s0)
    80018f1c:	feffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018f20:	87aa                	mv	a5,a0
    80018f22:	2781                	sext.w	a5,a5
    80018f24:	f8442703          	lw	a4,-124(s0)
    80018f28:	9fb9                	addw	a5,a5,a4
    80018f2a:	0007871b          	sext.w	a4,a5
    80018f2e:	e5442783          	lw	a5,-428(s0)
    80018f32:	2781                	sext.w	a5,a5
    80018f34:	02e7f963          	bgeu	a5,a4,80018f66 <minix3_get_data+0x51a>
                // Copy the remaining data into the buffer
                memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    80018f38:	f8446783          	lwu	a5,-124(s0)
    80018f3c:	e5843703          	ld	a4,-424(s0)
    80018f40:	00f706b3          	add	a3,a4,a5
    80018f44:	e5442703          	lw	a4,-428(s0)
    80018f48:	f8442783          	lw	a5,-124(s0)
    80018f4c:	40f707bb          	subw	a5,a4,a5
    80018f50:	2781                	sext.w	a5,a5
    80018f52:	2781                	sext.w	a5,a5
    80018f54:	863e                	mv	a2,a5
    80018f56:	f7043583          	ld	a1,-144(s0)
    80018f5a:	8536                	mv	a0,a3
    80018f5c:	3e2090ef          	jal	ra,8002233e <memcpy>
    80018f60:	814a                	mv	sp,s2
    80018f62:	09b0006f          	j	800197fc <minix3_get_data+0xdb0>
                // We're done
                return;
            } else {
                // Copy the entire zone into the buffer
                memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    80018f66:	f8446783          	lwu	a5,-124(s0)
    80018f6a:	e5843703          	ld	a4,-424(s0)
    80018f6e:	00f704b3          	add	s1,a4,a5
    80018f72:	e6843503          	ld	a0,-408(s0)
    80018f76:	f95fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018f7a:	87aa                	mv	a5,a0
    80018f7c:	2781                	sext.w	a5,a5
    80018f7e:	863e                	mv	a2,a5
    80018f80:	f7043583          	ld	a1,-144(s0)
    80018f84:	8526                	mv	a0,s1
    80018f86:	3b8090ef          	jal	ra,8002233e <memcpy>
            }
            buffer_cursor += minix3_get_zone_size(block_device);
    80018f8a:	e6843503          	ld	a0,-408(s0)
    80018f8e:	f7dfe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018f92:	87aa                	mv	a5,a0
    80018f94:	2781                	sext.w	a5,a5
    80018f96:	f8442703          	lw	a4,-124(s0)
    80018f9a:	9fb9                	addw	a5,a5,a4
    80018f9c:	f8f42223          	sw	a5,-124(s0)
    80018fa0:	a011                	j	80018fa4 <minix3_get_data+0x558>
            if (zone == 0) continue;
    80018fa2:	0001                	nop
        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80018fa4:	f8e44783          	lbu	a5,-114(s0)
    80018fa8:	2785                	addiw	a5,a5,1
    80018faa:	f8f40723          	sb	a5,-114(s0)
    80018fae:	f8e44783          	lbu	a5,-114(s0)
    80018fb2:	03079493          	slli	s1,a5,0x30
    80018fb6:	90c1                	srli	s1,s1,0x30
    80018fb8:	e6843503          	ld	a0,-408(s0)
    80018fbc:	f4ffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018fc0:	87aa                	mv	a5,a0
    80018fc2:	0027d79b          	srliw	a5,a5,0x2
    80018fc6:	17c2                	slli	a5,a5,0x30
    80018fc8:	93c1                	srli	a5,a5,0x30
    80018fca:	0004871b          	sext.w	a4,s1
    80018fce:	2781                	sext.w	a5,a5
    80018fd0:	e0f763e3          	bltu	a4,a5,80018dd6 <minix3_get_data+0x38a>
    80018fd4:	814a                	mv	sp,s2
    } else {
        debugf("No indirect zone\n");
    }

    // The next zone is a double indirect zone
    if (inode_data.zones[8] != 0) {
    80018fd6:	eb042783          	lw	a5,-336(s0)
    80018fda:	38078d63          	beqz	a5,80019374 <minix3_get_data+0x928>
    80018fde:	878a                	mv	a5,sp
    80018fe0:	89be                	mv	s3,a5
        uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80018fe2:	e6843503          	ld	a0,-408(s0)
    80018fe6:	f25fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80018fea:	87aa                	mv	a5,a0
    80018fec:	0027d79b          	srliw	a5,a5,0x2
    80018ff0:	17c2                	slli	a5,a5,0x30
    80018ff2:	93c1                	srli	a5,a5,0x30
    80018ff4:	873e                	mv	a4,a5
    80018ff6:	177d                	addi	a4,a4,-1
    80018ff8:	f4e43423          	sd	a4,-184(s0)
    80018ffc:	e0f43023          	sd	a5,-512(s0)
    80019000:	e0043423          	sd	zero,-504(s0)
    80019004:	e0043703          	ld	a4,-512(s0)
    80019008:	936d                	srli	a4,a4,0x3b
    8001900a:	e0843683          	ld	a3,-504(s0)
    8001900e:	0696                	slli	a3,a3,0x5
    80019010:	d2d43c23          	sd	a3,-712(s0)
    80019014:	d3843683          	ld	a3,-712(s0)
    80019018:	8f55                	or	a4,a4,a3
    8001901a:	d2e43c23          	sd	a4,-712(s0)
    8001901e:	e0043703          	ld	a4,-512(s0)
    80019022:	0716                	slli	a4,a4,0x5
    80019024:	d2e43823          	sd	a4,-720(s0)
    80019028:	def43823          	sd	a5,-528(s0)
    8001902c:	de043c23          	sd	zero,-520(s0)
    80019030:	df043703          	ld	a4,-528(s0)
    80019034:	936d                	srli	a4,a4,0x3b
    80019036:	df843683          	ld	a3,-520(s0)
    8001903a:	0696                	slli	a3,a3,0x5
    8001903c:	d2d43423          	sd	a3,-728(s0)
    80019040:	d2843683          	ld	a3,-728(s0)
    80019044:	8f55                	or	a4,a4,a3
    80019046:	d2e43423          	sd	a4,-728(s0)
    8001904a:	df043703          	ld	a4,-528(s0)
    8001904e:	0716                	slli	a4,a4,0x5
    80019050:	d2e43023          	sd	a4,-736(s0)
    80019054:	078a                	slli	a5,a5,0x2
    80019056:	07bd                	addi	a5,a5,15
    80019058:	8391                	srli	a5,a5,0x4
    8001905a:	0792                	slli	a5,a5,0x4
    8001905c:	40f10133          	sub	sp,sp,a5
    80019060:	878a                	mv	a5,sp
    80019062:	078d                	addi	a5,a5,3
    80019064:	8389                	srli	a5,a5,0x2
    80019066:	078a                	slli	a5,a5,0x2
    80019068:	f4f43023          	sd	a5,-192(s0)
        // We're done
        minix3_get_zone(block_device, inode_data.zones[8], (uint8_t*)double_indirect_zones);
    8001906c:	eb042783          	lw	a5,-336(s0)
    80019070:	f4043603          	ld	a2,-192(s0)
    80019074:	85be                	mv	a1,a5
    80019076:	e6843503          	ld	a0,-408(s0)
    8001907a:	9effe0ef          	jal	ra,80017a68 <minix3_get_zone>

        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    8001907e:	f80407a3          	sb	zero,-113(s0)
    80019082:	a4e9                	j	8001934c <minix3_get_data+0x900>
    80019084:	878a                	mv	a5,sp
    80019086:	84be                	mv	s1,a5
            uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80019088:	f8f44783          	lbu	a5,-113(s0)
    8001908c:	2781                	sext.w	a5,a5
    8001908e:	f4043703          	ld	a4,-192(s0)
    80019092:	078a                	slli	a5,a5,0x2
    80019094:	97ba                	add	a5,a5,a4
    80019096:	439c                	lw	a5,0(a5)
    80019098:	f2f42e23          	sw	a5,-196(s0)
            if (indirect_zone == 0) continue;
    8001909c:	f3c42783          	lw	a5,-196(s0)
    800190a0:	2781                	sext.w	a5,a5
    800190a2:	e399                	bnez	a5,800190a8 <minix3_get_data+0x65c>
    800190a4:	8126                	mv	sp,s1
    800190a6:	ac71                	j	80019342 <minix3_get_data+0x8f6>

            uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    800190a8:	e6843503          	ld	a0,-408(s0)
    800190ac:	e5ffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800190b0:	87aa                	mv	a5,a0
    800190b2:	0027d79b          	srliw	a5,a5,0x2
    800190b6:	17c2                	slli	a5,a5,0x30
    800190b8:	93c1                	srli	a5,a5,0x30
    800190ba:	873e                	mv	a4,a5
    800190bc:	177d                	addi	a4,a4,-1
    800190be:	f2e43823          	sd	a4,-208(s0)
    800190c2:	def43023          	sd	a5,-544(s0)
    800190c6:	de043423          	sd	zero,-536(s0)
    800190ca:	de043703          	ld	a4,-544(s0)
    800190ce:	936d                	srli	a4,a4,0x3b
    800190d0:	de843683          	ld	a3,-536(s0)
    800190d4:	00569a93          	slli	s5,a3,0x5
    800190d8:	01576ab3          	or	s5,a4,s5
    800190dc:	de043703          	ld	a4,-544(s0)
    800190e0:	00571a13          	slli	s4,a4,0x5
    800190e4:	dcf43823          	sd	a5,-560(s0)
    800190e8:	dc043c23          	sd	zero,-552(s0)
    800190ec:	dd043703          	ld	a4,-560(s0)
    800190f0:	936d                	srli	a4,a4,0x3b
    800190f2:	dd843683          	ld	a3,-552(s0)
    800190f6:	0696                	slli	a3,a3,0x5
    800190f8:	d0d43c23          	sd	a3,-744(s0)
    800190fc:	d1843683          	ld	a3,-744(s0)
    80019100:	8f55                	or	a4,a4,a3
    80019102:	d0e43c23          	sd	a4,-744(s0)
    80019106:	dd043703          	ld	a4,-560(s0)
    8001910a:	0716                	slli	a4,a4,0x5
    8001910c:	d0e43823          	sd	a4,-752(s0)
    80019110:	078a                	slli	a5,a5,0x2
    80019112:	07bd                	addi	a5,a5,15
    80019114:	8391                	srli	a5,a5,0x4
    80019116:	0792                	slli	a5,a5,0x4
    80019118:	40f10133          	sub	sp,sp,a5
    8001911c:	878a                	mv	a5,sp
    8001911e:	078d                	addi	a5,a5,3
    80019120:	8389                	srli	a5,a5,0x2
    80019122:	078a                	slli	a5,a5,0x2
    80019124:	f2f43423          	sd	a5,-216(s0)
            minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    80019128:	f3c42783          	lw	a5,-196(s0)
    8001912c:	f2843603          	ld	a2,-216(s0)
    80019130:	85be                	mv	a1,a5
    80019132:	e6843503          	ld	a0,-408(s0)
    80019136:	933fe0ef          	jal	ra,80017a68 <minix3_get_zone>

            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001913a:	f80401a3          	sb	zero,-125(s0)
    8001913e:	aae9                	j	80019318 <minix3_get_data+0x8cc>
                uint32_t zone = indirect_zones[indirect_zone];
    80019140:	f8344783          	lbu	a5,-125(s0)
    80019144:	2781                	sext.w	a5,a5
    80019146:	f2843703          	ld	a4,-216(s0)
    8001914a:	078a                	slli	a5,a5,0x2
    8001914c:	97ba                	add	a5,a5,a4
    8001914e:	439c                	lw	a5,0(a5)
    80019150:	f2f42223          	sw	a5,-220(s0)
                if (zone == 0) continue;
    80019154:	f2442783          	lw	a5,-220(s0)
    80019158:	2781                	sext.w	a5,a5
    8001915a:	1a078963          	beqz	a5,8001930c <minix3_get_data+0x8c0>
                debugf("Reading double indirect zone %d\n", zone);

                if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    8001915e:	e6843503          	ld	a0,-408(s0)
    80019162:	da9fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019166:	87aa                	mv	a5,a0
    80019168:	2781                	sext.w	a5,a5
    8001916a:	f8842703          	lw	a4,-120(s0)
    8001916e:	9fb9                	addw	a5,a5,a4
    80019170:	0007871b          	sext.w	a4,a5
    80019174:	e6042783          	lw	a5,-416(s0)
    80019178:	2781                	sext.w	a5,a5
    8001917a:	00f77e63          	bgeu	a4,a5,80019196 <minix3_get_data+0x74a>
                    // We're not at the offset yet
                    file_cursor += minix3_get_zone_size(block_device);
    8001917e:	e6843503          	ld	a0,-408(s0)
    80019182:	d89fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019186:	87aa                	mv	a5,a0
    80019188:	2781                	sext.w	a5,a5
    8001918a:	f8842703          	lw	a4,-120(s0)
    8001918e:	9fb9                	addw	a5,a5,a4
    80019190:	f8f42423          	sw	a5,-120(s0)
                    continue;
    80019194:	aaad                	j	8001930e <minix3_get_data+0x8c2>
                } else if (file_cursor < offset) {
    80019196:	f8842703          	lw	a4,-120(s0)
    8001919a:	e6042783          	lw	a5,-416(s0)
    8001919e:	2701                	sext.w	a4,a4
    800191a0:	2781                	sext.w	a5,a5
    800191a2:	0af77b63          	bgeu	a4,a5,80019258 <minix3_get_data+0x80c>
                    // We're in the middle of the offset
                    // Read the zone into the buffer
                    minix3_get_zone(block_device, zone, zone_data);
    800191a6:	f2442783          	lw	a5,-220(s0)
    800191aa:	f7043603          	ld	a2,-144(s0)
    800191ae:	85be                	mv	a1,a5
    800191b0:	e6843503          	ld	a0,-408(s0)
    800191b4:	8b5fe0ef          	jal	ra,80017a68 <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    800191b8:	e6843503          	ld	a0,-408(s0)
    800191bc:	d4ffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800191c0:	87aa                	mv	a5,a0
    800191c2:	0007871b          	sext.w	a4,a5
    800191c6:	f8842683          	lw	a3,-120(s0)
    800191ca:	e6042783          	lw	a5,-416(s0)
    800191ce:	40f687bb          	subw	a5,a3,a5
    800191d2:	2781                	sext.w	a5,a5
    800191d4:	9fb9                	addw	a5,a5,a4
    800191d6:	0007871b          	sext.w	a4,a5
    800191da:	e5442783          	lw	a5,-428(s0)
    800191de:	2781                	sext.w	a5,a5
    800191e0:	02e7e563          	bltu	a5,a4,8001920a <minix3_get_data+0x7be>
    800191e4:	e6843503          	ld	a0,-408(s0)
    800191e8:	d23fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800191ec:	87aa                	mv	a5,a0
    800191ee:	0007871b          	sext.w	a4,a5
    800191f2:	f8842683          	lw	a3,-120(s0)
    800191f6:	e6042783          	lw	a5,-416(s0)
    800191fa:	40f687bb          	subw	a5,a3,a5
    800191fe:	2781                	sext.w	a5,a5
    80019200:	9fb9                	addw	a5,a5,a4
    80019202:	2781                	sext.w	a5,a5
    80019204:	1782                	slli	a5,a5,0x20
    80019206:	9381                	srli	a5,a5,0x20
    80019208:	a019                	j	8001920e <minix3_get_data+0x7c2>
    8001920a:	e5446783          	lwu	a5,-428(s0)
    8001920e:	f0f43c23          	sd	a5,-232(s0)
                    memcpy(data, zone_data + offset - file_cursor, remaining);
    80019212:	e6046703          	lwu	a4,-416(s0)
    80019216:	f8846783          	lwu	a5,-120(s0)
    8001921a:	40f707b3          	sub	a5,a4,a5
    8001921e:	f7043703          	ld	a4,-144(s0)
    80019222:	97ba                	add	a5,a5,a4
    80019224:	f1843703          	ld	a4,-232(s0)
    80019228:	2701                	sext.w	a4,a4
    8001922a:	863a                	mv	a2,a4
    8001922c:	85be                	mv	a1,a5
    8001922e:	e5843503          	ld	a0,-424(s0)
    80019232:	10c090ef          	jal	ra,8002233e <memcpy>
                    buffer_cursor += remaining;
    80019236:	f1843783          	ld	a5,-232(s0)
    8001923a:	2781                	sext.w	a5,a5
    8001923c:	f8442703          	lw	a4,-124(s0)
    80019240:	9fb9                	addw	a5,a5,a4
    80019242:	f8f42223          	sw	a5,-124(s0)
                    file_cursor = offset + remaining;
    80019246:	f1843783          	ld	a5,-232(s0)
    8001924a:	2781                	sext.w	a5,a5
    8001924c:	e6042703          	lw	a4,-416(s0)
    80019250:	9fb9                	addw	a5,a5,a4
    80019252:	f8f42423          	sw	a5,-120(s0)
                    continue;
    80019256:	a865                	j	8001930e <minix3_get_data+0x8c2>
                }
                
                // Read the zone into the buffer
                memset(zone_data, 0, minix3_get_zone_size(block_device));
    80019258:	e6843503          	ld	a0,-408(s0)
    8001925c:	caffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019260:	87aa                	mv	a5,a0
    80019262:	2781                	sext.w	a5,a5
    80019264:	863e                	mv	a2,a5
    80019266:	4581                	li	a1,0
    80019268:	f7043503          	ld	a0,-144(s0)
    8001926c:	7d1080ef          	jal	ra,8002223c <memset>
                minix3_get_zone(block_device, zone, zone_data);
    80019270:	f2442783          	lw	a5,-220(s0)
    80019274:	f7043603          	ld	a2,-144(s0)
    80019278:	85be                	mv	a1,a5
    8001927a:	e6843503          	ld	a0,-408(s0)
    8001927e:	feafe0ef          	jal	ra,80017a68 <minix3_get_zone>

                // If the cursor is past the amount of data we want, we're done
                if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80019282:	e6843503          	ld	a0,-408(s0)
    80019286:	c85fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001928a:	87aa                	mv	a5,a0
    8001928c:	2781                	sext.w	a5,a5
    8001928e:	f8442703          	lw	a4,-124(s0)
    80019292:	9fb9                	addw	a5,a5,a4
    80019294:	0007871b          	sext.w	a4,a5
    80019298:	e5442783          	lw	a5,-428(s0)
    8001929c:	2781                	sext.w	a5,a5
    8001929e:	02e7f963          	bgeu	a5,a4,800192d0 <minix3_get_data+0x884>
                    // Copy the remaining data into the buffer
                    memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    800192a2:	f8446783          	lwu	a5,-124(s0)
    800192a6:	e5843703          	ld	a4,-424(s0)
    800192aa:	00f706b3          	add	a3,a4,a5
    800192ae:	e5442703          	lw	a4,-428(s0)
    800192b2:	f8442783          	lw	a5,-124(s0)
    800192b6:	40f707bb          	subw	a5,a4,a5
    800192ba:	2781                	sext.w	a5,a5
    800192bc:	2781                	sext.w	a5,a5
    800192be:	863e                	mv	a2,a5
    800192c0:	f7043583          	ld	a1,-144(s0)
    800192c4:	8536                	mv	a0,a3
    800192c6:	078090ef          	jal	ra,8002233e <memcpy>
    800192ca:	8126                	mv	sp,s1
    800192cc:	814e                	mv	sp,s3
    800192ce:	a33d                	j	800197fc <minix3_get_data+0xdb0>
                    // We're done
                    return;
                } else {
                    // Copy the entire zone into the buffer
                    memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    800192d0:	f8446783          	lwu	a5,-124(s0)
    800192d4:	e5843703          	ld	a4,-424(s0)
    800192d8:	00f70933          	add	s2,a4,a5
    800192dc:	e6843503          	ld	a0,-408(s0)
    800192e0:	c2bfe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800192e4:	87aa                	mv	a5,a0
    800192e6:	2781                	sext.w	a5,a5
    800192e8:	863e                	mv	a2,a5
    800192ea:	f7043583          	ld	a1,-144(s0)
    800192ee:	854a                	mv	a0,s2
    800192f0:	04e090ef          	jal	ra,8002233e <memcpy>
                }
                buffer_cursor += minix3_get_zone_size(block_device);
    800192f4:	e6843503          	ld	a0,-408(s0)
    800192f8:	c13fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800192fc:	87aa                	mv	a5,a0
    800192fe:	2781                	sext.w	a5,a5
    80019300:	f8442703          	lw	a4,-124(s0)
    80019304:	9fb9                	addw	a5,a5,a4
    80019306:	f8f42223          	sw	a5,-124(s0)
    8001930a:	a011                	j	8001930e <minix3_get_data+0x8c2>
                if (zone == 0) continue;
    8001930c:	0001                	nop
            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001930e:	f8344783          	lbu	a5,-125(s0)
    80019312:	2785                	addiw	a5,a5,1
    80019314:	f8f401a3          	sb	a5,-125(s0)
    80019318:	f8344783          	lbu	a5,-125(s0)
    8001931c:	03079913          	slli	s2,a5,0x30
    80019320:	03095913          	srli	s2,s2,0x30
    80019324:	e6843503          	ld	a0,-408(s0)
    80019328:	be3fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001932c:	87aa                	mv	a5,a0
    8001932e:	0027d79b          	srliw	a5,a5,0x2
    80019332:	17c2                	slli	a5,a5,0x30
    80019334:	93c1                	srli	a5,a5,0x30
    80019336:	0009071b          	sext.w	a4,s2
    8001933a:	2781                	sext.w	a5,a5
    8001933c:	e0f762e3          	bltu	a4,a5,80019140 <minix3_get_data+0x6f4>
    80019340:	8126                	mv	sp,s1
        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80019342:	f8f44783          	lbu	a5,-113(s0)
    80019346:	2785                	addiw	a5,a5,1
    80019348:	f8f407a3          	sb	a5,-113(s0)
    8001934c:	f8f44783          	lbu	a5,-113(s0)
    80019350:	03079493          	slli	s1,a5,0x30
    80019354:	90c1                	srli	s1,s1,0x30
    80019356:	e6843503          	ld	a0,-408(s0)
    8001935a:	bb1fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001935e:	87aa                	mv	a5,a0
    80019360:	0027d79b          	srliw	a5,a5,0x2
    80019364:	17c2                	slli	a5,a5,0x30
    80019366:	93c1                	srli	a5,a5,0x30
    80019368:	0004871b          	sext.w	a4,s1
    8001936c:	2781                	sext.w	a5,a5
    8001936e:	d0f76be3          	bltu	a4,a5,80019084 <minix3_get_data+0x638>
    80019372:	814e                	mv	sp,s3
    } else {
        debugf("No double indirect zone\n");
    }

    // The next zone is a triple indirect zone
    if (inode_data.zones[9] != 0) {
    80019374:	eb442783          	lw	a5,-332(s0)
    80019378:	48078163          	beqz	a5,800197fa <minix3_get_data+0xdae>
    8001937c:	878a                	mv	a5,sp
    8001937e:	8a3e                	mv	s4,a5
        uint32_t triple_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80019380:	e6843503          	ld	a0,-408(s0)
    80019384:	b87fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019388:	87aa                	mv	a5,a0
    8001938a:	0027d79b          	srliw	a5,a5,0x2
    8001938e:	17c2                	slli	a5,a5,0x30
    80019390:	93c1                	srli	a5,a5,0x30
    80019392:	873e                	mv	a4,a5
    80019394:	177d                	addi	a4,a4,-1
    80019396:	f0e43823          	sd	a4,-240(s0)
    8001939a:	dcf43023          	sd	a5,-576(s0)
    8001939e:	dc043423          	sd	zero,-568(s0)
    800193a2:	dc043703          	ld	a4,-576(s0)
    800193a6:	936d                	srli	a4,a4,0x3b
    800193a8:	dc843683          	ld	a3,-568(s0)
    800193ac:	0696                	slli	a3,a3,0x5
    800193ae:	d0d43423          	sd	a3,-760(s0)
    800193b2:	d0843683          	ld	a3,-760(s0)
    800193b6:	8f55                	or	a4,a4,a3
    800193b8:	d0e43423          	sd	a4,-760(s0)
    800193bc:	dc043703          	ld	a4,-576(s0)
    800193c0:	0716                	slli	a4,a4,0x5
    800193c2:	d0e43023          	sd	a4,-768(s0)
    800193c6:	daf43823          	sd	a5,-592(s0)
    800193ca:	da043c23          	sd	zero,-584(s0)
    800193ce:	db043703          	ld	a4,-592(s0)
    800193d2:	936d                	srli	a4,a4,0x3b
    800193d4:	db843683          	ld	a3,-584(s0)
    800193d8:	0696                	slli	a3,a3,0x5
    800193da:	ced43c23          	sd	a3,-776(s0)
    800193de:	cf843683          	ld	a3,-776(s0)
    800193e2:	8f55                	or	a4,a4,a3
    800193e4:	cee43c23          	sd	a4,-776(s0)
    800193e8:	db043703          	ld	a4,-592(s0)
    800193ec:	0716                	slli	a4,a4,0x5
    800193ee:	cee43823          	sd	a4,-784(s0)
    800193f2:	078a                	slli	a5,a5,0x2
    800193f4:	07bd                	addi	a5,a5,15
    800193f6:	8391                	srli	a5,a5,0x4
    800193f8:	0792                	slli	a5,a5,0x4
    800193fa:	40f10133          	sub	sp,sp,a5
    800193fe:	878a                	mv	a5,sp
    80019400:	078d                	addi	a5,a5,3
    80019402:	8389                	srli	a5,a5,0x2
    80019404:	078a                	slli	a5,a5,0x2
    80019406:	f0f43423          	sd	a5,-248(s0)
        minix3_get_zone(block_device, inode_data.zones[9], (uint8_t*)triple_indirect_zones);
    8001940a:	eb442783          	lw	a5,-332(s0)
    8001940e:	f0843603          	ld	a2,-248(s0)
    80019412:	85be                	mv	a1,a5
    80019414:	e6843503          	ld	a0,-408(s0)
    80019418:	e50fe0ef          	jal	ra,80017a68 <minix3_get_zone>

        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    8001941c:	f8040123          	sb	zero,-126(s0)
    80019420:	ae4d                	j	800197d2 <minix3_get_data+0xd86>
    80019422:	878a                	mv	a5,sp
    80019424:	84be                	mv	s1,a5
            uint32_t double_indirect_zone = triple_indirect_zones[triple_indirect_zone];
    80019426:	f8244783          	lbu	a5,-126(s0)
    8001942a:	2781                	sext.w	a5,a5
    8001942c:	f0843703          	ld	a4,-248(s0)
    80019430:	078a                	slli	a5,a5,0x2
    80019432:	97ba                	add	a5,a5,a4
    80019434:	439c                	lw	a5,0(a5)
    80019436:	f0f42223          	sw	a5,-252(s0)
            if (double_indirect_zone == 0) continue;
    8001943a:	f0442783          	lw	a5,-252(s0)
    8001943e:	2781                	sext.w	a5,a5
    80019440:	e399                	bnez	a5,80019446 <minix3_get_data+0x9fa>
    80019442:	8126                	mv	sp,s1
    80019444:	a651                	j	800197c8 <minix3_get_data+0xd7c>
            uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80019446:	e6843503          	ld	a0,-408(s0)
    8001944a:	ac1fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001944e:	87aa                	mv	a5,a0
    80019450:	0027d79b          	srliw	a5,a5,0x2
    80019454:	17c2                	slli	a5,a5,0x30
    80019456:	93c1                	srli	a5,a5,0x30
    80019458:	873e                	mv	a4,a5
    8001945a:	177d                	addi	a4,a4,-1
    8001945c:	eee43c23          	sd	a4,-264(s0)
    80019460:	daf43023          	sd	a5,-608(s0)
    80019464:	da043423          	sd	zero,-600(s0)
    80019468:	da043703          	ld	a4,-608(s0)
    8001946c:	936d                	srli	a4,a4,0x3b
    8001946e:	da843683          	ld	a3,-600(s0)
    80019472:	00569b93          	slli	s7,a3,0x5
    80019476:	01776bb3          	or	s7,a4,s7
    8001947a:	da043703          	ld	a4,-608(s0)
    8001947e:	00571b13          	slli	s6,a4,0x5
    80019482:	d8f43823          	sd	a5,-624(s0)
    80019486:	d8043c23          	sd	zero,-616(s0)
    8001948a:	d9043703          	ld	a4,-624(s0)
    8001948e:	936d                	srli	a4,a4,0x3b
    80019490:	d9843683          	ld	a3,-616(s0)
    80019494:	00569c93          	slli	s9,a3,0x5
    80019498:	01976cb3          	or	s9,a4,s9
    8001949c:	d9043703          	ld	a4,-624(s0)
    800194a0:	00571c13          	slli	s8,a4,0x5
    800194a4:	078a                	slli	a5,a5,0x2
    800194a6:	07bd                	addi	a5,a5,15
    800194a8:	8391                	srli	a5,a5,0x4
    800194aa:	0792                	slli	a5,a5,0x4
    800194ac:	40f10133          	sub	sp,sp,a5
    800194b0:	878a                	mv	a5,sp
    800194b2:	078d                	addi	a5,a5,3
    800194b4:	8389                	srli	a5,a5,0x2
    800194b6:	078a                	slli	a5,a5,0x2
    800194b8:	eef43823          	sd	a5,-272(s0)
            minix3_get_zone(block_device, double_indirect_zone, (uint8_t*)double_indirect_zones);
    800194bc:	f0442783          	lw	a5,-252(s0)
    800194c0:	ef043603          	ld	a2,-272(s0)
    800194c4:	85be                	mv	a1,a5
    800194c6:	e6843503          	ld	a0,-408(s0)
    800194ca:	d9efe0ef          	jal	ra,80017a68 <minix3_get_zone>

            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    800194ce:	f80400a3          	sb	zero,-127(s0)
    800194d2:	a4f1                	j	8001979e <minix3_get_data+0xd52>
    800194d4:	878a                	mv	a5,sp
    800194d6:	893e                	mv	s2,a5
                uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    800194d8:	f8144783          	lbu	a5,-127(s0)
    800194dc:	2781                	sext.w	a5,a5
    800194de:	ef043703          	ld	a4,-272(s0)
    800194e2:	078a                	slli	a5,a5,0x2
    800194e4:	97ba                	add	a5,a5,a4
    800194e6:	439c                	lw	a5,0(a5)
    800194e8:	eef42623          	sw	a5,-276(s0)
                if (indirect_zone == 0) continue;
    800194ec:	eec42783          	lw	a5,-276(s0)
    800194f0:	2781                	sext.w	a5,a5
    800194f2:	e399                	bnez	a5,800194f8 <minix3_get_data+0xaac>
    800194f4:	814a                	mv	sp,s2
    800194f6:	ac79                	j	80019794 <minix3_get_data+0xd48>
                uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    800194f8:	e6843503          	ld	a0,-408(s0)
    800194fc:	a0ffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019500:	87aa                	mv	a5,a0
    80019502:	0027d79b          	srliw	a5,a5,0x2
    80019506:	17c2                	slli	a5,a5,0x30
    80019508:	93c1                	srli	a5,a5,0x30
    8001950a:	873e                	mv	a4,a5
    8001950c:	177d                	addi	a4,a4,-1
    8001950e:	eee43023          	sd	a4,-288(s0)
    80019512:	d8f43023          	sd	a5,-640(s0)
    80019516:	d8043423          	sd	zero,-632(s0)
    8001951a:	d8043703          	ld	a4,-640(s0)
    8001951e:	936d                	srli	a4,a4,0x3b
    80019520:	d8843683          	ld	a3,-632(s0)
    80019524:	00569d93          	slli	s11,a3,0x5
    80019528:	01b76db3          	or	s11,a4,s11
    8001952c:	d8043703          	ld	a4,-640(s0)
    80019530:	00571d13          	slli	s10,a4,0x5
    80019534:	d6f43823          	sd	a5,-656(s0)
    80019538:	d6043c23          	sd	zero,-648(s0)
    8001953c:	d7043703          	ld	a4,-656(s0)
    80019540:	936d                	srli	a4,a4,0x3b
    80019542:	d7843683          	ld	a3,-648(s0)
    80019546:	0696                	slli	a3,a3,0x5
    80019548:	ced43423          	sd	a3,-792(s0)
    8001954c:	ce843683          	ld	a3,-792(s0)
    80019550:	8f55                	or	a4,a4,a3
    80019552:	cee43423          	sd	a4,-792(s0)
    80019556:	d7043703          	ld	a4,-656(s0)
    8001955a:	0716                	slli	a4,a4,0x5
    8001955c:	cee43023          	sd	a4,-800(s0)
    80019560:	078a                	slli	a5,a5,0x2
    80019562:	07bd                	addi	a5,a5,15
    80019564:	8391                	srli	a5,a5,0x4
    80019566:	0792                	slli	a5,a5,0x4
    80019568:	40f10133          	sub	sp,sp,a5
    8001956c:	878a                	mv	a5,sp
    8001956e:	078d                	addi	a5,a5,3
    80019570:	8389                	srli	a5,a5,0x2
    80019572:	078a                	slli	a5,a5,0x2
    80019574:	ecf43c23          	sd	a5,-296(s0)
                minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    80019578:	eec42783          	lw	a5,-276(s0)
    8001957c:	ed843603          	ld	a2,-296(s0)
    80019580:	85be                	mv	a1,a5
    80019582:	e6843503          	ld	a0,-408(s0)
    80019586:	ce2fe0ef          	jal	ra,80017a68 <minix3_get_zone>

                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001958a:	f8040023          	sb	zero,-128(s0)
    8001958e:	aaf1                	j	8001976a <minix3_get_data+0xd1e>
                    uint32_t zone = indirect_zones[indirect_zone];
    80019590:	f8044783          	lbu	a5,-128(s0)
    80019594:	2781                	sext.w	a5,a5
    80019596:	ed843703          	ld	a4,-296(s0)
    8001959a:	078a                	slli	a5,a5,0x2
    8001959c:	97ba                	add	a5,a5,a4
    8001959e:	439c                	lw	a5,0(a5)
    800195a0:	ecf42a23          	sw	a5,-300(s0)
                    if (zone == 0) continue;
    800195a4:	ed442783          	lw	a5,-300(s0)
    800195a8:	2781                	sext.w	a5,a5
    800195aa:	1a078a63          	beqz	a5,8001975e <minix3_get_data+0xd12>
                    debugf("Reading triple indirect zone %d\n", zone);
                    
                    if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    800195ae:	e6843503          	ld	a0,-408(s0)
    800195b2:	959fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800195b6:	87aa                	mv	a5,a0
    800195b8:	2781                	sext.w	a5,a5
    800195ba:	f8842703          	lw	a4,-120(s0)
    800195be:	9fb9                	addw	a5,a5,a4
    800195c0:	0007871b          	sext.w	a4,a5
    800195c4:	e6042783          	lw	a5,-416(s0)
    800195c8:	2781                	sext.w	a5,a5
    800195ca:	00f77e63          	bgeu	a4,a5,800195e6 <minix3_get_data+0xb9a>
                        // We're not at the offset yet
                        file_cursor += minix3_get_zone_size(block_device);
    800195ce:	e6843503          	ld	a0,-408(s0)
    800195d2:	939fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800195d6:	87aa                	mv	a5,a0
    800195d8:	2781                	sext.w	a5,a5
    800195da:	f8842703          	lw	a4,-120(s0)
    800195de:	9fb9                	addw	a5,a5,a4
    800195e0:	f8f42423          	sw	a5,-120(s0)
                        continue;
    800195e4:	aab5                	j	80019760 <minix3_get_data+0xd14>
                    } else if (file_cursor < offset) {
    800195e6:	f8842703          	lw	a4,-120(s0)
    800195ea:	e6042783          	lw	a5,-416(s0)
    800195ee:	2701                	sext.w	a4,a4
    800195f0:	2781                	sext.w	a5,a5
    800195f2:	0af77b63          	bgeu	a4,a5,800196a8 <minix3_get_data+0xc5c>
                        // We're in the middle of the offset
                        // Read the zone into the buffer
                        minix3_get_zone(block_device, zone, zone_data);
    800195f6:	ed442783          	lw	a5,-300(s0)
    800195fa:	f7043603          	ld	a2,-144(s0)
    800195fe:	85be                	mv	a1,a5
    80019600:	e6843503          	ld	a0,-408(s0)
    80019604:	c64fe0ef          	jal	ra,80017a68 <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80019608:	e6843503          	ld	a0,-408(s0)
    8001960c:	8fffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019610:	87aa                	mv	a5,a0
    80019612:	0007871b          	sext.w	a4,a5
    80019616:	f8842683          	lw	a3,-120(s0)
    8001961a:	e6042783          	lw	a5,-416(s0)
    8001961e:	40f687bb          	subw	a5,a3,a5
    80019622:	2781                	sext.w	a5,a5
    80019624:	9fb9                	addw	a5,a5,a4
    80019626:	0007871b          	sext.w	a4,a5
    8001962a:	e5442783          	lw	a5,-428(s0)
    8001962e:	2781                	sext.w	a5,a5
    80019630:	02e7e563          	bltu	a5,a4,8001965a <minix3_get_data+0xc0e>
    80019634:	e6843503          	ld	a0,-408(s0)
    80019638:	8d3fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001963c:	87aa                	mv	a5,a0
    8001963e:	0007871b          	sext.w	a4,a5
    80019642:	f8842683          	lw	a3,-120(s0)
    80019646:	e6042783          	lw	a5,-416(s0)
    8001964a:	40f687bb          	subw	a5,a3,a5
    8001964e:	2781                	sext.w	a5,a5
    80019650:	9fb9                	addw	a5,a5,a4
    80019652:	2781                	sext.w	a5,a5
    80019654:	1782                	slli	a5,a5,0x20
    80019656:	9381                	srli	a5,a5,0x20
    80019658:	a019                	j	8001965e <minix3_get_data+0xc12>
    8001965a:	e5446783          	lwu	a5,-428(s0)
    8001965e:	ecf43423          	sd	a5,-312(s0)
                        memcpy(data, zone_data + offset - file_cursor, remaining);
    80019662:	e6046703          	lwu	a4,-416(s0)
    80019666:	f8846783          	lwu	a5,-120(s0)
    8001966a:	40f707b3          	sub	a5,a4,a5
    8001966e:	f7043703          	ld	a4,-144(s0)
    80019672:	97ba                	add	a5,a5,a4
    80019674:	ec843703          	ld	a4,-312(s0)
    80019678:	2701                	sext.w	a4,a4
    8001967a:	863a                	mv	a2,a4
    8001967c:	85be                	mv	a1,a5
    8001967e:	e5843503          	ld	a0,-424(s0)
    80019682:	4bd080ef          	jal	ra,8002233e <memcpy>
                        buffer_cursor += remaining;
    80019686:	ec843783          	ld	a5,-312(s0)
    8001968a:	2781                	sext.w	a5,a5
    8001968c:	f8442703          	lw	a4,-124(s0)
    80019690:	9fb9                	addw	a5,a5,a4
    80019692:	f8f42223          	sw	a5,-124(s0)
                        file_cursor = offset + remaining;
    80019696:	ec843783          	ld	a5,-312(s0)
    8001969a:	2781                	sext.w	a5,a5
    8001969c:	e6042703          	lw	a4,-416(s0)
    800196a0:	9fb9                	addw	a5,a5,a4
    800196a2:	f8f42423          	sw	a5,-120(s0)
                        continue;
    800196a6:	a86d                	j	80019760 <minix3_get_data+0xd14>
                    }
                
                    
                    // Read the zone into the buffer
                    memset(zone_data, 0, minix3_get_zone_size(block_device));
    800196a8:	e6843503          	ld	a0,-408(s0)
    800196ac:	85ffe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800196b0:	87aa                	mv	a5,a0
    800196b2:	2781                	sext.w	a5,a5
    800196b4:	863e                	mv	a2,a5
    800196b6:	4581                	li	a1,0
    800196b8:	f7043503          	ld	a0,-144(s0)
    800196bc:	381080ef          	jal	ra,8002223c <memset>
                    minix3_get_zone(block_device, zone, zone_data);
    800196c0:	ed442783          	lw	a5,-300(s0)
    800196c4:	f7043603          	ld	a2,-144(s0)
    800196c8:	85be                	mv	a1,a5
    800196ca:	e6843503          	ld	a0,-408(s0)
    800196ce:	b9afe0ef          	jal	ra,80017a68 <minix3_get_zone>

                    // If the cursor is past the amount of data we want, we're done
                    if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    800196d2:	e6843503          	ld	a0,-408(s0)
    800196d6:	835fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800196da:	87aa                	mv	a5,a0
    800196dc:	2781                	sext.w	a5,a5
    800196de:	f8442703          	lw	a4,-124(s0)
    800196e2:	9fb9                	addw	a5,a5,a4
    800196e4:	0007871b          	sext.w	a4,a5
    800196e8:	e5442783          	lw	a5,-428(s0)
    800196ec:	2781                	sext.w	a5,a5
    800196ee:	02e7fa63          	bgeu	a5,a4,80019722 <minix3_get_data+0xcd6>
                        // Copy the remaining data into the buffer
                        memcpy(data + buffer_cursor, zone_data, count - buffer_cursor);
    800196f2:	f8446783          	lwu	a5,-124(s0)
    800196f6:	e5843703          	ld	a4,-424(s0)
    800196fa:	00f706b3          	add	a3,a4,a5
    800196fe:	e5442703          	lw	a4,-428(s0)
    80019702:	f8442783          	lw	a5,-124(s0)
    80019706:	40f707bb          	subw	a5,a4,a5
    8001970a:	2781                	sext.w	a5,a5
    8001970c:	2781                	sext.w	a5,a5
    8001970e:	863e                	mv	a2,a5
    80019710:	f7043583          	ld	a1,-144(s0)
    80019714:	8536                	mv	a0,a3
    80019716:	429080ef          	jal	ra,8002233e <memcpy>
    8001971a:	814a                	mv	sp,s2
    8001971c:	8126                	mv	sp,s1
    8001971e:	8152                	mv	sp,s4
    80019720:	a8f1                	j	800197fc <minix3_get_data+0xdb0>
                        // We're done
                        return;
                    } else {
                        // Copy the entire zone into the buffer
                        memcpy(data + buffer_cursor, zone_data, minix3_get_zone_size(block_device));
    80019722:	f8446783          	lwu	a5,-124(s0)
    80019726:	e5843703          	ld	a4,-424(s0)
    8001972a:	00f709b3          	add	s3,a4,a5
    8001972e:	e6843503          	ld	a0,-408(s0)
    80019732:	fd8fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019736:	87aa                	mv	a5,a0
    80019738:	2781                	sext.w	a5,a5
    8001973a:	863e                	mv	a2,a5
    8001973c:	f7043583          	ld	a1,-144(s0)
    80019740:	854e                	mv	a0,s3
    80019742:	3fd080ef          	jal	ra,8002233e <memcpy>
                    }
                    buffer_cursor += minix3_get_zone_size(block_device);
    80019746:	e6843503          	ld	a0,-408(s0)
    8001974a:	fc0fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001974e:	87aa                	mv	a5,a0
    80019750:	2781                	sext.w	a5,a5
    80019752:	f8442703          	lw	a4,-124(s0)
    80019756:	9fb9                	addw	a5,a5,a4
    80019758:	f8f42223          	sw	a5,-124(s0)
    8001975c:	a011                	j	80019760 <minix3_get_data+0xd14>
                    if (zone == 0) continue;
    8001975e:	0001                	nop
                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80019760:	f8044783          	lbu	a5,-128(s0)
    80019764:	2785                	addiw	a5,a5,1
    80019766:	f8f40023          	sb	a5,-128(s0)
    8001976a:	f8044783          	lbu	a5,-128(s0)
    8001976e:	03079993          	slli	s3,a5,0x30
    80019772:	0309d993          	srli	s3,s3,0x30
    80019776:	e6843503          	ld	a0,-408(s0)
    8001977a:	f90fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001977e:	87aa                	mv	a5,a0
    80019780:	0027d79b          	srliw	a5,a5,0x2
    80019784:	17c2                	slli	a5,a5,0x30
    80019786:	93c1                	srli	a5,a5,0x30
    80019788:	0009871b          	sext.w	a4,s3
    8001978c:	2781                	sext.w	a5,a5
    8001978e:	e0f761e3          	bltu	a4,a5,80019590 <minix3_get_data+0xb44>
    80019792:	814a                	mv	sp,s2
            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80019794:	f8144783          	lbu	a5,-127(s0)
    80019798:	2785                	addiw	a5,a5,1
    8001979a:	f8f400a3          	sb	a5,-127(s0)
    8001979e:	f8144783          	lbu	a5,-127(s0)
    800197a2:	03079913          	slli	s2,a5,0x30
    800197a6:	03095913          	srli	s2,s2,0x30
    800197aa:	e6843503          	ld	a0,-408(s0)
    800197ae:	f5cfe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800197b2:	87aa                	mv	a5,a0
    800197b4:	0027d79b          	srliw	a5,a5,0x2
    800197b8:	17c2                	slli	a5,a5,0x30
    800197ba:	93c1                	srli	a5,a5,0x30
    800197bc:	0009071b          	sext.w	a4,s2
    800197c0:	2781                	sext.w	a5,a5
    800197c2:	d0f769e3          	bltu	a4,a5,800194d4 <minix3_get_data+0xa88>
    800197c6:	8126                	mv	sp,s1
        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    800197c8:	f8244783          	lbu	a5,-126(s0)
    800197cc:	2785                	addiw	a5,a5,1
    800197ce:	f8f40123          	sb	a5,-126(s0)
    800197d2:	f8244783          	lbu	a5,-126(s0)
    800197d6:	03079493          	slli	s1,a5,0x30
    800197da:	90c1                	srli	s1,s1,0x30
    800197dc:	e6843503          	ld	a0,-408(s0)
    800197e0:	f2afe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800197e4:	87aa                	mv	a5,a0
    800197e6:	0027d79b          	srliw	a5,a5,0x2
    800197ea:	17c2                	slli	a5,a5,0x30
    800197ec:	93c1                	srli	a5,a5,0x30
    800197ee:	0004871b          	sext.w	a4,s1
    800197f2:	2781                	sext.w	a5,a5
    800197f4:	c2f767e3          	bltu	a4,a5,80019422 <minix3_get_data+0x9d6>
    800197f8:	8152                	mv	sp,s4
    } else {
        debugf("No triple indirect zone\n");
    }

    // If we get here, we've read all the data we can
    return;
    800197fa:	0001                	nop
    800197fc:	cd843103          	ld	sp,-808(s0)
}
    80019800:	cd040113          	addi	sp,s0,-816
    80019804:	32813083          	ld	ra,808(sp)
    80019808:	32013403          	ld	s0,800(sp)
    8001980c:	31813483          	ld	s1,792(sp)
    80019810:	31013903          	ld	s2,784(sp)
    80019814:	30813983          	ld	s3,776(sp)
    80019818:	30013a03          	ld	s4,768(sp)
    8001981c:	2f813a83          	ld	s5,760(sp)
    80019820:	2f013b03          	ld	s6,752(sp)
    80019824:	2e813b83          	ld	s7,744(sp)
    80019828:	2e013c03          	ld	s8,736(sp)
    8001982c:	2d813c83          	ld	s9,728(sp)
    80019830:	2d013d03          	ld	s10,720(sp)
    80019834:	2c813d83          	ld	s11,712(sp)
    80019838:	33010113          	addi	sp,sp,816
    8001983c:	8082                	ret

000000008001983e <minix3_put_data>:
void minix3_put_data(VirtioDevice *block_device, uint32_t inode, uint8_t *data, uint32_t offset, uint32_t count) {
    8001983e:	cd010113          	addi	sp,sp,-816
    80019842:	32113423          	sd	ra,808(sp)
    80019846:	32813023          	sd	s0,800(sp)
    8001984a:	30913c23          	sd	s1,792(sp)
    8001984e:	31213823          	sd	s2,784(sp)
    80019852:	31313423          	sd	s3,776(sp)
    80019856:	31413023          	sd	s4,768(sp)
    8001985a:	2f513c23          	sd	s5,760(sp)
    8001985e:	2f613823          	sd	s6,752(sp)
    80019862:	2f713423          	sd	s7,744(sp)
    80019866:	2f813023          	sd	s8,736(sp)
    8001986a:	2d913c23          	sd	s9,728(sp)
    8001986e:	2da13823          	sd	s10,720(sp)
    80019872:	2db13423          	sd	s11,712(sp)
    80019876:	1e00                	addi	s0,sp,816
    80019878:	e6a43423          	sd	a0,-408(s0)
    8001987c:	87ae                	mv	a5,a1
    8001987e:	e4c43c23          	sd	a2,-424(s0)
    80019882:	e6f42223          	sw	a5,-412(s0)
    80019886:	87b6                	mv	a5,a3
    80019888:	e6f42023          	sw	a5,-416(s0)
    8001988c:	87ba                	mv	a5,a4
    8001988e:	e4f42a23          	sw	a5,-428(s0)
    80019892:	878a                	mv	a5,sp
    80019894:	ccf43c23          	sd	a5,-808(s0)
    // First, get the inode
    Inode inode_data = minix3_get_inode(block_device, inode);
    80019898:	e7840713          	addi	a4,s0,-392
    8001989c:	e6442783          	lw	a5,-412(s0)
    800198a0:	863e                	mv	a2,a5
    800198a2:	e6843583          	ld	a1,-408(s0)
    800198a6:	853a                	mv	a0,a4
    800198a8:	ce3fe0ef          	jal	ra,8001858a <minix3_get_inode>

    uint8_t zone_data[minix3_get_zone_size(block_device)];
    800198ac:	e6843503          	ld	a0,-408(s0)
    800198b0:	e5afe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800198b4:	87aa                	mv	a5,a0
    800198b6:	873e                	mv	a4,a5
    800198b8:	87ba                	mv	a5,a4
    800198ba:	17fd                	addi	a5,a5,-1
    800198bc:	f6f43c23          	sd	a5,-136(s0)
    800198c0:	e4e43023          	sd	a4,-448(s0)
    800198c4:	e4043423          	sd	zero,-440(s0)
    800198c8:	e4043783          	ld	a5,-448(s0)
    800198cc:	93f5                	srli	a5,a5,0x3d
    800198ce:	e4843683          	ld	a3,-440(s0)
    800198d2:	068e                	slli	a3,a3,0x3
    800198d4:	d6d43423          	sd	a3,-664(s0)
    800198d8:	d6843683          	ld	a3,-664(s0)
    800198dc:	8fd5                	or	a5,a5,a3
    800198de:	d6f43423          	sd	a5,-664(s0)
    800198e2:	e4043783          	ld	a5,-448(s0)
    800198e6:	078e                	slli	a5,a5,0x3
    800198e8:	d6f43023          	sd	a5,-672(s0)
    800198ec:	e2e43823          	sd	a4,-464(s0)
    800198f0:	e2043c23          	sd	zero,-456(s0)
    800198f4:	e3043783          	ld	a5,-464(s0)
    800198f8:	93f5                	srli	a5,a5,0x3d
    800198fa:	e3843683          	ld	a3,-456(s0)
    800198fe:	00369993          	slli	s3,a3,0x3
    80019902:	0137e9b3          	or	s3,a5,s3
    80019906:	e3043783          	ld	a5,-464(s0)
    8001990a:	00379913          	slli	s2,a5,0x3
    8001990e:	87ba                	mv	a5,a4
    80019910:	07bd                	addi	a5,a5,15
    80019912:	8391                	srli	a5,a5,0x4
    80019914:	0792                	slli	a5,a5,0x4
    80019916:	40f10133          	sub	sp,sp,a5
    8001991a:	878a                	mv	a5,sp
    8001991c:	00078793          	mv	a5,a5
    80019920:	f6f43823          	sd	a5,-144(s0)

    // The cursor is the current position in the data buffer
    uint32_t buffer_cursor = 0;
    80019924:	f8042223          	sw	zero,-124(s0)
    // The file cursor is the current position in the file
    uint32_t file_cursor = 0;
    80019928:	f8042423          	sw	zero,-120(s0)

    // Now, get the data
    // The first 7 zones are direct zones
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    8001992c:	f80406a3          	sb	zero,-115(s0)
    80019930:	a425                	j	80019b58 <minix3_put_data+0x31a>
        uint32_t zone = inode_data.zones[direct_zone];
    80019932:	f8d44783          	lbu	a5,-115(s0)
    80019936:	2781                	sext.w	a5,a5
    80019938:	0791                	addi	a5,a5,4
    8001993a:	078a                	slli	a5,a5,0x2
    8001993c:	f9040713          	addi	a4,s0,-112
    80019940:	97ba                	add	a5,a5,a4
    80019942:	ef07a783          	lw	a5,-272(a5)
    80019946:	ecf42223          	sw	a5,-316(s0)
        if (zone == 0) {
    8001994a:	ec442783          	lw	a5,-316(s0)
    8001994e:	2781                	sext.w	a5,a5
    80019950:	1e078c63          	beqz	a5,80019b48 <minix3_put_data+0x30a>
            debugf("No direct zone %d\n", zone);
            continue;
        }
        if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80019954:	e6843503          	ld	a0,-408(s0)
    80019958:	db2fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001995c:	87aa                	mv	a5,a0
    8001995e:	2781                	sext.w	a5,a5
    80019960:	f8842703          	lw	a4,-120(s0)
    80019964:	9fb9                	addw	a5,a5,a4
    80019966:	0007871b          	sext.w	a4,a5
    8001996a:	e6042783          	lw	a5,-416(s0)
    8001996e:	2781                	sext.w	a5,a5
    80019970:	00f77e63          	bgeu	a4,a5,8001998c <minix3_put_data+0x14e>
            // We're not at the offset yet
            file_cursor += minix3_get_zone_size(block_device);
    80019974:	e6843503          	ld	a0,-408(s0)
    80019978:	d92fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001997c:	87aa                	mv	a5,a0
    8001997e:	2781                	sext.w	a5,a5
    80019980:	f8842703          	lw	a4,-120(s0)
    80019984:	9fb9                	addw	a5,a5,a4
    80019986:	f8f42423          	sw	a5,-120(s0)
            continue;
    8001998a:	a2d1                	j	80019b4e <minix3_put_data+0x310>
        } else if (file_cursor < offset) {
    8001998c:	f8842703          	lw	a4,-120(s0)
    80019990:	e6042783          	lw	a5,-416(s0)
    80019994:	2701                	sext.w	a4,a4
    80019996:	2781                	sext.w	a5,a5
    80019998:	0cf77d63          	bgeu	a4,a5,80019a72 <minix3_put_data+0x234>
            // We're in the middle of the offset
            // Read the zone into the buffer
            debugf("Writing first direct zone %d\n", zone);
            minix3_get_zone(block_device, zone, zone_data);
    8001999c:	ec442783          	lw	a5,-316(s0)
    800199a0:	f7043603          	ld	a2,-144(s0)
    800199a4:	85be                	mv	a1,a5
    800199a6:	e6843503          	ld	a0,-408(s0)
    800199aa:	8befe0ef          	jal	ra,80017a68 <minix3_get_zone>

            // Copy the remaining data into the buffer
            size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    800199ae:	e6843503          	ld	a0,-408(s0)
    800199b2:	d58fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800199b6:	87aa                	mv	a5,a0
    800199b8:	0007871b          	sext.w	a4,a5
    800199bc:	f8842683          	lw	a3,-120(s0)
    800199c0:	e6042783          	lw	a5,-416(s0)
    800199c4:	40f687bb          	subw	a5,a3,a5
    800199c8:	2781                	sext.w	a5,a5
    800199ca:	9fb9                	addw	a5,a5,a4
    800199cc:	0007871b          	sext.w	a4,a5
    800199d0:	e5442783          	lw	a5,-428(s0)
    800199d4:	2781                	sext.w	a5,a5
    800199d6:	02e7e563          	bltu	a5,a4,80019a00 <minix3_put_data+0x1c2>
    800199da:	e6843503          	ld	a0,-408(s0)
    800199de:	d2cfe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    800199e2:	87aa                	mv	a5,a0
    800199e4:	0007871b          	sext.w	a4,a5
    800199e8:	f8842683          	lw	a3,-120(s0)
    800199ec:	e6042783          	lw	a5,-416(s0)
    800199f0:	40f687bb          	subw	a5,a3,a5
    800199f4:	2781                	sext.w	a5,a5
    800199f6:	9fb9                	addw	a5,a5,a4
    800199f8:	2781                	sext.w	a5,a5
    800199fa:	1782                	slli	a5,a5,0x20
    800199fc:	9381                	srli	a5,a5,0x20
    800199fe:	a019                	j	80019a04 <minix3_put_data+0x1c6>
    80019a00:	e5446783          	lwu	a5,-428(s0)
    80019a04:	eaf43c23          	sd	a5,-328(s0)
            memcpy(zone_data + offset - file_cursor, data, remaining);
    80019a08:	e6046703          	lwu	a4,-416(s0)
    80019a0c:	f8846783          	lwu	a5,-120(s0)
    80019a10:	40f707b3          	sub	a5,a4,a5
    80019a14:	f7043703          	ld	a4,-144(s0)
    80019a18:	97ba                	add	a5,a5,a4
    80019a1a:	eb843703          	ld	a4,-328(s0)
    80019a1e:	2701                	sext.w	a4,a4
    80019a20:	863a                	mv	a2,a4
    80019a22:	e5843583          	ld	a1,-424(s0)
    80019a26:	853e                	mv	a0,a5
    80019a28:	117080ef          	jal	ra,8002233e <memcpy>
            debugf("Wrote %u bytes to zone %u at offset %u (0x%x)\n", remaining, zone, offset, offset);
            minix3_put_zone(block_device, zone, zone_data);
    80019a2c:	ec442783          	lw	a5,-316(s0)
    80019a30:	f7043603          	ld	a2,-144(s0)
    80019a34:	85be                	mv	a1,a5
    80019a36:	e6843503          	ld	a0,-408(s0)
    80019a3a:	8dafe0ef          	jal	ra,80017b14 <minix3_put_zone>

            buffer_cursor += remaining;
    80019a3e:	eb843783          	ld	a5,-328(s0)
    80019a42:	2781                	sext.w	a5,a5
    80019a44:	f8442703          	lw	a4,-124(s0)
    80019a48:	9fb9                	addw	a5,a5,a4
    80019a4a:	f8f42223          	sw	a5,-124(s0)
            file_cursor = offset + remaining;
    80019a4e:	eb843783          	ld	a5,-328(s0)
    80019a52:	2781                	sext.w	a5,a5
    80019a54:	e6042703          	lw	a4,-416(s0)
    80019a58:	9fb9                	addw	a5,a5,a4
    80019a5a:	f8f42423          	sw	a5,-120(s0)
            if (buffer_cursor >= count) {
    80019a5e:	f8442703          	lw	a4,-124(s0)
    80019a62:	e5442783          	lw	a5,-428(s0)
    80019a66:	2701                	sext.w	a4,a4
    80019a68:	2781                	sext.w	a5,a5
    80019a6a:	0ef76163          	bltu	a4,a5,80019b4c <minix3_put_data+0x30e>
                // We're done
                return;
    80019a6e:	4b70006f          	j	8001a724 <minix3_put_data+0xee6>
            }

            continue;
        }

        memset(zone_data, 0, minix3_get_zone_size(block_device));
    80019a72:	e6843503          	ld	a0,-408(s0)
    80019a76:	c94fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019a7a:	87aa                	mv	a5,a0
    80019a7c:	2781                	sext.w	a5,a5
    80019a7e:	863e                	mv	a2,a5
    80019a80:	4581                	li	a1,0
    80019a82:	f7043503          	ld	a0,-144(s0)
    80019a86:	7b6080ef          	jal	ra,8002223c <memset>

        // Write the buffer into the zone
        if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80019a8a:	e6843503          	ld	a0,-408(s0)
    80019a8e:	c7cfe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019a92:	87aa                	mv	a5,a0
    80019a94:	2781                	sext.w	a5,a5
    80019a96:	f8442703          	lw	a4,-124(s0)
    80019a9a:	9fb9                	addw	a5,a5,a4
    80019a9c:	0007871b          	sext.w	a4,a5
    80019aa0:	e5442783          	lw	a5,-428(s0)
    80019aa4:	2781                	sext.w	a5,a5
    80019aa6:	04e7fa63          	bgeu	a5,a4,80019afa <minix3_put_data+0x2bc>
            minix3_get_zone(block_device, zone, zone_data);
    80019aaa:	ec442783          	lw	a5,-316(s0)
    80019aae:	f7043603          	ld	a2,-144(s0)
    80019ab2:	85be                	mv	a1,a5
    80019ab4:	e6843503          	ld	a0,-408(s0)
    80019ab8:	fb1fd0ef          	jal	ra,80017a68 <minix3_get_zone>
            debugf("Writing last direct zone %d\n", zone);
            // Copy the remaining data into the buffer
            memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    80019abc:	f8446783          	lwu	a5,-124(s0)
    80019ac0:	e5843703          	ld	a4,-424(s0)
    80019ac4:	00f706b3          	add	a3,a4,a5
    80019ac8:	e5442703          	lw	a4,-428(s0)
    80019acc:	f8442783          	lw	a5,-124(s0)
    80019ad0:	40f707bb          	subw	a5,a4,a5
    80019ad4:	2781                	sext.w	a5,a5
    80019ad6:	2781                	sext.w	a5,a5
    80019ad8:	863e                	mv	a2,a5
    80019ada:	85b6                	mv	a1,a3
    80019adc:	f7043503          	ld	a0,-144(s0)
    80019ae0:	05f080ef          	jal	ra,8002233e <memcpy>
            // We're done
            minix3_put_zone(block_device, zone, zone_data);
    80019ae4:	ec442783          	lw	a5,-316(s0)
    80019ae8:	f7043603          	ld	a2,-144(s0)
    80019aec:	85be                	mv	a1,a5
    80019aee:	e6843503          	ld	a0,-408(s0)
    80019af2:	822fe0ef          	jal	ra,80017b14 <minix3_put_zone>
            return;
    80019af6:	42f0006f          	j	8001a724 <minix3_put_data+0xee6>
        } else {
            debugf("Writing direct zone %d\n", zone);
            // Copy the entire zone into the buffer
            memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    80019afa:	f8446783          	lwu	a5,-124(s0)
    80019afe:	e5843703          	ld	a4,-424(s0)
    80019b02:	00f704b3          	add	s1,a4,a5
    80019b06:	e6843503          	ld	a0,-408(s0)
    80019b0a:	c00fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019b0e:	87aa                	mv	a5,a0
    80019b10:	2781                	sext.w	a5,a5
    80019b12:	863e                	mv	a2,a5
    80019b14:	85a6                	mv	a1,s1
    80019b16:	f7043503          	ld	a0,-144(s0)
    80019b1a:	025080ef          	jal	ra,8002233e <memcpy>
            minix3_put_zone(block_device, zone, zone_data);
    80019b1e:	ec442783          	lw	a5,-316(s0)
    80019b22:	f7043603          	ld	a2,-144(s0)
    80019b26:	85be                	mv	a1,a5
    80019b28:	e6843503          	ld	a0,-408(s0)
    80019b2c:	fe9fd0ef          	jal	ra,80017b14 <minix3_put_zone>
        }
        buffer_cursor += minix3_get_zone_size(block_device);
    80019b30:	e6843503          	ld	a0,-408(s0)
    80019b34:	bd6fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019b38:	87aa                	mv	a5,a0
    80019b3a:	2781                	sext.w	a5,a5
    80019b3c:	f8442703          	lw	a4,-124(s0)
    80019b40:	9fb9                	addw	a5,a5,a4
    80019b42:	f8f42223          	sw	a5,-124(s0)
    80019b46:	a021                	j	80019b4e <minix3_put_data+0x310>
            continue;
    80019b48:	0001                	nop
    80019b4a:	a011                	j	80019b4e <minix3_put_data+0x310>
            continue;
    80019b4c:	0001                	nop
    for (uint8_t direct_zone=0; direct_zone<7; direct_zone++) {
    80019b4e:	f8d44783          	lbu	a5,-115(s0)
    80019b52:	2785                	addiw	a5,a5,1
    80019b54:	f8f406a3          	sb	a5,-115(s0)
    80019b58:	f8d44783          	lbu	a5,-115(s0)
    80019b5c:	0ff7f713          	andi	a4,a5,255
    80019b60:	4799                	li	a5,6
    80019b62:	dce7f8e3          	bgeu	a5,a4,80019932 <minix3_put_data+0xf4>
    }

    debugf("Done with direct zones\n");
    // The next zone is an indirect zone
    if (inode_data.zones[7] != 0) {
    80019b66:	eac42783          	lw	a5,-340(s0)
    80019b6a:	2e078c63          	beqz	a5,80019e62 <minix3_put_data+0x624>
    80019b6e:	878a                	mv	a5,sp
    80019b70:	893e                	mv	s2,a5
        uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80019b72:	e6843503          	ld	a0,-408(s0)
    80019b76:	b94fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019b7a:	87aa                	mv	a5,a0
    80019b7c:	0027d79b          	srliw	a5,a5,0x2
    80019b80:	17c2                	slli	a5,a5,0x30
    80019b82:	93c1                	srli	a5,a5,0x30
    80019b84:	873e                	mv	a4,a5
    80019b86:	177d                	addi	a4,a4,-1
    80019b88:	f6e43423          	sd	a4,-152(s0)
    80019b8c:	e2f43023          	sd	a5,-480(s0)
    80019b90:	e2043423          	sd	zero,-472(s0)
    80019b94:	e2043703          	ld	a4,-480(s0)
    80019b98:	936d                	srli	a4,a4,0x3b
    80019b9a:	e2843683          	ld	a3,-472(s0)
    80019b9e:	0696                	slli	a3,a3,0x5
    80019ba0:	d4d43c23          	sd	a3,-680(s0)
    80019ba4:	d5843683          	ld	a3,-680(s0)
    80019ba8:	8f55                	or	a4,a4,a3
    80019baa:	d4e43c23          	sd	a4,-680(s0)
    80019bae:	e2043703          	ld	a4,-480(s0)
    80019bb2:	0716                	slli	a4,a4,0x5
    80019bb4:	d4e43823          	sd	a4,-688(s0)
    80019bb8:	e0f43823          	sd	a5,-496(s0)
    80019bbc:	e0043c23          	sd	zero,-488(s0)
    80019bc0:	e1043703          	ld	a4,-496(s0)
    80019bc4:	936d                	srli	a4,a4,0x3b
    80019bc6:	e1843683          	ld	a3,-488(s0)
    80019bca:	0696                	slli	a3,a3,0x5
    80019bcc:	d4d43423          	sd	a3,-696(s0)
    80019bd0:	d4843683          	ld	a3,-696(s0)
    80019bd4:	8f55                	or	a4,a4,a3
    80019bd6:	d4e43423          	sd	a4,-696(s0)
    80019bda:	e1043703          	ld	a4,-496(s0)
    80019bde:	0716                	slli	a4,a4,0x5
    80019be0:	d4e43023          	sd	a4,-704(s0)
    80019be4:	078a                	slli	a5,a5,0x2
    80019be6:	07bd                	addi	a5,a5,15
    80019be8:	8391                	srli	a5,a5,0x4
    80019bea:	0792                	slli	a5,a5,0x4
    80019bec:	40f10133          	sub	sp,sp,a5
    80019bf0:	878a                	mv	a5,sp
    80019bf2:	078d                	addi	a5,a5,3
    80019bf4:	8389                	srli	a5,a5,0x2
    80019bf6:	078a                	slli	a5,a5,0x2
    80019bf8:	f6f43023          	sd	a5,-160(s0)
        minix3_get_zone(block_device, inode_data.zones[7], (uint8_t*)indirect_zones);
    80019bfc:	eac42783          	lw	a5,-340(s0)
    80019c00:	f6043603          	ld	a2,-160(s0)
    80019c04:	85be                	mv	a1,a5
    80019c06:	e6843503          	ld	a0,-408(s0)
    80019c0a:	e5ffd0ef          	jal	ra,80017a68 <minix3_get_zone>

        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80019c0e:	f8040723          	sb	zero,-114(s0)
    80019c12:	a405                	j	80019e32 <minix3_put_data+0x5f4>
            uint32_t zone = indirect_zones[indirect_zone];
    80019c14:	f8e44783          	lbu	a5,-114(s0)
    80019c18:	2781                	sext.w	a5,a5
    80019c1a:	f6043703          	ld	a4,-160(s0)
    80019c1e:	078a                	slli	a5,a5,0x2
    80019c20:	97ba                	add	a5,a5,a4
    80019c22:	439c                	lw	a5,0(a5)
    80019c24:	f4f42e23          	sw	a5,-164(s0)
            if (zone == 0) continue;
    80019c28:	f5c42783          	lw	a5,-164(s0)
    80019c2c:	2781                	sext.w	a5,a5
    80019c2e:	1e078a63          	beqz	a5,80019e22 <minix3_put_data+0x5e4>
            debugf("Writing indirect zone %d\n", zone);

            if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80019c32:	e6843503          	ld	a0,-408(s0)
    80019c36:	ad4fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019c3a:	87aa                	mv	a5,a0
    80019c3c:	2781                	sext.w	a5,a5
    80019c3e:	f8842703          	lw	a4,-120(s0)
    80019c42:	9fb9                	addw	a5,a5,a4
    80019c44:	0007871b          	sext.w	a4,a5
    80019c48:	e6042783          	lw	a5,-416(s0)
    80019c4c:	2781                	sext.w	a5,a5
    80019c4e:	00f77e63          	bgeu	a4,a5,80019c6a <minix3_put_data+0x42c>
                // We're not at the offset yet
                file_cursor += minix3_get_zone_size(block_device);
    80019c52:	e6843503          	ld	a0,-408(s0)
    80019c56:	ab4fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019c5a:	87aa                	mv	a5,a0
    80019c5c:	2781                	sext.w	a5,a5
    80019c5e:	f8842703          	lw	a4,-120(s0)
    80019c62:	9fb9                	addw	a5,a5,a4
    80019c64:	f8f42423          	sw	a5,-120(s0)
                continue;
    80019c68:	a2c1                	j	80019e28 <minix3_put_data+0x5ea>
            } else if (file_cursor < offset) {
    80019c6a:	f8842703          	lw	a4,-120(s0)
    80019c6e:	e6042783          	lw	a5,-416(s0)
    80019c72:	2701                	sext.w	a4,a4
    80019c74:	2781                	sext.w	a5,a5
    80019c76:	0cf77c63          	bgeu	a4,a5,80019d4e <minix3_put_data+0x510>
                // We're in the middle of the offset
                // Read the zone into the buffer
                minix3_get_zone(block_device, zone, zone_data);
    80019c7a:	f5c42783          	lw	a5,-164(s0)
    80019c7e:	f7043603          	ld	a2,-144(s0)
    80019c82:	85be                	mv	a1,a5
    80019c84:	e6843503          	ld	a0,-408(s0)
    80019c88:	de1fd0ef          	jal	ra,80017a68 <minix3_get_zone>
                // Copy the remaining data into the buffer
                size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    80019c8c:	e6843503          	ld	a0,-408(s0)
    80019c90:	a7afe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019c94:	87aa                	mv	a5,a0
    80019c96:	0007871b          	sext.w	a4,a5
    80019c9a:	f8842683          	lw	a3,-120(s0)
    80019c9e:	e6042783          	lw	a5,-416(s0)
    80019ca2:	40f687bb          	subw	a5,a3,a5
    80019ca6:	2781                	sext.w	a5,a5
    80019ca8:	9fb9                	addw	a5,a5,a4
    80019caa:	0007871b          	sext.w	a4,a5
    80019cae:	e5442783          	lw	a5,-428(s0)
    80019cb2:	2781                	sext.w	a5,a5
    80019cb4:	02e7e563          	bltu	a5,a4,80019cde <minix3_put_data+0x4a0>
    80019cb8:	e6843503          	ld	a0,-408(s0)
    80019cbc:	a4efe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019cc0:	87aa                	mv	a5,a0
    80019cc2:	0007871b          	sext.w	a4,a5
    80019cc6:	f8842683          	lw	a3,-120(s0)
    80019cca:	e6042783          	lw	a5,-416(s0)
    80019cce:	40f687bb          	subw	a5,a3,a5
    80019cd2:	2781                	sext.w	a5,a5
    80019cd4:	9fb9                	addw	a5,a5,a4
    80019cd6:	2781                	sext.w	a5,a5
    80019cd8:	1782                	slli	a5,a5,0x20
    80019cda:	9381                	srli	a5,a5,0x20
    80019cdc:	a019                	j	80019ce2 <minix3_put_data+0x4a4>
    80019cde:	e5446783          	lwu	a5,-428(s0)
    80019ce2:	f4f43823          	sd	a5,-176(s0)
                memcpy(zone_data + offset - file_cursor, data, remaining);
    80019ce6:	e6046703          	lwu	a4,-416(s0)
    80019cea:	f8846783          	lwu	a5,-120(s0)
    80019cee:	40f707b3          	sub	a5,a4,a5
    80019cf2:	f7043703          	ld	a4,-144(s0)
    80019cf6:	97ba                	add	a5,a5,a4
    80019cf8:	f5043703          	ld	a4,-176(s0)
    80019cfc:	2701                	sext.w	a4,a4
    80019cfe:	863a                	mv	a2,a4
    80019d00:	e5843583          	ld	a1,-424(s0)
    80019d04:	853e                	mv	a0,a5
    80019d06:	638080ef          	jal	ra,8002233e <memcpy>
                minix3_put_zone(block_device, zone, zone_data);
    80019d0a:	f5c42783          	lw	a5,-164(s0)
    80019d0e:	f7043603          	ld	a2,-144(s0)
    80019d12:	85be                	mv	a1,a5
    80019d14:	e6843503          	ld	a0,-408(s0)
    80019d18:	dfdfd0ef          	jal	ra,80017b14 <minix3_put_zone>

                buffer_cursor += remaining;
    80019d1c:	f5043783          	ld	a5,-176(s0)
    80019d20:	2781                	sext.w	a5,a5
    80019d22:	f8442703          	lw	a4,-124(s0)
    80019d26:	9fb9                	addw	a5,a5,a4
    80019d28:	f8f42223          	sw	a5,-124(s0)
                file_cursor = offset + remaining;
    80019d2c:	f5043783          	ld	a5,-176(s0)
    80019d30:	2781                	sext.w	a5,a5
    80019d32:	e6042703          	lw	a4,-416(s0)
    80019d36:	9fb9                	addw	a5,a5,a4
    80019d38:	f8f42423          	sw	a5,-120(s0)
                if (buffer_cursor >= count) {
    80019d3c:	f8442703          	lw	a4,-124(s0)
    80019d40:	e5442783          	lw	a5,-428(s0)
    80019d44:	2701                	sext.w	a4,a4
    80019d46:	2781                	sext.w	a5,a5
    80019d48:	0cf76f63          	bltu	a4,a5,80019e26 <minix3_put_data+0x5e8>
                    // We're done
                    return;
    80019d4c:	aa01                	j	80019e5c <minix3_put_data+0x61e>
                }
                continue;
            }

            memset(zone_data, 0, minix3_get_zone_size(block_device));
    80019d4e:	e6843503          	ld	a0,-408(s0)
    80019d52:	9b8fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019d56:	87aa                	mv	a5,a0
    80019d58:	2781                	sext.w	a5,a5
    80019d5a:	863e                	mv	a2,a5
    80019d5c:	4581                	li	a1,0
    80019d5e:	f7043503          	ld	a0,-144(s0)
    80019d62:	4da080ef          	jal	ra,8002223c <memset>

            if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    80019d66:	e6843503          	ld	a0,-408(s0)
    80019d6a:	9a0fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019d6e:	87aa                	mv	a5,a0
    80019d70:	2781                	sext.w	a5,a5
    80019d72:	f8442703          	lw	a4,-124(s0)
    80019d76:	9fb9                	addw	a5,a5,a4
    80019d78:	0007871b          	sext.w	a4,a5
    80019d7c:	e5442783          	lw	a5,-428(s0)
    80019d80:	2781                	sext.w	a5,a5
    80019d82:	04e7f963          	bgeu	a5,a4,80019dd4 <minix3_put_data+0x596>
                minix3_get_zone(block_device, zone, zone_data);
    80019d86:	f5c42783          	lw	a5,-164(s0)
    80019d8a:	f7043603          	ld	a2,-144(s0)
    80019d8e:	85be                	mv	a1,a5
    80019d90:	e6843503          	ld	a0,-408(s0)
    80019d94:	cd5fd0ef          	jal	ra,80017a68 <minix3_get_zone>
                // Copy the remaining data into the buffer
                memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    80019d98:	f8446783          	lwu	a5,-124(s0)
    80019d9c:	e5843703          	ld	a4,-424(s0)
    80019da0:	00f706b3          	add	a3,a4,a5
    80019da4:	e5442703          	lw	a4,-428(s0)
    80019da8:	f8442783          	lw	a5,-124(s0)
    80019dac:	40f707bb          	subw	a5,a4,a5
    80019db0:	2781                	sext.w	a5,a5
    80019db2:	2781                	sext.w	a5,a5
    80019db4:	863e                	mv	a2,a5
    80019db6:	85b6                	mv	a1,a3
    80019db8:	f7043503          	ld	a0,-144(s0)
    80019dbc:	582080ef          	jal	ra,8002233e <memcpy>
                // We're done
                minix3_put_zone(block_device, zone, zone_data);
    80019dc0:	f5c42783          	lw	a5,-164(s0)
    80019dc4:	f7043603          	ld	a2,-144(s0)
    80019dc8:	85be                	mv	a1,a5
    80019dca:	e6843503          	ld	a0,-408(s0)
    80019dce:	d47fd0ef          	jal	ra,80017b14 <minix3_put_zone>
                return;
    80019dd2:	a069                	j	80019e5c <minix3_put_data+0x61e>
            } else {
                // Copy the entire zone into the buffer
                memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    80019dd4:	f8446783          	lwu	a5,-124(s0)
    80019dd8:	e5843703          	ld	a4,-424(s0)
    80019ddc:	00f704b3          	add	s1,a4,a5
    80019de0:	e6843503          	ld	a0,-408(s0)
    80019de4:	926fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019de8:	87aa                	mv	a5,a0
    80019dea:	2781                	sext.w	a5,a5
    80019dec:	863e                	mv	a2,a5
    80019dee:	85a6                	mv	a1,s1
    80019df0:	f7043503          	ld	a0,-144(s0)
    80019df4:	54a080ef          	jal	ra,8002233e <memcpy>
                minix3_put_zone(block_device, zone, zone_data);
    80019df8:	f5c42783          	lw	a5,-164(s0)
    80019dfc:	f7043603          	ld	a2,-144(s0)
    80019e00:	85be                	mv	a1,a5
    80019e02:	e6843503          	ld	a0,-408(s0)
    80019e06:	d0ffd0ef          	jal	ra,80017b14 <minix3_put_zone>
            }
            buffer_cursor += minix3_get_zone_size(block_device);
    80019e0a:	e6843503          	ld	a0,-408(s0)
    80019e0e:	8fcfe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019e12:	87aa                	mv	a5,a0
    80019e14:	2781                	sext.w	a5,a5
    80019e16:	f8442703          	lw	a4,-124(s0)
    80019e1a:	9fb9                	addw	a5,a5,a4
    80019e1c:	f8f42223          	sw	a5,-124(s0)
    80019e20:	a021                	j	80019e28 <minix3_put_data+0x5ea>
            if (zone == 0) continue;
    80019e22:	0001                	nop
    80019e24:	a011                	j	80019e28 <minix3_put_data+0x5ea>
                continue;
    80019e26:	0001                	nop
        for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80019e28:	f8e44783          	lbu	a5,-114(s0)
    80019e2c:	2785                	addiw	a5,a5,1
    80019e2e:	f8f40723          	sb	a5,-114(s0)
    80019e32:	f8e44783          	lbu	a5,-114(s0)
    80019e36:	03079493          	slli	s1,a5,0x30
    80019e3a:	90c1                	srli	s1,s1,0x30
    80019e3c:	e6843503          	ld	a0,-408(s0)
    80019e40:	8cafe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019e44:	87aa                	mv	a5,a0
    80019e46:	0027d79b          	srliw	a5,a5,0x2
    80019e4a:	17c2                	slli	a5,a5,0x30
    80019e4c:	93c1                	srli	a5,a5,0x30
    80019e4e:	0004871b          	sext.w	a4,s1
    80019e52:	2781                	sext.w	a5,a5
    80019e54:	dcf760e3          	bltu	a4,a5,80019c14 <minix3_put_data+0x3d6>
    80019e58:	814a                	mv	sp,s2
    80019e5a:	a021                	j	80019e62 <minix3_put_data+0x624>
    80019e5c:	814a                	mv	sp,s2
    80019e5e:	0c70006f          	j	8001a724 <minix3_put_data+0xee6>
        debugf("No indirect zone\n");
    }

    // The next zone is a double indirect zone
    // The next zone is a double indirect zone
    if (inode_data.zones[8] != 0) {
    80019e62:	eb042783          	lw	a5,-336(s0)
    80019e66:	3e078463          	beqz	a5,8001a24e <minix3_put_data+0xa10>
    80019e6a:	878a                	mv	a5,sp
    80019e6c:	89be                	mv	s3,a5
        uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80019e6e:	e6843503          	ld	a0,-408(s0)
    80019e72:	898fe0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019e76:	87aa                	mv	a5,a0
    80019e78:	0027d79b          	srliw	a5,a5,0x2
    80019e7c:	17c2                	slli	a5,a5,0x30
    80019e7e:	93c1                	srli	a5,a5,0x30
    80019e80:	873e                	mv	a4,a5
    80019e82:	177d                	addi	a4,a4,-1
    80019e84:	f4e43423          	sd	a4,-184(s0)
    80019e88:	e0f43023          	sd	a5,-512(s0)
    80019e8c:	e0043423          	sd	zero,-504(s0)
    80019e90:	e0043703          	ld	a4,-512(s0)
    80019e94:	936d                	srli	a4,a4,0x3b
    80019e96:	e0843683          	ld	a3,-504(s0)
    80019e9a:	0696                	slli	a3,a3,0x5
    80019e9c:	d2d43c23          	sd	a3,-712(s0)
    80019ea0:	d3843683          	ld	a3,-712(s0)
    80019ea4:	8f55                	or	a4,a4,a3
    80019ea6:	d2e43c23          	sd	a4,-712(s0)
    80019eaa:	e0043703          	ld	a4,-512(s0)
    80019eae:	0716                	slli	a4,a4,0x5
    80019eb0:	d2e43823          	sd	a4,-720(s0)
    80019eb4:	def43823          	sd	a5,-528(s0)
    80019eb8:	de043c23          	sd	zero,-520(s0)
    80019ebc:	df043703          	ld	a4,-528(s0)
    80019ec0:	936d                	srli	a4,a4,0x3b
    80019ec2:	df843683          	ld	a3,-520(s0)
    80019ec6:	0696                	slli	a3,a3,0x5
    80019ec8:	d2d43423          	sd	a3,-728(s0)
    80019ecc:	d2843683          	ld	a3,-728(s0)
    80019ed0:	8f55                	or	a4,a4,a3
    80019ed2:	d2e43423          	sd	a4,-728(s0)
    80019ed6:	df043703          	ld	a4,-528(s0)
    80019eda:	0716                	slli	a4,a4,0x5
    80019edc:	d2e43023          	sd	a4,-736(s0)
    80019ee0:	078a                	slli	a5,a5,0x2
    80019ee2:	07bd                	addi	a5,a5,15
    80019ee4:	8391                	srli	a5,a5,0x4
    80019ee6:	0792                	slli	a5,a5,0x4
    80019ee8:	40f10133          	sub	sp,sp,a5
    80019eec:	878a                	mv	a5,sp
    80019eee:	078d                	addi	a5,a5,3
    80019ef0:	8389                	srli	a5,a5,0x2
    80019ef2:	078a                	slli	a5,a5,0x2
    80019ef4:	f4f43023          	sd	a5,-192(s0)
        // We're done
        minix3_get_zone(block_device, inode_data.zones[8], (uint8_t*)double_indirect_zones);
    80019ef8:	eb042783          	lw	a5,-336(s0)
    80019efc:	f4043603          	ld	a2,-192(s0)
    80019f00:	85be                	mv	a1,a5
    80019f02:	e6843503          	ld	a0,-408(s0)
    80019f06:	b63fd0ef          	jal	ra,80017a68 <minix3_get_zone>

        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    80019f0a:	f80407a3          	sb	zero,-113(s0)
    80019f0e:	ae21                	j	8001a226 <minix3_put_data+0x9e8>
    80019f10:	878a                	mv	a5,sp
    80019f12:	84be                	mv	s1,a5
            uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    80019f14:	f8f44783          	lbu	a5,-113(s0)
    80019f18:	2781                	sext.w	a5,a5
    80019f1a:	f4043703          	ld	a4,-192(s0)
    80019f1e:	078a                	slli	a5,a5,0x2
    80019f20:	97ba                	add	a5,a5,a4
    80019f22:	439c                	lw	a5,0(a5)
    80019f24:	f2f42e23          	sw	a5,-196(s0)
            if (indirect_zone == 0) continue;
    80019f28:	f3c42783          	lw	a5,-196(s0)
    80019f2c:	2781                	sext.w	a5,a5
    80019f2e:	e399                	bnez	a5,80019f34 <minix3_put_data+0x6f6>
    80019f30:	8126                	mv	sp,s1
    80019f32:	a4ed                	j	8001a21c <minix3_put_data+0x9de>

            uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    80019f34:	e6843503          	ld	a0,-408(s0)
    80019f38:	fd3fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019f3c:	87aa                	mv	a5,a0
    80019f3e:	0027d79b          	srliw	a5,a5,0x2
    80019f42:	17c2                	slli	a5,a5,0x30
    80019f44:	93c1                	srli	a5,a5,0x30
    80019f46:	873e                	mv	a4,a5
    80019f48:	177d                	addi	a4,a4,-1
    80019f4a:	f2e43823          	sd	a4,-208(s0)
    80019f4e:	def43023          	sd	a5,-544(s0)
    80019f52:	de043423          	sd	zero,-536(s0)
    80019f56:	de043703          	ld	a4,-544(s0)
    80019f5a:	936d                	srli	a4,a4,0x3b
    80019f5c:	de843683          	ld	a3,-536(s0)
    80019f60:	00569a93          	slli	s5,a3,0x5
    80019f64:	01576ab3          	or	s5,a4,s5
    80019f68:	de043703          	ld	a4,-544(s0)
    80019f6c:	00571a13          	slli	s4,a4,0x5
    80019f70:	dcf43823          	sd	a5,-560(s0)
    80019f74:	dc043c23          	sd	zero,-552(s0)
    80019f78:	dd043703          	ld	a4,-560(s0)
    80019f7c:	936d                	srli	a4,a4,0x3b
    80019f7e:	dd843683          	ld	a3,-552(s0)
    80019f82:	0696                	slli	a3,a3,0x5
    80019f84:	d0d43c23          	sd	a3,-744(s0)
    80019f88:	d1843683          	ld	a3,-744(s0)
    80019f8c:	8f55                	or	a4,a4,a3
    80019f8e:	d0e43c23          	sd	a4,-744(s0)
    80019f92:	dd043703          	ld	a4,-560(s0)
    80019f96:	0716                	slli	a4,a4,0x5
    80019f98:	d0e43823          	sd	a4,-752(s0)
    80019f9c:	078a                	slli	a5,a5,0x2
    80019f9e:	07bd                	addi	a5,a5,15
    80019fa0:	8391                	srli	a5,a5,0x4
    80019fa2:	0792                	slli	a5,a5,0x4
    80019fa4:	40f10133          	sub	sp,sp,a5
    80019fa8:	878a                	mv	a5,sp
    80019faa:	078d                	addi	a5,a5,3
    80019fac:	8389                	srli	a5,a5,0x2
    80019fae:	078a                	slli	a5,a5,0x2
    80019fb0:	f2f43423          	sd	a5,-216(s0)
            minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    80019fb4:	f3c42783          	lw	a5,-196(s0)
    80019fb8:	f2843603          	ld	a2,-216(s0)
    80019fbc:	85be                	mv	a1,a5
    80019fbe:	e6843503          	ld	a0,-408(s0)
    80019fc2:	aa7fd0ef          	jal	ra,80017a68 <minix3_get_zone>

            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    80019fc6:	f80401a3          	sb	zero,-125(s0)
    80019fca:	a405                	j	8001a1ea <minix3_put_data+0x9ac>
                uint32_t zone = indirect_zones[indirect_zone];
    80019fcc:	f8344783          	lbu	a5,-125(s0)
    80019fd0:	2781                	sext.w	a5,a5
    80019fd2:	f2843703          	ld	a4,-216(s0)
    80019fd6:	078a                	slli	a5,a5,0x2
    80019fd8:	97ba                	add	a5,a5,a4
    80019fda:	439c                	lw	a5,0(a5)
    80019fdc:	f2f42223          	sw	a5,-220(s0)
                if (zone == 0) continue;
    80019fe0:	f2442783          	lw	a5,-220(s0)
    80019fe4:	2781                	sext.w	a5,a5
    80019fe6:	1e078a63          	beqz	a5,8001a1da <minix3_put_data+0x99c>
                debugf("Writing double indirect zone %d\n", zone);

                if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    80019fea:	e6843503          	ld	a0,-408(s0)
    80019fee:	f1dfd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    80019ff2:	87aa                	mv	a5,a0
    80019ff4:	2781                	sext.w	a5,a5
    80019ff6:	f8842703          	lw	a4,-120(s0)
    80019ffa:	9fb9                	addw	a5,a5,a4
    80019ffc:	0007871b          	sext.w	a4,a5
    8001a000:	e6042783          	lw	a5,-416(s0)
    8001a004:	2781                	sext.w	a5,a5
    8001a006:	00f77e63          	bgeu	a4,a5,8001a022 <minix3_put_data+0x7e4>
                    // We're not at the offset yet
                    file_cursor += minix3_get_zone_size(block_device);
    8001a00a:	e6843503          	ld	a0,-408(s0)
    8001a00e:	efdfd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a012:	87aa                	mv	a5,a0
    8001a014:	2781                	sext.w	a5,a5
    8001a016:	f8842703          	lw	a4,-120(s0)
    8001a01a:	9fb9                	addw	a5,a5,a4
    8001a01c:	f8f42423          	sw	a5,-120(s0)
                    continue;
    8001a020:	a2c1                	j	8001a1e0 <minix3_put_data+0x9a2>
                } else if (file_cursor < offset) {
    8001a022:	f8842703          	lw	a4,-120(s0)
    8001a026:	e6042783          	lw	a5,-416(s0)
    8001a02a:	2701                	sext.w	a4,a4
    8001a02c:	2781                	sext.w	a5,a5
    8001a02e:	0cf77c63          	bgeu	a4,a5,8001a106 <minix3_put_data+0x8c8>
                    // We're in the middle of the offset
                    // Read the zone into the buffer
                    minix3_get_zone(block_device, zone, zone_data);
    8001a032:	f2442783          	lw	a5,-220(s0)
    8001a036:	f7043603          	ld	a2,-144(s0)
    8001a03a:	85be                	mv	a1,a5
    8001a03c:	e6843503          	ld	a0,-408(s0)
    8001a040:	a29fd0ef          	jal	ra,80017a68 <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    8001a044:	e6843503          	ld	a0,-408(s0)
    8001a048:	ec3fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a04c:	87aa                	mv	a5,a0
    8001a04e:	0007871b          	sext.w	a4,a5
    8001a052:	f8842683          	lw	a3,-120(s0)
    8001a056:	e6042783          	lw	a5,-416(s0)
    8001a05a:	40f687bb          	subw	a5,a3,a5
    8001a05e:	2781                	sext.w	a5,a5
    8001a060:	9fb9                	addw	a5,a5,a4
    8001a062:	0007871b          	sext.w	a4,a5
    8001a066:	e5442783          	lw	a5,-428(s0)
    8001a06a:	2781                	sext.w	a5,a5
    8001a06c:	02e7e563          	bltu	a5,a4,8001a096 <minix3_put_data+0x858>
    8001a070:	e6843503          	ld	a0,-408(s0)
    8001a074:	e97fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a078:	87aa                	mv	a5,a0
    8001a07a:	0007871b          	sext.w	a4,a5
    8001a07e:	f8842683          	lw	a3,-120(s0)
    8001a082:	e6042783          	lw	a5,-416(s0)
    8001a086:	40f687bb          	subw	a5,a3,a5
    8001a08a:	2781                	sext.w	a5,a5
    8001a08c:	9fb9                	addw	a5,a5,a4
    8001a08e:	2781                	sext.w	a5,a5
    8001a090:	1782                	slli	a5,a5,0x20
    8001a092:	9381                	srli	a5,a5,0x20
    8001a094:	a019                	j	8001a09a <minix3_put_data+0x85c>
    8001a096:	e5446783          	lwu	a5,-428(s0)
    8001a09a:	f0f43c23          	sd	a5,-232(s0)
                    memcpy(zone_data + offset - file_cursor, data, remaining);
    8001a09e:	e6046703          	lwu	a4,-416(s0)
    8001a0a2:	f8846783          	lwu	a5,-120(s0)
    8001a0a6:	40f707b3          	sub	a5,a4,a5
    8001a0aa:	f7043703          	ld	a4,-144(s0)
    8001a0ae:	97ba                	add	a5,a5,a4
    8001a0b0:	f1843703          	ld	a4,-232(s0)
    8001a0b4:	2701                	sext.w	a4,a4
    8001a0b6:	863a                	mv	a2,a4
    8001a0b8:	e5843583          	ld	a1,-424(s0)
    8001a0bc:	853e                	mv	a0,a5
    8001a0be:	280080ef          	jal	ra,8002233e <memcpy>
                    minix3_put_zone(block_device, zone, zone_data);
    8001a0c2:	f2442783          	lw	a5,-220(s0)
    8001a0c6:	f7043603          	ld	a2,-144(s0)
    8001a0ca:	85be                	mv	a1,a5
    8001a0cc:	e6843503          	ld	a0,-408(s0)
    8001a0d0:	a45fd0ef          	jal	ra,80017b14 <minix3_put_zone>

                    buffer_cursor += remaining;
    8001a0d4:	f1843783          	ld	a5,-232(s0)
    8001a0d8:	2781                	sext.w	a5,a5
    8001a0da:	f8442703          	lw	a4,-124(s0)
    8001a0de:	9fb9                	addw	a5,a5,a4
    8001a0e0:	f8f42223          	sw	a5,-124(s0)
                    file_cursor = offset + remaining;
    8001a0e4:	f1843783          	ld	a5,-232(s0)
    8001a0e8:	2781                	sext.w	a5,a5
    8001a0ea:	e6042703          	lw	a4,-416(s0)
    8001a0ee:	9fb9                	addw	a5,a5,a4
    8001a0f0:	f8f42423          	sw	a5,-120(s0)
                    if (buffer_cursor >= count) {
    8001a0f4:	f8442703          	lw	a4,-124(s0)
    8001a0f8:	e5442783          	lw	a5,-428(s0)
    8001a0fc:	2701                	sext.w	a4,a4
    8001a0fe:	2781                	sext.w	a5,a5
    8001a100:	0cf76f63          	bltu	a4,a5,8001a1de <minix3_put_data+0x9a0>
                        // We're done
                        return;
    8001a104:	aa09                	j	8001a216 <minix3_put_data+0x9d8>
                    }
                    continue;
                }

                memset(zone_data, 0, minix3_get_zone_size(block_device));
    8001a106:	e6843503          	ld	a0,-408(s0)
    8001a10a:	e01fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a10e:	87aa                	mv	a5,a0
    8001a110:	2781                	sext.w	a5,a5
    8001a112:	863e                	mv	a2,a5
    8001a114:	4581                	li	a1,0
    8001a116:	f7043503          	ld	a0,-144(s0)
    8001a11a:	122080ef          	jal	ra,8002223c <memset>
                if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    8001a11e:	e6843503          	ld	a0,-408(s0)
    8001a122:	de9fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a126:	87aa                	mv	a5,a0
    8001a128:	2781                	sext.w	a5,a5
    8001a12a:	f8442703          	lw	a4,-124(s0)
    8001a12e:	9fb9                	addw	a5,a5,a4
    8001a130:	0007871b          	sext.w	a4,a5
    8001a134:	e5442783          	lw	a5,-428(s0)
    8001a138:	2781                	sext.w	a5,a5
    8001a13a:	04e7f963          	bgeu	a5,a4,8001a18c <minix3_put_data+0x94e>
                    minix3_get_zone(block_device, zone, zone_data);
    8001a13e:	f2442783          	lw	a5,-220(s0)
    8001a142:	f7043603          	ld	a2,-144(s0)
    8001a146:	85be                	mv	a1,a5
    8001a148:	e6843503          	ld	a0,-408(s0)
    8001a14c:	91dfd0ef          	jal	ra,80017a68 <minix3_get_zone>
                    // Copy the remaining data into the buffer
                    memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    8001a150:	f8446783          	lwu	a5,-124(s0)
    8001a154:	e5843703          	ld	a4,-424(s0)
    8001a158:	00f706b3          	add	a3,a4,a5
    8001a15c:	e5442703          	lw	a4,-428(s0)
    8001a160:	f8442783          	lw	a5,-124(s0)
    8001a164:	40f707bb          	subw	a5,a4,a5
    8001a168:	2781                	sext.w	a5,a5
    8001a16a:	2781                	sext.w	a5,a5
    8001a16c:	863e                	mv	a2,a5
    8001a16e:	85b6                	mv	a1,a3
    8001a170:	f7043503          	ld	a0,-144(s0)
    8001a174:	1ca080ef          	jal	ra,8002233e <memcpy>
                    // We're done
                    minix3_put_zone(block_device, zone, zone_data);
    8001a178:	f2442783          	lw	a5,-220(s0)
    8001a17c:	f7043603          	ld	a2,-144(s0)
    8001a180:	85be                	mv	a1,a5
    8001a182:	e6843503          	ld	a0,-408(s0)
    8001a186:	98ffd0ef          	jal	ra,80017b14 <minix3_put_zone>
                    return;
    8001a18a:	a071                	j	8001a216 <minix3_put_data+0x9d8>
                } else {
                    // Copy the entire zone into the buffer
                    memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    8001a18c:	f8446783          	lwu	a5,-124(s0)
    8001a190:	e5843703          	ld	a4,-424(s0)
    8001a194:	00f70933          	add	s2,a4,a5
    8001a198:	e6843503          	ld	a0,-408(s0)
    8001a19c:	d6ffd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a1a0:	87aa                	mv	a5,a0
    8001a1a2:	2781                	sext.w	a5,a5
    8001a1a4:	863e                	mv	a2,a5
    8001a1a6:	85ca                	mv	a1,s2
    8001a1a8:	f7043503          	ld	a0,-144(s0)
    8001a1ac:	192080ef          	jal	ra,8002233e <memcpy>
                    minix3_put_zone(block_device, zone, zone_data);
    8001a1b0:	f2442783          	lw	a5,-220(s0)
    8001a1b4:	f7043603          	ld	a2,-144(s0)
    8001a1b8:	85be                	mv	a1,a5
    8001a1ba:	e6843503          	ld	a0,-408(s0)
    8001a1be:	957fd0ef          	jal	ra,80017b14 <minix3_put_zone>
                }

                buffer_cursor += minix3_get_zone_size(block_device);
    8001a1c2:	e6843503          	ld	a0,-408(s0)
    8001a1c6:	d45fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a1ca:	87aa                	mv	a5,a0
    8001a1cc:	2781                	sext.w	a5,a5
    8001a1ce:	f8442703          	lw	a4,-124(s0)
    8001a1d2:	9fb9                	addw	a5,a5,a4
    8001a1d4:	f8f42223          	sw	a5,-124(s0)
    8001a1d8:	a021                	j	8001a1e0 <minix3_put_data+0x9a2>
                if (zone == 0) continue;
    8001a1da:	0001                	nop
    8001a1dc:	a011                	j	8001a1e0 <minix3_put_data+0x9a2>
                    continue;
    8001a1de:	0001                	nop
            for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001a1e0:	f8344783          	lbu	a5,-125(s0)
    8001a1e4:	2785                	addiw	a5,a5,1
    8001a1e6:	f8f401a3          	sb	a5,-125(s0)
    8001a1ea:	f8344783          	lbu	a5,-125(s0)
    8001a1ee:	03079913          	slli	s2,a5,0x30
    8001a1f2:	03095913          	srli	s2,s2,0x30
    8001a1f6:	e6843503          	ld	a0,-408(s0)
    8001a1fa:	d11fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a1fe:	87aa                	mv	a5,a0
    8001a200:	0027d79b          	srliw	a5,a5,0x2
    8001a204:	17c2                	slli	a5,a5,0x30
    8001a206:	93c1                	srli	a5,a5,0x30
    8001a208:	0009071b          	sext.w	a4,s2
    8001a20c:	2781                	sext.w	a5,a5
    8001a20e:	daf76fe3          	bltu	a4,a5,80019fcc <minix3_put_data+0x78e>
    8001a212:	8126                	mv	sp,s1
    8001a214:	a021                	j	8001a21c <minix3_put_data+0x9de>
    8001a216:	8126                	mv	sp,s1
    8001a218:	814e                	mv	sp,s3
    8001a21a:	a329                	j	8001a724 <minix3_put_data+0xee6>
        for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    8001a21c:	f8f44783          	lbu	a5,-113(s0)
    8001a220:	2785                	addiw	a5,a5,1
    8001a222:	f8f407a3          	sb	a5,-113(s0)
    8001a226:	f8f44783          	lbu	a5,-113(s0)
    8001a22a:	03079493          	slli	s1,a5,0x30
    8001a22e:	90c1                	srli	s1,s1,0x30
    8001a230:	e6843503          	ld	a0,-408(s0)
    8001a234:	cd7fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a238:	87aa                	mv	a5,a0
    8001a23a:	0027d79b          	srliw	a5,a5,0x2
    8001a23e:	17c2                	slli	a5,a5,0x30
    8001a240:	93c1                	srli	a5,a5,0x30
    8001a242:	0004871b          	sext.w	a4,s1
    8001a246:	2781                	sext.w	a5,a5
    8001a248:	ccf764e3          	bltu	a4,a5,80019f10 <minix3_put_data+0x6d2>
    8001a24c:	814e                	mv	sp,s3
    } else {
        debugf("No double indirect zone\n");
    }

    // The next zone is a triple indirect zone
    if (inode_data.zones[9] != 0) {
    8001a24e:	eb442783          	lw	a5,-332(s0)
    8001a252:	4c078863          	beqz	a5,8001a722 <minix3_put_data+0xee4>
    8001a256:	878a                	mv	a5,sp
    8001a258:	8a3e                	mv	s4,a5
        uint32_t triple_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    8001a25a:	e6843503          	ld	a0,-408(s0)
    8001a25e:	cadfd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a262:	87aa                	mv	a5,a0
    8001a264:	0027d79b          	srliw	a5,a5,0x2
    8001a268:	17c2                	slli	a5,a5,0x30
    8001a26a:	93c1                	srli	a5,a5,0x30
    8001a26c:	873e                	mv	a4,a5
    8001a26e:	177d                	addi	a4,a4,-1
    8001a270:	f0e43823          	sd	a4,-240(s0)
    8001a274:	dcf43023          	sd	a5,-576(s0)
    8001a278:	dc043423          	sd	zero,-568(s0)
    8001a27c:	dc043703          	ld	a4,-576(s0)
    8001a280:	936d                	srli	a4,a4,0x3b
    8001a282:	dc843683          	ld	a3,-568(s0)
    8001a286:	0696                	slli	a3,a3,0x5
    8001a288:	d0d43423          	sd	a3,-760(s0)
    8001a28c:	d0843683          	ld	a3,-760(s0)
    8001a290:	8f55                	or	a4,a4,a3
    8001a292:	d0e43423          	sd	a4,-760(s0)
    8001a296:	dc043703          	ld	a4,-576(s0)
    8001a29a:	0716                	slli	a4,a4,0x5
    8001a29c:	d0e43023          	sd	a4,-768(s0)
    8001a2a0:	daf43823          	sd	a5,-592(s0)
    8001a2a4:	da043c23          	sd	zero,-584(s0)
    8001a2a8:	db043703          	ld	a4,-592(s0)
    8001a2ac:	936d                	srli	a4,a4,0x3b
    8001a2ae:	db843683          	ld	a3,-584(s0)
    8001a2b2:	0696                	slli	a3,a3,0x5
    8001a2b4:	ced43c23          	sd	a3,-776(s0)
    8001a2b8:	cf843683          	ld	a3,-776(s0)
    8001a2bc:	8f55                	or	a4,a4,a3
    8001a2be:	cee43c23          	sd	a4,-776(s0)
    8001a2c2:	db043703          	ld	a4,-592(s0)
    8001a2c6:	0716                	slli	a4,a4,0x5
    8001a2c8:	cee43823          	sd	a4,-784(s0)
    8001a2cc:	078a                	slli	a5,a5,0x2
    8001a2ce:	07bd                	addi	a5,a5,15
    8001a2d0:	8391                	srli	a5,a5,0x4
    8001a2d2:	0792                	slli	a5,a5,0x4
    8001a2d4:	40f10133          	sub	sp,sp,a5
    8001a2d8:	878a                	mv	a5,sp
    8001a2da:	078d                	addi	a5,a5,3
    8001a2dc:	8389                	srli	a5,a5,0x2
    8001a2de:	078a                	slli	a5,a5,0x2
    8001a2e0:	f0f43423          	sd	a5,-248(s0)
        minix3_get_zone(block_device, inode_data.zones[9], (uint8_t*)triple_indirect_zones);
    8001a2e4:	eb442783          	lw	a5,-332(s0)
    8001a2e8:	f0843603          	ld	a2,-248(s0)
    8001a2ec:	85be                	mv	a1,a5
    8001a2ee:	e6843503          	ld	a0,-408(s0)
    8001a2f2:	f76fd0ef          	jal	ra,80017a68 <minix3_get_zone>

        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    8001a2f6:	f8040123          	sb	zero,-126(s0)
    8001a2fa:	a101                	j	8001a6fa <minix3_put_data+0xebc>
    8001a2fc:	878a                	mv	a5,sp
    8001a2fe:	84be                	mv	s1,a5
            uint32_t double_indirect_zone = triple_indirect_zones[triple_indirect_zone];
    8001a300:	f8244783          	lbu	a5,-126(s0)
    8001a304:	2781                	sext.w	a5,a5
    8001a306:	f0843703          	ld	a4,-248(s0)
    8001a30a:	078a                	slli	a5,a5,0x2
    8001a30c:	97ba                	add	a5,a5,a4
    8001a30e:	439c                	lw	a5,0(a5)
    8001a310:	f0f42223          	sw	a5,-252(s0)
            if (double_indirect_zone == 0) continue;
    8001a314:	f0442783          	lw	a5,-252(s0)
    8001a318:	2781                	sext.w	a5,a5
    8001a31a:	e399                	bnez	a5,8001a320 <minix3_put_data+0xae2>
    8001a31c:	8126                	mv	sp,s1
    8001a31e:	aec9                	j	8001a6f0 <minix3_put_data+0xeb2>
            uint32_t double_indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    8001a320:	e6843503          	ld	a0,-408(s0)
    8001a324:	be7fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a328:	87aa                	mv	a5,a0
    8001a32a:	0027d79b          	srliw	a5,a5,0x2
    8001a32e:	17c2                	slli	a5,a5,0x30
    8001a330:	93c1                	srli	a5,a5,0x30
    8001a332:	873e                	mv	a4,a5
    8001a334:	177d                	addi	a4,a4,-1
    8001a336:	eee43c23          	sd	a4,-264(s0)
    8001a33a:	daf43023          	sd	a5,-608(s0)
    8001a33e:	da043423          	sd	zero,-600(s0)
    8001a342:	da043703          	ld	a4,-608(s0)
    8001a346:	936d                	srli	a4,a4,0x3b
    8001a348:	da843683          	ld	a3,-600(s0)
    8001a34c:	00569b93          	slli	s7,a3,0x5
    8001a350:	01776bb3          	or	s7,a4,s7
    8001a354:	da043703          	ld	a4,-608(s0)
    8001a358:	00571b13          	slli	s6,a4,0x5
    8001a35c:	d8f43823          	sd	a5,-624(s0)
    8001a360:	d8043c23          	sd	zero,-616(s0)
    8001a364:	d9043703          	ld	a4,-624(s0)
    8001a368:	936d                	srli	a4,a4,0x3b
    8001a36a:	d9843683          	ld	a3,-616(s0)
    8001a36e:	00569c93          	slli	s9,a3,0x5
    8001a372:	01976cb3          	or	s9,a4,s9
    8001a376:	d9043703          	ld	a4,-624(s0)
    8001a37a:	00571c13          	slli	s8,a4,0x5
    8001a37e:	078a                	slli	a5,a5,0x2
    8001a380:	07bd                	addi	a5,a5,15
    8001a382:	8391                	srli	a5,a5,0x4
    8001a384:	0792                	slli	a5,a5,0x4
    8001a386:	40f10133          	sub	sp,sp,a5
    8001a38a:	878a                	mv	a5,sp
    8001a38c:	078d                	addi	a5,a5,3
    8001a38e:	8389                	srli	a5,a5,0x2
    8001a390:	078a                	slli	a5,a5,0x2
    8001a392:	eef43823          	sd	a5,-272(s0)
            minix3_get_zone(block_device, double_indirect_zone, (uint8_t*)double_indirect_zones);
    8001a396:	f0442783          	lw	a5,-252(s0)
    8001a39a:	ef043603          	ld	a2,-272(s0)
    8001a39e:	85be                	mv	a1,a5
    8001a3a0:	e6843503          	ld	a0,-408(s0)
    8001a3a4:	ec4fd0ef          	jal	ra,80017a68 <minix3_get_zone>

            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    8001a3a8:	f80400a3          	sb	zero,-127(s0)
    8001a3ac:	ae29                	j	8001a6c6 <minix3_put_data+0xe88>
    8001a3ae:	878a                	mv	a5,sp
    8001a3b0:	893e                	mv	s2,a5
                uint32_t indirect_zone = double_indirect_zones[double_indirect_zone];
    8001a3b2:	f8144783          	lbu	a5,-127(s0)
    8001a3b6:	2781                	sext.w	a5,a5
    8001a3b8:	ef043703          	ld	a4,-272(s0)
    8001a3bc:	078a                	slli	a5,a5,0x2
    8001a3be:	97ba                	add	a5,a5,a4
    8001a3c0:	439c                	lw	a5,0(a5)
    8001a3c2:	eef42623          	sw	a5,-276(s0)
                if (indirect_zone == 0) continue;
    8001a3c6:	eec42783          	lw	a5,-276(s0)
    8001a3ca:	2781                	sext.w	a5,a5
    8001a3cc:	e399                	bnez	a5,8001a3d2 <minix3_put_data+0xb94>
    8001a3ce:	814a                	mv	sp,s2
    8001a3d0:	a4f5                	j	8001a6bc <minix3_put_data+0xe7e>
                uint32_t indirect_zones[minix3_get_zone_size(block_device) / sizeof(uint32_t)];
    8001a3d2:	e6843503          	ld	a0,-408(s0)
    8001a3d6:	b35fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a3da:	87aa                	mv	a5,a0
    8001a3dc:	0027d79b          	srliw	a5,a5,0x2
    8001a3e0:	17c2                	slli	a5,a5,0x30
    8001a3e2:	93c1                	srli	a5,a5,0x30
    8001a3e4:	873e                	mv	a4,a5
    8001a3e6:	177d                	addi	a4,a4,-1
    8001a3e8:	eee43023          	sd	a4,-288(s0)
    8001a3ec:	d8f43023          	sd	a5,-640(s0)
    8001a3f0:	d8043423          	sd	zero,-632(s0)
    8001a3f4:	d8043703          	ld	a4,-640(s0)
    8001a3f8:	936d                	srli	a4,a4,0x3b
    8001a3fa:	d8843683          	ld	a3,-632(s0)
    8001a3fe:	00569d93          	slli	s11,a3,0x5
    8001a402:	01b76db3          	or	s11,a4,s11
    8001a406:	d8043703          	ld	a4,-640(s0)
    8001a40a:	00571d13          	slli	s10,a4,0x5
    8001a40e:	d6f43823          	sd	a5,-656(s0)
    8001a412:	d6043c23          	sd	zero,-648(s0)
    8001a416:	d7043703          	ld	a4,-656(s0)
    8001a41a:	936d                	srli	a4,a4,0x3b
    8001a41c:	d7843683          	ld	a3,-648(s0)
    8001a420:	0696                	slli	a3,a3,0x5
    8001a422:	ced43423          	sd	a3,-792(s0)
    8001a426:	ce843683          	ld	a3,-792(s0)
    8001a42a:	8f55                	or	a4,a4,a3
    8001a42c:	cee43423          	sd	a4,-792(s0)
    8001a430:	d7043703          	ld	a4,-656(s0)
    8001a434:	0716                	slli	a4,a4,0x5
    8001a436:	cee43023          	sd	a4,-800(s0)
    8001a43a:	078a                	slli	a5,a5,0x2
    8001a43c:	07bd                	addi	a5,a5,15
    8001a43e:	8391                	srli	a5,a5,0x4
    8001a440:	0792                	slli	a5,a5,0x4
    8001a442:	40f10133          	sub	sp,sp,a5
    8001a446:	878a                	mv	a5,sp
    8001a448:	078d                	addi	a5,a5,3
    8001a44a:	8389                	srli	a5,a5,0x2
    8001a44c:	078a                	slli	a5,a5,0x2
    8001a44e:	ecf43c23          	sd	a5,-296(s0)
                minix3_get_zone(block_device, indirect_zone, (uint8_t*)indirect_zones);
    8001a452:	eec42783          	lw	a5,-276(s0)
    8001a456:	ed843603          	ld	a2,-296(s0)
    8001a45a:	85be                	mv	a1,a5
    8001a45c:	e6843503          	ld	a0,-408(s0)
    8001a460:	e08fd0ef          	jal	ra,80017a68 <minix3_get_zone>

                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001a464:	f8040023          	sb	zero,-128(s0)
    8001a468:	a405                	j	8001a688 <minix3_put_data+0xe4a>
                    uint32_t zone = indirect_zones[indirect_zone];
    8001a46a:	f8044783          	lbu	a5,-128(s0)
    8001a46e:	2781                	sext.w	a5,a5
    8001a470:	ed843703          	ld	a4,-296(s0)
    8001a474:	078a                	slli	a5,a5,0x2
    8001a476:	97ba                	add	a5,a5,a4
    8001a478:	439c                	lw	a5,0(a5)
    8001a47a:	ecf42a23          	sw	a5,-300(s0)
                    if (zone == 0) continue;
    8001a47e:	ed442783          	lw	a5,-300(s0)
    8001a482:	2781                	sext.w	a5,a5
    8001a484:	1e078a63          	beqz	a5,8001a678 <minix3_put_data+0xe3a>
                    debugf("Writing triple indirect zone %d\n", zone);

                    if (file_cursor + minix3_get_zone_size(block_device) < offset) {
    8001a488:	e6843503          	ld	a0,-408(s0)
    8001a48c:	a7ffd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a490:	87aa                	mv	a5,a0
    8001a492:	2781                	sext.w	a5,a5
    8001a494:	f8842703          	lw	a4,-120(s0)
    8001a498:	9fb9                	addw	a5,a5,a4
    8001a49a:	0007871b          	sext.w	a4,a5
    8001a49e:	e6042783          	lw	a5,-416(s0)
    8001a4a2:	2781                	sext.w	a5,a5
    8001a4a4:	00f77e63          	bgeu	a4,a5,8001a4c0 <minix3_put_data+0xc82>
                        // We're not at the offset yet
                        file_cursor += minix3_get_zone_size(block_device);
    8001a4a8:	e6843503          	ld	a0,-408(s0)
    8001a4ac:	a5ffd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a4b0:	87aa                	mv	a5,a0
    8001a4b2:	2781                	sext.w	a5,a5
    8001a4b4:	f8842703          	lw	a4,-120(s0)
    8001a4b8:	9fb9                	addw	a5,a5,a4
    8001a4ba:	f8f42423          	sw	a5,-120(s0)
                        continue;
    8001a4be:	a2c1                	j	8001a67e <minix3_put_data+0xe40>
                    } else if (file_cursor < offset) {
    8001a4c0:	f8842703          	lw	a4,-120(s0)
    8001a4c4:	e6042783          	lw	a5,-416(s0)
    8001a4c8:	2701                	sext.w	a4,a4
    8001a4ca:	2781                	sext.w	a5,a5
    8001a4cc:	0cf77c63          	bgeu	a4,a5,8001a5a4 <minix3_put_data+0xd66>
                        // We're in the middle of the offset
                        // Read the zone into the buffer
                        minix3_get_zone(block_device, zone, zone_data);
    8001a4d0:	ed442783          	lw	a5,-300(s0)
    8001a4d4:	f7043603          	ld	a2,-144(s0)
    8001a4d8:	85be                	mv	a1,a5
    8001a4da:	e6843503          	ld	a0,-408(s0)
    8001a4de:	d8afd0ef          	jal	ra,80017a68 <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        size_t remaining = min(count, minix3_get_zone_size(block_device) - (offset - file_cursor));
    8001a4e2:	e6843503          	ld	a0,-408(s0)
    8001a4e6:	a25fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a4ea:	87aa                	mv	a5,a0
    8001a4ec:	0007871b          	sext.w	a4,a5
    8001a4f0:	f8842683          	lw	a3,-120(s0)
    8001a4f4:	e6042783          	lw	a5,-416(s0)
    8001a4f8:	40f687bb          	subw	a5,a3,a5
    8001a4fc:	2781                	sext.w	a5,a5
    8001a4fe:	9fb9                	addw	a5,a5,a4
    8001a500:	0007871b          	sext.w	a4,a5
    8001a504:	e5442783          	lw	a5,-428(s0)
    8001a508:	2781                	sext.w	a5,a5
    8001a50a:	02e7e563          	bltu	a5,a4,8001a534 <minix3_put_data+0xcf6>
    8001a50e:	e6843503          	ld	a0,-408(s0)
    8001a512:	9f9fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a516:	87aa                	mv	a5,a0
    8001a518:	0007871b          	sext.w	a4,a5
    8001a51c:	f8842683          	lw	a3,-120(s0)
    8001a520:	e6042783          	lw	a5,-416(s0)
    8001a524:	40f687bb          	subw	a5,a3,a5
    8001a528:	2781                	sext.w	a5,a5
    8001a52a:	9fb9                	addw	a5,a5,a4
    8001a52c:	2781                	sext.w	a5,a5
    8001a52e:	1782                	slli	a5,a5,0x20
    8001a530:	9381                	srli	a5,a5,0x20
    8001a532:	a019                	j	8001a538 <minix3_put_data+0xcfa>
    8001a534:	e5446783          	lwu	a5,-428(s0)
    8001a538:	ecf43423          	sd	a5,-312(s0)
                        memcpy(zone_data + offset - file_cursor, data, remaining);
    8001a53c:	e6046703          	lwu	a4,-416(s0)
    8001a540:	f8846783          	lwu	a5,-120(s0)
    8001a544:	40f707b3          	sub	a5,a4,a5
    8001a548:	f7043703          	ld	a4,-144(s0)
    8001a54c:	97ba                	add	a5,a5,a4
    8001a54e:	ec843703          	ld	a4,-312(s0)
    8001a552:	2701                	sext.w	a4,a4
    8001a554:	863a                	mv	a2,a4
    8001a556:	e5843583          	ld	a1,-424(s0)
    8001a55a:	853e                	mv	a0,a5
    8001a55c:	5e3070ef          	jal	ra,8002233e <memcpy>
                        minix3_put_zone(block_device, zone, zone_data);
    8001a560:	ed442783          	lw	a5,-300(s0)
    8001a564:	f7043603          	ld	a2,-144(s0)
    8001a568:	85be                	mv	a1,a5
    8001a56a:	e6843503          	ld	a0,-408(s0)
    8001a56e:	da6fd0ef          	jal	ra,80017b14 <minix3_put_zone>

                        buffer_cursor += remaining;
    8001a572:	ec843783          	ld	a5,-312(s0)
    8001a576:	2781                	sext.w	a5,a5
    8001a578:	f8442703          	lw	a4,-124(s0)
    8001a57c:	9fb9                	addw	a5,a5,a4
    8001a57e:	f8f42223          	sw	a5,-124(s0)
                        file_cursor = offset + remaining;
    8001a582:	ec843783          	ld	a5,-312(s0)
    8001a586:	2781                	sext.w	a5,a5
    8001a588:	e6042703          	lw	a4,-416(s0)
    8001a58c:	9fb9                	addw	a5,a5,a4
    8001a58e:	f8f42423          	sw	a5,-120(s0)
                        if (buffer_cursor >= count) {
    8001a592:	f8442703          	lw	a4,-124(s0)
    8001a596:	e5442783          	lw	a5,-428(s0)
    8001a59a:	2701                	sext.w	a4,a4
    8001a59c:	2781                	sext.w	a5,a5
    8001a59e:	0cf76f63          	bltu	a4,a5,8001a67c <minix3_put_data+0xe3e>
                            // We're done
                            return;
    8001a5a2:	aa09                	j	8001a6b4 <minix3_put_data+0xe76>
                        }
                        continue;
                    }

                    memset(zone_data, 0, minix3_get_zone_size(block_device));
    8001a5a4:	e6843503          	ld	a0,-408(s0)
    8001a5a8:	963fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a5ac:	87aa                	mv	a5,a0
    8001a5ae:	2781                	sext.w	a5,a5
    8001a5b0:	863e                	mv	a2,a5
    8001a5b2:	4581                	li	a1,0
    8001a5b4:	f7043503          	ld	a0,-144(s0)
    8001a5b8:	485070ef          	jal	ra,8002223c <memset>

                    if (buffer_cursor + minix3_get_zone_size(block_device) > count) {
    8001a5bc:	e6843503          	ld	a0,-408(s0)
    8001a5c0:	94bfd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a5c4:	87aa                	mv	a5,a0
    8001a5c6:	2781                	sext.w	a5,a5
    8001a5c8:	f8442703          	lw	a4,-124(s0)
    8001a5cc:	9fb9                	addw	a5,a5,a4
    8001a5ce:	0007871b          	sext.w	a4,a5
    8001a5d2:	e5442783          	lw	a5,-428(s0)
    8001a5d6:	2781                	sext.w	a5,a5
    8001a5d8:	04e7f963          	bgeu	a5,a4,8001a62a <minix3_put_data+0xdec>
                        minix3_get_zone(block_device, zone, zone_data);
    8001a5dc:	ed442783          	lw	a5,-300(s0)
    8001a5e0:	f7043603          	ld	a2,-144(s0)
    8001a5e4:	85be                	mv	a1,a5
    8001a5e6:	e6843503          	ld	a0,-408(s0)
    8001a5ea:	c7efd0ef          	jal	ra,80017a68 <minix3_get_zone>
                        // Copy the remaining data into the buffer
                        memcpy(zone_data, data + buffer_cursor, count - buffer_cursor);
    8001a5ee:	f8446783          	lwu	a5,-124(s0)
    8001a5f2:	e5843703          	ld	a4,-424(s0)
    8001a5f6:	00f706b3          	add	a3,a4,a5
    8001a5fa:	e5442703          	lw	a4,-428(s0)
    8001a5fe:	f8442783          	lw	a5,-124(s0)
    8001a602:	40f707bb          	subw	a5,a4,a5
    8001a606:	2781                	sext.w	a5,a5
    8001a608:	2781                	sext.w	a5,a5
    8001a60a:	863e                	mv	a2,a5
    8001a60c:	85b6                	mv	a1,a3
    8001a60e:	f7043503          	ld	a0,-144(s0)
    8001a612:	52d070ef          	jal	ra,8002233e <memcpy>
                        // We're done
                        minix3_put_zone(block_device, zone, zone_data);
    8001a616:	ed442783          	lw	a5,-300(s0)
    8001a61a:	f7043603          	ld	a2,-144(s0)
    8001a61e:	85be                	mv	a1,a5
    8001a620:	e6843503          	ld	a0,-408(s0)
    8001a624:	cf0fd0ef          	jal	ra,80017b14 <minix3_put_zone>
                        return;
    8001a628:	a071                	j	8001a6b4 <minix3_put_data+0xe76>
                    } else {
                        // Copy the entire zone into the buffer
                        memcpy(zone_data, data + buffer_cursor, minix3_get_zone_size(block_device));
    8001a62a:	f8446783          	lwu	a5,-124(s0)
    8001a62e:	e5843703          	ld	a4,-424(s0)
    8001a632:	00f709b3          	add	s3,a4,a5
    8001a636:	e6843503          	ld	a0,-408(s0)
    8001a63a:	8d1fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a63e:	87aa                	mv	a5,a0
    8001a640:	2781                	sext.w	a5,a5
    8001a642:	863e                	mv	a2,a5
    8001a644:	85ce                	mv	a1,s3
    8001a646:	f7043503          	ld	a0,-144(s0)
    8001a64a:	4f5070ef          	jal	ra,8002233e <memcpy>
                        minix3_put_zone(block_device, zone, zone_data);
    8001a64e:	ed442783          	lw	a5,-300(s0)
    8001a652:	f7043603          	ld	a2,-144(s0)
    8001a656:	85be                	mv	a1,a5
    8001a658:	e6843503          	ld	a0,-408(s0)
    8001a65c:	cb8fd0ef          	jal	ra,80017b14 <minix3_put_zone>
                    }
                    buffer_cursor += minix3_get_zone_size(block_device);
    8001a660:	e6843503          	ld	a0,-408(s0)
    8001a664:	8a7fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a668:	87aa                	mv	a5,a0
    8001a66a:	2781                	sext.w	a5,a5
    8001a66c:	f8442703          	lw	a4,-124(s0)
    8001a670:	9fb9                	addw	a5,a5,a4
    8001a672:	f8f42223          	sw	a5,-124(s0)
    8001a676:	a021                	j	8001a67e <minix3_put_data+0xe40>
                    if (zone == 0) continue;
    8001a678:	0001                	nop
    8001a67a:	a011                	j	8001a67e <minix3_put_data+0xe40>
                        continue;
    8001a67c:	0001                	nop
                for (uint8_t indirect_zone=0; indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); indirect_zone++) {
    8001a67e:	f8044783          	lbu	a5,-128(s0)
    8001a682:	2785                	addiw	a5,a5,1
    8001a684:	f8f40023          	sb	a5,-128(s0)
    8001a688:	f8044783          	lbu	a5,-128(s0)
    8001a68c:	03079993          	slli	s3,a5,0x30
    8001a690:	0309d993          	srli	s3,s3,0x30
    8001a694:	e6843503          	ld	a0,-408(s0)
    8001a698:	873fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a69c:	87aa                	mv	a5,a0
    8001a69e:	0027d79b          	srliw	a5,a5,0x2
    8001a6a2:	17c2                	slli	a5,a5,0x30
    8001a6a4:	93c1                	srli	a5,a5,0x30
    8001a6a6:	0009871b          	sext.w	a4,s3
    8001a6aa:	2781                	sext.w	a5,a5
    8001a6ac:	daf76fe3          	bltu	a4,a5,8001a46a <minix3_put_data+0xc2c>
    8001a6b0:	814a                	mv	sp,s2
    8001a6b2:	a029                	j	8001a6bc <minix3_put_data+0xe7e>
    8001a6b4:	814a                	mv	sp,s2
    8001a6b6:	8126                	mv	sp,s1
    8001a6b8:	8152                	mv	sp,s4
    8001a6ba:	a0ad                	j	8001a724 <minix3_put_data+0xee6>
            for (uint8_t double_indirect_zone=0; double_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); double_indirect_zone++) {
    8001a6bc:	f8144783          	lbu	a5,-127(s0)
    8001a6c0:	2785                	addiw	a5,a5,1
    8001a6c2:	f8f400a3          	sb	a5,-127(s0)
    8001a6c6:	f8144783          	lbu	a5,-127(s0)
    8001a6ca:	03079913          	slli	s2,a5,0x30
    8001a6ce:	03095913          	srli	s2,s2,0x30
    8001a6d2:	e6843503          	ld	a0,-408(s0)
    8001a6d6:	835fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a6da:	87aa                	mv	a5,a0
    8001a6dc:	0027d79b          	srliw	a5,a5,0x2
    8001a6e0:	17c2                	slli	a5,a5,0x30
    8001a6e2:	93c1                	srli	a5,a5,0x30
    8001a6e4:	0009071b          	sext.w	a4,s2
    8001a6e8:	2781                	sext.w	a5,a5
    8001a6ea:	ccf762e3          	bltu	a4,a5,8001a3ae <minix3_put_data+0xb70>
    8001a6ee:	8126                	mv	sp,s1
        for (uint8_t triple_indirect_zone=0; triple_indirect_zone<minix3_get_zone_size(block_device) / sizeof(uint32_t); triple_indirect_zone++) {
    8001a6f0:	f8244783          	lbu	a5,-126(s0)
    8001a6f4:	2785                	addiw	a5,a5,1
    8001a6f6:	f8f40123          	sb	a5,-126(s0)
    8001a6fa:	f8244783          	lbu	a5,-126(s0)
    8001a6fe:	03079493          	slli	s1,a5,0x30
    8001a702:	90c1                	srli	s1,s1,0x30
    8001a704:	e6843503          	ld	a0,-408(s0)
    8001a708:	803fd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a70c:	87aa                	mv	a5,a0
    8001a70e:	0027d79b          	srliw	a5,a5,0x2
    8001a712:	17c2                	slli	a5,a5,0x30
    8001a714:	93c1                	srli	a5,a5,0x30
    8001a716:	0004871b          	sext.w	a4,s1
    8001a71a:	2781                	sext.w	a5,a5
    8001a71c:	bef760e3          	bltu	a4,a5,8001a2fc <minix3_put_data+0xabe>
    8001a720:	8152                	mv	sp,s4
        debugf("No triple indirect zone\n");
    }


    // If we get here, we've read all the data we can
    return;
    8001a722:	0001                	nop
    8001a724:	cd843103          	ld	sp,-808(s0)
}
    8001a728:	cd040113          	addi	sp,s0,-816
    8001a72c:	32813083          	ld	ra,808(sp)
    8001a730:	32013403          	ld	s0,800(sp)
    8001a734:	31813483          	ld	s1,792(sp)
    8001a738:	31013903          	ld	s2,784(sp)
    8001a73c:	30813983          	ld	s3,776(sp)
    8001a740:	30013a03          	ld	s4,768(sp)
    8001a744:	2f813a83          	ld	s5,760(sp)
    8001a748:	2f013b03          	ld	s6,752(sp)
    8001a74c:	2e813b83          	ld	s7,744(sp)
    8001a750:	2e013c03          	ld	s8,736(sp)
    8001a754:	2d813c83          	ld	s9,728(sp)
    8001a758:	2d013d03          	ld	s10,720(sp)
    8001a75c:	2c813d83          	ld	s11,712(sp)
    8001a760:	33010113          	addi	sp,sp,816
    8001a764:	8082                	ret

000000008001a766 <minix3_find_next_free_dir_entry>:

// TODO: Figure out a better way to report error than return -1 since it can 
// be a valid dir entry number.
uint32_t minix3_find_next_free_dir_entry(VirtioDevice *block_device, uint32_t inode) {
    8001a766:	7171                	addi	sp,sp,-176
    8001a768:	f506                	sd	ra,168(sp)
    8001a76a:	f122                	sd	s0,160(sp)
    8001a76c:	1900                	addi	s0,sp,176
    8001a76e:	f4a43c23          	sd	a0,-168(s0)
    8001a772:	87ae                	mv	a5,a1
    8001a774:	f4f42a23          	sw	a5,-172(s0)
    if (!minix3_is_dir(block_device, inode)) {
    8001a778:	f5442783          	lw	a5,-172(s0)
    8001a77c:	85be                	mv	a1,a5
    8001a77e:	f5843503          	ld	a0,-168(s0)
    8001a782:	93afe0ef          	jal	ra,800188bc <minix3_is_dir>
    8001a786:	87aa                	mv	a5,a0
    8001a788:	0017c793          	xori	a5,a5,1
    8001a78c:	0ff7f793          	andi	a5,a5,255
    8001a790:	cf99                	beqz	a5,8001a7ae <minix3_find_next_free_dir_entry+0x48>
        warnf("minix3_find_next_free_dir_entry: Inode %u (0x%x) not a directory\n", inode, inode);
    8001a792:	f5442703          	lw	a4,-172(s0)
    8001a796:	f5442783          	lw	a5,-172(s0)
    8001a79a:	863a                	mv	a2,a4
    8001a79c:	85be                	mv	a1,a5
    8001a79e:	0000e517          	auipc	a0,0xe
    8001a7a2:	96250513          	addi	a0,a0,-1694 # 80028100 <pow10.0+0x12a0>
    8001a7a6:	692010ef          	jal	ra,8001be38 <warnf>
        return -1;
    8001a7aa:	57fd                	li	a5,-1
    8001a7ac:	a8ad                	j	8001a826 <minix3_find_next_free_dir_entry+0xc0>
    }

    Inode data = minix3_get_inode(block_device, inode);
    8001a7ae:	fa840793          	addi	a5,s0,-88
    8001a7b2:	f5442703          	lw	a4,-172(s0)
    8001a7b6:	863a                	mv	a2,a4
    8001a7b8:	f5843583          	ld	a1,-168(s0)
    8001a7bc:	853e                	mv	a0,a5
    8001a7be:	dcdfd0ef          	jal	ra,8001858a <minix3_get_inode>
    DirEntry entry;
    for (size_t i = 0; i < minix3_get_zone_size(block_device) / sizeof(DirEntry); i++) {
    8001a7c2:	fe043423          	sd	zero,-24(s0)
    8001a7c6:	a81d                	j	8001a7fc <minix3_find_next_free_dir_entry+0x96>
        minix3_get_dir_entry(block_device, inode, i, &entry);
    8001a7c8:	fe843783          	ld	a5,-24(s0)
    8001a7cc:	0007871b          	sext.w	a4,a5
    8001a7d0:	f6840693          	addi	a3,s0,-152
    8001a7d4:	f5442783          	lw	a5,-172(s0)
    8001a7d8:	863a                	mv	a2,a4
    8001a7da:	85be                	mv	a1,a5
    8001a7dc:	f5843503          	ld	a0,-168(s0)
    8001a7e0:	050000ef          	jal	ra,8001a830 <minix3_get_dir_entry>

        if (entry.inode == 0) {
    8001a7e4:	f6842783          	lw	a5,-152(s0)
    8001a7e8:	e789                	bnez	a5,8001a7f2 <minix3_find_next_free_dir_entry+0x8c>
            debugf("minix3_find_next_free_dir_entry: Found free entry %u\n", i);
            return i;
    8001a7ea:	fe843783          	ld	a5,-24(s0)
    8001a7ee:	2781                	sext.w	a5,a5
    8001a7f0:	a81d                	j	8001a826 <minix3_find_next_free_dir_entry+0xc0>
    for (size_t i = 0; i < minix3_get_zone_size(block_device) / sizeof(DirEntry); i++) {
    8001a7f2:	fe843783          	ld	a5,-24(s0)
    8001a7f6:	0785                	addi	a5,a5,1
    8001a7f8:	fef43423          	sd	a5,-24(s0)
    8001a7fc:	f5843503          	ld	a0,-168(s0)
    8001a800:	f0afd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001a804:	87aa                	mv	a5,a0
    8001a806:	0067d79b          	srliw	a5,a5,0x6
    8001a80a:	17c2                	slli	a5,a5,0x30
    8001a80c:	93c1                	srli	a5,a5,0x30
    8001a80e:	873e                	mv	a4,a5
    8001a810:	fe843783          	ld	a5,-24(s0)
    8001a814:	fae7eae3          	bltu	a5,a4,8001a7c8 <minix3_find_next_free_dir_entry+0x62>
        } else {
            debugf("minix3_find_next_free_dir_entry: Entry %u is %s\n", i, entry.name);
        }
    }
    warnf("minix3_find_next_free_dir_entry: Couldn't find a free directory entry\n");
    8001a818:	0000e517          	auipc	a0,0xe
    8001a81c:	93050513          	addi	a0,a0,-1744 # 80028148 <pow10.0+0x12e8>
    8001a820:	618010ef          	jal	ra,8001be38 <warnf>
    return -1;
    8001a824:	57fd                	li	a5,-1
}
    8001a826:	853e                	mv	a0,a5
    8001a828:	70aa                	ld	ra,168(sp)
    8001a82a:	740a                	ld	s0,160(sp)
    8001a82c:	614d                	addi	sp,sp,176
    8001a82e:	8082                	ret

000000008001a830 <minix3_get_dir_entry>:

bool minix3_get_dir_entry(VirtioDevice *block_device, uint32_t inode, uint32_t entry, DirEntry *data) {
    8001a830:	7131                	addi	sp,sp,-192
    8001a832:	fd06                	sd	ra,184(sp)
    8001a834:	f922                	sd	s0,176(sp)
    8001a836:	0180                	addi	s0,sp,192
    8001a838:	f4a43c23          	sd	a0,-168(s0)
    8001a83c:	87ae                	mv	a5,a1
    8001a83e:	8732                	mv	a4,a2
    8001a840:	f4d43423          	sd	a3,-184(s0)
    8001a844:	f4f42a23          	sw	a5,-172(s0)
    8001a848:	87ba                	mv	a5,a4
    8001a84a:	f4f42823          	sw	a5,-176(s0)
    if (!minix3_is_dir(block_device, inode)) {
    8001a84e:	f5442783          	lw	a5,-172(s0)
    8001a852:	85be                	mv	a1,a5
    8001a854:	f5843503          	ld	a0,-168(s0)
    8001a858:	864fe0ef          	jal	ra,800188bc <minix3_is_dir>
    8001a85c:	87aa                	mv	a5,a0
    8001a85e:	0017c793          	xori	a5,a5,1
    8001a862:	0ff7f793          	andi	a5,a5,255
    8001a866:	cf99                	beqz	a5,8001a884 <minix3_get_dir_entry+0x54>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    8001a868:	f5442703          	lw	a4,-172(s0)
    8001a86c:	f5442783          	lw	a5,-172(s0)
    8001a870:	863a                	mv	a2,a4
    8001a872:	85be                	mv	a1,a5
    8001a874:	0000e517          	auipc	a0,0xe
    8001a878:	91c50513          	addi	a0,a0,-1764 # 80028190 <pow10.0+0x1330>
    8001a87c:	5bc010ef          	jal	ra,8001be38 <warnf>
        return false;
    8001a880:	4781                	li	a5,0
    8001a882:	a8a9                	j	8001a8dc <minix3_get_dir_entry+0xac>
    }
    Inode inode_data = minix3_get_inode(block_device, inode);
    8001a884:	fa840793          	addi	a5,s0,-88
    8001a888:	f5442703          	lw	a4,-172(s0)
    8001a88c:	863a                	mv	a2,a4
    8001a88e:	f5843583          	ld	a1,-168(s0)
    8001a892:	853e                	mv	a0,a5
    8001a894:	cf7fd0ef          	jal	ra,8001858a <minix3_get_inode>
    debugf("Getting entry %u from inode %u\n", entry, inode);
    DirEntry tmp;

    uint32_t offset = entry * sizeof(DirEntry);
    8001a898:	f5042783          	lw	a5,-176(s0)
    8001a89c:	0067979b          	slliw	a5,a5,0x6
    8001a8a0:	fef42623          	sw	a5,-20(s0)
    minix3_get_data(block_device, inode, (uint8_t*)&tmp, offset, sizeof(DirEntry));
    8001a8a4:	fec42683          	lw	a3,-20(s0)
    8001a8a8:	f6840613          	addi	a2,s0,-152
    8001a8ac:	f5442783          	lw	a5,-172(s0)
    8001a8b0:	04000713          	li	a4,64
    8001a8b4:	85be                	mv	a1,a5
    8001a8b6:	f5843503          	ld	a0,-168(s0)
    8001a8ba:	992fe0ef          	jal	ra,80018a4c <minix3_get_data>
    memcpy(data, &tmp, sizeof(DirEntry));
    8001a8be:	f6840793          	addi	a5,s0,-152
    8001a8c2:	04000613          	li	a2,64
    8001a8c6:	85be                	mv	a1,a5
    8001a8c8:	f4843503          	ld	a0,-184(s0)
    8001a8cc:	273070ef          	jal	ra,8002233e <memcpy>
    debugf("Got entry %s at offset %u from inode %u\n", tmp.name, offset, inode);
    if (tmp.inode == 0) {
    8001a8d0:	f6842783          	lw	a5,-152(s0)
    8001a8d4:	e399                	bnez	a5,8001a8da <minix3_get_dir_entry+0xaa>
        return false;
    8001a8d6:	4781                	li	a5,0
    8001a8d8:	a011                	j	8001a8dc <minix3_get_dir_entry+0xac>
    }

    return true;
    8001a8da:	4785                	li	a5,1
}
    8001a8dc:	853e                	mv	a0,a5
    8001a8de:	70ea                	ld	ra,184(sp)
    8001a8e0:	744a                	ld	s0,176(sp)
    8001a8e2:	6129                	addi	sp,sp,192
    8001a8e4:	8082                	ret

000000008001a8e6 <minix3_put_dir_entry>:

void minix3_put_dir_entry(VirtioDevice *block_device, uint32_t inode, uint32_t entry, DirEntry data) {
    8001a8e6:	7179                	addi	sp,sp,-48
    8001a8e8:	f406                	sd	ra,40(sp)
    8001a8ea:	f022                	sd	s0,32(sp)
    8001a8ec:	ec26                	sd	s1,24(sp)
    8001a8ee:	1800                	addi	s0,sp,48
    8001a8f0:	fca43c23          	sd	a0,-40(s0)
    8001a8f4:	87ae                	mv	a5,a1
    8001a8f6:	8732                	mv	a4,a2
    8001a8f8:	84b6                	mv	s1,a3
    8001a8fa:	fcf42a23          	sw	a5,-44(s0)
    8001a8fe:	87ba                	mv	a5,a4
    8001a900:	fcf42823          	sw	a5,-48(s0)
    if (!minix3_is_dir(block_device, inode)) {
    8001a904:	fd442783          	lw	a5,-44(s0)
    8001a908:	85be                	mv	a1,a5
    8001a90a:	fd843503          	ld	a0,-40(s0)
    8001a90e:	faffd0ef          	jal	ra,800188bc <minix3_is_dir>
    8001a912:	87aa                	mv	a5,a0
    8001a914:	0017c793          	xori	a5,a5,1
    8001a918:	0ff7f793          	andi	a5,a5,255
    8001a91c:	cf91                	beqz	a5,8001a938 <minix3_put_dir_entry+0x52>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    8001a91e:	fd442703          	lw	a4,-44(s0)
    8001a922:	fd442783          	lw	a5,-44(s0)
    8001a926:	863a                	mv	a2,a4
    8001a928:	85be                	mv	a1,a5
    8001a92a:	0000e517          	auipc	a0,0xe
    8001a92e:	86650513          	addi	a0,a0,-1946 # 80028190 <pow10.0+0x1330>
    8001a932:	506010ef          	jal	ra,8001be38 <warnf>
        return;
    8001a936:	a00d                	j	8001a958 <minix3_put_dir_entry+0x72>
    }
    // Inode inode_data = minix3_get_inode(block_device, inode);
    debugf("Putting entry %u to inode %u\n", entry, inode);

    minix3_put_data(block_device, inode, (uint8_t*)&data, entry * sizeof(DirEntry), sizeof(DirEntry));
    8001a938:	fd042783          	lw	a5,-48(s0)
    8001a93c:	0067979b          	slliw	a5,a5,0x6
    8001a940:	0007869b          	sext.w	a3,a5
    8001a944:	fd442783          	lw	a5,-44(s0)
    8001a948:	04000713          	li	a4,64
    8001a94c:	8626                	mv	a2,s1
    8001a94e:	85be                	mv	a1,a5
    8001a950:	fd843503          	ld	a0,-40(s0)
    8001a954:	eebfe0ef          	jal	ra,8001983e <minix3_put_data>
}
    8001a958:	70a2                	ld	ra,40(sp)
    8001a95a:	7402                	ld	s0,32(sp)
    8001a95c:	64e2                	ld	s1,24(sp)
    8001a95e:	6145                	addi	sp,sp,48
    8001a960:	8082                	ret

000000008001a962 <minix3_list_dir>:


// List all of the entries in the given directory to the given buffer.
uint32_t minix3_list_dir(VirtioDevice *block_device, uint32_t inode, DirEntry *entries, uint32_t max_entries) {
    8001a962:	7131                	addi	sp,sp,-192
    8001a964:	fd06                	sd	ra,184(sp)
    8001a966:	f922                	sd	s0,176(sp)
    8001a968:	0180                	addi	s0,sp,192
    8001a96a:	f4a43c23          	sd	a0,-168(s0)
    8001a96e:	87ae                	mv	a5,a1
    8001a970:	f4c43423          	sd	a2,-184(s0)
    8001a974:	8736                	mv	a4,a3
    8001a976:	f4f42a23          	sw	a5,-172(s0)
    8001a97a:	87ba                	mv	a5,a4
    8001a97c:	f4f42823          	sw	a5,-176(s0)
    if (!minix3_is_dir(block_device, inode)) {
    8001a980:	f5442783          	lw	a5,-172(s0)
    8001a984:	85be                	mv	a1,a5
    8001a986:	f5843503          	ld	a0,-168(s0)
    8001a98a:	f33fd0ef          	jal	ra,800188bc <minix3_is_dir>
    8001a98e:	87aa                	mv	a5,a0
    8001a990:	0017c793          	xori	a5,a5,1
    8001a994:	0ff7f793          	andi	a5,a5,255
    8001a998:	cf99                	beqz	a5,8001a9b6 <minix3_list_dir+0x54>
        warnf("Inode %u (%x) is not a directory\n", inode, inode);
    8001a99a:	f5442703          	lw	a4,-172(s0)
    8001a99e:	f5442783          	lw	a5,-172(s0)
    8001a9a2:	863a                	mv	a2,a4
    8001a9a4:	85be                	mv	a1,a5
    8001a9a6:	0000d517          	auipc	a0,0xd
    8001a9aa:	7ea50513          	addi	a0,a0,2026 # 80028190 <pow10.0+0x1330>
    8001a9ae:	48a010ef          	jal	ra,8001be38 <warnf>
        return 0;
    8001a9b2:	4781                	li	a5,0
    8001a9b4:	a059                	j	8001aa3a <minix3_list_dir+0xd8>
    }
    Inode inode_data = minix3_get_inode(block_device, inode);
    8001a9b6:	fa840793          	addi	a5,s0,-88
    8001a9ba:	f5442703          	lw	a4,-172(s0)
    8001a9be:	863a                	mv	a2,a4
    8001a9c0:	f5843583          	ld	a1,-168(s0)
    8001a9c4:	853e                	mv	a0,a5
    8001a9c6:	bc5fd0ef          	jal	ra,8001858a <minix3_get_inode>
    debugf("Listing directory %u\n", inode);
    uint32_t entry = 0;
    8001a9ca:	fe042623          	sw	zero,-20(s0)
    DirEntry tmp;
    while (minix3_get_dir_entry(block_device, inode, entry, &tmp)) {
    8001a9ce:	a0b1                	j	8001aa1a <minix3_list_dir+0xb8>
        debugf("Found entry %s at inode %u\n", tmp.name, tmp.inode);
        memcpy(entries + entry, &tmp, sizeof(DirEntry));
    8001a9d0:	fec46783          	lwu	a5,-20(s0)
    8001a9d4:	079a                	slli	a5,a5,0x6
    8001a9d6:	f4843703          	ld	a4,-184(s0)
    8001a9da:	97ba                	add	a5,a5,a4
    8001a9dc:	f6840713          	addi	a4,s0,-152
    8001a9e0:	04000613          	li	a2,64
    8001a9e4:	85ba                	mv	a1,a4
    8001a9e6:	853e                	mv	a0,a5
    8001a9e8:	157070ef          	jal	ra,8002233e <memcpy>
        entry++;
    8001a9ec:	fec42783          	lw	a5,-20(s0)
    8001a9f0:	2785                	addiw	a5,a5,1
    8001a9f2:	fef42623          	sw	a5,-20(s0)
        if (entry >= max_entries) {
    8001a9f6:	fec42703          	lw	a4,-20(s0)
    8001a9fa:	f5042783          	lw	a5,-176(s0)
    8001a9fe:	2701                	sext.w	a4,a4
    8001aa00:	2781                	sext.w	a5,a5
    8001aa02:	00f76c63          	bltu	a4,a5,8001aa1a <minix3_list_dir+0xb8>
            warnf("Too many entries in directory %u\n", inode);
    8001aa06:	f5442783          	lw	a5,-172(s0)
    8001aa0a:	85be                	mv	a1,a5
    8001aa0c:	0000d517          	auipc	a0,0xd
    8001aa10:	7ac50513          	addi	a0,a0,1964 # 800281b8 <pow10.0+0x1358>
    8001aa14:	424010ef          	jal	ra,8001be38 <warnf>
            break;
    8001aa18:	a839                	j	8001aa36 <minix3_list_dir+0xd4>
    while (minix3_get_dir_entry(block_device, inode, entry, &tmp)) {
    8001aa1a:	f6840693          	addi	a3,s0,-152
    8001aa1e:	fec42703          	lw	a4,-20(s0)
    8001aa22:	f5442783          	lw	a5,-172(s0)
    8001aa26:	863a                	mv	a2,a4
    8001aa28:	85be                	mv	a1,a5
    8001aa2a:	f5843503          	ld	a0,-168(s0)
    8001aa2e:	e03ff0ef          	jal	ra,8001a830 <minix3_get_dir_entry>
    8001aa32:	87aa                	mv	a5,a0
    8001aa34:	ffd1                	bnez	a5,8001a9d0 <minix3_list_dir+0x6e>
        }
    }
    return entry;
    8001aa36:	fec42783          	lw	a5,-20(s0)
}
    8001aa3a:	853e                	mv	a0,a5
    8001aa3c:	70ea                	ld	ra,184(sp)
    8001aa3e:	744a                	ld	s0,176(sp)
    8001aa40:	6129                	addi	sp,sp,192
    8001aa42:	8082                	ret

000000008001aa44 <minix3_find_dir_entry>:
// Returns the inode number of the file with the given name in the given directory.
// If the file does not exist, return INVALID_INODE.
uint32_t minix3_find_dir_entry(VirtioDevice *block_device, uint32_t inode, const char *name) {
    8001aa44:	7139                	addi	sp,sp,-64
    8001aa46:	fc06                	sd	ra,56(sp)
    8001aa48:	f822                	sd	s0,48(sp)
    8001aa4a:	0080                	addi	s0,sp,64
    8001aa4c:	7379                	lui	t1,0xffffe
    8001aa4e:	911a                	add	sp,sp,t1
    8001aa50:	77f9                	lui	a5,0xffffe
    8001aa52:	ff040713          	addi	a4,s0,-16
    8001aa56:	97ba                	add	a5,a5,a4
    8001aa58:	fea7b423          	sd	a0,-24(a5) # ffffffffffffdfe8 <_heap_end+0xffffffff77fedfe8>
    8001aa5c:	872e                	mv	a4,a1
    8001aa5e:	77f9                	lui	a5,0xffffe
    8001aa60:	ff040693          	addi	a3,s0,-16
    8001aa64:	97b6                	add	a5,a5,a3
    8001aa66:	fcc7bc23          	sd	a2,-40(a5) # ffffffffffffdfd8 <_heap_end+0xffffffff77fedfd8>
    8001aa6a:	77f9                	lui	a5,0xffffe
    8001aa6c:	ff040693          	addi	a3,s0,-16
    8001aa70:	97b6                	add	a5,a5,a3
    8001aa72:	fee7a223          	sw	a4,-28(a5) # ffffffffffffdfe4 <_heap_end+0xffffffff77fedfe4>
    minix3_load_device(block_device);
    8001aa76:	77f9                	lui	a5,0xffffe
    8001aa78:	ff040713          	addi	a4,s0,-16
    8001aa7c:	97ba                	add	a5,a5,a4
    8001aa7e:	fe87b503          	ld	a0,-24(a5) # ffffffffffffdfe8 <_heap_end+0xffffffff77fedfe8>
    8001aa82:	e6cfd0ef          	jal	ra,800180ee <minix3_load_device>
    
    DirEntry entries[128];
    uint32_t num_entries = minix3_list_dir(block_device, inode, entries, 128);
    8001aa86:	77f9                	lui	a5,0xffffe
    8001aa88:	17e1                	addi	a5,a5,-8
    8001aa8a:	ff040713          	addi	a4,s0,-16
    8001aa8e:	00f70633          	add	a2,a4,a5
    8001aa92:	77f9                	lui	a5,0xffffe
    8001aa94:	ff040713          	addi	a4,s0,-16
    8001aa98:	97ba                	add	a5,a5,a4
    8001aa9a:	fe47a703          	lw	a4,-28(a5) # ffffffffffffdfe4 <_heap_end+0xffffffff77fedfe4>
    8001aa9e:	77f9                	lui	a5,0xffffe
    8001aaa0:	ff040693          	addi	a3,s0,-16
    8001aaa4:	97b6                	add	a5,a5,a3
    8001aaa6:	08000693          	li	a3,128
    8001aaaa:	85ba                	mv	a1,a4
    8001aaac:	fe87b503          	ld	a0,-24(a5) # ffffffffffffdfe8 <_heap_end+0xffffffff77fedfe8>
    8001aab0:	eb3ff0ef          	jal	ra,8001a962 <minix3_list_dir>
    8001aab4:	87aa                	mv	a5,a0
    8001aab6:	fef42423          	sw	a5,-24(s0)

    for (uint32_t i=0; i<num_entries; i++) {
    8001aaba:	fe042623          	sw	zero,-20(s0)
    8001aabe:	a0b9                	j	8001ab0c <minix3_find_dir_entry+0xc8>
        if (strcmp(entries[i].name, name) == 0) {
    8001aac0:	77f9                	lui	a5,0xffffe
    8001aac2:	17e1                	addi	a5,a5,-8
    8001aac4:	ff040713          	addi	a4,s0,-16
    8001aac8:	973e                	add	a4,a4,a5
    8001aaca:	fec46783          	lwu	a5,-20(s0)
    8001aace:	079a                	slli	a5,a5,0x6
    8001aad0:	97ba                	add	a5,a5,a4
    8001aad2:	00478713          	addi	a4,a5,4 # ffffffffffffe004 <_heap_end+0xffffffff77fee004>
    8001aad6:	77f9                	lui	a5,0xffffe
    8001aad8:	ff040693          	addi	a3,s0,-16
    8001aadc:	97b6                	add	a5,a5,a3
    8001aade:	fd87b583          	ld	a1,-40(a5) # ffffffffffffdfd8 <_heap_end+0xffffffff77fedfd8>
    8001aae2:	853a                	mv	a0,a4
    8001aae4:	3e9070ef          	jal	ra,800226cc <strcmp>
    8001aae8:	87aa                	mv	a5,a0
    8001aaea:	ef81                	bnez	a5,8001ab02 <minix3_find_dir_entry+0xbe>
            debugf("Found entry %s at inode %u\n", name, entries[i].inode);
            return entries[i].inode;
    8001aaec:	77f9                	lui	a5,0xffffe
    8001aaee:	ff040713          	addi	a4,s0,-16
    8001aaf2:	973e                	add	a4,a4,a5
    8001aaf4:	fec46783          	lwu	a5,-20(s0)
    8001aaf8:	079a                	slli	a5,a5,0x6
    8001aafa:	97ba                	add	a5,a5,a4
    8001aafc:	ff87a783          	lw	a5,-8(a5) # ffffffffffffdff8 <_heap_end+0xffffffff77fedff8>
    8001ab00:	a091                	j	8001ab44 <minix3_find_dir_entry+0x100>
    for (uint32_t i=0; i<num_entries; i++) {
    8001ab02:	fec42783          	lw	a5,-20(s0)
    8001ab06:	2785                	addiw	a5,a5,1
    8001ab08:	fef42623          	sw	a5,-20(s0)
    8001ab0c:	fec42703          	lw	a4,-20(s0)
    8001ab10:	fe842783          	lw	a5,-24(s0)
    8001ab14:	2701                	sext.w	a4,a4
    8001ab16:	2781                	sext.w	a5,a5
    8001ab18:	faf764e3          	bltu	a4,a5,8001aac0 <minix3_find_dir_entry+0x7c>
        }
    }
    warnf("Could not find entry %s in inode %u\n", name, inode);
    8001ab1c:	77f9                	lui	a5,0xffffe
    8001ab1e:	ff040713          	addi	a4,s0,-16
    8001ab22:	97ba                	add	a5,a5,a4
    8001ab24:	fe47a703          	lw	a4,-28(a5) # ffffffffffffdfe4 <_heap_end+0xffffffff77fedfe4>
    8001ab28:	77f9                	lui	a5,0xffffe
    8001ab2a:	ff040693          	addi	a3,s0,-16
    8001ab2e:	97b6                	add	a5,a5,a3
    8001ab30:	863a                	mv	a2,a4
    8001ab32:	fd87b583          	ld	a1,-40(a5) # ffffffffffffdfd8 <_heap_end+0xffffffff77fedfd8>
    8001ab36:	0000d517          	auipc	a0,0xd
    8001ab3a:	6aa50513          	addi	a0,a0,1706 # 800281e0 <pow10.0+0x1380>
    8001ab3e:	2fa010ef          	jal	ra,8001be38 <warnf>
    return INVALID_INODE;
    8001ab42:	4781                	li	a5,0
}
    8001ab44:	853e                	mv	a0,a5
    8001ab46:	6309                	lui	t1,0x2
    8001ab48:	911a                	add	sp,sp,t1
    8001ab4a:	70e2                	ld	ra,56(sp)
    8001ab4c:	7442                	ld	s0,48(sp)
    8001ab4e:	6121                	addi	sp,sp,64
    8001ab50:	8082                	ret

000000008001ab52 <strcat>:

void strcat(char *dest, char *src) {
    8001ab52:	7179                	addi	sp,sp,-48
    8001ab54:	f422                	sd	s0,40(sp)
    8001ab56:	1800                	addi	s0,sp,48
    8001ab58:	fca43c23          	sd	a0,-40(s0)
    8001ab5c:	fcb43823          	sd	a1,-48(s0)
    uint32_t i, j;
    for (i=0; dest[i] != 0; i++) {
    8001ab60:	fe042623          	sw	zero,-20(s0)
    8001ab64:	a031                	j	8001ab70 <strcat+0x1e>
    8001ab66:	fec42783          	lw	a5,-20(s0)
    8001ab6a:	2785                	addiw	a5,a5,1
    8001ab6c:	fef42623          	sw	a5,-20(s0)
    8001ab70:	fec46783          	lwu	a5,-20(s0)
    8001ab74:	fd843703          	ld	a4,-40(s0)
    8001ab78:	97ba                	add	a5,a5,a4
    8001ab7a:	0007c783          	lbu	a5,0(a5)
    8001ab7e:	f7e5                	bnez	a5,8001ab66 <strcat+0x14>
    }
    for (j=0; src[j] != 0; j++) {
    8001ab80:	fe042423          	sw	zero,-24(s0)
    8001ab84:	a815                	j	8001abb8 <strcat+0x66>
        dest[i + j] = src[j];
    8001ab86:	fe846783          	lwu	a5,-24(s0)
    8001ab8a:	fd043703          	ld	a4,-48(s0)
    8001ab8e:	973e                	add	a4,a4,a5
    8001ab90:	fec42683          	lw	a3,-20(s0)
    8001ab94:	fe842783          	lw	a5,-24(s0)
    8001ab98:	9fb5                	addw	a5,a5,a3
    8001ab9a:	2781                	sext.w	a5,a5
    8001ab9c:	1782                	slli	a5,a5,0x20
    8001ab9e:	9381                	srli	a5,a5,0x20
    8001aba0:	fd843683          	ld	a3,-40(s0)
    8001aba4:	97b6                	add	a5,a5,a3
    8001aba6:	00074703          	lbu	a4,0(a4)
    8001abaa:	00e78023          	sb	a4,0(a5)
    for (j=0; src[j] != 0; j++) {
    8001abae:	fe842783          	lw	a5,-24(s0)
    8001abb2:	2785                	addiw	a5,a5,1
    8001abb4:	fef42423          	sw	a5,-24(s0)
    8001abb8:	fe846783          	lwu	a5,-24(s0)
    8001abbc:	fd043703          	ld	a4,-48(s0)
    8001abc0:	97ba                	add	a5,a5,a4
    8001abc2:	0007c783          	lbu	a5,0(a5)
    8001abc6:	f3e1                	bnez	a5,8001ab86 <strcat+0x34>
    }
    dest[i + j] = 0;
    8001abc8:	fec42703          	lw	a4,-20(s0)
    8001abcc:	fe842783          	lw	a5,-24(s0)
    8001abd0:	9fb9                	addw	a5,a5,a4
    8001abd2:	2781                	sext.w	a5,a5
    8001abd4:	1782                	slli	a5,a5,0x20
    8001abd6:	9381                	srli	a5,a5,0x20
    8001abd8:	fd843703          	ld	a4,-40(s0)
    8001abdc:	97ba                	add	a5,a5,a4
    8001abde:	00078023          	sb	zero,0(a5)
}
    8001abe2:	0001                	nop
    8001abe4:	7422                	ld	s0,40(sp)
    8001abe6:	6145                	addi	sp,sp,48
    8001abe8:	8082                	ret

000000008001abea <minix3_traverse>:

void minix3_traverse(VirtioDevice *block_device, uint32_t inode, char *root_path, void *data, uint32_t current_depth, uint32_t max_depth, void (*callback)(VirtioDevice *block_device, uint32_t inode, const char *path, char *name, void *data, uint32_t depth)) {
    8001abea:	7109                	addi	sp,sp,-384
    8001abec:	fe86                	sd	ra,376(sp)
    8001abee:	faa2                	sd	s0,368(sp)
    8001abf0:	f6a6                	sd	s1,360(sp)
    8001abf2:	f2ca                	sd	s2,352(sp)
    8001abf4:	eece                	sd	s3,344(sp)
    8001abf6:	ead2                	sd	s4,336(sp)
    8001abf8:	e6d6                	sd	s5,328(sp)
    8001abfa:	e2da                	sd	s6,320(sp)
    8001abfc:	fe5e                	sd	s7,312(sp)
    8001abfe:	fa62                	sd	s8,304(sp)
    8001ac00:	f666                	sd	s9,296(sp)
    8001ac02:	0300                	addi	s0,sp,384
    8001ac04:	eaa43423          	sd	a0,-344(s0)
    8001ac08:	e8c43c23          	sd	a2,-360(s0)
    8001ac0c:	e8d43823          	sd	a3,-368(s0)
    8001ac10:	86ba                	mv	a3,a4
    8001ac12:	873e                	mv	a4,a5
    8001ac14:	e9043023          	sd	a6,-384(s0)
    8001ac18:	87ae                	mv	a5,a1
    8001ac1a:	eaf42223          	sw	a5,-348(s0)
    8001ac1e:	87b6                	mv	a5,a3
    8001ac20:	eaf42023          	sw	a5,-352(s0)
    8001ac24:	87ba                	mv	a5,a4
    8001ac26:	e8f42623          	sw	a5,-372(s0)
    8001ac2a:	878a                	mv	a5,sp
    8001ac2c:	84be                	mv	s1,a5
    debugf("Traversing %s: inode %u at depth %d\n", root_path, inode, current_depth);
    if (current_depth > max_depth) {
    8001ac2e:	ea042703          	lw	a4,-352(s0)
    8001ac32:	e8c42783          	lw	a5,-372(s0)
    8001ac36:	2701                	sext.w	a4,a4
    8001ac38:	2781                	sext.w	a5,a5
    8001ac3a:	24e7ed63          	bltu	a5,a4,8001ae94 <minix3_traverse+0x2aa>
        return;
    }
    if (!minix3_has_inode(block_device, inode)) {
    8001ac3e:	ea442783          	lw	a5,-348(s0)
    8001ac42:	85be                	mv	a1,a5
    8001ac44:	ea843503          	ld	a0,-344(s0)
    8001ac48:	eccfd0ef          	jal	ra,80018314 <minix3_has_inode>
    8001ac4c:	87aa                	mv	a5,a0
    8001ac4e:	0017c793          	xori	a5,a5,1
    8001ac52:	0ff7f793          	andi	a5,a5,255
    8001ac56:	cb99                	beqz	a5,8001ac6c <minix3_traverse+0x82>
        warnf("Inode %u does not exist\n", inode);
    8001ac58:	ea442783          	lw	a5,-348(s0)
    8001ac5c:	85be                	mv	a1,a5
    8001ac5e:	0000d517          	auipc	a0,0xd
    8001ac62:	5aa50513          	addi	a0,a0,1450 # 80028208 <pow10.0+0x13a8>
    8001ac66:	1d2010ef          	jal	ra,8001be38 <warnf>
        return;
    8001ac6a:	a435                	j	8001ae96 <minix3_traverse+0x2ac>
    }
    debugf("Traversing inode %u at depth %d\n", inode, current_depth);
    char name[128];
    strncpy(name, path_file_name(root_path), sizeof(name));
    8001ac6c:	e9843503          	ld	a0,-360(s0)
    8001ac70:	069060ef          	jal	ra,800214d8 <path_file_name>
    8001ac74:	872a                	mv	a4,a0
    8001ac76:	ef840793          	addi	a5,s0,-264
    8001ac7a:	08000613          	li	a2,128
    8001ac7e:	85ba                	mv	a1,a4
    8001ac80:	853e                	mv	a0,a5
    8001ac82:	5dd070ef          	jal	ra,80022a5e <strncpy>
    if (minix3_is_dir(block_device, inode)) {
    8001ac86:	ea442783          	lw	a5,-348(s0)
    8001ac8a:	85be                	mv	a1,a5
    8001ac8c:	ea843503          	ld	a0,-344(s0)
    8001ac90:	c2dfd0ef          	jal	ra,800188bc <minix3_is_dir>
    8001ac94:	87aa                	mv	a5,a0
    8001ac96:	e38d                	bnez	a5,8001acb8 <minix3_traverse+0xce>
        debugf("Is a directory\n");
    } else {
        debugf("Not a directory\n");
        callback(block_device, inode, root_path, name, data, current_depth);
    8001ac98:	ea042783          	lw	a5,-352(s0)
    8001ac9c:	ef840693          	addi	a3,s0,-264
    8001aca0:	ea442583          	lw	a1,-348(s0)
    8001aca4:	e8043803          	ld	a6,-384(s0)
    8001aca8:	e9043703          	ld	a4,-368(s0)
    8001acac:	e9843603          	ld	a2,-360(s0)
    8001acb0:	ea843503          	ld	a0,-344(s0)
    8001acb4:	9802                	jalr	a6
        return;
    8001acb6:	a2c5                	j	8001ae96 <minix3_traverse+0x2ac>
    }

    Inode inode_data = minix3_get_inode(block_device, inode);
    8001acb8:	eb840793          	addi	a5,s0,-328
    8001acbc:	ea442703          	lw	a4,-348(s0)
    8001acc0:	863a                	mv	a2,a4
    8001acc2:	ea843583          	ld	a1,-344(s0)
    8001acc6:	853e                	mv	a0,a5
    8001acc8:	8c3fd0ef          	jal	ra,8001858a <minix3_get_inode>
    debug_inode(block_device, inode);
    8001accc:	ea442783          	lw	a5,-348(s0)
    8001acd0:	85be                	mv	a1,a5
    8001acd2:	ea843503          	ld	a0,-344(s0)
    8001acd6:	f85fc0ef          	jal	ra,80017c5a <debug_inode>
    uint32_t max_entries = minix3_get_zone_size(block_device) / sizeof(DirEntry);
    8001acda:	ea843503          	ld	a0,-344(s0)
    8001acde:	a2cfd0ef          	jal	ra,80017f0a <minix3_get_zone_size>
    8001ace2:	87aa                	mv	a5,a0
    8001ace4:	0067d79b          	srliw	a5,a5,0x6
    8001ace8:	17c2                	slli	a5,a5,0x30
    8001acea:	93c1                	srli	a5,a5,0x30
    8001acec:	f8f42c23          	sw	a5,-104(s0)
    debugf("Max entries: %u\n", max_entries);
    DirEntry entries[max_entries];
    8001acf0:	f9842783          	lw	a5,-104(s0)
    8001acf4:	02079713          	slli	a4,a5,0x20
    8001acf8:	9301                	srli	a4,a4,0x20
    8001acfa:	177d                	addi	a4,a4,-1
    8001acfc:	f8e43823          	sd	a4,-112(s0)
    8001ad00:	02079713          	slli	a4,a5,0x20
    8001ad04:	9301                	srli	a4,a4,0x20
    8001ad06:	8c3a                	mv	s8,a4
    8001ad08:	4c81                	li	s9,0
    8001ad0a:	037c5713          	srli	a4,s8,0x37
    8001ad0e:	009c9a93          	slli	s5,s9,0x9
    8001ad12:	01576ab3          	or	s5,a4,s5
    8001ad16:	009c1a13          	slli	s4,s8,0x9
    8001ad1a:	02079713          	slli	a4,a5,0x20
    8001ad1e:	9301                	srli	a4,a4,0x20
    8001ad20:	8b3a                	mv	s6,a4
    8001ad22:	4b81                	li	s7,0
    8001ad24:	037b5713          	srli	a4,s6,0x37
    8001ad28:	009b9993          	slli	s3,s7,0x9
    8001ad2c:	013769b3          	or	s3,a4,s3
    8001ad30:	009b1913          	slli	s2,s6,0x9
    8001ad34:	1782                	slli	a5,a5,0x20
    8001ad36:	9381                	srli	a5,a5,0x20
    8001ad38:	079a                	slli	a5,a5,0x6
    8001ad3a:	07bd                	addi	a5,a5,15
    8001ad3c:	8391                	srli	a5,a5,0x4
    8001ad3e:	0792                	slli	a5,a5,0x4
    8001ad40:	40f10133          	sub	sp,sp,a5
    8001ad44:	878a                	mv	a5,sp
    8001ad46:	078d                	addi	a5,a5,3
    8001ad48:	8389                	srli	a5,a5,0x2
    8001ad4a:	078a                	slli	a5,a5,0x2
    8001ad4c:	f8f43423          	sd	a5,-120(s0)
    debugf("Allocated entries\n");
    uint32_t num_entries = minix3_list_dir(block_device, inode, entries, max_entries);
    8001ad50:	f9842703          	lw	a4,-104(s0)
    8001ad54:	ea442783          	lw	a5,-348(s0)
    8001ad58:	86ba                	mv	a3,a4
    8001ad5a:	f8843603          	ld	a2,-120(s0)
    8001ad5e:	85be                	mv	a1,a5
    8001ad60:	ea843503          	ld	a0,-344(s0)
    8001ad64:	bffff0ef          	jal	ra,8001a962 <minix3_list_dir>
    8001ad68:	87aa                	mv	a5,a0
    8001ad6a:	f8f42223          	sw	a5,-124(s0)
    debugf("Found %u entries\n", num_entries);

    char *path = kmalloc(1024);
    8001ad6e:	40000513          	li	a0,1024
    8001ad72:	fc0fa0ef          	jal	ra,80015532 <kmalloc>
    8001ad76:	f6a43c23          	sd	a0,-136(s0)
    callback(block_device, inode, root_path, name, data, current_depth);
    8001ad7a:	ea042783          	lw	a5,-352(s0)
    8001ad7e:	ef840693          	addi	a3,s0,-264
    8001ad82:	ea442583          	lw	a1,-348(s0)
    8001ad86:	e8043803          	ld	a6,-384(s0)
    8001ad8a:	e9043703          	ld	a4,-368(s0)
    8001ad8e:	e9843603          	ld	a2,-360(s0)
    8001ad92:	ea843503          	ld	a0,-344(s0)
    8001ad96:	9802                	jalr	a6
    for (uint32_t i=0; i<num_entries; i++) {
    8001ad98:	f8042e23          	sw	zero,-100(s0)
    8001ad9c:	a8f9                	j	8001ae7a <minix3_traverse+0x290>
        if (entries[i].inode == INVALID_INODE) {
    8001ad9e:	f8843703          	ld	a4,-120(s0)
    8001ada2:	f9c46783          	lwu	a5,-100(s0)
    8001ada6:	079a                	slli	a5,a5,0x6
    8001ada8:	97ba                	add	a5,a5,a4
    8001adaa:	439c                	lw	a5,0(a5)
    8001adac:	cfdd                	beqz	a5,8001ae6a <minix3_traverse+0x280>
            continue;
        }
        strncpy(name, entries[i].name, sizeof(name));
    8001adae:	f9c46783          	lwu	a5,-100(s0)
    8001adb2:	079a                	slli	a5,a5,0x6
    8001adb4:	f8843703          	ld	a4,-120(s0)
    8001adb8:	97ba                	add	a5,a5,a4
    8001adba:	00478713          	addi	a4,a5,4
    8001adbe:	ef840793          	addi	a5,s0,-264
    8001adc2:	08000613          	li	a2,128
    8001adc6:	85ba                	mv	a1,a4
    8001adc8:	853e                	mv	a0,a5
    8001adca:	495070ef          	jal	ra,80022a5e <strncpy>
        //         name[j] = 0;
        //         break;
        //     }
        //     name[j] = entries[i].name[j];
        // }
        if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) {
    8001adce:	ef840793          	addi	a5,s0,-264
    8001add2:	0000d597          	auipc	a1,0xd
    8001add6:	45658593          	addi	a1,a1,1110 # 80028228 <pow10.0+0x13c8>
    8001adda:	853e                	mv	a0,a5
    8001addc:	0f1070ef          	jal	ra,800226cc <strcmp>
    8001ade0:	87aa                	mv	a5,a0
    8001ade2:	c7d1                	beqz	a5,8001ae6e <minix3_traverse+0x284>
    8001ade4:	ef840793          	addi	a5,s0,-264
    8001ade8:	0000d597          	auipc	a1,0xd
    8001adec:	44858593          	addi	a1,a1,1096 # 80028230 <pow10.0+0x13d0>
    8001adf0:	853e                	mv	a0,a5
    8001adf2:	0db070ef          	jal	ra,800226cc <strcmp>
    8001adf6:	87aa                	mv	a5,a0
    8001adf8:	cbbd                	beqz	a5,8001ae6e <minix3_traverse+0x284>
            continue;
        }

        strcpy(path, root_path);
    8001adfa:	e9843583          	ld	a1,-360(s0)
    8001adfe:	f7843503          	ld	a0,-136(s0)
    8001ae02:	407070ef          	jal	ra,80022a08 <strcpy>
        if (strcmp(path, "/") != 0) {
    8001ae06:	0000d597          	auipc	a1,0xd
    8001ae0a:	f9258593          	addi	a1,a1,-110 # 80027d98 <pow10.0+0xf38>
    8001ae0e:	f7843503          	ld	a0,-136(s0)
    8001ae12:	0bb070ef          	jal	ra,800226cc <strcmp>
    8001ae16:	87aa                	mv	a5,a0
    8001ae18:	cb89                	beqz	a5,8001ae2a <minix3_traverse+0x240>
            strcat(path, "/");
    8001ae1a:	0000d597          	auipc	a1,0xd
    8001ae1e:	f7e58593          	addi	a1,a1,-130 # 80027d98 <pow10.0+0xf38>
    8001ae22:	f7843503          	ld	a0,-136(s0)
    8001ae26:	d2dff0ef          	jal	ra,8001ab52 <strcat>
        }
        strcat(path, name);
    8001ae2a:	ef840793          	addi	a5,s0,-264
    8001ae2e:	85be                	mv	a1,a5
    8001ae30:	f7843503          	ld	a0,-136(s0)
    8001ae34:	d1fff0ef          	jal	ra,8001ab52 <strcat>

        minix3_traverse(block_device, entries[i].inode, path, data, current_depth + 1, max_depth, callback);
    8001ae38:	f8843703          	ld	a4,-120(s0)
    8001ae3c:	f9c46783          	lwu	a5,-100(s0)
    8001ae40:	079a                	slli	a5,a5,0x6
    8001ae42:	97ba                	add	a5,a5,a4
    8001ae44:	438c                	lw	a1,0(a5)
    8001ae46:	ea042783          	lw	a5,-352(s0)
    8001ae4a:	2785                	addiw	a5,a5,1
    8001ae4c:	0007871b          	sext.w	a4,a5
    8001ae50:	e8c42783          	lw	a5,-372(s0)
    8001ae54:	e8043803          	ld	a6,-384(s0)
    8001ae58:	e9043683          	ld	a3,-368(s0)
    8001ae5c:	f7843603          	ld	a2,-136(s0)
    8001ae60:	ea843503          	ld	a0,-344(s0)
    8001ae64:	d87ff0ef          	jal	ra,8001abea <minix3_traverse>
    8001ae68:	a021                	j	8001ae70 <minix3_traverse+0x286>
            continue;
    8001ae6a:	0001                	nop
    8001ae6c:	a011                	j	8001ae70 <minix3_traverse+0x286>
            continue;
    8001ae6e:	0001                	nop
    for (uint32_t i=0; i<num_entries; i++) {
    8001ae70:	f9c42783          	lw	a5,-100(s0)
    8001ae74:	2785                	addiw	a5,a5,1
    8001ae76:	f8f42e23          	sw	a5,-100(s0)
    8001ae7a:	f9c42703          	lw	a4,-100(s0)
    8001ae7e:	f8442783          	lw	a5,-124(s0)
    8001ae82:	2701                	sext.w	a4,a4
    8001ae84:	2781                	sext.w	a5,a5
    8001ae86:	f0f76ce3          	bltu	a4,a5,8001ad9e <minix3_traverse+0x1b4>
    }

    kfree(path);
    8001ae8a:	f7843503          	ld	a0,-136(s0)
    8001ae8e:	eecfa0ef          	jal	ra,8001557a <kfree>
    return;
    8001ae92:	a011                	j	8001ae96 <minix3_traverse+0x2ac>
        return;
    8001ae94:	0001                	nop
    8001ae96:	8126                	mv	sp,s1
}
    8001ae98:	e8040113          	addi	sp,s0,-384
    8001ae9c:	70f6                	ld	ra,376(sp)
    8001ae9e:	7456                	ld	s0,368(sp)
    8001aea0:	74b6                	ld	s1,360(sp)
    8001aea2:	7916                	ld	s2,352(sp)
    8001aea4:	69f6                	ld	s3,344(sp)
    8001aea6:	6a56                	ld	s4,336(sp)
    8001aea8:	6ab6                	ld	s5,328(sp)
    8001aeaa:	6b16                	ld	s6,320(sp)
    8001aeac:	7bf2                	ld	s7,312(sp)
    8001aeae:	7c52                	ld	s8,304(sp)
    8001aeb0:	7cb2                	ld	s9,296(sp)
    8001aeb2:	6119                	addi	sp,sp,384
    8001aeb4:	8082                	ret

000000008001aeb6 <generate_unique_pid>:
#define STACK_SIZE  (STACK_PAGES * PAGE_SIZE)
#define STACK_TOP   0xfffffffc0ffee000UL

static uint16_t pid = 1; // Start from 1, 0 is reserved

static uint16_t generate_unique_pid(void) {
    8001aeb6:	1141                	addi	sp,sp,-16
    8001aeb8:	e406                	sd	ra,8(sp)
    8001aeba:	e022                	sd	s0,0(sp)
    8001aebc:	0800                	addi	s0,sp,16
    ++pid;
    8001aebe:	0000f797          	auipc	a5,0xf
    8001aec2:	14478793          	addi	a5,a5,324 # 8002a002 <pid>
    8001aec6:	0007d783          	lhu	a5,0(a5)
    8001aeca:	2785                	addiw	a5,a5,1
    8001aecc:	03079713          	slli	a4,a5,0x30
    8001aed0:	9341                	srli	a4,a4,0x30
    8001aed2:	0000f797          	auipc	a5,0xf
    8001aed6:	13078793          	addi	a5,a5,304 # 8002a002 <pid>
    8001aeda:	00e79023          	sh	a4,0(a5)
    if (pid == PID_LIMIT)
    8001aede:	0000f797          	auipc	a5,0xf
    8001aee2:	12478793          	addi	a5,a5,292 # 8002a002 <pid>
    8001aee6:	0007d783          	lhu	a5,0(a5)
    8001aeea:	0007871b          	sext.w	a4,a5
    8001aeee:	67c1                	lui	a5,0x10
    8001aef0:	17fd                	addi	a5,a5,-1
    8001aef2:	00f71863          	bne	a4,a5,8001af02 <generate_unique_pid+0x4c>
        warnf("process.c (generate_unique_pid): Reached PID_LIMIT\n");
    8001aef6:	0000d517          	auipc	a0,0xd
    8001aefa:	34250513          	addi	a0,a0,834 # 80028238 <pow10.0+0x13d8>
    8001aefe:	73b000ef          	jal	ra,8001be38 <warnf>
    return pid;
    8001af02:	0000f797          	auipc	a5,0xf
    8001af06:	10078793          	addi	a5,a5,256 # 8002a002 <pid>
    8001af0a:	0007d783          	lhu	a5,0(a5)
}
    8001af0e:	853e                	mv	a0,a5
    8001af10:	60a2                	ld	ra,8(sp)
    8001af12:	6402                	ld	s0,0(sp)
    8001af14:	0141                	addi	sp,sp,16
    8001af16:	8082                	ret

000000008001af18 <rcb_debug>:

void rcb_debug(RCB *rcb) {
    8001af18:	715d                	addi	sp,sp,-80
    8001af1a:	e486                	sd	ra,72(sp)
    8001af1c:	e0a2                	sd	s0,64(sp)
    8001af1e:	0880                	addi	s0,sp,80
    8001af20:	faa43c23          	sd	a0,-72(s0)
    debugf("RCB:\n");
    8001af24:	0000d517          	auipc	a0,0xd
    8001af28:	34c50513          	addi	a0,a0,844 # 80028270 <pow10.0+0x1410>
    8001af2c:	6b7000ef          	jal	ra,8001bde2 <debugf>
    // List *stack_pages;
    // List *heap_pages;
    // List *file_descriptors;
    // Map *environemnt;
    // PageTable *ptable;
    debugf("  image_pages:\n");
    8001af30:	0000d517          	auipc	a0,0xd
    8001af34:	34850513          	addi	a0,a0,840 # 80028278 <pow10.0+0x1418>
    8001af38:	6ab000ef          	jal	ra,8001bde2 <debugf>
    struct ListElem *e;
    list_for_each(rcb->image_pages, e) {
    8001af3c:	fb843783          	ld	a5,-72(s0)
    8001af40:	639c                	ld	a5,0(a5)
    8001af42:	853e                	mv	a0,a5
    8001af44:	113050ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001af48:	fea43423          	sd	a0,-24(s0)
    8001af4c:	a01d                	j	8001af72 <rcb_debug+0x5a>
        debugf("    %p\n", list_elem_value_ptr(e));
    8001af4e:	fe843503          	ld	a0,-24(s0)
    8001af52:	165050ef          	jal	ra,800208b6 <list_elem_value>
    8001af56:	87aa                	mv	a5,a0
    8001af58:	85be                	mv	a1,a5
    8001af5a:	0000d517          	auipc	a0,0xd
    8001af5e:	32e50513          	addi	a0,a0,814 # 80028288 <pow10.0+0x1428>
    8001af62:	681000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(rcb->image_pages, e) {
    8001af66:	fe843503          	ld	a0,-24(s0)
    8001af6a:	135050ef          	jal	ra,8002089e <list_elem_prev>
    8001af6e:	fea43423          	sd	a0,-24(s0)
    8001af72:	fb843783          	ld	a5,-72(s0)
    8001af76:	639c                	ld	a5,0(a5)
    8001af78:	fe843583          	ld	a1,-24(s0)
    8001af7c:	853e                	mv	a0,a5
    8001af7e:	04b050ef          	jal	ra,800207c8 <list_elem_valid>
    8001af82:	87aa                	mv	a5,a0
    8001af84:	f7e9                	bnez	a5,8001af4e <rcb_debug+0x36>
    }
    debugf("  stack_pages:\n");
    8001af86:	0000d517          	auipc	a0,0xd
    8001af8a:	30a50513          	addi	a0,a0,778 # 80028290 <pow10.0+0x1430>
    8001af8e:	655000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(rcb->stack_pages, e) {
    8001af92:	fb843783          	ld	a5,-72(s0)
    8001af96:	679c                	ld	a5,8(a5)
    8001af98:	853e                	mv	a0,a5
    8001af9a:	0bd050ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001af9e:	fea43423          	sd	a0,-24(s0)
    8001afa2:	a01d                	j	8001afc8 <rcb_debug+0xb0>
        debugf("    %p\n", list_elem_value_ptr(e));
    8001afa4:	fe843503          	ld	a0,-24(s0)
    8001afa8:	10f050ef          	jal	ra,800208b6 <list_elem_value>
    8001afac:	87aa                	mv	a5,a0
    8001afae:	85be                	mv	a1,a5
    8001afb0:	0000d517          	auipc	a0,0xd
    8001afb4:	2d850513          	addi	a0,a0,728 # 80028288 <pow10.0+0x1428>
    8001afb8:	62b000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(rcb->stack_pages, e) {
    8001afbc:	fe843503          	ld	a0,-24(s0)
    8001afc0:	0df050ef          	jal	ra,8002089e <list_elem_prev>
    8001afc4:	fea43423          	sd	a0,-24(s0)
    8001afc8:	fb843783          	ld	a5,-72(s0)
    8001afcc:	679c                	ld	a5,8(a5)
    8001afce:	fe843583          	ld	a1,-24(s0)
    8001afd2:	853e                	mv	a0,a5
    8001afd4:	7f4050ef          	jal	ra,800207c8 <list_elem_valid>
    8001afd8:	87aa                	mv	a5,a0
    8001afda:	f7e9                	bnez	a5,8001afa4 <rcb_debug+0x8c>
    }
    debugf("  heap_pages:\n");
    8001afdc:	0000d517          	auipc	a0,0xd
    8001afe0:	2c450513          	addi	a0,a0,708 # 800282a0 <pow10.0+0x1440>
    8001afe4:	5ff000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(rcb->heap_pages, e) {
    8001afe8:	fb843783          	ld	a5,-72(s0)
    8001afec:	6b9c                	ld	a5,16(a5)
    8001afee:	853e                	mv	a0,a5
    8001aff0:	067050ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001aff4:	fea43423          	sd	a0,-24(s0)
    8001aff8:	a01d                	j	8001b01e <rcb_debug+0x106>
        debugf("    %p\n", list_elem_value_ptr(e));
    8001affa:	fe843503          	ld	a0,-24(s0)
    8001affe:	0b9050ef          	jal	ra,800208b6 <list_elem_value>
    8001b002:	87aa                	mv	a5,a0
    8001b004:	85be                	mv	a1,a5
    8001b006:	0000d517          	auipc	a0,0xd
    8001b00a:	28250513          	addi	a0,a0,642 # 80028288 <pow10.0+0x1428>
    8001b00e:	5d5000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(rcb->heap_pages, e) {
    8001b012:	fe843503          	ld	a0,-24(s0)
    8001b016:	089050ef          	jal	ra,8002089e <list_elem_prev>
    8001b01a:	fea43423          	sd	a0,-24(s0)
    8001b01e:	fb843783          	ld	a5,-72(s0)
    8001b022:	6b9c                	ld	a5,16(a5)
    8001b024:	fe843583          	ld	a1,-24(s0)
    8001b028:	853e                	mv	a0,a5
    8001b02a:	79e050ef          	jal	ra,800207c8 <list_elem_valid>
    8001b02e:	87aa                	mv	a5,a0
    8001b030:	f7e9                	bnez	a5,8001affa <rcb_debug+0xe2>
    }
    debugf("  file_descriptors:\n");
    8001b032:	0000d517          	auipc	a0,0xd
    8001b036:	27e50513          	addi	a0,a0,638 # 800282b0 <pow10.0+0x1450>
    8001b03a:	5a9000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(rcb->file_descriptors, e) {
    8001b03e:	fb843783          	ld	a5,-72(s0)
    8001b042:	6f9c                	ld	a5,24(a5)
    8001b044:	853e                	mv	a0,a5
    8001b046:	011050ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001b04a:	fea43423          	sd	a0,-24(s0)
    8001b04e:	a01d                	j	8001b074 <rcb_debug+0x15c>
        debugf("    %p\n", list_elem_value_ptr(e));
    8001b050:	fe843503          	ld	a0,-24(s0)
    8001b054:	063050ef          	jal	ra,800208b6 <list_elem_value>
    8001b058:	87aa                	mv	a5,a0
    8001b05a:	85be                	mv	a1,a5
    8001b05c:	0000d517          	auipc	a0,0xd
    8001b060:	22c50513          	addi	a0,a0,556 # 80028288 <pow10.0+0x1428>
    8001b064:	57f000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(rcb->file_descriptors, e) {
    8001b068:	fe843503          	ld	a0,-24(s0)
    8001b06c:	033050ef          	jal	ra,8002089e <list_elem_prev>
    8001b070:	fea43423          	sd	a0,-24(s0)
    8001b074:	fb843783          	ld	a5,-72(s0)
    8001b078:	6f9c                	ld	a5,24(a5)
    8001b07a:	fe843583          	ld	a1,-24(s0)
    8001b07e:	853e                	mv	a0,a5
    8001b080:	748050ef          	jal	ra,800207c8 <list_elem_valid>
    8001b084:	87aa                	mv	a5,a0
    8001b086:	f7e9                	bnez	a5,8001b050 <rcb_debug+0x138>
    }
    debugf("  environemnt:\n");
    8001b088:	0000d517          	auipc	a0,0xd
    8001b08c:	24050513          	addi	a0,a0,576 # 800282c8 <pow10.0+0x1468>
    8001b090:	553000ef          	jal	ra,8001bde2 <debugf>
    struct List *keys = map_get_keys(rcb->environemnt);
    8001b094:	fb843783          	ld	a5,-72(s0)
    8001b098:	739c                	ld	a5,32(a5)
    8001b09a:	853e                	mv	a0,a5
    8001b09c:	2c6060ef          	jal	ra,80021362 <map_get_keys>
    8001b0a0:	fca43c23          	sd	a0,-40(s0)
    struct ListElem *k;
    list_for_each(keys, k) {
    8001b0a4:	fd843503          	ld	a0,-40(s0)
    8001b0a8:	7ae050ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001b0ac:	fea43023          	sd	a0,-32(s0)
    8001b0b0:	a0a1                	j	8001b0f8 <rcb_debug+0x1e0>
        char *key = list_elem_value_ptr(k);
    8001b0b2:	fe043503          	ld	a0,-32(s0)
    8001b0b6:	001050ef          	jal	ra,800208b6 <list_elem_value>
    8001b0ba:	87aa                	mv	a5,a0
    8001b0bc:	fcf43823          	sd	a5,-48(s0)
        char *value;
        map_get(rcb->environemnt, key, (MapValue *)&value);
    8001b0c0:	fb843783          	ld	a5,-72(s0)
    8001b0c4:	739c                	ld	a5,32(a5)
    8001b0c6:	fc840713          	addi	a4,s0,-56
    8001b0ca:	863a                	mv	a2,a4
    8001b0cc:	fd043583          	ld	a1,-48(s0)
    8001b0d0:	853e                	mv	a0,a5
    8001b0d2:	77d050ef          	jal	ra,8002104e <map_get>
        debugf("    %s=%s\n", key, value);
    8001b0d6:	fc843783          	ld	a5,-56(s0)
    8001b0da:	863e                	mv	a2,a5
    8001b0dc:	fd043583          	ld	a1,-48(s0)
    8001b0e0:	0000d517          	auipc	a0,0xd
    8001b0e4:	1f850513          	addi	a0,a0,504 # 800282d8 <pow10.0+0x1478>
    8001b0e8:	4fb000ef          	jal	ra,8001bde2 <debugf>
    list_for_each(keys, k) {
    8001b0ec:	fe043503          	ld	a0,-32(s0)
    8001b0f0:	7ae050ef          	jal	ra,8002089e <list_elem_prev>
    8001b0f4:	fea43023          	sd	a0,-32(s0)
    8001b0f8:	fe043583          	ld	a1,-32(s0)
    8001b0fc:	fd843503          	ld	a0,-40(s0)
    8001b100:	6c8050ef          	jal	ra,800207c8 <list_elem_valid>
    8001b104:	87aa                	mv	a5,a0
    8001b106:	f7d5                	bnez	a5,8001b0b2 <rcb_debug+0x19a>
    }
    map_free_get_keys(keys);
    8001b108:	fd843503          	ld	a0,-40(s0)
    8001b10c:	2fc060ef          	jal	ra,80021408 <map_free_get_keys>
    debugf("  ptable:\n");
    8001b110:	0000d517          	auipc	a0,0xd
    8001b114:	1d850513          	addi	a0,a0,472 # 800282e8 <pow10.0+0x1488>
    8001b118:	4cb000ef          	jal	ra,8001bde2 <debugf>
    debugf("    %p\n", rcb->ptable);
    8001b11c:	fb843783          	ld	a5,-72(s0)
    8001b120:	779c                	ld	a5,40(a5)
    8001b122:	85be                	mv	a1,a5
    8001b124:	0000d517          	auipc	a0,0xd
    8001b128:	16450513          	addi	a0,a0,356 # 80028288 <pow10.0+0x1428>
    8001b12c:	4b7000ef          	jal	ra,8001bde2 <debugf>
}
    8001b130:	0001                	nop
    8001b132:	60a6                	ld	ra,72(sp)
    8001b134:	6406                	ld	s0,64(sp)
    8001b136:	6161                	addi	sp,sp,80
    8001b138:	8082                	ret

000000008001b13a <trap_frame_debug>:


void trap_frame_debug(TrapFrame *tf) {
    8001b13a:	7179                	addi	sp,sp,-48
    8001b13c:	f406                	sd	ra,40(sp)
    8001b13e:	f022                	sd	s0,32(sp)
    8001b140:	1800                	addi	s0,sp,48
    8001b142:	fca43c23          	sd	a0,-40(s0)
    debugf("TrapFrame:\n");
    8001b146:	0000d517          	auipc	a0,0xd
    8001b14a:	1b250513          	addi	a0,a0,434 # 800282f8 <pow10.0+0x1498>
    8001b14e:	495000ef          	jal	ra,8001bde2 <debugf>
    // uint64_t satp;
    // uint64_t sscratch;
    // uint64_t stvec;
    // uint64_t trap_satp;
    // uint64_t trap_stack;
    debugf("  xregs:\n");
    8001b152:	0000d517          	auipc	a0,0xd
    8001b156:	1b650513          	addi	a0,a0,438 # 80028308 <pow10.0+0x14a8>
    8001b15a:	489000ef          	jal	ra,8001bde2 <debugf>
    for (int i = 0; i < 32; i++) {
    8001b15e:	fe042623          	sw	zero,-20(s0)
    8001b162:	a03d                	j	8001b190 <trap_frame_debug+0x56>
        debugf("    x%d: %d\n", i, tf->xregs[i]);
    8001b164:	fd843703          	ld	a4,-40(s0)
    8001b168:	fec42783          	lw	a5,-20(s0)
    8001b16c:	078e                	slli	a5,a5,0x3
    8001b16e:	97ba                	add	a5,a5,a4
    8001b170:	6398                	ld	a4,0(a5)
    8001b172:	fec42783          	lw	a5,-20(s0)
    8001b176:	863a                	mv	a2,a4
    8001b178:	85be                	mv	a1,a5
    8001b17a:	0000d517          	auipc	a0,0xd
    8001b17e:	19e50513          	addi	a0,a0,414 # 80028318 <pow10.0+0x14b8>
    8001b182:	461000ef          	jal	ra,8001bde2 <debugf>
    for (int i = 0; i < 32; i++) {
    8001b186:	fec42783          	lw	a5,-20(s0)
    8001b18a:	2785                	addiw	a5,a5,1
    8001b18c:	fef42623          	sw	a5,-20(s0)
    8001b190:	fec42783          	lw	a5,-20(s0)
    8001b194:	0007871b          	sext.w	a4,a5
    8001b198:	47fd                	li	a5,31
    8001b19a:	fce7d5e3          	bge	a5,a4,8001b164 <trap_frame_debug+0x2a>
    }
    debugf("  fregs:\n");
    8001b19e:	0000d517          	auipc	a0,0xd
    8001b1a2:	18a50513          	addi	a0,a0,394 # 80028328 <pow10.0+0x14c8>
    8001b1a6:	43d000ef          	jal	ra,8001bde2 <debugf>
    for (int i = 0; i < 32; i++) {
    8001b1aa:	fe042423          	sw	zero,-24(s0)
    8001b1ae:	a815                	j	8001b1e2 <trap_frame_debug+0xa8>
        debugf("    f%d: %d\n", i, tf->fregs[i]);
    8001b1b0:	fd843703          	ld	a4,-40(s0)
    8001b1b4:	fe842783          	lw	a5,-24(s0)
    8001b1b8:	02078793          	addi	a5,a5,32
    8001b1bc:	078e                	slli	a5,a5,0x3
    8001b1be:	97ba                	add	a5,a5,a4
    8001b1c0:	239c                	fld	fa5,0(a5)
    8001b1c2:	fe842783          	lw	a5,-24(s0)
    8001b1c6:	e2078653          	fmv.x.d	a2,fa5
    8001b1ca:	85be                	mv	a1,a5
    8001b1cc:	0000d517          	auipc	a0,0xd
    8001b1d0:	16c50513          	addi	a0,a0,364 # 80028338 <pow10.0+0x14d8>
    8001b1d4:	40f000ef          	jal	ra,8001bde2 <debugf>
    for (int i = 0; i < 32; i++) {
    8001b1d8:	fe842783          	lw	a5,-24(s0)
    8001b1dc:	2785                	addiw	a5,a5,1
    8001b1de:	fef42423          	sw	a5,-24(s0)
    8001b1e2:	fe842783          	lw	a5,-24(s0)
    8001b1e6:	0007871b          	sext.w	a4,a5
    8001b1ea:	47fd                	li	a5,31
    8001b1ec:	fce7d2e3          	bge	a5,a4,8001b1b0 <trap_frame_debug+0x76>
    }
    debugf("  sepc: 0x%p\n", tf->sepc);
    8001b1f0:	fd843783          	ld	a5,-40(s0)
    8001b1f4:	2007b783          	ld	a5,512(a5)
    8001b1f8:	85be                	mv	a1,a5
    8001b1fa:	0000d517          	auipc	a0,0xd
    8001b1fe:	14e50513          	addi	a0,a0,334 # 80028348 <pow10.0+0x14e8>
    8001b202:	3e1000ef          	jal	ra,8001bde2 <debugf>
    debugf("  sstatus: 0x%p\n", tf->sstatus);
    8001b206:	fd843783          	ld	a5,-40(s0)
    8001b20a:	2087b783          	ld	a5,520(a5)
    8001b20e:	85be                	mv	a1,a5
    8001b210:	0000d517          	auipc	a0,0xd
    8001b214:	14850513          	addi	a0,a0,328 # 80028358 <pow10.0+0x14f8>
    8001b218:	3cb000ef          	jal	ra,8001bde2 <debugf>
    debugf("  sie: 0x%p\n", tf->sie);
    8001b21c:	fd843783          	ld	a5,-40(s0)
    8001b220:	2107b783          	ld	a5,528(a5)
    8001b224:	85be                	mv	a1,a5
    8001b226:	0000d517          	auipc	a0,0xd
    8001b22a:	14a50513          	addi	a0,a0,330 # 80028370 <pow10.0+0x1510>
    8001b22e:	3b5000ef          	jal	ra,8001bde2 <debugf>
    debugf("  satp: 0x%p\n", tf->satp);
    8001b232:	fd843783          	ld	a5,-40(s0)
    8001b236:	2187b783          	ld	a5,536(a5)
    8001b23a:	85be                	mv	a1,a5
    8001b23c:	0000d517          	auipc	a0,0xd
    8001b240:	14450513          	addi	a0,a0,324 # 80028380 <pow10.0+0x1520>
    8001b244:	39f000ef          	jal	ra,8001bde2 <debugf>
    debugf("  sscratch: 0x%p\n", tf->sscratch);
    8001b248:	fd843783          	ld	a5,-40(s0)
    8001b24c:	2207b783          	ld	a5,544(a5)
    8001b250:	85be                	mv	a1,a5
    8001b252:	0000d517          	auipc	a0,0xd
    8001b256:	13e50513          	addi	a0,a0,318 # 80028390 <pow10.0+0x1530>
    8001b25a:	389000ef          	jal	ra,8001bde2 <debugf>
    debugf("  stvec: 0x%p\n", tf->stvec);
    8001b25e:	fd843783          	ld	a5,-40(s0)
    8001b262:	2287b783          	ld	a5,552(a5)
    8001b266:	85be                	mv	a1,a5
    8001b268:	0000d517          	auipc	a0,0xd
    8001b26c:	14050513          	addi	a0,a0,320 # 800283a8 <pow10.0+0x1548>
    8001b270:	373000ef          	jal	ra,8001bde2 <debugf>
    debugf("  trap_satp: 0x%p\n", tf->trap_satp);
    8001b274:	fd843783          	ld	a5,-40(s0)
    8001b278:	2307b783          	ld	a5,560(a5)
    8001b27c:	85be                	mv	a1,a5
    8001b27e:	0000d517          	auipc	a0,0xd
    8001b282:	13a50513          	addi	a0,a0,314 # 800283b8 <pow10.0+0x1558>
    8001b286:	35d000ef          	jal	ra,8001bde2 <debugf>
    debugf("  trap_stack: 0x%p\n", tf->trap_stack);
    8001b28a:	fd843783          	ld	a5,-40(s0)
    8001b28e:	2387b783          	ld	a5,568(a5)
    8001b292:	85be                	mv	a1,a5
    8001b294:	0000d517          	auipc	a0,0xd
    8001b298:	13c50513          	addi	a0,a0,316 # 800283d0 <pow10.0+0x1570>
    8001b29c:	347000ef          	jal	ra,8001bde2 <debugf>
}
    8001b2a0:	0001                	nop
    8001b2a2:	70a2                	ld	ra,40(sp)
    8001b2a4:	7402                	ld	s0,32(sp)
    8001b2a6:	6145                	addi	sp,sp,48
    8001b2a8:	8082                	ret

000000008001b2aa <process_debug>:

void process_debug(Process *p) {
    8001b2aa:	7179                	addi	sp,sp,-48
    8001b2ac:	f406                	sd	ra,40(sp)
    8001b2ae:	f022                	sd	s0,32(sp)
    8001b2b0:	ec26                	sd	s1,24(sp)
    8001b2b2:	1800                	addi	s0,sp,48
    8001b2b4:	fca43c23          	sd	a0,-40(s0)
    debugf("Process:\n");
    8001b2b8:	0000d517          	auipc	a0,0xd
    8001b2bc:	13050513          	addi	a0,a0,304 # 800283e8 <pow10.0+0x1588>
    8001b2c0:	323000ef          	jal	ra,8001bde2 <debugf>
    // uint16_t pid;
    // uint32_t hart;
    // ProcessMode mode;
    // ProcessState state;
    // TrapFrame frame;
    debugf("  pid: %d\n", p->pid);
    8001b2c4:	fd843783          	ld	a5,-40(s0)
    8001b2c8:	0007d783          	lhu	a5,0(a5)
    8001b2cc:	2781                	sext.w	a5,a5
    8001b2ce:	85be                	mv	a1,a5
    8001b2d0:	0000d517          	auipc	a0,0xd
    8001b2d4:	12850513          	addi	a0,a0,296 # 800283f8 <pow10.0+0x1598>
    8001b2d8:	30b000ef          	jal	ra,8001bde2 <debugf>
    debugf("  hart: %d\n", p->hart);
    8001b2dc:	fd843783          	ld	a5,-40(s0)
    8001b2e0:	43dc                	lw	a5,4(a5)
    8001b2e2:	85be                	mv	a1,a5
    8001b2e4:	0000d517          	auipc	a0,0xd
    8001b2e8:	12450513          	addi	a0,a0,292 # 80028408 <pow10.0+0x15a8>
    8001b2ec:	2f7000ef          	jal	ra,8001bde2 <debugf>
    debugf("  mode: %d\n", p->mode);
    8001b2f0:	fd843783          	ld	a5,-40(s0)
    8001b2f4:	479c                	lw	a5,8(a5)
    8001b2f6:	85be                	mv	a1,a5
    8001b2f8:	0000d517          	auipc	a0,0xd
    8001b2fc:	12050513          	addi	a0,a0,288 # 80028418 <pow10.0+0x15b8>
    8001b300:	2e3000ef          	jal	ra,8001bde2 <debugf>
    debugf("  state: %d\n", p->state);
    8001b304:	fd843783          	ld	a5,-40(s0)
    8001b308:	47dc                	lw	a5,12(a5)
    8001b30a:	85be                	mv	a1,a5
    8001b30c:	0000d517          	auipc	a0,0xd
    8001b310:	11c50513          	addi	a0,a0,284 # 80028428 <pow10.0+0x15c8>
    8001b314:	2cf000ef          	jal	ra,8001bde2 <debugf>
    trap_frame_debug(&p->frame);
    8001b318:	fd843783          	ld	a5,-40(s0)
    8001b31c:	07c1                	addi	a5,a5,16
    8001b31e:	853e                	mv	a0,a5
    8001b320:	e1bff0ef          	jal	ra,8001b13a <trap_frame_debug>
    // uint64_t sleep_until;
    // uint64_t runtime;
    // uint64_t ran_at;
    // uint64_t priority;
    // uint64_t quantum;
    debugf("  sleep_until: %d\n", p->sleep_until);
    8001b324:	fd843783          	ld	a5,-40(s0)
    8001b328:	2507b783          	ld	a5,592(a5)
    8001b32c:	85be                	mv	a1,a5
    8001b32e:	0000d517          	auipc	a0,0xd
    8001b332:	10a50513          	addi	a0,a0,266 # 80028438 <pow10.0+0x15d8>
    8001b336:	2ad000ef          	jal	ra,8001bde2 <debugf>
    debugf("  runtime: %d\n", p->runtime);
    8001b33a:	fd843783          	ld	a5,-40(s0)
    8001b33e:	2587b783          	ld	a5,600(a5)
    8001b342:	85be                	mv	a1,a5
    8001b344:	0000d517          	auipc	a0,0xd
    8001b348:	10c50513          	addi	a0,a0,268 # 80028450 <pow10.0+0x15f0>
    8001b34c:	297000ef          	jal	ra,8001bde2 <debugf>
    debugf("  ran_at: %d\n", p->ran_at);
    8001b350:	fd843783          	ld	a5,-40(s0)
    8001b354:	2607b783          	ld	a5,608(a5)
    8001b358:	85be                	mv	a1,a5
    8001b35a:	0000d517          	auipc	a0,0xd
    8001b35e:	10650513          	addi	a0,a0,262 # 80028460 <pow10.0+0x1600>
    8001b362:	281000ef          	jal	ra,8001bde2 <debugf>
    debugf("  priority: %d\n", p->priority);
    8001b366:	fd843783          	ld	a5,-40(s0)
    8001b36a:	2687b783          	ld	a5,616(a5)
    8001b36e:	85be                	mv	a1,a5
    8001b370:	0000d517          	auipc	a0,0xd
    8001b374:	10050513          	addi	a0,a0,256 # 80028470 <pow10.0+0x1610>
    8001b378:	26b000ef          	jal	ra,8001bde2 <debugf>
    debugf("  quantum: %d\n", p->quantum);
    8001b37c:	fd843783          	ld	a5,-40(s0)
    8001b380:	2707b783          	ld	a5,624(a5)
    8001b384:	85be                	mv	a1,a5
    8001b386:	0000d517          	auipc	a0,0xd
    8001b38a:	0fa50513          	addi	a0,a0,250 # 80028480 <pow10.0+0x1620>
    8001b38e:	255000ef          	jal	ra,8001bde2 <debugf>

    if (p->image) {
    8001b392:	fd843783          	ld	a5,-40(s0)
    8001b396:	2787b783          	ld	a5,632(a5)
    8001b39a:	c3a9                	beqz	a5,8001b3dc <process_debug+0x132>
        debugf("  image: %p\n", p->image);
    8001b39c:	fd843783          	ld	a5,-40(s0)
    8001b3a0:	2787b783          	ld	a5,632(a5)
    8001b3a4:	85be                	mv	a1,a5
    8001b3a6:	0000d517          	auipc	a0,0xd
    8001b3aa:	0ea50513          	addi	a0,a0,234 # 80028490 <pow10.0+0x1630>
    8001b3ae:	235000ef          	jal	ra,8001bde2 <debugf>
        debugf("  image_size: 0x%X (%d pages)\n", p->image_size, ALIGN_UP_POT(p->image_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    8001b3b2:	fd843783          	ld	a5,-40(s0)
    8001b3b6:	2807b683          	ld	a3,640(a5)
    8001b3ba:	fd843783          	ld	a5,-40(s0)
    8001b3be:	2807b703          	ld	a4,640(a5)
    8001b3c2:	6785                	lui	a5,0x1
    8001b3c4:	17fd                	addi	a5,a5,-1
    8001b3c6:	97ba                	add	a5,a5,a4
    8001b3c8:	83b1                	srli	a5,a5,0xc
    8001b3ca:	863e                	mv	a2,a5
    8001b3cc:	85b6                	mv	a1,a3
    8001b3ce:	0000d517          	auipc	a0,0xd
    8001b3d2:	0d250513          	addi	a0,a0,210 # 800284a0 <pow10.0+0x1640>
    8001b3d6:	20d000ef          	jal	ra,8001bde2 <debugf>
    8001b3da:	a039                	j	8001b3e8 <process_debug+0x13e>
    } else {
        debugf("  image: NULL\n");
    8001b3dc:	0000d517          	auipc	a0,0xd
    8001b3e0:	0e450513          	addi	a0,a0,228 # 800284c0 <pow10.0+0x1660>
    8001b3e4:	1ff000ef          	jal	ra,8001bde2 <debugf>
    }
    if (p->text) {
    8001b3e8:	fd843783          	ld	a5,-40(s0)
    8001b3ec:	2887b783          	ld	a5,648(a5) # 1288 <i+0x1268>
    8001b3f0:	cfb9                	beqz	a5,8001b44e <process_debug+0x1a4>
        debugf("  text: %p (physical address = %p)\n", p->text_vaddr, mmu_translate(p->rcb.ptable, (uintptr_t)p->text_vaddr));
    8001b3f2:	fd843783          	ld	a5,-40(s0)
    8001b3f6:	2907b483          	ld	s1,656(a5)
    8001b3fa:	fd843783          	ld	a5,-40(s0)
    8001b3fe:	3407b703          	ld	a4,832(a5)
    8001b402:	fd843783          	ld	a5,-40(s0)
    8001b406:	2907b783          	ld	a5,656(a5)
    8001b40a:	85be                	mv	a1,a5
    8001b40c:	853a                	mv	a0,a4
    8001b40e:	cf8fa0ef          	jal	ra,80015906 <mmu_translate>
    8001b412:	87aa                	mv	a5,a0
    8001b414:	863e                	mv	a2,a5
    8001b416:	85a6                	mv	a1,s1
    8001b418:	0000d517          	auipc	a0,0xd
    8001b41c:	0b850513          	addi	a0,a0,184 # 800284d0 <pow10.0+0x1670>
    8001b420:	1c3000ef          	jal	ra,8001bde2 <debugf>
        debugf("  text_size: 0x%X (%d pages)\n", p->text_size, ALIGN_UP_POT(p->text_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    8001b424:	fd843783          	ld	a5,-40(s0)
    8001b428:	2987b683          	ld	a3,664(a5)
    8001b42c:	fd843783          	ld	a5,-40(s0)
    8001b430:	2987b703          	ld	a4,664(a5)
    8001b434:	6785                	lui	a5,0x1
    8001b436:	17fd                	addi	a5,a5,-1
    8001b438:	97ba                	add	a5,a5,a4
    8001b43a:	83b1                	srli	a5,a5,0xc
    8001b43c:	863e                	mv	a2,a5
    8001b43e:	85b6                	mv	a1,a3
    8001b440:	0000d517          	auipc	a0,0xd
    8001b444:	0b850513          	addi	a0,a0,184 # 800284f8 <pow10.0+0x1698>
    8001b448:	19b000ef          	jal	ra,8001bde2 <debugf>
    8001b44c:	a039                	j	8001b45a <process_debug+0x1b0>
    } else {
        debugf("  text: NULL\n");
    8001b44e:	0000d517          	auipc	a0,0xd
    8001b452:	0ca50513          	addi	a0,a0,202 # 80028518 <pow10.0+0x16b8>
    8001b456:	18d000ef          	jal	ra,8001bde2 <debugf>
    }
    if (p->bss) {
    8001b45a:	fd843783          	ld	a5,-40(s0)
    8001b45e:	2a07b783          	ld	a5,672(a5) # 12a0 <i+0x1280>
    8001b462:	cfb9                	beqz	a5,8001b4c0 <process_debug+0x216>
        debugf("  bss: %p (physical address = %p)\n", p->bss_vaddr, mmu_translate(p->rcb.ptable, (uintptr_t)p->bss_vaddr));
    8001b464:	fd843783          	ld	a5,-40(s0)
    8001b468:	2a87b483          	ld	s1,680(a5)
    8001b46c:	fd843783          	ld	a5,-40(s0)
    8001b470:	3407b703          	ld	a4,832(a5)
    8001b474:	fd843783          	ld	a5,-40(s0)
    8001b478:	2a87b783          	ld	a5,680(a5)
    8001b47c:	85be                	mv	a1,a5
    8001b47e:	853a                	mv	a0,a4
    8001b480:	c86fa0ef          	jal	ra,80015906 <mmu_translate>
    8001b484:	87aa                	mv	a5,a0
    8001b486:	863e                	mv	a2,a5
    8001b488:	85a6                	mv	a1,s1
    8001b48a:	0000d517          	auipc	a0,0xd
    8001b48e:	09e50513          	addi	a0,a0,158 # 80028528 <pow10.0+0x16c8>
    8001b492:	151000ef          	jal	ra,8001bde2 <debugf>
        // debugf("  bss_size: 0x%X (%d pages)\n", p->bss_size, p->bss_size / PAGE_SIZE);
        debugf("  bss_size: 0x%X (%d pages)\n", p->bss_size, ALIGN_UP_POT(p->bss_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    8001b496:	fd843783          	ld	a5,-40(s0)
    8001b49a:	2b07b683          	ld	a3,688(a5)
    8001b49e:	fd843783          	ld	a5,-40(s0)
    8001b4a2:	2b07b703          	ld	a4,688(a5)
    8001b4a6:	6785                	lui	a5,0x1
    8001b4a8:	17fd                	addi	a5,a5,-1
    8001b4aa:	97ba                	add	a5,a5,a4
    8001b4ac:	83b1                	srli	a5,a5,0xc
    8001b4ae:	863e                	mv	a2,a5
    8001b4b0:	85b6                	mv	a1,a3
    8001b4b2:	0000d517          	auipc	a0,0xd
    8001b4b6:	09e50513          	addi	a0,a0,158 # 80028550 <pow10.0+0x16f0>
    8001b4ba:	129000ef          	jal	ra,8001bde2 <debugf>
    8001b4be:	a039                	j	8001b4cc <process_debug+0x222>
        
    } else {
        debugf("  bss: NULL\n");
    8001b4c0:	0000d517          	auipc	a0,0xd
    8001b4c4:	0b050513          	addi	a0,a0,176 # 80028570 <pow10.0+0x1710>
    8001b4c8:	11b000ef          	jal	ra,8001bde2 <debugf>
    }
    if (p->rodata) {
    8001b4cc:	fd843783          	ld	a5,-40(s0)
    8001b4d0:	2b87b783          	ld	a5,696(a5) # 12b8 <i+0x1298>
    8001b4d4:	cfb9                	beqz	a5,8001b532 <process_debug+0x288>
        debugf("  rodata: %p (physical address = %p)\n", p->rodata_vaddr, mmu_translate(p->rcb.ptable, (uintptr_t)p->rodata_vaddr));
    8001b4d6:	fd843783          	ld	a5,-40(s0)
    8001b4da:	2c07b483          	ld	s1,704(a5)
    8001b4de:	fd843783          	ld	a5,-40(s0)
    8001b4e2:	3407b703          	ld	a4,832(a5)
    8001b4e6:	fd843783          	ld	a5,-40(s0)
    8001b4ea:	2c07b783          	ld	a5,704(a5)
    8001b4ee:	85be                	mv	a1,a5
    8001b4f0:	853a                	mv	a0,a4
    8001b4f2:	c14fa0ef          	jal	ra,80015906 <mmu_translate>
    8001b4f6:	87aa                	mv	a5,a0
    8001b4f8:	863e                	mv	a2,a5
    8001b4fa:	85a6                	mv	a1,s1
    8001b4fc:	0000d517          	auipc	a0,0xd
    8001b500:	08450513          	addi	a0,a0,132 # 80028580 <pow10.0+0x1720>
    8001b504:	0df000ef          	jal	ra,8001bde2 <debugf>
        debugf("  rodata_size: 0x%X (%d pages)\n", p->rodata_size, ALIGN_UP_POT(p->rodata_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    8001b508:	fd843783          	ld	a5,-40(s0)
    8001b50c:	2c87b683          	ld	a3,712(a5)
    8001b510:	fd843783          	ld	a5,-40(s0)
    8001b514:	2c87b703          	ld	a4,712(a5)
    8001b518:	6785                	lui	a5,0x1
    8001b51a:	17fd                	addi	a5,a5,-1
    8001b51c:	97ba                	add	a5,a5,a4
    8001b51e:	83b1                	srli	a5,a5,0xc
    8001b520:	863e                	mv	a2,a5
    8001b522:	85b6                	mv	a1,a3
    8001b524:	0000d517          	auipc	a0,0xd
    8001b528:	08450513          	addi	a0,a0,132 # 800285a8 <pow10.0+0x1748>
    8001b52c:	0b7000ef          	jal	ra,8001bde2 <debugf>
    8001b530:	a039                	j	8001b53e <process_debug+0x294>
    } else {
        debugf("  rodata: NULL\n");
    8001b532:	0000d517          	auipc	a0,0xd
    8001b536:	09650513          	addi	a0,a0,150 # 800285c8 <pow10.0+0x1768>
    8001b53a:	0a9000ef          	jal	ra,8001bde2 <debugf>
    }
    if (p->data) {
    8001b53e:	fd843783          	ld	a5,-40(s0)
    8001b542:	2d07b783          	ld	a5,720(a5) # 12d0 <i+0x12b0>
    8001b546:	cfb9                	beqz	a5,8001b5a4 <process_debug+0x2fa>
        debugf("  data: %p (physical address = %p)\n", p->data_vaddr, mmu_translate(p->rcb.ptable, (uintptr_t)p->data_vaddr));
    8001b548:	fd843783          	ld	a5,-40(s0)
    8001b54c:	2d87b483          	ld	s1,728(a5)
    8001b550:	fd843783          	ld	a5,-40(s0)
    8001b554:	3407b703          	ld	a4,832(a5)
    8001b558:	fd843783          	ld	a5,-40(s0)
    8001b55c:	2d87b783          	ld	a5,728(a5)
    8001b560:	85be                	mv	a1,a5
    8001b562:	853a                	mv	a0,a4
    8001b564:	ba2fa0ef          	jal	ra,80015906 <mmu_translate>
    8001b568:	87aa                	mv	a5,a0
    8001b56a:	863e                	mv	a2,a5
    8001b56c:	85a6                	mv	a1,s1
    8001b56e:	0000d517          	auipc	a0,0xd
    8001b572:	06a50513          	addi	a0,a0,106 # 800285d8 <pow10.0+0x1778>
    8001b576:	06d000ef          	jal	ra,8001bde2 <debugf>
        debugf("  data_size: 0x%X (%d pages)\n", p->data_size, ALIGN_UP_POT(p->data_size, PAGE_SIZE_4K) / PAGE_SIZE_4K);
    8001b57a:	fd843783          	ld	a5,-40(s0)
    8001b57e:	2e07b683          	ld	a3,736(a5)
    8001b582:	fd843783          	ld	a5,-40(s0)
    8001b586:	2e07b703          	ld	a4,736(a5)
    8001b58a:	6785                	lui	a5,0x1
    8001b58c:	17fd                	addi	a5,a5,-1
    8001b58e:	97ba                	add	a5,a5,a4
    8001b590:	83b1                	srli	a5,a5,0xc
    8001b592:	863e                	mv	a2,a5
    8001b594:	85b6                	mv	a1,a3
    8001b596:	0000d517          	auipc	a0,0xd
    8001b59a:	06a50513          	addi	a0,a0,106 # 80028600 <pow10.0+0x17a0>
    8001b59e:	045000ef          	jal	ra,8001bde2 <debugf>
    8001b5a2:	a039                	j	8001b5b0 <process_debug+0x306>
    } else {
        debugf("  data: NULL\n");
    8001b5a4:	0000d517          	auipc	a0,0xd
    8001b5a8:	07c50513          	addi	a0,a0,124 # 80028620 <pow10.0+0x17c0>
    8001b5ac:	037000ef          	jal	ra,8001bde2 <debugf>
    }

    // // Resources
    // RCB rcb;
    rcb_debug(&p->rcb);
    8001b5b0:	fd843783          	ld	a5,-40(s0)
    8001b5b4:	31878793          	addi	a5,a5,792 # 1318 <i+0x12f8>
    8001b5b8:	853e                	mv	a0,a5
    8001b5ba:	95fff0ef          	jal	ra,8001af18 <rcb_debug>
    // uint64_t break_size;
}
    8001b5be:	0001                	nop
    8001b5c0:	70a2                	ld	ra,40(sp)
    8001b5c2:	7402                	ld	s0,32(sp)
    8001b5c4:	64e2                	ld	s1,24(sp)
    8001b5c6:	6145                	addi	sp,sp,48
    8001b5c8:	8082                	ret

000000008001b5ca <process_new>:

Process *process_new(ProcessMode mode)
{
    8001b5ca:	715d                	addi	sp,sp,-80
    8001b5cc:	e486                	sd	ra,72(sp)
    8001b5ce:	e0a2                	sd	s0,64(sp)
    8001b5d0:	0880                	addi	s0,sp,80
    8001b5d2:	87aa                	mv	a5,a0
    8001b5d4:	faf42e23          	sw	a5,-68(s0)
    Process *p = (Process *)kzalloc(sizeof(*p));
    8001b5d8:	35000593          	li	a1,848
    8001b5dc:	4505                	li	a0,1
    8001b5de:	f75f90ef          	jal	ra,80015552 <kcalloc>
    8001b5e2:	fea43023          	sd	a0,-32(s0)
    debugf("process.c (process_new): Process address: 0x%08x\n", p);
    8001b5e6:	fe043583          	ld	a1,-32(s0)
    8001b5ea:	0000d517          	auipc	a0,0xd
    8001b5ee:	04650513          	addi	a0,a0,70 # 80028630 <pow10.0+0x17d0>
    8001b5f2:	7f0000ef          	jal	ra,8001bde2 <debugf>

    p->pid = generate_unique_pid();
    8001b5f6:	8c1ff0ef          	jal	ra,8001aeb6 <generate_unique_pid>
    8001b5fa:	87aa                	mv	a5,a0
    8001b5fc:	873e                	mv	a4,a5
    8001b5fe:	fe043783          	ld	a5,-32(s0)
    8001b602:	00e79023          	sh	a4,0(a5)
    p->hart = -1U;
    8001b606:	fe043783          	ld	a5,-32(s0)
    8001b60a:	577d                	li	a4,-1
    8001b60c:	c3d8                	sw	a4,4(a5)
    p->mode = mode;
    8001b60e:	fe043783          	ld	a5,-32(s0)
    8001b612:	fbc42703          	lw	a4,-68(s0)
    8001b616:	c798                	sw	a4,8(a5)
    p->state = PS_WAITING;
    8001b618:	fe043783          	ld	a5,-32(s0)
    8001b61c:	4705                	li	a4,1
    8001b61e:	c7d8                	sw	a4,12(a5)
    
    process_map_set(p);
    8001b620:	fe043503          	ld	a0,-32(s0)
    8001b624:	4e6000ef          	jal	ra,8001bb0a <process_map_set>

    // Initialize the Resource Control Block
    p->rcb.image_pages = list_new();
    8001b628:	5df040ef          	jal	ra,80020406 <list_new>
    8001b62c:	872a                	mv	a4,a0
    8001b62e:	fe043783          	ld	a5,-32(s0)
    8001b632:	30e7bc23          	sd	a4,792(a5)
    p->rcb.stack_pages = list_new();
    8001b636:	5d1040ef          	jal	ra,80020406 <list_new>
    8001b63a:	872a                	mv	a4,a0
    8001b63c:	fe043783          	ld	a5,-32(s0)
    8001b640:	32e7b023          	sd	a4,800(a5)
    p->rcb.heap_pages = list_new();
    8001b644:	5c3040ef          	jal	ra,80020406 <list_new>
    8001b648:	872a                	mv	a4,a0
    8001b64a:	fe043783          	ld	a5,-32(s0)
    8001b64e:	32e7b423          	sd	a4,808(a5)
    p->rcb.file_descriptors = list_new();
    8001b652:	5b5040ef          	jal	ra,80020406 <list_new>
    8001b656:	872a                	mv	a4,a0
    8001b658:	fe043783          	ld	a5,-32(s0)
    8001b65c:	32e7b823          	sd	a4,816(a5)
    p->rcb.environemnt = map_new();
    8001b660:	0a7050ef          	jal	ra,80020f06 <map_new>
    8001b664:	872a                	mv	a4,a0
    8001b666:	fe043783          	ld	a5,-32(s0)
    8001b66a:	32e7bc23          	sd	a4,824(a5)
    p->rcb.ptable = mmu_table_create();
    8001b66e:	814fa0ef          	jal	ra,80015682 <mmu_table_create>
    8001b672:	872a                	mv	a4,a0
    8001b674:	fe043783          	ld	a5,-32(s0)
    8001b678:	34e7b023          	sd	a4,832(a5)

    // Set the trap frame and create all necessary structures.
    // p->frame.sepc = filled_in_by_ELF_loader
    p->frame.sstatus = SSTATUS_SPP_BOOL(mode) | SSTATUS_FS_INITIAL | SSTATUS_SPIE;
    8001b67c:	fbc42783          	lw	a5,-68(s0)
    8001b680:	2781                	sext.w	a5,a5
    8001b682:	c789                	beqz	a5,8001b68c <process_new+0xc2>
    8001b684:	6789                	lui	a5,0x2
    8001b686:	12078793          	addi	a5,a5,288 # 2120 <i+0x2100>
    8001b68a:	a021                	j	8001b692 <process_new+0xc8>
    8001b68c:	6789                	lui	a5,0x2
    8001b68e:	02078793          	addi	a5,a5,32 # 2020 <i+0x2000>
    8001b692:	fe043703          	ld	a4,-32(s0)
    8001b696:	20f73c23          	sd	a5,536(a4)
    p->frame.sie = SIE_SEIE | SIE_SSIE | SIE_STIE;
    8001b69a:	fe043783          	ld	a5,-32(s0)
    8001b69e:	22200713          	li	a4,546
    8001b6a2:	22e7b023          	sd	a4,544(a5)
    p->frame.satp = SATP(p->rcb.ptable, p->pid);
    8001b6a6:	fe043783          	ld	a5,-32(s0)
    8001b6aa:	3407b783          	ld	a5,832(a5)
    8001b6ae:	00c7d713          	srli	a4,a5,0xc
    8001b6b2:	57fd                	li	a5,-1
    8001b6b4:	83d1                	srli	a5,a5,0x14
    8001b6b6:	8f7d                	and	a4,a4,a5
    8001b6b8:	fe043783          	ld	a5,-32(s0)
    8001b6bc:	0007d783          	lhu	a5,0(a5)
    8001b6c0:	17b2                	slli	a5,a5,0x2c
    8001b6c2:	8f5d                	or	a4,a4,a5
    8001b6c4:	57fd                	li	a5,-1
    8001b6c6:	17fe                	slli	a5,a5,0x3f
    8001b6c8:	8f5d                	or	a4,a4,a5
    8001b6ca:	fe043783          	ld	a5,-32(s0)
    8001b6ce:	22e7b423          	sd	a4,552(a5)
    p->frame.sscratch = (unsigned long)&p->frame;
    8001b6d2:	fe043783          	ld	a5,-32(s0)
    8001b6d6:	07c1                	addi	a5,a5,16
    8001b6d8:	873e                	mv	a4,a5
    8001b6da:	fe043783          	ld	a5,-32(s0)
    8001b6de:	22e7b823          	sd	a4,560(a5)
    p->frame.stvec = trampoline_trap_start;
    8001b6e2:	0000e797          	auipc	a5,0xe
    8001b6e6:	17f78793          	addi	a5,a5,383 # 80029861 <trampoline_trap_start>
    8001b6ea:	6398                	ld	a4,0(a5)
    8001b6ec:	fe043783          	ld	a5,-32(s0)
    8001b6f0:	22e7bc23          	sd	a4,568(a5)
    p->frame.trap_satp = SATP_KERNEL;
    8001b6f4:	0000a797          	auipc	a5,0xa
    8001b6f8:	91478793          	addi	a5,a5,-1772 # 80025008 <kernel_mmu_table>
    8001b6fc:	639c                	ld	a5,0(a5)
    8001b6fe:	00c7d713          	srli	a4,a5,0xc
    8001b702:	57fd                	li	a5,-1
    8001b704:	83d1                	srli	a5,a5,0x14
    8001b706:	8f7d                	and	a4,a4,a5
    8001b708:	8ffff7b7          	lui	a5,0x8ffff
    8001b70c:	1782                	slli	a5,a5,0x20
    8001b70e:	8f5d                	or	a4,a4,a5
    8001b710:	fe043783          	ld	a5,-32(s0)
    8001b714:	24e7b023          	sd	a4,576(a5) # ffffffff8ffff240 <_heap_end+0xffffffff07fef240>
    // p->frame.trap_stack = filled_in_by_SCHEDULER
    
    p->frame.trap_stack = (uint64_t)kmalloc(0x10000); 
    8001b718:	6541                	lui	a0,0x10
    8001b71a:	e19f90ef          	jal	ra,80015532 <kmalloc>
    8001b71e:	87aa                	mv	a5,a0
    8001b720:	873e                	mv	a4,a5
    8001b722:	fe043783          	ld	a5,-32(s0)
    8001b726:	24e7b423          	sd	a4,584(a5)

    // We need to keep track of the stack itself in the kernel, so we can free it
    // later, but the user process will interact with the stack via the SP register.
    p->frame.xregs[XREG_SP] = STACK_TOP + STACK_SIZE;
    8001b72a:	fe043783          	ld	a5,-32(s0)
    8001b72e:	c0fff737          	lui	a4,0xc0fff
    8001b732:	0712                	slli	a4,a4,0x4
    8001b734:	f398                	sd	a4,32(a5)
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    8001b736:	fe043423          	sd	zero,-24(s0)
    8001b73a:	a085                	j	8001b79a <process_new+0x1d0>
        void *stack = page_zalloc();
    8001b73c:	4505                	li	a0,1
    8001b73e:	049020ef          	jal	ra,8001df86 <page_znalloc>
    8001b742:	fca43023          	sd	a0,-64(s0)
        list_add_ptr(p->rcb.stack_pages, stack);
    8001b746:	fe043783          	ld	a5,-32(s0)
    8001b74a:	3207b783          	ld	a5,800(a5)
    8001b74e:	fc043703          	ld	a4,-64(s0)
    8001b752:	85ba                	mv	a1,a4
    8001b754:	853e                	mv	a0,a5
    8001b756:	4e1040ef          	jal	ra,80020436 <list_add>
        mmu_map(p->rcb.ptable, STACK_TOP + PAGE_SIZE * i, (unsigned long)stack,
    8001b75a:	fe043783          	ld	a5,-32(s0)
    8001b75e:	3407b503          	ld	a0,832(a5)
    8001b762:	fe843783          	ld	a5,-24(s0)
    8001b766:	00c79713          	slli	a4,a5,0xc
    8001b76a:	ffe087b7          	lui	a5,0xffe08
    8001b76e:	17dd                	addi	a5,a5,-9
    8001b770:	07b6                	slli	a5,a5,0xd
    8001b772:	00f705b3          	add	a1,a4,a5
    8001b776:	fc043603          	ld	a2,-64(s0)
    8001b77a:	fbc42783          	lw	a5,-68(s0)
    8001b77e:	2781                	sext.w	a5,a5
    8001b780:	e399                	bnez	a5,8001b786 <process_new+0x1bc>
    8001b782:	47c1                	li	a5,16
    8001b784:	a011                	j	8001b788 <process_new+0x1be>
    8001b786:	4799                	li	a5,6
    8001b788:	873e                	mv	a4,a5
    8001b78a:	4681                	li	a3,0
    8001b78c:	f51f90ef          	jal	ra,800156dc <mmu_map>
    for (unsigned long i = 0; i < STACK_PAGES; i += 1) {
    8001b790:	fe843783          	ld	a5,-24(s0)
    8001b794:	0785                	addi	a5,a5,1
    8001b796:	fef43423          	sd	a5,-24(s0)
    8001b79a:	fe843703          	ld	a4,-24(s0)
    8001b79e:	4785                	li	a5,1
    8001b7a0:	f8e7fee3          	bgeu	a5,a4,8001b73c <process_new+0x172>
    }

    // We need to map certain kernel portions into the user's page table. Notice
    // that the PB_USER is NOT set, but it needs to be there because we need to execute
    // the trap/start instructions while using the user's page table until we change SATP.
    unsigned long trans_trampoline_start = mmu_translate(kernel_mmu_table, trampoline_thread_start);
    8001b7a4:	0000a797          	auipc	a5,0xa
    8001b7a8:	86478793          	addi	a5,a5,-1948 # 80025008 <kernel_mmu_table>
    8001b7ac:	6398                	ld	a4,0(a5)
    8001b7ae:	0000e797          	auipc	a5,0xe
    8001b7b2:	09b78793          	addi	a5,a5,155 # 80029849 <trampoline_thread_start>
    8001b7b6:	639c                	ld	a5,0(a5)
    8001b7b8:	85be                	mv	a1,a5
    8001b7ba:	853a                	mv	a0,a4
    8001b7bc:	94afa0ef          	jal	ra,80015906 <mmu_translate>
    8001b7c0:	fca43c23          	sd	a0,-40(s0)
    unsigned long trans_trampoline_trap  = mmu_translate(kernel_mmu_table, trampoline_trap_start);
    8001b7c4:	0000a797          	auipc	a5,0xa
    8001b7c8:	84478793          	addi	a5,a5,-1980 # 80025008 <kernel_mmu_table>
    8001b7cc:	6398                	ld	a4,0(a5)
    8001b7ce:	0000e797          	auipc	a5,0xe
    8001b7d2:	09378793          	addi	a5,a5,147 # 80029861 <trampoline_trap_start>
    8001b7d6:	639c                	ld	a5,0(a5)
    8001b7d8:	85be                	mv	a1,a5
    8001b7da:	853a                	mv	a0,a4
    8001b7dc:	92afa0ef          	jal	ra,80015906 <mmu_translate>
    8001b7e0:	fca43823          	sd	a0,-48(s0)
    mmu_map(p->rcb.ptable, trampoline_thread_start, trans_trampoline_start, MMU_LEVEL_4K,
    8001b7e4:	fe043783          	ld	a5,-32(s0)
    8001b7e8:	3407b503          	ld	a0,832(a5)
    8001b7ec:	0000e797          	auipc	a5,0xe
    8001b7f0:	05d78793          	addi	a5,a5,93 # 80029849 <trampoline_thread_start>
    8001b7f4:	639c                	ld	a5,0(a5)
    8001b7f6:	4729                	li	a4,10
    8001b7f8:	4681                	li	a3,0
    8001b7fa:	fd843603          	ld	a2,-40(s0)
    8001b7fe:	85be                	mv	a1,a5
    8001b800:	eddf90ef          	jal	ra,800156dc <mmu_map>
            PB_READ | PB_EXECUTE);
    mmu_map(p->rcb.ptable, trampoline_trap_start, trans_trampoline_trap, MMU_LEVEL_4K,
    8001b804:	fe043783          	ld	a5,-32(s0)
    8001b808:	3407b503          	ld	a0,832(a5)
    8001b80c:	0000e797          	auipc	a5,0xe
    8001b810:	05578793          	addi	a5,a5,85 # 80029861 <trampoline_trap_start>
    8001b814:	639c                	ld	a5,0(a5)
    8001b816:	4729                	li	a4,10
    8001b818:	4681                	li	a3,0
    8001b81a:	fd043603          	ld	a2,-48(s0)
    8001b81e:	85be                	mv	a1,a5
    8001b820:	ebdf90ef          	jal	ra,800156dc <mmu_map>
            PB_READ | PB_EXECUTE);

    // Map trap frame to user's page table
    uintptr_t trans_frame = kernel_mmu_translate((uintptr_t)&p->frame);
    8001b824:	fe043783          	ld	a5,-32(s0)
    8001b828:	07c1                	addi	a5,a5,16
    8001b82a:	853e                	mv	a0,a5
    8001b82c:	a58fa0ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001b830:	fca43423          	sd	a0,-56(s0)
    mmu_map(p->rcb.ptable, (uintptr_t)&p->frame, trans_frame, MMU_LEVEL_4K, PB_READ | PB_WRITE | PB_EXECUTE);
    8001b834:	fe043783          	ld	a5,-32(s0)
    8001b838:	3407b503          	ld	a0,832(a5)
    8001b83c:	fe043783          	ld	a5,-32(s0)
    8001b840:	07c1                	addi	a5,a5,16
    8001b842:	4739                	li	a4,14
    8001b844:	4681                	li	a3,0
    8001b846:	fc843603          	ld	a2,-56(s0)
    8001b84a:	85be                	mv	a1,a5
    8001b84c:	e91f90ef          	jal	ra,800156dc <mmu_map>

    SFENCE_ASID(p->pid);
    8001b850:	fe043783          	ld	a5,-32(s0)
    8001b854:	0007d783          	lhu	a5,0(a5)
    8001b858:	12f00073          	sfence.vma	zero,a5

    return p;
    8001b85c:	fe043783          	ld	a5,-32(s0)
}
    8001b860:	853e                	mv	a0,a5
    8001b862:	60a6                	ld	ra,72(sp)
    8001b864:	6406                	ld	s0,64(sp)
    8001b866:	6161                	addi	sp,sp,80
    8001b868:	8082                	ret

000000008001b86a <process_free>:

int process_free(Process *p)
{
    8001b86a:	7179                	addi	sp,sp,-48
    8001b86c:	f406                	sd	ra,40(sp)
    8001b86e:	f022                	sd	s0,32(sp)
    8001b870:	1800                	addi	s0,sp,48
    8001b872:	fca43c23          	sd	a0,-40(s0)
    struct ListElem *e;

    if (!p || !ON_HART_NONE(p)) {
    8001b876:	fd843783          	ld	a5,-40(s0)
    8001b87a:	cb81                	beqz	a5,8001b88a <process_free+0x20>
    8001b87c:	fd843783          	ld	a5,-40(s0)
    8001b880:	43dc                	lw	a5,4(a5)
    8001b882:	873e                	mv	a4,a5
    8001b884:	57fd                	li	a5,-1
    8001b886:	00f70463          	beq	a4,a5,8001b88e <process_free+0x24>
        // Process is invalid or running somewhere, or this is stale.
        return -1;
    8001b88a:	57fd                	li	a5,-1
    8001b88c:	a2e1                	j	8001ba54 <process_free+0x1ea>
    }

    // Free all resources allocated to the process.
    if (p->rcb.image_pages) {
    8001b88e:	fd843783          	ld	a5,-40(s0)
    8001b892:	3187b783          	ld	a5,792(a5)
    8001b896:	cbb9                	beqz	a5,8001b8ec <process_free+0x82>
        list_for_each(p->rcb.image_pages, e) {
    8001b898:	fd843783          	ld	a5,-40(s0)
    8001b89c:	3187b783          	ld	a5,792(a5)
    8001b8a0:	853e                	mv	a0,a5
    8001b8a2:	7b5040ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001b8a6:	fea43423          	sd	a0,-24(s0)
    8001b8aa:	a839                	j	8001b8c8 <process_free+0x5e>
            page_free(list_elem_value_ptr(e));
    8001b8ac:	fe843503          	ld	a0,-24(s0)
    8001b8b0:	006050ef          	jal	ra,800208b6 <list_elem_value>
    8001b8b4:	87aa                	mv	a5,a0
    8001b8b6:	853e                	mv	a0,a5
    8001b8b8:	76a020ef          	jal	ra,8001e022 <page_free>
        list_for_each(p->rcb.image_pages, e) {
    8001b8bc:	fe843503          	ld	a0,-24(s0)
    8001b8c0:	7df040ef          	jal	ra,8002089e <list_elem_prev>
    8001b8c4:	fea43423          	sd	a0,-24(s0)
    8001b8c8:	fd843783          	ld	a5,-40(s0)
    8001b8cc:	3187b783          	ld	a5,792(a5)
    8001b8d0:	fe843583          	ld	a1,-24(s0)
    8001b8d4:	853e                	mv	a0,a5
    8001b8d6:	6f3040ef          	jal	ra,800207c8 <list_elem_valid>
    8001b8da:	87aa                	mv	a5,a0
    8001b8dc:	fbe1                	bnez	a5,8001b8ac <process_free+0x42>
        }
        list_free(p->rcb.image_pages);
    8001b8de:	fd843783          	ld	a5,-40(s0)
    8001b8e2:	3187b783          	ld	a5,792(a5)
    8001b8e6:	853e                	mv	a0,a5
    8001b8e8:	689040ef          	jal	ra,80020770 <list_free>
    }

    if (p->rcb.stack_pages) {
    8001b8ec:	fd843783          	ld	a5,-40(s0)
    8001b8f0:	3207b783          	ld	a5,800(a5)
    8001b8f4:	cbb9                	beqz	a5,8001b94a <process_free+0xe0>
        list_for_each(p->rcb.stack_pages, e) {
    8001b8f6:	fd843783          	ld	a5,-40(s0)
    8001b8fa:	3207b783          	ld	a5,800(a5)
    8001b8fe:	853e                	mv	a0,a5
    8001b900:	757040ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001b904:	fea43423          	sd	a0,-24(s0)
    8001b908:	a839                	j	8001b926 <process_free+0xbc>
            page_free(list_elem_value_ptr(e));
    8001b90a:	fe843503          	ld	a0,-24(s0)
    8001b90e:	7a9040ef          	jal	ra,800208b6 <list_elem_value>
    8001b912:	87aa                	mv	a5,a0
    8001b914:	853e                	mv	a0,a5
    8001b916:	70c020ef          	jal	ra,8001e022 <page_free>
        list_for_each(p->rcb.stack_pages, e) {
    8001b91a:	fe843503          	ld	a0,-24(s0)
    8001b91e:	781040ef          	jal	ra,8002089e <list_elem_prev>
    8001b922:	fea43423          	sd	a0,-24(s0)
    8001b926:	fd843783          	ld	a5,-40(s0)
    8001b92a:	3207b783          	ld	a5,800(a5)
    8001b92e:	fe843583          	ld	a1,-24(s0)
    8001b932:	853e                	mv	a0,a5
    8001b934:	695040ef          	jal	ra,800207c8 <list_elem_valid>
    8001b938:	87aa                	mv	a5,a0
    8001b93a:	fbe1                	bnez	a5,8001b90a <process_free+0xa0>
        }
        list_free(p->rcb.stack_pages);
    8001b93c:	fd843783          	ld	a5,-40(s0)
    8001b940:	3207b783          	ld	a5,800(a5)
    8001b944:	853e                	mv	a0,a5
    8001b946:	62b040ef          	jal	ra,80020770 <list_free>
    }

    if (p->rcb.heap_pages) {
    8001b94a:	fd843783          	ld	a5,-40(s0)
    8001b94e:	3287b783          	ld	a5,808(a5)
    8001b952:	cbb9                	beqz	a5,8001b9a8 <process_free+0x13e>
        list_for_each(p->rcb.heap_pages, e) {
    8001b954:	fd843783          	ld	a5,-40(s0)
    8001b958:	3287b783          	ld	a5,808(a5)
    8001b95c:	853e                	mv	a0,a5
    8001b95e:	6f9040ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001b962:	fea43423          	sd	a0,-24(s0)
    8001b966:	a839                	j	8001b984 <process_free+0x11a>
            page_free(list_elem_value_ptr(e));
    8001b968:	fe843503          	ld	a0,-24(s0)
    8001b96c:	74b040ef          	jal	ra,800208b6 <list_elem_value>
    8001b970:	87aa                	mv	a5,a0
    8001b972:	853e                	mv	a0,a5
    8001b974:	6ae020ef          	jal	ra,8001e022 <page_free>
        list_for_each(p->rcb.heap_pages, e) {
    8001b978:	fe843503          	ld	a0,-24(s0)
    8001b97c:	723040ef          	jal	ra,8002089e <list_elem_prev>
    8001b980:	fea43423          	sd	a0,-24(s0)
    8001b984:	fd843783          	ld	a5,-40(s0)
    8001b988:	3287b783          	ld	a5,808(a5)
    8001b98c:	fe843583          	ld	a1,-24(s0)
    8001b990:	853e                	mv	a0,a5
    8001b992:	637040ef          	jal	ra,800207c8 <list_elem_valid>
    8001b996:	87aa                	mv	a5,a0
    8001b998:	fbe1                	bnez	a5,8001b968 <process_free+0xfe>
        }
        list_free(p->rcb.heap_pages);
    8001b99a:	fd843783          	ld	a5,-40(s0)
    8001b99e:	3287b783          	ld	a5,808(a5)
    8001b9a2:	853e                	mv	a0,a5
    8001b9a4:	5cd040ef          	jal	ra,80020770 <list_free>
    }

    if (p->rcb.file_descriptors) {
    8001b9a8:	fd843783          	ld	a5,-40(s0)
    8001b9ac:	3307b783          	ld	a5,816(a5)
    8001b9b0:	cbb9                	beqz	a5,8001ba06 <process_free+0x19c>
        list_for_each(p->rcb.file_descriptors, e) {
    8001b9b2:	fd843783          	ld	a5,-40(s0)
    8001b9b6:	3307b783          	ld	a5,816(a5)
    8001b9ba:	853e                	mv	a0,a5
    8001b9bc:	69b040ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001b9c0:	fea43423          	sd	a0,-24(s0)
    8001b9c4:	a839                	j	8001b9e2 <process_free+0x178>
            page_free(list_elem_value_ptr(e));
    8001b9c6:	fe843503          	ld	a0,-24(s0)
    8001b9ca:	6ed040ef          	jal	ra,800208b6 <list_elem_value>
    8001b9ce:	87aa                	mv	a5,a0
    8001b9d0:	853e                	mv	a0,a5
    8001b9d2:	650020ef          	jal	ra,8001e022 <page_free>
        list_for_each(p->rcb.file_descriptors, e) {
    8001b9d6:	fe843503          	ld	a0,-24(s0)
    8001b9da:	6c5040ef          	jal	ra,8002089e <list_elem_prev>
    8001b9de:	fea43423          	sd	a0,-24(s0)
    8001b9e2:	fd843783          	ld	a5,-40(s0)
    8001b9e6:	3307b783          	ld	a5,816(a5)
    8001b9ea:	fe843583          	ld	a1,-24(s0)
    8001b9ee:	853e                	mv	a0,a5
    8001b9f0:	5d9040ef          	jal	ra,800207c8 <list_elem_valid>
    8001b9f4:	87aa                	mv	a5,a0
    8001b9f6:	fbe1                	bnez	a5,8001b9c6 <process_free+0x15c>
        }
        list_free(p->rcb.file_descriptors);
    8001b9f8:	fd843783          	ld	a5,-40(s0)
    8001b9fc:	3307b783          	ld	a5,816(a5)
    8001ba00:	853e                	mv	a0,a5
    8001ba02:	56f040ef          	jal	ra,80020770 <list_free>
    }

    if (p->rcb.environemnt) {
    8001ba06:	fd843783          	ld	a5,-40(s0)
    8001ba0a:	3387b783          	ld	a5,824(a5)
    8001ba0e:	cf81                	beqz	a5,8001ba26 <process_free+0x1bc>
        map_free_get_keys(map_get_keys(p->rcb.environemnt));
    8001ba10:	fd843783          	ld	a5,-40(s0)
    8001ba14:	3387b783          	ld	a5,824(a5)
    8001ba18:	853e                	mv	a0,a5
    8001ba1a:	149050ef          	jal	ra,80021362 <map_get_keys>
    8001ba1e:	87aa                	mv	a5,a0
    8001ba20:	853e                	mv	a0,a5
    8001ba22:	1e7050ef          	jal	ra,80021408 <map_free_get_keys>
    }

    if (p->rcb.ptable) {
    8001ba26:	fd843783          	ld	a5,-40(s0)
    8001ba2a:	3407b783          	ld	a5,832(a5)
    8001ba2e:	cf91                	beqz	a5,8001ba4a <process_free+0x1e0>
        mmu_free(p->rcb.ptable);
    8001ba30:	fd843783          	ld	a5,-40(s0)
    8001ba34:	3407b783          	ld	a5,832(a5)
    8001ba38:	853e                	mv	a0,a5
    8001ba3a:	e47f90ef          	jal	ra,80015880 <mmu_free>
        SFENCE_ASID(p->pid);
    8001ba3e:	fd843783          	ld	a5,-40(s0)
    8001ba42:	0007d783          	lhu	a5,0(a5)
    8001ba46:	12f00073          	sfence.vma	zero,a5
    }

    kfree(p);
    8001ba4a:	fd843503          	ld	a0,-40(s0)
    8001ba4e:	b2df90ef          	jal	ra,8001557a <kfree>
    return 0;
    8001ba52:	4781                	li	a5,0
}
    8001ba54:	853e                	mv	a0,a5
    8001ba56:	70a2                	ld	ra,40(sp)
    8001ba58:	7402                	ld	s0,32(sp)
    8001ba5a:	6145                	addi	sp,sp,48
    8001ba5c:	8082                	ret

000000008001ba5e <process_run>:

bool process_run(Process *p, unsigned int hart)
{
    8001ba5e:	7179                	addi	sp,sp,-48
    8001ba60:	f406                	sd	ra,40(sp)
    8001ba62:	f022                	sd	s0,32(sp)
    8001ba64:	1800                	addi	s0,sp,48
    8001ba66:	fca43c23          	sd	a0,-40(s0)
    8001ba6a:	87ae                	mv	a5,a1
    8001ba6c:	fcf42a23          	sw	a5,-44(s0)
    void process_asm_run(void *frame_addr);
    unsigned int me = sbi_whoami();
    8001ba70:	724000ef          	jal	ra,8001c194 <sbi_whoami>
    8001ba74:	87aa                	mv	a5,a0
    8001ba76:	fef42623          	sw	a5,-20(s0)

    if (me == hart) {
    8001ba7a:	fec42703          	lw	a4,-20(s0)
    8001ba7e:	fd442783          	lw	a5,-44(s0)
    8001ba82:	2701                	sext.w	a4,a4
    8001ba84:	2781                	sext.w	a5,a5
    8001ba86:	02f71463          	bne	a4,a5,8001baae <process_run+0x50>
        pid_harts_map_set(hart, p->pid);
    8001ba8a:	fd843783          	ld	a5,-40(s0)
    8001ba8e:	0007d703          	lhu	a4,0(a5)
    8001ba92:	fd442783          	lw	a5,-44(s0)
    8001ba96:	85ba                	mv	a1,a4
    8001ba98:	853e                	mv	a0,a5
    8001ba9a:	102000ef          	jal	ra,8001bb9c <pid_harts_map_set>
        process_asm_run(&p->frame);
    8001ba9e:	fd843783          	ld	a5,-40(s0)
    8001baa2:	07c1                	addi	a5,a5,16
    8001baa4:	853e                	mv	a0,a5
    8001baa6:	01f040ef          	jal	ra,800202c4 <process_asm_run>
        // process_asm_run should not return, but if it does
        // something went wrong.
        return false;
    8001baaa:	4781                	li	a5,0
    8001baac:	a80d                	j	8001bade <process_run+0x80>
    }

    return sbi_hart_start(hart, trampoline_thread_start, (unsigned long)&p->frame, p->frame.satp);
    8001baae:	0000e797          	auipc	a5,0xe
    8001bab2:	d9b78793          	addi	a5,a5,-613 # 80029849 <trampoline_thread_start>
    8001bab6:	6398                	ld	a4,0(a5)
    8001bab8:	fd843783          	ld	a5,-40(s0)
    8001babc:	07c1                	addi	a5,a5,16
    8001babe:	863e                	mv	a2,a5
    8001bac0:	fd843783          	ld	a5,-40(s0)
    8001bac4:	2287b683          	ld	a3,552(a5)
    8001bac8:	fd442783          	lw	a5,-44(s0)
    8001bacc:	85ba                	mv	a1,a4
    8001bace:	853e                	mv	a0,a5
    8001bad0:	59c000ef          	jal	ra,8001c06c <sbi_hart_start>
    8001bad4:	87aa                	mv	a5,a0
    8001bad6:	00f037b3          	snez	a5,a5
    8001bada:	0ff7f793          	andi	a5,a5,255
}
    8001bade:	853e                	mv	a0,a5
    8001bae0:	70a2                	ld	ra,40(sp)
    8001bae2:	7402                	ld	s0,32(sp)
    8001bae4:	6145                	addi	sp,sp,48
    8001bae6:	8082                	ret

000000008001bae8 <process_map_init>:
static Map *processes;

// Initialize the processes map, needs to be called before creating the
// first process.
void process_map_init()
{
    8001bae8:	1141                	addi	sp,sp,-16
    8001baea:	e406                	sd	ra,8(sp)
    8001baec:	e022                	sd	s0,0(sp)
    8001baee:	0800                	addi	s0,sp,16
    processes = map_new();
    8001baf0:	416050ef          	jal	ra,80020f06 <map_new>
    8001baf4:	872a                	mv	a4,a0
    8001baf6:	00009797          	auipc	a5,0x9
    8001bafa:	64a78793          	addi	a5,a5,1610 # 80025140 <processes>
    8001bafe:	e398                	sd	a4,0(a5)
}
    8001bb00:	0001                	nop
    8001bb02:	60a2                	ld	ra,8(sp)
    8001bb04:	6402                	ld	s0,0(sp)
    8001bb06:	0141                	addi	sp,sp,16
    8001bb08:	8082                	ret

000000008001bb0a <process_map_set>:

// Store a process on a map as its PID as the key.
void process_map_set(Process *p)
{
    8001bb0a:	1101                	addi	sp,sp,-32
    8001bb0c:	ec06                	sd	ra,24(sp)
    8001bb0e:	e822                	sd	s0,16(sp)
    8001bb10:	1000                	addi	s0,sp,32
    8001bb12:	fea43423          	sd	a0,-24(s0)
    map_set_int(processes, p->pid, (MapValue)p);
    8001bb16:	00009797          	auipc	a5,0x9
    8001bb1a:	62a78793          	addi	a5,a5,1578 # 80025140 <processes>
    8001bb1e:	6398                	ld	a4,0(a5)
    8001bb20:	fe843783          	ld	a5,-24(s0)
    8001bb24:	0007d783          	lhu	a5,0(a5)
    8001bb28:	86be                	mv	a3,a5
    8001bb2a:	fe843783          	ld	a5,-24(s0)
    8001bb2e:	863e                	mv	a2,a5
    8001bb30:	85b6                	mv	a1,a3
    8001bb32:	853a                	mv	a0,a4
    8001bb34:	4aa050ef          	jal	ra,80020fde <map_set_int>
}
    8001bb38:	0001                	nop
    8001bb3a:	60e2                	ld	ra,24(sp)
    8001bb3c:	6442                	ld	s0,16(sp)
    8001bb3e:	6105                	addi	sp,sp,32
    8001bb40:	8082                	ret

000000008001bb42 <process_map_get>:

// Get process stored on the process map using the PID as the key.
Process *process_map_get(uint16_t pid) 
{
    8001bb42:	7179                	addi	sp,sp,-48
    8001bb44:	f406                	sd	ra,40(sp)
    8001bb46:	f022                	sd	s0,32(sp)
    8001bb48:	1800                	addi	s0,sp,48
    8001bb4a:	87aa                	mv	a5,a0
    8001bb4c:	fcf41f23          	sh	a5,-34(s0)
    MapValue val;
    map_get_int(processes, pid, &val);
    8001bb50:	00009797          	auipc	a5,0x9
    8001bb54:	5f078793          	addi	a5,a5,1520 # 80025140 <processes>
    8001bb58:	639c                	ld	a5,0(a5)
    8001bb5a:	fde45703          	lhu	a4,-34(s0)
    8001bb5e:	fe840693          	addi	a3,s0,-24
    8001bb62:	8636                	mv	a2,a3
    8001bb64:	85ba                	mv	a1,a4
    8001bb66:	853e                	mv	a0,a5
    8001bb68:	532050ef          	jal	ra,8002109a <map_get_int>
    return (Process *)val;
    8001bb6c:	fe843783          	ld	a5,-24(s0)
}
    8001bb70:	853e                	mv	a0,a5
    8001bb72:	70a2                	ld	ra,40(sp)
    8001bb74:	7402                	ld	s0,32(sp)
    8001bb76:	6145                	addi	sp,sp,48
    8001bb78:	8082                	ret

000000008001bb7a <pid_harts_map_init>:
static Map *pid_on_harts;

// Initialize the PID on harts map, needs to be called before creating the
// first process.
void pid_harts_map_init()
{
    8001bb7a:	1141                	addi	sp,sp,-16
    8001bb7c:	e406                	sd	ra,8(sp)
    8001bb7e:	e022                	sd	s0,0(sp)
    8001bb80:	0800                	addi	s0,sp,16
    pid_on_harts = map_new();
    8001bb82:	384050ef          	jal	ra,80020f06 <map_new>
    8001bb86:	872a                	mv	a4,a0
    8001bb88:	00009797          	auipc	a5,0x9
    8001bb8c:	5c078793          	addi	a5,a5,1472 # 80025148 <pid_on_harts>
    8001bb90:	e398                	sd	a4,0(a5)
}
    8001bb92:	0001                	nop
    8001bb94:	60a2                	ld	ra,8(sp)
    8001bb96:	6402                	ld	s0,0(sp)
    8001bb98:	0141                	addi	sp,sp,16
    8001bb9a:	8082                	ret

000000008001bb9c <pid_harts_map_set>:

// Associate the PID running to hart
void pid_harts_map_set(uint32_t hart, uint16_t pid)
{
    8001bb9c:	1101                	addi	sp,sp,-32
    8001bb9e:	ec06                	sd	ra,24(sp)
    8001bba0:	e822                	sd	s0,16(sp)
    8001bba2:	1000                	addi	s0,sp,32
    8001bba4:	87aa                	mv	a5,a0
    8001bba6:	872e                	mv	a4,a1
    8001bba8:	fef42623          	sw	a5,-20(s0)
    8001bbac:	87ba                	mv	a5,a4
    8001bbae:	fef41523          	sh	a5,-22(s0)
    if (hart > MAX_NUM_HARTS - 1)
    8001bbb2:	fec42783          	lw	a5,-20(s0)
    8001bbb6:	0007871b          	sext.w	a4,a5
    8001bbba:	479d                	li	a5,7
    8001bbbc:	00e7f863          	bgeu	a5,a4,8001bbcc <pid_harts_map_set+0x30>
        fatalf("set_pid_on_hart: Invalid hart number\n");
    8001bbc0:	0000d517          	auipc	a0,0xd
    8001bbc4:	aa850513          	addi	a0,a0,-1368 # 80028668 <pow10.0+0x1808>
    8001bbc8:	374000ef          	jal	ra,8001bf3c <fatalf>
    map_set_int(pid_on_harts, hart, pid);
    8001bbcc:	00009797          	auipc	a5,0x9
    8001bbd0:	57c78793          	addi	a5,a5,1404 # 80025148 <pid_on_harts>
    8001bbd4:	639c                	ld	a5,0(a5)
    8001bbd6:	fec46703          	lwu	a4,-20(s0)
    8001bbda:	fea45683          	lhu	a3,-22(s0)
    8001bbde:	8636                	mv	a2,a3
    8001bbe0:	85ba                	mv	a1,a4
    8001bbe2:	853e                	mv	a0,a5
    8001bbe4:	3fa050ef          	jal	ra,80020fde <map_set_int>
}
    8001bbe8:	0001                	nop
    8001bbea:	60e2                	ld	ra,24(sp)
    8001bbec:	6442                	ld	s0,16(sp)
    8001bbee:	6105                	addi	sp,sp,32
    8001bbf0:	8082                	ret

000000008001bbf2 <pid_harts_map_get>:

// Get the PID running on hart
uint16_t pid_harts_map_get(uint32_t hart)
{
    8001bbf2:	7179                	addi	sp,sp,-48
    8001bbf4:	f406                	sd	ra,40(sp)
    8001bbf6:	f022                	sd	s0,32(sp)
    8001bbf8:	1800                	addi	s0,sp,48
    8001bbfa:	87aa                	mv	a5,a0
    8001bbfc:	fcf42e23          	sw	a5,-36(s0)
    if (hart > MAX_NUM_HARTS - 1)
    8001bc00:	fdc42783          	lw	a5,-36(s0)
    8001bc04:	0007871b          	sext.w	a4,a5
    8001bc08:	479d                	li	a5,7
    8001bc0a:	00e7f863          	bgeu	a5,a4,8001bc1a <pid_harts_map_get+0x28>
        fatalf("get_pid_on_hart: Invalid hart number\n");
    8001bc0e:	0000d517          	auipc	a0,0xd
    8001bc12:	a8250513          	addi	a0,a0,-1406 # 80028690 <pow10.0+0x1830>
    8001bc16:	326000ef          	jal	ra,8001bf3c <fatalf>
    MapValue val;
    map_get_int(pid_on_harts, hart, &val);
    8001bc1a:	00009797          	auipc	a5,0x9
    8001bc1e:	52e78793          	addi	a5,a5,1326 # 80025148 <pid_on_harts>
    8001bc22:	639c                	ld	a5,0(a5)
    8001bc24:	fdc46703          	lwu	a4,-36(s0)
    8001bc28:	fe840693          	addi	a3,s0,-24
    8001bc2c:	8636                	mv	a2,a3
    8001bc2e:	85ba                	mv	a1,a4
    8001bc30:	853e                	mv	a0,a5
    8001bc32:	468050ef          	jal	ra,8002109a <map_get_int>
    return (uint16_t)val;
    8001bc36:	fe843783          	ld	a5,-24(s0)
    8001bc3a:	17c2                	slli	a5,a5,0x30
    8001bc3c:	93c1                	srli	a5,a5,0x30
}
    8001bc3e:	853e                	mv	a0,a5
    8001bc40:	70a2                	ld	ra,40(sp)
    8001bc42:	7402                	ld	s0,32(sp)
    8001bc44:	6145                	addi	sp,sp,48
    8001bc46:	8082                	ret

000000008001bc48 <lgprefix>:

static bool last_was_newline = true;

static int k_log_level = 0xFFF;

static const char *lgprefix(log_type lt) {
    8001bc48:	1101                	addi	sp,sp,-32
    8001bc4a:	ec22                	sd	s0,24(sp)
    8001bc4c:	1000                	addi	s0,sp,32
    8001bc4e:	87aa                	mv	a5,a0
    8001bc50:	fef42623          	sw	a5,-20(s0)
    8001bc54:	fec42783          	lw	a5,-20(s0)
    8001bc58:	0007871b          	sext.w	a4,a5
    8001bc5c:	47c1                	li	a5,16
    8001bc5e:	04e7ed63          	bltu	a5,a4,8001bcb8 <lgprefix+0x70>
    8001bc62:	fec46783          	lwu	a5,-20(s0)
    8001bc66:	00279713          	slli	a4,a5,0x2
    8001bc6a:	0000d797          	auipc	a5,0xd
    8001bc6e:	aa278793          	addi	a5,a5,-1374 # 8002870c <pow10.0+0x18ac>
    8001bc72:	97ba                	add	a5,a5,a4
    8001bc74:	439c                	lw	a5,0(a5)
    8001bc76:	0007871b          	sext.w	a4,a5
    8001bc7a:	0000d797          	auipc	a5,0xd
    8001bc7e:	a9278793          	addi	a5,a5,-1390 # 8002870c <pow10.0+0x18ac>
    8001bc82:	97ba                	add	a5,a5,a4
    8001bc84:	8782                	jr	a5
    switch (lt) {
        case LOG_DEBUG:
            return "[DEBUG]: ";
    8001bc86:	0000d797          	auipc	a5,0xd
    8001bc8a:	a3278793          	addi	a5,a5,-1486 # 800286b8 <pow10.0+0x1858>
    8001bc8e:	a80d                	j	8001bcc0 <lgprefix+0x78>
        case LOG_INFO:
            return "[INFO]: ";
    8001bc90:	0000d797          	auipc	a5,0xd
    8001bc94:	a3878793          	addi	a5,a5,-1480 # 800286c8 <pow10.0+0x1868>
    8001bc98:	a025                	j	8001bcc0 <lgprefix+0x78>
        case LOG_WARN:
            return "[WARN]: ";
    8001bc9a:	0000d797          	auipc	a5,0xd
    8001bc9e:	a3e78793          	addi	a5,a5,-1474 # 800286d8 <pow10.0+0x1878>
    8001bca2:	a839                	j	8001bcc0 <lgprefix+0x78>
        case LOG_ERROR:
            return "[ERROR]: ";
    8001bca4:	0000d797          	auipc	a5,0xd
    8001bca8:	a4478793          	addi	a5,a5,-1468 # 800286e8 <pow10.0+0x1888>
    8001bcac:	a811                	j	8001bcc0 <lgprefix+0x78>
        case LOG_FATAL:
            return "[FATAL]: ";
    8001bcae:	0000d797          	auipc	a5,0xd
    8001bcb2:	a4a78793          	addi	a5,a5,-1462 # 800286f8 <pow10.0+0x1898>
    8001bcb6:	a029                	j	8001bcc0 <lgprefix+0x78>
        default:
            return "";
    8001bcb8:	0000d797          	auipc	a5,0xd
    8001bcbc:	a5078793          	addi	a5,a5,-1456 # 80028708 <pow10.0+0x18a8>
    }
}
    8001bcc0:	853e                	mv	a0,a5
    8001bcc2:	6462                	ld	s0,24(sp)
    8001bcc4:	6105                	addi	sp,sp,32
    8001bcc6:	8082                	ret

000000008001bcc8 <vlogf>:

static int vlogf(log_type lt, const char *fmt, va_list args)
{
    8001bcc8:	7139                	addi	sp,sp,-64
    8001bcca:	fc06                	sd	ra,56(sp)
    8001bccc:	f822                	sd	s0,48(sp)
    8001bcce:	0080                	addi	s0,sp,64
    8001bcd0:	87aa                	mv	a5,a0
    8001bcd2:	fcb43823          	sd	a1,-48(s0)
    8001bcd6:	fcc43423          	sd	a2,-56(s0)
    8001bcda:	fcf42e23          	sw	a5,-36(s0)
    if (!(lt & k_log_level)) {
    8001bcde:	0000e797          	auipc	a5,0xe
    8001bce2:	32a78793          	addi	a5,a5,810 # 8002a008 <k_log_level>
    8001bce6:	439c                	lw	a5,0(a5)
    8001bce8:	0007871b          	sext.w	a4,a5
    8001bcec:	fdc42783          	lw	a5,-36(s0)
    8001bcf0:	8ff9                	and	a5,a5,a4
    8001bcf2:	2781                	sext.w	a5,a5
    8001bcf4:	e399                	bnez	a5,8001bcfa <vlogf+0x32>
        return 0;
    8001bcf6:	4781                	li	a5,0
    8001bcf8:	a049                	j	8001bd7a <vlogf+0xb2>
    }
    int printf(const char *fmt, ...);
    if (last_was_newline) {
    8001bcfa:	0000e797          	auipc	a5,0xe
    8001bcfe:	30a78793          	addi	a5,a5,778 # 8002a004 <last_was_newline>
    8001bd02:	0007c783          	lbu	a5,0(a5)
    8001bd06:	cf91                	beqz	a5,8001bd22 <vlogf+0x5a>
        printf("%s", lgprefix(lt));
    8001bd08:	fdc42783          	lw	a5,-36(s0)
    8001bd0c:	853e                	mv	a0,a5
    8001bd0e:	f3bff0ef          	jal	ra,8001bc48 <lgprefix>
    8001bd12:	87aa                	mv	a5,a0
    8001bd14:	85be                	mv	a1,a5
    8001bd16:	0000d517          	auipc	a0,0xd
    8001bd1a:	a3a50513          	addi	a0,a0,-1478 # 80028750 <pow10.0+0x18f0>
    8001bd1e:	dabf70ef          	jal	ra,80013ac8 <printf>
    }
    for (const char *p = fmt; *p != '\0'; p++) {
    8001bd22:	fd043783          	ld	a5,-48(s0)
    8001bd26:	fef43423          	sd	a5,-24(s0)
    8001bd2a:	a825                	j	8001bd62 <vlogf+0x9a>
        if (*p == '\n') {
    8001bd2c:	fe843783          	ld	a5,-24(s0)
    8001bd30:	0007c783          	lbu	a5,0(a5)
    8001bd34:	873e                	mv	a4,a5
    8001bd36:	47a9                	li	a5,10
    8001bd38:	00f71a63          	bne	a4,a5,8001bd4c <vlogf+0x84>
            last_was_newline = true;
    8001bd3c:	0000e797          	auipc	a5,0xe
    8001bd40:	2c878793          	addi	a5,a5,712 # 8002a004 <last_was_newline>
    8001bd44:	4705                	li	a4,1
    8001bd46:	00e78023          	sb	a4,0(a5)
    8001bd4a:	a039                	j	8001bd58 <vlogf+0x90>
        } else {
            last_was_newline = false;
    8001bd4c:	0000e797          	auipc	a5,0xe
    8001bd50:	2b878793          	addi	a5,a5,696 # 8002a004 <last_was_newline>
    8001bd54:	00078023          	sb	zero,0(a5)
    for (const char *p = fmt; *p != '\0'; p++) {
    8001bd58:	fe843783          	ld	a5,-24(s0)
    8001bd5c:	0785                	addi	a5,a5,1
    8001bd5e:	fef43423          	sd	a5,-24(s0)
    8001bd62:	fe843783          	ld	a5,-24(s0)
    8001bd66:	0007c783          	lbu	a5,0(a5)
    8001bd6a:	f3e9                	bnez	a5,8001bd2c <vlogf+0x64>
        }
    }
    int vprintf_(const char *format, va_list va);
    return vprintf_(fmt, args);
    8001bd6c:	fc843583          	ld	a1,-56(s0)
    8001bd70:	fd043503          	ld	a0,-48(s0)
    8001bd74:	e83f70ef          	jal	ra,80013bf6 <vprintf_>
    8001bd78:	87aa                	mv	a5,a0
}
    8001bd7a:	853e                	mv	a0,a5
    8001bd7c:	70e2                	ld	ra,56(sp)
    8001bd7e:	7442                	ld	s0,48(sp)
    8001bd80:	6121                	addi	sp,sp,64
    8001bd82:	8082                	ret

000000008001bd84 <logf>:

int logf(log_type lt, const char *fmt, ...)
{
    8001bd84:	7159                	addi	sp,sp,-112
    8001bd86:	fc06                	sd	ra,56(sp)
    8001bd88:	f822                	sd	s0,48(sp)
    8001bd8a:	0080                	addi	s0,sp,64
    8001bd8c:	fcb43823          	sd	a1,-48(s0)
    8001bd90:	e010                	sd	a2,0(s0)
    8001bd92:	e414                	sd	a3,8(s0)
    8001bd94:	e818                	sd	a4,16(s0)
    8001bd96:	ec1c                	sd	a5,24(s0)
    8001bd98:	03043023          	sd	a6,32(s0)
    8001bd9c:	03143423          	sd	a7,40(s0)
    8001bda0:	87aa                	mv	a5,a0
    8001bda2:	fcf42e23          	sw	a5,-36(s0)
    va_list va;
    va_start(va, fmt);
    8001bda6:	03040793          	addi	a5,s0,48
    8001bdaa:	fcf43423          	sd	a5,-56(s0)
    8001bdae:	fc843783          	ld	a5,-56(s0)
    8001bdb2:	fd078793          	addi	a5,a5,-48
    8001bdb6:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(lt, fmt, va);
    8001bdba:	fe043703          	ld	a4,-32(s0)
    8001bdbe:	fdc42783          	lw	a5,-36(s0)
    8001bdc2:	863a                	mv	a2,a4
    8001bdc4:	fd043583          	ld	a1,-48(s0)
    8001bdc8:	853e                	mv	a0,a5
    8001bdca:	effff0ef          	jal	ra,8001bcc8 <vlogf>
    8001bdce:	87aa                	mv	a5,a0
    8001bdd0:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001bdd4:	fec42783          	lw	a5,-20(s0)
}
    8001bdd8:	853e                	mv	a0,a5
    8001bdda:	70e2                	ld	ra,56(sp)
    8001bddc:	7442                	ld	s0,48(sp)
    8001bdde:	6165                	addi	sp,sp,112
    8001bde0:	8082                	ret

000000008001bde2 <debugf>:

int debugf(const char *fmt, ...)
{
    8001bde2:	7159                	addi	sp,sp,-112
    8001bde4:	f406                	sd	ra,40(sp)
    8001bde6:	f022                	sd	s0,32(sp)
    8001bde8:	1800                	addi	s0,sp,48
    8001bdea:	fca43c23          	sd	a0,-40(s0)
    8001bdee:	e40c                	sd	a1,8(s0)
    8001bdf0:	e810                	sd	a2,16(s0)
    8001bdf2:	ec14                	sd	a3,24(s0)
    8001bdf4:	f018                	sd	a4,32(s0)
    8001bdf6:	f41c                	sd	a5,40(s0)
    8001bdf8:	03043823          	sd	a6,48(s0)
    8001bdfc:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001be00:	04040793          	addi	a5,s0,64
    8001be04:	fcf43823          	sd	a5,-48(s0)
    8001be08:	fd043783          	ld	a5,-48(s0)
    8001be0c:	fc878793          	addi	a5,a5,-56
    8001be10:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_DEBUG, fmt, va);
    8001be14:	fe043783          	ld	a5,-32(s0)
    8001be18:	863e                	mv	a2,a5
    8001be1a:	fd843583          	ld	a1,-40(s0)
    8001be1e:	4509                	li	a0,2
    8001be20:	ea9ff0ef          	jal	ra,8001bcc8 <vlogf>
    8001be24:	87aa                	mv	a5,a0
    8001be26:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001be2a:	fec42783          	lw	a5,-20(s0)
}
    8001be2e:	853e                	mv	a0,a5
    8001be30:	70a2                	ld	ra,40(sp)
    8001be32:	7402                	ld	s0,32(sp)
    8001be34:	6165                	addi	sp,sp,112
    8001be36:	8082                	ret

000000008001be38 <warnf>:

int warnf(const char *fmt, ...)
{
    8001be38:	7159                	addi	sp,sp,-112
    8001be3a:	f406                	sd	ra,40(sp)
    8001be3c:	f022                	sd	s0,32(sp)
    8001be3e:	1800                	addi	s0,sp,48
    8001be40:	fca43c23          	sd	a0,-40(s0)
    8001be44:	e40c                	sd	a1,8(s0)
    8001be46:	e810                	sd	a2,16(s0)
    8001be48:	ec14                	sd	a3,24(s0)
    8001be4a:	f018                	sd	a4,32(s0)
    8001be4c:	f41c                	sd	a5,40(s0)
    8001be4e:	03043823          	sd	a6,48(s0)
    8001be52:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001be56:	04040793          	addi	a5,s0,64
    8001be5a:	fcf43823          	sd	a5,-48(s0)
    8001be5e:	fd043783          	ld	a5,-48(s0)
    8001be62:	fc878793          	addi	a5,a5,-56
    8001be66:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_WARN, fmt, va);
    8001be6a:	fe043783          	ld	a5,-32(s0)
    8001be6e:	863e                	mv	a2,a5
    8001be70:	fd843583          	ld	a1,-40(s0)
    8001be74:	4541                	li	a0,16
    8001be76:	e53ff0ef          	jal	ra,8001bcc8 <vlogf>
    8001be7a:	87aa                	mv	a5,a0
    8001be7c:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001be80:	fec42783          	lw	a5,-20(s0)
}
    8001be84:	853e                	mv	a0,a5
    8001be86:	70a2                	ld	ra,40(sp)
    8001be88:	7402                	ld	s0,32(sp)
    8001be8a:	6165                	addi	sp,sp,112
    8001be8c:	8082                	ret

000000008001be8e <textf>:

int textf(const char *fmt, ...)
{
    8001be8e:	7159                	addi	sp,sp,-112
    8001be90:	f406                	sd	ra,40(sp)
    8001be92:	f022                	sd	s0,32(sp)
    8001be94:	1800                	addi	s0,sp,48
    8001be96:	fca43c23          	sd	a0,-40(s0)
    8001be9a:	e40c                	sd	a1,8(s0)
    8001be9c:	e810                	sd	a2,16(s0)
    8001be9e:	ec14                	sd	a3,24(s0)
    8001bea0:	f018                	sd	a4,32(s0)
    8001bea2:	f41c                	sd	a5,40(s0)
    8001bea4:	03043823          	sd	a6,48(s0)
    8001bea8:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001beac:	04040793          	addi	a5,s0,64
    8001beb0:	fcf43823          	sd	a5,-48(s0)
    8001beb4:	fd043783          	ld	a5,-48(s0)
    8001beb8:	fc878793          	addi	a5,a5,-56
    8001bebc:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_TEXT, fmt, va);
    8001bec0:	fe043783          	ld	a5,-32(s0)
    8001bec4:	863e                	mv	a2,a5
    8001bec6:	fd843583          	ld	a1,-40(s0)
    8001beca:	02000513          	li	a0,32
    8001bece:	dfbff0ef          	jal	ra,8001bcc8 <vlogf>
    8001bed2:	87aa                	mv	a5,a0
    8001bed4:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001bed8:	fec42783          	lw	a5,-20(s0)
}
    8001bedc:	853e                	mv	a0,a5
    8001bede:	70a2                	ld	ra,40(sp)
    8001bee0:	7402                	ld	s0,32(sp)
    8001bee2:	6165                	addi	sp,sp,112
    8001bee4:	8082                	ret

000000008001bee6 <infof>:

int infof(const char *fmt, ...)
{
    8001bee6:	7159                	addi	sp,sp,-112
    8001bee8:	f406                	sd	ra,40(sp)
    8001beea:	f022                	sd	s0,32(sp)
    8001beec:	1800                	addi	s0,sp,48
    8001beee:	fca43c23          	sd	a0,-40(s0)
    8001bef2:	e40c                	sd	a1,8(s0)
    8001bef4:	e810                	sd	a2,16(s0)
    8001bef6:	ec14                	sd	a3,24(s0)
    8001bef8:	f018                	sd	a4,32(s0)
    8001befa:	f41c                	sd	a5,40(s0)
    8001befc:	03043823          	sd	a6,48(s0)
    8001bf00:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001bf04:	04040793          	addi	a5,s0,64
    8001bf08:	fcf43823          	sd	a5,-48(s0)
    8001bf0c:	fd043783          	ld	a5,-48(s0)
    8001bf10:	fc878793          	addi	a5,a5,-56
    8001bf14:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(LOG_INFO, fmt, va);
    8001bf18:	fe043783          	ld	a5,-32(s0)
    8001bf1c:	863e                	mv	a2,a5
    8001bf1e:	fd843583          	ld	a1,-40(s0)
    8001bf22:	4511                	li	a0,4
    8001bf24:	da5ff0ef          	jal	ra,8001bcc8 <vlogf>
    8001bf28:	87aa                	mv	a5,a0
    8001bf2a:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    8001bf2e:	fec42783          	lw	a5,-20(s0)
}
    8001bf32:	853e                	mv	a0,a5
    8001bf34:	70a2                	ld	ra,40(sp)
    8001bf36:	7402                	ld	s0,32(sp)
    8001bf38:	6165                	addi	sp,sp,112
    8001bf3a:	8082                	ret

000000008001bf3c <fatalf>:

ATTR_NORET void fatalf(const char *fmt, ...)
{
    8001bf3c:	7159                	addi	sp,sp,-112
    8001bf3e:	f406                	sd	ra,40(sp)
    8001bf40:	f022                	sd	s0,32(sp)
    8001bf42:	1800                	addi	s0,sp,48
    8001bf44:	fca43c23          	sd	a0,-40(s0)
    8001bf48:	e40c                	sd	a1,8(s0)
    8001bf4a:	e810                	sd	a2,16(s0)
    8001bf4c:	ec14                	sd	a3,24(s0)
    8001bf4e:	f018                	sd	a4,32(s0)
    8001bf50:	f41c                	sd	a5,40(s0)
    8001bf52:	03043823          	sd	a6,48(s0)
    8001bf56:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, fmt);
    8001bf5a:	04040793          	addi	a5,s0,64
    8001bf5e:	fcf43823          	sd	a5,-48(s0)
    8001bf62:	fd043783          	ld	a5,-48(s0)
    8001bf66:	fc878793          	addi	a5,a5,-56
    8001bf6a:	fef43423          	sd	a5,-24(s0)
    vlogf(LOG_FATAL, fmt, va);
    8001bf6e:	fe843783          	ld	a5,-24(s0)
    8001bf72:	863e                	mv	a2,a5
    8001bf74:	fd843583          	ld	a1,-40(s0)
    8001bf78:	4521                	li	a0,8
    8001bf7a:	d4fff0ef          	jal	ra,8001bcc8 <vlogf>
    va_end(va);

    CSR_CLEAR("sstatus");
    8001bf7e:	10001073          	csrw	sstatus,zero
    WFI_LOOP();
    8001bf82:	10500073          	wfi
    8001bf86:	bff5                	j	8001bf82 <fatalf+0x46>

000000008001bf88 <klogset>:
}

void klogset(log_type lt)
{
    8001bf88:	1101                	addi	sp,sp,-32
    8001bf8a:	ec22                	sd	s0,24(sp)
    8001bf8c:	1000                	addi	s0,sp,32
    8001bf8e:	87aa                	mv	a5,a0
    8001bf90:	fef42623          	sw	a5,-20(s0)
    k_log_level |= lt;
    8001bf94:	0000e797          	auipc	a5,0xe
    8001bf98:	07478793          	addi	a5,a5,116 # 8002a008 <k_log_level>
    8001bf9c:	439c                	lw	a5,0(a5)
    8001bf9e:	0007871b          	sext.w	a4,a5
    8001bfa2:	fec42783          	lw	a5,-20(s0)
    8001bfa6:	8fd9                	or	a5,a5,a4
    8001bfa8:	2781                	sext.w	a5,a5
    8001bfaa:	0007871b          	sext.w	a4,a5
    8001bfae:	0000e797          	auipc	a5,0xe
    8001bfb2:	05a78793          	addi	a5,a5,90 # 8002a008 <k_log_level>
    8001bfb6:	c398                	sw	a4,0(a5)
}
    8001bfb8:	0001                	nop
    8001bfba:	6462                	ld	s0,24(sp)
    8001bfbc:	6105                	addi	sp,sp,32
    8001bfbe:	8082                	ret

000000008001bfc0 <klogclear>:

void klogclear(log_type lt)
{
    8001bfc0:	1101                	addi	sp,sp,-32
    8001bfc2:	ec22                	sd	s0,24(sp)
    8001bfc4:	1000                	addi	s0,sp,32
    8001bfc6:	87aa                	mv	a5,a0
    8001bfc8:	fef42623          	sw	a5,-20(s0)
    k_log_level &= ~lt;
    8001bfcc:	fec42783          	lw	a5,-20(s0)
    8001bfd0:	fff7c793          	not	a5,a5
    8001bfd4:	0007871b          	sext.w	a4,a5
    8001bfd8:	0000e797          	auipc	a5,0xe
    8001bfdc:	03078793          	addi	a5,a5,48 # 8002a008 <k_log_level>
    8001bfe0:	439c                	lw	a5,0(a5)
    8001bfe2:	2781                	sext.w	a5,a5
    8001bfe4:	8ff9                	and	a5,a5,a4
    8001bfe6:	2781                	sext.w	a5,a5
    8001bfe8:	0007871b          	sext.w	a4,a5
    8001bfec:	0000e797          	auipc	a5,0xe
    8001bff0:	01c78793          	addi	a5,a5,28 # 8002a008 <k_log_level>
    8001bff4:	c398                	sw	a4,0(a5)
    8001bff6:	0001                	nop
    8001bff8:	6462                	ld	s0,24(sp)
    8001bffa:	6105                	addi	sp,sp,32
    8001bffc:	8082                	ret

000000008001bffe <sbi_putchar>:
#include <compiler.h>
#include <config.h>
#include <sbi.h>

void sbi_putchar(char c)
{
    8001bffe:	1101                	addi	sp,sp,-32
    8001c000:	ec22                	sd	s0,24(sp)
    8001c002:	1000                	addi	s0,sp,32
    8001c004:	87aa                	mv	a5,a0
    8001c006:	fef407a3          	sb	a5,-17(s0)
    asm volatile("mv a7, %0\nmv a0, %1\necall" ::"r"(SBI_SVCALL_PUTCHAR), "r"(c) : "a7", "a0");
    8001c00a:	47a5                	li	a5,9
    8001c00c:	fef44703          	lbu	a4,-17(s0)
    8001c010:	88be                	mv	a7,a5
    8001c012:	853a                	mv	a0,a4
    8001c014:	00000073          	ecall
}
    8001c018:	0001                	nop
    8001c01a:	6462                	ld	s0,24(sp)
    8001c01c:	6105                	addi	sp,sp,32
    8001c01e:	8082                	ret

000000008001c020 <sbi_getchar>:

char sbi_getchar(void)
{
    8001c020:	1101                	addi	sp,sp,-32
    8001c022:	ec22                	sd	s0,24(sp)
    8001c024:	1000                	addi	s0,sp,32
    char c;
    asm volatile("mv a7, %1\necall\nmv %0, a0\n" : "=r"(c) : "r"(SBI_SVCALL_GETCHAR) : "a7", "a0");
    8001c026:	47a9                	li	a5,10
    8001c028:	88be                	mv	a7,a5
    8001c02a:	00000073          	ecall
    8001c02e:	87aa                	mv	a5,a0
    8001c030:	fef407a3          	sb	a5,-17(s0)
    return c;
    8001c034:	fef44783          	lbu	a5,-17(s0)
}
    8001c038:	853e                	mv	a0,a5
    8001c03a:	6462                	ld	s0,24(sp)
    8001c03c:	6105                	addi	sp,sp,32
    8001c03e:	8082                	ret

000000008001c040 <sbi_hart_get_status>:

int sbi_hart_get_status(unsigned int hart)
{
    8001c040:	7179                	addi	sp,sp,-48
    8001c042:	f422                	sd	s0,40(sp)
    8001c044:	1800                	addi	s0,sp,48
    8001c046:	87aa                	mv	a5,a0
    8001c048:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\necall\nmv %0, a0\n"
    8001c04c:	4785                	li	a5,1
    8001c04e:	fdc42703          	lw	a4,-36(s0)
    8001c052:	88be                	mv	a7,a5
    8001c054:	853a                	mv	a0,a4
    8001c056:	00000073          	ecall
    8001c05a:	87aa                	mv	a5,a0
    8001c05c:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_STATUS), "r"(hart)
                 : "a0", "a7");
    return stat;
    8001c060:	fec42783          	lw	a5,-20(s0)
}
    8001c064:	853e                	mv	a0,a5
    8001c066:	7422                	ld	s0,40(sp)
    8001c068:	6145                	addi	sp,sp,48
    8001c06a:	8082                	ret

000000008001c06c <sbi_hart_start>:

int sbi_hart_start(unsigned int hart, unsigned long target, unsigned long scratch, unsigned long satp)
{
    8001c06c:	7139                	addi	sp,sp,-64
    8001c06e:	fc22                	sd	s0,56(sp)
    8001c070:	0080                	addi	s0,sp,64
    8001c072:	87aa                	mv	a5,a0
    8001c074:	fcb43823          	sd	a1,-48(s0)
    8001c078:	fcc43423          	sd	a2,-56(s0)
    8001c07c:	fcd43023          	sd	a3,-64(s0)
    8001c080:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    asm volatile("mv a7, %1\nmv a0, %2\nmv a1, %3\nmv a2, %4\nmv a3, %5\necall\nmv %0, a0\n"
    8001c084:	4789                	li	a5,2
    8001c086:	fdc42703          	lw	a4,-36(s0)
    8001c08a:	fd043683          	ld	a3,-48(s0)
    8001c08e:	fc843803          	ld	a6,-56(s0)
    8001c092:	fc043303          	ld	t1,-64(s0)
    8001c096:	88be                	mv	a7,a5
    8001c098:	853a                	mv	a0,a4
    8001c09a:	85b6                	mv	a1,a3
    8001c09c:	8642                	mv	a2,a6
    8001c09e:	869a                	mv	a3,t1
    8001c0a0:	00000073          	ecall
    8001c0a4:	87aa                	mv	a5,a0
    8001c0a6:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_START), "r"(hart), "r"(target), "r"(scratch), "r"(satp)
                 : "a0", "a1", "a2", "a7");
    return stat;
    8001c0aa:	fec42783          	lw	a5,-20(s0)
}
    8001c0ae:	853e                	mv	a0,a5
    8001c0b0:	7462                	ld	s0,56(sp)
    8001c0b2:	6121                	addi	sp,sp,64
    8001c0b4:	8082                	ret

000000008001c0b6 <sbi_hart_stop>:

void sbi_hart_stop(void)
{
    8001c0b6:	1141                	addi	sp,sp,-16
    8001c0b8:	e422                	sd	s0,8(sp)
    8001c0ba:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall\nwfi" : : "r"(SBI_SVCALL_HART_STOP) : "a0", "a7");
    8001c0bc:	478d                	li	a5,3
    8001c0be:	88be                	mv	a7,a5
    8001c0c0:	00000073          	ecall
    8001c0c4:	10500073          	wfi
}
    8001c0c8:	0001                	nop
    8001c0ca:	6422                	ld	s0,8(sp)
    8001c0cc:	0141                	addi	sp,sp,16
    8001c0ce:	8082                	ret

000000008001c0d0 <sbi_poweroff>:

void sbi_poweroff(void)
{
    8001c0d0:	1141                	addi	sp,sp,-16
    8001c0d2:	e422                	sd	s0,8(sp)
    8001c0d4:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" : : "r"(SBI_SVCALL_POWEROFF) : "a0", "a7");
    8001c0d6:	47b1                	li	a5,12
    8001c0d8:	88be                	mv	a7,a5
    8001c0da:	00000073          	ecall
}
    8001c0de:	0001                	nop
    8001c0e0:	6422                	ld	s0,8(sp)
    8001c0e2:	0141                	addi	sp,sp,16
    8001c0e4:	8082                	ret

000000008001c0e6 <sbi_get_time>:

unsigned long sbi_get_time(void)
{
    8001c0e6:	1101                	addi	sp,sp,-32
    8001c0e8:	ec22                	sd	s0,24(sp)
    8001c0ea:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_GET_TIME) : "a0", "a7");
    8001c0ec:	4791                	li	a5,4
    8001c0ee:	88be                	mv	a7,a5
    8001c0f0:	00000073          	ecall
    8001c0f4:	87aa                	mv	a5,a0
    8001c0f6:	fef43423          	sd	a5,-24(s0)
    return ret;
    8001c0fa:	fe843783          	ld	a5,-24(s0)
}
    8001c0fe:	853e                	mv	a0,a5
    8001c100:	6462                	ld	s0,24(sp)
    8001c102:	6105                	addi	sp,sp,32
    8001c104:	8082                	ret

000000008001c106 <sbi_set_timer>:

void sbi_set_timer(unsigned int hart, unsigned long val)
{
    8001c106:	1101                	addi	sp,sp,-32
    8001c108:	ec22                	sd	s0,24(sp)
    8001c10a:	1000                	addi	s0,sp,32
    8001c10c:	87aa                	mv	a5,a0
    8001c10e:	feb43023          	sd	a1,-32(s0)
    8001c112:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_SET_TIMECMP), "r"(hart),
    8001c116:	4795                	li	a5,5
    8001c118:	fec42703          	lw	a4,-20(s0)
    8001c11c:	fe043683          	ld	a3,-32(s0)
    8001c120:	88be                	mv	a7,a5
    8001c122:	853a                	mv	a0,a4
    8001c124:	85b6                	mv	a1,a3
    8001c126:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    8001c12a:	0001                	nop
    8001c12c:	6462                	ld	s0,24(sp)
    8001c12e:	6105                	addi	sp,sp,32
    8001c130:	8082                	ret

000000008001c132 <sbi_add_timer>:

void sbi_add_timer(unsigned int hart, unsigned long val)
{
    8001c132:	1101                	addi	sp,sp,-32
    8001c134:	ec22                	sd	s0,24(sp)
    8001c136:	1000                	addi	s0,sp,32
    8001c138:	87aa                	mv	a5,a0
    8001c13a:	feb43023          	sd	a1,-32(s0)
    8001c13e:	fef42623          	sw	a5,-20(s0)
    asm volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_ADD_TIMECMP), "r"(hart),
    8001c142:	4799                	li	a5,6
    8001c144:	fec42703          	lw	a4,-20(s0)
    8001c148:	fe043683          	ld	a3,-32(s0)
    8001c14c:	88be                	mv	a7,a5
    8001c14e:	853a                	mv	a0,a4
    8001c150:	85b6                	mv	a1,a3
    8001c152:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    8001c156:	0001                	nop
    8001c158:	6462                	ld	s0,24(sp)
    8001c15a:	6105                	addi	sp,sp,32
    8001c15c:	8082                	ret

000000008001c15e <sbi_ack_timer>:

void sbi_ack_timer(void)
{
    8001c15e:	1141                	addi	sp,sp,-16
    8001c160:	e422                	sd	s0,8(sp)
    8001c162:	0800                	addi	s0,sp,16
    asm volatile("mv a7, %0\necall" ::"r"(SBI_SVCALL_ACK_TIMER) : "a7");
    8001c164:	479d                	li	a5,7
    8001c166:	88be                	mv	a7,a5
    8001c168:	00000073          	ecall
}
    8001c16c:	0001                	nop
    8001c16e:	6422                	ld	s0,8(sp)
    8001c170:	0141                	addi	sp,sp,16
    8001c172:	8082                	ret

000000008001c174 <sbi_rtc_get_time>:

unsigned long sbi_rtc_get_time(void)
{
    8001c174:	1101                	addi	sp,sp,-32
    8001c176:	ec22                	sd	s0,24(sp)
    8001c178:	1000                	addi	s0,sp,32
    unsigned long ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0"
    8001c17a:	47a1                	li	a5,8
    8001c17c:	88be                	mv	a7,a5
    8001c17e:	00000073          	ecall
    8001c182:	87aa                	mv	a5,a0
    8001c184:	fef43423          	sd	a5,-24(s0)
                 : "=r"(ret)
                 : "r"(SBI_SVCALL_RTC_GET_TIME)
                 : "a0", "a7");
    return ret;
    8001c188:	fe843783          	ld	a5,-24(s0)
}
    8001c18c:	853e                	mv	a0,a5
    8001c18e:	6462                	ld	s0,24(sp)
    8001c190:	6105                	addi	sp,sp,32
    8001c192:	8082                	ret

000000008001c194 <sbi_whoami>:

int sbi_whoami(void)
{
    8001c194:	1101                	addi	sp,sp,-32
    8001c196:	ec22                	sd	s0,24(sp)
    8001c198:	1000                	addi	s0,sp,32
    int ret;
    asm volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_WHOAMI) : "a0", "a7");
    8001c19a:	47ad                	li	a5,11
    8001c19c:	88be                	mv	a7,a5
    8001c19e:	00000073          	ecall
    8001c1a2:	87aa                	mv	a5,a0
    8001c1a4:	fef42623          	sw	a5,-20(s0)
    return ret;
    8001c1a8:	fec42783          	lw	a5,-20(s0)
}
    8001c1ac:	853e                	mv	a0,a5
    8001c1ae:	6462                	ld	s0,24(sp)
    8001c1b0:	6105                	addi	sp,sp,32
    8001c1b2:	8082                	ret

000000008001c1b4 <sbi_num_harts>:

int sbi_num_harts(void)
{
    8001c1b4:	1101                	addi	sp,sp,-32
    8001c1b6:	ec06                	sd	ra,24(sp)
    8001c1b8:	e822                	sd	s0,16(sp)
    8001c1ba:	1000                	addi	s0,sp,32
    unsigned int i;
    int num_harts = 0;
    8001c1bc:	fe042423          	sw	zero,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    8001c1c0:	fe042623          	sw	zero,-20(s0)
    8001c1c4:	a015                	j	8001c1e8 <sbi_num_harts+0x34>
        if (sbi_hart_get_status(i) != 0) {
    8001c1c6:	fec42783          	lw	a5,-20(s0)
    8001c1ca:	853e                	mv	a0,a5
    8001c1cc:	e75ff0ef          	jal	ra,8001c040 <sbi_hart_get_status>
    8001c1d0:	87aa                	mv	a5,a0
    8001c1d2:	c791                	beqz	a5,8001c1de <sbi_num_harts+0x2a>
            num_harts += 1;
    8001c1d4:	fe842783          	lw	a5,-24(s0)
    8001c1d8:	2785                	addiw	a5,a5,1
    8001c1da:	fef42423          	sw	a5,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    8001c1de:	fec42783          	lw	a5,-20(s0)
    8001c1e2:	2785                	addiw	a5,a5,1
    8001c1e4:	fef42623          	sw	a5,-20(s0)
    8001c1e8:	fec42783          	lw	a5,-20(s0)
    8001c1ec:	0007871b          	sext.w	a4,a5
    8001c1f0:	478d                	li	a5,3
    8001c1f2:	fce7fae3          	bgeu	a5,a4,8001c1c6 <sbi_num_harts+0x12>
        }
    }
    return num_harts;
    8001c1f6:	fe842783          	lw	a5,-24(s0)
}
    8001c1fa:	853e                	mv	a0,a5
    8001c1fc:	60e2                	ld	ra,24(sp)
    8001c1fe:	6442                	ld	s0,16(sp)
    8001c200:	6105                	addi	sp,sp,32
    8001c202:	8082                	ret

000000008001c204 <plic_set_priority>:
#define PLIC_PCI_INTB 33
#define PLIC_PCI_INTC 34
#define PLIC_PCI_INTD 35

void plic_set_priority(int interrupt_id, char priority)
{
    8001c204:	7179                	addi	sp,sp,-48
    8001c206:	f422                	sd	s0,40(sp)
    8001c208:	1800                	addi	s0,sp,48
    8001c20a:	87aa                	mv	a5,a0
    8001c20c:	872e                	mv	a4,a1
    8001c20e:	fcf42e23          	sw	a5,-36(s0)
    8001c212:	87ba                	mv	a5,a4
    8001c214:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_PRIORITY(interrupt_id);
    8001c218:	fdc42783          	lw	a5,-36(s0)
    8001c21c:	0027979b          	slliw	a5,a5,0x2
    8001c220:	2781                	sext.w	a5,a5
    8001c222:	873e                	mv	a4,a5
    8001c224:	0c0007b7          	lui	a5,0xc000
    8001c228:	97ba                	add	a5,a5,a4
    8001c22a:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    8001c22e:	fdb44783          	lbu	a5,-37(s0)
    8001c232:	2781                	sext.w	a5,a5
    8001c234:	8b9d                	andi	a5,a5,7
    8001c236:	0007871b          	sext.w	a4,a5
    8001c23a:	fe843783          	ld	a5,-24(s0)
    8001c23e:	c398                	sw	a4,0(a5)
}
    8001c240:	0001                	nop
    8001c242:	7422                	ld	s0,40(sp)
    8001c244:	6145                	addi	sp,sp,48
    8001c246:	8082                	ret

000000008001c248 <plic_set_threshold>:
void plic_set_threshold(int hart, char priority)
{
    8001c248:	7179                	addi	sp,sp,-48
    8001c24a:	f422                	sd	s0,40(sp)
    8001c24c:	1800                	addi	s0,sp,48
    8001c24e:	87aa                	mv	a5,a0
    8001c250:	872e                	mv	a4,a1
    8001c252:	fcf42e23          	sw	a5,-36(s0)
    8001c256:	87ba                	mv	a5,a4
    8001c258:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_THRESHOLD(hart, PLIC_MODE_SUPERVISOR);
    8001c25c:	fdc42783          	lw	a5,-36(s0)
    8001c260:	0017979b          	slliw	a5,a5,0x1
    8001c264:	2781                	sext.w	a5,a5
    8001c266:	2785                	addiw	a5,a5,1
    8001c268:	2781                	sext.w	a5,a5
    8001c26a:	00c7979b          	slliw	a5,a5,0xc
    8001c26e:	2781                	sext.w	a5,a5
    8001c270:	873e                	mv	a4,a5
    8001c272:	0c2007b7          	lui	a5,0xc200
    8001c276:	97ba                	add	a5,a5,a4
    8001c278:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    8001c27c:	fdb44783          	lbu	a5,-37(s0)
    8001c280:	2781                	sext.w	a5,a5
    8001c282:	8b9d                	andi	a5,a5,7
    8001c284:	0007871b          	sext.w	a4,a5
    8001c288:	fe843783          	ld	a5,-24(s0)
    8001c28c:	c398                	sw	a4,0(a5)
}
    8001c28e:	0001                	nop
    8001c290:	7422                	ld	s0,40(sp)
    8001c292:	6145                	addi	sp,sp,48
    8001c294:	8082                	ret

000000008001c296 <plic_enable>:
void plic_enable(int hart, int interrupt_id)
{
    8001c296:	7179                	addi	sp,sp,-48
    8001c298:	f422                	sd	s0,40(sp)
    8001c29a:	1800                	addi	s0,sp,48
    8001c29c:	87aa                	mv	a5,a0
    8001c29e:	872e                	mv	a4,a1
    8001c2a0:	fcf42e23          	sw	a5,-36(s0)
    8001c2a4:	87ba                	mv	a5,a4
    8001c2a6:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    8001c2aa:	fdc42783          	lw	a5,-36(s0)
    8001c2ae:	0017979b          	slliw	a5,a5,0x1
    8001c2b2:	2781                	sext.w	a5,a5
    8001c2b4:	2785                	addiw	a5,a5,1
    8001c2b6:	2781                	sext.w	a5,a5
    8001c2b8:	0077979b          	slliw	a5,a5,0x7
    8001c2bc:	2781                	sext.w	a5,a5
    8001c2be:	873e                	mv	a4,a5
    8001c2c0:	0c0027b7          	lui	a5,0xc002
    8001c2c4:	97ba                	add	a5,a5,a4
    8001c2c6:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] |= 1UL << (interrupt_id % 32);
    8001c2ca:	fd842783          	lw	a5,-40(s0)
    8001c2ce:	41f7d71b          	sraiw	a4,a5,0x1f
    8001c2d2:	01b7571b          	srliw	a4,a4,0x1b
    8001c2d6:	9fb9                	addw	a5,a5,a4
    8001c2d8:	4057d79b          	sraiw	a5,a5,0x5
    8001c2dc:	0007869b          	sext.w	a3,a5
    8001c2e0:	87b6                	mv	a5,a3
    8001c2e2:	078a                	slli	a5,a5,0x2
    8001c2e4:	fe843703          	ld	a4,-24(s0)
    8001c2e8:	97ba                	add	a5,a5,a4
    8001c2ea:	438c                	lw	a1,0(a5)
    8001c2ec:	fd842703          	lw	a4,-40(s0)
    8001c2f0:	41f7579b          	sraiw	a5,a4,0x1f
    8001c2f4:	01b7d79b          	srliw	a5,a5,0x1b
    8001c2f8:	9f3d                	addw	a4,a4,a5
    8001c2fa:	8b7d                	andi	a4,a4,31
    8001c2fc:	40f707bb          	subw	a5,a4,a5
    8001c300:	2781                	sext.w	a5,a5
    8001c302:	873e                	mv	a4,a5
    8001c304:	4785                	li	a5,1
    8001c306:	00e797b3          	sll	a5,a5,a4
    8001c30a:	0007861b          	sext.w	a2,a5
    8001c30e:	87b6                	mv	a5,a3
    8001c310:	078a                	slli	a5,a5,0x2
    8001c312:	fe843703          	ld	a4,-24(s0)
    8001c316:	97ba                	add	a5,a5,a4
    8001c318:	86ae                	mv	a3,a1
    8001c31a:	8732                	mv	a4,a2
    8001c31c:	8f55                	or	a4,a4,a3
    8001c31e:	2701                	sext.w	a4,a4
    8001c320:	c398                	sw	a4,0(a5)
}
    8001c322:	0001                	nop
    8001c324:	7422                	ld	s0,40(sp)
    8001c326:	6145                	addi	sp,sp,48
    8001c328:	8082                	ret

000000008001c32a <plic_disable>:
void plic_disable(int hart, int interrupt_id)
{
    8001c32a:	7179                	addi	sp,sp,-48
    8001c32c:	f422                	sd	s0,40(sp)
    8001c32e:	1800                	addi	s0,sp,48
    8001c330:	87aa                	mv	a5,a0
    8001c332:	872e                	mv	a4,a1
    8001c334:	fcf42e23          	sw	a5,-36(s0)
    8001c338:	87ba                	mv	a5,a4
    8001c33a:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    8001c33e:	fdc42783          	lw	a5,-36(s0)
    8001c342:	0017979b          	slliw	a5,a5,0x1
    8001c346:	2781                	sext.w	a5,a5
    8001c348:	2785                	addiw	a5,a5,1
    8001c34a:	2781                	sext.w	a5,a5
    8001c34c:	0077979b          	slliw	a5,a5,0x7
    8001c350:	2781                	sext.w	a5,a5
    8001c352:	873e                	mv	a4,a5
    8001c354:	0c0027b7          	lui	a5,0xc002
    8001c358:	97ba                	add	a5,a5,a4
    8001c35a:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] &= ~(1UL << (interrupt_id % 32));
    8001c35e:	fd842783          	lw	a5,-40(s0)
    8001c362:	41f7d71b          	sraiw	a4,a5,0x1f
    8001c366:	01b7571b          	srliw	a4,a4,0x1b
    8001c36a:	9fb9                	addw	a5,a5,a4
    8001c36c:	4057d79b          	sraiw	a5,a5,0x5
    8001c370:	0007869b          	sext.w	a3,a5
    8001c374:	87b6                	mv	a5,a3
    8001c376:	078a                	slli	a5,a5,0x2
    8001c378:	fe843703          	ld	a4,-24(s0)
    8001c37c:	97ba                	add	a5,a5,a4
    8001c37e:	438c                	lw	a1,0(a5)
    8001c380:	fd842703          	lw	a4,-40(s0)
    8001c384:	41f7579b          	sraiw	a5,a4,0x1f
    8001c388:	01b7d79b          	srliw	a5,a5,0x1b
    8001c38c:	9f3d                	addw	a4,a4,a5
    8001c38e:	8b7d                	andi	a4,a4,31
    8001c390:	40f707bb          	subw	a5,a4,a5
    8001c394:	2781                	sext.w	a5,a5
    8001c396:	873e                	mv	a4,a5
    8001c398:	4785                	li	a5,1
    8001c39a:	00e797b3          	sll	a5,a5,a4
    8001c39e:	2781                	sext.w	a5,a5
    8001c3a0:	fff7c793          	not	a5,a5
    8001c3a4:	0007861b          	sext.w	a2,a5
    8001c3a8:	87b6                	mv	a5,a3
    8001c3aa:	078a                	slli	a5,a5,0x2
    8001c3ac:	fe843703          	ld	a4,-24(s0)
    8001c3b0:	97ba                	add	a5,a5,a4
    8001c3b2:	86ae                	mv	a3,a1
    8001c3b4:	8732                	mv	a4,a2
    8001c3b6:	8f75                	and	a4,a4,a3
    8001c3b8:	2701                	sext.w	a4,a4
    8001c3ba:	c398                	sw	a4,0(a5)
}
    8001c3bc:	0001                	nop
    8001c3be:	7422                	ld	s0,40(sp)
    8001c3c0:	6145                	addi	sp,sp,48
    8001c3c2:	8082                	ret

000000008001c3c4 <plic_claim>:
uint32_t plic_claim(int hart)
{
    8001c3c4:	7179                	addi	sp,sp,-48
    8001c3c6:	f422                	sd	s0,40(sp)
    8001c3c8:	1800                	addi	s0,sp,48
    8001c3ca:	87aa                	mv	a5,a0
    8001c3cc:	fcf42e23          	sw	a5,-36(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    8001c3d0:	fdc42783          	lw	a5,-36(s0)
    8001c3d4:	0017979b          	slliw	a5,a5,0x1
    8001c3d8:	2781                	sext.w	a5,a5
    8001c3da:	2785                	addiw	a5,a5,1
    8001c3dc:	2781                	sext.w	a5,a5
    8001c3de:	00c7979b          	slliw	a5,a5,0xc
    8001c3e2:	2781                	sext.w	a5,a5
    8001c3e4:	873e                	mv	a4,a5
    8001c3e6:	0c2007b7          	lui	a5,0xc200
    8001c3ea:	0791                	addi	a5,a5,4
    8001c3ec:	97ba                	add	a5,a5,a4
    8001c3ee:	fef43423          	sd	a5,-24(s0)
    return *base;
    8001c3f2:	fe843783          	ld	a5,-24(s0)
    8001c3f6:	439c                	lw	a5,0(a5)
}
    8001c3f8:	853e                	mv	a0,a5
    8001c3fa:	7422                	ld	s0,40(sp)
    8001c3fc:	6145                	addi	sp,sp,48
    8001c3fe:	8082                	ret

000000008001c400 <plic_complete>:
void plic_complete(int hart, int id)
{
    8001c400:	7179                	addi	sp,sp,-48
    8001c402:	f422                	sd	s0,40(sp)
    8001c404:	1800                	addi	s0,sp,48
    8001c406:	87aa                	mv	a5,a0
    8001c408:	872e                	mv	a4,a1
    8001c40a:	fcf42e23          	sw	a5,-36(s0)
    8001c40e:	87ba                	mv	a5,a4
    8001c410:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    8001c414:	fdc42783          	lw	a5,-36(s0)
    8001c418:	0017979b          	slliw	a5,a5,0x1
    8001c41c:	2781                	sext.w	a5,a5
    8001c41e:	2785                	addiw	a5,a5,1
    8001c420:	2781                	sext.w	a5,a5
    8001c422:	00c7979b          	slliw	a5,a5,0xc
    8001c426:	2781                	sext.w	a5,a5
    8001c428:	873e                	mv	a4,a5
    8001c42a:	0c2007b7          	lui	a5,0xc200
    8001c42e:	0791                	addi	a5,a5,4
    8001c430:	97ba                	add	a5,a5,a4
    8001c432:	fef43423          	sd	a5,-24(s0)
    *base          = id;
    8001c436:	fd842703          	lw	a4,-40(s0)
    8001c43a:	fe843783          	ld	a5,-24(s0)
    8001c43e:	c398                	sw	a4,0(a5)
}
    8001c440:	0001                	nop
    8001c442:	7422                	ld	s0,40(sp)
    8001c444:	6145                	addi	sp,sp,48
    8001c446:	8082                	ret

000000008001c448 <plic_handle_irq>:

void plic_handle_irq(int hart)
{
    8001c448:	7179                	addi	sp,sp,-48
    8001c44a:	f406                	sd	ra,40(sp)
    8001c44c:	f022                	sd	s0,32(sp)
    8001c44e:	1800                	addi	s0,sp,48
    8001c450:	87aa                	mv	a5,a0
    8001c452:	fcf42e23          	sw	a5,-36(s0)
    int irq = plic_claim(hart);
    8001c456:	fdc42783          	lw	a5,-36(s0)
    8001c45a:	853e                	mv	a0,a5
    8001c45c:	f69ff0ef          	jal	ra,8001c3c4 <plic_claim>
    8001c460:	87aa                	mv	a5,a0
    8001c462:	2781                	sext.w	a5,a5
    8001c464:	fef42623          	sw	a5,-20(s0)
    8001c468:	fec42783          	lw	a5,-20(s0)
    8001c46c:	3781                	addiw	a5,a5,-32
    8001c46e:	2781                	sext.w	a5,a5

    switch (irq) {
    8001c470:	873e                	mv	a4,a5
    8001c472:	478d                	li	a5,3
    8001c474:	00e7e863          	bltu	a5,a4,8001c484 <plic_handle_irq+0x3c>
        // PCI devices 32-35
        case PLIC_PCI_INTA: [[fallthrough]]
        case PLIC_PCI_INTB: [[fallthrough]]
        case PLIC_PCI_INTC: [[fallthrough]]
        case PLIC_PCI_INTD:
            pci_dispatch_irq(irq);
    8001c478:	fec42783          	lw	a5,-20(s0)
    8001c47c:	853e                	mv	a0,a5
    8001c47e:	fdcf80ef          	jal	ra,80014c5a <pci_dispatch_irq>
            break;
    8001c482:	0001                	nop
    }
    plic_complete(hart, irq);
    8001c484:	fec42703          	lw	a4,-20(s0)
    8001c488:	fdc42783          	lw	a5,-36(s0)
    8001c48c:	85ba                	mv	a1,a4
    8001c48e:	853e                	mv	a0,a5
    8001c490:	f71ff0ef          	jal	ra,8001c400 <plic_complete>
}
    8001c494:	0001                	nop
    8001c496:	70a2                	ld	ra,40(sp)
    8001c498:	7402                	ld	s0,32(sp)
    8001c49a:	6145                	addi	sp,sp,48
    8001c49c:	8082                	ret

000000008001c49e <plic_init>:

void plic_init(void)
{
    8001c49e:	1141                	addi	sp,sp,-16
    8001c4a0:	e406                	sd	ra,8(sp)
    8001c4a2:	e022                	sd	s0,0(sp)
    8001c4a4:	0800                	addi	s0,sp,16
    plic_enable(0, PLIC_PCI_INTA);
    8001c4a6:	02000593          	li	a1,32
    8001c4aa:	4501                	li	a0,0
    8001c4ac:	debff0ef          	jal	ra,8001c296 <plic_enable>
    plic_enable(0, PLIC_PCI_INTB);
    8001c4b0:	02100593          	li	a1,33
    8001c4b4:	4501                	li	a0,0
    8001c4b6:	de1ff0ef          	jal	ra,8001c296 <plic_enable>
    plic_enable(0, PLIC_PCI_INTC);
    8001c4ba:	02200593          	li	a1,34
    8001c4be:	4501                	li	a0,0
    8001c4c0:	dd7ff0ef          	jal	ra,8001c296 <plic_enable>
    plic_enable(0, PLIC_PCI_INTD);
    8001c4c4:	02300593          	li	a1,35
    8001c4c8:	4501                	li	a0,0
    8001c4ca:	dcdff0ef          	jal	ra,8001c296 <plic_enable>

    plic_set_threshold(0, 0);
    8001c4ce:	4581                	li	a1,0
    8001c4d0:	4501                	li	a0,0
    8001c4d2:	d77ff0ef          	jal	ra,8001c248 <plic_set_threshold>

    plic_set_priority(PLIC_PCI_INTA, 7);
    8001c4d6:	459d                	li	a1,7
    8001c4d8:	02000513          	li	a0,32
    8001c4dc:	d29ff0ef          	jal	ra,8001c204 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTB, 7);
    8001c4e0:	459d                	li	a1,7
    8001c4e2:	02100513          	li	a0,33
    8001c4e6:	d1fff0ef          	jal	ra,8001c204 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTC, 7);
    8001c4ea:	459d                	li	a1,7
    8001c4ec:	02200513          	li	a0,34
    8001c4f0:	d15ff0ef          	jal	ra,8001c204 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTD, 7);
    8001c4f4:	459d                	li	a1,7
    8001c4f6:	02300513          	li	a0,35
    8001c4fa:	d0bff0ef          	jal	ra,8001c204 <plic_set_priority>
}
    8001c4fe:	0001                	nop
    8001c500:	60a2                	ld	ra,8(sp)
    8001c502:	6402                	ld	s0,0(sp)
    8001c504:	0141                	addi	sp,sp,16
    8001c506:	8082                	ret

000000008001c508 <virtio_create_job>:



static Vector *virtio_devices = NULL;

void virtio_create_job(VirtioDevice *dev, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job)) {
    8001c508:	7179                	addi	sp,sp,-48
    8001c50a:	f406                	sd	ra,40(sp)
    8001c50c:	f022                	sd	s0,32(sp)
    8001c50e:	1800                	addi	s0,sp,48
    8001c510:	fea43423          	sd	a0,-24(s0)
    8001c514:	feb43023          	sd	a1,-32(s0)
    8001c518:	fcc43c23          	sd	a2,-40(s0)
    virtio_create_job_with_data(dev, pid_id, callback, NULL);
    8001c51c:	4681                	li	a3,0
    8001c51e:	fd843603          	ld	a2,-40(s0)
    8001c522:	fe043583          	ld	a1,-32(s0)
    8001c526:	fe843503          	ld	a0,-24(s0)
    8001c52a:	00e000ef          	jal	ra,8001c538 <virtio_create_job_with_data>
}
    8001c52e:	0001                	nop
    8001c530:	70a2                	ld	ra,40(sp)
    8001c532:	7402                	ld	s0,32(sp)
    8001c534:	6145                	addi	sp,sp,48
    8001c536:	8082                	ret

000000008001c538 <virtio_create_job_with_data>:

void virtio_create_job_with_data(VirtioDevice *dev, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job), void *data) {
    8001c538:	7171                	addi	sp,sp,-176
    8001c53a:	f506                	sd	ra,168(sp)
    8001c53c:	f122                	sd	s0,160(sp)
    8001c53e:	1900                	addi	s0,sp,176
    8001c540:	faa43423          	sd	a0,-88(s0)
    8001c544:	fab43023          	sd	a1,-96(s0)
    8001c548:	f8c43c23          	sd	a2,-104(s0)
    8001c54c:	f8d43823          	sd	a3,-112(s0)
    Job job = job_create(virtio_get_next_job_id(dev), pid_id, callback);
    8001c550:	fa843503          	ld	a0,-88(s0)
    8001c554:	490000ef          	jal	ra,8001c9e4 <virtio_get_next_job_id>
    8001c558:	872a                	mv	a4,a0
    8001c55a:	fb840793          	addi	a5,s0,-72
    8001c55e:	f9843683          	ld	a3,-104(s0)
    8001c562:	fa043603          	ld	a2,-96(s0)
    8001c566:	85ba                	mv	a1,a4
    8001c568:	853e                	mv	a0,a5
    8001c56a:	0de000ef          	jal	ra,8001c648 <job_create>
    job.data = data;
    8001c56e:	f9043783          	ld	a5,-112(s0)
    8001c572:	fef43423          	sd	a5,-24(s0)
    virtio_add_job(dev, job);
    8001c576:	fb843803          	ld	a6,-72(s0)
    8001c57a:	fc043503          	ld	a0,-64(s0)
    8001c57e:	fc843583          	ld	a1,-56(s0)
    8001c582:	fd043603          	ld	a2,-48(s0)
    8001c586:	fd843683          	ld	a3,-40(s0)
    8001c58a:	fe043703          	ld	a4,-32(s0)
    8001c58e:	fe843783          	ld	a5,-24(s0)
    8001c592:	f5043823          	sd	a6,-176(s0)
    8001c596:	f4a43c23          	sd	a0,-168(s0)
    8001c59a:	f6b43023          	sd	a1,-160(s0)
    8001c59e:	f6c43423          	sd	a2,-152(s0)
    8001c5a2:	f6d43823          	sd	a3,-144(s0)
    8001c5a6:	f6e43c23          	sd	a4,-136(s0)
    8001c5aa:	f8f43023          	sd	a5,-128(s0)
    8001c5ae:	f5040793          	addi	a5,s0,-176
    8001c5b2:	85be                	mv	a1,a5
    8001c5b4:	fa843503          	ld	a0,-88(s0)
    8001c5b8:	2a4000ef          	jal	ra,8001c85c <virtio_add_job>
}
    8001c5bc:	0001                	nop
    8001c5be:	70aa                	ld	ra,168(sp)
    8001c5c0:	740a                	ld	s0,160(sp)
    8001c5c2:	614d                	addi	sp,sp,176
    8001c5c4:	8082                	ret

000000008001c5c6 <virtio_get_job>:

Job *virtio_get_job(VirtioDevice *dev, uint64_t job_id) {
    8001c5c6:	7179                	addi	sp,sp,-48
    8001c5c8:	f406                	sd	ra,40(sp)
    8001c5ca:	f022                	sd	s0,32(sp)
    8001c5cc:	1800                	addi	s0,sp,48
    8001c5ce:	fca43c23          	sd	a0,-40(s0)
    8001c5d2:	fcb43823          	sd	a1,-48(s0)
    for (uint64_t i=0; i<vector_size(dev->jobs); i++) {
    8001c5d6:	fe043423          	sd	zero,-24(s0)
    8001c5da:	a099                	j	8001c620 <virtio_get_job+0x5a>
        Job *job = NULL;
    8001c5dc:	fe043023          	sd	zero,-32(s0)
        vector_get_ptr(dev->jobs, i, &job);
    8001c5e0:	fd843783          	ld	a5,-40(s0)
    8001c5e4:	63dc                	ld	a5,128(a5)
    8001c5e6:	fe843703          	ld	a4,-24(s0)
    8001c5ea:	2701                	sext.w	a4,a4
    8001c5ec:	fe040693          	addi	a3,s0,-32
    8001c5f0:	8636                	mv	a2,a3
    8001c5f2:	85ba                	mv	a1,a4
    8001c5f4:	853e                	mv	a0,a5
    8001c5f6:	099060ef          	jal	ra,80022e8e <vector_get>
        if (job == NULL) {
    8001c5fa:	fe043783          	ld	a5,-32(s0)
    8001c5fe:	cb99                	beqz	a5,8001c614 <virtio_get_job+0x4e>
            debugf("No job\n");
            continue;
        }
        if (job->job_id == job_id) {
    8001c600:	fe043783          	ld	a5,-32(s0)
    8001c604:	639c                	ld	a5,0(a5)
    8001c606:	fd043703          	ld	a4,-48(s0)
    8001c60a:	00f71663          	bne	a4,a5,8001c616 <virtio_get_job+0x50>
            return job;
    8001c60e:	fe043783          	ld	a5,-32(s0)
    8001c612:	a035                	j	8001c63e <virtio_get_job+0x78>
            continue;
    8001c614:	0001                	nop
    for (uint64_t i=0; i<vector_size(dev->jobs); i++) {
    8001c616:	fe843783          	ld	a5,-24(s0)
    8001c61a:	0785                	addi	a5,a5,1
    8001c61c:	fef43423          	sd	a5,-24(s0)
    8001c620:	fd843783          	ld	a5,-40(s0)
    8001c624:	63dc                	ld	a5,128(a5)
    8001c626:	853e                	mv	a0,a5
    8001c628:	7c7060ef          	jal	ra,800235ee <vector_size>
    8001c62c:	87aa                	mv	a5,a0
    8001c62e:	2781                	sext.w	a5,a5
    8001c630:	1782                	slli	a5,a5,0x20
    8001c632:	9381                	srli	a5,a5,0x20
    8001c634:	fe843703          	ld	a4,-24(s0)
    8001c638:	faf762e3          	bltu	a4,a5,8001c5dc <virtio_get_job+0x16>
        }
    }
    debugf("No job found with ID %d\n", job_id);
    return NULL;
    8001c63c:	4781                	li	a5,0
}
    8001c63e:	853e                	mv	a0,a5
    8001c640:	70a2                	ld	ra,40(sp)
    8001c642:	7402                	ld	s0,32(sp)
    8001c644:	6145                	addi	sp,sp,48
    8001c646:	8082                	ret

000000008001c648 <job_create>:

Job job_create(uint64_t job_id, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job)) {
    8001c648:	7179                	addi	sp,sp,-48
    8001c64a:	f406                	sd	ra,40(sp)
    8001c64c:	f022                	sd	s0,32(sp)
    8001c64e:	1800                	addi	s0,sp,48
    8001c650:	fea43423          	sd	a0,-24(s0)
    8001c654:	feb43023          	sd	a1,-32(s0)
    8001c658:	fcc43c23          	sd	a2,-40(s0)
    8001c65c:	fcd43823          	sd	a3,-48(s0)
    return job_create_with_data(job_id, pid_id, callback, NULL);
    8001c660:	fe843783          	ld	a5,-24(s0)
    8001c664:	4701                	li	a4,0
    8001c666:	fd043683          	ld	a3,-48(s0)
    8001c66a:	fd843603          	ld	a2,-40(s0)
    8001c66e:	fe043583          	ld	a1,-32(s0)
    8001c672:	853e                	mv	a0,a5
    8001c674:	010000ef          	jal	ra,8001c684 <job_create_with_data>
}
    8001c678:	fe843503          	ld	a0,-24(s0)
    8001c67c:	70a2                	ld	ra,40(sp)
    8001c67e:	7402                	ld	s0,32(sp)
    8001c680:	6145                	addi	sp,sp,48
    8001c682:	8082                	ret

000000008001c684 <job_create_with_data>:

Job job_create_with_data(uint64_t job_id, uint64_t pid_id, void (*callback)(struct VirtioDevice *device, struct Job *job), void *data) {
    8001c684:	7119                	addi	sp,sp,-128
    8001c686:	fca2                	sd	s0,120(sp)
    8001c688:	0100                	addi	s0,sp,128
    8001c68a:	faa43423          	sd	a0,-88(s0)
    8001c68e:	fab43023          	sd	a1,-96(s0)
    8001c692:	f8c43c23          	sd	a2,-104(s0)
    8001c696:	f8d43823          	sd	a3,-112(s0)
    8001c69a:	f8e43423          	sd	a4,-120(s0)
    Job job;
    job.job_id = job_id;
    8001c69e:	fa043783          	ld	a5,-96(s0)
    8001c6a2:	faf43c23          	sd	a5,-72(s0)
    job.pid_id = pid_id;
    8001c6a6:	f9843783          	ld	a5,-104(s0)
    8001c6aa:	fcf43023          	sd	a5,-64(s0)
    job.callback = callback;
    8001c6ae:	f9043783          	ld	a5,-112(s0)
    8001c6b2:	fef43023          	sd	a5,-32(s0)
    job.done = false;
    8001c6b6:	fc040423          	sb	zero,-56(s0)
    job.data = data;
    8001c6ba:	f8843783          	ld	a5,-120(s0)
    8001c6be:	fef43423          	sd	a5,-24(s0)
    return job;
    8001c6c2:	fa843783          	ld	a5,-88(s0)
    8001c6c6:	fb843883          	ld	a7,-72(s0)
    8001c6ca:	fc043803          	ld	a6,-64(s0)
    8001c6ce:	fc843503          	ld	a0,-56(s0)
    8001c6d2:	fd043583          	ld	a1,-48(s0)
    8001c6d6:	fd843603          	ld	a2,-40(s0)
    8001c6da:	fe043683          	ld	a3,-32(s0)
    8001c6de:	fe843703          	ld	a4,-24(s0)
    8001c6e2:	0117b023          	sd	a7,0(a5) # c200000 <i+0xc1fffe0>
    8001c6e6:	0107b423          	sd	a6,8(a5)
    8001c6ea:	eb88                	sd	a0,16(a5)
    8001c6ec:	ef8c                	sd	a1,24(a5)
    8001c6ee:	f390                	sd	a2,32(a5)
    8001c6f0:	f794                	sd	a3,40(a5)
    8001c6f2:	fb98                	sd	a4,48(a5)
}
    8001c6f4:	fa843503          	ld	a0,-88(s0)
    8001c6f8:	7466                	ld	s0,120(sp)
    8001c6fa:	6109                	addi	sp,sp,128
    8001c6fc:	8082                	ret

000000008001c6fe <job_set_context>:

void job_set_context(Job *job, VirtioDescriptor *desc, uint16_t num_descriptors) {
    8001c6fe:	7179                	addi	sp,sp,-48
    8001c700:	f422                	sd	s0,40(sp)
    8001c702:	1800                	addi	s0,sp,48
    8001c704:	fea43423          	sd	a0,-24(s0)
    8001c708:	feb43023          	sd	a1,-32(s0)
    8001c70c:	87b2                	mv	a5,a2
    8001c70e:	fcf41f23          	sh	a5,-34(s0)
    if (job == NULL) {
    8001c712:	fe843783          	ld	a5,-24(s0)
    8001c716:	cf89                	beqz	a5,8001c730 <job_set_context+0x32>
        debugf("No job\n");
        return;
    }
    job->context.desc = desc;
    8001c718:	fe843783          	ld	a5,-24(s0)
    8001c71c:	fe043703          	ld	a4,-32(s0)
    8001c720:	ef98                	sd	a4,24(a5)
    job->context.num_descriptors = num_descriptors;
    8001c722:	fe843783          	ld	a5,-24(s0)
    8001c726:	fde45703          	lhu	a4,-34(s0)
    8001c72a:	02e79023          	sh	a4,32(a5)
    8001c72e:	a011                	j	8001c732 <job_set_context+0x34>
        return;
    8001c730:	0001                	nop
}
    8001c732:	7422                	ld	s0,40(sp)
    8001c734:	6145                	addi	sp,sp,48
    8001c736:	8082                	ret

000000008001c738 <job_destroy>:

void job_destroy(Job *job) {
    8001c738:	1101                	addi	sp,sp,-32
    8001c73a:	ec06                	sd	ra,24(sp)
    8001c73c:	e822                	sd	s0,16(sp)
    8001c73e:	1000                	addi	s0,sp,32
    8001c740:	fea43423          	sd	a0,-24(s0)
    if (job->data != NULL) {
    8001c744:	fe843783          	ld	a5,-24(s0)
    8001c748:	7b9c                	ld	a5,48(a5)
    8001c74a:	c799                	beqz	a5,8001c758 <job_destroy+0x20>
        debugf("About to free non-nulled Job data\n");
        kfree(job->data);
    8001c74c:	fe843783          	ld	a5,-24(s0)
    8001c750:	7b9c                	ld	a5,48(a5)
    8001c752:	853e                	mv	a0,a5
    8001c754:	e27f80ef          	jal	ra,8001557a <kfree>
    }

    if (job != NULL) {
    8001c758:	fe843783          	ld	a5,-24(s0)
    8001c75c:	c789                	beqz	a5,8001c766 <job_destroy+0x2e>
        kfree(job);
    8001c75e:	fe843503          	ld	a0,-24(s0)
    8001c762:	e19f80ef          	jal	ra,8001557a <kfree>
    }
}
    8001c766:	0001                	nop
    8001c768:	60e2                	ld	ra,24(sp)
    8001c76a:	6442                	ld	s0,16(sp)
    8001c76c:	6105                	addi	sp,sp,32
    8001c76e:	8082                	ret

000000008001c770 <virtio_callback_and_free_job>:

void virtio_callback_and_free_job(VirtioDevice *dev, uint64_t job_id) {
    8001c770:	7179                	addi	sp,sp,-48
    8001c772:	f406                	sd	ra,40(sp)
    8001c774:	f022                	sd	s0,32(sp)
    8001c776:	1800                	addi	s0,sp,48
    8001c778:	fca43c23          	sd	a0,-40(s0)
    8001c77c:	fcb43823          	sd	a1,-48(s0)
    Job *job = virtio_get_job(dev, job_id);
    8001c780:	fd043583          	ld	a1,-48(s0)
    8001c784:	fd843503          	ld	a0,-40(s0)
    8001c788:	e3fff0ef          	jal	ra,8001c5c6 <virtio_get_job>
    8001c78c:	fea43423          	sd	a0,-24(s0)
    if (job == NULL) {
    8001c790:	fe843783          	ld	a5,-24(s0)
    8001c794:	c79d                	beqz	a5,8001c7c2 <virtio_callback_and_free_job+0x52>
        debugf("No job\n");
        return;
    }
    job->done = true;
    8001c796:	fe843783          	ld	a5,-24(s0)
    8001c79a:	4705                	li	a4,1
    8001c79c:	00e78823          	sb	a4,16(a5)
    if (job->callback != NULL) {
    8001c7a0:	fe843783          	ld	a5,-24(s0)
    8001c7a4:	779c                	ld	a5,40(a5)
    8001c7a6:	cb89                	beqz	a5,8001c7b8 <virtio_callback_and_free_job+0x48>
        job->callback(dev, job);
    8001c7a8:	fe843783          	ld	a5,-24(s0)
    8001c7ac:	779c                	ld	a5,40(a5)
    8001c7ae:	fe843583          	ld	a1,-24(s0)
    8001c7b2:	fd843503          	ld	a0,-40(s0)
    8001c7b6:	9782                	jalr	a5
    } else {
        debugf("No callback for job\n");
    }

    job_destroy(job);
    8001c7b8:	fe843503          	ld	a0,-24(s0)
    8001c7bc:	f7dff0ef          	jal	ra,8001c738 <job_destroy>
    8001c7c0:	a011                	j	8001c7c4 <virtio_callback_and_free_job+0x54>
        return;
    8001c7c2:	0001                	nop
}
    8001c7c4:	70a2                	ld	ra,40(sp)
    8001c7c6:	7402                	ld	s0,32(sp)
    8001c7c8:	6145                	addi	sp,sp,48
    8001c7ca:	8082                	ret

000000008001c7cc <virtio_is_device_available>:

bool virtio_is_device_available(VirtioDevice *dev) {
    8001c7cc:	1101                	addi	sp,sp,-32
    8001c7ce:	ec22                	sd	s0,24(sp)
    8001c7d0:	1000                	addi	s0,sp,32
    8001c7d2:	fea43423          	sd	a0,-24(s0)
    return dev->lock == MUTEX_UNLOCKED;
    8001c7d6:	fe843783          	ld	a5,-24(s0)
    8001c7da:	0907a783          	lw	a5,144(a5)
    8001c7de:	0017b793          	seqz	a5,a5
    8001c7e2:	0ff7f793          	andi	a5,a5,255
}
    8001c7e6:	853e                	mv	a0,a5
    8001c7e8:	6462                	ld	s0,24(sp)
    8001c7ea:	6105                	addi	sp,sp,32
    8001c7ec:	8082                	ret

000000008001c7ee <virtio_acquire_device>:

void virtio_acquire_device(VirtioDevice *dev) {
    8001c7ee:	7179                	addi	sp,sp,-48
    8001c7f0:	f406                	sd	ra,40(sp)
    8001c7f2:	f022                	sd	s0,32(sp)
    8001c7f4:	1800                	addi	s0,sp,48
    8001c7f6:	fca43c23          	sd	a0,-40(s0)
    IRQ_OFF();
    8001c7fa:	100027f3          	csrr	a5,sstatus
    8001c7fe:	fef43423          	sd	a5,-24(s0)
    8001c802:	fe843783          	ld	a5,-24(s0)
    8001c806:	9bf5                	andi	a5,a5,-3
    8001c808:	10079073          	csrw	sstatus,a5
    debugf("Acquiring device %p\n", dev);
    mutex_spinlock(&dev->lock);
    8001c80c:	fd843783          	ld	a5,-40(s0)
    8001c810:	09078793          	addi	a5,a5,144
    8001c814:	853e                	mv	a0,a5
    8001c816:	e25f80ef          	jal	ra,8001563a <mutex_spinlock>
}
    8001c81a:	0001                	nop
    8001c81c:	70a2                	ld	ra,40(sp)
    8001c81e:	7402                	ld	s0,32(sp)
    8001c820:	6145                	addi	sp,sp,48
    8001c822:	8082                	ret

000000008001c824 <virtio_release_device>:

void virtio_release_device(VirtioDevice *dev) {
    8001c824:	7179                	addi	sp,sp,-48
    8001c826:	f406                	sd	ra,40(sp)
    8001c828:	f022                	sd	s0,32(sp)
    8001c82a:	1800                	addi	s0,sp,48
    8001c82c:	fca43c23          	sd	a0,-40(s0)
    mutex_unlock(&dev->lock);
    8001c830:	fd843783          	ld	a5,-40(s0)
    8001c834:	09078793          	addi	a5,a5,144
    8001c838:	853e                	mv	a0,a5
    8001c83a:	e2ff80ef          	jal	ra,80015668 <mutex_unlock>
    debugf("Releasing device %p\n", dev);
    IRQ_ON();
    8001c83e:	100027f3          	csrr	a5,sstatus
    8001c842:	fef43423          	sd	a5,-24(s0)
    8001c846:	fe843783          	ld	a5,-24(s0)
    8001c84a:	0027e793          	ori	a5,a5,2
    8001c84e:	10079073          	csrw	sstatus,a5
}
    8001c852:	0001                	nop
    8001c854:	70a2                	ld	ra,40(sp)
    8001c856:	7402                	ld	s0,32(sp)
    8001c858:	6145                	addi	sp,sp,48
    8001c85a:	8082                	ret

000000008001c85c <virtio_add_job>:

void virtio_add_job(VirtioDevice *dev, Job job) {
    8001c85c:	7139                	addi	sp,sp,-64
    8001c85e:	fc06                	sd	ra,56(sp)
    8001c860:	f822                	sd	s0,48(sp)
    8001c862:	f426                	sd	s1,40(sp)
    8001c864:	0080                	addi	s0,sp,64
    8001c866:	fca43423          	sd	a0,-56(s0)
    8001c86a:	84ae                	mv	s1,a1
    Job *mem = (Job *)kzalloc(sizeof(Job));
    8001c86c:	03800593          	li	a1,56
    8001c870:	4505                	li	a0,1
    8001c872:	ce1f80ef          	jal	ra,80015552 <kcalloc>
    8001c876:	fca43c23          	sd	a0,-40(s0)
    memcpy(mem, &job, sizeof(Job));
    8001c87a:	03800613          	li	a2,56
    8001c87e:	85a6                	mv	a1,s1
    8001c880:	fd843503          	ld	a0,-40(s0)
    8001c884:	2bb050ef          	jal	ra,8002233e <memcpy>
    vector_push_ptr(dev->jobs, mem);
    8001c888:	fc843783          	ld	a5,-56(s0)
    8001c88c:	63dc                	ld	a5,128(a5)
    8001c88e:	fd843703          	ld	a4,-40(s0)
    8001c892:	85ba                	mv	a1,a4
    8001c894:	853e                	mv	a0,a5
    8001c896:	498060ef          	jal	ra,80022d2e <vector_push>
}
    8001c89a:	0001                	nop
    8001c89c:	70e2                	ld	ra,56(sp)
    8001c89e:	7442                	ld	s0,48(sp)
    8001c8a0:	74a2                	ld	s1,40(sp)
    8001c8a2:	6121                	addi	sp,sp,64
    8001c8a4:	8082                	ret

000000008001c8a6 <virtio_debug_job>:
//         }
//     }
//     return NULL;
// }

void virtio_debug_job(VirtioDevice *dev, Job *job) {
    8001c8a6:	7179                	addi	sp,sp,-48
    8001c8a8:	f422                	sd	s0,40(sp)
    8001c8aa:	1800                	addi	s0,sp,48
    8001c8ac:	fca43c23          	sd	a0,-40(s0)
    8001c8b0:	fcb43823          	sd	a1,-48(s0)
    debugf("Done %d\n", job->done);
    debugf("Data %p\n", job->data);
    debugf("Context\n");
    debugf("  Num descriptors %d\n", job->context.num_descriptors);
    debugf("  Descriptors\n");
    for (uint16_t i=0; i<job->context.num_descriptors; i++) {
    8001c8b4:	fe041723          	sh	zero,-18(s0)
    8001c8b8:	a031                	j	8001c8c4 <virtio_debug_job+0x1e>
    8001c8ba:	fee45783          	lhu	a5,-18(s0)
    8001c8be:	2785                	addiw	a5,a5,1
    8001c8c0:	fef41723          	sh	a5,-18(s0)
    8001c8c4:	fd043783          	ld	a5,-48(s0)
    8001c8c8:	0207d783          	lhu	a5,32(a5)
    8001c8cc:	fee45703          	lhu	a4,-18(s0)
    8001c8d0:	2701                	sext.w	a4,a4
    8001c8d2:	2781                	sext.w	a5,a5
    8001c8d4:	fef763e3          	bltu	a4,a5,8001c8ba <virtio_debug_job+0x14>
        debugf("      addr: %p\n", job->context.desc[i].addr);
        debugf("      len: %d\n", job->context.desc[i].len);
        debugf("      flags: %d\n", job->context.desc[i].flags);
        debugf("      next: %d\n", job->context.desc[i].next);
    }
}
    8001c8d8:	0001                	nop
    8001c8da:	0001                	nop
    8001c8dc:	7422                	ld	s0,40(sp)
    8001c8de:	6145                	addi	sp,sp,48
    8001c8e0:	8082                	ret

000000008001c8e2 <virtio_handle_interrupt>:

void virtio_handle_interrupt(VirtioDevice *dev, VirtioDescriptor desc[], uint16_t num_descriptors) {
    8001c8e2:	7139                	addi	sp,sp,-64
    8001c8e4:	fc06                	sd	ra,56(sp)
    8001c8e6:	f822                	sd	s0,48(sp)
    8001c8e8:	0080                	addi	s0,sp,64
    8001c8ea:	fca43c23          	sd	a0,-40(s0)
    8001c8ee:	fcb43823          	sd	a1,-48(s0)
    8001c8f2:	87b2                	mv	a5,a2
    8001c8f4:	fcf41723          	sh	a5,-50(s0)
    uint64_t job_id = virtio_which_job_from_interrupt(dev);
    8001c8f8:	fd843503          	ld	a0,-40(s0)
    8001c8fc:	06e000ef          	jal	ra,8001c96a <virtio_which_job_from_interrupt>
    8001c900:	fea43423          	sd	a0,-24(s0)
    if (job_id == -1ULL) {
    8001c904:	fe843703          	ld	a4,-24(s0)
    8001c908:	57fd                	li	a5,-1
    8001c90a:	00f71963          	bne	a4,a5,8001c91c <virtio_handle_interrupt+0x3a>
        warnf("No job found matching interrupt\n");
    8001c90e:	0000c517          	auipc	a0,0xc
    8001c912:	e4a50513          	addi	a0,a0,-438 # 80028758 <pow10.0+0x18f8>
    8001c916:	d22ff0ef          	jal	ra,8001be38 <warnf>
        return;
    8001c91a:	a0a1                	j	8001c962 <virtio_handle_interrupt+0x80>
    }
    Job *job = virtio_get_job(dev, job_id);
    8001c91c:	fe843583          	ld	a1,-24(s0)
    8001c920:	fd843503          	ld	a0,-40(s0)
    8001c924:	ca3ff0ef          	jal	ra,8001c5c6 <virtio_get_job>
    8001c928:	fea43023          	sd	a0,-32(s0)
    if (job == NULL) {
    8001c92c:	fe043783          	ld	a5,-32(s0)
    8001c930:	eb91                	bnez	a5,8001c944 <virtio_handle_interrupt+0x62>
        warnf("No job found with ID %d\n", job_id);
    8001c932:	fe843583          	ld	a1,-24(s0)
    8001c936:	0000c517          	auipc	a0,0xc
    8001c93a:	e4a50513          	addi	a0,a0,-438 # 80028780 <pow10.0+0x1920>
    8001c93e:	cfaff0ef          	jal	ra,8001be38 <warnf>
        return;
    8001c942:	a005                	j	8001c962 <virtio_handle_interrupt+0x80>
    }
    job_set_context(job, desc, num_descriptors);
    8001c944:	fce45783          	lhu	a5,-50(s0)
    8001c948:	863e                	mv	a2,a5
    8001c94a:	fd043583          	ld	a1,-48(s0)
    8001c94e:	fe043503          	ld	a0,-32(s0)
    8001c952:	dadff0ef          	jal	ra,8001c6fe <job_set_context>

    virtio_complete_job(dev, job_id);
    8001c956:	fe843583          	ld	a1,-24(s0)
    8001c95a:	fd843503          	ld	a0,-40(s0)
    8001c95e:	0a0000ef          	jal	ra,8001c9fe <virtio_complete_job>
}
    8001c962:	70e2                	ld	ra,56(sp)
    8001c964:	7442                	ld	s0,48(sp)
    8001c966:	6121                	addi	sp,sp,64
    8001c968:	8082                	ret

000000008001c96a <virtio_which_job_from_interrupt>:

uint64_t virtio_which_job_from_interrupt(VirtioDevice *dev) {
    8001c96a:	1101                	addi	sp,sp,-32
    8001c96c:	ec22                	sd	s0,24(sp)
    8001c96e:	1000                	addi	s0,sp,32
    8001c970:	fea43423          	sd	a0,-24(s0)
    // Get the ID of the job from the descriptor
    return (uint64_t)dev->device_idx - 1;
    8001c974:	fe843783          	ld	a5,-24(s0)
    8001c978:	08c7d783          	lhu	a5,140(a5)
    8001c97c:	17fd                	addi	a5,a5,-1
}
    8001c97e:	853e                	mv	a0,a5
    8001c980:	6462                	ld	s0,24(sp)
    8001c982:	6105                	addi	sp,sp,32
    8001c984:	8082                	ret

000000008001c986 <virtio_get_job_id_by_index>:

uint64_t virtio_get_job_id_by_index(VirtioDevice *dev, uint64_t index) {
    8001c986:	7179                	addi	sp,sp,-48
    8001c988:	f406                	sd	ra,40(sp)
    8001c98a:	f022                	sd	s0,32(sp)
    8001c98c:	1800                	addi	s0,sp,48
    8001c98e:	fca43c23          	sd	a0,-40(s0)
    8001c992:	fcb43823          	sd	a1,-48(s0)
    Job *job = NULL;
    8001c996:	fe043423          	sd	zero,-24(s0)
    if (index >= vector_size(dev->jobs)) {
    8001c99a:	fd843783          	ld	a5,-40(s0)
    8001c99e:	63dc                	ld	a5,128(a5)
    8001c9a0:	853e                	mv	a0,a5
    8001c9a2:	44d060ef          	jal	ra,800235ee <vector_size>
    8001c9a6:	87aa                	mv	a5,a0
    8001c9a8:	2781                	sext.w	a5,a5
    8001c9aa:	1782                	slli	a5,a5,0x20
    8001c9ac:	9381                	srli	a5,a5,0x20
    8001c9ae:	fd043703          	ld	a4,-48(s0)
    8001c9b2:	00f76463          	bltu	a4,a5,8001c9ba <virtio_get_job_id_by_index+0x34>
        return -1ULL;
    8001c9b6:	57fd                	li	a5,-1
    8001c9b8:	a00d                	j	8001c9da <virtio_get_job_id_by_index+0x54>
    }

    vector_get_ptr(dev->jobs, index, &job);
    8001c9ba:	fd843783          	ld	a5,-40(s0)
    8001c9be:	63dc                	ld	a5,128(a5)
    8001c9c0:	fd043703          	ld	a4,-48(s0)
    8001c9c4:	2701                	sext.w	a4,a4
    8001c9c6:	fe840693          	addi	a3,s0,-24
    8001c9ca:	8636                	mv	a2,a3
    8001c9cc:	85ba                	mv	a1,a4
    8001c9ce:	853e                	mv	a0,a5
    8001c9d0:	4be060ef          	jal	ra,80022e8e <vector_get>
    return job->job_id;
    8001c9d4:	fe843783          	ld	a5,-24(s0)
    8001c9d8:	639c                	ld	a5,0(a5)
}
    8001c9da:	853e                	mv	a0,a5
    8001c9dc:	70a2                	ld	ra,40(sp)
    8001c9de:	7402                	ld	s0,32(sp)
    8001c9e0:	6145                	addi	sp,sp,48
    8001c9e2:	8082                	ret

000000008001c9e4 <virtio_get_next_job_id>:

uint64_t virtio_get_next_job_id(VirtioDevice *dev) {
    8001c9e4:	1101                	addi	sp,sp,-32
    8001c9e6:	ec22                	sd	s0,24(sp)
    8001c9e8:	1000                	addi	s0,sp,32
    8001c9ea:	fea43423          	sd	a0,-24(s0)
    return (uint64_t)dev->device_idx;
    8001c9ee:	fe843783          	ld	a5,-24(s0)
    8001c9f2:	08c7d783          	lhu	a5,140(a5)
}
    8001c9f6:	853e                	mv	a0,a5
    8001c9f8:	6462                	ld	s0,24(sp)
    8001c9fa:	6105                	addi	sp,sp,32
    8001c9fc:	8082                	ret

000000008001c9fe <virtio_complete_job>:

void virtio_complete_job(VirtioDevice *dev, uint64_t job_id) {
    8001c9fe:	7179                	addi	sp,sp,-48
    8001ca00:	f406                	sd	ra,40(sp)
    8001ca02:	f022                	sd	s0,32(sp)
    8001ca04:	1800                	addi	s0,sp,48
    8001ca06:	fca43c23          	sd	a0,-40(s0)
    8001ca0a:	fcb43823          	sd	a1,-48(s0)
    virtio_acquire_device(dev);
    8001ca0e:	fd843503          	ld	a0,-40(s0)
    8001ca12:	dddff0ef          	jal	ra,8001c7ee <virtio_acquire_device>
    Job *job = virtio_get_job(dev, job_id);
    8001ca16:	fd043583          	ld	a1,-48(s0)
    8001ca1a:	fd843503          	ld	a0,-40(s0)
    8001ca1e:	ba9ff0ef          	jal	ra,8001c5c6 <virtio_get_job>
    8001ca22:	fea43423          	sd	a0,-24(s0)
    if (job == NULL) {
    8001ca26:	fe843783          	ld	a5,-24(s0)
    8001ca2a:	ef91                	bnez	a5,8001ca46 <virtio_complete_job+0x48>
        warnf("No job found with ID %d\n", job_id);
    8001ca2c:	fd043583          	ld	a1,-48(s0)
    8001ca30:	0000c517          	auipc	a0,0xc
    8001ca34:	d5050513          	addi	a0,a0,-688 # 80028780 <pow10.0+0x1920>
    8001ca38:	c00ff0ef          	jal	ra,8001be38 <warnf>
        virtio_release_device(dev);
    8001ca3c:	fd843503          	ld	a0,-40(s0)
    8001ca40:	de5ff0ef          	jal	ra,8001c824 <virtio_release_device>
        return;
    8001ca44:	a899                	j	8001ca9a <virtio_complete_job+0x9c>
    }

    if (job->done) {
    8001ca46:	fe843783          	ld	a5,-24(s0)
    8001ca4a:	0107c783          	lbu	a5,16(a5)
    8001ca4e:	cf91                	beqz	a5,8001ca6a <virtio_complete_job+0x6c>
        warnf("Job %d already done\n", job_id);
    8001ca50:	fd043583          	ld	a1,-48(s0)
    8001ca54:	0000c517          	auipc	a0,0xc
    8001ca58:	d4c50513          	addi	a0,a0,-692 # 800287a0 <pow10.0+0x1940>
    8001ca5c:	bdcff0ef          	jal	ra,8001be38 <warnf>
        virtio_release_device(dev);
    8001ca60:	fd843503          	ld	a0,-40(s0)
    8001ca64:	dc1ff0ef          	jal	ra,8001c824 <virtio_release_device>
        return;
    8001ca68:	a80d                	j	8001ca9a <virtio_complete_job+0x9c>
    }
    virtio_callback_and_free_job(dev, job_id);
    8001ca6a:	fd043583          	ld	a1,-48(s0)
    8001ca6e:	fd843503          	ld	a0,-40(s0)
    8001ca72:	cffff0ef          	jal	ra,8001c770 <virtio_callback_and_free_job>
    if (job->done) {
    8001ca76:	fe843783          	ld	a5,-24(s0)
    8001ca7a:	0107c783          	lbu	a5,16(a5)
    8001ca7e:	cb91                	beqz	a5,8001ca92 <virtio_complete_job+0x94>
        debugf("Job %d done\n", job_id);
        vector_remove_val_ptr(dev->jobs, job);
    8001ca80:	fd843783          	ld	a5,-40(s0)
    8001ca84:	63dc                	ld	a5,128(a5)
    8001ca86:	fe843703          	ld	a4,-24(s0)
    8001ca8a:	85ba                	mv	a1,a4
    8001ca8c:	853e                	mv	a0,a5
    8001ca8e:	76c060ef          	jal	ra,800231fa <vector_remove_value>
    } else {
        debugf("Job %d not done\n", job_id);
    }

    virtio_release_device(dev);
    8001ca92:	fd843503          	ld	a0,-40(s0)
    8001ca96:	d8fff0ef          	jal	ra,8001c824 <virtio_release_device>
}
    8001ca9a:	70a2                	ld	ra,40(sp)
    8001ca9c:	7402                	ld	s0,32(sp)
    8001ca9e:	6145                	addi	sp,sp,48
    8001caa0:	8082                	ret

000000008001caa2 <virtio_get_block_config>:

volatile struct VirtioBlockConfig *virtio_get_block_config(VirtioDevice *device) {
    8001caa2:	1101                	addi	sp,sp,-32
    8001caa4:	ec06                	sd	ra,24(sp)
    8001caa6:	e822                	sd	s0,16(sp)
    8001caa8:	1000                	addi	s0,sp,32
    8001caaa:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioBlockConfig *)pci_get_device_specific_config(device->pcidev);
    8001caae:	fe843783          	ld	a5,-24(s0)
    8001cab2:	63bc                	ld	a5,64(a5)
    8001cab4:	853e                	mv	a0,a5
    8001cab6:	9edf70ef          	jal	ra,800144a2 <pci_get_device_specific_config>
    8001caba:	87aa                	mv	a5,a0
}
    8001cabc:	853e                	mv	a0,a5
    8001cabe:	60e2                	ld	ra,24(sp)
    8001cac0:	6442                	ld	s0,16(sp)
    8001cac2:	6105                	addi	sp,sp,32
    8001cac4:	8082                	ret

000000008001cac6 <virtio_get_input_config>:

volatile struct VirtioInputConfig *virtio_get_input_config(VirtioDevice *device) {
    8001cac6:	1101                	addi	sp,sp,-32
    8001cac8:	ec06                	sd	ra,24(sp)
    8001caca:	e822                	sd	s0,16(sp)
    8001cacc:	1000                	addi	s0,sp,32
    8001cace:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioInputConfig *)pci_get_device_specific_config(device->pcidev);
    8001cad2:	fe843783          	ld	a5,-24(s0)
    8001cad6:	63bc                	ld	a5,64(a5)
    8001cad8:	853e                	mv	a0,a5
    8001cada:	9c9f70ef          	jal	ra,800144a2 <pci_get_device_specific_config>
    8001cade:	87aa                	mv	a5,a0
}
    8001cae0:	853e                	mv	a0,a5
    8001cae2:	60e2                	ld	ra,24(sp)
    8001cae4:	6442                	ld	s0,16(sp)
    8001cae6:	6105                	addi	sp,sp,32
    8001cae8:	8082                	ret

000000008001caea <virtio_get_gpu_config>:

volatile struct VirtioGpuConfig *virtio_get_gpu_config(VirtioDevice *device) {
    8001caea:	1101                	addi	sp,sp,-32
    8001caec:	ec06                	sd	ra,24(sp)
    8001caee:	e822                	sd	s0,16(sp)
    8001caf0:	1000                	addi	s0,sp,32
    8001caf2:	fea43423          	sd	a0,-24(s0)
    return (volatile struct VirtioGpuConfig *)pci_get_device_specific_config(device->pcidev);
    8001caf6:	fe843783          	ld	a5,-24(s0)
    8001cafa:	63bc                	ld	a5,64(a5)
    8001cafc:	853e                	mv	a0,a5
    8001cafe:	9a5f70ef          	jal	ra,800144a2 <pci_get_device_specific_config>
    8001cb02:	87aa                	mv	a5,a0
}
    8001cb04:	853e                	mv	a0,a5
    8001cb06:	60e2                	ld	ra,24(sp)
    8001cb08:	6442                	ld	s0,16(sp)
    8001cb0a:	6105                	addi	sp,sp,32
    8001cb0c:	8082                	ret

000000008001cb0e <virtio_get_device_id>:

uint16_t virtio_get_device_id(VirtioDevice *dev) {
    8001cb0e:	1101                	addi	sp,sp,-32
    8001cb10:	ec22                	sd	s0,24(sp)
    8001cb12:	1000                	addi	s0,sp,32
    8001cb14:	fea43423          	sd	a0,-24(s0)
    return dev->pcidev->ecam_header->device_id;
    8001cb18:	fe843783          	ld	a5,-24(s0)
    8001cb1c:	63bc                	ld	a5,64(a5)
    8001cb1e:	639c                	ld	a5,0(a5)
    8001cb20:	0027d783          	lhu	a5,2(a5)
    8001cb24:	17c2                	slli	a5,a5,0x30
    8001cb26:	93c1                	srli	a5,a5,0x30
}
    8001cb28:	853e                	mv	a0,a5
    8001cb2a:	6462                	ld	s0,24(sp)
    8001cb2c:	6105                	addi	sp,sp,32
    8001cb2e:	8082                	ret

000000008001cb30 <virtio_is_rng_device>:

bool virtio_is_rng_device(VirtioDevice *dev) {
    8001cb30:	1101                	addi	sp,sp,-32
    8001cb32:	ec06                	sd	ra,24(sp)
    8001cb34:	e822                	sd	s0,16(sp)
    8001cb36:	1000                	addi	s0,sp,32
    8001cb38:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_ENTROPY);
    8001cb3c:	fe843503          	ld	a0,-24(s0)
    8001cb40:	fcfff0ef          	jal	ra,8001cb0e <virtio_get_device_id>
    8001cb44:	87aa                	mv	a5,a0
    8001cb46:	0007871b          	sext.w	a4,a5
    8001cb4a:	6785                	lui	a5,0x1
    8001cb4c:	04478793          	addi	a5,a5,68 # 1044 <i+0x1024>
    8001cb50:	40f707b3          	sub	a5,a4,a5
    8001cb54:	0017b793          	seqz	a5,a5
    8001cb58:	0ff7f793          	andi	a5,a5,255
}
    8001cb5c:	853e                	mv	a0,a5
    8001cb5e:	60e2                	ld	ra,24(sp)
    8001cb60:	6442                	ld	s0,16(sp)
    8001cb62:	6105                	addi	sp,sp,32
    8001cb64:	8082                	ret

000000008001cb66 <virtio_is_block_device>:

bool virtio_is_block_device(VirtioDevice *dev) {
    8001cb66:	1101                	addi	sp,sp,-32
    8001cb68:	ec06                	sd	ra,24(sp)
    8001cb6a:	e822                	sd	s0,16(sp)
    8001cb6c:	1000                	addi	s0,sp,32
    8001cb6e:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_BLOCK);
    8001cb72:	fe843503          	ld	a0,-24(s0)
    8001cb76:	f99ff0ef          	jal	ra,8001cb0e <virtio_get_device_id>
    8001cb7a:	87aa                	mv	a5,a0
    8001cb7c:	0007871b          	sext.w	a4,a5
    8001cb80:	6785                	lui	a5,0x1
    8001cb82:	04278793          	addi	a5,a5,66 # 1042 <i+0x1022>
    8001cb86:	40f707b3          	sub	a5,a4,a5
    8001cb8a:	0017b793          	seqz	a5,a5
    8001cb8e:	0ff7f793          	andi	a5,a5,255
}
    8001cb92:	853e                	mv	a0,a5
    8001cb94:	60e2                	ld	ra,24(sp)
    8001cb96:	6442                	ld	s0,16(sp)
    8001cb98:	6105                	addi	sp,sp,32
    8001cb9a:	8082                	ret

000000008001cb9c <virtio_is_input_device>:

bool virtio_is_input_device(VirtioDevice *dev) {
    8001cb9c:	1101                	addi	sp,sp,-32
    8001cb9e:	ec06                	sd	ra,24(sp)
    8001cba0:	e822                	sd	s0,16(sp)
    8001cba2:	1000                	addi	s0,sp,32
    8001cba4:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_INPUT);
    8001cba8:	fe843503          	ld	a0,-24(s0)
    8001cbac:	f63ff0ef          	jal	ra,8001cb0e <virtio_get_device_id>
    8001cbb0:	87aa                	mv	a5,a0
    8001cbb2:	0007871b          	sext.w	a4,a5
    8001cbb6:	6785                	lui	a5,0x1
    8001cbb8:	05278793          	addi	a5,a5,82 # 1052 <i+0x1032>
    8001cbbc:	40f707b3          	sub	a5,a4,a5
    8001cbc0:	0017b793          	seqz	a5,a5
    8001cbc4:	0ff7f793          	andi	a5,a5,255
}
    8001cbc8:	853e                	mv	a0,a5
    8001cbca:	60e2                	ld	ra,24(sp)
    8001cbcc:	6442                	ld	s0,16(sp)
    8001cbce:	6105                	addi	sp,sp,32
    8001cbd0:	8082                	ret

000000008001cbd2 <virtio_is_gpu_device>:

bool virtio_is_gpu_device(VirtioDevice *dev) {
    8001cbd2:	1101                	addi	sp,sp,-32
    8001cbd4:	ec06                	sd	ra,24(sp)
    8001cbd6:	e822                	sd	s0,16(sp)
    8001cbd8:	1000                	addi	s0,sp,32
    8001cbda:	fea43423          	sd	a0,-24(s0)
    return virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_GPU);
    8001cbde:	fe843503          	ld	a0,-24(s0)
    8001cbe2:	f2dff0ef          	jal	ra,8001cb0e <virtio_get_device_id>
    8001cbe6:	87aa                	mv	a5,a0
    8001cbe8:	0007871b          	sext.w	a4,a5
    8001cbec:	6785                	lui	a5,0x1
    8001cbee:	05078793          	addi	a5,a5,80 # 1050 <i+0x1030>
    8001cbf2:	40f707b3          	sub	a5,a4,a5
    8001cbf6:	0017b793          	seqz	a5,a5
    8001cbfa:	0ff7f793          	andi	a5,a5,255
}
    8001cbfe:	853e                	mv	a0,a5
    8001cc00:	60e2                	ld	ra,24(sp)
    8001cc02:	6442                	ld	s0,16(sp)
    8001cc04:	6105                	addi	sp,sp,32
    8001cc06:	8082                	ret

000000008001cc08 <virtio_get_queue_size>:

uint16_t virtio_get_queue_size(VirtioDevice *dev) {
    8001cc08:	1101                	addi	sp,sp,-32
    8001cc0a:	ec22                	sd	s0,24(sp)
    8001cc0c:	1000                	addi	s0,sp,32
    8001cc0e:	fea43423          	sd	a0,-24(s0)
    return dev->common_cfg->queue_size;
    8001cc12:	fe843783          	ld	a5,-24(s0)
    8001cc16:	67bc                	ld	a5,72(a5)
    8001cc18:	0187d783          	lhu	a5,24(a5)
    8001cc1c:	17c2                	slli	a5,a5,0x30
    8001cc1e:	93c1                	srli	a5,a5,0x30
}
    8001cc20:	853e                	mv	a0,a5
    8001cc22:	6462                	ld	s0,24(sp)
    8001cc24:	6105                	addi	sp,sp,32
    8001cc26:	8082                	ret

000000008001cc28 <virtio_get_device>:

VirtioDevice *virtio_get_device(uint16_t device_type, uint16_t n) {
    8001cc28:	7139                	addi	sp,sp,-64
    8001cc2a:	fc06                	sd	ra,56(sp)
    8001cc2c:	f822                	sd	s0,48(sp)
    8001cc2e:	f426                	sd	s1,40(sp)
    8001cc30:	0080                	addi	s0,sp,64
    8001cc32:	87aa                	mv	a5,a0
    8001cc34:	872e                	mv	a4,a1
    8001cc36:	fcf41723          	sh	a5,-50(s0)
    8001cc3a:	87ba                	mv	a5,a4
    8001cc3c:	fcf41623          	sh	a5,-52(s0)
    uint16_t count = 0;
    8001cc40:	fc041f23          	sh	zero,-34(s0)
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001cc44:	fc041e23          	sh	zero,-36(s0)
    8001cc48:	a8b9                	j	8001cca6 <virtio_get_device+0x7e>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001cc4a:	fdc45783          	lhu	a5,-36(s0)
    8001cc4e:	853e                	mv	a0,a5
    8001cc50:	16c000ef          	jal	ra,8001cdbc <virtio_get_nth_saved_device>
    8001cc54:	fca43823          	sd	a0,-48(s0)
        if (virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(device_type) && count++ == n) {
    8001cc58:	fd043503          	ld	a0,-48(s0)
    8001cc5c:	eb3ff0ef          	jal	ra,8001cb0e <virtio_get_device_id>
    8001cc60:	87aa                	mv	a5,a0
    8001cc62:	0007869b          	sext.w	a3,a5
    8001cc66:	fce45783          	lhu	a5,-50(s0)
    8001cc6a:	0007871b          	sext.w	a4,a5
    8001cc6e:	6785                	lui	a5,0x1
    8001cc70:	0407879b          	addiw	a5,a5,64
    8001cc74:	9fb9                	addw	a5,a5,a4
    8001cc76:	2781                	sext.w	a5,a5
    8001cc78:	8736                	mv	a4,a3
    8001cc7a:	02f71163          	bne	a4,a5,8001cc9c <virtio_get_device+0x74>
    8001cc7e:	fde45783          	lhu	a5,-34(s0)
    8001cc82:	0017871b          	addiw	a4,a5,1
    8001cc86:	fce41f23          	sh	a4,-34(s0)
    8001cc8a:	fcc45703          	lhu	a4,-52(s0)
    8001cc8e:	2701                	sext.w	a4,a4
    8001cc90:	2781                	sext.w	a5,a5
    8001cc92:	00f71563          	bne	a4,a5,8001cc9c <virtio_get_device+0x74>
            return dev;
    8001cc96:	fd043783          	ld	a5,-48(s0)
    8001cc9a:	a825                	j	8001ccd2 <virtio_get_device+0xaa>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001cc9c:	fdc45783          	lhu	a5,-36(s0)
    8001cca0:	2785                	addiw	a5,a5,1
    8001cca2:	fcf41e23          	sh	a5,-36(s0)
    8001cca6:	fdc45483          	lhu	s1,-36(s0)
    8001ccaa:	212000ef          	jal	ra,8001cebc <virtio_count_saved_devices>
    8001ccae:	87aa                	mv	a5,a0
    8001ccb0:	f8f4ede3          	bltu	s1,a5,8001cc4a <virtio_get_device+0x22>
        }
    }

    warnf("Device #%d with PCI ID=%d could not be found\n", n, device_type);
    8001ccb4:	fcc45783          	lhu	a5,-52(s0)
    8001ccb8:	2781                	sext.w	a5,a5
    8001ccba:	fce45703          	lhu	a4,-50(s0)
    8001ccbe:	2701                	sext.w	a4,a4
    8001ccc0:	863a                	mv	a2,a4
    8001ccc2:	85be                	mv	a1,a5
    8001ccc4:	0000c517          	auipc	a0,0xc
    8001ccc8:	af450513          	addi	a0,a0,-1292 # 800287b8 <pow10.0+0x1958>
    8001cccc:	96cff0ef          	jal	ra,8001be38 <warnf>
    return NULL;
    8001ccd0:	4781                	li	a5,0
}
    8001ccd2:	853e                	mv	a0,a5
    8001ccd4:	70e2                	ld	ra,56(sp)
    8001ccd6:	7442                	ld	s0,48(sp)
    8001ccd8:	74a2                	ld	s1,40(sp)
    8001ccda:	6121                	addi	sp,sp,64
    8001ccdc:	8082                	ret

000000008001ccde <virtio_get_rng_device>:

VirtioDevice *virtio_get_rng_device(void) {
    8001ccde:	1141                	addi	sp,sp,-16
    8001cce0:	e406                	sd	ra,8(sp)
    8001cce2:	e022                	sd	s0,0(sp)
    8001cce4:	0800                	addi	s0,sp,16
    debugf("Getting RNG device\n");
    return virtio_get_device(VIRTIO_PCI_DEVICE_ENTROPY, 0);
    8001cce6:	4581                	li	a1,0
    8001cce8:	4511                	li	a0,4
    8001ccea:	f3fff0ef          	jal	ra,8001cc28 <virtio_get_device>
    8001ccee:	87aa                	mv	a5,a0
}
    8001ccf0:	853e                	mv	a0,a5
    8001ccf2:	60a2                	ld	ra,8(sp)
    8001ccf4:	6402                	ld	s0,0(sp)
    8001ccf6:	0141                	addi	sp,sp,16
    8001ccf8:	8082                	ret

000000008001ccfa <virtio_get_block_device>:

VirtioDevice *virtio_get_block_device(uint16_t n) {
    8001ccfa:	7179                	addi	sp,sp,-48
    8001ccfc:	f406                	sd	ra,40(sp)
    8001ccfe:	f022                	sd	s0,32(sp)
    8001cd00:	1800                	addi	s0,sp,48
    8001cd02:	87aa                	mv	a5,a0
    8001cd04:	fcf41f23          	sh	a5,-34(s0)
    debugf("Getting block device %d\n", n);
    VirtioDevice *result = virtio_get_device(VIRTIO_PCI_DEVICE_BLOCK, n);
    8001cd08:	fde45783          	lhu	a5,-34(s0)
    8001cd0c:	85be                	mv	a1,a5
    8001cd0e:	4509                	li	a0,2
    8001cd10:	f19ff0ef          	jal	ra,8001cc28 <virtio_get_device>
    8001cd14:	fea43423          	sd	a0,-24(s0)
    if (result == NULL) {
    8001cd18:	fe843783          	ld	a5,-24(s0)
    8001cd1c:	eb99                	bnez	a5,8001cd32 <virtio_get_block_device+0x38>
        warnf("No block device #%d\n", n);
    8001cd1e:	fde45783          	lhu	a5,-34(s0)
    8001cd22:	2781                	sext.w	a5,a5
    8001cd24:	85be                	mv	a1,a5
    8001cd26:	0000c517          	auipc	a0,0xc
    8001cd2a:	ac250513          	addi	a0,a0,-1342 # 800287e8 <pow10.0+0x1988>
    8001cd2e:	90aff0ef          	jal	ra,8001be38 <warnf>
    }
    return result;
    8001cd32:	fe843783          	ld	a5,-24(s0)
}
    8001cd36:	853e                	mv	a0,a5
    8001cd38:	70a2                	ld	ra,40(sp)
    8001cd3a:	7402                	ld	s0,32(sp)
    8001cd3c:	6145                	addi	sp,sp,48
    8001cd3e:	8082                	ret

000000008001cd40 <virtio_get_input_device>:

VirtioDevice *virtio_get_input_device(uint16_t n) {
    8001cd40:	7179                	addi	sp,sp,-48
    8001cd42:	f406                	sd	ra,40(sp)
    8001cd44:	f022                	sd	s0,32(sp)
    8001cd46:	1800                	addi	s0,sp,48
    8001cd48:	87aa                	mv	a5,a0
    8001cd4a:	fcf41f23          	sh	a5,-34(s0)
    debugf("Getting input device %d\n", n);
    VirtioDevice *result = virtio_get_device(VIRTIO_PCI_DEVICE_INPUT, n);
    8001cd4e:	fde45783          	lhu	a5,-34(s0)
    8001cd52:	85be                	mv	a1,a5
    8001cd54:	4549                	li	a0,18
    8001cd56:	ed3ff0ef          	jal	ra,8001cc28 <virtio_get_device>
    8001cd5a:	fea43423          	sd	a0,-24(s0)
    if (result == NULL) {
    8001cd5e:	fe843783          	ld	a5,-24(s0)
    8001cd62:	eb99                	bnez	a5,8001cd78 <virtio_get_input_device+0x38>
        warnf("No input device #%d\n", n);
    8001cd64:	fde45783          	lhu	a5,-34(s0)
    8001cd68:	2781                	sext.w	a5,a5
    8001cd6a:	85be                	mv	a1,a5
    8001cd6c:	0000c517          	auipc	a0,0xc
    8001cd70:	a9450513          	addi	a0,a0,-1388 # 80028800 <pow10.0+0x19a0>
    8001cd74:	8c4ff0ef          	jal	ra,8001be38 <warnf>
    }
    return result;
    8001cd78:	fe843783          	ld	a5,-24(s0)
}
    8001cd7c:	853e                	mv	a0,a5
    8001cd7e:	70a2                	ld	ra,40(sp)
    8001cd80:	7402                	ld	s0,32(sp)
    8001cd82:	6145                	addi	sp,sp,48
    8001cd84:	8082                	ret

000000008001cd86 <virtio_get_gpu_device>:

VirtioDevice *virtio_get_gpu_device(void) {
    8001cd86:	1101                	addi	sp,sp,-32
    8001cd88:	ec06                	sd	ra,24(sp)
    8001cd8a:	e822                	sd	s0,16(sp)
    8001cd8c:	1000                	addi	s0,sp,32
    // return virtio_get_device(VIRTIO_PCI_DEVICE_GPU, 0);
    debugf("Getting GPU device %d\n", 0);
    VirtioDevice *result = virtio_get_device(VIRTIO_PCI_DEVICE_GPU, 0);
    8001cd8e:	4581                	li	a1,0
    8001cd90:	4541                	li	a0,16
    8001cd92:	e97ff0ef          	jal	ra,8001cc28 <virtio_get_device>
    8001cd96:	fea43423          	sd	a0,-24(s0)
    if (result == NULL) {
    8001cd9a:	fe843783          	ld	a5,-24(s0)
    8001cd9e:	eb81                	bnez	a5,8001cdae <virtio_get_gpu_device+0x28>
        warnf("No GPU device #%d\n", 0);
    8001cda0:	4581                	li	a1,0
    8001cda2:	0000c517          	auipc	a0,0xc
    8001cda6:	a7650513          	addi	a0,a0,-1418 # 80028818 <pow10.0+0x19b8>
    8001cdaa:	88eff0ef          	jal	ra,8001be38 <warnf>
    }
    return result;
    8001cdae:	fe843783          	ld	a5,-24(s0)
}
    8001cdb2:	853e                	mv	a0,a5
    8001cdb4:	60e2                	ld	ra,24(sp)
    8001cdb6:	6442                	ld	s0,16(sp)
    8001cdb8:	6105                	addi	sp,sp,32
    8001cdba:	8082                	ret

000000008001cdbc <virtio_get_nth_saved_device>:

VirtioDevice *virtio_get_nth_saved_device(uint16_t n) {
    8001cdbc:	7179                	addi	sp,sp,-48
    8001cdbe:	f406                	sd	ra,40(sp)
    8001cdc0:	f022                	sd	s0,32(sp)
    8001cdc2:	1800                	addi	s0,sp,48
    8001cdc4:	87aa                	mv	a5,a0
    8001cdc6:	fcf41f23          	sh	a5,-34(s0)
    VirtioDevice *result;
    vector_get_ptr(virtio_devices, n, &result);
    8001cdca:	00008797          	auipc	a5,0x8
    8001cdce:	38678793          	addi	a5,a5,902 # 80025150 <virtio_devices>
    8001cdd2:	639c                	ld	a5,0(a5)
    8001cdd4:	fde45703          	lhu	a4,-34(s0)
    8001cdd8:	2701                	sext.w	a4,a4
    8001cdda:	fe840693          	addi	a3,s0,-24
    8001cdde:	8636                	mv	a2,a3
    8001cde0:	85ba                	mv	a1,a4
    8001cde2:	853e                	mv	a0,a5
    8001cde4:	0aa060ef          	jal	ra,80022e8e <vector_get>
    return result;
    8001cde8:	fe843783          	ld	a5,-24(s0)
}
    8001cdec:	853e                	mv	a0,a5
    8001cdee:	70a2                	ld	ra,40(sp)
    8001cdf0:	7402                	ld	s0,32(sp)
    8001cdf2:	6145                	addi	sp,sp,48
    8001cdf4:	8082                	ret

000000008001cdf6 <virtio_save_device>:

void virtio_save_device(VirtioDevice device) {
    8001cdf6:	7179                	addi	sp,sp,-48
    8001cdf8:	f406                	sd	ra,40(sp)
    8001cdfa:	f022                	sd	s0,32(sp)
    8001cdfc:	ec26                	sd	s1,24(sp)
    8001cdfe:	1800                	addi	s0,sp,48
    8001ce00:	84aa                	mv	s1,a0
    VirtioDevice *mem = (VirtioDevice *)kzalloc(sizeof(VirtioDevice));
    8001ce02:	09800593          	li	a1,152
    8001ce06:	4505                	li	a0,1
    8001ce08:	f4af80ef          	jal	ra,80015552 <kcalloc>
    8001ce0c:	fca43c23          	sd	a0,-40(s0)
    memcpy(mem, &device, sizeof(VirtioDevice));
    8001ce10:	09800613          	li	a2,152
    8001ce14:	85a6                	mv	a1,s1
    8001ce16:	fd843503          	ld	a0,-40(s0)
    8001ce1a:	524050ef          	jal	ra,8002233e <memcpy>
    vector_push_ptr(virtio_devices, mem);
    8001ce1e:	00008797          	auipc	a5,0x8
    8001ce22:	33278793          	addi	a5,a5,818 # 80025150 <virtio_devices>
    8001ce26:	639c                	ld	a5,0(a5)
    8001ce28:	fd843703          	ld	a4,-40(s0)
    8001ce2c:	85ba                	mv	a1,a4
    8001ce2e:	853e                	mv	a0,a5
    8001ce30:	6ff050ef          	jal	ra,80022d2e <vector_push>
}
    8001ce34:	0001                	nop
    8001ce36:	70a2                	ld	ra,40(sp)
    8001ce38:	7402                	ld	s0,32(sp)
    8001ce3a:	64e2                	ld	s1,24(sp)
    8001ce3c:	6145                	addi	sp,sp,48
    8001ce3e:	8082                	ret

000000008001ce40 <virtio_from_pci_device>:

VirtioDevice *virtio_from_pci_device(PCIDevice *pcidevice) {
    8001ce40:	7179                	addi	sp,sp,-48
    8001ce42:	f406                	sd	ra,40(sp)
    8001ce44:	f022                	sd	s0,32(sp)
    8001ce46:	1800                	addi	s0,sp,48
    8001ce48:	fca43c23          	sd	a0,-40(s0)
    for(uint32_t i = 0; i < vector_size(virtio_devices);i++){
    8001ce4c:	fe042623          	sw	zero,-20(s0)
    8001ce50:	a081                	j	8001ce90 <virtio_from_pci_device+0x50>
        VirtioDevice *curr_virt_device = NULL;
    8001ce52:	fe043023          	sd	zero,-32(s0)
        vector_get_ptr(virtio_devices, i, &curr_virt_device);
    8001ce56:	00008797          	auipc	a5,0x8
    8001ce5a:	2fa78793          	addi	a5,a5,762 # 80025150 <virtio_devices>
    8001ce5e:	639c                	ld	a5,0(a5)
    8001ce60:	fe040693          	addi	a3,s0,-32
    8001ce64:	fec42703          	lw	a4,-20(s0)
    8001ce68:	8636                	mv	a2,a3
    8001ce6a:	85ba                	mv	a1,a4
    8001ce6c:	853e                	mv	a0,a5
    8001ce6e:	020060ef          	jal	ra,80022e8e <vector_get>
        if(curr_virt_device->pcidev == pcidevice) {
    8001ce72:	fe043783          	ld	a5,-32(s0)
    8001ce76:	63bc                	ld	a5,64(a5)
    8001ce78:	fd843703          	ld	a4,-40(s0)
    8001ce7c:	00f71563          	bne	a4,a5,8001ce86 <virtio_from_pci_device+0x46>
            return curr_virt_device;
    8001ce80:	fe043783          	ld	a5,-32(s0)
    8001ce84:	a03d                	j	8001ceb2 <virtio_from_pci_device+0x72>
    for(uint32_t i = 0; i < vector_size(virtio_devices);i++){
    8001ce86:	fec42783          	lw	a5,-20(s0)
    8001ce8a:	2785                	addiw	a5,a5,1
    8001ce8c:	fef42623          	sw	a5,-20(s0)
    8001ce90:	00008797          	auipc	a5,0x8
    8001ce94:	2c078793          	addi	a5,a5,704 # 80025150 <virtio_devices>
    8001ce98:	639c                	ld	a5,0(a5)
    8001ce9a:	853e                	mv	a0,a5
    8001ce9c:	752060ef          	jal	ra,800235ee <vector_size>
    8001cea0:	87aa                	mv	a5,a0
    8001cea2:	0007871b          	sext.w	a4,a5
    8001cea6:	fec42783          	lw	a5,-20(s0)
    8001ceaa:	2781                	sext.w	a5,a5
    8001ceac:	fae7e3e3          	bltu	a5,a4,8001ce52 <virtio_from_pci_device+0x12>
        }
    }
    return NULL;
    8001ceb0:	4781                	li	a5,0
}
    8001ceb2:	853e                	mv	a0,a5
    8001ceb4:	70a2                	ld	ra,40(sp)
    8001ceb6:	7402                	ld	s0,32(sp)
    8001ceb8:	6145                	addi	sp,sp,48
    8001ceba:	8082                	ret

000000008001cebc <virtio_count_saved_devices>:

// Get the number of saved Virtio devices.
uint64_t virtio_count_saved_devices(void) {
    8001cebc:	1141                	addi	sp,sp,-16
    8001cebe:	e406                	sd	ra,8(sp)
    8001cec0:	e022                	sd	s0,0(sp)
    8001cec2:	0800                	addi	s0,sp,16
    return vector_size(virtio_devices);
    8001cec4:	00008797          	auipc	a5,0x8
    8001cec8:	28c78793          	addi	a5,a5,652 # 80025150 <virtio_devices>
    8001cecc:	639c                	ld	a5,0(a5)
    8001cece:	853e                	mv	a0,a5
    8001ced0:	71e060ef          	jal	ra,800235ee <vector_size>
    8001ced4:	87aa                	mv	a5,a0
    8001ced6:	2781                	sext.w	a5,a5
    8001ced8:	1782                	slli	a5,a5,0x20
    8001ceda:	9381                	srli	a5,a5,0x20
}
    8001cedc:	853e                	mv	a0,a5
    8001cede:	60a2                	ld	ra,8(sp)
    8001cee0:	6402                	ld	s0,0(sp)
    8001cee2:	0141                	addi	sp,sp,16
    8001cee4:	8082                	ret

000000008001cee6 <virtio_get_capability>:

// Get a virtio capability for a given device by the virtio capability's type.
// If this is zero, it will get the common configuration capability. If this is
// one, it will get the notify capability. If this is two, it will get the ISR
// capability. Etc.
volatile struct VirtioCapability *virtio_get_capability(VirtioDevice *dev, uint8_t type) {
    8001cee6:	1101                	addi	sp,sp,-32
    8001cee8:	ec06                	sd	ra,24(sp)
    8001ceea:	e822                	sd	s0,16(sp)
    8001ceec:	1000                	addi	s0,sp,32
    8001ceee:	fea43423          	sd	a0,-24(s0)
    8001cef2:	87ae                	mv	a5,a1
    8001cef4:	fef403a3          	sb	a5,-25(s0)
    return pci_get_virtio_capability(dev->pcidev, type);
    8001cef8:	fe843783          	ld	a5,-24(s0)
    8001cefc:	63bc                	ld	a5,64(a5)
    8001cefe:	fe744703          	lbu	a4,-25(s0)
    8001cf02:	85ba                	mv	a1,a4
    8001cf04:	853e                	mv	a0,a5
    8001cf06:	a80f70ef          	jal	ra,80014186 <pci_get_virtio_capability>
    8001cf0a:	87aa                	mv	a5,a0
}
    8001cf0c:	853e                	mv	a0,a5
    8001cf0e:	60e2                	ld	ra,24(sp)
    8001cf10:	6442                	ld	s0,16(sp)
    8001cf12:	6105                	addi	sp,sp,32
    8001cf14:	8082                	ret

000000008001cf16 <virtio_init>:
/**
 * @brief Initialize the virtio system
 */


void virtio_init(void) {
    8001cf16:	7161                	addi	sp,sp,-432
    8001cf18:	f706                	sd	ra,424(sp)
    8001cf1a:	f322                	sd	s0,416(sp)
    8001cf1c:	ef26                	sd	s1,408(sp)
    8001cf1e:	1b00                	addi	s0,sp,432
    debugf("virtio_init: Initializing virtio system...\n");
    // Initialize the vector of virtio devices
    virtio_devices = vector_new();
    8001cf20:	56f050ef          	jal	ra,80022c8e <vector_new>
    8001cf24:	872a                	mv	a4,a0
    8001cf26:	00008797          	auipc	a5,0x8
    8001cf2a:	22a78793          	addi	a5,a5,554 # 80025150 <virtio_devices>
    8001cf2e:	e398                	sd	a4,0(a5)

    // Get the number of PCI devices saved
    // This will allow us to iterate through all of them and find the virtio devices
    uint64_t num_pci_devices = pci_count_saved_devices();
    8001cf30:	ad2f70ef          	jal	ra,80014202 <pci_count_saved_devices>
    8001cf34:	fca43423          	sd	a0,-56(s0)
    
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    8001cf38:	fc043c23          	sd	zero,-40(s0)
    8001cf3c:	acc1                	j	8001d20c <virtio_init+0x2f6>
        // Get the PCI device
        PCIDevice *pcidevice = pci_get_nth_saved_device(i);
    8001cf3e:	fd843783          	ld	a5,-40(s0)
    8001cf42:	17c2                	slli	a5,a5,0x30
    8001cf44:	93c1                	srli	a5,a5,0x30
    8001cf46:	853e                	mv	a0,a5
    8001cf48:	c10f70ef          	jal	ra,80014358 <pci_get_nth_saved_device>
    8001cf4c:	faa43823          	sd	a0,-80(s0)
        
        // Is this a virtio device?
        if (pci_is_virtio_device(pcidevice)) { // Access through ecam_header
    8001cf50:	fb043503          	ld	a0,-80(s0)
    8001cf54:	87af70ef          	jal	ra,80013fce <pci_is_virtio_device>
    8001cf58:	87aa                	mv	a5,a0
    8001cf5a:	2a078463          	beqz	a5,8001d202 <virtio_init+0x2ec>

            // Create a new bookkeeping structure for the virtio device
            VirtioDevice viodev;

            // Add the PCI device to the bookkeeping structure
            viodev.pcidev = pcidevice;
    8001cf5e:	fb043783          	ld	a5,-80(s0)
    8001cf62:	f2f43c23          	sd	a5,-200(s0)
            // Add the common configuration, notify capability, and ISR to the bookkeeping structure
            viodev.common_cfg = pci_get_virtio_common_config(pcidevice);
    8001cf66:	fb043503          	ld	a0,-80(s0)
    8001cf6a:	d90f70ef          	jal	ra,800144fa <pci_get_virtio_common_config>
    8001cf6e:	87aa                	mv	a5,a0
    8001cf70:	f4f43023          	sd	a5,-192(s0)
            viodev.notify_cap = pci_get_virtio_notify_capability(pcidevice);
    8001cf74:	fb043503          	ld	a0,-80(s0)
    8001cf78:	ddaf70ef          	jal	ra,80014552 <pci_get_virtio_notify_capability>
    8001cf7c:	87aa                	mv	a5,a0
    8001cf7e:	f4f43423          	sd	a5,-184(s0)
            viodev.isr = pci_get_virtio_isr_status(pcidevice);
    8001cf82:	fb043503          	ld	a0,-80(s0)
    8001cf86:	e30f70ef          	jal	ra,800145b6 <pci_get_virtio_isr_status>
    8001cf8a:	87aa                	mv	a5,a0
    8001cf8c:	f4f43823          	sd	a5,-176(s0)
            if (virtio_is_rng_device(&viodev)) {
    8001cf90:	ef840793          	addi	a5,s0,-264
    8001cf94:	853e                	mv	a0,a5
    8001cf96:	b9bff0ef          	jal	ra,8001cb30 <virtio_is_rng_device>
    8001cf9a:	87aa                	mv	a5,a0
    8001cf9c:	ef89                	bnez	a5,8001cfb6 <virtio_init+0xa0>
                debugf("Setting up RNG device\n");
            } else if (virtio_is_block_device(&viodev)) {
    8001cf9e:	ef840793          	addi	a5,s0,-264
    8001cfa2:	853e                	mv	a0,a5
    8001cfa4:	bc3ff0ef          	jal	ra,8001cb66 <virtio_is_block_device>
    8001cfa8:	87aa                	mv	a5,a0
    8001cfaa:	e791                	bnez	a5,8001cfb6 <virtio_init+0xa0>
                debugf("Setting up block device\n");
            } else if (virtio_is_input_device(&viodev)) {
    8001cfac:	ef840793          	addi	a5,s0,-264
    8001cfb0:	853e                	mv	a0,a5
    8001cfb2:	bebff0ef          	jal	ra,8001cb9c <virtio_is_input_device>
            debugf("Common config at 0x%08x\n", viodev.common_cfg);
            debugf("Notify config at 0x%08x\n", viodev.notify_cap);
            debugf("ISR config at 0x%08x\n", viodev.isr);

            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status = VIRTIO_F_RESET;
    8001cfb6:	f4043783          	ld	a5,-192(s0)
    8001cfba:	00078a23          	sb	zero,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status = VIRTIO_F_ACKNOWLEDGE;
    8001cfbe:	f4043783          	ld	a5,-192(s0)
    8001cfc2:	4705                	li	a4,1
    8001cfc4:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER;
    8001cfc8:	f4043783          	ld	a5,-192(s0)
    8001cfcc:	0147c783          	lbu	a5,20(a5)
    8001cfd0:	0ff7f713          	andi	a4,a5,255
    8001cfd4:	f4043783          	ld	a5,-192(s0)
    8001cfd8:	00276713          	ori	a4,a4,2
    8001cfdc:	0ff77713          	andi	a4,a4,255
    8001cfe0:	00e78a23          	sb	a4,20(a5)
            debugf("Status: %x\n", viodev.common_cfg->device_status);
            if (viodev.common_cfg->device_feature & VIRTIO_F_IN_ORDER) {
    8001cfe4:	f4043783          	ld	a5,-192(s0)
    8001cfe8:	43dc                	lw	a5,4(a5)
    8001cfea:	2781                	sext.w	a5,a5
    8001cfec:	0237f793          	andi	a5,a5,35
    8001cff0:	2781                	sext.w	a5,a5
    8001cff2:	cf81                	beqz	a5,8001d00a <virtio_init+0xf4>
                debugf("Device supports in-order\n");
                viodev.common_cfg->driver_feature |= VIRTIO_F_IN_ORDER;
    8001cff4:	f4043783          	ld	a5,-192(s0)
    8001cff8:	47dc                	lw	a5,12(a5)
    8001cffa:	0007871b          	sext.w	a4,a5
    8001cffe:	f4043783          	ld	a5,-192(s0)
    8001d002:	02376713          	ori	a4,a4,35
    8001d006:	2701                	sext.w	a4,a4
    8001d008:	c7d8                	sw	a4,12(a5)
            } else {
                debugf("Device does not support in-order\n");
            }
            viodev.common_cfg->device_status |= VIRTIO_F_FEATURES_OK;
    8001d00a:	f4043783          	ld	a5,-192(s0)
    8001d00e:	0147c783          	lbu	a5,20(a5)
    8001d012:	0ff7f713          	andi	a4,a5,255
    8001d016:	f4043783          	ld	a5,-192(s0)
    8001d01a:	00876713          	ori	a4,a4,8
    8001d01e:	0ff77713          	andi	a4,a4,255
    8001d022:	00e78a23          	sb	a4,20(a5)
            if (!(viodev.common_cfg->device_status & VIRTIO_F_FEATURES_OK)) {
    8001d026:	f4043783          	ld	a5,-192(s0)
    8001d02a:	0147c783          	lbu	a5,20(a5)
    8001d02e:	0ff7f793          	andi	a5,a5,255
    8001d032:	2781                	sext.w	a5,a5
    8001d034:	8ba1                	andi	a5,a5,8
    8001d036:	2781                	sext.w	a5,a5
    8001d038:	e799                	bnez	a5,8001d046 <virtio_init+0x130>
                warnf("Device does not accept features\n");
    8001d03a:	0000b517          	auipc	a0,0xb
    8001d03e:	7f650513          	addi	a0,a0,2038 # 80028830 <pow10.0+0x19d0>
    8001d042:	df7fe0ef          	jal	ra,8001be38 <warnf>
            }
            
            // Fix qsize below
            viodev.common_cfg->queue_select = 0;
    8001d046:	f4043783          	ld	a5,-192(s0)
    8001d04a:	00079b23          	sh	zero,22(a5)
            uint16_t qsize = viodev.common_cfg->queue_size;
    8001d04e:	f4043783          	ld	a5,-192(s0)
    8001d052:	0187d783          	lhu	a5,24(a5)
    8001d056:	faf41723          	sh	a5,-82(s0)
            debugf("Virtio device has queue size %d\n", qsize);

            // Allocate contiguous physical memory for descriptor table, driver ring, and device ring
            // These are virtual memory pointers that we will use in the OS side.
            viodev.desc = (VirtioDescriptor *)kzalloc(VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
    8001d05a:	fae45783          	lhu	a5,-82(s0)
    8001d05e:	2781                	sext.w	a5,a5
    8001d060:	0047979b          	slliw	a5,a5,0x4
    8001d064:	2781                	sext.w	a5,a5
    8001d066:	85be                	mv	a1,a5
    8001d068:	4505                	li	a0,1
    8001d06a:	ce8f80ef          	jal	ra,80015552 <kcalloc>
    8001d06e:	87aa                	mv	a5,a0
    8001d070:	f4f43c23          	sd	a5,-168(s0)
            viodev.driver = (VirtioDriverRing *)kzalloc(VIRTIO_DRIVER_TABLE_BYTES(qsize));
    8001d074:	fae45783          	lhu	a5,-82(s0)
    8001d078:	2781                	sext.w	a5,a5
    8001d07a:	278d                	addiw	a5,a5,3
    8001d07c:	2781                	sext.w	a5,a5
    8001d07e:	0017979b          	slliw	a5,a5,0x1
    8001d082:	2781                	sext.w	a5,a5
    8001d084:	85be                	mv	a1,a5
    8001d086:	4505                	li	a0,1
    8001d088:	ccaf80ef          	jal	ra,80015552 <kcalloc>
    8001d08c:	87aa                	mv	a5,a0
    8001d08e:	f6f43023          	sd	a5,-160(s0)
            viodev.device = (VirtioDeviceRing *)kzalloc(VIRTIO_DEVICE_TABLE_BYTES(qsize));
    8001d092:	fae45783          	lhu	a5,-82(s0)
    8001d096:	2781                	sext.w	a5,a5
    8001d098:	0037979b          	slliw	a5,a5,0x3
    8001d09c:	2781                	sext.w	a5,a5
    8001d09e:	2799                	addiw	a5,a5,6
    8001d0a0:	2781                	sext.w	a5,a5
    8001d0a2:	85be                	mv	a1,a5
    8001d0a4:	4505                	li	a0,1
    8001d0a6:	cacf80ef          	jal	ra,80015552 <kcalloc>
    8001d0aa:	87aa                	mv	a5,a0
    8001d0ac:	f6f43423          	sd	a5,-152(s0)
            debugf("Descriptor ring size: %d\n", VIRTIO_DESCRIPTOR_TABLE_BYTES(qsize));
            debugf("Driver ring size: %d\n", VIRTIO_DRIVER_TABLE_BYTES(qsize));
            debugf("Device ring size: %d\n", VIRTIO_DEVICE_TABLE_BYTES(qsize));

            // Initialize the indices
            viodev.desc_idx = 0;
    8001d0b0:	f8041023          	sh	zero,-128(s0)
            viodev.driver_idx = 0;
    8001d0b4:	f8041123          	sh	zero,-126(s0)
            viodev.device_idx = 0;
    8001d0b8:	f8041223          	sh	zero,-124(s0)

            // Add the physical addresses for the descriptor table, driver ring, and device ring to the common configuration
            // We translate the virtual addresses so the devices can actuall access the memory.
            uint64_t phys_desc = kernel_mmu_translate((uint64_t)viodev.desc),
    8001d0bc:	f5843783          	ld	a5,-168(s0)
    8001d0c0:	853e                	mv	a0,a5
    8001d0c2:	9c3f80ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001d0c6:	faa43023          	sd	a0,-96(s0)
                phys_driver = kernel_mmu_translate((uint64_t)viodev.driver),
    8001d0ca:	f6043783          	ld	a5,-160(s0)
    8001d0ce:	853e                	mv	a0,a5
    8001d0d0:	9b5f80ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001d0d4:	f8a43c23          	sd	a0,-104(s0)
                phys_device = kernel_mmu_translate((uint64_t)viodev.device);
    8001d0d8:	f6843783          	ld	a5,-152(s0)
    8001d0dc:	853e                	mv	a0,a5
    8001d0de:	9a7f80ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001d0e2:	f8a43823          	sd	a0,-112(s0)
            viodev.common_cfg->queue_desc = phys_desc;
    8001d0e6:	f4043783          	ld	a5,-192(s0)
    8001d0ea:	fa043703          	ld	a4,-96(s0)
    8001d0ee:	f398                	sd	a4,32(a5)
            viodev.common_cfg->queue_driver = phys_driver;
    8001d0f0:	f4043783          	ld	a5,-192(s0)
    8001d0f4:	f9843703          	ld	a4,-104(s0)
    8001d0f8:	f798                	sd	a4,40(a5)
            viodev.common_cfg->queue_device = phys_device;
    8001d0fa:	f4043783          	ld	a5,-192(s0)
    8001d0fe:	f9043703          	ld	a4,-112(s0)
    8001d102:	fb98                	sd	a4,48(a5)
            debugf("virtio_init: queue_desc = 0x%08lx physical (0x%08lx virtual)\n", phys_desc, viodev.desc);
            debugf("virtio_init: queue_driver = 0x%08lx physical (0x%08lx virtual)\n", phys_driver, viodev.driver);
            debugf("virtio_init: queue_device = 0x%08lx physical (0x%08lx virtual)\n", phys_device, viodev.device);
            if (viodev.common_cfg->queue_desc != phys_desc) {
    8001d104:	f4043783          	ld	a5,-192(s0)
    8001d108:	739c                	ld	a5,32(a5)
    8001d10a:	fa043703          	ld	a4,-96(s0)
    8001d10e:	02f70363          	beq	a4,a5,8001d134 <virtio_init+0x21e>
                warnf("Device does not reflect physical desc ring  @0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_desc, phys_desc, viodev.common_cfg->queue_desc);
    8001d112:	f4043783          	ld	a5,-192(s0)
    8001d116:	02078713          	addi	a4,a5,32
    8001d11a:	f4043783          	ld	a5,-192(s0)
    8001d11e:	739c                	ld	a5,32(a5)
    8001d120:	86be                	mv	a3,a5
    8001d122:	fa043603          	ld	a2,-96(s0)
    8001d126:	85ba                	mv	a1,a4
    8001d128:	0000b517          	auipc	a0,0xb
    8001d12c:	73050513          	addi	a0,a0,1840 # 80028858 <pow10.0+0x19f8>
    8001d130:	d09fe0ef          	jal	ra,8001be38 <warnf>
            }
            if (viodev.common_cfg->queue_driver != phys_driver) {
    8001d134:	f4043783          	ld	a5,-192(s0)
    8001d138:	779c                	ld	a5,40(a5)
    8001d13a:	f9843703          	ld	a4,-104(s0)
    8001d13e:	02f70363          	beq	a4,a5,8001d164 <virtio_init+0x24e>
                warnf("Device does not reflect physical driver ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_driver, phys_driver, viodev.common_cfg->queue_driver);
    8001d142:	f4043783          	ld	a5,-192(s0)
    8001d146:	02878713          	addi	a4,a5,40
    8001d14a:	f4043783          	ld	a5,-192(s0)
    8001d14e:	779c                	ld	a5,40(a5)
    8001d150:	86be                	mv	a3,a5
    8001d152:	f9843603          	ld	a2,-104(s0)
    8001d156:	85ba                	mv	a1,a4
    8001d158:	0000b517          	auipc	a0,0xb
    8001d15c:	75050513          	addi	a0,a0,1872 # 800288a8 <pow10.0+0x1a48>
    8001d160:	cd9fe0ef          	jal	ra,8001be38 <warnf>
            }
            if (viodev.common_cfg->queue_device != phys_device){
    8001d164:	f4043783          	ld	a5,-192(s0)
    8001d168:	7b9c                	ld	a5,48(a5)
    8001d16a:	f9043703          	ld	a4,-112(s0)
    8001d16e:	02f70363          	beq	a4,a5,8001d194 <virtio_init+0x27e>
                warnf("Device does not reflect physical device ring@0x%08x (wrote %x but read %x)\n", &viodev.common_cfg->queue_device, phys_device, viodev.common_cfg->queue_device);
    8001d172:	f4043783          	ld	a5,-192(s0)
    8001d176:	03078713          	addi	a4,a5,48
    8001d17a:	f4043783          	ld	a5,-192(s0)
    8001d17e:	7b9c                	ld	a5,48(a5)
    8001d180:	86be                	mv	a3,a5
    8001d182:	f9043603          	ld	a2,-112(s0)
    8001d186:	85ba                	mv	a1,a4
    8001d188:	0000b517          	auipc	a0,0xb
    8001d18c:	77050513          	addi	a0,a0,1904 # 800288f8 <pow10.0+0x1a98>
    8001d190:	ca9fe0ef          	jal	ra,8001be38 <warnf>
            }
            debugf("Set up tables for virtio device\n");
            viodev.common_cfg->queue_enable = 1;
    8001d194:	f4043783          	ld	a5,-192(s0)
    8001d198:	4705                	li	a4,1
    8001d19a:	00e79e23          	sh	a4,28(a5)
            viodev.common_cfg->device_status |= VIRTIO_F_DRIVER_OK;
    8001d19e:	f4043783          	ld	a5,-192(s0)
    8001d1a2:	0147c783          	lbu	a5,20(a5)
    8001d1a6:	0ff7f713          	andi	a4,a5,255
    8001d1aa:	f4043783          	ld	a5,-192(s0)
    8001d1ae:	00476713          	ori	a4,a4,4
    8001d1b2:	0ff77713          	andi	a4,a4,255
    8001d1b6:	00e78a23          	sb	a4,20(a5)
            viodev.device->flags = 0;
    8001d1ba:	f6843783          	ld	a5,-152(s0)
    8001d1be:	00079023          	sh	zero,0(a5)
            viodev.lock = MUTEX_UNLOCKED;
    8001d1c2:	f8042423          	sw	zero,-120(s0)
            viodev.jobs = vector_new();
    8001d1c6:	2c9050ef          	jal	ra,80022c8e <vector_new>
    8001d1ca:	87aa                	mv	a5,a0
    8001d1cc:	f6f43c23          	sd	a5,-136(s0)
            virtio_set_device_name(&viodev, "Unknown Virtio Device");
    8001d1d0:	ef840793          	addi	a5,s0,-264
    8001d1d4:	0000b597          	auipc	a1,0xb
    8001d1d8:	77458593          	addi	a1,a1,1908 # 80028948 <pow10.0+0x1ae8>
    8001d1dc:	853e                	mv	a0,a5
    8001d1de:	0ee000ef          	jal	ra,8001d2cc <virtio_set_device_name>
            // Add to vector using vector_push
            virtio_save_device(viodev);
    8001d1e2:	e5040793          	addi	a5,s0,-432
    8001d1e6:	ef840713          	addi	a4,s0,-264
    8001d1ea:	09800693          	li	a3,152
    8001d1ee:	8636                	mv	a2,a3
    8001d1f0:	85ba                	mv	a1,a4
    8001d1f2:	853e                	mv	a0,a5
    8001d1f4:	14a050ef          	jal	ra,8002233e <memcpy>
    8001d1f8:	e5040793          	addi	a5,s0,-432
    8001d1fc:	853e                	mv	a0,a5
    8001d1fe:	bf9ff0ef          	jal	ra,8001cdf6 <virtio_save_device>
    for (uint64_t i = 0; i < num_pci_devices; ++i) {
    8001d202:	fd843783          	ld	a5,-40(s0)
    8001d206:	0785                	addi	a5,a5,1
    8001d208:	fcf43c23          	sd	a5,-40(s0)
    8001d20c:	fd843703          	ld	a4,-40(s0)
    8001d210:	fc843783          	ld	a5,-56(s0)
    8001d214:	d2f765e3          	bltu	a4,a5,8001cf3e <virtio_init+0x28>
        }
    }
    rng_device_init();
    8001d218:	c61f60ef          	jal	ra,80013e78 <rng_device_init>
    block_device_init();
    8001d21c:	47e010ef          	jal	ra,8001e69a <block_device_init>
    gpu_device_init();
    8001d220:	e47f80ef          	jal	ra,80016066 <gpu_device_init>
    /*
    loop over every virtio device and initialize based on type
    */

    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001d224:	fc041b23          	sh	zero,-42(s0)
    8001d228:	a82d                	j	8001d262 <virtio_init+0x34c>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001d22a:	fd645783          	lhu	a5,-42(s0)
    8001d22e:	853e                	mv	a0,a5
    8001d230:	b8dff0ef          	jal	ra,8001cdbc <virtio_get_nth_saved_device>
    8001d234:	faa43c23          	sd	a0,-72(s0)
        if(virtio_get_device_id(dev) == VIRTIO_PCI_DEVICE_ID(VIRTIO_PCI_DEVICE_INPUT)){
    8001d238:	fb843503          	ld	a0,-72(s0)
    8001d23c:	8d3ff0ef          	jal	ra,8001cb0e <virtio_get_device_id>
    8001d240:	87aa                	mv	a5,a0
    8001d242:	0007871b          	sext.w	a4,a5
    8001d246:	6785                	lui	a5,0x1
    8001d248:	05278793          	addi	a5,a5,82 # 1052 <i+0x1032>
    8001d24c:	00f71663          	bne	a4,a5,8001d258 <virtio_init+0x342>
            input_device_init(dev);
    8001d250:	fb843503          	ld	a0,-72(s0)
    8001d254:	751000ef          	jal	ra,8001e1a4 <input_device_init>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001d258:	fd645783          	lhu	a5,-42(s0)
    8001d25c:	2785                	addiw	a5,a5,1
    8001d25e:	fcf41b23          	sh	a5,-42(s0)
    8001d262:	fd645483          	lhu	s1,-42(s0)
    8001d266:	c57ff0ef          	jal	ra,8001cebc <virtio_count_saved_devices>
    8001d26a:	87aa                	mv	a5,a0
    8001d26c:	faf4efe3          	bltu	s1,a5,8001d22a <virtio_init+0x314>
        }
    }
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001d270:	fc041a23          	sh	zero,-44(s0)
    8001d274:	a835                	j	8001d2b0 <virtio_init+0x39a>
        VirtioDevice *dev = virtio_get_nth_saved_device(i);
    8001d276:	fd445783          	lhu	a5,-44(s0)
    8001d27a:	853e                	mv	a0,a5
    8001d27c:	b41ff0ef          	jal	ra,8001cdbc <virtio_get_nth_saved_device>
    8001d280:	fca43023          	sd	a0,-64(s0)
        infof("Found device #%u: \"%s\"\n", i, virtio_get_device_name(dev));
    8001d284:	fd445783          	lhu	a5,-44(s0)
    8001d288:	0007849b          	sext.w	s1,a5
    8001d28c:	fc043503          	ld	a0,-64(s0)
    8001d290:	068000ef          	jal	ra,8001d2f8 <virtio_get_device_name>
    8001d294:	87aa                	mv	a5,a0
    8001d296:	863e                	mv	a2,a5
    8001d298:	85a6                	mv	a1,s1
    8001d29a:	0000b517          	auipc	a0,0xb
    8001d29e:	6c650513          	addi	a0,a0,1734 # 80028960 <pow10.0+0x1b00>
    8001d2a2:	c45fe0ef          	jal	ra,8001bee6 <infof>
    for (uint16_t i=0; i<virtio_count_saved_devices(); i++) {
    8001d2a6:	fd445783          	lhu	a5,-44(s0)
    8001d2aa:	2785                	addiw	a5,a5,1
    8001d2ac:	fcf41a23          	sh	a5,-44(s0)
    8001d2b0:	fd445483          	lhu	s1,-44(s0)
    8001d2b4:	c09ff0ef          	jal	ra,8001cebc <virtio_count_saved_devices>
    8001d2b8:	87aa                	mv	a5,a0
    8001d2ba:	faf4eee3          	bltu	s1,a5,8001d276 <virtio_init+0x360>
    }
    debugf("virtio_init: Done initializing virtio system\n");
}
    8001d2be:	0001                	nop
    8001d2c0:	0001                	nop
    8001d2c2:	70ba                	ld	ra,424(sp)
    8001d2c4:	741a                	ld	s0,416(sp)
    8001d2c6:	64fa                	ld	s1,408(sp)
    8001d2c8:	615d                	addi	sp,sp,432
    8001d2ca:	8082                	ret

000000008001d2cc <virtio_set_device_name>:

void virtio_set_device_name(VirtioDevice *dev, const char *name) {
    8001d2cc:	1101                	addi	sp,sp,-32
    8001d2ce:	ec06                	sd	ra,24(sp)
    8001d2d0:	e822                	sd	s0,16(sp)
    8001d2d2:	1000                	addi	s0,sp,32
    8001d2d4:	fea43423          	sd	a0,-24(s0)
    8001d2d8:	feb43023          	sd	a1,-32(s0)
    strncpy(dev->name, name, sizeof(dev->name));
    8001d2dc:	fe843783          	ld	a5,-24(s0)
    8001d2e0:	04000613          	li	a2,64
    8001d2e4:	fe043583          	ld	a1,-32(s0)
    8001d2e8:	853e                	mv	a0,a5
    8001d2ea:	774050ef          	jal	ra,80022a5e <strncpy>
}
    8001d2ee:	0001                	nop
    8001d2f0:	60e2                	ld	ra,24(sp)
    8001d2f2:	6442                	ld	s0,16(sp)
    8001d2f4:	6105                	addi	sp,sp,32
    8001d2f6:	8082                	ret

000000008001d2f8 <virtio_get_device_name>:

const char *virtio_get_device_name(VirtioDevice *dev) {
    8001d2f8:	1101                	addi	sp,sp,-32
    8001d2fa:	ec22                	sd	s0,24(sp)
    8001d2fc:	1000                	addi	s0,sp,32
    8001d2fe:	fea43423          	sd	a0,-24(s0)
    return dev->name;
    8001d302:	fe843783          	ld	a5,-24(s0)
}
    8001d306:	853e                	mv	a0,a5
    8001d308:	6462                	ld	s0,24(sp)
    8001d30a:	6105                	addi	sp,sp,32
    8001d30c:	8082                	ret

000000008001d30e <virtio_notify_register>:

// Get the notify capability for the given virtio device.
volatile uint16_t *virtio_notify_register(VirtioDevice *device) {
    8001d30e:	715d                	addi	sp,sp,-80
    8001d310:	e486                	sd	ra,72(sp)
    8001d312:	e0a2                	sd	s0,64(sp)
    8001d314:	0880                	addi	s0,sp,80
    8001d316:	faa43c23          	sd	a0,-72(s0)
    // struct VirtioCapability *vio_cap = pci_get_virtio_capability(device->pcidev, VIRTIO_PCI_CAP_NOTIFY_CFG);
    // volatile VirtioPciNotifyCfg *notify_cap = pci_get_virtio_notify_capability(device->pcidev);
    uint8_t bar_num = device->notify_cap->cap.bar;
    8001d31a:	fb843783          	ld	a5,-72(s0)
    8001d31e:	6bbc                	ld	a5,80(a5)
    8001d320:	0047c783          	lbu	a5,4(a5)
    8001d324:	fef407a3          	sb	a5,-17(s0)
    uint64_t offset = device->notify_cap->cap.offset;
    8001d328:	fb843783          	ld	a5,-72(s0)
    8001d32c:	6bbc                	ld	a5,80(a5)
    8001d32e:	479c                	lw	a5,8(a5)
    8001d330:	2781                	sext.w	a5,a5
    8001d332:	1782                	slli	a5,a5,0x20
    8001d334:	9381                	srli	a5,a5,0x20
    8001d336:	fef43023          	sd	a5,-32(s0)
    uint16_t queue_notify_off = device->common_cfg->queue_notify_off;
    8001d33a:	fb843783          	ld	a5,-72(s0)
    8001d33e:	67bc                	ld	a5,72(a5)
    8001d340:	01e7d783          	lhu	a5,30(a5)
    8001d344:	fcf41f23          	sh	a5,-34(s0)
    uint32_t notify_off_multiplier = device->notify_cap->notify_off_multiplier;
    8001d348:	fb843783          	ld	a5,-72(s0)
    8001d34c:	6bbc                	ld	a5,80(a5)
    8001d34e:	4b9c                	lw	a5,16(a5)
    8001d350:	fcf42c23          	sw	a5,-40(s0)
    uint64_t bar = (uint64_t)pci_get_device_bar(device->pcidev, bar_num);
    8001d354:	fb843783          	ld	a5,-72(s0)
    8001d358:	63bc                	ld	a5,64(a5)
    8001d35a:	fef44703          	lbu	a4,-17(s0)
    8001d35e:	85ba                	mv	a1,a4
    8001d360:	853e                	mv	a0,a5
    8001d362:	a18f70ef          	jal	ra,8001457a <pci_get_device_bar>
    8001d366:	87aa                	mv	a5,a0
    8001d368:	fcf43823          	sd	a5,-48(s0)
    // debugf("Notify cap bar=%d offset=%x, (len=%d)\n", bar_num, offset, device->notify_cap->cap.length);
    // debugf("BAR at %x, offset=%x, queue_notify_off=%x, notify_off_mult=%x\n", bar, offset, queue_notify_off, notify_off_multiplier);

    uint16_t *notify = (uint16_t*)(bar + BAR_NOTIFY_CAP(offset, queue_notify_off, notify_off_multiplier));
    8001d36c:	fde45783          	lhu	a5,-34(s0)
    8001d370:	2781                	sext.w	a5,a5
    8001d372:	fd842703          	lw	a4,-40(s0)
    8001d376:	02f707bb          	mulw	a5,a4,a5
    8001d37a:	2781                	sext.w	a5,a5
    8001d37c:	02079713          	slli	a4,a5,0x20
    8001d380:	9301                	srli	a4,a4,0x20
    8001d382:	fe043783          	ld	a5,-32(s0)
    8001d386:	973e                	add	a4,a4,a5
    8001d388:	fd043783          	ld	a5,-48(s0)
    8001d38c:	97ba                	add	a5,a5,a4
    8001d38e:	fcf43423          	sd	a5,-56(s0)
    return notify;
    8001d392:	fc843783          	ld	a5,-56(s0)
}
    8001d396:	853e                	mv	a0,a5
    8001d398:	60a6                	ld	ra,72(sp)
    8001d39a:	6406                	ld	s0,64(sp)
    8001d39c:	6161                	addi	sp,sp,80
    8001d39e:	8082                	ret

000000008001d3a0 <virtio_notify>:
 * @brief Virtio notification
 * @param viodev - virtio device to notify for
 * @param which_queue - queue number to notify
 */
void virtio_notify(VirtioDevice *viodev, uint16_t which_queue)
{
    8001d3a0:	7179                	addi	sp,sp,-48
    8001d3a2:	f406                	sd	ra,40(sp)
    8001d3a4:	f022                	sd	s0,32(sp)
    8001d3a6:	1800                	addi	s0,sp,48
    8001d3a8:	fca43c23          	sd	a0,-40(s0)
    8001d3ac:	87ae                	mv	a5,a1
    8001d3ae:	fcf41b23          	sh	a5,-42(s0)
    uint16_t num_queues = viodev->common_cfg->num_queues;
    8001d3b2:	fd843783          	ld	a5,-40(s0)
    8001d3b6:	67bc                	ld	a5,72(a5)
    8001d3b8:	0127d783          	lhu	a5,18(a5)
    8001d3bc:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    8001d3c0:	fd645703          	lhu	a4,-42(s0)
    8001d3c4:	fee45783          	lhu	a5,-18(s0)
    8001d3c8:	2701                	sext.w	a4,a4
    8001d3ca:	2781                	sext.w	a5,a5
    8001d3cc:	02f76363          	bltu	a4,a5,8001d3f2 <virtio_notify+0x52>
        warnf("virtio_notify: Provided queue number %d is too big (num_queues=%d) for device %s\n", which_queue, num_queues, viodev->name);
    8001d3d0:	fd645783          	lhu	a5,-42(s0)
    8001d3d4:	2781                	sext.w	a5,a5
    8001d3d6:	fee45703          	lhu	a4,-18(s0)
    8001d3da:	2701                	sext.w	a4,a4
    8001d3dc:	fd843683          	ld	a3,-40(s0)
    8001d3e0:	863a                	mv	a2,a4
    8001d3e2:	85be                	mv	a1,a5
    8001d3e4:	0000b517          	auipc	a0,0xb
    8001d3e8:	59450513          	addi	a0,a0,1428 # 80028978 <pow10.0+0x1b18>
    8001d3ec:	a4dfe0ef          	jal	ra,8001be38 <warnf>
        return;
    8001d3f0:	a025                	j	8001d418 <virtio_notify+0x78>
    }

    // Select the queue we are looking at
    viodev->common_cfg->queue_select = which_queue;
    8001d3f2:	fd843783          	ld	a5,-40(s0)
    8001d3f6:	67bc                	ld	a5,72(a5)
    8001d3f8:	fd645703          	lhu	a4,-42(s0)
    8001d3fc:	00e79b23          	sh	a4,22(a5)

    volatile uint16_t *notify_register = virtio_notify_register(viodev);
    8001d400:	fd843503          	ld	a0,-40(s0)
    8001d404:	f0bff0ef          	jal	ra,8001d30e <virtio_notify_register>
    8001d408:	fea43023          	sd	a0,-32(s0)
    // debugf("Notifying at 0x%p on instruction...\n", notify_register);
    *notify_register = which_queue;
    8001d40c:	fe043783          	ld	a5,-32(s0)
    8001d410:	fd645703          	lhu	a4,-42(s0)
    8001d414:	00e79023          	sh	a4,0(a5)
    // debugf("Notified device\n\n");
}
    8001d418:	70a2                	ld	ra,40(sp)
    8001d41a:	7402                	ld	s0,32(sp)
    8001d41c:	6145                	addi	sp,sp,48
    8001d41e:	8082                	ret

000000008001d420 <virtio_set_queue_and_get_size>:

// Select the queue and get its size
uint16_t virtio_set_queue_and_get_size(VirtioDevice *device, uint16_t which_queue) {
    8001d420:	7179                	addi	sp,sp,-48
    8001d422:	f406                	sd	ra,40(sp)
    8001d424:	f022                	sd	s0,32(sp)
    8001d426:	1800                	addi	s0,sp,48
    8001d428:	fca43c23          	sd	a0,-40(s0)
    8001d42c:	87ae                	mv	a5,a1
    8001d42e:	fcf41b23          	sh	a5,-42(s0)
    if (device->common_cfg->queue_select != which_queue) {
    8001d432:	fd843783          	ld	a5,-40(s0)
    8001d436:	67bc                	ld	a5,72(a5)
    8001d438:	0167d783          	lhu	a5,22(a5)
    8001d43c:	17c2                	slli	a5,a5,0x30
    8001d43e:	93c1                	srli	a5,a5,0x30
    8001d440:	fd645703          	lhu	a4,-42(s0)
    8001d444:	2701                	sext.w	a4,a4
    8001d446:	2781                	sext.w	a5,a5
    8001d448:	00f70963          	beq	a4,a5,8001d45a <virtio_set_queue_and_get_size+0x3a>
        device->common_cfg->queue_select = which_queue;
    8001d44c:	fd843783          	ld	a5,-40(s0)
    8001d450:	67bc                	ld	a5,72(a5)
    8001d452:	fd645703          	lhu	a4,-42(s0)
    8001d456:	00e79b23          	sh	a4,22(a5)
    }
    uint16_t num_queues = device->common_cfg->num_queues;
    8001d45a:	fd843783          	ld	a5,-40(s0)
    8001d45e:	67bc                	ld	a5,72(a5)
    8001d460:	0127d783          	lhu	a5,18(a5)
    8001d464:	fef41723          	sh	a5,-18(s0)

    if (which_queue >= num_queues) {
    8001d468:	fd645703          	lhu	a4,-42(s0)
    8001d46c:	fee45783          	lhu	a5,-18(s0)
    8001d470:	2701                	sext.w	a4,a4
    8001d472:	2781                	sext.w	a5,a5
    8001d474:	02f76363          	bltu	a4,a5,8001d49a <virtio_set_queue_and_get_size+0x7a>
        warnf("virtio_notify: Provided queue number %d is too big (num_queues=%d)...\n", which_queue, num_queues);
    8001d478:	fd645783          	lhu	a5,-42(s0)
    8001d47c:	2781                	sext.w	a5,a5
    8001d47e:	fee45703          	lhu	a4,-18(s0)
    8001d482:	2701                	sext.w	a4,a4
    8001d484:	863a                	mv	a2,a4
    8001d486:	85be                	mv	a1,a5
    8001d488:	0000b517          	auipc	a0,0xb
    8001d48c:	54850513          	addi	a0,a0,1352 # 800289d0 <pow10.0+0x1b70>
    8001d490:	9a9fe0ef          	jal	ra,8001be38 <warnf>
        return -1;
    8001d494:	67c1                	lui	a5,0x10
    8001d496:	17fd                	addi	a5,a5,-1
    8001d498:	a801                	j	8001d4a8 <virtio_set_queue_and_get_size+0x88>
    }

    return device->common_cfg->queue_size;
    8001d49a:	fd843783          	ld	a5,-40(s0)
    8001d49e:	67bc                	ld	a5,72(a5)
    8001d4a0:	0187d783          	lhu	a5,24(a5) # 10018 <i+0xfff8>
    8001d4a4:	17c2                	slli	a5,a5,0x30
    8001d4a6:	93c1                	srli	a5,a5,0x30
}
    8001d4a8:	853e                	mv	a0,a5
    8001d4aa:	70a2                	ld	ra,40(sp)
    8001d4ac:	7402                	ld	s0,32(sp)
    8001d4ae:	6145                	addi	sp,sp,48
    8001d4b0:	8082                	ret

000000008001d4b2 <virtio_send_one_descriptor>:

void virtio_send_one_descriptor(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor descriptor, bool notify_device_when_done) {
    8001d4b2:	7179                	addi	sp,sp,-48
    8001d4b4:	f406                	sd	ra,40(sp)
    8001d4b6:	f022                	sd	s0,32(sp)
    8001d4b8:	1800                	addi	s0,sp,48
    8001d4ba:	fea43423          	sd	a0,-24(s0)
    8001d4be:	87ae                	mv	a5,a1
    8001d4c0:	fcc43823          	sd	a2,-48(s0)
    8001d4c4:	fcd43c23          	sd	a3,-40(s0)
    8001d4c8:	fef41323          	sh	a5,-26(s0)
    8001d4cc:	87ba                	mv	a5,a4
    8001d4ce:	fef402a3          	sb	a5,-27(s0)
    virtio_send_descriptor_chain(device, which_queue, &descriptor, 1, notify_device_when_done);
    8001d4d2:	fe544703          	lbu	a4,-27(s0)
    8001d4d6:	fd040613          	addi	a2,s0,-48
    8001d4da:	fe645783          	lhu	a5,-26(s0)
    8001d4de:	4685                	li	a3,1
    8001d4e0:	85be                	mv	a1,a5
    8001d4e2:	fe843503          	ld	a0,-24(s0)
    8001d4e6:	00e000ef          	jal	ra,8001d4f4 <virtio_send_descriptor_chain>
}
    8001d4ea:	0001                	nop
    8001d4ec:	70a2                	ld	ra,40(sp)
    8001d4ee:	7402                	ld	s0,32(sp)
    8001d4f0:	6145                	addi	sp,sp,48
    8001d4f2:	8082                	ret

000000008001d4f4 <virtio_send_descriptor_chain>:


void virtio_send_descriptor_chain(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor *descriptors, uint16_t num_descriptors, bool notify_device_when_done) {
    8001d4f4:	711d                	addi	sp,sp,-96
    8001d4f6:	ec86                	sd	ra,88(sp)
    8001d4f8:	e8a2                	sd	s0,80(sp)
    8001d4fa:	1080                	addi	s0,sp,96
    8001d4fc:	faa43c23          	sd	a0,-72(s0)
    8001d500:	87ae                	mv	a5,a1
    8001d502:	fac43423          	sd	a2,-88(s0)
    8001d506:	faf41b23          	sh	a5,-74(s0)
    8001d50a:	87b6                	mv	a5,a3
    8001d50c:	faf41a23          	sh	a5,-76(s0)
    8001d510:	87ba                	mv	a5,a4
    8001d512:	faf409a3          	sb	a5,-77(s0)
    // Confirm the device is ready
    if (!device->ready) {
    8001d516:	fb843783          	ld	a5,-72(s0)
    8001d51a:	08e7c783          	lbu	a5,142(a5)
    8001d51e:	0017c793          	xori	a5,a5,1
    8001d522:	0ff7f793          	andi	a5,a5,255
    8001d526:	cb81                	beqz	a5,8001d536 <virtio_send_descriptor_chain+0x42>
        fatalf("device is not ready\n");
    8001d528:	0000b517          	auipc	a0,0xb
    8001d52c:	4f050513          	addi	a0,a0,1264 # 80028a18 <pow10.0+0x1bb8>
    8001d530:	a0dfe0ef          	jal	ra,8001bf3c <fatalf>
        return;
    8001d534:	aaf1                	j	8001d710 <virtio_send_descriptor_chain+0x21c>
    }

    virtio_acquire_device(device);
    8001d536:	fb843503          	ld	a0,-72(s0)
    8001d53a:	ab4ff0ef          	jal	ra,8001c7ee <virtio_acquire_device>

    // Select the queue we're using
    if (which_queue >= device->common_cfg->num_queues) {
    8001d53e:	fb843783          	ld	a5,-72(s0)
    8001d542:	67bc                	ld	a5,72(a5)
    8001d544:	0127d783          	lhu	a5,18(a5)
    8001d548:	17c2                	slli	a5,a5,0x30
    8001d54a:	93c1                	srli	a5,a5,0x30
    8001d54c:	fb645703          	lhu	a4,-74(s0)
    8001d550:	2701                	sext.w	a4,a4
    8001d552:	2781                	sext.w	a5,a5
    8001d554:	02f76763          	bltu	a4,a5,8001d582 <virtio_send_descriptor_chain+0x8e>
        fatalf("queue number %d is too big (num_queues=%d)\n", which_queue, device->common_cfg->num_queues);
    8001d558:	fb645783          	lhu	a5,-74(s0)
    8001d55c:	0007871b          	sext.w	a4,a5
    8001d560:	fb843783          	ld	a5,-72(s0)
    8001d564:	67bc                	ld	a5,72(a5)
    8001d566:	0127d783          	lhu	a5,18(a5)
    8001d56a:	17c2                	slli	a5,a5,0x30
    8001d56c:	93c1                	srli	a5,a5,0x30
    8001d56e:	2781                	sext.w	a5,a5
    8001d570:	863e                	mv	a2,a5
    8001d572:	85ba                	mv	a1,a4
    8001d574:	0000b517          	auipc	a0,0xb
    8001d578:	4bc50513          	addi	a0,a0,1212 # 80028a30 <pow10.0+0x1bd0>
    8001d57c:	9c1fe0ef          	jal	ra,8001bf3c <fatalf>
        return;
    8001d580:	aa41                	j	8001d710 <virtio_send_descriptor_chain+0x21c>
    }

    // The size of the queue we're using
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    8001d582:	fb645783          	lhu	a5,-74(s0)
    8001d586:	85be                	mv	a1,a5
    8001d588:	fb843503          	ld	a0,-72(s0)
    8001d58c:	e95ff0ef          	jal	ra,8001d420 <virtio_set_queue_and_get_size>
    8001d590:	87aa                	mv	a5,a0
    8001d592:	fef43023          	sd	a5,-32(s0)
#define VIRTQ_DESC_F_NEXT 1
#define VIRTQ_DESC_F_WRITE 2
#define VIRTQ_DESC_F_INDIRECT 4
    uint16_t    flags;
    uint16_t    next;*/
    device->driver_idx = device->driver->idx;
    8001d596:	fb843783          	ld	a5,-72(s0)
    8001d59a:	77bc                	ld	a5,104(a5)
    8001d59c:	0027d783          	lhu	a5,2(a5)
    8001d5a0:	03079713          	slli	a4,a5,0x30
    8001d5a4:	9341                	srli	a4,a4,0x30
    8001d5a6:	fb843783          	ld	a5,-72(s0)
    8001d5aa:	08e79523          	sh	a4,138(a5)
    uint64_t head_descriptor_index = device->desc_idx;
    8001d5ae:	fb843783          	ld	a5,-72(s0)
    8001d5b2:	0887d783          	lhu	a5,136(a5)
    8001d5b6:	fcf43c23          	sd	a5,-40(s0)
    for (int i=0; i<num_descriptors; i++) {
    8001d5ba:	fe042623          	sw	zero,-20(s0)
    8001d5be:	a075                	j	8001d66a <virtio_send_descriptor_chain+0x176>
        uint64_t descriptor_index = (device->desc_idx + i) % queue_size;
    8001d5c0:	fb843783          	ld	a5,-72(s0)
    8001d5c4:	0887d783          	lhu	a5,136(a5)
    8001d5c8:	2781                	sext.w	a5,a5
    8001d5ca:	fec42703          	lw	a4,-20(s0)
    8001d5ce:	9fb9                	addw	a5,a5,a4
    8001d5d0:	2781                	sext.w	a5,a5
    8001d5d2:	873e                	mv	a4,a5
    8001d5d4:	fe043783          	ld	a5,-32(s0)
    8001d5d8:	02f777b3          	remu	a5,a4,a5
    8001d5dc:	fcf43823          	sd	a5,-48(s0)
        // debugf("Writing descriptor %d to queue %d\n", descriptor_index, which_queue);
        VirtioDescriptor descriptor = descriptors[i];
    8001d5e0:	fec42783          	lw	a5,-20(s0)
    8001d5e4:	0792                	slli	a5,a5,0x4
    8001d5e6:	fa843703          	ld	a4,-88(s0)
    8001d5ea:	97ba                	add	a5,a5,a4
    8001d5ec:	6398                	ld	a4,0(a5)
    8001d5ee:	fce43023          	sd	a4,-64(s0)
    8001d5f2:	679c                	ld	a5,8(a5)
    8001d5f4:	fcf43423          	sd	a5,-56(s0)
        descriptor.next = (descriptor_index + 1) % queue_size;
    8001d5f8:	fd043783          	ld	a5,-48(s0)
    8001d5fc:	00178713          	addi	a4,a5,1
    8001d600:	fe043783          	ld	a5,-32(s0)
    8001d604:	02f777b3          	remu	a5,a4,a5
    8001d608:	17c2                	slli	a5,a5,0x30
    8001d60a:	93c1                	srli	a5,a5,0x30
    8001d60c:	fcf41723          	sh	a5,-50(s0)
        if (i < num_descriptors - 1) {
    8001d610:	fb445783          	lhu	a5,-76(s0)
    8001d614:	2781                	sext.w	a5,a5
    8001d616:	37fd                	addiw	a5,a5,-1
    8001d618:	0007871b          	sext.w	a4,a5
    8001d61c:	fec42783          	lw	a5,-20(s0)
    8001d620:	2781                	sext.w	a5,a5
    8001d622:	00e7db63          	bge	a5,a4,8001d638 <virtio_send_descriptor_chain+0x144>
            descriptor.flags |= VIRTQ_DESC_F_NEXT;
    8001d626:	fcc45783          	lhu	a5,-52(s0)
    8001d62a:	0017e793          	ori	a5,a5,1
    8001d62e:	17c2                	slli	a5,a5,0x30
    8001d630:	93c1                	srli	a5,a5,0x30
    8001d632:	fcf41623          	sh	a5,-52(s0)
    8001d636:	a801                	j	8001d646 <virtio_send_descriptor_chain+0x152>
        } else {
            descriptor.flags &= ~VIRTQ_DESC_F_NEXT;
    8001d638:	fcc45783          	lhu	a5,-52(s0)
    8001d63c:	9bf9                	andi	a5,a5,-2
    8001d63e:	17c2                	slli	a5,a5,0x30
    8001d640:	93c1                	srli	a5,a5,0x30
    8001d642:	fcf41623          	sh	a5,-52(s0)
        // debugf("Descriptor addr: %p\n", descriptor.addr);
        // debugf("Descriptor len: 0x%x = %d\n", descriptor.len, descriptor.len);
        // debugf("Descriptor flags: 0x%x = %d\n", descriptor.flags, descriptor.flags);
        // debugf("Descriptor next: 0x%x = %d\n", descriptor.next, descriptor.next);
        // Put the descriptor in the descriptor table
        device->desc[descriptor_index] = descriptor;
    8001d646:	fb843783          	ld	a5,-72(s0)
    8001d64a:	73b8                	ld	a4,96(a5)
    8001d64c:	fd043783          	ld	a5,-48(s0)
    8001d650:	0792                	slli	a5,a5,0x4
    8001d652:	97ba                	add	a5,a5,a4
    8001d654:	fc043703          	ld	a4,-64(s0)
    8001d658:	e398                	sd	a4,0(a5)
    8001d65a:	fc843703          	ld	a4,-56(s0)
    8001d65e:	e798                	sd	a4,8(a5)
    for (int i=0; i<num_descriptors; i++) {
    8001d660:	fec42783          	lw	a5,-20(s0)
    8001d664:	2785                	addiw	a5,a5,1
    8001d666:	fef42623          	sw	a5,-20(s0)
    8001d66a:	fb445783          	lhu	a5,-76(s0)
    8001d66e:	0007871b          	sext.w	a4,a5
    8001d672:	fec42783          	lw	a5,-20(s0)
    8001d676:	2781                	sext.w	a5,a5
    8001d678:	f4e7c4e3          	blt	a5,a4,8001d5c0 <virtio_send_descriptor_chain+0xcc>
    }
    // Put the descriptor into the driver ring
    device->driver->ring[device->driver->idx % queue_size] = head_descriptor_index;
    8001d67c:	fb843783          	ld	a5,-72(s0)
    8001d680:	77b4                	ld	a3,104(a5)
    8001d682:	fb843783          	ld	a5,-72(s0)
    8001d686:	77bc                	ld	a5,104(a5)
    8001d688:	0027d783          	lhu	a5,2(a5)
    8001d68c:	17c2                	slli	a5,a5,0x30
    8001d68e:	93c1                	srli	a5,a5,0x30
    8001d690:	873e                	mv	a4,a5
    8001d692:	fe043783          	ld	a5,-32(s0)
    8001d696:	02f777b3          	remu	a5,a4,a5
    8001d69a:	fd843703          	ld	a4,-40(s0)
    8001d69e:	1742                	slli	a4,a4,0x30
    8001d6a0:	9341                	srli	a4,a4,0x30
    8001d6a2:	0786                	slli	a5,a5,0x1
    8001d6a4:	97b6                	add	a5,a5,a3
    8001d6a6:	00e79223          	sh	a4,4(a5)
    // Increment the index to make it "visible" to the device
    device->driver->idx++;
    8001d6aa:	fb843783          	ld	a5,-72(s0)
    8001d6ae:	77bc                	ld	a5,104(a5)
    8001d6b0:	0027d703          	lhu	a4,2(a5)
    8001d6b4:	1742                	slli	a4,a4,0x30
    8001d6b6:	9341                	srli	a4,a4,0x30
    8001d6b8:	2705                	addiw	a4,a4,1
    8001d6ba:	1742                	slli	a4,a4,0x30
    8001d6bc:	9341                	srli	a4,a4,0x30
    8001d6be:	00e79123          	sh	a4,2(a5)
    // Update the descriptor index for our bookkeeping
    device->desc_idx = (device->desc_idx + num_descriptors) % queue_size;
    8001d6c2:	fb843783          	ld	a5,-72(s0)
    8001d6c6:	0887d783          	lhu	a5,136(a5)
    8001d6ca:	0007871b          	sext.w	a4,a5
    8001d6ce:	fb445783          	lhu	a5,-76(s0)
    8001d6d2:	2781                	sext.w	a5,a5
    8001d6d4:	9fb9                	addw	a5,a5,a4
    8001d6d6:	2781                	sext.w	a5,a5
    8001d6d8:	873e                	mv	a4,a5
    8001d6da:	fe043783          	ld	a5,-32(s0)
    8001d6de:	02f777b3          	remu	a5,a4,a5
    8001d6e2:	03079713          	slli	a4,a5,0x30
    8001d6e6:	9341                	srli	a4,a4,0x30
    8001d6e8:	fb843783          	ld	a5,-72(s0)
    8001d6ec:	08e79423          	sh	a4,136(a5)

    // debugf("Driver index: %d\n", device->driver->idx);
    // debugf("Descriptor index: %d\n", device->desc_idx);
    
    virtio_release_device(device);
    8001d6f0:	fb843503          	ld	a0,-72(s0)
    8001d6f4:	930ff0ef          	jal	ra,8001c824 <virtio_release_device>

    // Notify the device if we're ready to do so
    if (notify_device_when_done) {
    8001d6f8:	fb344783          	lbu	a5,-77(s0)
    8001d6fc:	0ff7f793          	andi	a5,a5,255
    8001d700:	cb81                	beqz	a5,8001d710 <virtio_send_descriptor_chain+0x21c>
        virtio_notify(device, which_queue);
    8001d702:	fb645783          	lhu	a5,-74(s0)
    8001d706:	85be                	mv	a1,a5
    8001d708:	fb843503          	ld	a0,-72(s0)
    8001d70c:	c95ff0ef          	jal	ra,8001d3a0 <virtio_notify>
    }
}
    8001d710:	60e6                	ld	ra,88(sp)
    8001d712:	6446                	ld	s0,80(sp)
    8001d714:	6125                	addi	sp,sp,96
    8001d716:	8082                	ret

000000008001d718 <virtio_receive_descriptor_chain>:


uint16_t virtio_receive_descriptor_chain(VirtioDevice *device, uint16_t which_queue, VirtioDescriptor *received, uint16_t max_descriptors, bool wait_for_descriptor) {
    8001d718:	715d                	addi	sp,sp,-80
    8001d71a:	e486                	sd	ra,72(sp)
    8001d71c:	e0a2                	sd	s0,64(sp)
    8001d71e:	0880                	addi	s0,sp,80
    8001d720:	fca43423          	sd	a0,-56(s0)
    8001d724:	87ae                	mv	a5,a1
    8001d726:	fac43c23          	sd	a2,-72(s0)
    8001d72a:	fcf41323          	sh	a5,-58(s0)
    8001d72e:	87b6                	mv	a5,a3
    8001d730:	fcf41223          	sh	a5,-60(s0)
    8001d734:	87ba                	mv	a5,a4
    8001d736:	fcf401a3          	sb	a5,-61(s0)
    uint64_t queue_size = virtio_set_queue_and_get_size(device, which_queue);
    8001d73a:	fc645783          	lhu	a5,-58(s0)
    8001d73e:	85be                	mv	a1,a5
    8001d740:	fc843503          	ld	a0,-56(s0)
    8001d744:	cddff0ef          	jal	ra,8001d420 <virtio_set_queue_and_get_size>
    8001d748:	87aa                	mv	a5,a0
    8001d74a:	fcf43c23          	sd	a5,-40(s0)
    if (wait_for_descriptor) {
    8001d74e:	fc344783          	lbu	a5,-61(s0)
    8001d752:	0ff7f793          	andi	a5,a5,255
    8001d756:	cb81                	beqz	a5,8001d766 <virtio_receive_descriptor_chain+0x4e>
        virtio_wait_for_descriptor(device, which_queue);
    8001d758:	fc645783          	lhu	a5,-58(s0)
    8001d75c:	85be                	mv	a1,a5
    8001d75e:	fc843503          	ld	a0,-56(s0)
    8001d762:	1fc000ef          	jal	ra,8001d95e <virtio_wait_for_descriptor>
    }

    if (!virtio_has_received_descriptor(device, which_queue)) {
    8001d766:	fc645783          	lhu	a5,-58(s0)
    8001d76a:	85be                	mv	a1,a5
    8001d76c:	fc843503          	ld	a0,-56(s0)
    8001d770:	1a0000ef          	jal	ra,8001d910 <virtio_has_received_descriptor>
    8001d774:	87aa                	mv	a5,a0
    8001d776:	0017c793          	xori	a5,a5,1
    8001d77a:	0ff7f793          	andi	a5,a5,255
    8001d77e:	cb89                	beqz	a5,8001d790 <virtio_receive_descriptor_chain+0x78>
        warnf("No descriptor received\n");
    8001d780:	0000b517          	auipc	a0,0xb
    8001d784:	2e050513          	addi	a0,a0,736 # 80028a60 <pow10.0+0x1c00>
    8001d788:	eb0fe0ef          	jal	ra,8001be38 <warnf>
        return 0;
    8001d78c:	4781                	li	a5,0
    8001d78e:	a209                	j	8001d890 <virtio_receive_descriptor_chain+0x178>
    }
    

    // Get the descriptor index from the device ring
    uint64_t descriptor_index = device->device->ring[device->device_idx % queue_size].id;
    8001d790:	fc843783          	ld	a5,-56(s0)
    8001d794:	7bb8                	ld	a4,112(a5)
    8001d796:	fc843783          	ld	a5,-56(s0)
    8001d79a:	08c7d783          	lhu	a5,140(a5)
    8001d79e:	86be                	mv	a3,a5
    8001d7a0:	fd843783          	ld	a5,-40(s0)
    8001d7a4:	02f6f7b3          	remu	a5,a3,a5
    8001d7a8:	078e                	slli	a5,a5,0x3
    8001d7aa:	97ba                	add	a5,a5,a4
    8001d7ac:	43dc                	lw	a5,4(a5)
    8001d7ae:	2781                	sext.w	a5,a5
    8001d7b0:	1782                	slli	a5,a5,0x20
    8001d7b2:	9381                	srli	a5,a5,0x20
    8001d7b4:	fcf43823          	sd	a5,-48(s0)
    // Get the length of the descriptor
    volatile VirtioDescriptor *descriptor = (volatile VirtioDescriptor*)&device->desc[descriptor_index];
    8001d7b8:	fc843783          	ld	a5,-56(s0)
    8001d7bc:	73b8                	ld	a4,96(a5)
    8001d7be:	fd043783          	ld	a5,-48(s0)
    8001d7c2:	0792                	slli	a5,a5,0x4
    8001d7c4:	97ba                	add	a5,a5,a4
    8001d7c6:	fef43423          	sd	a5,-24(s0)

    uint16_t i = 0;
    8001d7ca:	fe041323          	sh	zero,-26(s0)
    while (descriptor->flags & VIRTQ_DESC_F_NEXT) {
    8001d7ce:	a091                	j	8001d812 <virtio_receive_descriptor_chain+0xfa>
        received[i++] = *descriptor;
    8001d7d0:	fe645783          	lhu	a5,-26(s0)
    8001d7d4:	0017871b          	addiw	a4,a5,1
    8001d7d8:	fee41323          	sh	a4,-26(s0)
    8001d7dc:	0792                	slli	a5,a5,0x4
    8001d7de:	fb843703          	ld	a4,-72(s0)
    8001d7e2:	97ba                	add	a5,a5,a4
    8001d7e4:	fe843703          	ld	a4,-24(s0)
    8001d7e8:	6314                	ld	a3,0(a4)
    8001d7ea:	e394                	sd	a3,0(a5)
    8001d7ec:	6718                	ld	a4,8(a4)
    8001d7ee:	e798                	sd	a4,8(a5)
        // debugf("Reading descriptor %d from queue %d\n", descriptor_index, which_queue);
        // debugf("Descriptor addr: %p\n", descriptor->addr);
        // debugf("Descriptor len: 0x%x = %d\n", descriptor->len, descriptor->len);
        // debugf("Descriptor flags: 0x%x = %d\n", descriptor->flags, descriptor->flags);
        // debugf("Descriptor next: 0x%x = %d\n", descriptor->next, descriptor->next);
        descriptor_index = descriptor->next;
    8001d7f0:	fe843783          	ld	a5,-24(s0)
    8001d7f4:	00e7d783          	lhu	a5,14(a5)
    8001d7f8:	17c2                	slli	a5,a5,0x30
    8001d7fa:	93c1                	srli	a5,a5,0x30
    8001d7fc:	fcf43823          	sd	a5,-48(s0)
        descriptor = (volatile VirtioDescriptor*)&device->desc[descriptor_index];
    8001d800:	fc843783          	ld	a5,-56(s0)
    8001d804:	73b8                	ld	a4,96(a5)
    8001d806:	fd043783          	ld	a5,-48(s0)
    8001d80a:	0792                	slli	a5,a5,0x4
    8001d80c:	97ba                	add	a5,a5,a4
    8001d80e:	fef43423          	sd	a5,-24(s0)
    while (descriptor->flags & VIRTQ_DESC_F_NEXT) {
    8001d812:	fe843783          	ld	a5,-24(s0)
    8001d816:	00c7d783          	lhu	a5,12(a5)
    8001d81a:	17c2                	slli	a5,a5,0x30
    8001d81c:	93c1                	srli	a5,a5,0x30
    8001d81e:	2781                	sext.w	a5,a5
    8001d820:	8b85                	andi	a5,a5,1
    8001d822:	2781                	sext.w	a5,a5
    8001d824:	f7d5                	bnez	a5,8001d7d0 <virtio_receive_descriptor_chain+0xb8>
    }

    received[i] = *descriptor;
    8001d826:	fe645783          	lhu	a5,-26(s0)
    8001d82a:	0792                	slli	a5,a5,0x4
    8001d82c:	fb843703          	ld	a4,-72(s0)
    8001d830:	97ba                	add	a5,a5,a4
    8001d832:	fe843703          	ld	a4,-24(s0)
    8001d836:	6314                	ld	a3,0(a4)
    8001d838:	e394                	sd	a3,0(a5)
    8001d83a:	6718                	ld	a4,8(a4)
    8001d83c:	e798                	sd	a4,8(a5)
    // debugf("Reading descriptor %d from queue %d\n", i, which_queue);
    // debugf("Descriptor addr: %p\n", descriptor->addr);
    // debugf("Descriptor len: 0x%x = %d\n", descriptor->len, descriptor->len);
    // debugf("Descriptor flags: 0x%x = %d\n", descriptor->flags, descriptor->flags);
    // debugf("Descriptor next: 0x%x = %d\n", descriptor->next, descriptor->next);
    i++;
    8001d83e:	fe645783          	lhu	a5,-26(s0)
    8001d842:	2785                	addiw	a5,a5,1
    8001d844:	fef41323          	sh	a5,-26(s0)
    // device->device_idx = device->device->idx;
    if (i > max_descriptors) {
    8001d848:	fe645703          	lhu	a4,-26(s0)
    8001d84c:	fc445783          	lhu	a5,-60(s0)
    8001d850:	2701                	sext.w	a4,a4
    8001d852:	2781                	sext.w	a5,a5
    8001d854:	02e7f063          	bgeu	a5,a4,8001d874 <virtio_receive_descriptor_chain+0x15c>
        warnf("Received %d descriptors, but expected %d or fewer\n", i, max_descriptors);
    8001d858:	fe645783          	lhu	a5,-26(s0)
    8001d85c:	2781                	sext.w	a5,a5
    8001d85e:	fc445703          	lhu	a4,-60(s0)
    8001d862:	2701                	sext.w	a4,a4
    8001d864:	863a                	mv	a2,a4
    8001d866:	85be                	mv	a1,a5
    8001d868:	0000b517          	auipc	a0,0xb
    8001d86c:	21050513          	addi	a0,a0,528 # 80028a78 <pow10.0+0x1c18>
    8001d870:	dc8fe0ef          	jal	ra,8001be38 <warnf>
    }
    device->device_idx++;
    8001d874:	fc843783          	ld	a5,-56(s0)
    8001d878:	08c7d783          	lhu	a5,140(a5)
    8001d87c:	2785                	addiw	a5,a5,1
    8001d87e:	03079713          	slli	a4,a5,0x30
    8001d882:	9341                	srli	a4,a4,0x30
    8001d884:	fc843783          	ld	a5,-56(s0)
    8001d888:	08e79623          	sh	a4,140(a5)
    return i;
    8001d88c:	fe645783          	lhu	a5,-26(s0)
}
    8001d890:	853e                	mv	a0,a5
    8001d892:	60a6                	ld	ra,72(sp)
    8001d894:	6406                	ld	s0,64(sp)
    8001d896:	6161                	addi	sp,sp,80
    8001d898:	8082                	ret

000000008001d89a <virtio_receive_one_descriptor>:

VirtioDescriptor virtio_receive_one_descriptor(VirtioDevice *device, uint16_t which_queue, bool wait_for_descriptor) {
    8001d89a:	715d                	addi	sp,sp,-80
    8001d89c:	e486                	sd	ra,72(sp)
    8001d89e:	e0a2                	sd	s0,64(sp)
    8001d8a0:	fc4a                	sd	s2,56(sp)
    8001d8a2:	f84e                	sd	s3,48(sp)
    8001d8a4:	0880                	addi	s0,sp,80
    8001d8a6:	faa43c23          	sd	a0,-72(s0)
    8001d8aa:	87ae                	mv	a5,a1
    8001d8ac:	8732                	mv	a4,a2
    8001d8ae:	faf41b23          	sh	a5,-74(s0)
    8001d8b2:	87ba                	mv	a5,a4
    8001d8b4:	faf40aa3          	sb	a5,-75(s0)
    VirtioDescriptor received;
    received.addr = 0;
    8001d8b8:	fc043023          	sd	zero,-64(s0)
    received.flags = 0;
    8001d8bc:	fc041623          	sh	zero,-52(s0)
    received.len = 0;
    8001d8c0:	fc042423          	sw	zero,-56(s0)
    received.next = 0;
    8001d8c4:	fc041723          	sh	zero,-50(s0)
    virtio_receive_descriptor_chain(device, which_queue, &received, 1, wait_for_descriptor);
    8001d8c8:	fb544703          	lbu	a4,-75(s0)
    8001d8cc:	fc040613          	addi	a2,s0,-64
    8001d8d0:	fb645783          	lhu	a5,-74(s0)
    8001d8d4:	4685                	li	a3,1
    8001d8d6:	85be                	mv	a1,a5
    8001d8d8:	fb843503          	ld	a0,-72(s0)
    8001d8dc:	e3dff0ef          	jal	ra,8001d718 <virtio_receive_descriptor_chain>
    return received;
    8001d8e0:	fc043783          	ld	a5,-64(s0)
    8001d8e4:	fcf43823          	sd	a5,-48(s0)
    8001d8e8:	fc843783          	ld	a5,-56(s0)
    8001d8ec:	fcf43c23          	sd	a5,-40(s0)
    8001d8f0:	fd043703          	ld	a4,-48(s0)
    8001d8f4:	fd843783          	ld	a5,-40(s0)
    8001d8f8:	893a                	mv	s2,a4
    8001d8fa:	89be                	mv	s3,a5
    8001d8fc:	874a                	mv	a4,s2
    8001d8fe:	87ce                	mv	a5,s3
}
    8001d900:	853a                	mv	a0,a4
    8001d902:	85be                	mv	a1,a5
    8001d904:	60a6                	ld	ra,72(sp)
    8001d906:	6406                	ld	s0,64(sp)
    8001d908:	7962                	ld	s2,56(sp)
    8001d90a:	79c2                	ld	s3,48(sp)
    8001d90c:	6161                	addi	sp,sp,80
    8001d90e:	8082                	ret

000000008001d910 <virtio_has_received_descriptor>:

bool virtio_has_received_descriptor(VirtioDevice *device, uint16_t which_queue) {
    8001d910:	1101                	addi	sp,sp,-32
    8001d912:	ec06                	sd	ra,24(sp)
    8001d914:	e822                	sd	s0,16(sp)
    8001d916:	1000                	addi	s0,sp,32
    8001d918:	fea43423          	sd	a0,-24(s0)
    8001d91c:	87ae                	mv	a5,a1
    8001d91e:	fef41323          	sh	a5,-26(s0)
    virtio_set_queue_and_get_size(device, which_queue);
    8001d922:	fe645783          	lhu	a5,-26(s0)
    8001d926:	85be                	mv	a1,a5
    8001d928:	fe843503          	ld	a0,-24(s0)
    8001d92c:	af5ff0ef          	jal	ra,8001d420 <virtio_set_queue_and_get_size>
    if (device->device_idx == device->device->idx) {
    8001d930:	fe843783          	ld	a5,-24(s0)
    8001d934:	08c7d703          	lhu	a4,140(a5)
    8001d938:	fe843783          	ld	a5,-24(s0)
    8001d93c:	7bbc                	ld	a5,112(a5)
    8001d93e:	0027d783          	lhu	a5,2(a5)
    8001d942:	17c2                	slli	a5,a5,0x30
    8001d944:	93c1                	srli	a5,a5,0x30
    8001d946:	2701                	sext.w	a4,a4
    8001d948:	2781                	sext.w	a5,a5
    8001d94a:	00f71463          	bne	a4,a5,8001d952 <virtio_has_received_descriptor+0x42>
        return false;
    8001d94e:	4781                	li	a5,0
    8001d950:	a011                	j	8001d954 <virtio_has_received_descriptor+0x44>
    }
    return true;
    8001d952:	4785                	li	a5,1
}
    8001d954:	853e                	mv	a0,a5
    8001d956:	60e2                	ld	ra,24(sp)
    8001d958:	6442                	ld	s0,16(sp)
    8001d95a:	6105                	addi	sp,sp,32
    8001d95c:	8082                	ret

000000008001d95e <virtio_wait_for_descriptor>:

void virtio_wait_for_descriptor(VirtioDevice *device, uint16_t which_queue) {
    8001d95e:	1101                	addi	sp,sp,-32
    8001d960:	ec06                	sd	ra,24(sp)
    8001d962:	e822                	sd	s0,16(sp)
    8001d964:	1000                	addi	s0,sp,32
    8001d966:	fea43423          	sd	a0,-24(s0)
    8001d96a:	87ae                	mv	a5,a1
    8001d96c:	fef41323          	sh	a5,-26(s0)
    while (!virtio_has_received_descriptor(device, which_queue)) {
    8001d970:	0001                	nop
    8001d972:	fe645783          	lhu	a5,-26(s0)
    8001d976:	85be                	mv	a1,a5
    8001d978:	fe843503          	ld	a0,-24(s0)
    8001d97c:	f95ff0ef          	jal	ra,8001d910 <virtio_has_received_descriptor>
    8001d980:	87aa                	mv	a5,a0
    8001d982:	0017c793          	xori	a5,a5,1
    8001d986:	0ff7f793          	andi	a5,a5,255
    8001d98a:	f7e5                	bnez	a5,8001d972 <virtio_wait_for_descriptor+0x14>
        debugf("Blocking on descriptor\n");
        // Do nothing
    }
}
    8001d98c:	0001                	nop
    8001d98e:	0001                	nop
    8001d990:	60e2                	ld	ra,24(sp)
    8001d992:	6442                	ld	s0,16(sp)
    8001d994:	6105                	addi	sp,sp,32
    8001d996:	8082                	ret

000000008001d998 <set_taken>:

static uint8_t *bookkeeping;  // Pointer to the bookkeeping area

// For some reason, the macros didn't work for me, so I used the static functions like Marz said and it works.
static void set_taken(uint64_t index)
{
    8001d998:	1101                	addi	sp,sp,-32
    8001d99a:	ec22                	sd	s0,24(sp)
    8001d99c:	1000                	addi	s0,sp,32
    8001d99e:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2));
    8001d9a2:	00007797          	auipc	a5,0x7
    8001d9a6:	7b678793          	addi	a5,a5,1974 # 80025158 <bookkeeping>
    8001d9aa:	6398                	ld	a4,0(a5)
    8001d9ac:	fe843783          	ld	a5,-24(s0)
    8001d9b0:	8389                	srli	a5,a5,0x2
    8001d9b2:	973e                	add	a4,a4,a5
    8001d9b4:	00074703          	lbu	a4,0(a4) # ffffffffc0fff000 <_heap_end+0xffffffff38fef000>
    8001d9b8:	0187169b          	slliw	a3,a4,0x18
    8001d9bc:	4186d69b          	sraiw	a3,a3,0x18
    8001d9c0:	fe843703          	ld	a4,-24(s0)
    8001d9c4:	2701                	sext.w	a4,a4
    8001d9c6:	8b0d                	andi	a4,a4,3
    8001d9c8:	2701                	sext.w	a4,a4
    8001d9ca:	0017171b          	slliw	a4,a4,0x1
    8001d9ce:	2701                	sext.w	a4,a4
    8001d9d0:	4605                	li	a2,1
    8001d9d2:	00e6173b          	sllw	a4,a2,a4
    8001d9d6:	2701                	sext.w	a4,a4
    8001d9d8:	0187171b          	slliw	a4,a4,0x18
    8001d9dc:	4187571b          	sraiw	a4,a4,0x18
    8001d9e0:	8f55                	or	a4,a4,a3
    8001d9e2:	0187169b          	slliw	a3,a4,0x18
    8001d9e6:	4186d69b          	sraiw	a3,a3,0x18
    8001d9ea:	00007717          	auipc	a4,0x7
    8001d9ee:	76e70713          	addi	a4,a4,1902 # 80025158 <bookkeeping>
    8001d9f2:	6318                	ld	a4,0(a4)
    8001d9f4:	97ba                	add	a5,a5,a4
    8001d9f6:	0ff6f713          	andi	a4,a3,255
    8001d9fa:	00e78023          	sb	a4,0(a5)
}
    8001d9fe:	0001                	nop
    8001da00:	6462                	ld	s0,24(sp)
    8001da02:	6105                	addi	sp,sp,32
    8001da04:	8082                	ret

000000008001da06 <clear_taken>:

static void clear_taken(uint64_t index)
{
    8001da06:	1101                	addi	sp,sp,-32
    8001da08:	ec22                	sd	s0,24(sp)
    8001da0a:	1000                	addi	s0,sp,32
    8001da0c:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2));
    8001da10:	00007797          	auipc	a5,0x7
    8001da14:	74878793          	addi	a5,a5,1864 # 80025158 <bookkeeping>
    8001da18:	6398                	ld	a4,0(a5)
    8001da1a:	fe843783          	ld	a5,-24(s0)
    8001da1e:	8389                	srli	a5,a5,0x2
    8001da20:	973e                	add	a4,a4,a5
    8001da22:	00074703          	lbu	a4,0(a4)
    8001da26:	0187169b          	slliw	a3,a4,0x18
    8001da2a:	4186d69b          	sraiw	a3,a3,0x18
    8001da2e:	fe843703          	ld	a4,-24(s0)
    8001da32:	2701                	sext.w	a4,a4
    8001da34:	8b0d                	andi	a4,a4,3
    8001da36:	2701                	sext.w	a4,a4
    8001da38:	0017171b          	slliw	a4,a4,0x1
    8001da3c:	2701                	sext.w	a4,a4
    8001da3e:	4605                	li	a2,1
    8001da40:	00e6173b          	sllw	a4,a2,a4
    8001da44:	2701                	sext.w	a4,a4
    8001da46:	0187171b          	slliw	a4,a4,0x18
    8001da4a:	4187571b          	sraiw	a4,a4,0x18
    8001da4e:	fff74713          	not	a4,a4
    8001da52:	0187171b          	slliw	a4,a4,0x18
    8001da56:	4187571b          	sraiw	a4,a4,0x18
    8001da5a:	8f75                	and	a4,a4,a3
    8001da5c:	0187169b          	slliw	a3,a4,0x18
    8001da60:	4186d69b          	sraiw	a3,a3,0x18
    8001da64:	00007717          	auipc	a4,0x7
    8001da68:	6f470713          	addi	a4,a4,1780 # 80025158 <bookkeeping>
    8001da6c:	6318                	ld	a4,0(a4)
    8001da6e:	97ba                	add	a5,a5,a4
    8001da70:	0ff6f713          	andi	a4,a3,255
    8001da74:	00e78023          	sb	a4,0(a5)
}
    8001da78:	0001                	nop
    8001da7a:	6462                	ld	s0,24(sp)
    8001da7c:	6105                	addi	sp,sp,32
    8001da7e:	8082                	ret

000000008001da80 <is_taken>:

static int is_taken(uint64_t index)
{
    8001da80:	1101                	addi	sp,sp,-32
    8001da82:	ec22                	sd	s0,24(sp)
    8001da84:	1000                	addi	s0,sp,32
    8001da86:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2));
    8001da8a:	00007797          	auipc	a5,0x7
    8001da8e:	6ce78793          	addi	a5,a5,1742 # 80025158 <bookkeeping>
    8001da92:	6398                	ld	a4,0(a5)
    8001da94:	fe843783          	ld	a5,-24(s0)
    8001da98:	8389                	srli	a5,a5,0x2
    8001da9a:	97ba                	add	a5,a5,a4
    8001da9c:	0007c783          	lbu	a5,0(a5)
    8001daa0:	0007871b          	sext.w	a4,a5
    8001daa4:	fe843783          	ld	a5,-24(s0)
    8001daa8:	2781                	sext.w	a5,a5
    8001daaa:	8b8d                	andi	a5,a5,3
    8001daac:	2781                	sext.w	a5,a5
    8001daae:	0017979b          	slliw	a5,a5,0x1
    8001dab2:	2781                	sext.w	a5,a5
    8001dab4:	4685                	li	a3,1
    8001dab6:	00f697bb          	sllw	a5,a3,a5
    8001daba:	2781                	sext.w	a5,a5
    8001dabc:	8ff9                	and	a5,a5,a4
    8001dabe:	2781                	sext.w	a5,a5
}
    8001dac0:	853e                	mv	a0,a5
    8001dac2:	6462                	ld	s0,24(sp)
    8001dac4:	6105                	addi	sp,sp,32
    8001dac6:	8082                	ret

000000008001dac8 <set_last>:

static void set_last(uint64_t index)
{
    8001dac8:	1101                	addi	sp,sp,-32
    8001daca:	ec22                	sd	s0,24(sp)
    8001dacc:	1000                	addi	s0,sp,32
    8001dace:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] |= (1 << ((index % 4) * 2 + 1));
    8001dad2:	00007797          	auipc	a5,0x7
    8001dad6:	68678793          	addi	a5,a5,1670 # 80025158 <bookkeeping>
    8001dada:	6398                	ld	a4,0(a5)
    8001dadc:	fe843783          	ld	a5,-24(s0)
    8001dae0:	8389                	srli	a5,a5,0x2
    8001dae2:	973e                	add	a4,a4,a5
    8001dae4:	00074703          	lbu	a4,0(a4)
    8001dae8:	0187169b          	slliw	a3,a4,0x18
    8001daec:	4186d69b          	sraiw	a3,a3,0x18
    8001daf0:	fe843703          	ld	a4,-24(s0)
    8001daf4:	2701                	sext.w	a4,a4
    8001daf6:	8b0d                	andi	a4,a4,3
    8001daf8:	2701                	sext.w	a4,a4
    8001dafa:	0017171b          	slliw	a4,a4,0x1
    8001dafe:	2701                	sext.w	a4,a4
    8001db00:	2705                	addiw	a4,a4,1
    8001db02:	2701                	sext.w	a4,a4
    8001db04:	4605                	li	a2,1
    8001db06:	00e6173b          	sllw	a4,a2,a4
    8001db0a:	2701                	sext.w	a4,a4
    8001db0c:	0187171b          	slliw	a4,a4,0x18
    8001db10:	4187571b          	sraiw	a4,a4,0x18
    8001db14:	8f55                	or	a4,a4,a3
    8001db16:	0187169b          	slliw	a3,a4,0x18
    8001db1a:	4186d69b          	sraiw	a3,a3,0x18
    8001db1e:	00007717          	auipc	a4,0x7
    8001db22:	63a70713          	addi	a4,a4,1594 # 80025158 <bookkeeping>
    8001db26:	6318                	ld	a4,0(a4)
    8001db28:	97ba                	add	a5,a5,a4
    8001db2a:	0ff6f713          	andi	a4,a3,255
    8001db2e:	00e78023          	sb	a4,0(a5)
}
    8001db32:	0001                	nop
    8001db34:	6462                	ld	s0,24(sp)
    8001db36:	6105                	addi	sp,sp,32
    8001db38:	8082                	ret

000000008001db3a <clear_last>:

static void clear_last(uint64_t index)
{
    8001db3a:	1101                	addi	sp,sp,-32
    8001db3c:	ec22                	sd	s0,24(sp)
    8001db3e:	1000                	addi	s0,sp,32
    8001db40:	fea43423          	sd	a0,-24(s0)
    bookkeeping[index / 4] &= ~(1 << ((index % 4) * 2 + 1));
    8001db44:	00007797          	auipc	a5,0x7
    8001db48:	61478793          	addi	a5,a5,1556 # 80025158 <bookkeeping>
    8001db4c:	6398                	ld	a4,0(a5)
    8001db4e:	fe843783          	ld	a5,-24(s0)
    8001db52:	8389                	srli	a5,a5,0x2
    8001db54:	973e                	add	a4,a4,a5
    8001db56:	00074703          	lbu	a4,0(a4)
    8001db5a:	0187169b          	slliw	a3,a4,0x18
    8001db5e:	4186d69b          	sraiw	a3,a3,0x18
    8001db62:	fe843703          	ld	a4,-24(s0)
    8001db66:	2701                	sext.w	a4,a4
    8001db68:	8b0d                	andi	a4,a4,3
    8001db6a:	2701                	sext.w	a4,a4
    8001db6c:	0017171b          	slliw	a4,a4,0x1
    8001db70:	2701                	sext.w	a4,a4
    8001db72:	2705                	addiw	a4,a4,1
    8001db74:	2701                	sext.w	a4,a4
    8001db76:	4605                	li	a2,1
    8001db78:	00e6173b          	sllw	a4,a2,a4
    8001db7c:	2701                	sext.w	a4,a4
    8001db7e:	0187171b          	slliw	a4,a4,0x18
    8001db82:	4187571b          	sraiw	a4,a4,0x18
    8001db86:	fff74713          	not	a4,a4
    8001db8a:	0187171b          	slliw	a4,a4,0x18
    8001db8e:	4187571b          	sraiw	a4,a4,0x18
    8001db92:	8f75                	and	a4,a4,a3
    8001db94:	0187169b          	slliw	a3,a4,0x18
    8001db98:	4186d69b          	sraiw	a3,a3,0x18
    8001db9c:	00007717          	auipc	a4,0x7
    8001dba0:	5bc70713          	addi	a4,a4,1468 # 80025158 <bookkeeping>
    8001dba4:	6318                	ld	a4,0(a4)
    8001dba6:	97ba                	add	a5,a5,a4
    8001dba8:	0ff6f713          	andi	a4,a3,255
    8001dbac:	00e78023          	sb	a4,0(a5)
}
    8001dbb0:	0001                	nop
    8001dbb2:	6462                	ld	s0,24(sp)
    8001dbb4:	6105                	addi	sp,sp,32
    8001dbb6:	8082                	ret

000000008001dbb8 <is_last>:

static int is_last(uint64_t index)
{
    8001dbb8:	1101                	addi	sp,sp,-32
    8001dbba:	ec22                	sd	s0,24(sp)
    8001dbbc:	1000                	addi	s0,sp,32
    8001dbbe:	fea43423          	sd	a0,-24(s0)
    return bookkeeping[index / 4] & (1 << ((index % 4) * 2 + 1));
    8001dbc2:	00007797          	auipc	a5,0x7
    8001dbc6:	59678793          	addi	a5,a5,1430 # 80025158 <bookkeeping>
    8001dbca:	6398                	ld	a4,0(a5)
    8001dbcc:	fe843783          	ld	a5,-24(s0)
    8001dbd0:	8389                	srli	a5,a5,0x2
    8001dbd2:	97ba                	add	a5,a5,a4
    8001dbd4:	0007c783          	lbu	a5,0(a5)
    8001dbd8:	0007871b          	sext.w	a4,a5
    8001dbdc:	fe843783          	ld	a5,-24(s0)
    8001dbe0:	2781                	sext.w	a5,a5
    8001dbe2:	8b8d                	andi	a5,a5,3
    8001dbe4:	2781                	sext.w	a5,a5
    8001dbe6:	0017979b          	slliw	a5,a5,0x1
    8001dbea:	2781                	sext.w	a5,a5
    8001dbec:	2785                	addiw	a5,a5,1
    8001dbee:	2781                	sext.w	a5,a5
    8001dbf0:	4685                	li	a3,1
    8001dbf2:	00f697bb          	sllw	a5,a3,a5
    8001dbf6:	2781                	sext.w	a5,a5
    8001dbf8:	8ff9                	and	a5,a5,a4
    8001dbfa:	2781                	sext.w	a5,a5
}
    8001dbfc:	853e                	mv	a0,a5
    8001dbfe:	6462                	ld	s0,24(sp)
    8001dc00:	6105                	addi	sp,sp,32
    8001dc02:	8082                	ret

000000008001dc04 <page_init>:

void page_init(void)
{
    8001dc04:	1101                	addi	sp,sp,-32
    8001dc06:	ec06                	sd	ra,24(sp)
    8001dc08:	e822                	sd	s0,16(sp)
    8001dc0a:	1000                	addi	s0,sp,32
    /* Initialize the page system. */
    bookkeeping = (uint8_t*)sym_start(heap);
    8001dc0c:	00007797          	auipc	a5,0x7
    8001dc10:	54c78793          	addi	a5,a5,1356 # 80025158 <bookkeeping>
    8001dc14:	00015717          	auipc	a4,0x15
    8001dc18:	3ec70713          	addi	a4,a4,1004 # 80033000 <_heap_start>
    8001dc1c:	e398                	sd	a4,0(a5)
    
    // Print bookkeeping area
    mutex_spinlock(&page_lock);
    8001dc1e:	00007517          	auipc	a0,0x7
    8001dc22:	3f250513          	addi	a0,a0,1010 # 80025010 <page_lock>
    8001dc26:	a15f70ef          	jal	ra,8001563a <mutex_spinlock>

    // Initialize the bookkeeping area
    memset(bookkeeping, 0, BK_SIZE_IN_BYTES);
    8001dc2a:	00007797          	auipc	a5,0x7
    8001dc2e:	52e78793          	addi	a5,a5,1326 # 80025158 <bookkeeping>
    8001dc32:	6394                	ld	a3,0(a5)
    8001dc34:	07ff2717          	auipc	a4,0x7ff2
    8001dc38:	3cc70713          	addi	a4,a4,972 # 88010000 <_heap_end>
    8001dc3c:	00015797          	auipc	a5,0x15
    8001dc40:	3c478793          	addi	a5,a5,964 # 80033000 <_heap_start>
    8001dc44:	40f707b3          	sub	a5,a4,a5
    8001dc48:	83b9                	srli	a5,a5,0xe
    8001dc4a:	0007871b          	sext.w	a4,a5
    8001dc4e:	6785                	lui	a5,0x1
    8001dc50:	37fd                	addiw	a5,a5,-1
    8001dc52:	9fb9                	addw	a5,a5,a4
    8001dc54:	2781                	sext.w	a5,a5
    8001dc56:	0007871b          	sext.w	a4,a5
    8001dc5a:	77fd                	lui	a5,0xfffff
    8001dc5c:	8ff9                	and	a5,a5,a4
    8001dc5e:	2781                	sext.w	a5,a5
    8001dc60:	863e                	mv	a2,a5
    8001dc62:	4581                	li	a1,0
    8001dc64:	8536                	mv	a0,a3
    8001dc66:	5d6040ef          	jal	ra,8002223c <memset>
    // Mark the bookkeeping pages as taken
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    8001dc6a:	fe043423          	sd	zero,-24(s0)
    8001dc6e:	a811                	j	8001dc82 <page_init+0x7e>
        set_taken(i);
    8001dc70:	fe843503          	ld	a0,-24(s0)
    8001dc74:	d25ff0ef          	jal	ra,8001d998 <set_taken>
    for (uint64_t i = 0; i < BK_SIZE_IN_PAGES; i++) {
    8001dc78:	fe843783          	ld	a5,-24(s0)
    8001dc7c:	0785                	addi	a5,a5,1
    8001dc7e:	fef43423          	sd	a5,-24(s0)
    8001dc82:	07ff2717          	auipc	a4,0x7ff2
    8001dc86:	37e70713          	addi	a4,a4,894 # 88010000 <_heap_end>
    8001dc8a:	00015797          	auipc	a5,0x15
    8001dc8e:	37678793          	addi	a5,a5,886 # 80033000 <_heap_start>
    8001dc92:	40f707b3          	sub	a5,a4,a5
    8001dc96:	00e7d713          	srli	a4,a5,0xe
    8001dc9a:	6785                	lui	a5,0x1
    8001dc9c:	17fd                	addi	a5,a5,-1
    8001dc9e:	97ba                	add	a5,a5,a4
    8001dca0:	83b1                	srli	a5,a5,0xc
    8001dca2:	fe843703          	ld	a4,-24(s0)
    8001dca6:	fcf765e3          	bltu	a4,a5,8001dc70 <page_init+0x6c>
    }
    set_last(BK_SIZE_IN_PAGES-1);
    8001dcaa:	07ff2717          	auipc	a4,0x7ff2
    8001dcae:	35670713          	addi	a4,a4,854 # 88010000 <_heap_end>
    8001dcb2:	00015797          	auipc	a5,0x15
    8001dcb6:	34e78793          	addi	a5,a5,846 # 80033000 <_heap_start>
    8001dcba:	40f707b3          	sub	a5,a4,a5
    8001dcbe:	00e7d713          	srli	a4,a5,0xe
    8001dcc2:	6785                	lui	a5,0x1
    8001dcc4:	17fd                	addi	a5,a5,-1
    8001dcc6:	97ba                	add	a5,a5,a4
    8001dcc8:	83b1                	srli	a5,a5,0xc
    8001dcca:	17fd                	addi	a5,a5,-1
    8001dccc:	853e                	mv	a0,a5
    8001dcce:	dfbff0ef          	jal	ra,8001dac8 <set_last>

    debugf("page_init: bookkeeping area initialized\n");
    debugf("page_init: bookkeeping area starts at 0x%08lx\n", bookkeeping);
    debugf("page_init: bookkeeping area ends at 0x%08lx\n", bookkeeping + BK_SIZE_IN_BYTES);
    mutex_unlock(&page_lock);
    8001dcd2:	00007517          	auipc	a0,0x7
    8001dcd6:	33e50513          	addi	a0,a0,830 # 80025010 <page_lock>
    8001dcda:	98ff70ef          	jal	ra,80015668 <mutex_unlock>

    // Print out the bookkeeping area's contents
    logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    8001dcde:	00007797          	auipc	a5,0x7
    8001dce2:	47a78793          	addi	a5,a5,1146 # 80025158 <bookkeeping>
    8001dce6:	6390                	ld	a2,0(a5)
    8001dce8:	00007797          	auipc	a5,0x7
    8001dcec:	47078793          	addi	a5,a5,1136 # 80025158 <bookkeeping>
    8001dcf0:	6398                	ld	a4,0(a5)
    8001dcf2:	07ff2697          	auipc	a3,0x7ff2
    8001dcf6:	30e68693          	addi	a3,a3,782 # 88010000 <_heap_end>
    8001dcfa:	00015797          	auipc	a5,0x15
    8001dcfe:	30678793          	addi	a5,a5,774 # 80033000 <_heap_start>
    8001dd02:	40f687b3          	sub	a5,a3,a5
    8001dd06:	00e7d693          	srli	a3,a5,0xe
    8001dd0a:	6785                	lui	a5,0x1
    8001dd0c:	17fd                	addi	a5,a5,-1
    8001dd0e:	96be                	add	a3,a3,a5
    8001dd10:	77fd                	lui	a5,0xfffff
    8001dd12:	8ff5                	and	a5,a5,a3
    8001dd14:	97ba                	add	a5,a5,a4
    8001dd16:	86be                	mv	a3,a5
    8001dd18:	0000b597          	auipc	a1,0xb
    8001dd1c:	d9858593          	addi	a1,a1,-616 # 80028ab0 <pow10.0+0x1c50>
    8001dd20:	4511                	li	a0,4
    8001dd22:	862fe0ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  Heap: 0x%08lx -> 0x%08lx", bookkeeping + BK_SIZE_IN_BYTES, bookkeeping + HEAP_SIZE_IN_BYTES);
    8001dd26:	00007797          	auipc	a5,0x7
    8001dd2a:	43278793          	addi	a5,a5,1074 # 80025158 <bookkeeping>
    8001dd2e:	6398                	ld	a4,0(a5)
    8001dd30:	07ff2697          	auipc	a3,0x7ff2
    8001dd34:	2d068693          	addi	a3,a3,720 # 88010000 <_heap_end>
    8001dd38:	00015797          	auipc	a5,0x15
    8001dd3c:	2c878793          	addi	a5,a5,712 # 80033000 <_heap_start>
    8001dd40:	40f687b3          	sub	a5,a3,a5
    8001dd44:	00e7d693          	srli	a3,a5,0xe
    8001dd48:	6785                	lui	a5,0x1
    8001dd4a:	17fd                	addi	a5,a5,-1
    8001dd4c:	96be                	add	a3,a3,a5
    8001dd4e:	77fd                	lui	a5,0xfffff
    8001dd50:	8ff5                	and	a5,a5,a3
    8001dd52:	00f70633          	add	a2,a4,a5
    8001dd56:	00007797          	auipc	a5,0x7
    8001dd5a:	40278793          	addi	a5,a5,1026 # 80025158 <bookkeeping>
    8001dd5e:	6398                	ld	a4,0(a5)
    8001dd60:	07ff2697          	auipc	a3,0x7ff2
    8001dd64:	2a068693          	addi	a3,a3,672 # 88010000 <_heap_end>
    8001dd68:	00015797          	auipc	a5,0x15
    8001dd6c:	29878793          	addi	a5,a5,664 # 80033000 <_heap_start>
    8001dd70:	40f687b3          	sub	a5,a3,a5
    8001dd74:	97ba                	add	a5,a5,a4
    8001dd76:	86be                	mv	a3,a5
    8001dd78:	0000b597          	auipc	a1,0xb
    8001dd7c:	d5858593          	addi	a1,a1,-680 # 80028ad0 <pow10.0+0x1c70>
    8001dd80:	4511                	li	a0,4
    8001dd82:	802fe0ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    8001dd86:	07ff2717          	auipc	a4,0x7ff2
    8001dd8a:	27a70713          	addi	a4,a4,634 # 88010000 <_heap_end>
    8001dd8e:	00015797          	auipc	a5,0x15
    8001dd92:	27278793          	addi	a5,a5,626 # 80033000 <_heap_start>
    8001dd96:	40f70633          	sub	a2,a4,a5
    8001dd9a:	07ff2717          	auipc	a4,0x7ff2
    8001dd9e:	26670713          	addi	a4,a4,614 # 88010000 <_heap_end>
    8001dda2:	00015797          	auipc	a5,0x15
    8001dda6:	25e78793          	addi	a5,a5,606 # 80033000 <_heap_start>
    8001ddaa:	40f707b3          	sub	a5,a4,a5
    8001ddae:	83b1                	srli	a5,a5,0xc
    8001ddb0:	86be                	mv	a3,a5
    8001ddb2:	0000b597          	auipc	a1,0xb
    8001ddb6:	d3e58593          	addi	a1,a1,-706 # 80028af0 <pow10.0+0x1c90>
    8001ddba:	4511                	li	a0,4
    8001ddbc:	fc9fd0ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    8001ddc0:	07ff2717          	auipc	a4,0x7ff2
    8001ddc4:	24070713          	addi	a4,a4,576 # 88010000 <_heap_end>
    8001ddc8:	00015797          	auipc	a5,0x15
    8001ddcc:	23878793          	addi	a5,a5,568 # 80033000 <_heap_start>
    8001ddd0:	40f707b3          	sub	a5,a4,a5
    8001ddd4:	00e7d713          	srli	a4,a5,0xe
    8001ddd8:	6785                	lui	a5,0x1
    8001ddda:	17fd                	addi	a5,a5,-1
    8001dddc:	973e                	add	a4,a4,a5
    8001ddde:	77fd                	lui	a5,0xfffff
    8001dde0:	00f77633          	and	a2,a4,a5
    8001dde4:	07ff2717          	auipc	a4,0x7ff2
    8001dde8:	21c70713          	addi	a4,a4,540 # 88010000 <_heap_end>
    8001ddec:	00015797          	auipc	a5,0x15
    8001ddf0:	21478793          	addi	a5,a5,532 # 80033000 <_heap_start>
    8001ddf4:	40f707b3          	sub	a5,a4,a5
    8001ddf8:	00e7d713          	srli	a4,a5,0xe
    8001ddfc:	6785                	lui	a5,0x1
    8001ddfe:	17fd                	addi	a5,a5,-1
    8001de00:	97ba                	add	a5,a5,a4
    8001de02:	83b1                	srli	a5,a5,0xc
    8001de04:	86be                	mv	a3,a5
    8001de06:	0000b597          	auipc	a1,0xb
    8001de0a:	d1258593          	addi	a1,a1,-750 # 80028b18 <pow10.0+0x1cb8>
    8001de0e:	4511                	li	a0,4
    8001de10:	f75fd0ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    8001de14:	31a000ef          	jal	ra,8001e12e <page_count_taken>
    8001de18:	87aa                	mv	a5,a0
    8001de1a:	863e                	mv	a2,a5
    8001de1c:	0000b597          	auipc	a1,0xb
    8001de20:	d2c58593          	addi	a1,a1,-724 # 80028b48 <pow10.0+0x1ce8>
    8001de24:	4511                	li	a0,4
    8001de26:	f5ffd0ef          	jal	ra,8001bd84 <logf>
    logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
    8001de2a:	28e000ef          	jal	ra,8001e0b8 <page_count_free>
    8001de2e:	87aa                	mv	a5,a0
    8001de30:	863e                	mv	a2,a5
    8001de32:	0000b597          	auipc	a1,0xb
    8001de36:	d2e58593          	addi	a1,a1,-722 # 80028b60 <pow10.0+0x1d00>
    8001de3a:	4511                	li	a0,4
    8001de3c:	f49fd0ef          	jal	ra,8001bd84 <logf>
    // logf(LOG_INFO, "Page Init: 0x%08lx -> 0x%08lx\n", bookkeeping, bookkeeping + BK_SIZE_IN_BYTES);
    // logf(LOG_INFO, "  Heap size: 0x%lx bytes, %lu pages\n", HEAP_SIZE_IN_BYTES, HEAP_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Bookkeeping size: 0x%lx bytes, %lu pages\n", BK_SIZE_IN_BYTES, BK_SIZE_IN_PAGES);
    // logf(LOG_INFO, "  Taken pages: %lu\n", page_count_taken());
    // logf(LOG_INFO, "  Free pages: %lu\n", page_count_free());
}
    8001de40:	0001                	nop
    8001de42:	60e2                	ld	ra,24(sp)
    8001de44:	6442                	ld	s0,16(sp)
    8001de46:	6105                	addi	sp,sp,32
    8001de48:	8082                	ret

000000008001de4a <page_nalloc>:

void *page_nalloc(int n)
{
    8001de4a:	7139                	addi	sp,sp,-64
    8001de4c:	fc06                	sd	ra,56(sp)
    8001de4e:	f822                	sd	s0,48(sp)
    8001de50:	0080                	addi	s0,sp,64
    8001de52:	87aa                	mv	a5,a0
    8001de54:	fcf42623          	sw	a5,-52(s0)
    if (n <= 0) {
    8001de58:	fcc42783          	lw	a5,-52(s0)
    8001de5c:	2781                	sext.w	a5,a5
    8001de5e:	00f04463          	bgtz	a5,8001de66 <page_nalloc+0x1c>
        return NULL;
    8001de62:	4781                	li	a5,0
    8001de64:	aa21                	j	8001df7c <page_nalloc+0x132>
    }

    mutex_spinlock(&page_lock);
    8001de66:	00007517          	auipc	a0,0x7
    8001de6a:	1aa50513          	addi	a0,a0,426 # 80025010 <page_lock>
    8001de6e:	fccf70ef          	jal	ra,8001563a <mutex_spinlock>

    int start = 0;
    8001de72:	fe042623          	sw	zero,-20(s0)
    int consecutive = 0;
    8001de76:	fe042423          	sw	zero,-24(s0)

    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001de7a:	fe043023          	sd	zero,-32(s0)
    8001de7e:	a8c9                	j	8001df50 <page_nalloc+0x106>
        if (!is_taken(i) && !is_last(i)) {
    8001de80:	fe043503          	ld	a0,-32(s0)
    8001de84:	bfdff0ef          	jal	ra,8001da80 <is_taken>
    8001de88:	87aa                	mv	a5,a0
    8001de8a:	efc5                	bnez	a5,8001df42 <page_nalloc+0xf8>
    8001de8c:	fe043503          	ld	a0,-32(s0)
    8001de90:	d29ff0ef          	jal	ra,8001dbb8 <is_last>
    8001de94:	87aa                	mv	a5,a0
    8001de96:	e7d5                	bnez	a5,8001df42 <page_nalloc+0xf8>
            if (consecutive == 0) {
    8001de98:	fe842783          	lw	a5,-24(s0)
    8001de9c:	2781                	sext.w	a5,a5
    8001de9e:	e789                	bnez	a5,8001dea8 <page_nalloc+0x5e>
                start = i;
    8001dea0:	fe043783          	ld	a5,-32(s0)
    8001dea4:	fef42623          	sw	a5,-20(s0)
            }

            consecutive++;
    8001dea8:	fe842783          	lw	a5,-24(s0)
    8001deac:	2785                	addiw	a5,a5,1
    8001deae:	fef42423          	sw	a5,-24(s0)

            if (consecutive >= n) {
    8001deb2:	fe842703          	lw	a4,-24(s0)
    8001deb6:	fcc42783          	lw	a5,-52(s0)
    8001deba:	2701                	sext.w	a4,a4
    8001debc:	2781                	sext.w	a5,a5
    8001debe:	08f74463          	blt	a4,a5,8001df46 <page_nalloc+0xfc>
                // debugf("page_nalloc: found %d consecutive pages starting at 0x%08lx\n", n, start);
                for (int j = 0; j < n; j++) {
    8001dec2:	fc042e23          	sw	zero,-36(s0)
    8001dec6:	a091                	j	8001df0a <page_nalloc+0xc0>
                    // debugf("page_nalloc: marking page 0x%08lx as taken\n", start + j);
                    set_taken(start + j);
    8001dec8:	fec42703          	lw	a4,-20(s0)
    8001decc:	fdc42783          	lw	a5,-36(s0)
    8001ded0:	9fb9                	addw	a5,a5,a4
    8001ded2:	2781                	sext.w	a5,a5
    8001ded4:	853e                	mv	a0,a5
    8001ded6:	ac3ff0ef          	jal	ra,8001d998 <set_taken>
                    if (j == n - 1) {
    8001deda:	fcc42783          	lw	a5,-52(s0)
    8001dede:	37fd                	addiw	a5,a5,-1
    8001dee0:	0007871b          	sext.w	a4,a5
    8001dee4:	fdc42783          	lw	a5,-36(s0)
    8001dee8:	2781                	sext.w	a5,a5
    8001deea:	00e79b63          	bne	a5,a4,8001df00 <page_nalloc+0xb6>
                        set_last(start + j);
    8001deee:	fec42703          	lw	a4,-20(s0)
    8001def2:	fdc42783          	lw	a5,-36(s0)
    8001def6:	9fb9                	addw	a5,a5,a4
    8001def8:	2781                	sext.w	a5,a5
    8001defa:	853e                	mv	a0,a5
    8001defc:	bcdff0ef          	jal	ra,8001dac8 <set_last>
                for (int j = 0; j < n; j++) {
    8001df00:	fdc42783          	lw	a5,-36(s0)
    8001df04:	2785                	addiw	a5,a5,1
    8001df06:	fcf42e23          	sw	a5,-36(s0)
    8001df0a:	fdc42703          	lw	a4,-36(s0)
    8001df0e:	fcc42783          	lw	a5,-52(s0)
    8001df12:	2701                	sext.w	a4,a4
    8001df14:	2781                	sext.w	a5,a5
    8001df16:	faf749e3          	blt	a4,a5,8001dec8 <page_nalloc+0x7e>
                    }
                }
                // debugf("page_nalloc: marking page 0x%08lx as last\n", start + n - 1);

                mutex_unlock(&page_lock);
    8001df1a:	00007517          	auipc	a0,0x7
    8001df1e:	0f650513          	addi	a0,a0,246 # 80025010 <page_lock>
    8001df22:	f46f70ef          	jal	ra,80015668 <mutex_unlock>
                // debugf("Found free %d pages at #%d, %d\n", n, start, i);
                void *result = (void*)((uint64_t)bookkeeping + ((uint64_t)start * PAGE_SIZE));
    8001df26:	fec42783          	lw	a5,-20(s0)
    8001df2a:	07b2                	slli	a5,a5,0xc
    8001df2c:	00007717          	auipc	a4,0x7
    8001df30:	22c70713          	addi	a4,a4,556 # 80025158 <bookkeeping>
    8001df34:	6318                	ld	a4,0(a4)
    8001df36:	97ba                	add	a5,a5,a4
    8001df38:	fcf43823          	sd	a5,-48(s0)

                debugf("Found %d free pages at %p\n", n, result);
                return result;
    8001df3c:	fd043783          	ld	a5,-48(s0)
    8001df40:	a835                	j	8001df7c <page_nalloc+0x132>
            }
        } else {
            // debugf("page_nalloc: page 0x%08lx is taken\n", i);
            consecutive = 0;
    8001df42:	fe042423          	sw	zero,-24(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001df46:	fe043783          	ld	a5,-32(s0)
    8001df4a:	0785                	addi	a5,a5,1
    8001df4c:	fef43023          	sd	a5,-32(s0)
    8001df50:	07ff2717          	auipc	a4,0x7ff2
    8001df54:	0b070713          	addi	a4,a4,176 # 88010000 <_heap_end>
    8001df58:	00015797          	auipc	a5,0x15
    8001df5c:	0a878793          	addi	a5,a5,168 # 80033000 <_heap_start>
    8001df60:	40f707b3          	sub	a5,a4,a5
    8001df64:	83b1                	srli	a5,a5,0xc
    8001df66:	fe043703          	ld	a4,-32(s0)
    8001df6a:	f0f76be3          	bltu	a4,a5,8001de80 <page_nalloc+0x36>
        }
    }

    mutex_unlock(&page_lock);
    8001df6e:	00007517          	auipc	a0,0x7
    8001df72:	0a250513          	addi	a0,a0,162 # 80025010 <page_lock>
    8001df76:	ef2f70ef          	jal	ra,80015668 <mutex_unlock>
    return NULL;
    8001df7a:	4781                	li	a5,0
}
    8001df7c:	853e                	mv	a0,a5
    8001df7e:	70e2                	ld	ra,56(sp)
    8001df80:	7442                	ld	s0,48(sp)
    8001df82:	6121                	addi	sp,sp,64
    8001df84:	8082                	ret

000000008001df86 <page_znalloc>:

void *page_znalloc(int n)
{
    8001df86:	7179                	addi	sp,sp,-48
    8001df88:	f406                	sd	ra,40(sp)
    8001df8a:	f022                	sd	s0,32(sp)
    8001df8c:	1800                	addi	s0,sp,48
    8001df8e:	87aa                	mv	a5,a0
    8001df90:	fcf42e23          	sw	a5,-36(s0)
    if (n <= 0) {
    8001df94:	fdc42783          	lw	a5,-36(s0)
    8001df98:	2781                	sext.w	a5,a5
    8001df9a:	00f04463          	bgtz	a5,8001dfa2 <page_znalloc+0x1c>
        return NULL;
    8001df9e:	4781                	li	a5,0
    8001dfa0:	a805                	j	8001dfd0 <page_znalloc+0x4a>
    }
    
    void *mem = page_nalloc(n);
    8001dfa2:	fdc42783          	lw	a5,-36(s0)
    8001dfa6:	853e                	mv	a0,a5
    8001dfa8:	ea3ff0ef          	jal	ra,8001de4a <page_nalloc>
    8001dfac:	fea43423          	sd	a0,-24(s0)
    if (mem) {
    8001dfb0:	fe843783          	ld	a5,-24(s0)
    8001dfb4:	cf81                	beqz	a5,8001dfcc <page_znalloc+0x46>
        // debugf("page_znalloc: zeroing out %d pages starting at 0x%08lx\n", n, mem);
        memset(mem, 0, n * PAGE_SIZE);
    8001dfb6:	fdc42783          	lw	a5,-36(s0)
    8001dfba:	00c7979b          	slliw	a5,a5,0xc
    8001dfbe:	2781                	sext.w	a5,a5
    8001dfc0:	863e                	mv	a2,a5
    8001dfc2:	4581                	li	a1,0
    8001dfc4:	fe843503          	ld	a0,-24(s0)
    8001dfc8:	274040ef          	jal	ra,8002223c <memset>
    }
    return mem;
    8001dfcc:	fe843783          	ld	a5,-24(s0)
}
    8001dfd0:	853e                	mv	a0,a5
    8001dfd2:	70a2                	ld	ra,40(sp)
    8001dfd4:	7402                	ld	s0,32(sp)
    8001dfd6:	6145                	addi	sp,sp,48
    8001dfd8:	8082                	ret

000000008001dfda <page_to_index>:

uint64_t page_to_index(void *page) {
    8001dfda:	1101                	addi	sp,sp,-32
    8001dfdc:	ec22                	sd	s0,24(sp)
    8001dfde:	1000                	addi	s0,sp,32
    8001dfe0:	fea43423          	sd	a0,-24(s0)
    return ((uint64_t)page - (uint64_t)bookkeeping) / PAGE_SIZE;
    8001dfe4:	fe843783          	ld	a5,-24(s0)
    8001dfe8:	00007717          	auipc	a4,0x7
    8001dfec:	17070713          	addi	a4,a4,368 # 80025158 <bookkeeping>
    8001dff0:	6318                	ld	a4,0(a4)
    8001dff2:	8f99                	sub	a5,a5,a4
    8001dff4:	83b1                	srli	a5,a5,0xc
}
    8001dff6:	853e                	mv	a0,a5
    8001dff8:	6462                	ld	s0,24(sp)
    8001dffa:	6105                	addi	sp,sp,32
    8001dffc:	8082                	ret

000000008001dffe <index_to_page>:

void *index_to_page(uint64_t idx) {
    8001dffe:	1101                	addi	sp,sp,-32
    8001e000:	ec22                	sd	s0,24(sp)
    8001e002:	1000                	addi	s0,sp,32
    8001e004:	fea43423          	sd	a0,-24(s0)
    return (void*)(idx * PAGE_SIZE + (uint64_t)bookkeeping);
    8001e008:	fe843783          	ld	a5,-24(s0)
    8001e00c:	07b2                	slli	a5,a5,0xc
    8001e00e:	00007717          	auipc	a4,0x7
    8001e012:	14a70713          	addi	a4,a4,330 # 80025158 <bookkeeping>
    8001e016:	6318                	ld	a4,0(a4)
    8001e018:	97ba                	add	a5,a5,a4
}
    8001e01a:	853e                	mv	a0,a5
    8001e01c:	6462                	ld	s0,24(sp)
    8001e01e:	6105                	addi	sp,sp,32
    8001e020:	8082                	ret

000000008001e022 <page_free>:

void page_free(void *p)
{
    8001e022:	7179                	addi	sp,sp,-48
    8001e024:	f406                	sd	ra,40(sp)
    8001e026:	f022                	sd	s0,32(sp)
    8001e028:	1800                	addi	s0,sp,48
    8001e02a:	fca43c23          	sd	a0,-40(s0)
    if (p == NULL) {
    8001e02e:	fd843783          	ld	a5,-40(s0)
    8001e032:	cfb5                	beqz	a5,8001e0ae <page_free+0x8c>
        return;
    }
    /* Free the page */
    // uint64_t x = ((uint64_t)p - (uint64_t)bookkeeping) / PAGE_SIZE;
    uint64_t x = page_to_index(p);
    8001e034:	fd843503          	ld	a0,-40(s0)
    8001e038:	fa3ff0ef          	jal	ra,8001dfda <page_to_index>
    8001e03c:	fea43423          	sd	a0,-24(s0)
    // debugf("page_free: freeing page %lu at address 0x%p\n", x, p);

    mutex_spinlock(&page_lock);
    8001e040:	00007517          	auipc	a0,0x7
    8001e044:	fd050513          	addi	a0,a0,-48 # 80025010 <page_lock>
    8001e048:	df2f70ef          	jal	ra,8001563a <mutex_spinlock>


    if (!is_taken(x)) {
    8001e04c:	fe843503          	ld	a0,-24(s0)
    8001e050:	a31ff0ef          	jal	ra,8001da80 <is_taken>
    8001e054:	87aa                	mv	a5,a0
    8001e056:	e38d                	bnez	a5,8001e078 <page_free+0x56>
        // logf(LOG_ERROR, "page_free: page 0x%08lx is already free!\n", x);
        mutex_unlock(&page_lock);
    8001e058:	00007517          	auipc	a0,0x7
    8001e05c:	fb850513          	addi	a0,a0,-72 # 80025010 <page_lock>
    8001e060:	e08f70ef          	jal	ra,80015668 <mutex_unlock>
        return;
    8001e064:	a0b1                	j	8001e0b0 <page_free+0x8e>
    }

    // Clear all the pages starting at the index until the last page
    while (is_taken(x) && !is_last(x)) {
        clear_taken(x);
    8001e066:	fe843503          	ld	a0,-24(s0)
    8001e06a:	99dff0ef          	jal	ra,8001da06 <clear_taken>
        x++;
    8001e06e:	fe843783          	ld	a5,-24(s0)
    8001e072:	0785                	addi	a5,a5,1
    8001e074:	fef43423          	sd	a5,-24(s0)
    while (is_taken(x) && !is_last(x)) {
    8001e078:	fe843503          	ld	a0,-24(s0)
    8001e07c:	a05ff0ef          	jal	ra,8001da80 <is_taken>
    8001e080:	87aa                	mv	a5,a0
    8001e082:	c799                	beqz	a5,8001e090 <page_free+0x6e>
    8001e084:	fe843503          	ld	a0,-24(s0)
    8001e088:	b31ff0ef          	jal	ra,8001dbb8 <is_last>
    8001e08c:	87aa                	mv	a5,a0
    8001e08e:	dfe1                	beqz	a5,8001e066 <page_free+0x44>
    }
    clear_taken(x);
    8001e090:	fe843503          	ld	a0,-24(s0)
    8001e094:	973ff0ef          	jal	ra,8001da06 <clear_taken>
    clear_last(x);
    8001e098:	fe843503          	ld	a0,-24(s0)
    8001e09c:	a9fff0ef          	jal	ra,8001db3a <clear_last>


    mutex_unlock(&page_lock);
    8001e0a0:	00007517          	auipc	a0,0x7
    8001e0a4:	f7050513          	addi	a0,a0,-144 # 80025010 <page_lock>
    8001e0a8:	dc0f70ef          	jal	ra,80015668 <mutex_unlock>
    8001e0ac:	a011                	j	8001e0b0 <page_free+0x8e>
        return;
    8001e0ae:	0001                	nop
}
    8001e0b0:	70a2                	ld	ra,40(sp)
    8001e0b2:	7402                	ld	s0,32(sp)
    8001e0b4:	6145                	addi	sp,sp,48
    8001e0b6:	8082                	ret

000000008001e0b8 <page_count_free>:

int page_count_free(void)
{
    8001e0b8:	1101                	addi	sp,sp,-32
    8001e0ba:	ec06                	sd	ra,24(sp)
    8001e0bc:	e822                	sd	s0,16(sp)
    8001e0be:	1000                	addi	s0,sp,32
    int ret = 0;
    8001e0c0:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract taken. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract taken pages from it.
    */

    mutex_spinlock(&page_lock);
    8001e0c4:	00007517          	auipc	a0,0x7
    8001e0c8:	f4c50513          	addi	a0,a0,-180 # 80025010 <page_lock>
    8001e0cc:	d6ef70ef          	jal	ra,8001563a <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001e0d0:	fe043023          	sd	zero,-32(s0)
    8001e0d4:	a00d                	j	8001e0f6 <page_count_free+0x3e>
       if (!is_taken(i)) {
    8001e0d6:	fe043503          	ld	a0,-32(s0)
    8001e0da:	9a7ff0ef          	jal	ra,8001da80 <is_taken>
    8001e0de:	87aa                	mv	a5,a0
    8001e0e0:	e791                	bnez	a5,8001e0ec <page_count_free+0x34>
           ret++;
    8001e0e2:	fec42783          	lw	a5,-20(s0)
    8001e0e6:	2785                	addiw	a5,a5,1
    8001e0e8:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001e0ec:	fe043783          	ld	a5,-32(s0)
    8001e0f0:	0785                	addi	a5,a5,1
    8001e0f2:	fef43023          	sd	a5,-32(s0)
    8001e0f6:	07ff2717          	auipc	a4,0x7ff2
    8001e0fa:	f0a70713          	addi	a4,a4,-246 # 88010000 <_heap_end>
    8001e0fe:	00015797          	auipc	a5,0x15
    8001e102:	f0278793          	addi	a5,a5,-254 # 80033000 <_heap_start>
    8001e106:	40f707b3          	sub	a5,a4,a5
    8001e10a:	83b1                	srli	a5,a5,0xc
    8001e10c:	fe043703          	ld	a4,-32(s0)
    8001e110:	fcf763e3          	bltu	a4,a5,8001e0d6 <page_count_free+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    8001e114:	00007517          	auipc	a0,0x7
    8001e118:	efc50513          	addi	a0,a0,-260 # 80025010 <page_lock>
    8001e11c:	d4cf70ef          	jal	ra,80015668 <mutex_unlock>

    return ret;
    8001e120:	fec42783          	lw	a5,-20(s0)
}
    8001e124:	853e                	mv	a0,a5
    8001e126:	60e2                	ld	ra,24(sp)
    8001e128:	6442                	ld	s0,16(sp)
    8001e12a:	6105                	addi	sp,sp,32
    8001e12c:	8082                	ret

000000008001e12e <page_count_taken>:

int page_count_taken(void)
{
    8001e12e:	1101                	addi	sp,sp,-32
    8001e130:	ec06                	sd	ra,24(sp)
    8001e132:	e822                	sd	s0,16(sp)
    8001e134:	1000                	addi	s0,sp,32
    int ret = 0;
    8001e136:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract free. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract free pages from it.
    */

    mutex_spinlock(&page_lock);
    8001e13a:	00007517          	auipc	a0,0x7
    8001e13e:	ed650513          	addi	a0,a0,-298 # 80025010 <page_lock>
    8001e142:	cf8f70ef          	jal	ra,8001563a <mutex_spinlock>
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001e146:	fe043023          	sd	zero,-32(s0)
    8001e14a:	a00d                	j	8001e16c <page_count_taken+0x3e>
       if (is_taken(i)) {
    8001e14c:	fe043503          	ld	a0,-32(s0)
    8001e150:	931ff0ef          	jal	ra,8001da80 <is_taken>
    8001e154:	87aa                	mv	a5,a0
    8001e156:	c791                	beqz	a5,8001e162 <page_count_taken+0x34>
           ret++;
    8001e158:	fec42783          	lw	a5,-20(s0)
    8001e15c:	2785                	addiw	a5,a5,1
    8001e15e:	fef42623          	sw	a5,-20(s0)
    for (uint64_t i = 0; i < HEAP_SIZE_IN_PAGES; i++) {
    8001e162:	fe043783          	ld	a5,-32(s0)
    8001e166:	0785                	addi	a5,a5,1
    8001e168:	fef43023          	sd	a5,-32(s0)
    8001e16c:	07ff2717          	auipc	a4,0x7ff2
    8001e170:	e9470713          	addi	a4,a4,-364 # 88010000 <_heap_end>
    8001e174:	00015797          	auipc	a5,0x15
    8001e178:	e8c78793          	addi	a5,a5,-372 # 80033000 <_heap_start>
    8001e17c:	40f707b3          	sub	a5,a4,a5
    8001e180:	83b1                	srli	a5,a5,0xc
    8001e182:	fe043703          	ld	a4,-32(s0)
    8001e186:	fcf763e3          	bltu	a4,a5,8001e14c <page_count_taken+0x1e>
       }
    }
    mutex_unlock(&page_lock);
    8001e18a:	00007517          	auipc	a0,0x7
    8001e18e:	e8650513          	addi	a0,a0,-378 # 80025010 <page_lock>
    8001e192:	cd6f70ef          	jal	ra,80015668 <mutex_unlock>

    return ret;
    8001e196:	fec42783          	lw	a5,-20(s0)
}
    8001e19a:	853e                	mv	a0,a5
    8001e19c:	60e2                	ld	ra,24(sp)
    8001e19e:	6442                	ld	s0,16(sp)
    8001e1a0:	6105                	addi	sp,sp,32
    8001e1a2:	8082                	ret

000000008001e1a4 <input_device_init>:
static InputDevice keyboard_dev;
static InputDevice tablet_dev;
// static Ring *input_events;  //TODO: use the ring to buffer input events and also limit the number of events
// const int event_limit = 1000;   //limits number of events so we don't run out of memory

void input_device_init(VirtioDevice *device) {
    8001e1a4:	715d                	addi	sp,sp,-80
    8001e1a6:	e486                	sd	ra,72(sp)
    8001e1a8:	e0a2                	sd	s0,64(sp)
    8001e1aa:	0880                	addi	s0,sp,80
    8001e1ac:	faa43c23          	sd	a0,-72(s0)
    IRQ_OFF();
    8001e1b0:	100027f3          	csrr	a5,sstatus
    8001e1b4:	fef43023          	sd	a5,-32(s0)
    8001e1b8:	fe043783          	ld	a5,-32(s0)
    8001e1bc:	9bf5                	andi	a5,a5,-3
    8001e1be:	10079073          	csrw	sstatus,a5
    device_active_jobs = vector_new();
    8001e1c2:	2cd040ef          	jal	ra,80022c8e <vector_new>
    8001e1c6:	872a                	mv	a4,a0
    8001e1c8:	00007797          	auipc	a5,0x7
    8001e1cc:	f9878793          	addi	a5,a5,-104 # 80025160 <device_active_jobs>
    8001e1d0:	e398                	sd	a4,0(a5)
    volatile VirtioInputConfig *config = virtio_get_input_config(device);
    8001e1d2:	fb843503          	ld	a0,-72(s0)
    8001e1d6:	8f1fe0ef          	jal	ra,8001cac6 <virtio_get_input_config>
    8001e1da:	fca43c23          	sd	a0,-40(s0)

    uint16_t prod_id = input_device_get_prod_id(config);
    8001e1de:	fd843503          	ld	a0,-40(s0)
    8001e1e2:	248000ef          	jal	ra,8001e42a <input_device_get_prod_id>
    8001e1e6:	87aa                	mv	a5,a0
    8001e1e8:	fcf41b23          	sh	a5,-42(s0)
    InputDevice *input_dev;
    switch (prod_id) {
    8001e1ec:	fd645783          	lhu	a5,-42(s0)
    8001e1f0:	0007871b          	sext.w	a4,a5
    8001e1f4:	86ba                	mv	a3,a4
    8001e1f6:	4785                	li	a5,1
    8001e1f8:	00f68663          	beq	a3,a5,8001e204 <input_device_init+0x60>
    8001e1fc:	478d                	li	a5,3
    8001e1fe:	06f70363          	beq	a4,a5,8001e264 <input_device_init+0xc0>
    8001e202:	a0c9                	j	8001e2c4 <input_device_init+0x120>
    case EV_KEY:
        virtio_set_device_name(device, "Keyboard");
    8001e204:	0000b597          	auipc	a1,0xb
    8001e208:	97458593          	addi	a1,a1,-1676 # 80028b78 <pow10.0+0x1d18>
    8001e20c:	fb843503          	ld	a0,-72(s0)
    8001e210:	8bcff0ef          	jal	ra,8001d2cc <virtio_set_device_name>
        device->ready = true;
    8001e214:	fb843783          	ld	a5,-72(s0)
    8001e218:	4705                	li	a4,1
    8001e21a:	08e78723          	sb	a4,142(a5)
        device->is_keyboard = 1;
    8001e21e:	fb843783          	ld	a5,-72(s0)
    8001e222:	0947c703          	lbu	a4,148(a5)
    8001e226:	00176713          	ori	a4,a4,1
    8001e22a:	08e78a23          	sb	a4,148(a5)
        device->is_tablet = 0;
    8001e22e:	fb843783          	ld	a5,-72(s0)
    8001e232:	0947c703          	lbu	a4,148(a5)
    8001e236:	9b75                	andi	a4,a4,-3
    8001e238:	08e78a23          	sb	a4,148(a5)
        keyboard_dev.viodev = device;
    8001e23c:	00007797          	auipc	a5,0x7
    8001e240:	f2c78793          	addi	a5,a5,-212 # 80025168 <keyboard_dev>
    8001e244:	fb843703          	ld	a4,-72(s0)
    8001e248:	e798                	sd	a4,8(a5)
        input_dev = &keyboard_dev;
    8001e24a:	00007797          	auipc	a5,0x7
    8001e24e:	f1e78793          	addi	a5,a5,-226 # 80025168 <keyboard_dev>
    8001e252:	fef43423          	sd	a5,-24(s0)
        debugf("input_device_init: Input device initialized as keyboard\n");
    8001e256:	0000b517          	auipc	a0,0xb
    8001e25a:	93250513          	addi	a0,a0,-1742 # 80028b88 <pow10.0+0x1d28>
    8001e25e:	b85fd0ef          	jal	ra,8001bde2 <debugf>
        break;
    8001e262:	a8a5                	j	8001e2da <input_device_init+0x136>
    case EV_ABS:
        virtio_set_device_name(device, "Tablet");
    8001e264:	0000b597          	auipc	a1,0xb
    8001e268:	96458593          	addi	a1,a1,-1692 # 80028bc8 <pow10.0+0x1d68>
    8001e26c:	fb843503          	ld	a0,-72(s0)
    8001e270:	85cff0ef          	jal	ra,8001d2cc <virtio_set_device_name>
        device->ready = true;
    8001e274:	fb843783          	ld	a5,-72(s0)
    8001e278:	4705                	li	a4,1
    8001e27a:	08e78723          	sb	a4,142(a5)
        device->is_keyboard = 1;
    8001e27e:	fb843783          	ld	a5,-72(s0)
    8001e282:	0947c703          	lbu	a4,148(a5)
    8001e286:	00176713          	ori	a4,a4,1
    8001e28a:	08e78a23          	sb	a4,148(a5)
        device->is_tablet = 0;
    8001e28e:	fb843783          	ld	a5,-72(s0)
    8001e292:	0947c703          	lbu	a4,148(a5)
    8001e296:	9b75                	andi	a4,a4,-3
    8001e298:	08e78a23          	sb	a4,148(a5)
        tablet_dev.viodev = device;
    8001e29c:	00007797          	auipc	a5,0x7
    8001e2a0:	0ec78793          	addi	a5,a5,236 # 80025388 <tablet_dev>
    8001e2a4:	fb843703          	ld	a4,-72(s0)
    8001e2a8:	e798                	sd	a4,8(a5)
        input_dev = &tablet_dev;
    8001e2aa:	00007797          	auipc	a5,0x7
    8001e2ae:	0de78793          	addi	a5,a5,222 # 80025388 <tablet_dev>
    8001e2b2:	fef43423          	sd	a5,-24(s0)
        debugf("input_device_init: Input device initialized as tablet\n");
    8001e2b6:	0000b517          	auipc	a0,0xb
    8001e2ba:	91a50513          	addi	a0,a0,-1766 # 80028bd0 <pow10.0+0x1d70>
    8001e2be:	b25fd0ef          	jal	ra,8001bde2 <debugf>
        break;
    8001e2c2:	a821                	j	8001e2da <input_device_init+0x136>
    default:
        fatalf("input_device_init: Unsupported device\n", prod_id);
    8001e2c4:	fd645783          	lhu	a5,-42(s0)
    8001e2c8:	2781                	sext.w	a5,a5
    8001e2ca:	85be                	mv	a1,a5
    8001e2cc:	0000b517          	auipc	a0,0xb
    8001e2d0:	93c50513          	addi	a0,a0,-1732 # 80028c08 <pow10.0+0x1da8>
    8001e2d4:	c69fd0ef          	jal	ra,8001bf3c <fatalf>
        break;
    8001e2d8:	0001                	nop
    }

    IRQ_ON();
    8001e2da:	100027f3          	csrr	a5,sstatus
    8001e2de:	fcf43423          	sd	a5,-56(s0)
    8001e2e2:	fc843783          	ld	a5,-56(s0)
    8001e2e6:	0027e793          	ori	a5,a5,2
    8001e2ea:	10079073          	csrw	sstatus,a5
    input_device_receive_buffer_init(input_dev);
    8001e2ee:	fe843503          	ld	a0,-24(s0)
    8001e2f2:	024000ef          	jal	ra,8001e316 <input_device_receive_buffer_init>
    debugf("Input device init done for device at %p\n", device->pcidev->ecam_header);
    8001e2f6:	fb843783          	ld	a5,-72(s0)
    8001e2fa:	63bc                	ld	a5,64(a5)
    8001e2fc:	639c                	ld	a5,0(a5)
    8001e2fe:	85be                	mv	a1,a5
    8001e300:	0000b517          	auipc	a0,0xb
    8001e304:	93050513          	addi	a0,a0,-1744 # 80028c30 <pow10.0+0x1dd0>
    8001e308:	adbfd0ef          	jal	ra,8001bde2 <debugf>
}
    8001e30c:	0001                	nop
    8001e30e:	60a6                	ld	ra,72(sp)
    8001e310:	6406                	ld	s0,64(sp)
    8001e312:	6161                	addi	sp,sp,80
    8001e314:	8082                	ret

000000008001e316 <input_device_receive_buffer_init>:
//     debugf("[Input] Input not found!");
//     return NULL;
// }

// At device init, populate the driver ring with receive buffers so we can receive events
void input_device_receive_buffer_init(InputDevice *input_dev) {
    8001e316:	7139                	addi	sp,sp,-64
    8001e318:	fc06                	sd	ra,56(sp)
    8001e31a:	f822                	sd	s0,48(sp)
    8001e31c:	0080                	addi	s0,sp,64
    8001e31e:	fca43423          	sd	a0,-56(s0)
    for (int i = 0; i < INPUT_EVENT_BUFFER_SIZE; i++) {
    8001e322:	fe042623          	sw	zero,-20(s0)
    8001e326:	a0b9                	j	8001e374 <input_device_receive_buffer_init+0x5e>
        VirtioDescriptor recv_buf_desc;
        recv_buf_desc.addr = kernel_mmu_translate((uintptr_t)&input_dev->event_buffer[i]);
    8001e328:	fec42783          	lw	a5,-20(s0)
    8001e32c:	0789                	addi	a5,a5,2
    8001e32e:	078e                	slli	a5,a5,0x3
    8001e330:	fc843703          	ld	a4,-56(s0)
    8001e334:	97ba                	add	a5,a5,a4
    8001e336:	853e                	mv	a0,a5
    8001e338:	f4cf70ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001e33c:	87aa                	mv	a5,a0
    8001e33e:	fcf43c23          	sd	a5,-40(s0)
        recv_buf_desc.flags = VIRTQ_DESC_F_WRITE;
    8001e342:	4789                	li	a5,2
    8001e344:	fef41223          	sh	a5,-28(s0)
        recv_buf_desc.len = sizeof(VirtioInputEvent);
    8001e348:	47a1                	li	a5,8
    8001e34a:	fef42023          	sw	a5,-32(s0)
        recv_buf_desc.next = 0;
    8001e34e:	fe041323          	sh	zero,-26(s0)
        virtio_send_one_descriptor(input_dev->viodev, 0, recv_buf_desc, true);
    8001e352:	fc843783          	ld	a5,-56(s0)
    8001e356:	679c                	ld	a5,8(a5)
    8001e358:	4705                	li	a4,1
    8001e35a:	fd843603          	ld	a2,-40(s0)
    8001e35e:	fe043683          	ld	a3,-32(s0)
    8001e362:	4581                	li	a1,0
    8001e364:	853e                	mv	a0,a5
    8001e366:	94cff0ef          	jal	ra,8001d4b2 <virtio_send_one_descriptor>
    for (int i = 0; i < INPUT_EVENT_BUFFER_SIZE; i++) {
    8001e36a:	fec42783          	lw	a5,-20(s0)
    8001e36e:	2785                	addiw	a5,a5,1
    8001e370:	fef42623          	sw	a5,-20(s0)
    8001e374:	fec42783          	lw	a5,-20(s0)
    8001e378:	0007871b          	sext.w	a4,a5
    8001e37c:	03f00793          	li	a5,63
    8001e380:	fae7d4e3          	bge	a5,a4,8001e328 <input_device_receive_buffer_init+0x12>
    }
}
    8001e384:	0001                	nop
    8001e386:	0001                	nop
    8001e388:	70e2                	ld	ra,56(sp)
    8001e38a:	7442                	ld	s0,48(sp)
    8001e38c:	6121                	addi	sp,sp,64
    8001e38e:	8082                	ret

000000008001e390 <get_input_device_config>:

void get_input_device_config(VirtioDevice *device, uint8_t select, uint8_t subsel, uint8_t size) {
    8001e390:	7179                	addi	sp,sp,-48
    8001e392:	f406                	sd	ra,40(sp)
    8001e394:	f022                	sd	s0,32(sp)
    8001e396:	1800                	addi	s0,sp,48
    8001e398:	fca43c23          	sd	a0,-40(s0)
    8001e39c:	87ae                	mv	a5,a1
    8001e39e:	8736                	mv	a4,a3
    8001e3a0:	fcf40ba3          	sb	a5,-41(s0)
    8001e3a4:	87b2                	mv	a5,a2
    8001e3a6:	fcf40b23          	sb	a5,-42(s0)
    8001e3aa:	87ba                	mv	a5,a4
    8001e3ac:	fcf40aa3          	sb	a5,-43(s0)
    volatile VirtioInputConfig *config = virtio_get_input_config(device);
    8001e3b0:	fd843503          	ld	a0,-40(s0)
    8001e3b4:	f12fe0ef          	jal	ra,8001cac6 <virtio_get_input_config>
    8001e3b8:	fea43423          	sd	a0,-24(s0)
    config->select = select;
    8001e3bc:	fe843783          	ld	a5,-24(s0)
    8001e3c0:	fd744703          	lbu	a4,-41(s0)
    8001e3c4:	00e78023          	sb	a4,0(a5)
    debugf("set_input_device_config: select = 0x%x\n", config->select);
    8001e3c8:	fe843783          	ld	a5,-24(s0)
    8001e3cc:	0007c783          	lbu	a5,0(a5)
    8001e3d0:	0ff7f793          	andi	a5,a5,255
    8001e3d4:	2781                	sext.w	a5,a5
    8001e3d6:	85be                	mv	a1,a5
    8001e3d8:	0000b517          	auipc	a0,0xb
    8001e3dc:	88850513          	addi	a0,a0,-1912 # 80028c60 <pow10.0+0x1e00>
    8001e3e0:	a03fd0ef          	jal	ra,8001bde2 <debugf>
    config->subsel = subsel;
    8001e3e4:	fe843783          	ld	a5,-24(s0)
    8001e3e8:	fd644703          	lbu	a4,-42(s0)
    8001e3ec:	00e780a3          	sb	a4,1(a5)
    debugf("set_input_device_config: subsel = 0x%x\n", config->subsel);
    8001e3f0:	fe843783          	ld	a5,-24(s0)
    8001e3f4:	0017c783          	lbu	a5,1(a5)
    8001e3f8:	0ff7f793          	andi	a5,a5,255
    8001e3fc:	2781                	sext.w	a5,a5
    8001e3fe:	85be                	mv	a1,a5
    8001e400:	0000b517          	auipc	a0,0xb
    8001e404:	88850513          	addi	a0,a0,-1912 # 80028c88 <pow10.0+0x1e28>
    8001e408:	9dbfd0ef          	jal	ra,8001bde2 <debugf>
    debugf("%.128s\n", config->string);
    8001e40c:	fe843783          	ld	a5,-24(s0)
    8001e410:	07a1                	addi	a5,a5,8
    8001e412:	85be                	mv	a1,a5
    8001e414:	0000b517          	auipc	a0,0xb
    8001e418:	89c50513          	addi	a0,a0,-1892 # 80028cb0 <pow10.0+0x1e50>
    8001e41c:	9c7fd0ef          	jal	ra,8001bde2 <debugf>
}
    8001e420:	0001                	nop
    8001e422:	70a2                	ld	ra,40(sp)
    8001e424:	7402                	ld	s0,32(sp)
    8001e426:	6145                	addi	sp,sp,48
    8001e428:	8082                	ret

000000008001e42a <input_device_get_prod_id>:

uint16_t input_device_get_prod_id(volatile VirtioInputConfig *config) {
    8001e42a:	1101                	addi	sp,sp,-32
    8001e42c:	ec22                	sd	s0,24(sp)
    8001e42e:	1000                	addi	s0,sp,32
    8001e430:	fea43423          	sd	a0,-24(s0)
    config->select = VIRTIO_INPUT_CFG_ID_DEVIDS;
    8001e434:	fe843783          	ld	a5,-24(s0)
    8001e438:	470d                	li	a4,3
    8001e43a:	00e78023          	sb	a4,0(a5)
    config->subsel = 0;
    8001e43e:	fe843783          	ld	a5,-24(s0)
    8001e442:	000780a3          	sb	zero,1(a5)
    return config->ids.product;
    8001e446:	fe843783          	ld	a5,-24(s0)
    8001e44a:	00c7d783          	lhu	a5,12(a5)
    8001e44e:	17c2                	slli	a5,a5,0x30
    8001e450:	93c1                	srli	a5,a5,0x30
}
    8001e452:	853e                	mv	a0,a5
    8001e454:	6462                	ld	s0,24(sp)
    8001e456:	6105                	addi	sp,sp,32
    8001e458:	8082                	ret

000000008001e45a <input_device_isr>:

void input_device_isr(VirtioDevice* viodev) {
    8001e45a:	715d                	addi	sp,sp,-80
    8001e45c:	e486                	sd	ra,72(sp)
    8001e45e:	e0a2                	sd	s0,64(sp)
    8001e460:	0880                	addi	s0,sp,80
    8001e462:	faa43c23          	sd	a0,-72(s0)
    debugf("input_device_isr: Starting ISR\n");
    8001e466:	0000b517          	auipc	a0,0xb
    8001e46a:	85250513          	addi	a0,a0,-1966 # 80028cb8 <pow10.0+0x1e58>
    8001e46e:	975fd0ef          	jal	ra,8001bde2 <debugf>
    
    if(!viodev->ready){
    8001e472:	fb843783          	ld	a5,-72(s0)
    8001e476:	08e7c783          	lbu	a5,142(a5)
    8001e47a:	0017c793          	xori	a5,a5,1
    8001e47e:	0ff7f793          	andi	a5,a5,255
    8001e482:	c799                	beqz	a5,8001e490 <input_device_isr+0x36>
        fatalf("input_device_isr: Device not ready!\n");
    8001e484:	0000b517          	auipc	a0,0xb
    8001e488:	85450513          	addi	a0,a0,-1964 # 80028cd8 <pow10.0+0x1e78>
    8001e48c:	ab1fd0ef          	jal	ra,8001bf3c <fatalf>
    }

    InputDevice *input_dev;
    if (viodev->is_keyboard) {
    8001e490:	fb843783          	ld	a5,-72(s0)
    8001e494:	0947c783          	lbu	a5,148(a5)
    8001e498:	8b85                	andi	a5,a5,1
    8001e49a:	0ff7f793          	andi	a5,a5,255
    8001e49e:	cb81                	beqz	a5,8001e4ae <input_device_isr+0x54>
        input_dev = &keyboard_dev;
    8001e4a0:	00007797          	auipc	a5,0x7
    8001e4a4:	cc878793          	addi	a5,a5,-824 # 80025168 <keyboard_dev>
    8001e4a8:	fef43423          	sd	a5,-24(s0)
    8001e4ac:	a035                	j	8001e4d8 <input_device_isr+0x7e>
    } else if (viodev->is_tablet) {
    8001e4ae:	fb843783          	ld	a5,-72(s0)
    8001e4b2:	0947c783          	lbu	a5,148(a5)
    8001e4b6:	8b89                	andi	a5,a5,2
    8001e4b8:	0ff7f793          	andi	a5,a5,255
    8001e4bc:	cb81                	beqz	a5,8001e4cc <input_device_isr+0x72>
        input_dev = &tablet_dev;
    8001e4be:	00007797          	auipc	a5,0x7
    8001e4c2:	eca78793          	addi	a5,a5,-310 # 80025388 <tablet_dev>
    8001e4c6:	fef43423          	sd	a5,-24(s0)
    8001e4ca:	a039                	j	8001e4d8 <input_device_isr+0x7e>
    } else {
        fatalf("input_device_isr: Unsupported input device\n");
    8001e4cc:	0000b517          	auipc	a0,0xb
    8001e4d0:	83450513          	addi	a0,a0,-1996 # 80028d00 <pow10.0+0x1ea0>
    8001e4d4:	a69fd0ef          	jal	ra,8001bf3c <fatalf>
    }

    uint16_t start_device_idx = viodev->device_idx;
    8001e4d8:	fb843783          	ld	a5,-72(s0)
    8001e4dc:	08c7d783          	lhu	a5,140(a5)
    8001e4e0:	fef41223          	sh	a5,-28(s0)
    uint16_t num_received = 0;
    8001e4e4:	fe041323          	sh	zero,-26(s0)
    // Have to receive multiple descriptors
    while (viodev->device_idx != viodev->device->idx) {
    8001e4e8:	a229                	j	8001e5f2 <input_device_isr+0x198>
        // uint32_t id = viodev->device->ring[viodev->device_idx % queue_size].id;
        VirtioDescriptor received_desc;
        virtio_receive_descriptor_chain(viodev, 0, &received_desc, 1, false);
    8001e4ea:	fc040793          	addi	a5,s0,-64
    8001e4ee:	4701                	li	a4,0
    8001e4f0:	4685                	li	a3,1
    8001e4f2:	863e                	mv	a2,a5
    8001e4f4:	4581                	li	a1,0
    8001e4f6:	fb843503          	ld	a0,-72(s0)
    8001e4fa:	a1eff0ef          	jal	ra,8001d718 <virtio_receive_descriptor_chain>
        VirtioInputEvent *event_ptr = (VirtioInputEvent *)received_desc.addr;
    8001e4fe:	fc043783          	ld	a5,-64(s0)
    8001e502:	fcf43c23          	sd	a5,-40(s0)

        uint32_t len = received_desc.len;
    8001e506:	fc842783          	lw	a5,-56(s0)
    8001e50a:	fcf42a23          	sw	a5,-44(s0)
        if (len != sizeof(VirtioInputEvent)) {
    8001e50e:	fd442783          	lw	a5,-44(s0)
    8001e512:	0007871b          	sext.w	a4,a5
    8001e516:	47a1                	li	a5,8
    8001e518:	02f70663          	beq	a4,a5,8001e544 <input_device_isr+0xea>
            debugf("input_device_isr: Received invalid input event size: %d\n", len);
    8001e51c:	fd442783          	lw	a5,-44(s0)
    8001e520:	85be                	mv	a1,a5
    8001e522:	0000b517          	auipc	a0,0xb
    8001e526:	80e50513          	addi	a0,a0,-2034 # 80028d30 <pow10.0+0x1ed0>
    8001e52a:	8b9fd0ef          	jal	ra,8001bde2 <debugf>
            virtio_send_one_descriptor(viodev, 0, received_desc, true);
    8001e52e:	4705                	li	a4,1
    8001e530:	fc043603          	ld	a2,-64(s0)
    8001e534:	fc843683          	ld	a3,-56(s0)
    8001e538:	4581                	li	a1,0
    8001e53a:	fb843503          	ld	a0,-72(s0)
    8001e53e:	f75fe0ef          	jal	ra,8001d4b2 <virtio_send_one_descriptor>
    8001e542:	a845                	j	8001e5f2 <input_device_isr+0x198>
            continue;
        }

        // Copy event to local buffer
        if (input_dev->buffer_size < INPUT_EVENT_BUFFER_SIZE) {
    8001e544:	fe843783          	ld	a5,-24(s0)
    8001e548:	2187a783          	lw	a5,536(a5)
    8001e54c:	873e                	mv	a4,a5
    8001e54e:	03f00793          	li	a5,63
    8001e552:	06e7cb63          	blt	a5,a4,8001e5c8 <input_device_isr+0x16e>
            // IRQ_OFF();
            // memcpy(&input_dev->event_buffer[input_dev->tail], event_ptr, sizeof(VirtioInputEvent));
            // IRQ_ON();
            input_dev->tail = (input_dev->tail + 1) % INPUT_EVENT_BUFFER_SIZE;
    8001e556:	fe843783          	ld	a5,-24(s0)
    8001e55a:	2147a783          	lw	a5,532(a5)
    8001e55e:	2785                	addiw	a5,a5,1
    8001e560:	2781                	sext.w	a5,a5
    8001e562:	873e                	mv	a4,a5
    8001e564:	41f7579b          	sraiw	a5,a4,0x1f
    8001e568:	01a7d79b          	srliw	a5,a5,0x1a
    8001e56c:	9f3d                	addw	a4,a4,a5
    8001e56e:	03f77713          	andi	a4,a4,63
    8001e572:	40f707bb          	subw	a5,a4,a5
    8001e576:	0007871b          	sext.w	a4,a5
    8001e57a:	fe843783          	ld	a5,-24(s0)
    8001e57e:	20e7aa23          	sw	a4,532(a5)
            input_dev->buffer_size++;
    8001e582:	fe843783          	ld	a5,-24(s0)
    8001e586:	2187a783          	lw	a5,536(a5)
    8001e58a:	2785                	addiw	a5,a5,1
    8001e58c:	0007871b          	sext.w	a4,a5
    8001e590:	fe843783          	ld	a5,-24(s0)
    8001e594:	20e7ac23          	sw	a4,536(a5)
            debugf("input_device_isr: Input event received: type = 0x%x, code = 0x%x, value = 0x%x\n", event_ptr->type, event_ptr->code, event_ptr->value);
    8001e598:	fd843783          	ld	a5,-40(s0)
    8001e59c:	0007d783          	lhu	a5,0(a5)
    8001e5a0:	0007871b          	sext.w	a4,a5
    8001e5a4:	fd843783          	ld	a5,-40(s0)
    8001e5a8:	0027d783          	lhu	a5,2(a5)
    8001e5ac:	0007861b          	sext.w	a2,a5
    8001e5b0:	fd843783          	ld	a5,-40(s0)
    8001e5b4:	43dc                	lw	a5,4(a5)
    8001e5b6:	86be                	mv	a3,a5
    8001e5b8:	85ba                	mv	a1,a4
    8001e5ba:	0000a517          	auipc	a0,0xa
    8001e5be:	7b650513          	addi	a0,a0,1974 # 80028d70 <pow10.0+0x1f10>
    8001e5c2:	821fd0ef          	jal	ra,8001bde2 <debugf>
    8001e5c6:	a039                	j	8001e5d4 <input_device_isr+0x17a>
        } else {
            debugf("input_device_isr: Input event buffer full, event dropped\n");
    8001e5c8:	0000a517          	auipc	a0,0xa
    8001e5cc:	7f850513          	addi	a0,a0,2040 # 80028dc0 <pow10.0+0x1f60>
    8001e5d0:	813fd0ef          	jal	ra,8001bde2 <debugf>
        }
        virtio_send_one_descriptor(viodev, 0, received_desc, true);
    8001e5d4:	4705                	li	a4,1
    8001e5d6:	fc043603          	ld	a2,-64(s0)
    8001e5da:	fc843683          	ld	a3,-56(s0)
    8001e5de:	4581                	li	a1,0
    8001e5e0:	fb843503          	ld	a0,-72(s0)
    8001e5e4:	ecffe0ef          	jal	ra,8001d4b2 <virtio_send_one_descriptor>
        ++num_received;
    8001e5e8:	fe645783          	lhu	a5,-26(s0)
    8001e5ec:	2785                	addiw	a5,a5,1
    8001e5ee:	fef41323          	sh	a5,-26(s0)
    while (viodev->device_idx != viodev->device->idx) {
    8001e5f2:	fb843783          	ld	a5,-72(s0)
    8001e5f6:	08c7d703          	lhu	a4,140(a5)
    8001e5fa:	fb843783          	ld	a5,-72(s0)
    8001e5fe:	7bbc                	ld	a5,112(a5)
    8001e600:	0027d783          	lhu	a5,2(a5)
    8001e604:	17c2                	slli	a5,a5,0x30
    8001e606:	93c1                	srli	a5,a5,0x30
    8001e608:	2701                	sext.w	a4,a4
    8001e60a:	2781                	sext.w	a5,a5
    8001e60c:	ecf71fe3          	bne	a4,a5,8001e4ea <input_device_isr+0x90>
    }

    // Sanity check
    debugf("input_device_isr: After receiving descriptors\n");
    8001e610:	0000a517          	auipc	a0,0xa
    8001e614:	7f050513          	addi	a0,a0,2032 # 80028e00 <pow10.0+0x1fa0>
    8001e618:	fcafd0ef          	jal	ra,8001bde2 <debugf>
    debugf("  num_received = %d\n", num_received);
    8001e61c:	fe645783          	lhu	a5,-26(s0)
    8001e620:	2781                	sext.w	a5,a5
    8001e622:	85be                	mv	a1,a5
    8001e624:	0000b517          	auipc	a0,0xb
    8001e628:	80c50513          	addi	a0,a0,-2036 # 80028e30 <pow10.0+0x1fd0>
    8001e62c:	fb6fd0ef          	jal	ra,8001bde2 <debugf>
    debugf("  Starting device_idx = %d\n", start_device_idx);
    8001e630:	fe445783          	lhu	a5,-28(s0)
    8001e634:	2781                	sext.w	a5,a5
    8001e636:	85be                	mv	a1,a5
    8001e638:	0000b517          	auipc	a0,0xb
    8001e63c:	81050513          	addi	a0,a0,-2032 # 80028e48 <pow10.0+0x1fe8>
    8001e640:	fa2fd0ef          	jal	ra,8001bde2 <debugf>
    debugf("  Ending device_idx = %d\n", viodev->device_idx);
    8001e644:	fb843783          	ld	a5,-72(s0)
    8001e648:	08c7d783          	lhu	a5,140(a5)
    8001e64c:	2781                	sext.w	a5,a5
    8001e64e:	85be                	mv	a1,a5
    8001e650:	0000b517          	auipc	a0,0xb
    8001e654:	81850513          	addi	a0,a0,-2024 # 80028e68 <pow10.0+0x2008>
    8001e658:	f8afd0ef          	jal	ra,8001bde2 <debugf>
    debugf("  Ending device->idx = %d\n", viodev->device->idx);
    8001e65c:	fb843783          	ld	a5,-72(s0)
    8001e660:	7bbc                	ld	a5,112(a5)
    8001e662:	0027d783          	lhu	a5,2(a5)
    8001e666:	17c2                	slli	a5,a5,0x30
    8001e668:	93c1                	srli	a5,a5,0x30
    8001e66a:	2781                	sext.w	a5,a5
    8001e66c:	85be                	mv	a1,a5
    8001e66e:	0000b517          	auipc	a0,0xb
    8001e672:	81a50513          	addi	a0,a0,-2022 # 80028e88 <pow10.0+0x2028>
    8001e676:	f6cfd0ef          	jal	ra,8001bde2 <debugf>
    debugf("  input_dev->buffer_size = %d\n", input_dev->buffer_size);
    8001e67a:	fe843783          	ld	a5,-24(s0)
    8001e67e:	2187a783          	lw	a5,536(a5)
    8001e682:	85be                	mv	a1,a5
    8001e684:	0000b517          	auipc	a0,0xb
    8001e688:	82450513          	addi	a0,a0,-2012 # 80028ea8 <pow10.0+0x2048>
    8001e68c:	f56fd0ef          	jal	ra,8001bde2 <debugf>
}
    8001e690:	0001                	nop
    8001e692:	60a6                	ld	ra,72(sp)
    8001e694:	6406                	ld	s0,64(sp)
    8001e696:	6161                	addi	sp,sp,80
    8001e698:	8082                	ret

000000008001e69a <block_device_init>:
static uint64_t request_count = 0;
static Vector *device_active_jobs;
// static VirtioDevice *block_device;
static Mutex block_device_mutex;

void block_device_init() {
    8001e69a:	7139                	addi	sp,sp,-64
    8001e69c:	fc06                	sd	ra,56(sp)
    8001e69e:	f822                	sd	s0,48(sp)
    8001e6a0:	0080                	addi	s0,sp,64
    // device_active_jobs = vector_new();
    // block_device = virtio_get_block_device();
    block_device_mutex = MUTEX_UNLOCKED;
    8001e6a2:	00007797          	auipc	a5,0x7
    8001e6a6:	f1678793          	addi	a5,a5,-234 # 800255b8 <block_device_mutex>
    8001e6aa:	0007a023          	sw	zero,0(a5)
    for (uint16_t n; n < 8; n++) {
    8001e6ae:	a095                	j	8001e712 <block_device_init+0x78>
        // debugf("BAR %d: %x\n", n, pci_get_bar(block_device->pcidev, n));
        VirtioDevice *block_device = virtio_get_block_device(n);
    8001e6b0:	fee45783          	lhu	a5,-18(s0)
    8001e6b4:	853e                	mv	a0,a5
    8001e6b6:	e44fe0ef          	jal	ra,8001ccfa <virtio_get_block_device>
    8001e6ba:	fea43023          	sd	a0,-32(s0)
        if (block_device == NULL) {
    8001e6be:	fe043783          	ld	a5,-32(s0)
    8001e6c2:	c3b1                	beqz	a5,8001e706 <block_device_init+0x6c>
            debugf("No block device #%d\n", n);
            continue;
        }
        char name[16];
        sprintf(name, "block%d", n);
    8001e6c4:	fee45783          	lhu	a5,-18(s0)
    8001e6c8:	0007871b          	sext.w	a4,a5
    8001e6cc:	fc840793          	addi	a5,s0,-56
    8001e6d0:	863a                	mv	a2,a4
    8001e6d2:	0000a597          	auipc	a1,0xa
    8001e6d6:	7f658593          	addi	a1,a1,2038 # 80028ec8 <pow10.0+0x2068>
    8001e6da:	853e                	mv	a0,a5
    8001e6dc:	c4ef50ef          	jal	ra,80013b2a <sprintf>
        virtio_set_device_name(block_device, name);
    8001e6e0:	fc840793          	addi	a5,s0,-56
    8001e6e4:	85be                	mv	a1,a5
    8001e6e6:	fe043503          	ld	a0,-32(s0)
    8001e6ea:	be3fe0ef          	jal	ra,8001d2cc <virtio_set_device_name>
        block_device->ready = true;
    8001e6ee:	fe043783          	ld	a5,-32(s0)
    8001e6f2:	4705                	li	a4,1
    8001e6f4:	08e78723          	sb	a4,142(a5)
        volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001e6f8:	fe043503          	ld	a0,-32(s0)
    8001e6fc:	ba6fe0ef          	jal	ra,8001caa2 <virtio_get_block_config>
    8001e700:	fca43c23          	sd	a0,-40(s0)
    8001e704:	a011                	j	8001e708 <block_device_init+0x6e>
            continue;
    8001e706:	0001                	nop
    for (uint16_t n; n < 8; n++) {
    8001e708:	fee45783          	lhu	a5,-18(s0)
    8001e70c:	2785                	addiw	a5,a5,1
    8001e70e:	fef41723          	sh	a5,-18(s0)
    8001e712:	fee45783          	lhu	a5,-18(s0)
    8001e716:	0007871b          	sext.w	a4,a5
    8001e71a:	479d                	li	a5,7
    8001e71c:	f8e7fae3          	bgeu	a5,a4,8001e6b0 <block_device_init+0x16>
        debugf("Block #%d device has %d capacity\n", n, config->capacity);
        debugf("Block #%d device has %d cylinders\n", n, config->geometry.cylinders);
        debugf("Block #%d device has %d heads\n", n, config->geometry.heads);
        debugf("Block device init done for device at %p\n", block_device->pcidev->ecam_header);
    }
}
    8001e720:	0001                	nop
    8001e722:	0001                	nop
    8001e724:	70e2                	ld	ra,56(sp)
    8001e726:	7442                	ld	s0,48(sp)
    8001e728:	6121                	addi	sp,sp,64
    8001e72a:	8082                	ret

000000008001e72c <block_device_get_sector_size>:

uint64_t block_device_get_sector_size(VirtioDevice *block_device) {
    8001e72c:	7179                	addi	sp,sp,-48
    8001e72e:	f406                	sd	ra,40(sp)
    8001e730:	f022                	sd	s0,32(sp)
    8001e732:	1800                	addi	s0,sp,48
    8001e734:	fca43c23          	sd	a0,-40(s0)
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001e738:	fd843503          	ld	a0,-40(s0)
    8001e73c:	b66fe0ef          	jal	ra,8001caa2 <virtio_get_block_config>
    8001e740:	fea43423          	sd	a0,-24(s0)
    return config->blk_size;
    8001e744:	fe843783          	ld	a5,-24(s0)
    8001e748:	4bdc                	lw	a5,20(a5)
    8001e74a:	2781                	sext.w	a5,a5
    8001e74c:	1782                	slli	a5,a5,0x20
    8001e74e:	9381                	srli	a5,a5,0x20
}
    8001e750:	853e                	mv	a0,a5
    8001e752:	70a2                	ld	ra,40(sp)
    8001e754:	7402                	ld	s0,32(sp)
    8001e756:	6145                	addi	sp,sp,48
    8001e758:	8082                	ret

000000008001e75a <block_device_get_sector_count>:

uint64_t block_device_get_sector_count(VirtioDevice *block_device) {
    8001e75a:	7179                	addi	sp,sp,-48
    8001e75c:	f406                	sd	ra,40(sp)
    8001e75e:	f022                	sd	s0,32(sp)
    8001e760:	1800                	addi	s0,sp,48
    8001e762:	fca43c23          	sd	a0,-40(s0)
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001e766:	fd843503          	ld	a0,-40(s0)
    8001e76a:	b38fe0ef          	jal	ra,8001caa2 <virtio_get_block_config>
    8001e76e:	fea43423          	sd	a0,-24(s0)
    return config->capacity;
    8001e772:	fe843783          	ld	a5,-24(s0)
    8001e776:	639c                	ld	a5,0(a5)
}
    8001e778:	853e                	mv	a0,a5
    8001e77a:	70a2                	ld	ra,40(sp)
    8001e77c:	7402                	ld	s0,32(sp)
    8001e77e:	6145                	addi	sp,sp,48
    8001e780:	8082                	ret

000000008001e782 <block_device_get_bytes>:

uint64_t block_device_get_bytes(VirtioDevice *block_device) {
    8001e782:	7179                	addi	sp,sp,-48
    8001e784:	f406                	sd	ra,40(sp)
    8001e786:	f022                	sd	s0,32(sp)
    8001e788:	1800                	addi	s0,sp,48
    8001e78a:	fca43c23          	sd	a0,-40(s0)
    volatile VirtioBlockConfig *config = virtio_get_block_config(block_device);
    8001e78e:	fd843503          	ld	a0,-40(s0)
    8001e792:	b10fe0ef          	jal	ra,8001caa2 <virtio_get_block_config>
    8001e796:	fea43423          	sd	a0,-24(s0)
    return config->capacity * config->blk_size;
    8001e79a:	fe843783          	ld	a5,-24(s0)
    8001e79e:	6398                	ld	a4,0(a5)
    8001e7a0:	fe843783          	ld	a5,-24(s0)
    8001e7a4:	4bdc                	lw	a5,20(a5)
    8001e7a6:	2781                	sext.w	a5,a5
    8001e7a8:	1782                	slli	a5,a5,0x20
    8001e7aa:	9381                	srli	a5,a5,0x20
    8001e7ac:	02f707b3          	mul	a5,a4,a5
}
    8001e7b0:	853e                	mv	a0,a5
    8001e7b2:	70a2                	ld	ra,40(sp)
    8001e7b4:	7402                	ld	s0,32(sp)
    8001e7b6:	6145                	addi	sp,sp,48
    8001e7b8:	8082                	ret

000000008001e7ba <block_device_handle_job>:

void block_device_handle_job(VirtioDevice *block_device, Job *job) {
    8001e7ba:	7179                	addi	sp,sp,-48
    8001e7bc:	f422                	sd	s0,40(sp)
    8001e7be:	1800                	addi	s0,sp,48
    8001e7c0:	fca43c23          	sd	a0,-40(s0)
    8001e7c4:	fcb43823          	sd	a1,-48(s0)
    debugf("Handling block device job %u\n", job->job_id);
    BlockRequestPacket *packet = (BlockRequestPacket *)job->data;
    8001e7c8:	fd043783          	ld	a5,-48(s0)
    8001e7cc:	7b9c                	ld	a5,48(a5)
    8001e7ce:	fef43423          	sd	a5,-24(s0)
    debugf("Packet status in handle: %x\n", packet->status);
    
    job->data = NULL;
    8001e7d2:	fd043783          	ld	a5,-48(s0)
    8001e7d6:	0207b823          	sd	zero,48(a5)
}
    8001e7da:	0001                	nop
    8001e7dc:	7422                	ld	s0,40(sp)
    8001e7de:	6145                	addi	sp,sp,48
    8001e7e0:	8082                	ret

000000008001e7e2 <block_device_send_request>:

void block_device_send_request(VirtioDevice *block_device, BlockRequestPacket *packet) {
    8001e7e2:	7119                	addi	sp,sp,-128
    8001e7e4:	fc86                	sd	ra,120(sp)
    8001e7e6:	f8a2                	sd	s0,112(sp)
    8001e7e8:	0100                	addi	s0,sp,128
    8001e7ea:	f8a43423          	sd	a0,-120(s0)
    8001e7ee:	f8b43023          	sd	a1,-128(s0)
    mutex_spinlock(&block_device_mutex);
    8001e7f2:	00007517          	auipc	a0,0x7
    8001e7f6:	dc650513          	addi	a0,a0,-570 # 800255b8 <block_device_mutex>
    8001e7fa:	e41f60ef          	jal	ra,8001563a <mutex_spinlock>
    request_count++;
    8001e7fe:	00007797          	auipc	a5,0x7
    8001e802:	daa78793          	addi	a5,a5,-598 # 800255a8 <request_count>
    8001e806:	639c                	ld	a5,0(a5)
    8001e808:	00178713          	addi	a4,a5,1
    8001e80c:	00007797          	auipc	a5,0x7
    8001e810:	d9c78793          	addi	a5,a5,-612 # 800255a8 <request_count>
    8001e814:	e398                	sd	a4,0(a5)

    debugf("Sending block request #%u\n", request_count);
    // First descriptor is the header
    packet->status = 0xf;
    8001e816:	f8043783          	ld	a5,-128(s0)
    8001e81a:	473d                	li	a4,15
    8001e81c:	00e78ca3          	sb	a4,25(a5)

    VirtioDescriptor header;
    header.addr = kernel_mmu_translate((uint64_t)packet);
    8001e820:	f8043783          	ld	a5,-128(s0)
    8001e824:	853e                	mv	a0,a5
    8001e826:	a5ef70ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001e82a:	87aa                	mv	a5,a0
    8001e82c:	fef43023          	sd	a5,-32(s0)
    header.flags = VIRTQ_DESC_F_NEXT;
    8001e830:	4785                	li	a5,1
    8001e832:	fef41623          	sh	a5,-20(s0)
    header.len = sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t);
    8001e836:	47c1                	li	a5,16
    8001e838:	fef42423          	sw	a5,-24(s0)

    // Second descriptor is the data
    VirtioDescriptor data;
    data.addr = kernel_mmu_translate((uint64_t)packet->data);
    8001e83c:	f8043783          	ld	a5,-128(s0)
    8001e840:	6b9c                	ld	a5,16(a5)
    8001e842:	853e                	mv	a0,a5
    8001e844:	a40f70ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001e848:	87aa                	mv	a5,a0
    8001e84a:	fcf43823          	sd	a5,-48(s0)
    if (packet->type == VIRTIO_BLK_T_IN)
    8001e84e:	f8043783          	ld	a5,-128(s0)
    8001e852:	439c                	lw	a5,0(a5)
    8001e854:	e781                	bnez	a5,8001e85c <block_device_send_request+0x7a>
        data.flags = VIRTQ_DESC_F_WRITE;
    8001e856:	4789                	li	a5,2
    8001e858:	fcf41e23          	sh	a5,-36(s0)
    data.flags |= VIRTQ_DESC_F_NEXT;
    8001e85c:	fdc45783          	lhu	a5,-36(s0)
    8001e860:	0017e793          	ori	a5,a5,1
    8001e864:	17c2                	slli	a5,a5,0x30
    8001e866:	93c1                	srli	a5,a5,0x30
    8001e868:	fcf41e23          	sh	a5,-36(s0)
    data.len = packet->sector_count * 512;
    8001e86c:	f8043783          	ld	a5,-128(s0)
    8001e870:	0187c783          	lbu	a5,24(a5)
    8001e874:	2781                	sext.w	a5,a5
    8001e876:	0097979b          	slliw	a5,a5,0x9
    8001e87a:	2781                	sext.w	a5,a5
    8001e87c:	2781                	sext.w	a5,a5
    8001e87e:	fcf42c23          	sw	a5,-40(s0)

    // The third descriptor is the status
    VirtioDescriptor status;
    status.addr = kernel_mmu_translate((uint64_t)&packet->status);
    8001e882:	f8043783          	ld	a5,-128(s0)
    8001e886:	07e5                	addi	a5,a5,25
    8001e888:	853e                	mv	a0,a5
    8001e88a:	9faf70ef          	jal	ra,80015a84 <kernel_mmu_translate>
    8001e88e:	87aa                	mv	a5,a0
    8001e890:	fcf43023          	sd	a5,-64(s0)
    status.flags = VIRTQ_DESC_F_WRITE;
    8001e894:	4789                	li	a5,2
    8001e896:	fcf41623          	sh	a5,-52(s0)
    status.len = sizeof(packet->status);
    8001e89a:	4785                	li	a5,1
    8001e89c:	fcf42423          	sw	a5,-56(s0)

    VirtioDescriptor chain[3];
    chain[0] = header;
    8001e8a0:	fe043783          	ld	a5,-32(s0)
    8001e8a4:	f8f43823          	sd	a5,-112(s0)
    8001e8a8:	fe843783          	ld	a5,-24(s0)
    8001e8ac:	f8f43c23          	sd	a5,-104(s0)
    chain[1] = data;
    8001e8b0:	fd043783          	ld	a5,-48(s0)
    8001e8b4:	faf43023          	sd	a5,-96(s0)
    8001e8b8:	fd843783          	ld	a5,-40(s0)
    8001e8bc:	faf43423          	sd	a5,-88(s0)
    chain[2] = status;
    8001e8c0:	fc043783          	ld	a5,-64(s0)
    8001e8c4:	faf43823          	sd	a5,-80(s0)
    8001e8c8:	fc843783          	ld	a5,-56(s0)
    8001e8cc:	faf43c23          	sd	a5,-72(s0)

    virtio_create_job_with_data(block_device, 1, block_device_handle_job, packet);
    8001e8d0:	f8043683          	ld	a3,-128(s0)
    8001e8d4:	00000617          	auipc	a2,0x0
    8001e8d8:	ee660613          	addi	a2,a2,-282 # 8001e7ba <block_device_handle_job>
    8001e8dc:	4585                	li	a1,1
    8001e8de:	f8843503          	ld	a0,-120(s0)
    8001e8e2:	c57fd0ef          	jal	ra,8001c538 <virtio_create_job_with_data>
    virtio_send_descriptor_chain(block_device, 0, chain, 3, true);
    8001e8e6:	f9040793          	addi	a5,s0,-112
    8001e8ea:	4705                	li	a4,1
    8001e8ec:	468d                	li	a3,3
    8001e8ee:	863e                	mv	a2,a5
    8001e8f0:	4581                	li	a1,0
    8001e8f2:	f8843503          	ld	a0,-120(s0)
    8001e8f6:	bfffe0ef          	jal	ra,8001d4f4 <virtio_send_descriptor_chain>
    WFI();
    8001e8fa:	10500073          	wfi

    debugf("Packet status after sending request #%u: %x\n", request_count, packet->status);
    if (packet->status != 0) {
    8001e8fe:	f8043783          	ld	a5,-128(s0)
    8001e902:	0197c783          	lbu	a5,25(a5)
    8001e906:	cf89                	beqz	a5,8001e920 <block_device_send_request+0x13e>
        warnf("Block device request failed with status %x\n", packet->status);
    8001e908:	f8043783          	ld	a5,-128(s0)
    8001e90c:	0197c783          	lbu	a5,25(a5)
    8001e910:	2781                	sext.w	a5,a5
    8001e912:	85be                	mv	a1,a5
    8001e914:	0000a517          	auipc	a0,0xa
    8001e918:	5bc50513          	addi	a0,a0,1468 # 80028ed0 <pow10.0+0x2070>
    8001e91c:	d1cfd0ef          	jal	ra,8001be38 <warnf>
    }
    
    mutex_unlock(&block_device_mutex);
    8001e920:	00007517          	auipc	a0,0x7
    8001e924:	c9850513          	addi	a0,a0,-872 # 800255b8 <block_device_mutex>
    8001e928:	d41f60ef          	jal	ra,80015668 <mutex_unlock>
}
    8001e92c:	0001                	nop
    8001e92e:	70e6                	ld	ra,120(sp)
    8001e930:	7446                	ld	s0,112(sp)
    8001e932:	6109                	addi	sp,sp,128
    8001e934:	8082                	ret

000000008001e936 <block_device_read_sector>:

void block_device_read_sector(VirtioDevice *block_device, uint64_t sector, uint8_t *data) {
    8001e936:	715d                	addi	sp,sp,-80
    8001e938:	e486                	sd	ra,72(sp)
    8001e93a:	e0a2                	sd	s0,64(sp)
    8001e93c:	0880                	addi	s0,sp,80
    8001e93e:	fca43423          	sd	a0,-56(s0)
    8001e942:	fcb43023          	sd	a1,-64(s0)
    8001e946:	fac43c23          	sd	a2,-72(s0)
    debugf("Reading sector %d\n", sector);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_IN;
    8001e94a:	fc042823          	sw	zero,-48(s0)
    packet.sector = sector;
    8001e94e:	fc043783          	ld	a5,-64(s0)
    8001e952:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001e956:	fb843783          	ld	a5,-72(s0)
    8001e95a:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    8001e95e:	4785                	li	a5,1
    8001e960:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001e964:	47bd                	li	a5,15
    8001e966:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001e96a:	fd040793          	addi	a5,s0,-48
    8001e96e:	85be                	mv	a1,a5
    8001e970:	fc843503          	ld	a0,-56(s0)
    8001e974:	e6fff0ef          	jal	ra,8001e7e2 <block_device_send_request>
}
    8001e978:	0001                	nop
    8001e97a:	60a6                	ld	ra,72(sp)
    8001e97c:	6406                	ld	s0,64(sp)
    8001e97e:	6161                	addi	sp,sp,80
    8001e980:	8082                	ret

000000008001e982 <block_device_write_sector>:

void block_device_write_sector(VirtioDevice *block_device, uint64_t sector, uint8_t *data) {
    8001e982:	715d                	addi	sp,sp,-80
    8001e984:	e486                	sd	ra,72(sp)
    8001e986:	e0a2                	sd	s0,64(sp)
    8001e988:	0880                	addi	s0,sp,80
    8001e98a:	fca43423          	sd	a0,-56(s0)
    8001e98e:	fcb43023          	sd	a1,-64(s0)
    8001e992:	fac43c23          	sd	a2,-72(s0)
    debugf("Writing sector %d\n", sector);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_OUT;
    8001e996:	4785                	li	a5,1
    8001e998:	fcf42823          	sw	a5,-48(s0)
    packet.sector = sector;
    8001e99c:	fc043783          	ld	a5,-64(s0)
    8001e9a0:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001e9a4:	fb843783          	ld	a5,-72(s0)
    8001e9a8:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = 1;
    8001e9ac:	4785                	li	a5,1
    8001e9ae:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001e9b2:	47bd                	li	a5,15
    8001e9b4:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001e9b8:	fd040793          	addi	a5,s0,-48
    8001e9bc:	85be                	mv	a1,a5
    8001e9be:	fc843503          	ld	a0,-56(s0)
    8001e9c2:	e21ff0ef          	jal	ra,8001e7e2 <block_device_send_request>
}
    8001e9c6:	0001                	nop
    8001e9c8:	60a6                	ld	ra,72(sp)
    8001e9ca:	6406                	ld	s0,64(sp)
    8001e9cc:	6161                	addi	sp,sp,80
    8001e9ce:	8082                	ret

000000008001e9d0 <block_device_read_sectors>:

void block_device_read_sectors(VirtioDevice *block_device, uint64_t sector, uint8_t *data, uint64_t count) {
    8001e9d0:	715d                	addi	sp,sp,-80
    8001e9d2:	e486                	sd	ra,72(sp)
    8001e9d4:	e0a2                	sd	s0,64(sp)
    8001e9d6:	0880                	addi	s0,sp,80
    8001e9d8:	fca43423          	sd	a0,-56(s0)
    8001e9dc:	fcb43023          	sd	a1,-64(s0)
    8001e9e0:	fac43c23          	sd	a2,-72(s0)
    8001e9e4:	fad43823          	sd	a3,-80(s0)
    debugf("Read sectors %d-%d\n", sector, sector + count);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_IN;
    8001e9e8:	fc042823          	sw	zero,-48(s0)
    packet.sector = sector;
    8001e9ec:	fc043783          	ld	a5,-64(s0)
    8001e9f0:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001e9f4:	fb843783          	ld	a5,-72(s0)
    8001e9f8:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = count;
    8001e9fc:	fb043783          	ld	a5,-80(s0)
    8001ea00:	0ff7f793          	andi	a5,a5,255
    8001ea04:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001ea08:	47bd                	li	a5,15
    8001ea0a:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001ea0e:	fd040793          	addi	a5,s0,-48
    8001ea12:	85be                	mv	a1,a5
    8001ea14:	fc843503          	ld	a0,-56(s0)
    8001ea18:	dcbff0ef          	jal	ra,8001e7e2 <block_device_send_request>
}
    8001ea1c:	0001                	nop
    8001ea1e:	60a6                	ld	ra,72(sp)
    8001ea20:	6406                	ld	s0,64(sp)
    8001ea22:	6161                	addi	sp,sp,80
    8001ea24:	8082                	ret

000000008001ea26 <block_device_write_sectors>:

void block_device_write_sectors(VirtioDevice *block_device, uint64_t sector, uint8_t *data, uint64_t count) {
    8001ea26:	715d                	addi	sp,sp,-80
    8001ea28:	e486                	sd	ra,72(sp)
    8001ea2a:	e0a2                	sd	s0,64(sp)
    8001ea2c:	0880                	addi	s0,sp,80
    8001ea2e:	fca43423          	sd	a0,-56(s0)
    8001ea32:	fcb43023          	sd	a1,-64(s0)
    8001ea36:	fac43c23          	sd	a2,-72(s0)
    8001ea3a:	fad43823          	sd	a3,-80(s0)
    debugf("Writing sectors %d-%d\n", sector, sector + count);
    BlockRequestPacket packet;
    packet.type = VIRTIO_BLK_T_OUT;
    8001ea3e:	4785                	li	a5,1
    8001ea40:	fcf42823          	sw	a5,-48(s0)
    packet.sector = sector;
    8001ea44:	fc043783          	ld	a5,-64(s0)
    8001ea48:	fcf43c23          	sd	a5,-40(s0)
    packet.data = data;
    8001ea4c:	fb843783          	ld	a5,-72(s0)
    8001ea50:	fef43023          	sd	a5,-32(s0)
    packet.sector_count = count;
    8001ea54:	fb043783          	ld	a5,-80(s0)
    8001ea58:	0ff7f793          	andi	a5,a5,255
    8001ea5c:	fef40423          	sb	a5,-24(s0)
    packet.status = 0xf;
    8001ea60:	47bd                	li	a5,15
    8001ea62:	fef404a3          	sb	a5,-23(s0)

    block_device_send_request(block_device, &packet);
    8001ea66:	fd040793          	addi	a5,s0,-48
    8001ea6a:	85be                	mv	a1,a5
    8001ea6c:	fc843503          	ld	a0,-56(s0)
    8001ea70:	d73ff0ef          	jal	ra,8001e7e2 <block_device_send_request>
}
    8001ea74:	0001                	nop
    8001ea76:	60a6                	ld	ra,72(sp)
    8001ea78:	6406                	ld	s0,64(sp)
    8001ea7a:	6161                	addi	sp,sp,80
    8001ea7c:	8082                	ret

000000008001ea7e <block_device_read_bytes>:


void block_device_read_bytes(VirtioDevice *block_device, uint64_t byte, uint8_t *data, uint64_t bytes) {
    8001ea7e:	7159                	addi	sp,sp,-112
    8001ea80:	f486                	sd	ra,104(sp)
    8001ea82:	f0a2                	sd	s0,96(sp)
    8001ea84:	eca6                	sd	s1,88(sp)
    8001ea86:	1880                	addi	s0,sp,112
    8001ea88:	faa43423          	sd	a0,-88(s0)
    8001ea8c:	fab43023          	sd	a1,-96(s0)
    8001ea90:	f8c43c23          	sd	a2,-104(s0)
    8001ea94:	f8d43823          	sd	a3,-112(s0)
    8001ea98:	868a                	mv	a3,sp
    8001ea9a:	84b6                	mv	s1,a3
    debugf("block_device_read_bytes(%d, %p, %d)\n", byte, data, bytes);
    uint64_t sectors = ALIGN_UP_POT(bytes, 512) / 512;
    8001ea9c:	f9043683          	ld	a3,-112(s0)
    8001eaa0:	1ff68693          	addi	a3,a3,511
    8001eaa4:	82a5                	srli	a3,a3,0x9
    8001eaa6:	fcd43823          	sd	a3,-48(s0)
    uint64_t sector = byte / 512;
    8001eaaa:	fa043683          	ld	a3,-96(s0)
    8001eaae:	82a5                	srli	a3,a3,0x9
    8001eab0:	fcd43423          	sd	a3,-56(s0)
    uint8_t buffer[sectors][512];
    8001eab4:	fd043683          	ld	a3,-48(s0)
    8001eab8:	8636                	mv	a2,a3
    8001eaba:	167d                	addi	a2,a2,-1
    8001eabc:	fcc43023          	sd	a2,-64(s0)
    8001eac0:	8e36                	mv	t3,a3
    8001eac2:	4e81                	li	t4,0
    8001eac4:	034e5613          	srli	a2,t3,0x34
    8001eac8:	00ce9893          	slli	a7,t4,0xc
    8001eacc:	011668b3          	or	a7,a2,a7
    8001ead0:	00ce1813          	slli	a6,t3,0xc
    8001ead4:	8336                	mv	t1,a3
    8001ead6:	4381                	li	t2,0
    8001ead8:	03435613          	srli	a2,t1,0x34
    8001eadc:	00c39793          	slli	a5,t2,0xc
    8001eae0:	8fd1                	or	a5,a5,a2
    8001eae2:	00c31713          	slli	a4,t1,0xc
    8001eae6:	00969793          	slli	a5,a3,0x9
    8001eaea:	07bd                	addi	a5,a5,15
    8001eaec:	8391                	srli	a5,a5,0x4
    8001eaee:	0792                	slli	a5,a5,0x4
    8001eaf0:	40f10133          	sub	sp,sp,a5
    8001eaf4:	878a                	mv	a5,sp
    8001eaf6:	00078793          	mv	a5,a5
    8001eafa:	faf43c23          	sd	a5,-72(s0)
    
    block_device_read_sectors(block_device, sector, (uint8_t *)buffer, sectors);
    8001eafe:	fd043683          	ld	a3,-48(s0)
    8001eb02:	fb843603          	ld	a2,-72(s0)
    8001eb06:	fc843583          	ld	a1,-56(s0)
    8001eb0a:	fa843503          	ld	a0,-88(s0)
    8001eb0e:	ec3ff0ef          	jal	ra,8001e9d0 <block_device_read_sectors>

    uint64_t alignment_offset = byte % 512;
    8001eb12:	fa043783          	ld	a5,-96(s0)
    8001eb16:	1ff7f793          	andi	a5,a5,511
    8001eb1a:	faf43823          	sd	a5,-80(s0)

    // Copy the data with the correct offset
    for (uint64_t i = 0; i < bytes; i++) {
    8001eb1e:	fc043c23          	sd	zero,-40(s0)
    8001eb22:	a83d                	j	8001eb60 <block_device_read_bytes+0xe2>
        data[i] = buffer[i / 512][(alignment_offset + i) % 512];
    8001eb24:	fd843783          	ld	a5,-40(s0)
    8001eb28:	0097d693          	srli	a3,a5,0x9
    8001eb2c:	fb043703          	ld	a4,-80(s0)
    8001eb30:	fd843783          	ld	a5,-40(s0)
    8001eb34:	97ba                	add	a5,a5,a4
    8001eb36:	1ff7f713          	andi	a4,a5,511
    8001eb3a:	f9843603          	ld	a2,-104(s0)
    8001eb3e:	fd843783          	ld	a5,-40(s0)
    8001eb42:	97b2                	add	a5,a5,a2
    8001eb44:	fb843603          	ld	a2,-72(s0)
    8001eb48:	06a6                	slli	a3,a3,0x9
    8001eb4a:	96b2                	add	a3,a3,a2
    8001eb4c:	9736                	add	a4,a4,a3
    8001eb4e:	00074703          	lbu	a4,0(a4)
    8001eb52:	00e78023          	sb	a4,0(a5)
    for (uint64_t i = 0; i < bytes; i++) {
    8001eb56:	fd843783          	ld	a5,-40(s0)
    8001eb5a:	0785                	addi	a5,a5,1
    8001eb5c:	fcf43c23          	sd	a5,-40(s0)
    8001eb60:	fd843703          	ld	a4,-40(s0)
    8001eb64:	f9043783          	ld	a5,-112(s0)
    8001eb68:	faf76ee3          	bltu	a4,a5,8001eb24 <block_device_read_bytes+0xa6>
    8001eb6c:	8126                	mv	sp,s1
    }
}
    8001eb6e:	0001                	nop
    8001eb70:	f9040113          	addi	sp,s0,-112
    8001eb74:	70a6                	ld	ra,104(sp)
    8001eb76:	7406                	ld	s0,96(sp)
    8001eb78:	64e6                	ld	s1,88(sp)
    8001eb7a:	6165                	addi	sp,sp,112
    8001eb7c:	8082                	ret

000000008001eb7e <block_device_write_bytes>:


void block_device_write_bytes(VirtioDevice *block_device, uint64_t byte, uint8_t *data, uint64_t bytes) {
    8001eb7e:	7159                	addi	sp,sp,-112
    8001eb80:	f486                	sd	ra,104(sp)
    8001eb82:	f0a2                	sd	s0,96(sp)
    8001eb84:	eca6                	sd	s1,88(sp)
    8001eb86:	1880                	addi	s0,sp,112
    8001eb88:	faa43423          	sd	a0,-88(s0)
    8001eb8c:	fab43023          	sd	a1,-96(s0)
    8001eb90:	f8c43c23          	sd	a2,-104(s0)
    8001eb94:	f8d43823          	sd	a3,-112(s0)
    8001eb98:	868a                	mv	a3,sp
    8001eb9a:	84b6                	mv	s1,a3
    debugf("block_device_write_bytes(%d, %p, %d)\n", byte, data, bytes);
    uint64_t sectors = ALIGN_UP_POT(bytes, 512) / 512;
    8001eb9c:	f9043683          	ld	a3,-112(s0)
    8001eba0:	1ff68693          	addi	a3,a3,511
    8001eba4:	82a5                	srli	a3,a3,0x9
    8001eba6:	fcd43823          	sd	a3,-48(s0)
    uint64_t sector = byte / 512;
    8001ebaa:	fa043683          	ld	a3,-96(s0)
    8001ebae:	82a5                	srli	a3,a3,0x9
    8001ebb0:	fcd43423          	sd	a3,-56(s0)
    uint8_t buffer[sectors][512];
    8001ebb4:	fd043683          	ld	a3,-48(s0)
    8001ebb8:	8636                	mv	a2,a3
    8001ebba:	167d                	addi	a2,a2,-1
    8001ebbc:	fcc43023          	sd	a2,-64(s0)
    8001ebc0:	8e36                	mv	t3,a3
    8001ebc2:	4e81                	li	t4,0
    8001ebc4:	034e5613          	srli	a2,t3,0x34
    8001ebc8:	00ce9893          	slli	a7,t4,0xc
    8001ebcc:	011668b3          	or	a7,a2,a7
    8001ebd0:	00ce1813          	slli	a6,t3,0xc
    8001ebd4:	8336                	mv	t1,a3
    8001ebd6:	4381                	li	t2,0
    8001ebd8:	03435613          	srli	a2,t1,0x34
    8001ebdc:	00c39793          	slli	a5,t2,0xc
    8001ebe0:	8fd1                	or	a5,a5,a2
    8001ebe2:	00c31713          	slli	a4,t1,0xc
    8001ebe6:	00969793          	slli	a5,a3,0x9
    8001ebea:	07bd                	addi	a5,a5,15
    8001ebec:	8391                	srli	a5,a5,0x4
    8001ebee:	0792                	slli	a5,a5,0x4
    8001ebf0:	40f10133          	sub	sp,sp,a5
    8001ebf4:	878a                	mv	a5,sp
    8001ebf6:	00078793          	mv	a5,a5
    8001ebfa:	faf43c23          	sd	a5,-72(s0)

    uint64_t alignment_offset = byte % 512;
    8001ebfe:	fa043783          	ld	a5,-96(s0)
    8001ec02:	1ff7f793          	andi	a5,a5,511
    8001ec06:	faf43823          	sd	a5,-80(s0)
    block_device_read_sectors(block_device, sector, (uint8_t *)buffer, sectors);
    8001ec0a:	fd043683          	ld	a3,-48(s0)
    8001ec0e:	fb843603          	ld	a2,-72(s0)
    8001ec12:	fc843583          	ld	a1,-56(s0)
    8001ec16:	fa843503          	ld	a0,-88(s0)
    8001ec1a:	db7ff0ef          	jal	ra,8001e9d0 <block_device_read_sectors>
    // Copy the data with the correct offset
    for (uint64_t i = 0; i < bytes; i++) {
    8001ec1e:	fc043c23          	sd	zero,-40(s0)
    8001ec22:	a83d                	j	8001ec60 <block_device_write_bytes+0xe2>
        buffer[i / 512][(alignment_offset + i) % 512] = data[i];
    8001ec24:	f9843703          	ld	a4,-104(s0)
    8001ec28:	fd843783          	ld	a5,-40(s0)
    8001ec2c:	973e                	add	a4,a4,a5
    8001ec2e:	fd843783          	ld	a5,-40(s0)
    8001ec32:	0097d693          	srli	a3,a5,0x9
    8001ec36:	fb043603          	ld	a2,-80(s0)
    8001ec3a:	fd843783          	ld	a5,-40(s0)
    8001ec3e:	97b2                	add	a5,a5,a2
    8001ec40:	1ff7f793          	andi	a5,a5,511
    8001ec44:	00074703          	lbu	a4,0(a4)
    8001ec48:	fb843603          	ld	a2,-72(s0)
    8001ec4c:	06a6                	slli	a3,a3,0x9
    8001ec4e:	96b2                	add	a3,a3,a2
    8001ec50:	97b6                	add	a5,a5,a3
    8001ec52:	00e78023          	sb	a4,0(a5)
    for (uint64_t i = 0; i < bytes; i++) {
    8001ec56:	fd843783          	ld	a5,-40(s0)
    8001ec5a:	0785                	addi	a5,a5,1
    8001ec5c:	fcf43c23          	sd	a5,-40(s0)
    8001ec60:	fd843703          	ld	a4,-40(s0)
    8001ec64:	f9043783          	ld	a5,-112(s0)
    8001ec68:	faf76ee3          	bltu	a4,a5,8001ec24 <block_device_write_bytes+0xa6>
    }

    block_device_write_sectors(block_device, sector, (uint8_t *)buffer, sectors);
    8001ec6c:	fd043683          	ld	a3,-48(s0)
    8001ec70:	fb843603          	ld	a2,-72(s0)
    8001ec74:	fc843583          	ld	a1,-56(s0)
    8001ec78:	fa843503          	ld	a0,-88(s0)
    8001ec7c:	dabff0ef          	jal	ra,8001ea26 <block_device_write_sectors>
    8001ec80:	8126                	mv	sp,s1
}
    8001ec82:	0001                	nop
    8001ec84:	f9040113          	addi	sp,s0,-112
    8001ec88:	70a6                	ld	ra,104(sp)
    8001ec8a:	7406                	ld	s0,96(sp)
    8001ec8c:	64e6                	ld	s1,88(sp)
    8001ec8e:	6165                	addi	sp,sp,112
    8001ec90:	8082                	ret

000000008001ec92 <debug_file>:
#define debugf(...) debugf(__VA_ARGS__)
#else
#define debugf(...)
#endif

void debug_file(File *file) {
    8001ec92:	1101                	addi	sp,sp,-32
    8001ec94:	ec22                	sd	s0,24(sp)
    8001ec96:	1000                	addi	s0,sp,32
    8001ec98:	fea43423          	sd	a0,-24(s0)
    debugf("    type: %x\n", file->type);
    debugf("    is_file: %u\n", file->is_file);
    debugf("    is_dir: %u\n", file->is_dir);
    debugf("    is_block_device: %u\n", file->is_block_device);
    debugf("}\n");
}
    8001ec9c:	0001                	nop
    8001ec9e:	6462                	ld	s0,24(sp)
    8001eca0:	6105                	addi	sp,sp,32
    8001eca2:	8082                	ret

000000008001eca4 <vfs_read>:

int vfs_read(File *file, void *buf, int count) {
    8001eca4:	7179                	addi	sp,sp,-48
    8001eca6:	f406                	sd	ra,40(sp)
    8001eca8:	f022                	sd	s0,32(sp)
    8001ecaa:	1800                	addi	s0,sp,48
    8001ecac:	fea43423          	sd	a0,-24(s0)
    8001ecb0:	feb43023          	sd	a1,-32(s0)
    8001ecb4:	87b2                	mv	a5,a2
    8001ecb6:	fcf42e23          	sw	a5,-36(s0)
    if (file->offset + count > file->size) {
    8001ecba:	fe843783          	ld	a5,-24(s0)
    8001ecbe:	6bb8                	ld	a4,80(a5)
    8001ecc0:	fdc42783          	lw	a5,-36(s0)
    8001ecc4:	97ba                	add	a5,a5,a4
    8001ecc6:	873e                	mv	a4,a5
    8001ecc8:	fe843783          	ld	a5,-24(s0)
    8001eccc:	73bc                	ld	a5,96(a5)
    8001ecce:	02e7f063          	bgeu	a5,a4,8001ecee <vfs_read+0x4a>
        count = file->size - file->offset;
    8001ecd2:	fe843783          	ld	a5,-24(s0)
    8001ecd6:	73bc                	ld	a5,96(a5)
    8001ecd8:	0007871b          	sext.w	a4,a5
    8001ecdc:	fe843783          	ld	a5,-24(s0)
    8001ece0:	6bbc                	ld	a5,80(a5)
    8001ece2:	2781                	sext.w	a5,a5
    8001ece4:	40f707bb          	subw	a5,a4,a5
    8001ece8:	2781                	sext.w	a5,a5
    8001ecea:	fcf42e23          	sw	a5,-36(s0)
    }

    switch (file->type) {
    8001ecee:	fe843783          	ld	a5,-24(s0)
    8001ecf2:	0087d783          	lhu	a5,8(a5)
    8001ecf6:	2781                	sext.w	a5,a5
    8001ecf8:	86be                	mv	a3,a5
    8001ecfa:	4741                	li	a4,16
    8001ecfc:	04e68c63          	beq	a3,a4,8001ed54 <vfs_read+0xb0>
    8001ed00:	86be                	mv	a3,a5
    8001ed02:	4741                	li	a4,16
    8001ed04:	08d74563          	blt	a4,a3,8001ed8e <vfs_read+0xea>
    8001ed08:	86be                	mv	a3,a5
    8001ed0a:	4705                	li	a4,1
    8001ed0c:	00e68763          	beq	a3,a4,8001ed1a <vfs_read+0x76>
    8001ed10:	873e                	mv	a4,a5
    8001ed12:	4789                	li	a5,2
    8001ed14:	06f70b63          	beq	a4,a5,8001ed8a <vfs_read+0xe6>
    8001ed18:	a89d                	j	8001ed8e <vfs_read+0xea>
    case VFS_TYPE_FILE:
        minix3_get_data(file->dev, file->inode, buf, file->offset, count);
    8001ed1a:	fe843783          	ld	a5,-24(s0)
    8001ed1e:	6388                	ld	a0,0(a5)
    8001ed20:	fe843783          	ld	a5,-24(s0)
    8001ed24:	47ec                	lw	a1,76(a5)
    8001ed26:	fe843783          	ld	a5,-24(s0)
    8001ed2a:	6bbc                	ld	a5,80(a5)
    8001ed2c:	2781                	sext.w	a5,a5
    8001ed2e:	fdc42703          	lw	a4,-36(s0)
    8001ed32:	86be                	mv	a3,a5
    8001ed34:	fe043603          	ld	a2,-32(s0)
    8001ed38:	d15f90ef          	jal	ra,80018a4c <minix3_get_data>
        file->offset += count;
    8001ed3c:	fe843783          	ld	a5,-24(s0)
    8001ed40:	6bb8                	ld	a4,80(a5)
    8001ed42:	fdc42783          	lw	a5,-36(s0)
    8001ed46:	973e                	add	a4,a4,a5
    8001ed48:	fe843783          	ld	a5,-24(s0)
    8001ed4c:	ebb8                	sd	a4,80(a5)
        return count;
    8001ed4e:	fdc42783          	lw	a5,-36(s0)
    8001ed52:	a83d                	j	8001ed90 <vfs_read+0xec>
    case VFS_TYPE_BLOCK:
        block_device_read_bytes(file->dev, file->offset, buf, (uint64_t)count);
    8001ed54:	fe843783          	ld	a5,-24(s0)
    8001ed58:	6398                	ld	a4,0(a5)
    8001ed5a:	fe843783          	ld	a5,-24(s0)
    8001ed5e:	6bbc                	ld	a5,80(a5)
    8001ed60:	85be                	mv	a1,a5
    8001ed62:	fdc42783          	lw	a5,-36(s0)
    8001ed66:	86be                	mv	a3,a5
    8001ed68:	fe043603          	ld	a2,-32(s0)
    8001ed6c:	853a                	mv	a0,a4
    8001ed6e:	d11ff0ef          	jal	ra,8001ea7e <block_device_read_bytes>
        file->offset += count;
    8001ed72:	fe843783          	ld	a5,-24(s0)
    8001ed76:	6bb8                	ld	a4,80(a5)
    8001ed78:	fdc42783          	lw	a5,-36(s0)
    8001ed7c:	973e                	add	a4,a4,a5
    8001ed7e:	fe843783          	ld	a5,-24(s0)
    8001ed82:	ebb8                	sd	a4,80(a5)
        return count;
    8001ed84:	fdc42783          	lw	a5,-36(s0)
    8001ed88:	a021                	j	8001ed90 <vfs_read+0xec>
    case VFS_TYPE_DIR:
        debugf("vfs_read: reading from directory not supported\n");
        return -1;
    8001ed8a:	57fd                	li	a5,-1
    8001ed8c:	a011                	j	8001ed90 <vfs_read+0xec>
    default:
        debugf("vfs_read: unsupported file type %d\n", file->type);
        return -1;
    8001ed8e:	57fd                	li	a5,-1
    }
}
    8001ed90:	853e                	mv	a0,a5
    8001ed92:	70a2                	ld	ra,40(sp)
    8001ed94:	7402                	ld	s0,32(sp)
    8001ed96:	6145                	addi	sp,sp,48
    8001ed98:	8082                	ret

000000008001ed9a <vfs_write>:
int vfs_write(File *file, const char *buf, int count) {
    8001ed9a:	7179                	addi	sp,sp,-48
    8001ed9c:	f406                	sd	ra,40(sp)
    8001ed9e:	f022                	sd	s0,32(sp)
    8001eda0:	1800                	addi	s0,sp,48
    8001eda2:	fea43423          	sd	a0,-24(s0)
    8001eda6:	feb43023          	sd	a1,-32(s0)
    8001edaa:	87b2                	mv	a5,a2
    8001edac:	fcf42e23          	sw	a5,-36(s0)
    if (file->offset + count > file->size) {
    8001edb0:	fe843783          	ld	a5,-24(s0)
    8001edb4:	6bb8                	ld	a4,80(a5)
    8001edb6:	fdc42783          	lw	a5,-36(s0)
    8001edba:	97ba                	add	a5,a5,a4
    8001edbc:	873e                	mv	a4,a5
    8001edbe:	fe843783          	ld	a5,-24(s0)
    8001edc2:	73bc                	ld	a5,96(a5)
    8001edc4:	02e7f063          	bgeu	a5,a4,8001ede4 <vfs_write+0x4a>
        count = file->size - file->offset;
    8001edc8:	fe843783          	ld	a5,-24(s0)
    8001edcc:	73bc                	ld	a5,96(a5)
    8001edce:	0007871b          	sext.w	a4,a5
    8001edd2:	fe843783          	ld	a5,-24(s0)
    8001edd6:	6bbc                	ld	a5,80(a5)
    8001edd8:	2781                	sext.w	a5,a5
    8001edda:	40f707bb          	subw	a5,a4,a5
    8001edde:	2781                	sext.w	a5,a5
    8001ede0:	fcf42e23          	sw	a5,-36(s0)
    }

    switch (file->type) {
    8001ede4:	fe843783          	ld	a5,-24(s0)
    8001ede8:	0087d783          	lhu	a5,8(a5)
    8001edec:	2781                	sext.w	a5,a5
    8001edee:	86be                	mv	a3,a5
    8001edf0:	4741                	li	a4,16
    8001edf2:	04e68c63          	beq	a3,a4,8001ee4a <vfs_write+0xb0>
    8001edf6:	86be                	mv	a3,a5
    8001edf8:	4741                	li	a4,16
    8001edfa:	08d74563          	blt	a4,a3,8001ee84 <vfs_write+0xea>
    8001edfe:	86be                	mv	a3,a5
    8001ee00:	4705                	li	a4,1
    8001ee02:	00e68763          	beq	a3,a4,8001ee10 <vfs_write+0x76>
    8001ee06:	873e                	mv	a4,a5
    8001ee08:	4789                	li	a5,2
    8001ee0a:	06f70b63          	beq	a4,a5,8001ee80 <vfs_write+0xe6>
    8001ee0e:	a89d                	j	8001ee84 <vfs_write+0xea>
    case VFS_TYPE_FILE:
        minix3_put_data(file->dev, file->inode, buf, file->offset, count);
    8001ee10:	fe843783          	ld	a5,-24(s0)
    8001ee14:	6388                	ld	a0,0(a5)
    8001ee16:	fe843783          	ld	a5,-24(s0)
    8001ee1a:	47ec                	lw	a1,76(a5)
    8001ee1c:	fe843783          	ld	a5,-24(s0)
    8001ee20:	6bbc                	ld	a5,80(a5)
    8001ee22:	2781                	sext.w	a5,a5
    8001ee24:	fdc42703          	lw	a4,-36(s0)
    8001ee28:	86be                	mv	a3,a5
    8001ee2a:	fe043603          	ld	a2,-32(s0)
    8001ee2e:	a11fa0ef          	jal	ra,8001983e <minix3_put_data>
        file->offset += count;
    8001ee32:	fe843783          	ld	a5,-24(s0)
    8001ee36:	6bb8                	ld	a4,80(a5)
    8001ee38:	fdc42783          	lw	a5,-36(s0)
    8001ee3c:	973e                	add	a4,a4,a5
    8001ee3e:	fe843783          	ld	a5,-24(s0)
    8001ee42:	ebb8                	sd	a4,80(a5)
        return count;
    8001ee44:	fdc42783          	lw	a5,-36(s0)
    8001ee48:	a83d                	j	8001ee86 <vfs_write+0xec>
    case VFS_TYPE_BLOCK:
        block_device_write_bytes(file->dev, file->offset, buf, (uint64_t)count);
    8001ee4a:	fe843783          	ld	a5,-24(s0)
    8001ee4e:	6398                	ld	a4,0(a5)
    8001ee50:	fe843783          	ld	a5,-24(s0)
    8001ee54:	6bbc                	ld	a5,80(a5)
    8001ee56:	85be                	mv	a1,a5
    8001ee58:	fdc42783          	lw	a5,-36(s0)
    8001ee5c:	86be                	mv	a3,a5
    8001ee5e:	fe043603          	ld	a2,-32(s0)
    8001ee62:	853a                	mv	a0,a4
    8001ee64:	d1bff0ef          	jal	ra,8001eb7e <block_device_write_bytes>
        file->offset += count;
    8001ee68:	fe843783          	ld	a5,-24(s0)
    8001ee6c:	6bb8                	ld	a4,80(a5)
    8001ee6e:	fdc42783          	lw	a5,-36(s0)
    8001ee72:	973e                	add	a4,a4,a5
    8001ee74:	fe843783          	ld	a5,-24(s0)
    8001ee78:	ebb8                	sd	a4,80(a5)
        return count;
    8001ee7a:	fdc42783          	lw	a5,-36(s0)
    8001ee7e:	a021                	j	8001ee86 <vfs_write+0xec>
    case VFS_TYPE_DIR:
        debugf("vfs_write: writing to directory not supported\n");
        return -1;
    8001ee80:	57fd                	li	a5,-1
    8001ee82:	a011                	j	8001ee86 <vfs_write+0xec>
    default:
        debugf("vfs_write: unsupported file type %d\n", file->type);
        return -1;
    8001ee84:	57fd                	li	a5,-1
    }
}
    8001ee86:	853e                	mv	a0,a5
    8001ee88:	70a2                	ld	ra,40(sp)
    8001ee8a:	7402                	ld	s0,32(sp)
    8001ee8c:	6145                	addi	sp,sp,48
    8001ee8e:	8082                	ret

000000008001ee90 <vfs_print_mounted_devices>:
// static Map *mapped_paths;

// // A map of inodes to file paths (absolute path strings)
// static Map *mapped_inodes;

void vfs_print_mounted_devices() {
    8001ee90:	7139                	addi	sp,sp,-64
    8001ee92:	fc06                	sd	ra,56(sp)
    8001ee94:	f822                	sd	s0,48(sp)
    8001ee96:	f426                	sd	s1,40(sp)
    8001ee98:	0080                	addi	s0,sp,64
    if (mounted_devices == NULL) {
    8001ee9a:	00006797          	auipc	a5,0x6
    8001ee9e:	73678793          	addi	a5,a5,1846 # 800255d0 <mounted_devices>
    8001eea2:	639c                	ld	a5,0(a5)
    8001eea4:	eb89                	bnez	a5,8001eeb6 <vfs_print_mounted_devices+0x26>
        mounted_devices = map_new();
    8001eea6:	060020ef          	jal	ra,80020f06 <map_new>
    8001eeaa:	872a                	mv	a4,a0
    8001eeac:	00006797          	auipc	a5,0x6
    8001eeb0:	72478793          	addi	a5,a5,1828 # 800255d0 <mounted_devices>
    8001eeb4:	e398                	sd	a4,0(a5)
    }

    List *keys = map_get_keys(mounted_devices);
    8001eeb6:	00006797          	auipc	a5,0x6
    8001eeba:	71a78793          	addi	a5,a5,1818 # 800255d0 <mounted_devices>
    8001eebe:	639c                	ld	a5,0(a5)
    8001eec0:	853e                	mv	a0,a5
    8001eec2:	4a0020ef          	jal	ra,80021362 <map_get_keys>
    8001eec6:	fca43423          	sd	a0,-56(s0)
    list_sort(keys, list_sort_string_comparator_ascending);
    8001eeca:	00002597          	auipc	a1,0x2
    8001eece:	b0c58593          	addi	a1,a1,-1268 # 800209d6 <list_sort_string_comparator_ascending>
    8001eed2:	fc843503          	ld	a0,-56(s0)
    8001eed6:	606010ef          	jal	ra,800204dc <list_sort>
    ListElem *key = NULL;
    8001eeda:	fc043c23          	sd	zero,-40(s0)
    size_t count = 0;
    8001eede:	fc043823          	sd	zero,-48(s0)
    infof("Printing mounted drives:\n");
    8001eee2:	0000a517          	auipc	a0,0xa
    8001eee6:	01e50513          	addi	a0,a0,30 # 80028f00 <pow10.0+0x20a0>
    8001eeea:	ffdfc0ef          	jal	ra,8001bee6 <infof>
    list_for_each(keys, key) {
    8001eeee:	fc843503          	ld	a0,-56(s0)
    8001eef2:	165010ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001eef6:	fca43c23          	sd	a0,-40(s0)
    8001eefa:	a8a1                	j	8001ef52 <vfs_print_mounted_devices+0xc2>
        VirtioDevice *block_device;
        map_get(mounted_devices, list_elem_value(key), &block_device);
    8001eefc:	00006797          	auipc	a5,0x6
    8001ef00:	6d478793          	addi	a5,a5,1748 # 800255d0 <mounted_devices>
    8001ef04:	6384                	ld	s1,0(a5)
    8001ef06:	fd843503          	ld	a0,-40(s0)
    8001ef0a:	1ad010ef          	jal	ra,800208b6 <list_elem_value>
    8001ef0e:	87aa                	mv	a5,a0
    8001ef10:	873e                	mv	a4,a5
    8001ef12:	fc040793          	addi	a5,s0,-64
    8001ef16:	863e                	mv	a2,a5
    8001ef18:	85ba                	mv	a1,a4
    8001ef1a:	8526                	mv	a0,s1
    8001ef1c:	132020ef          	jal	ra,8002104e <map_get>
        infof("    %s at disk #%u\n", list_elem_value(key), count);
    8001ef20:	fd843503          	ld	a0,-40(s0)
    8001ef24:	193010ef          	jal	ra,800208b6 <list_elem_value>
    8001ef28:	87aa                	mv	a5,a0
    8001ef2a:	fd043603          	ld	a2,-48(s0)
    8001ef2e:	85be                	mv	a1,a5
    8001ef30:	0000a517          	auipc	a0,0xa
    8001ef34:	ff050513          	addi	a0,a0,-16 # 80028f20 <pow10.0+0x20c0>
    8001ef38:	faffc0ef          	jal	ra,8001bee6 <infof>
        count++;
    8001ef3c:	fd043783          	ld	a5,-48(s0)
    8001ef40:	0785                	addi	a5,a5,1
    8001ef42:	fcf43823          	sd	a5,-48(s0)
    list_for_each(keys, key) {
    8001ef46:	fd843503          	ld	a0,-40(s0)
    8001ef4a:	155010ef          	jal	ra,8002089e <list_elem_prev>
    8001ef4e:	fca43c23          	sd	a0,-40(s0)
    8001ef52:	fd843583          	ld	a1,-40(s0)
    8001ef56:	fc843503          	ld	a0,-56(s0)
    8001ef5a:	06f010ef          	jal	ra,800207c8 <list_elem_valid>
    8001ef5e:	87aa                	mv	a5,a0
    8001ef60:	ffd1                	bnez	a5,8001eefc <vfs_print_mounted_devices+0x6c>
    }
    map_free_get_keys(keys);
    8001ef62:	fc843503          	ld	a0,-56(s0)
    8001ef66:	4a2020ef          	jal	ra,80021408 <map_free_get_keys>

    if (count == 0) {
    8001ef6a:	fd043783          	ld	a5,-48(s0)
    8001ef6e:	eb81                	bnez	a5,8001ef7e <vfs_print_mounted_devices+0xee>
        warnf("There are no mounted devices\n");
    8001ef70:	0000a517          	auipc	a0,0xa
    8001ef74:	fc850513          	addi	a0,a0,-56 # 80028f38 <pow10.0+0x20d8>
    8001ef78:	ec1fc0ef          	jal	ra,8001be38 <warnf>
    } else {
        infof("There are %u mounted drives\n", count);
    }
}
    8001ef7c:	a809                	j	8001ef8e <vfs_print_mounted_devices+0xfe>
        infof("There are %u mounted drives\n", count);
    8001ef7e:	fd043583          	ld	a1,-48(s0)
    8001ef82:	0000a517          	auipc	a0,0xa
    8001ef86:	fd650513          	addi	a0,a0,-42 # 80028f58 <pow10.0+0x20f8>
    8001ef8a:	f5dfc0ef          	jal	ra,8001bee6 <infof>
}
    8001ef8e:	0001                	nop
    8001ef90:	70e2                	ld	ra,56(sp)
    8001ef92:	7442                	ld	s0,48(sp)
    8001ef94:	74a2                	ld	s1,40(sp)
    8001ef96:	6121                	addi	sp,sp,64
    8001ef98:	8082                	ret

000000008001ef9a <vfs_path_from_mounted_device>:

const char *vfs_path_from_mounted_device(VirtioDevice *mounted_device) {
    8001ef9a:	711d                	addi	sp,sp,-96
    8001ef9c:	ec86                	sd	ra,88(sp)
    8001ef9e:	e8a2                	sd	s0,80(sp)
    8001efa0:	e4a6                	sd	s1,72(sp)
    8001efa2:	1080                	addi	s0,sp,96
    8001efa4:	faa43423          	sd	a0,-88(s0)
    if (mounted_devices == NULL) {
    8001efa8:	00006797          	auipc	a5,0x6
    8001efac:	62878793          	addi	a5,a5,1576 # 800255d0 <mounted_devices>
    8001efb0:	639c                	ld	a5,0(a5)
    8001efb2:	eb89                	bnez	a5,8001efc4 <vfs_path_from_mounted_device+0x2a>
        mounted_devices = map_new();
    8001efb4:	753010ef          	jal	ra,80020f06 <map_new>
    8001efb8:	872a                	mv	a4,a0
    8001efba:	00006797          	auipc	a5,0x6
    8001efbe:	61678793          	addi	a5,a5,1558 # 800255d0 <mounted_devices>
    8001efc2:	e398                	sd	a4,0(a5)
    }

    List *keys = map_get_keys(mounted_devices);
    8001efc4:	00006797          	auipc	a5,0x6
    8001efc8:	60c78793          	addi	a5,a5,1548 # 800255d0 <mounted_devices>
    8001efcc:	639c                	ld	a5,0(a5)
    8001efce:	853e                	mv	a0,a5
    8001efd0:	392020ef          	jal	ra,80021362 <map_get_keys>
    8001efd4:	fca43023          	sd	a0,-64(s0)
    list_sort(keys, list_sort_string_comparator_ascending);
    8001efd8:	00002597          	auipc	a1,0x2
    8001efdc:	9fe58593          	addi	a1,a1,-1538 # 800209d6 <list_sort_string_comparator_ascending>
    8001efe0:	fc043503          	ld	a0,-64(s0)
    8001efe4:	4f8010ef          	jal	ra,800204dc <list_sort>
    ListElem *key = NULL;
    8001efe8:	fc043c23          	sd	zero,-40(s0)
    size_t count = 1;
    8001efec:	4785                	li	a5,1
    8001efee:	fcf43823          	sd	a5,-48(s0)

    VirtioDevice *result;
    list_for_each(keys, key) {
    8001eff2:	fc043503          	ld	a0,-64(s0)
    8001eff6:	061010ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001effa:	fca43c23          	sd	a0,-40(s0)
    8001effe:	a899                	j	8001f054 <vfs_path_from_mounted_device+0xba>
        VirtioDevice *block_device;
        map_get(mounted_devices, list_elem_value(key), &block_device);
    8001f000:	00006797          	auipc	a5,0x6
    8001f004:	5d078793          	addi	a5,a5,1488 # 800255d0 <mounted_devices>
    8001f008:	6384                	ld	s1,0(a5)
    8001f00a:	fd843503          	ld	a0,-40(s0)
    8001f00e:	0a9010ef          	jal	ra,800208b6 <list_elem_value>
    8001f012:	87aa                	mv	a5,a0
    8001f014:	873e                	mv	a4,a5
    8001f016:	fb840793          	addi	a5,s0,-72
    8001f01a:	863e                	mv	a2,a5
    8001f01c:	85ba                	mv	a1,a4
    8001f01e:	8526                	mv	a0,s1
    8001f020:	02e020ef          	jal	ra,8002104e <map_get>
        if (block_device == mounted_device) {
    8001f024:	fb843783          	ld	a5,-72(s0)
    8001f028:	fa843703          	ld	a4,-88(s0)
    8001f02c:	00f71963          	bne	a4,a5,8001f03e <vfs_path_from_mounted_device+0xa4>
            result = list_elem_value(key);
    8001f030:	fd843503          	ld	a0,-40(s0)
    8001f034:	083010ef          	jal	ra,800208b6 <list_elem_value>
    8001f038:	87aa                	mv	a5,a0
    8001f03a:	fcf43423          	sd	a5,-56(s0)
        }
        count++;
    8001f03e:	fd043783          	ld	a5,-48(s0)
    8001f042:	0785                	addi	a5,a5,1
    8001f044:	fcf43823          	sd	a5,-48(s0)
    list_for_each(keys, key) {
    8001f048:	fd843503          	ld	a0,-40(s0)
    8001f04c:	053010ef          	jal	ra,8002089e <list_elem_prev>
    8001f050:	fca43c23          	sd	a0,-40(s0)
    8001f054:	fd843583          	ld	a1,-40(s0)
    8001f058:	fc043503          	ld	a0,-64(s0)
    8001f05c:	76c010ef          	jal	ra,800207c8 <list_elem_valid>
    8001f060:	87aa                	mv	a5,a0
    8001f062:	ffd9                	bnez	a5,8001f000 <vfs_path_from_mounted_device+0x66>
    }
    map_free_get_keys(keys);
    8001f064:	fc043503          	ld	a0,-64(s0)
    8001f068:	3a0020ef          	jal	ra,80021408 <map_free_get_keys>

    return result;
    8001f06c:	fc843783          	ld	a5,-56(s0)
}
    8001f070:	853e                	mv	a0,a5
    8001f072:	60e6                	ld	ra,88(sp)
    8001f074:	6446                	ld	s0,80(sp)
    8001f076:	64a6                	ld	s1,72(sp)
    8001f078:	6125                	addi	sp,sp,96
    8001f07a:	8082                	ret

000000008001f07c <vfs_print_open_files>:

void vfs_print_open_files() {
    8001f07c:	715d                	addi	sp,sp,-80
    8001f07e:	e486                	sd	ra,72(sp)
    8001f080:	e0a2                	sd	s0,64(sp)
    8001f082:	fc26                	sd	s1,56(sp)
    8001f084:	0880                	addi	s0,sp,80
    if (open_files == NULL) {
    8001f086:	00006797          	auipc	a5,0x6
    8001f08a:	53a78793          	addi	a5,a5,1338 # 800255c0 <open_files>
    8001f08e:	639c                	ld	a5,0(a5)
    8001f090:	eb89                	bnez	a5,8001f0a2 <vfs_print_open_files+0x26>
        open_files = map_new();
    8001f092:	675010ef          	jal	ra,80020f06 <map_new>
    8001f096:	872a                	mv	a4,a0
    8001f098:	00006797          	auipc	a5,0x6
    8001f09c:	52878793          	addi	a5,a5,1320 # 800255c0 <open_files>
    8001f0a0:	e398                	sd	a4,0(a5)
    }

    infof("Printing open files:\n");
    8001f0a2:	0000a517          	auipc	a0,0xa
    8001f0a6:	ed650513          	addi	a0,a0,-298 # 80028f78 <pow10.0+0x2118>
    8001f0aa:	e3dfc0ef          	jal	ra,8001bee6 <infof>
    List *keys = map_get_keys(open_files);
    8001f0ae:	00006797          	auipc	a5,0x6
    8001f0b2:	51278793          	addi	a5,a5,1298 # 800255c0 <open_files>
    8001f0b6:	639c                	ld	a5,0(a5)
    8001f0b8:	853e                	mv	a0,a5
    8001f0ba:	2a8020ef          	jal	ra,80021362 <map_get_keys>
    8001f0be:	fca43423          	sd	a0,-56(s0)
    ListElem *key = NULL;
    8001f0c2:	fc043c23          	sd	zero,-40(s0)
    size_t count = 0;
    8001f0c6:	fc043823          	sd	zero,-48(s0)
    list_for_each(keys, key) {
    8001f0ca:	fc843503          	ld	a0,-56(s0)
    8001f0ce:	788010ef          	jal	ra,80020856 <list_elem_start_ascending>
    8001f0d2:	fca43c23          	sd	a0,-40(s0)
    8001f0d6:	a0a5                	j	8001f13e <vfs_print_open_files+0xc2>
        File *file;
        map_get(open_files, list_elem_value(key), &file);
    8001f0d8:	00006797          	auipc	a5,0x6
    8001f0dc:	4e878793          	addi	a5,a5,1256 # 800255c0 <open_files>
    8001f0e0:	6384                	ld	s1,0(a5)
    8001f0e2:	fd843503          	ld	a0,-40(s0)
    8001f0e6:	7d0010ef          	jal	ra,800208b6 <list_elem_value>
    8001f0ea:	87aa                	mv	a5,a0
    8001f0ec:	873e                	mv	a4,a5
    8001f0ee:	fb840793          	addi	a5,s0,-72
    8001f0f2:	863e                	mv	a2,a5
    8001f0f4:	85ba                	mv	a1,a4
    8001f0f6:	8526                	mv	a0,s1
    8001f0f8:	757010ef          	jal	ra,8002104e <map_get>
        const char *device_name = vfs_path_from_mounted_device(file->dev);
    8001f0fc:	fb843783          	ld	a5,-72(s0)
    8001f100:	639c                	ld	a5,0(a5)
    8001f102:	853e                	mv	a0,a5
    8001f104:	e97ff0ef          	jal	ra,8001ef9a <vfs_path_from_mounted_device>
    8001f108:	fca43023          	sd	a0,-64(s0)
        infof("   %s on device %s\n", list_elem_value(key), device_name);
    8001f10c:	fd843503          	ld	a0,-40(s0)
    8001f110:	7a6010ef          	jal	ra,800208b6 <list_elem_value>
    8001f114:	87aa                	mv	a5,a0
    8001f116:	fc043603          	ld	a2,-64(s0)
    8001f11a:	85be                	mv	a1,a5
    8001f11c:	0000a517          	auipc	a0,0xa
    8001f120:	e7450513          	addi	a0,a0,-396 # 80028f90 <pow10.0+0x2130>
    8001f124:	dc3fc0ef          	jal	ra,8001bee6 <infof>
        count++;
    8001f128:	fd043783          	ld	a5,-48(s0)
    8001f12c:	0785                	addi	a5,a5,1
    8001f12e:	fcf43823          	sd	a5,-48(s0)
    list_for_each(keys, key) {
    8001f132:	fd843503          	ld	a0,-40(s0)
    8001f136:	768010ef          	jal	ra,8002089e <list_elem_prev>
    8001f13a:	fca43c23          	sd	a0,-40(s0)
    8001f13e:	fd843583          	ld	a1,-40(s0)
    8001f142:	fc843503          	ld	a0,-56(s0)
    8001f146:	682010ef          	jal	ra,800207c8 <list_elem_valid>
    8001f14a:	87aa                	mv	a5,a0
    8001f14c:	f7d1                	bnez	a5,8001f0d8 <vfs_print_open_files+0x5c>
    }
    map_free_get_keys(keys);
    8001f14e:	fc843503          	ld	a0,-56(s0)
    8001f152:	2b6020ef          	jal	ra,80021408 <map_free_get_keys>

    if (count == 0) {
    8001f156:	fd043783          	ld	a5,-48(s0)
    8001f15a:	eb81                	bnez	a5,8001f16a <vfs_print_open_files+0xee>
        infof("There are no open files\n");
    8001f15c:	0000a517          	auipc	a0,0xa
    8001f160:	e4c50513          	addi	a0,a0,-436 # 80028fa8 <pow10.0+0x2148>
    8001f164:	d83fc0ef          	jal	ra,8001bee6 <infof>
    } else {
        infof("There are %u open files\n", count);
    }
}
    8001f168:	a809                	j	8001f17a <vfs_print_open_files+0xfe>
        infof("There are %u open files\n", count);
    8001f16a:	fd043583          	ld	a1,-48(s0)
    8001f16e:	0000a517          	auipc	a0,0xa
    8001f172:	e5a50513          	addi	a0,a0,-422 # 80028fc8 <pow10.0+0x2168>
    8001f176:	d71fc0ef          	jal	ra,8001bee6 <infof>
}
    8001f17a:	0001                	nop
    8001f17c:	60a6                	ld	ra,72(sp)
    8001f17e:	6406                	ld	s0,64(sp)
    8001f180:	74e2                	ld	s1,56(sp)
    8001f182:	6161                	addi	sp,sp,80
    8001f184:	8082                	ret

000000008001f186 <vfs_mount_callback>:

void vfs_mount_callback(VirtioDevice *block_device, uint32_t inode, const char *path, char *name, void *data, uint32_t depth) {
    8001f186:	7119                	addi	sp,sp,-128
    8001f188:	fc86                	sd	ra,120(sp)
    8001f18a:	f8a2                	sd	s0,112(sp)
    8001f18c:	0100                	addi	s0,sp,128
    8001f18e:	faa43423          	sd	a0,-88(s0)
    8001f192:	f8c43c23          	sd	a2,-104(s0)
    8001f196:	f8d43823          	sd	a3,-112(s0)
    8001f19a:	f8e43423          	sd	a4,-120(s0)
    8001f19e:	873e                	mv	a4,a5
    8001f1a0:	87ae                	mv	a5,a1
    8001f1a2:	faf42223          	sw	a5,-92(s0)
    8001f1a6:	87ba                	mv	a5,a4
    8001f1a8:	faf42023          	sw	a5,-96(s0)
    if (strcmp(path, "/") == 0) {
    8001f1ac:	0000a597          	auipc	a1,0xa
    8001f1b0:	e3c58593          	addi	a1,a1,-452 # 80028fe8 <pow10.0+0x2188>
    8001f1b4:	f9843503          	ld	a0,-104(s0)
    8001f1b8:	514030ef          	jal	ra,800226cc <strcmp>
    8001f1bc:	87aa                	mv	a5,a0
    8001f1be:	c7a5                	beqz	a5,8001f226 <vfs_mount_callback+0xa0>
        debugf("vfs_mount_callback: skipping /\n");
        return;
    }

    // Check if this is a block device that needs to be mounted
    Inode inode_data = minix3_get_inode(block_device, inode);
    8001f1c0:	fb040793          	addi	a5,s0,-80
    8001f1c4:	fa442703          	lw	a4,-92(s0)
    8001f1c8:	863a                	mv	a2,a4
    8001f1ca:	fa843583          	ld	a1,-88(s0)
    8001f1ce:	853e                	mv	a0,a5
    8001f1d0:	bbaf90ef          	jal	ra,8001858a <minix3_get_inode>
    if (S_ISBLK(inode_data.mode)) {
    8001f1d4:	fb045783          	lhu	a5,-80(s0)
    8001f1d8:	0007871b          	sext.w	a4,a5
    8001f1dc:	67bd                	lui	a5,0xf
    8001f1de:	8ff9                	and	a5,a5,a4
    8001f1e0:	2781                	sext.w	a5,a5
    8001f1e2:	873e                	mv	a4,a5
    8001f1e4:	6799                	lui	a5,0x6
    8001f1e6:	04f71363          	bne	a4,a5,8001f22c <vfs_mount_callback+0xa6>
        debugf("vfs_mount_callback: found block device %s\n", path);
        // Mount the block device
        block_device = virtio_get_block_device(mounted_device_count);
    8001f1ea:	00006797          	auipc	a5,0x6
    8001f1ee:	3de78793          	addi	a5,a5,990 # 800255c8 <mounted_device_count>
    8001f1f2:	639c                	ld	a5,0(a5)
    8001f1f4:	17c2                	slli	a5,a5,0x30
    8001f1f6:	93c1                	srli	a5,a5,0x30
    8001f1f8:	853e                	mv	a0,a5
    8001f1fa:	b01fd0ef          	jal	ra,8001ccfa <virtio_get_block_device>
    8001f1fe:	faa43423          	sd	a0,-88(s0)
        if (block_device == NULL) {
    8001f202:	fa843783          	ld	a5,-88(s0)
    8001f206:	c395                	beqz	a5,8001f22a <vfs_mount_callback+0xa4>
            debugf("vfs_mount_callback: could not find block device %u\n", mounted_device_count);
            return;
        }
        infof("Mounting block device at %s\n", path);
    8001f208:	f9843583          	ld	a1,-104(s0)
    8001f20c:	0000a517          	auipc	a0,0xa
    8001f210:	de450513          	addi	a0,a0,-540 # 80028ff0 <pow10.0+0x2190>
    8001f214:	cd3fc0ef          	jal	ra,8001bee6 <infof>
        vfs_mount(block_device, path);
    8001f218:	f9843583          	ld	a1,-104(s0)
    8001f21c:	fa843503          	ld	a0,-88(s0)
    8001f220:	10e000ef          	jal	ra,8001f32e <vfs_mount>
    8001f224:	a021                	j	8001f22c <vfs_mount_callback+0xa6>
        return;
    8001f226:	0001                	nop
    8001f228:	a011                	j	8001f22c <vfs_mount_callback+0xa6>
            return;
    8001f22a:	0001                	nop
    }
}
    8001f22c:	70e6                	ld	ra,120(sp)
    8001f22e:	7446                	ld	s0,112(sp)
    8001f230:	6109                	addi	sp,sp,128
    8001f232:	8082                	ret

000000008001f234 <vfs_init>:

void vfs_init(void) {
    8001f234:	1101                	addi	sp,sp,-32
    8001f236:	ec06                	sd	ra,24(sp)
    8001f238:	e822                	sd	s0,16(sp)
    8001f23a:	1000                	addi	s0,sp,32
    mounted_devices = map_new();
    8001f23c:	4cb010ef          	jal	ra,80020f06 <map_new>
    8001f240:	872a                	mv	a4,a0
    8001f242:	00006797          	auipc	a5,0x6
    8001f246:	38e78793          	addi	a5,a5,910 # 800255d0 <mounted_devices>
    8001f24a:	e398                	sd	a4,0(a5)
    mounted_device_count = 0;
    8001f24c:	00006797          	auipc	a5,0x6
    8001f250:	37c78793          	addi	a5,a5,892 # 800255c8 <mounted_device_count>
    8001f254:	0007b023          	sd	zero,0(a5)
    VirtioDevice *block_device = virtio_get_block_device(0);
    8001f258:	4501                	li	a0,0
    8001f25a:	aa1fd0ef          	jal	ra,8001ccfa <virtio_get_block_device>
    8001f25e:	fea43423          	sd	a0,-24(s0)
    vfs_print_mounted_devices();
    8001f262:	c2fff0ef          	jal	ra,8001ee90 <vfs_print_mounted_devices>
    vfs_mount(block_device, "/");
    8001f266:	0000a597          	auipc	a1,0xa
    8001f26a:	d8258593          	addi	a1,a1,-638 # 80028fe8 <pow10.0+0x2188>
    8001f26e:	fe843503          	ld	a0,-24(s0)
    8001f272:	0bc000ef          	jal	ra,8001f32e <vfs_mount>
    
    minix3_traverse(block_device, 1, "/", NULL, 0, 10, vfs_mount_callback);
    8001f276:	00000817          	auipc	a6,0x0
    8001f27a:	f1080813          	addi	a6,a6,-240 # 8001f186 <vfs_mount_callback>
    8001f27e:	47a9                	li	a5,10
    8001f280:	4701                	li	a4,0
    8001f282:	4681                	li	a3,0
    8001f284:	0000a617          	auipc	a2,0xa
    8001f288:	d6460613          	addi	a2,a2,-668 # 80028fe8 <pow10.0+0x2188>
    8001f28c:	4585                	li	a1,1
    8001f28e:	fe843503          	ld	a0,-24(s0)
    8001f292:	959fb0ef          	jal	ra,8001abea <minix3_traverse>
    vfs_print_mounted_devices();
    8001f296:	bfbff0ef          	jal	ra,8001ee90 <vfs_print_mounted_devices>
    vfs_print_open_files();
    8001f29a:	de3ff0ef          	jal	ra,8001f07c <vfs_print_open_files>
    infof("vfs_init: mounted %u devices\n", mounted_device_count);
    8001f29e:	00006797          	auipc	a5,0x6
    8001f2a2:	32a78793          	addi	a5,a5,810 # 800255c8 <mounted_device_count>
    8001f2a6:	639c                	ld	a5,0(a5)
    8001f2a8:	85be                	mv	a1,a5
    8001f2aa:	0000a517          	auipc	a0,0xa
    8001f2ae:	d6650513          	addi	a0,a0,-666 # 80029010 <pow10.0+0x21b0>
    8001f2b2:	c35fc0ef          	jal	ra,8001bee6 <infof>
}
    8001f2b6:	0001                	nop
    8001f2b8:	60e2                	ld	ra,24(sp)
    8001f2ba:	6442                	ld	s0,16(sp)
    8001f2bc:	6105                	addi	sp,sp,32
    8001f2be:	8082                	ret

000000008001f2c0 <get_parent_path>:

char *get_parent_path(const char *path) {
    8001f2c0:	7179                	addi	sp,sp,-48
    8001f2c2:	f406                	sd	ra,40(sp)
    8001f2c4:	f022                	sd	s0,32(sp)
    8001f2c6:	1800                	addi	s0,sp,48
    8001f2c8:	fca43c23          	sd	a0,-40(s0)
    char *parent_path = kmalloc(strlen(path) + 1);
    8001f2cc:	fd843503          	ld	a0,-40(s0)
    8001f2d0:	6fa030ef          	jal	ra,800229ca <strlen>
    8001f2d4:	87aa                	mv	a5,a0
    8001f2d6:	0785                	addi	a5,a5,1
    8001f2d8:	853e                	mv	a0,a5
    8001f2da:	a58f60ef          	jal	ra,80015532 <kmalloc>
    8001f2de:	fea43423          	sd	a0,-24(s0)
    strcpy(parent_path, path);
    8001f2e2:	fd843583          	ld	a1,-40(s0)
    8001f2e6:	fe843503          	ld	a0,-24(s0)
    8001f2ea:	71e030ef          	jal	ra,80022a08 <strcpy>
    char *filename = path_file_name(parent_path);
    8001f2ee:	fe843503          	ld	a0,-24(s0)
    8001f2f2:	1e6020ef          	jal	ra,800214d8 <path_file_name>
    8001f2f6:	fea43023          	sd	a0,-32(s0)
    if (&filename[-1] == parent_path) {
    8001f2fa:	fe043783          	ld	a5,-32(s0)
    8001f2fe:	17fd                	addi	a5,a5,-1
    8001f300:	fe843703          	ld	a4,-24(s0)
    8001f304:	00f71963          	bne	a4,a5,8001f316 <get_parent_path+0x56>
        // We are at root
        filename[0] = '\0';
    8001f308:	fe043783          	ld	a5,-32(s0)
    8001f30c:	00078023          	sb	zero,0(a5)
        return parent_path;
    8001f310:	fe843783          	ld	a5,-24(s0)
    8001f314:	a801                	j	8001f324 <get_parent_path+0x64>
    }

    filename[-1] = '\0';
    8001f316:	fe043783          	ld	a5,-32(s0)
    8001f31a:	17fd                	addi	a5,a5,-1
    8001f31c:	00078023          	sb	zero,0(a5)
    return parent_path;
    8001f320:	fe843783          	ld	a5,-24(s0)
}
    8001f324:	853e                	mv	a0,a5
    8001f326:	70a2                	ld	ra,40(sp)
    8001f328:	7402                	ld	s0,32(sp)
    8001f32a:	6145                	addi	sp,sp,48
    8001f32c:	8082                	ret

000000008001f32e <vfs_mount>:

void vfs_mount(VirtioDevice *block_device, const char *path) {
    8001f32e:	7179                	addi	sp,sp,-48
    8001f330:	f406                	sd	ra,40(sp)
    8001f332:	f022                	sd	s0,32(sp)
    8001f334:	1800                	addi	s0,sp,48
    8001f336:	fca43c23          	sd	a0,-40(s0)
    8001f33a:	fcb43823          	sd	a1,-48(s0)
    minix3_init(block_device, path);
    8001f33e:	fd043583          	ld	a1,-48(s0)
    8001f342:	fd843503          	ld	a0,-40(s0)
    8001f346:	a4df80ef          	jal	ra,80017d92 <minix3_init>

    if (mounted_devices == NULL) {
    8001f34a:	00006797          	auipc	a5,0x6
    8001f34e:	28678793          	addi	a5,a5,646 # 800255d0 <mounted_devices>
    8001f352:	639c                	ld	a5,0(a5)
    8001f354:	eb89                	bnez	a5,8001f366 <vfs_mount+0x38>
        mounted_devices = map_new();
    8001f356:	3b1010ef          	jal	ra,80020f06 <map_new>
    8001f35a:	872a                	mv	a4,a0
    8001f35c:	00006797          	auipc	a5,0x6
    8001f360:	27478793          	addi	a5,a5,628 # 800255d0 <mounted_devices>
    8001f364:	e398                	sd	a4,0(a5)
    }

    char *block_device_path = kmalloc(strlen(path) + 1);
    8001f366:	fd043503          	ld	a0,-48(s0)
    8001f36a:	660030ef          	jal	ra,800229ca <strlen>
    8001f36e:	87aa                	mv	a5,a0
    8001f370:	0785                	addi	a5,a5,1
    8001f372:	853e                	mv	a0,a5
    8001f374:	9bef60ef          	jal	ra,80015532 <kmalloc>
    8001f378:	fea43423          	sd	a0,-24(s0)
    strcpy(block_device_path, path);
    8001f37c:	fd043583          	ld	a1,-48(s0)
    8001f380:	fe843503          	ld	a0,-24(s0)
    8001f384:	684030ef          	jal	ra,80022a08 <strcpy>
    
    map_set(mounted_devices, block_device_path, (uint64_t)block_device);
    8001f388:	00006797          	auipc	a5,0x6
    8001f38c:	24878793          	addi	a5,a5,584 # 800255d0 <mounted_devices>
    8001f390:	639c                	ld	a5,0(a5)
    8001f392:	fd843703          	ld	a4,-40(s0)
    8001f396:	863a                	mv	a2,a4
    8001f398:	fe843583          	ld	a1,-24(s0)
    8001f39c:	853e                	mv	a0,a5
    8001f39e:	3ef010ef          	jal	ra,80020f8c <map_set>
    debugf("vfs_mount: mounted (%p) %s at %s\n", block_device, block_device_path, path);
    mounted_device_count += 1;
    8001f3a2:	00006797          	auipc	a5,0x6
    8001f3a6:	22678793          	addi	a5,a5,550 # 800255c8 <mounted_device_count>
    8001f3aa:	639c                	ld	a5,0(a5)
    8001f3ac:	00178713          	addi	a4,a5,1
    8001f3b0:	00006797          	auipc	a5,0x6
    8001f3b4:	21878793          	addi	a5,a5,536 # 800255c8 <mounted_device_count>
    8001f3b8:	e398                	sd	a4,0(a5)

}
    8001f3ba:	0001                	nop
    8001f3bc:	70a2                	ld	ra,40(sp)
    8001f3be:	7402                	ld	s0,32(sp)
    8001f3c0:	6145                	addi	sp,sp,48
    8001f3c2:	8082                	ret

000000008001f3c4 <vfs_get_mounted_device>:

VirtioDevice *vfs_get_mounted_device(const char *path) {
    8001f3c4:	7139                	addi	sp,sp,-64
    8001f3c6:	fc06                	sd	ra,56(sp)
    8001f3c8:	f822                	sd	s0,48(sp)
    8001f3ca:	0080                	addi	s0,sp,64
    8001f3cc:	fca43423          	sd	a0,-56(s0)
    if (path == NULL) {
    8001f3d0:	fc843783          	ld	a5,-56(s0)
    8001f3d4:	e399                	bnez	a5,8001f3da <vfs_get_mounted_device+0x16>
        debugf("vfs_get_mounted_device: path is NULL\n");
        return NULL;
    8001f3d6:	4781                	li	a5,0
    8001f3d8:	a0fd                	j	8001f4c6 <vfs_get_mounted_device+0x102>
    }

    if (strlen(path) == 0 || strcmp(path, "") == 0) {
    8001f3da:	fc843503          	ld	a0,-56(s0)
    8001f3de:	5ec030ef          	jal	ra,800229ca <strlen>
    8001f3e2:	87aa                	mv	a5,a0
    8001f3e4:	cb99                	beqz	a5,8001f3fa <vfs_get_mounted_device+0x36>
    8001f3e6:	0000a597          	auipc	a1,0xa
    8001f3ea:	c4a58593          	addi	a1,a1,-950 # 80029030 <pow10.0+0x21d0>
    8001f3ee:	fc843503          	ld	a0,-56(s0)
    8001f3f2:	2da030ef          	jal	ra,800226cc <strcmp>
    8001f3f6:	87aa                	mv	a5,a0
    8001f3f8:	e399                	bnez	a5,8001f3fe <vfs_get_mounted_device+0x3a>
        debugf("vfs_get_mounted_device: path is empty\n");
        return NULL;
    8001f3fa:	4781                	li	a5,0
    8001f3fc:	a0e9                	j	8001f4c6 <vfs_get_mounted_device+0x102>
    }

    if (mounted_devices == NULL) {
    8001f3fe:	00006797          	auipc	a5,0x6
    8001f402:	1d278793          	addi	a5,a5,466 # 800255d0 <mounted_devices>
    8001f406:	639c                	ld	a5,0(a5)
    8001f408:	eb89                	bnez	a5,8001f41a <vfs_get_mounted_device+0x56>
        mounted_devices = map_new();
    8001f40a:	2fd010ef          	jal	ra,80020f06 <map_new>
    8001f40e:	872a                	mv	a4,a0
    8001f410:	00006797          	auipc	a5,0x6
    8001f414:	1c078793          	addi	a5,a5,448 # 800255d0 <mounted_devices>
    8001f418:	e398                	sd	a4,0(a5)
    }

    VirtioDevice *block_device = NULL;
    8001f41a:	fc043c23          	sd	zero,-40(s0)
    map_get(mounted_devices, path, &block_device);
    8001f41e:	00006797          	auipc	a5,0x6
    8001f422:	1b278793          	addi	a5,a5,434 # 800255d0 <mounted_devices>
    8001f426:	639c                	ld	a5,0(a5)
    8001f428:	fd840713          	addi	a4,s0,-40
    8001f42c:	863a                	mv	a2,a4
    8001f42e:	fc843583          	ld	a1,-56(s0)
    8001f432:	853e                	mv	a0,a5
    8001f434:	41b010ef          	jal	ra,8002104e <map_get>
    // map_get_int(mounted_devices, 0, &block_device);

    if (block_device == NULL) {
    8001f438:	fd843783          	ld	a5,-40(s0)
    8001f43c:	e3d9                	bnez	a5,8001f4c2 <vfs_get_mounted_device+0xfe>
        debugf("vfs_get_mounted_device: no device found for %s\n", path);
        if (strcmp(path, "/") == 0) {
    8001f43e:	0000a597          	auipc	a1,0xa
    8001f442:	baa58593          	addi	a1,a1,-1110 # 80028fe8 <pow10.0+0x2188>
    8001f446:	fc843503          	ld	a0,-56(s0)
    8001f44a:	282030ef          	jal	ra,800226cc <strcmp>
    8001f44e:	87aa                	mv	a5,a0
    8001f450:	e399                	bnez	a5,8001f456 <vfs_get_mounted_device+0x92>
            debugf("vfs_get_mounted_device: no device found for /\n");
            return NULL;
    8001f452:	4781                	li	a5,0
    8001f454:	a88d                	j	8001f4c6 <vfs_get_mounted_device+0x102>
        }

        // Get the parent path
        char *parent_path = kmalloc(strlen(path) + 1);
    8001f456:	fc843503          	ld	a0,-56(s0)
    8001f45a:	570030ef          	jal	ra,800229ca <strlen>
    8001f45e:	87aa                	mv	a5,a0
    8001f460:	0785                	addi	a5,a5,1
    8001f462:	853e                	mv	a0,a5
    8001f464:	8cef60ef          	jal	ra,80015532 <kmalloc>
    8001f468:	fea43423          	sd	a0,-24(s0)
        strcpy(parent_path, path);
    8001f46c:	fc843583          	ld	a1,-56(s0)
    8001f470:	fe843503          	ld	a0,-24(s0)
    8001f474:	594030ef          	jal	ra,80022a08 <strcpy>
        char *filename = path_file_name(parent_path);
    8001f478:	fe843503          	ld	a0,-24(s0)
    8001f47c:	05c020ef          	jal	ra,800214d8 <path_file_name>
    8001f480:	fea43023          	sd	a0,-32(s0)
        if (&filename[-1] == parent_path) {
    8001f484:	fe043783          	ld	a5,-32(s0)
    8001f488:	17fd                	addi	a5,a5,-1
    8001f48a:	fe843703          	ld	a4,-24(s0)
    8001f48e:	00f71a63          	bne	a4,a5,8001f4a2 <vfs_get_mounted_device+0xde>
            // We are at root
            debugf("vfs_get_mounted_device: we are at root\n");
            return vfs_get_mounted_device("/");
    8001f492:	0000a517          	auipc	a0,0xa
    8001f496:	b5650513          	addi	a0,a0,-1194 # 80028fe8 <pow10.0+0x2188>
    8001f49a:	f2bff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001f49e:	87aa                	mv	a5,a0
    8001f4a0:	a01d                	j	8001f4c6 <vfs_get_mounted_device+0x102>
        }

        filename[-1] = '\0';
    8001f4a2:	fe043783          	ld	a5,-32(s0)
    8001f4a6:	17fd                	addi	a5,a5,-1
    8001f4a8:	00078023          	sb	zero,0(a5)


        // Get the parent device
        debugf("vfs_get_mounted_device: getting parent device for %s\n", path);
        block_device = vfs_get_mounted_device(parent_path);
    8001f4ac:	fe843503          	ld	a0,-24(s0)
    8001f4b0:	f15ff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001f4b4:	87aa                	mv	a5,a0
    8001f4b6:	fcf43c23          	sd	a5,-40(s0)
        kfree(parent_path);
    8001f4ba:	fe843503          	ld	a0,-24(s0)
    8001f4be:	8bcf60ef          	jal	ra,8001557a <kfree>
    } else {
        debugf("vfs_get_mounted_device: found device for %s\n", path);
    }

    debugf("vfs_get_mounted_device: returning %p\n", block_device);
    return block_device;
    8001f4c2:	fd843783          	ld	a5,-40(s0)
}
    8001f4c6:	853e                	mv	a0,a5
    8001f4c8:	70e2                	ld	ra,56(sp)
    8001f4ca:	7442                	ld	s0,48(sp)
    8001f4cc:	6121                	addi	sp,sp,64
    8001f4ce:	8082                	ret

000000008001f4d0 <is_mounted_device>:

bool is_mounted_device(const char *path) {
    8001f4d0:	1101                	addi	sp,sp,-32
    8001f4d2:	ec06                	sd	ra,24(sp)
    8001f4d4:	e822                	sd	s0,16(sp)
    8001f4d6:	1000                	addi	s0,sp,32
    8001f4d8:	fea43423          	sd	a0,-24(s0)
    return map_contains(mounted_devices, path);
    8001f4dc:	00006797          	auipc	a5,0x6
    8001f4e0:	0f478793          	addi	a5,a5,244 # 800255d0 <mounted_devices>
    8001f4e4:	639c                	ld	a5,0(a5)
    8001f4e6:	fe843583          	ld	a1,-24(s0)
    8001f4ea:	853e                	mv	a0,a5
    8001f4ec:	3ed010ef          	jal	ra,800210d8 <map_contains>
    8001f4f0:	87aa                	mv	a5,a0
}
    8001f4f2:	853e                	mv	a0,a5
    8001f4f4:	60e2                	ld	ra,24(sp)
    8001f4f6:	6442                	ld	s0,16(sp)
    8001f4f8:	6105                	addi	sp,sp,32
    8001f4fa:	8082                	ret

000000008001f4fc <get_path_relative_to_mount_point>:

char *get_path_relative_to_mount_point(const char *path) {
    8001f4fc:	7139                	addi	sp,sp,-64
    8001f4fe:	fc06                	sd	ra,56(sp)
    8001f500:	f822                	sd	s0,48(sp)
    8001f502:	0080                	addi	s0,sp,64
    8001f504:	fca43423          	sd	a0,-56(s0)
    // vfs_get_mounted_device(path);
    if (path == NULL) {
    8001f508:	fc843783          	ld	a5,-56(s0)
    8001f50c:	e399                	bnez	a5,8001f512 <get_path_relative_to_mount_point+0x16>
        debugf("get_path_relative_to_mount_point: path is NULL\n");
        return NULL;
    8001f50e:	4781                	li	a5,0
    8001f510:	a299                	j	8001f656 <get_path_relative_to_mount_point+0x15a>
    }

    if (strlen(path) == 0 || strcmp(path, "") == 0) {
    8001f512:	fc843503          	ld	a0,-56(s0)
    8001f516:	4b4030ef          	jal	ra,800229ca <strlen>
    8001f51a:	87aa                	mv	a5,a0
    8001f51c:	cb99                	beqz	a5,8001f532 <get_path_relative_to_mount_point+0x36>
    8001f51e:	0000a597          	auipc	a1,0xa
    8001f522:	b1258593          	addi	a1,a1,-1262 # 80029030 <pow10.0+0x21d0>
    8001f526:	fc843503          	ld	a0,-56(s0)
    8001f52a:	1a2030ef          	jal	ra,800226cc <strcmp>
    8001f52e:	87aa                	mv	a5,a0
    8001f530:	e399                	bnez	a5,8001f536 <get_path_relative_to_mount_point+0x3a>
        debugf("get_path_relative_to_mount_point: path is empty\n");
        return NULL;
    8001f532:	4781                	li	a5,0
    8001f534:	a20d                	j	8001f656 <get_path_relative_to_mount_point+0x15a>
    }

    char *result = kmalloc(strlen(path) + 1);
    8001f536:	fc843503          	ld	a0,-56(s0)
    8001f53a:	490030ef          	jal	ra,800229ca <strlen>
    8001f53e:	87aa                	mv	a5,a0
    8001f540:	0785                	addi	a5,a5,1
    8001f542:	853e                	mv	a0,a5
    8001f544:	feff50ef          	jal	ra,80015532 <kmalloc>
    8001f548:	fea43023          	sd	a0,-32(s0)
    if (strcmp(path, "/") == 0) {
    8001f54c:	0000a597          	auipc	a1,0xa
    8001f550:	a9c58593          	addi	a1,a1,-1380 # 80028fe8 <pow10.0+0x2188>
    8001f554:	fc843503          	ld	a0,-56(s0)
    8001f558:	174030ef          	jal	ra,800226cc <strcmp>
    8001f55c:	87aa                	mv	a5,a0
    8001f55e:	ef81                	bnez	a5,8001f576 <get_path_relative_to_mount_point+0x7a>
        debugf("get_path_relative_to_mount_point: path is /\n");
        strcpy(result, "/");
    8001f560:	0000a597          	auipc	a1,0xa
    8001f564:	a8858593          	addi	a1,a1,-1400 # 80028fe8 <pow10.0+0x2188>
    8001f568:	fe043503          	ld	a0,-32(s0)
    8001f56c:	49c030ef          	jal	ra,80022a08 <strcpy>
        return result;
    8001f570:	fe043783          	ld	a5,-32(s0)
    8001f574:	a0cd                	j	8001f656 <get_path_relative_to_mount_point+0x15a>
    }


    if (is_mounted_device(path)) {
    8001f576:	fc843503          	ld	a0,-56(s0)
    8001f57a:	f57ff0ef          	jal	ra,8001f4d0 <is_mounted_device>
    8001f57e:	87aa                	mv	a5,a0
    8001f580:	cf81                	beqz	a5,8001f598 <get_path_relative_to_mount_point+0x9c>
        debugf("get_path_relative_to_mount_point: path is a mounted device\n");
        strcpy(result, "/");
    8001f582:	0000a597          	auipc	a1,0xa
    8001f586:	a6658593          	addi	a1,a1,-1434 # 80028fe8 <pow10.0+0x2188>
    8001f58a:	fe043503          	ld	a0,-32(s0)
    8001f58e:	47a030ef          	jal	ra,80022a08 <strcpy>
        return result;
    8001f592:	fe043783          	ld	a5,-32(s0)
    8001f596:	a0c1                	j	8001f656 <get_path_relative_to_mount_point+0x15a>
    } else {
        debugf("get_path_relative_to_mount_point: path is not a mounted device\n");
        char *parent_path = get_parent_path(path);
    8001f598:	fc843503          	ld	a0,-56(s0)
    8001f59c:	d25ff0ef          	jal	ra,8001f2c0 <get_parent_path>
    8001f5a0:	fea43423          	sd	a0,-24(s0)
        while (!is_mounted_device(parent_path)) {
    8001f5a4:	a089                	j	8001f5e6 <get_path_relative_to_mount_point+0xea>
            debugf("get_path_relative_to_mount_point: %s is not a mounted device\n", parent_path);
            char *parent_parent_path = get_parent_path(parent_path);
    8001f5a6:	fe843503          	ld	a0,-24(s0)
    8001f5aa:	d17ff0ef          	jal	ra,8001f2c0 <get_parent_path>
    8001f5ae:	fca43c23          	sd	a0,-40(s0)
            kfree(parent_path);
    8001f5b2:	fe843503          	ld	a0,-24(s0)
    8001f5b6:	fc5f50ef          	jal	ra,8001557a <kfree>
            parent_path = parent_parent_path;
    8001f5ba:	fd843783          	ld	a5,-40(s0)
    8001f5be:	fef43423          	sd	a5,-24(s0)

            if (strcmp(parent_path, "/") == 0 || strcmp(parent_path, "") == 0) {
    8001f5c2:	0000a597          	auipc	a1,0xa
    8001f5c6:	a2658593          	addi	a1,a1,-1498 # 80028fe8 <pow10.0+0x2188>
    8001f5ca:	fe843503          	ld	a0,-24(s0)
    8001f5ce:	0fe030ef          	jal	ra,800226cc <strcmp>
    8001f5d2:	87aa                	mv	a5,a0
    8001f5d4:	cb89                	beqz	a5,8001f5e6 <get_path_relative_to_mount_point+0xea>
    8001f5d6:	0000a597          	auipc	a1,0xa
    8001f5da:	a5a58593          	addi	a1,a1,-1446 # 80029030 <pow10.0+0x21d0>
    8001f5de:	fe843503          	ld	a0,-24(s0)
    8001f5e2:	0ea030ef          	jal	ra,800226cc <strcmp>
        while (!is_mounted_device(parent_path)) {
    8001f5e6:	fe843503          	ld	a0,-24(s0)
    8001f5ea:	ee7ff0ef          	jal	ra,8001f4d0 <is_mounted_device>
    8001f5ee:	87aa                	mv	a5,a0
    8001f5f0:	0017c793          	xori	a5,a5,1
    8001f5f4:	0ff7f793          	andi	a5,a5,255
    8001f5f8:	f7dd                	bnez	a5,8001f5a6 <get_path_relative_to_mount_point+0xaa>
                debugf("get_path_relative_to_mount_point: parent path is /\n");
            }
        }

        debugf("get_path_relative_to_mount_point: %s is a mounted device\n", parent_path);
        if (strcmp(parent_path, "/") == 0 || strcmp(parent_path, "") == 0) {
    8001f5fa:	0000a597          	auipc	a1,0xa
    8001f5fe:	9ee58593          	addi	a1,a1,-1554 # 80028fe8 <pow10.0+0x2188>
    8001f602:	fe843503          	ld	a0,-24(s0)
    8001f606:	0c6030ef          	jal	ra,800226cc <strcmp>
    8001f60a:	87aa                	mv	a5,a0
    8001f60c:	cb99                	beqz	a5,8001f622 <get_path_relative_to_mount_point+0x126>
    8001f60e:	0000a597          	auipc	a1,0xa
    8001f612:	a2258593          	addi	a1,a1,-1502 # 80029030 <pow10.0+0x21d0>
    8001f616:	fe843503          	ld	a0,-24(s0)
    8001f61a:	0b2030ef          	jal	ra,800226cc <strcmp>
    8001f61e:	87aa                	mv	a5,a0
    8001f620:	eb81                	bnez	a5,8001f630 <get_path_relative_to_mount_point+0x134>
            debugf("get_path_relative_to_mount_point: parent path is /\n");
            strcpy(result, path);
    8001f622:	fc843583          	ld	a1,-56(s0)
    8001f626:	fe043503          	ld	a0,-32(s0)
    8001f62a:	3de030ef          	jal	ra,80022a08 <strcpy>
    8001f62e:	a831                	j	8001f64a <get_path_relative_to_mount_point+0x14e>
        } else {
            strcpy(result, path + strlen(parent_path));
    8001f630:	fe843503          	ld	a0,-24(s0)
    8001f634:	396030ef          	jal	ra,800229ca <strlen>
    8001f638:	872a                	mv	a4,a0
    8001f63a:	fc843783          	ld	a5,-56(s0)
    8001f63e:	97ba                	add	a5,a5,a4
    8001f640:	85be                	mv	a1,a5
    8001f642:	fe043503          	ld	a0,-32(s0)
    8001f646:	3c2030ef          	jal	ra,80022a08 <strcpy>
        }
        kfree(parent_path);
    8001f64a:	fe843503          	ld	a0,-24(s0)
    8001f64e:	f2df50ef          	jal	ra,8001557a <kfree>
        return result;
    8001f652:	fe043783          	ld	a5,-32(s0)
    }
}
    8001f656:	853e                	mv	a0,a5
    8001f658:	70e2                	ld	ra,56(sp)
    8001f65a:	7442                	ld	s0,48(sp)
    8001f65c:	6121                	addi	sp,sp,64
    8001f65e:	8082                	ret

000000008001f660 <vfs_should_create_if_doesnt_exist>:

bool vfs_should_create_if_doesnt_exist(flags_t flags, mode_t mode, type_t type) {
    8001f660:	1101                	addi	sp,sp,-32
    8001f662:	ec22                	sd	s0,24(sp)
    8001f664:	1000                	addi	s0,sp,32
    8001f666:	fea43423          	sd	a0,-24(s0)
    8001f66a:	87ae                	mv	a5,a1
    8001f66c:	8732                	mv	a4,a2
    8001f66e:	fef41323          	sh	a5,-26(s0)
    8001f672:	87ba                	mv	a5,a4
    8001f674:	fef41223          	sh	a5,-28(s0)
    return flags & O_CREAT;
    8001f678:	fe843783          	ld	a5,-24(s0)
    8001f67c:	8ba1                	andi	a5,a5,8
    8001f67e:	00f037b3          	snez	a5,a5
    8001f682:	0ff7f793          	andi	a5,a5,255
}
    8001f686:	853e                	mv	a0,a5
    8001f688:	6462                	ld	s0,24(sp)
    8001f68a:	6105                	addi	sp,sp,32
    8001f68c:	8082                	ret

000000008001f68e <vfs_should_truncate>:

bool vfs_should_truncate(flags_t flags, mode_t mode, type_t type) {
    8001f68e:	1101                	addi	sp,sp,-32
    8001f690:	ec22                	sd	s0,24(sp)
    8001f692:	1000                	addi	s0,sp,32
    8001f694:	fea43423          	sd	a0,-24(s0)
    8001f698:	87ae                	mv	a5,a1
    8001f69a:	8732                	mv	a4,a2
    8001f69c:	fef41323          	sh	a5,-26(s0)
    8001f6a0:	87ba                	mv	a5,a4
    8001f6a2:	fef41223          	sh	a5,-28(s0)
    return flags & O_TRUNC;
    8001f6a6:	fe843783          	ld	a5,-24(s0)
    8001f6aa:	8bc1                	andi	a5,a5,16
    8001f6ac:	00f037b3          	snez	a5,a5
    8001f6b0:	0ff7f793          	andi	a5,a5,255
}
    8001f6b4:	853e                	mv	a0,a5
    8001f6b6:	6462                	ld	s0,24(sp)
    8001f6b8:	6105                	addi	sp,sp,32
    8001f6ba:	8082                	ret

000000008001f6bc <vfs_get_open_file>:

File *vfs_get_open_file(const char *path) {
    8001f6bc:	7179                	addi	sp,sp,-48
    8001f6be:	f406                	sd	ra,40(sp)
    8001f6c0:	f022                	sd	s0,32(sp)
    8001f6c2:	1800                	addi	s0,sp,48
    8001f6c4:	fca43c23          	sd	a0,-40(s0)
    if (open_files == NULL) {
    8001f6c8:	00006797          	auipc	a5,0x6
    8001f6cc:	ef878793          	addi	a5,a5,-264 # 800255c0 <open_files>
    8001f6d0:	639c                	ld	a5,0(a5)
    8001f6d2:	eb89                	bnez	a5,8001f6e4 <vfs_get_open_file+0x28>
        open_files = map_new();
    8001f6d4:	033010ef          	jal	ra,80020f06 <map_new>
    8001f6d8:	872a                	mv	a4,a0
    8001f6da:	00006797          	auipc	a5,0x6
    8001f6de:	ee678793          	addi	a5,a5,-282 # 800255c0 <open_files>
    8001f6e2:	e398                	sd	a4,0(a5)
    }
    if (!map_contains(open_files, path)) {
    8001f6e4:	00006797          	auipc	a5,0x6
    8001f6e8:	edc78793          	addi	a5,a5,-292 # 800255c0 <open_files>
    8001f6ec:	639c                	ld	a5,0(a5)
    8001f6ee:	fd843583          	ld	a1,-40(s0)
    8001f6f2:	853e                	mv	a0,a5
    8001f6f4:	1e5010ef          	jal	ra,800210d8 <map_contains>
    8001f6f8:	87aa                	mv	a5,a0
    8001f6fa:	0017c793          	xori	a5,a5,1
    8001f6fe:	0ff7f793          	andi	a5,a5,255
    8001f702:	c399                	beqz	a5,8001f708 <vfs_get_open_file+0x4c>
        debugf("vfs_get_open_file: file is not open\n");
        return NULL;
    8001f704:	4781                	li	a5,0
    8001f706:	a015                	j	8001f72a <vfs_get_open_file+0x6e>
    }

    File *file = NULL;
    8001f708:	fe043423          	sd	zero,-24(s0)
    map_get(open_files, path, &file);
    8001f70c:	00006797          	auipc	a5,0x6
    8001f710:	eb478793          	addi	a5,a5,-332 # 800255c0 <open_files>
    8001f714:	639c                	ld	a5,0(a5)
    8001f716:	fe840713          	addi	a4,s0,-24
    8001f71a:	863a                	mv	a2,a4
    8001f71c:	fd843583          	ld	a1,-40(s0)
    8001f720:	853e                	mv	a0,a5
    8001f722:	12d010ef          	jal	ra,8002104e <map_get>
    debugf("vfs_get_open_file: %s is %p\n", path, file);
    return file;
    8001f726:	fe843783          	ld	a5,-24(s0)
}
    8001f72a:	853e                	mv	a0,a5
    8001f72c:	70a2                	ld	ra,40(sp)
    8001f72e:	7402                	ld	s0,32(sp)
    8001f730:	6145                	addi	sp,sp,48
    8001f732:	8082                	ret

000000008001f734 <vfs_is_open>:

bool vfs_is_open(const char *path) {
    8001f734:	1101                	addi	sp,sp,-32
    8001f736:	ec06                	sd	ra,24(sp)
    8001f738:	e822                	sd	s0,16(sp)
    8001f73a:	1000                	addi	s0,sp,32
    8001f73c:	fea43423          	sd	a0,-24(s0)
    if (open_files == NULL) {
    8001f740:	00006797          	auipc	a5,0x6
    8001f744:	e8078793          	addi	a5,a5,-384 # 800255c0 <open_files>
    8001f748:	639c                	ld	a5,0(a5)
    8001f74a:	eb89                	bnez	a5,8001f75c <vfs_is_open+0x28>
        open_files = map_new();
    8001f74c:	7ba010ef          	jal	ra,80020f06 <map_new>
    8001f750:	872a                	mv	a4,a0
    8001f752:	00006797          	auipc	a5,0x6
    8001f756:	e6e78793          	addi	a5,a5,-402 # 800255c0 <open_files>
    8001f75a:	e398                	sd	a4,0(a5)
    }
    debugf("vfs_is_open: %s\n", path);

    return map_contains(open_files, path);
    8001f75c:	00006797          	auipc	a5,0x6
    8001f760:	e6478793          	addi	a5,a5,-412 # 800255c0 <open_files>
    8001f764:	639c                	ld	a5,0(a5)
    8001f766:	fe843583          	ld	a1,-24(s0)
    8001f76a:	853e                	mv	a0,a5
    8001f76c:	16d010ef          	jal	ra,800210d8 <map_contains>
    8001f770:	87aa                	mv	a5,a0
}
    8001f772:	853e                	mv	a0,a5
    8001f774:	60e2                	ld	ra,24(sp)
    8001f776:	6442                	ld	s0,16(sp)
    8001f778:	6105                	addi	sp,sp,32
    8001f77a:	8082                	ret

000000008001f77c <vfs_open>:

File *vfs_open(const char *path, flags_t flags, mode_t mode, type_t type) {
    8001f77c:	7125                	addi	sp,sp,-416
    8001f77e:	ef06                	sd	ra,408(sp)
    8001f780:	eb22                	sd	s0,400(sp)
    8001f782:	e726                	sd	s1,392(sp)
    8001f784:	1300                	addi	s0,sp,416
    8001f786:	eaa43c23          	sd	a0,-328(s0)
    8001f78a:	eab43823          	sd	a1,-336(s0)
    8001f78e:	87b2                	mv	a5,a2
    8001f790:	8736                	mv	a4,a3
    8001f792:	eaf41723          	sh	a5,-338(s0)
    8001f796:	87ba                	mv	a5,a4
    8001f798:	eaf41623          	sh	a5,-340(s0)
    debugf("vfs_open: opening %s\n", path);

    if (is_mounted_device(path)) {
    8001f79c:	eb843503          	ld	a0,-328(s0)
    8001f7a0:	d31ff0ef          	jal	ra,8001f4d0 <is_mounted_device>
    8001f7a4:	87aa                	mv	a5,a0
    8001f7a6:	14078363          	beqz	a5,8001f8ec <vfs_open+0x170>
        debugf("vfs_open: path is a mounted device\n");
        if (!vfs_is_open(path)) {
    8001f7aa:	eb843503          	ld	a0,-328(s0)
    8001f7ae:	f87ff0ef          	jal	ra,8001f734 <vfs_is_open>
    8001f7b2:	87aa                	mv	a5,a0
    8001f7b4:	0017c793          	xori	a5,a5,1
    8001f7b8:	0ff7f793          	andi	a5,a5,255
    8001f7bc:	12078663          	beqz	a5,8001f8e8 <vfs_open+0x16c>
            debugf("vfs_open: mounting device\n");
            VirtioDevice *block_device = vfs_get_mounted_device(path);
    8001f7c0:	eb843503          	ld	a0,-328(s0)
    8001f7c4:	c01ff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001f7c8:	f8a43823          	sd	a0,-112(s0)
            File *file = kmalloc(sizeof(File));
    8001f7cc:	08800513          	li	a0,136
    8001f7d0:	d63f50ef          	jal	ra,80015532 <kmalloc>
    8001f7d4:	f8a43423          	sd	a0,-120(s0)
            memset(file, 0, sizeof(File));
    8001f7d8:	08800613          	li	a2,136
    8001f7dc:	4581                	li	a1,0
    8001f7de:	f8843503          	ld	a0,-120(s0)
    8001f7e2:	25b020ef          	jal	ra,8002223c <memset>
            file->path = kmalloc(strlen(path) + 1);
    8001f7e6:	eb843503          	ld	a0,-328(s0)
    8001f7ea:	1e0030ef          	jal	ra,800229ca <strlen>
    8001f7ee:	87aa                	mv	a5,a0
    8001f7f0:	0785                	addi	a5,a5,1
    8001f7f2:	853e                	mv	a0,a5
    8001f7f4:	d3ff50ef          	jal	ra,80015532 <kmalloc>
    8001f7f8:	872a                	mv	a4,a0
    8001f7fa:	f8843783          	ld	a5,-120(s0)
    8001f7fe:	fbb8                	sd	a4,112(a5)
            strcpy(file->path, path);
    8001f800:	f8843783          	ld	a5,-120(s0)
    8001f804:	7bbc                	ld	a5,112(a5)
    8001f806:	eb843583          	ld	a1,-328(s0)
    8001f80a:	853e                	mv	a0,a5
    8001f80c:	1fc030ef          	jal	ra,80022a08 <strcpy>
            file->flags = flags;
    8001f810:	f8843783          	ld	a5,-120(s0)
    8001f814:	eb043703          	ld	a4,-336(s0)
    8001f818:	f7b8                	sd	a4,104(a5)
            file->mode = mode;
    8001f81a:	f8843783          	ld	a5,-120(s0)
    8001f81e:	eae45703          	lhu	a4,-338(s0)
    8001f822:	04e79c23          	sh	a4,88(a5)
            file->type = type;
    8001f826:	f8843783          	ld	a5,-120(s0)
    8001f82a:	eac45703          	lhu	a4,-340(s0)
    8001f82e:	00e79423          	sh	a4,8(a5)
            file->dev = block_device;
    8001f832:	f8843783          	ld	a5,-120(s0)
    8001f836:	f9043703          	ld	a4,-112(s0)
    8001f83a:	e398                	sd	a4,0(a5)
            file->inode = 1;
    8001f83c:	f8843783          	ld	a5,-120(s0)
    8001f840:	4705                	li	a4,1
    8001f842:	c7f8                	sw	a4,76(a5)
            file->inode_data = minix3_get_inode(block_device, file->inode);
    8001f844:	f8843783          	ld	a5,-120(s0)
    8001f848:	47f8                	lw	a4,76(a5)
    8001f84a:	f8843483          	ld	s1,-120(s0)
    8001f84e:	e6040793          	addi	a5,s0,-416
    8001f852:	863a                	mv	a2,a4
    8001f854:	f9043583          	ld	a1,-112(s0)
    8001f858:	853e                	mv	a0,a5
    8001f85a:	d31f80ef          	jal	ra,8001858a <minix3_get_inode>
    8001f85e:	00c48793          	addi	a5,s1,12
    8001f862:	e6040713          	addi	a4,s0,-416
    8001f866:	04000693          	li	a3,64
    8001f86a:	8636                	mv	a2,a3
    8001f86c:	85ba                	mv	a1,a4
    8001f86e:	853e                	mv	a0,a5
    8001f870:	2cf020ef          	jal	ra,8002233e <memcpy>
            file->size = file->inode_data.size;
    8001f874:	f8843783          	ld	a5,-120(s0)
    8001f878:	4bdc                	lw	a5,20(a5)
    8001f87a:	02079713          	slli	a4,a5,0x20
    8001f87e:	9301                	srli	a4,a4,0x20
    8001f880:	f8843783          	ld	a5,-120(s0)
    8001f884:	f3b8                	sd	a4,96(a5)
            file->is_dir = true;
    8001f886:	f8843783          	ld	a5,-120(s0)
    8001f88a:	4705                	li	a4,1
    8001f88c:	06e78c23          	sb	a4,120(a5)
            file->is_file = false;
    8001f890:	f8843783          	ld	a5,-120(s0)
    8001f894:	06078ca3          	sb	zero,121(a5)
            file->is_symlink = false;
    8001f898:	f8843783          	ld	a5,-120(s0)
    8001f89c:	06078d23          	sb	zero,122(a5)
            file->is_hardlink = false;
    8001f8a0:	f8843783          	ld	a5,-120(s0)
    8001f8a4:	06078da3          	sb	zero,123(a5)
            file->is_block_device = false;
    8001f8a8:	f8843783          	ld	a5,-120(s0)
    8001f8ac:	06078e23          	sb	zero,124(a5)
            file->is_char_device = false;
    8001f8b0:	f8843783          	ld	a5,-120(s0)
    8001f8b4:	06078ea3          	sb	zero,125(a5)
            file->major = 0;
    8001f8b8:	f8843783          	ld	a5,-120(s0)
    8001f8bc:	06079f23          	sh	zero,126(a5)
            file->minor = 0;
    8001f8c0:	f8843783          	ld	a5,-120(s0)
    8001f8c4:	08079023          	sh	zero,128(a5)
            map_set(open_files, path, file);
    8001f8c8:	00006797          	auipc	a5,0x6
    8001f8cc:	cf878793          	addi	a5,a5,-776 # 800255c0 <open_files>
    8001f8d0:	639c                	ld	a5,0(a5)
    8001f8d2:	f8843703          	ld	a4,-120(s0)
    8001f8d6:	863a                	mv	a2,a4
    8001f8d8:	eb843583          	ld	a1,-328(s0)
    8001f8dc:	853e                	mv	a0,a5
    8001f8de:	6ae010ef          	jal	ra,80020f8c <map_set>
            return file; 
    8001f8e2:	f8843783          	ld	a5,-120(s0)
    8001f8e6:	a565                	j	8001ff8e <vfs_open+0x812>
        }
        return NULL;
    8001f8e8:	4781                	li	a5,0
    8001f8ea:	a555                	j	8001ff8e <vfs_open+0x812>
    }

    if (path == NULL) {
    8001f8ec:	eb843783          	ld	a5,-328(s0)
    8001f8f0:	e399                	bnez	a5,8001f8f6 <vfs_open+0x17a>
        debugf("vfs_open: path is NULL\n");
        return NULL;
    8001f8f2:	4781                	li	a5,0
    8001f8f4:	ad69                	j	8001ff8e <vfs_open+0x812>
    }

    if (strlen(path) == 0 || strcmp(path, "") == 0) {
    8001f8f6:	eb843503          	ld	a0,-328(s0)
    8001f8fa:	0d0030ef          	jal	ra,800229ca <strlen>
    8001f8fe:	87aa                	mv	a5,a0
    8001f900:	cb99                	beqz	a5,8001f916 <vfs_open+0x19a>
    8001f902:	00009597          	auipc	a1,0x9
    8001f906:	72e58593          	addi	a1,a1,1838 # 80029030 <pow10.0+0x21d0>
    8001f90a:	eb843503          	ld	a0,-328(s0)
    8001f90e:	5bf020ef          	jal	ra,800226cc <strcmp>
    8001f912:	87aa                	mv	a5,a0
    8001f914:	e399                	bnez	a5,8001f91a <vfs_open+0x19e>
        debugf("vfs_open: path is empty\n");
        return NULL;
    8001f916:	4781                	li	a5,0
    8001f918:	ad9d                	j	8001ff8e <vfs_open+0x812>
    }

    if (open_files == NULL) {
    8001f91a:	00006797          	auipc	a5,0x6
    8001f91e:	ca678793          	addi	a5,a5,-858 # 800255c0 <open_files>
    8001f922:	639c                	ld	a5,0(a5)
    8001f924:	eb89                	bnez	a5,8001f936 <vfs_open+0x1ba>
        open_files = map_new();
    8001f926:	5e0010ef          	jal	ra,80020f06 <map_new>
    8001f92a:	872a                	mv	a4,a0
    8001f92c:	00006797          	auipc	a5,0x6
    8001f930:	c9478793          	addi	a5,a5,-876 # 800255c0 <open_files>
    8001f934:	e398                	sd	a4,0(a5)
    }

    if (map_contains(open_files, path)) {
    8001f936:	00006797          	auipc	a5,0x6
    8001f93a:	c8a78793          	addi	a5,a5,-886 # 800255c0 <open_files>
    8001f93e:	639c                	ld	a5,0(a5)
    8001f940:	eb843583          	ld	a1,-328(s0)
    8001f944:	853e                	mv	a0,a5
    8001f946:	792010ef          	jal	ra,800210d8 <map_contains>
    8001f94a:	87aa                	mv	a5,a0
    8001f94c:	c38d                	beqz	a5,8001f96e <vfs_open+0x1f2>
        debugf("vfs_open: file is already open\n");
        File *file;
        map_get(open_files, path, &file);
    8001f94e:	00006797          	auipc	a5,0x6
    8001f952:	c7278793          	addi	a5,a5,-910 # 800255c0 <open_files>
    8001f956:	639c                	ld	a5,0(a5)
    8001f958:	f4040713          	addi	a4,s0,-192
    8001f95c:	863a                	mv	a2,a4
    8001f95e:	eb843583          	ld	a1,-328(s0)
    8001f962:	853e                	mv	a0,a5
    8001f964:	6ea010ef          	jal	ra,8002104e <map_get>
        return file;
    8001f968:	f4043783          	ld	a5,-192(s0)
    8001f96c:	a50d                	j	8001ff8e <vfs_open+0x812>
    }


    File *file = kmalloc(sizeof(File));
    8001f96e:	08800513          	li	a0,136
    8001f972:	bc1f50ef          	jal	ra,80015532 <kmalloc>
    8001f976:	fca43823          	sd	a0,-48(s0)
    memset(file, 0, sizeof(File));
    8001f97a:	08800613          	li	a2,136
    8001f97e:	4581                	li	a1,0
    8001f980:	fd043503          	ld	a0,-48(s0)
    8001f984:	0b9020ef          	jal	ra,8002223c <memset>
    file->path = kmalloc(strlen(path) + 1);
    8001f988:	eb843503          	ld	a0,-328(s0)
    8001f98c:	03e030ef          	jal	ra,800229ca <strlen>
    8001f990:	87aa                	mv	a5,a0
    8001f992:	0785                	addi	a5,a5,1
    8001f994:	853e                	mv	a0,a5
    8001f996:	b9df50ef          	jal	ra,80015532 <kmalloc>
    8001f99a:	872a                	mv	a4,a0
    8001f99c:	fd043783          	ld	a5,-48(s0)
    8001f9a0:	fbb8                	sd	a4,112(a5)
    strcpy(file->path, path);
    8001f9a2:	fd043783          	ld	a5,-48(s0)
    8001f9a6:	7bbc                	ld	a5,112(a5)
    8001f9a8:	eb843583          	ld	a1,-328(s0)
    8001f9ac:	853e                	mv	a0,a5
    8001f9ae:	05a030ef          	jal	ra,80022a08 <strcpy>
    file->flags = flags;
    8001f9b2:	fd043783          	ld	a5,-48(s0)
    8001f9b6:	eb043703          	ld	a4,-336(s0)
    8001f9ba:	f7b8                	sd	a4,104(a5)
    file->mode = mode;
    8001f9bc:	fd043783          	ld	a5,-48(s0)
    8001f9c0:	eae45703          	lhu	a4,-338(s0)
    8001f9c4:	04e79c23          	sh	a4,88(a5)
    file->type = type;
    8001f9c8:	fd043783          	ld	a5,-48(s0)
    8001f9cc:	eac45703          	lhu	a4,-340(s0)
    8001f9d0:	00e79423          	sh	a4,8(a5)
    file->dev = vfs_get_mounted_device(path);
    8001f9d4:	eb843503          	ld	a0,-328(s0)
    8001f9d8:	9edff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001f9dc:	872a                	mv	a4,a0
    8001f9de:	fd043783          	ld	a5,-48(s0)
    8001f9e2:	e398                	sd	a4,0(a5)

    char *path_relative_to_mount_point;
    // debugf("vfs_open: %s relative to mount point is %s\n", path, path_relative_to_mount_point);
    VirtioDevice *parent_device = vfs_get_mounted_device(path);
    8001f9e4:	eb843503          	ld	a0,-328(s0)
    8001f9e8:	9ddff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001f9ec:	fca43423          	sd	a0,-56(s0)
    debugf("vfs_open: parent device is %p\n", parent_device);
    char *block_device_name = path_file_name(path);
    8001f9f0:	eb843503          	ld	a0,-328(s0)
    8001f9f4:	2e5010ef          	jal	ra,800214d8 <path_file_name>
    8001f9f8:	fca43023          	sd	a0,-64(s0)
    uint32_t block_device_num = mounted_device_count;
    8001f9fc:	00006797          	auipc	a5,0x6
    8001fa00:	bcc78793          	addi	a5,a5,-1076 # 800255c8 <mounted_device_count>
    8001fa04:	639c                	ld	a5,0(a5)
    8001fa06:	faf42e23          	sw	a5,-68(s0)
    char *parent_path = get_parent_path(path);
    8001fa0a:	eb843503          	ld	a0,-328(s0)
    8001fa0e:	8b3ff0ef          	jal	ra,8001f2c0 <get_parent_path>
    8001fa12:	faa43823          	sd	a0,-80(s0)
    debugf("vfs_open: parent path is %s\n", parent_path);
    DirEntry dir_entry;
    size_t i = 0;
    8001fa16:	fa043423          	sd	zero,-88(s0)
    uint32_t free_dir_entry = 0;
    8001fa1a:	fa042223          	sw	zero,-92(s0)
    uint32_t parent_inode = 0;
    8001fa1e:	fa042023          	sw	zero,-96(s0)

    bool is_parent_open = vfs_is_open(parent_path);
    8001fa22:	fb043503          	ld	a0,-80(s0)
    8001fa26:	d0fff0ef          	jal	ra,8001f734 <vfs_is_open>
    8001fa2a:	87aa                	mv	a5,a0
    8001fa2c:	f8f40fa3          	sb	a5,-97(s0)
    debugf("vfs_open: parent is open: %u\n", is_parent_open);
    switch (type) {
    8001fa30:	eac45783          	lhu	a5,-340(s0)
    8001fa34:	2781                	sext.w	a5,a5
    8001fa36:	86be                	mv	a3,a5
    8001fa38:	4741                	li	a4,16
    8001fa3a:	24e68e63          	beq	a3,a4,8001fc96 <vfs_open+0x51a>
    8001fa3e:	86be                	mv	a3,a5
    8001fa40:	4741                	li	a4,16
    8001fa42:	4ed74763          	blt	a4,a3,8001ff30 <vfs_open+0x7b4>
    8001fa46:	86be                	mv	a3,a5
    8001fa48:	4709                	li	a4,2
    8001fa4a:	1ce68063          	beq	a3,a4,8001fc0a <vfs_open+0x48e>
    8001fa4e:	86be                	mv	a3,a5
    8001fa50:	4709                	li	a4,2
    8001fa52:	4cd74f63          	blt	a4,a3,8001ff30 <vfs_open+0x7b4>
    8001fa56:	c791                	beqz	a5,8001fa62 <vfs_open+0x2e6>
    8001fa58:	873e                	mv	a4,a5
    8001fa5a:	4785                	li	a5,1
    8001fa5c:	0cf70463          	beq	a4,a5,8001fb24 <vfs_open+0x3a8>
    8001fa60:	a9c1                	j	8001ff30 <vfs_open+0x7b4>
    case VFS_TYPE_INFER:
        // Infer the type from the minix3 type
        file->dev = vfs_get_mounted_device(path);
    8001fa62:	eb843503          	ld	a0,-328(s0)
    8001fa66:	95fff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001fa6a:	872a                	mv	a4,a0
    8001fa6c:	fd043783          	ld	a5,-48(s0)
    8001fa70:	e398                	sd	a4,0(a5)
        file->inode = minix3_get_inode_from_path(file->dev, file->path, false);
    8001fa72:	fd043783          	ld	a5,-48(s0)
    8001fa76:	6398                	ld	a4,0(a5)
    8001fa78:	fd043783          	ld	a5,-48(s0)
    8001fa7c:	7bbc                	ld	a5,112(a5)
    8001fa7e:	4601                	li	a2,0
    8001fa80:	85be                	mv	a1,a5
    8001fa82:	853a                	mv	a0,a4
    8001fa84:	b3ff70ef          	jal	ra,800175c2 <minix3_get_inode_from_path>
    8001fa88:	87aa                	mv	a5,a0
    8001fa8a:	0007871b          	sext.w	a4,a5
    8001fa8e:	fd043783          	ld	a5,-48(s0)
    8001fa92:	c7f8                	sw	a4,76(a5)
        // file->inode_data = minix3_get_inode(file->dev, file->inode);
        // file->size = file->inode_data.size;

        // kfree(path_relative_to_mount_point);
        kfree(parent_path);
    8001fa94:	fb043503          	ld	a0,-80(s0)
    8001fa98:	ae3f50ef          	jal	ra,8001557a <kfree>
        if (minix3_is_file(file->dev, file->inode)) {
    8001fa9c:	fd043783          	ld	a5,-48(s0)
    8001faa0:	6398                	ld	a4,0(a5)
    8001faa2:	fd043783          	ld	a5,-48(s0)
    8001faa6:	47fc                	lw	a5,76(a5)
    8001faa8:	85be                	mv	a1,a5
    8001faaa:	853a                	mv	a0,a4
    8001faac:	e81f80ef          	jal	ra,8001892c <minix3_is_file>
    8001fab0:	87aa                	mv	a5,a0
    8001fab2:	c789                	beqz	a5,8001fabc <vfs_open+0x340>
            debugf("vfs_open: %s is a file\n", path);
            type = VFS_TYPE_FILE;
    8001fab4:	4785                	li	a5,1
    8001fab6:	eaf41623          	sh	a5,-340(s0)
    8001faba:	a0b9                	j	8001fb08 <vfs_open+0x38c>
        } else if (minix3_is_dir(file->dev, file->inode)) {
    8001fabc:	fd043783          	ld	a5,-48(s0)
    8001fac0:	6398                	ld	a4,0(a5)
    8001fac2:	fd043783          	ld	a5,-48(s0)
    8001fac6:	47fc                	lw	a5,76(a5)
    8001fac8:	85be                	mv	a1,a5
    8001faca:	853a                	mv	a0,a4
    8001facc:	df1f80ef          	jal	ra,800188bc <minix3_is_dir>
    8001fad0:	87aa                	mv	a5,a0
    8001fad2:	c789                	beqz	a5,8001fadc <vfs_open+0x360>
            debugf("vfs_open: %s is a dir\n", path);
            type = VFS_TYPE_DIR;
    8001fad4:	4789                	li	a5,2
    8001fad6:	eaf41623          	sh	a5,-340(s0)
    8001fada:	a03d                	j	8001fb08 <vfs_open+0x38c>
        } else if (minix3_is_block_device(file->dev, file->inode)) {
    8001fadc:	fd043783          	ld	a5,-48(s0)
    8001fae0:	6398                	ld	a4,0(a5)
    8001fae2:	fd043783          	ld	a5,-48(s0)
    8001fae6:	47fc                	lw	a5,76(a5)
    8001fae8:	85be                	mv	a1,a5
    8001faea:	853a                	mv	a0,a4
    8001faec:	eb1f80ef          	jal	ra,8001899c <minix3_is_block_device>
    8001faf0:	87aa                	mv	a5,a0
    8001faf2:	c789                	beqz	a5,8001fafc <vfs_open+0x380>
            debugf("vfs_open: %s is a block device\n", path);
            type = VFS_TYPE_BLOCK;
    8001faf4:	47c1                	li	a5,16
    8001faf6:	eaf41623          	sh	a5,-340(s0)
    8001fafa:	a039                	j	8001fb08 <vfs_open+0x38c>
        } else {
            debugf("vfs_open: could not infer type\n");
            kfree(file);
    8001fafc:	fd043503          	ld	a0,-48(s0)
    8001fb00:	a7bf50ef          	jal	ra,8001557a <kfree>
            return NULL;
    8001fb04:	4781                	li	a5,0
    8001fb06:	a161                	j	8001ff8e <vfs_open+0x812>
        }
        return vfs_open(path, flags, mode, type);
    8001fb08:	eac45703          	lhu	a4,-340(s0)
    8001fb0c:	eae45783          	lhu	a5,-338(s0)
    8001fb10:	86ba                	mv	a3,a4
    8001fb12:	863e                	mv	a2,a5
    8001fb14:	eb043583          	ld	a1,-336(s0)
    8001fb18:	eb843503          	ld	a0,-328(s0)
    8001fb1c:	c61ff0ef          	jal	ra,8001f77c <vfs_open>
    8001fb20:	87aa                	mv	a5,a0
    8001fb22:	a1b5                	j	8001ff8e <vfs_open+0x812>
        break;

    case VFS_TYPE_FILE:
        debugf("vfs_open: opening file\n");
        if (vfs_is_open(path)) {
    8001fb24:	eb843503          	ld	a0,-328(s0)
    8001fb28:	c0dff0ef          	jal	ra,8001f734 <vfs_is_open>
    8001fb2c:	87aa                	mv	a5,a0
    8001fb2e:	c799                	beqz	a5,8001fb3c <vfs_open+0x3c0>
            debugf("vfs_open: file is already open\n");
            return vfs_get_open_file(path);
    8001fb30:	eb843503          	ld	a0,-328(s0)
    8001fb34:	b89ff0ef          	jal	ra,8001f6bc <vfs_get_open_file>
    8001fb38:	87aa                	mv	a5,a0
    8001fb3a:	a991                	j	8001ff8e <vfs_open+0x812>
        }
        if (!is_parent_open) {
    8001fb3c:	f9f44783          	lbu	a5,-97(s0)
    8001fb40:	0017c793          	xori	a5,a5,1
    8001fb44:	0ff7f793          	andi	a5,a5,255
    8001fb48:	cb99                	beqz	a5,8001fb5e <vfs_open+0x3e2>
            debugf("vfs_open: parent is not open\n");
            vfs_open(parent_path, flags, mode, VFS_TYPE_INFER);
    8001fb4a:	eae45783          	lhu	a5,-338(s0)
    8001fb4e:	4681                	li	a3,0
    8001fb50:	863e                	mv	a2,a5
    8001fb52:	eb043583          	ld	a1,-336(s0)
    8001fb56:	fb043503          	ld	a0,-80(s0)
    8001fb5a:	c23ff0ef          	jal	ra,8001f77c <vfs_open>
            //     debugf("vfs_open: could not open parent %s\n", parent_path);
            //     return NULL;
            // }
        }

        file->dev = vfs_get_mounted_device(path);
    8001fb5e:	eb843503          	ld	a0,-328(s0)
    8001fb62:	863ff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001fb66:	872a                	mv	a4,a0
    8001fb68:	fd043783          	ld	a5,-48(s0)
    8001fb6c:	e398                	sd	a4,0(a5)
        path_relative_to_mount_point = get_path_relative_to_mount_point(path);
    8001fb6e:	eb843503          	ld	a0,-328(s0)
    8001fb72:	98bff0ef          	jal	ra,8001f4fc <get_path_relative_to_mount_point>
    8001fb76:	fca43c23          	sd	a0,-40(s0)
        debugf("vfs_open: device is %p\n", file->dev);
        file->inode = minix3_get_inode_from_path(file->dev, path_relative_to_mount_point, false);
    8001fb7a:	fd043783          	ld	a5,-48(s0)
    8001fb7e:	639c                	ld	a5,0(a5)
    8001fb80:	4601                	li	a2,0
    8001fb82:	fd843583          	ld	a1,-40(s0)
    8001fb86:	853e                	mv	a0,a5
    8001fb88:	a3bf70ef          	jal	ra,800175c2 <minix3_get_inode_from_path>
    8001fb8c:	87aa                	mv	a5,a0
    8001fb8e:	0007871b          	sext.w	a4,a5
    8001fb92:	fd043783          	ld	a5,-48(s0)
    8001fb96:	c7f8                	sw	a4,76(a5)
        file->inode_data = minix3_get_inode(file->dev, file->inode);
    8001fb98:	fd043783          	ld	a5,-48(s0)
    8001fb9c:	6398                	ld	a4,0(a5)
    8001fb9e:	fd043783          	ld	a5,-48(s0)
    8001fba2:	47f4                	lw	a3,76(a5)
    8001fba4:	fd043483          	ld	s1,-48(s0)
    8001fba8:	e6040793          	addi	a5,s0,-416
    8001fbac:	8636                	mv	a2,a3
    8001fbae:	85ba                	mv	a1,a4
    8001fbb0:	853e                	mv	a0,a5
    8001fbb2:	9d9f80ef          	jal	ra,8001858a <minix3_get_inode>
    8001fbb6:	00c48793          	addi	a5,s1,12
    8001fbba:	e6040713          	addi	a4,s0,-416
    8001fbbe:	04000693          	li	a3,64
    8001fbc2:	8636                	mv	a2,a3
    8001fbc4:	85ba                	mv	a1,a4
    8001fbc6:	853e                	mv	a0,a5
    8001fbc8:	776020ef          	jal	ra,8002233e <memcpy>
        file->size = file->inode_data.size;
    8001fbcc:	fd043783          	ld	a5,-48(s0)
    8001fbd0:	4bdc                	lw	a5,20(a5)
    8001fbd2:	02079713          	slli	a4,a5,0x20
    8001fbd6:	9301                	srli	a4,a4,0x20
    8001fbd8:	fd043783          	ld	a5,-48(s0)
    8001fbdc:	f3b8                	sd	a4,96(a5)
        file->is_file = true;
    8001fbde:	fd043783          	ld	a5,-48(s0)
    8001fbe2:	4705                	li	a4,1
    8001fbe4:	06e78ca3          	sb	a4,121(a5)

        if (!is_parent_open) {
    8001fbe8:	f9f44783          	lbu	a5,-97(s0)
    8001fbec:	0017c793          	xori	a5,a5,1
    8001fbf0:	0ff7f793          	andi	a5,a5,255
    8001fbf4:	32078d63          	beqz	a5,8001ff2e <vfs_open+0x7b2>
            debugf("vfs_open: closing parent %s\n", parent_path);
            vfs_close(vfs_get_open_file(parent_path));
    8001fbf8:	fb043503          	ld	a0,-80(s0)
    8001fbfc:	ac1ff0ef          	jal	ra,8001f6bc <vfs_get_open_file>
    8001fc00:	87aa                	mv	a5,a0
    8001fc02:	853e                	mv	a0,a5
    8001fc04:	396000ef          	jal	ra,8001ff9a <vfs_close>
        }

        break;
    8001fc08:	a61d                	j	8001ff2e <vfs_open+0x7b2>

    case VFS_TYPE_DIR:
        file->dev = vfs_get_mounted_device(path);
    8001fc0a:	eb843503          	ld	a0,-328(s0)
    8001fc0e:	fb6ff0ef          	jal	ra,8001f3c4 <vfs_get_mounted_device>
    8001fc12:	872a                	mv	a4,a0
    8001fc14:	fd043783          	ld	a5,-48(s0)
    8001fc18:	e398                	sd	a4,0(a5)
        path_relative_to_mount_point = get_path_relative_to_mount_point(path);
    8001fc1a:	eb843503          	ld	a0,-328(s0)
    8001fc1e:	8dfff0ef          	jal	ra,8001f4fc <get_path_relative_to_mount_point>
    8001fc22:	fca43c23          	sd	a0,-40(s0)
        file->inode = minix3_get_inode_from_path(file->dev, path_relative_to_mount_point, false);
    8001fc26:	fd043783          	ld	a5,-48(s0)
    8001fc2a:	639c                	ld	a5,0(a5)
    8001fc2c:	4601                	li	a2,0
    8001fc2e:	fd843583          	ld	a1,-40(s0)
    8001fc32:	853e                	mv	a0,a5
    8001fc34:	98ff70ef          	jal	ra,800175c2 <minix3_get_inode_from_path>
    8001fc38:	87aa                	mv	a5,a0
    8001fc3a:	0007871b          	sext.w	a4,a5
    8001fc3e:	fd043783          	ld	a5,-48(s0)
    8001fc42:	c7f8                	sw	a4,76(a5)
        file->inode_data = minix3_get_inode(file->dev, file->inode);
    8001fc44:	fd043783          	ld	a5,-48(s0)
    8001fc48:	6398                	ld	a4,0(a5)
    8001fc4a:	fd043783          	ld	a5,-48(s0)
    8001fc4e:	47f4                	lw	a3,76(a5)
    8001fc50:	fd043483          	ld	s1,-48(s0)
    8001fc54:	e6040793          	addi	a5,s0,-416
    8001fc58:	8636                	mv	a2,a3
    8001fc5a:	85ba                	mv	a1,a4
    8001fc5c:	853e                	mv	a0,a5
    8001fc5e:	92df80ef          	jal	ra,8001858a <minix3_get_inode>
    8001fc62:	00c48793          	addi	a5,s1,12
    8001fc66:	e6040713          	addi	a4,s0,-416
    8001fc6a:	04000693          	li	a3,64
    8001fc6e:	8636                	mv	a2,a3
    8001fc70:	85ba                	mv	a1,a4
    8001fc72:	853e                	mv	a0,a5
    8001fc74:	6ca020ef          	jal	ra,8002233e <memcpy>
        file->size = file->inode_data.size;
    8001fc78:	fd043783          	ld	a5,-48(s0)
    8001fc7c:	4bdc                	lw	a5,20(a5)
    8001fc7e:	02079713          	slli	a4,a5,0x20
    8001fc82:	9301                	srli	a4,a4,0x20
    8001fc84:	fd043783          	ld	a5,-48(s0)
    8001fc88:	f3b8                	sd	a4,96(a5)
        file->is_dir = true;
    8001fc8a:	fd043783          	ld	a5,-48(s0)
    8001fc8e:	4705                	li	a4,1
    8001fc90:	06e78c23          	sb	a4,120(a5)
        break;
    8001fc94:	ac71                	j	8001ff30 <vfs_open+0x7b4>
    
    case VFS_TYPE_BLOCK:
        // Read the filename
        debugf("vfs_open: block device name is %s\n", block_device_name);
        path_relative_to_mount_point = get_path_relative_to_mount_point(path);
    8001fc96:	eb843503          	ld	a0,-328(s0)
    8001fc9a:	863ff0ef          	jal	ra,8001f4fc <get_path_relative_to_mount_point>
    8001fc9e:	fca43c23          	sd	a0,-40(s0)

        // Get the number of the block device
        debugf("vfs_open: block device number is %u\n", block_device_num);
        file->inode = minix3_get_inode_from_path(parent_device, path_relative_to_mount_point, false);
    8001fca2:	4601                	li	a2,0
    8001fca4:	fd843583          	ld	a1,-40(s0)
    8001fca8:	fc843503          	ld	a0,-56(s0)
    8001fcac:	917f70ef          	jal	ra,800175c2 <minix3_get_inode_from_path>
    8001fcb0:	87aa                	mv	a5,a0
    8001fcb2:	0007871b          	sext.w	a4,a5
    8001fcb6:	fd043783          	ld	a5,-48(s0)
    8001fcba:	c7f8                	sw	a4,76(a5)
        debugf("vfs_open: inode is %u\n", file->inode);

        if (file->inode == 0 && vfs_should_create_if_doesnt_exist(flags, mode, type)) {
    8001fcbc:	fd043783          	ld	a5,-48(s0)
    8001fcc0:	47fc                	lw	a5,76(a5)
    8001fcc2:	20079563          	bnez	a5,8001fecc <vfs_open+0x750>
    8001fcc6:	eac45703          	lhu	a4,-340(s0)
    8001fcca:	eae45783          	lhu	a5,-338(s0)
    8001fcce:	863a                	mv	a2,a4
    8001fcd0:	85be                	mv	a1,a5
    8001fcd2:	eb043503          	ld	a0,-336(s0)
    8001fcd6:	98bff0ef          	jal	ra,8001f660 <vfs_should_create_if_doesnt_exist>
    8001fcda:	87aa                	mv	a5,a0
    8001fcdc:	1e078863          	beqz	a5,8001fecc <vfs_open+0x750>
            debugf("vfs_open: creating block device\n");
            debugf("vfs_open: parent device is %p\n", parent_device);
            // Create the block device
            file->inode = minix3_alloc_inode(parent_device);
    8001fce0:	fc843503          	ld	a0,-56(s0)
    8001fce4:	a8ff80ef          	jal	ra,80018772 <minix3_alloc_inode>
    8001fce8:	87aa                	mv	a5,a0
    8001fcea:	0007871b          	sext.w	a4,a5
    8001fcee:	fd043783          	ld	a5,-48(s0)
    8001fcf2:	c7f8                	sw	a4,76(a5)
            debugf("vfs_open: created block device with inode %u\n", file->inode);
            file->inode_data = minix3_get_inode(parent_device, file->inode);
    8001fcf4:	fd043783          	ld	a5,-48(s0)
    8001fcf8:	47f8                	lw	a4,76(a5)
    8001fcfa:	fd043483          	ld	s1,-48(s0)
    8001fcfe:	e6040793          	addi	a5,s0,-416
    8001fd02:	863a                	mv	a2,a4
    8001fd04:	fc843583          	ld	a1,-56(s0)
    8001fd08:	853e                	mv	a0,a5
    8001fd0a:	881f80ef          	jal	ra,8001858a <minix3_get_inode>
    8001fd0e:	00c48793          	addi	a5,s1,12
    8001fd12:	e6040713          	addi	a4,s0,-416
    8001fd16:	04000693          	li	a3,64
    8001fd1a:	8636                	mv	a2,a3
    8001fd1c:	85ba                	mv	a1,a4
    8001fd1e:	853e                	mv	a0,a5
    8001fd20:	61e020ef          	jal	ra,8002233e <memcpy>
            file->inode_data.mode = S_IFBLK;
    8001fd24:	fd043783          	ld	a5,-48(s0)
    8001fd28:	6719                	lui	a4,0x6
    8001fd2a:	00e79623          	sh	a4,12(a5)
            file->inode_data.num_links = 1;
    8001fd2e:	fd043783          	ld	a5,-48(s0)
    8001fd32:	4705                	li	a4,1
    8001fd34:	00e79723          	sh	a4,14(a5)
            file->inode_data.uid = 0;
    8001fd38:	fd043783          	ld	a5,-48(s0)
    8001fd3c:	00079823          	sh	zero,16(a5)
            file->inode_data.gid = 0;
    8001fd40:	fd043783          	ld	a5,-48(s0)
    8001fd44:	00079923          	sh	zero,18(a5)
            file->inode_data.size = 0;
    8001fd48:	fd043783          	ld	a5,-48(s0)
    8001fd4c:	0007aa23          	sw	zero,20(a5)
            file->inode_data.atime = 0;
    8001fd50:	fd043783          	ld	a5,-48(s0)
    8001fd54:	0007ac23          	sw	zero,24(a5)
            file->inode_data.mtime = 0;
    8001fd58:	fd043783          	ld	a5,-48(s0)
    8001fd5c:	0007ae23          	sw	zero,28(a5)
            file->inode_data.ctime = 0;
    8001fd60:	fd043783          	ld	a5,-48(s0)
    8001fd64:	0207a023          	sw	zero,32(a5)
            minix3_put_inode(parent_device, file->inode, file->inode_data);
    8001fd68:	fd043783          	ld	a5,-48(s0)
    8001fd6c:	47e4                	lw	s1,76(a5)
    8001fd6e:	fd043783          	ld	a5,-48(s0)
    8001fd72:	e6040713          	addi	a4,s0,-416
    8001fd76:	07b1                	addi	a5,a5,12
    8001fd78:	04000693          	li	a3,64
    8001fd7c:	8636                	mv	a2,a3
    8001fd7e:	85be                	mv	a1,a5
    8001fd80:	853a                	mv	a0,a4
    8001fd82:	5bc020ef          	jal	ra,8002233e <memcpy>
    8001fd86:	e6040793          	addi	a5,s0,-416
    8001fd8a:	863e                	mv	a2,a5
    8001fd8c:	85a6                	mv	a1,s1
    8001fd8e:	fc843503          	ld	a0,-56(s0)
    8001fd92:	945f80ef          	jal	ra,800186d6 <minix3_put_inode>
            debugf("vfs_open: put inode\n");

            parent_inode = minix3_get_inode_from_path(parent_device, path_relative_to_mount_point, true);
    8001fd96:	4605                	li	a2,1
    8001fd98:	fd843583          	ld	a1,-40(s0)
    8001fd9c:	fc843503          	ld	a0,-56(s0)
    8001fda0:	823f70ef          	jal	ra,800175c2 <minix3_get_inode_from_path>
    8001fda4:	87aa                	mv	a5,a0
    8001fda6:	faf42023          	sw	a5,-96(s0)
            debugf("vfs_open: parent inode is %u\n", parent_inode);

            // Create the directory entry
            DirEntry dir_entry;
            memset(&dir_entry, 0, sizeof(dir_entry));
    8001fdaa:	ec040793          	addi	a5,s0,-320
    8001fdae:	04000613          	li	a2,64
    8001fdb2:	4581                	li	a1,0
    8001fdb4:	853e                	mv	a0,a5
    8001fdb6:	486020ef          	jal	ra,8002223c <memset>
            dir_entry.inode = file->inode;
    8001fdba:	fd043783          	ld	a5,-48(s0)
    8001fdbe:	47fc                	lw	a5,76(a5)
    8001fdc0:	ecf42023          	sw	a5,-320(s0)
            strcpy(dir_entry.name, block_device_name);
    8001fdc4:	ec040793          	addi	a5,s0,-320
    8001fdc8:	0791                	addi	a5,a5,4
    8001fdca:	fc043583          	ld	a1,-64(s0)
    8001fdce:	853e                	mv	a0,a5
    8001fdd0:	439020ef          	jal	ra,80022a08 <strcpy>
            debugf("vfs_open: created dir entry with inode %u and name %s\n", dir_entry.inode, dir_entry.name);

            // Find the next free directory entry
            free_dir_entry = minix3_find_next_free_dir_entry(parent_device, parent_inode);
    8001fdd4:	fa042783          	lw	a5,-96(s0)
    8001fdd8:	85be                	mv	a1,a5
    8001fdda:	fc843503          	ld	a0,-56(s0)
    8001fdde:	989fa0ef          	jal	ra,8001a766 <minix3_find_next_free_dir_entry>
    8001fde2:	87aa                	mv	a5,a0
    8001fde4:	faf42223          	sw	a5,-92(s0)
            debugf("vfs_open: found free dir entry %u\n", free_dir_entry);

            // Put the directory entry
            minix3_put_dir_entry(parent_device, parent_inode, free_dir_entry, dir_entry);
    8001fde8:	ec043883          	ld	a7,-320(s0)
    8001fdec:	ec843803          	ld	a6,-312(s0)
    8001fdf0:	ed043503          	ld	a0,-304(s0)
    8001fdf4:	ed843583          	ld	a1,-296(s0)
    8001fdf8:	ee043603          	ld	a2,-288(s0)
    8001fdfc:	ee843683          	ld	a3,-280(s0)
    8001fe00:	ef043703          	ld	a4,-272(s0)
    8001fe04:	ef843783          	ld	a5,-264(s0)
    8001fe08:	e7143023          	sd	a7,-416(s0)
    8001fe0c:	e7043423          	sd	a6,-408(s0)
    8001fe10:	e6a43823          	sd	a0,-400(s0)
    8001fe14:	e6b43c23          	sd	a1,-392(s0)
    8001fe18:	e8c43023          	sd	a2,-384(s0)
    8001fe1c:	e8d43423          	sd	a3,-376(s0)
    8001fe20:	e8e43823          	sd	a4,-368(s0)
    8001fe24:	e8f43c23          	sd	a5,-360(s0)
    8001fe28:	e6040693          	addi	a3,s0,-416
    8001fe2c:	fa442703          	lw	a4,-92(s0)
    8001fe30:	fa042783          	lw	a5,-96(s0)
    8001fe34:	863a                	mv	a2,a4
    8001fe36:	85be                	mv	a1,a5
    8001fe38:	fc843503          	ld	a0,-56(s0)
    8001fe3c:	aabfa0ef          	jal	ra,8001a8e6 <minix3_put_dir_entry>
            debugf("vfs_open: put dir entry\n");

            // Create the inode
            Inode inode_data;
            memset(&inode_data, 0, sizeof(inode_data));
    8001fe40:	f0040793          	addi	a5,s0,-256
    8001fe44:	04000613          	li	a2,64
    8001fe48:	4581                	li	a1,0
    8001fe4a:	853e                	mv	a0,a5
    8001fe4c:	3f0020ef          	jal	ra,8002223c <memset>
            inode_data.mode = S_IFBLK;
    8001fe50:	6799                	lui	a5,0x6
    8001fe52:	f0f41023          	sh	a5,-256(s0)
            inode_data.num_links = 1;
    8001fe56:	4785                	li	a5,1
    8001fe58:	f0f41123          	sh	a5,-254(s0)
            inode_data.uid = 0;
    8001fe5c:	f0041223          	sh	zero,-252(s0)
            inode_data.gid = 0;
    8001fe60:	f0041323          	sh	zero,-250(s0)
            inode_data.size = 0;
    8001fe64:	f0042423          	sw	zero,-248(s0)
            inode_data.atime = 0;
    8001fe68:	f0042623          	sw	zero,-244(s0)
            inode_data.mtime = 0;
    8001fe6c:	f0042823          	sw	zero,-240(s0)
            inode_data.ctime = 0;
    8001fe70:	f0042a23          	sw	zero,-236(s0)
            minix3_put_inode(parent_device, file->inode, inode_data);
    8001fe74:	fd043783          	ld	a5,-48(s0)
    8001fe78:	04c7a303          	lw	t1,76(a5) # 604c <i+0x602c>
    8001fe7c:	f0043883          	ld	a7,-256(s0)
    8001fe80:	f0843803          	ld	a6,-248(s0)
    8001fe84:	f1043503          	ld	a0,-240(s0)
    8001fe88:	f1843583          	ld	a1,-232(s0)
    8001fe8c:	f2043603          	ld	a2,-224(s0)
    8001fe90:	f2843683          	ld	a3,-216(s0)
    8001fe94:	f3043703          	ld	a4,-208(s0)
    8001fe98:	f3843783          	ld	a5,-200(s0)
    8001fe9c:	e7143023          	sd	a7,-416(s0)
    8001fea0:	e7043423          	sd	a6,-408(s0)
    8001fea4:	e6a43823          	sd	a0,-400(s0)
    8001fea8:	e6b43c23          	sd	a1,-392(s0)
    8001feac:	e8c43023          	sd	a2,-384(s0)
    8001feb0:	e8d43423          	sd	a3,-376(s0)
    8001feb4:	e8e43823          	sd	a4,-368(s0)
    8001feb8:	e8f43c23          	sd	a5,-360(s0)
    8001febc:	e6040793          	addi	a5,s0,-416
    8001fec0:	863e                	mv	a2,a5
    8001fec2:	859a                	mv	a1,t1
    8001fec4:	fc843503          	ld	a0,-56(s0)
    8001fec8:	80ff80ef          	jal	ra,800186d6 <minix3_put_inode>
        } else {
            debugf("vfs_open: not creating block device\n");
        }

        // Get the block device
        file->dev = virtio_get_block_device(block_device_num);
    8001fecc:	fbc42783          	lw	a5,-68(s0)
    8001fed0:	17c2                	slli	a5,a5,0x30
    8001fed2:	93c1                	srli	a5,a5,0x30
    8001fed4:	853e                	mv	a0,a5
    8001fed6:	e25fc0ef          	jal	ra,8001ccfa <virtio_get_block_device>
    8001feda:	872a                	mv	a4,a0
    8001fedc:	fd043783          	ld	a5,-48(s0)
    8001fee0:	e398                	sd	a4,0(a5)
        
        if (file->dev == NULL) {
    8001fee2:	fd043783          	ld	a5,-48(s0)
    8001fee6:	639c                	ld	a5,0(a5)
    8001fee8:	eb99                	bnez	a5,8001fefe <vfs_open+0x782>
            debugf("vfs_open: could not find block device\n");
            kfree(path_relative_to_mount_point);
    8001feea:	fd843503          	ld	a0,-40(s0)
    8001feee:	e8cf50ef          	jal	ra,8001557a <kfree>
            kfree(parent_path);
    8001fef2:	fb043503          	ld	a0,-80(s0)
    8001fef6:	e84f50ef          	jal	ra,8001557a <kfree>
            return NULL;
    8001fefa:	4781                	li	a5,0
    8001fefc:	a849                	j	8001ff8e <vfs_open+0x812>
        //     debugf("vfs_open: not a block device\n");
        //     debugf("vfs_open: mode is %x\n", file->inode_data.mode);
        //     return NULL;
        // }

        file->size = block_device_get_bytes(file->dev);
    8001fefe:	fd043783          	ld	a5,-48(s0)
    8001ff02:	639c                	ld	a5,0(a5)
    8001ff04:	853e                	mv	a0,a5
    8001ff06:	87dfe0ef          	jal	ra,8001e782 <block_device_get_bytes>
    8001ff0a:	872a                	mv	a4,a0
    8001ff0c:	fd043783          	ld	a5,-48(s0)
    8001ff10:	f3b8                	sd	a4,96(a5)
        file->is_block_device = true;
    8001ff12:	fd043783          	ld	a5,-48(s0)
    8001ff16:	4705                	li	a4,1
    8001ff18:	06e78e23          	sb	a4,124(a5)
        vfs_mount(file->dev, path);
    8001ff1c:	fd043783          	ld	a5,-48(s0)
    8001ff20:	639c                	ld	a5,0(a5)
    8001ff22:	eb843583          	ld	a1,-328(s0)
    8001ff26:	853e                	mv	a0,a5
    8001ff28:	c06ff0ef          	jal	ra,8001f32e <vfs_mount>
        break;
    8001ff2c:	a011                	j	8001ff30 <vfs_open+0x7b4>
        break;
    8001ff2e:	0001                	nop
    }
    kfree(path_relative_to_mount_point);
    8001ff30:	fd843503          	ld	a0,-40(s0)
    8001ff34:	e46f50ef          	jal	ra,8001557a <kfree>
    kfree(parent_path);
    8001ff38:	fb043503          	ld	a0,-80(s0)
    8001ff3c:	e3ef50ef          	jal	ra,8001557a <kfree>

    // Insert the file into the open files map
    map_set(open_files, path, file);
    8001ff40:	00005797          	auipc	a5,0x5
    8001ff44:	68078793          	addi	a5,a5,1664 # 800255c0 <open_files>
    8001ff48:	639c                	ld	a5,0(a5)
    8001ff4a:	fd043703          	ld	a4,-48(s0)
    8001ff4e:	863a                	mv	a2,a4
    8001ff50:	eb843583          	ld	a1,-328(s0)
    8001ff54:	853e                	mv	a0,a5
    8001ff56:	036010ef          	jal	ra,80020f8c <map_set>
    if (!map_contains(open_files, path)) {
    8001ff5a:	00005797          	auipc	a5,0x5
    8001ff5e:	66678793          	addi	a5,a5,1638 # 800255c0 <open_files>
    8001ff62:	639c                	ld	a5,0(a5)
    8001ff64:	eb843583          	ld	a1,-328(s0)
    8001ff68:	853e                	mv	a0,a5
    8001ff6a:	16e010ef          	jal	ra,800210d8 <map_contains>
    8001ff6e:	87aa                	mv	a5,a0
    8001ff70:	0017c793          	xori	a5,a5,1
    8001ff74:	0ff7f793          	andi	a5,a5,255
    8001ff78:	c399                	beqz	a5,8001ff7e <vfs_open+0x802>
        debugf("vfs_open: could not insert file into open files map\n");
        return NULL;
    8001ff7a:	4781                	li	a5,0
    8001ff7c:	a809                	j	8001ff8e <vfs_open+0x812>
    }

    // debugf("vfs_open: %d files open\n", map_size(open_files));
    debug_file(file);
    8001ff7e:	fd043503          	ld	a0,-48(s0)
    8001ff82:	d11fe0ef          	jal	ra,8001ec92 <debug_file>
    vfs_print_open_files();
    8001ff86:	8f6ff0ef          	jal	ra,8001f07c <vfs_print_open_files>
    return file;
    8001ff8a:	fd043783          	ld	a5,-48(s0)
}
    8001ff8e:	853e                	mv	a0,a5
    8001ff90:	60fa                	ld	ra,408(sp)
    8001ff92:	645a                	ld	s0,400(sp)
    8001ff94:	64ba                	ld	s1,392(sp)
    8001ff96:	611d                	addi	sp,sp,416
    8001ff98:	8082                	ret

000000008001ff9a <vfs_close>:

void vfs_close(File *file) {
    8001ff9a:	1101                	addi	sp,sp,-32
    8001ff9c:	ec06                	sd	ra,24(sp)
    8001ff9e:	e822                	sd	s0,16(sp)
    8001ffa0:	1000                	addi	s0,sp,32
    8001ffa2:	fea43423          	sd	a0,-24(s0)
    debugf("vfs_close: closing %s\n", file->path);
    if (open_files == NULL) {
    8001ffa6:	00005797          	auipc	a5,0x5
    8001ffaa:	61a78793          	addi	a5,a5,1562 # 800255c0 <open_files>
    8001ffae:	639c                	ld	a5,0(a5)
    8001ffb0:	eb89                	bnez	a5,8001ffc2 <vfs_close+0x28>
        open_files = map_new();
    8001ffb2:	755000ef          	jal	ra,80020f06 <map_new>
    8001ffb6:	872a                	mv	a4,a0
    8001ffb8:	00005797          	auipc	a5,0x5
    8001ffbc:	60878793          	addi	a5,a5,1544 # 800255c0 <open_files>
    8001ffc0:	e398                	sd	a4,0(a5)
    }
    if (!map_contains(open_files, file->path)) {
    8001ffc2:	00005797          	auipc	a5,0x5
    8001ffc6:	5fe78793          	addi	a5,a5,1534 # 800255c0 <open_files>
    8001ffca:	6398                	ld	a4,0(a5)
    8001ffcc:	fe843783          	ld	a5,-24(s0)
    8001ffd0:	7bbc                	ld	a5,112(a5)
    8001ffd2:	85be                	mv	a1,a5
    8001ffd4:	853a                	mv	a0,a4
    8001ffd6:	102010ef          	jal	ra,800210d8 <map_contains>
    8001ffda:	87aa                	mv	a5,a0
    8001ffdc:	0017c793          	xori	a5,a5,1
    8001ffe0:	0ff7f793          	andi	a5,a5,255
    8001ffe4:	eb95                	bnez	a5,80020018 <vfs_close+0x7e>
        debugf("vfs_close: file is not open\n");
        return;
    }
    // Remove the file from the open files map
    map_remove(open_files, file->path);
    8001ffe6:	00005797          	auipc	a5,0x5
    8001ffea:	5da78793          	addi	a5,a5,1498 # 800255c0 <open_files>
    8001ffee:	6398                	ld	a4,0(a5)
    8001fff0:	fe843783          	ld	a5,-24(s0)
    8001fff4:	7bbc                	ld	a5,112(a5)
    8001fff6:	85be                	mv	a1,a5
    8001fff8:	853a                	mv	a0,a4
    8001fffa:	132010ef          	jal	ra,8002112c <map_remove>
    // debug_file(file);
    vfs_print_open_files();
    8001fffe:	87eff0ef          	jal	ra,8001f07c <vfs_print_open_files>
    kfree(file->path);
    80020002:	fe843783          	ld	a5,-24(s0)
    80020006:	7bbc                	ld	a5,112(a5)
    80020008:	853e                	mv	a0,a5
    8002000a:	d70f50ef          	jal	ra,8001557a <kfree>
    kfree(file);
    8002000e:	fe843503          	ld	a0,-24(s0)
    80020012:	d68f50ef          	jal	ra,8001557a <kfree>
    80020016:	a011                	j	8002001a <vfs_close+0x80>
        return;
    80020018:	0001                	nop
}
    8002001a:	60e2                	ld	ra,24(sp)
    8002001c:	6442                	ld	s0,16(sp)
    8002001e:	6105                	addi	sp,sp,32
    80020020:	8082                	ret

0000000080020022 <vfs_stat>:
//     infof("Mapping %s to %u\n", path, inode);
//     map_set(mapped_paths, path, inode);
//     map_set_int(mapped_inodes, inode, (uintptr_t)path);
// }

int vfs_stat(File *file, Stat *stat) {
    80020022:	7159                	addi	sp,sp,-112
    80020024:	f486                	sd	ra,104(sp)
    80020026:	f0a2                	sd	s0,96(sp)
    80020028:	1880                	addi	s0,sp,112
    8002002a:	f8a43c23          	sd	a0,-104(s0)
    8002002e:	f8b43823          	sd	a1,-112(s0)
    VirtioDevice *block_device = file->dev;
    80020032:	f9843783          	ld	a5,-104(s0)
    80020036:	639c                	ld	a5,0(a5)
    80020038:	fef43423          	sd	a5,-24(s0)
    Inode data = minix3_get_inode(block_device, file->inode);
    8002003c:	f9843783          	ld	a5,-104(s0)
    80020040:	47f8                	lw	a4,76(a5)
    80020042:	fa840793          	addi	a5,s0,-88
    80020046:	863a                	mv	a2,a4
    80020048:	fe843583          	ld	a1,-24(s0)
    8002004c:	853e                	mv	a0,a5
    8002004e:	d3cf80ef          	jal	ra,8001858a <minix3_get_inode>
    stat->inode = file->inode;
    80020052:	f9843783          	ld	a5,-104(s0)
    80020056:	47f8                	lw	a4,76(a5)
    80020058:	f9043783          	ld	a5,-112(s0)
    8002005c:	c398                	sw	a4,0(a5)
    stat->mode = data.mode;
    8002005e:	fa845703          	lhu	a4,-88(s0)
    80020062:	f9043783          	ld	a5,-112(s0)
    80020066:	00e79223          	sh	a4,4(a5)
    stat->num_link = data.num_links;
    8002006a:	faa45703          	lhu	a4,-86(s0)
    8002006e:	f9043783          	ld	a5,-112(s0)
    80020072:	00e79323          	sh	a4,6(a5)
    stat->uid = data.uid;
    80020076:	fac45783          	lhu	a5,-84(s0)
    8002007a:	0007871b          	sext.w	a4,a5
    8002007e:	f9043783          	ld	a5,-112(s0)
    80020082:	c798                	sw	a4,8(a5)
    stat->gid = data.gid;
    80020084:	fae45783          	lhu	a5,-82(s0)
    80020088:	0007871b          	sext.w	a4,a5
    8002008c:	f9043783          	ld	a5,-112(s0)
    80020090:	c7d8                	sw	a4,12(a5)
    stat->size = data.size;
    80020092:	fb042703          	lw	a4,-80(s0)
    80020096:	f9043783          	ld	a5,-112(s0)
    8002009a:	cb98                	sw	a4,16(a5)
    stat->atime = data.atime;
    8002009c:	fb442703          	lw	a4,-76(s0)
    800200a0:	f9043783          	ld	a5,-112(s0)
    800200a4:	cbd8                	sw	a4,20(a5)
    stat->mtime = data.mtime;
    800200a6:	fb842703          	lw	a4,-72(s0)
    800200aa:	f9043783          	ld	a5,-112(s0)
    800200ae:	cf98                	sw	a4,24(a5)
    stat->ctime = data.ctime;
    800200b0:	fbc42703          	lw	a4,-68(s0)
    800200b4:	f9043783          	ld	a5,-112(s0)
    800200b8:	cfd8                	sw	a4,28(a5)
    return 0;
    800200ba:	4781                	li	a5,0
}
    800200bc:	853e                	mv	a0,a5
    800200be:	70a6                	ld	ra,104(sp)
    800200c0:	7406                	ld	s0,96(sp)
    800200c2:	6165                	addi	sp,sp,112
    800200c4:	8082                	ret

00000000800200c6 <vfs_link>:

bool vfs_link(File *dir, File *file) {
    800200c6:	7151                	addi	sp,sp,-240
    800200c8:	f586                	sd	ra,232(sp)
    800200ca:	f1a2                	sd	s0,224(sp)
    800200cc:	1980                	addi	s0,sp,240
    800200ce:	f4a43c23          	sd	a0,-168(s0)
    800200d2:	f4b43823          	sd	a1,-176(s0)
    // uint32_t inode1 = minix3_get_inode_from_path(file1->path1, 0);
    // uint32_t inode2 = minix3_get_inode_from_path(path2, 1);
    VirtioDevice *block_device = dir->dev;
    800200d6:	f5843783          	ld	a5,-168(s0)
    800200da:	639c                	ld	a5,0(a5)
    800200dc:	fef43423          	sd	a5,-24(s0)

    // path1 must exist
    if (file->inode == INVALID_INODE) {
    800200e0:	f5043783          	ld	a5,-176(s0)
    800200e4:	47fc                	lw	a5,76(a5)
    800200e6:	e399                	bnez	a5,800200ec <vfs_link+0x26>
        debugf("vfs_link: file doesn't exist\n");
        return false;
    800200e8:	4781                	li	a5,0
    800200ea:	a2bd                	j	80020258 <vfs_link+0x192>
    }

    // path1 must not be a directory
    if (minix3_is_dir(block_device, file->inode)) {
    800200ec:	f5043783          	ld	a5,-176(s0)
    800200f0:	47fc                	lw	a5,76(a5)
    800200f2:	85be                	mv	a1,a5
    800200f4:	fe843503          	ld	a0,-24(s0)
    800200f8:	fc4f80ef          	jal	ra,800188bc <minix3_is_dir>
    800200fc:	87aa                	mv	a5,a0
    800200fe:	c399                	beqz	a5,80020104 <vfs_link+0x3e>
        debugf("vfs_link: file is a directory\n");
        return false;
    80020100:	4781                	li	a5,0
    80020102:	aa99                	j	80020258 <vfs_link+0x192>
    }

    // Parent of path2 must exist
    if (dir->inode == INVALID_INODE) {
    80020104:	f5843783          	ld	a5,-168(s0)
    80020108:	47fc                	lw	a5,76(a5)
    8002010a:	e399                	bnez	a5,80020110 <vfs_link+0x4a>
        debugf("vfs_link: parent of dir doesn't exist\n");
        return false;
    8002010c:	4781                	li	a5,0
    8002010e:	a2a9                	j	80020258 <vfs_link+0x192>
    }

    if (!minix3_is_dir(block_device, dir->inode)) {
    80020110:	f5843783          	ld	a5,-168(s0)
    80020114:	47fc                	lw	a5,76(a5)
    80020116:	85be                	mv	a1,a5
    80020118:	fe843503          	ld	a0,-24(s0)
    8002011c:	fa0f80ef          	jal	ra,800188bc <minix3_is_dir>
    80020120:	87aa                	mv	a5,a0
    80020122:	0017c793          	xori	a5,a5,1
    80020126:	0ff7f793          	andi	a5,a5,255
    8002012a:	c399                	beqz	a5,80020130 <vfs_link+0x6a>
        debugf("vfs_link: parent of dir is not a directory\n");
        return false;
    8002012c:	4781                	li	a5,0
    8002012e:	a22d                	j	80020258 <vfs_link+0x192>
    }

    DirEntry data;
    memset(&data, 0, sizeof(data));
    80020130:	fa040793          	addi	a5,s0,-96
    80020134:	04000613          	li	a2,64
    80020138:	4581                	li	a1,0
    8002013a:	853e                	mv	a0,a5
    8002013c:	100020ef          	jal	ra,8002223c <memset>
    data.inode = file->inode;
    80020140:	f5043783          	ld	a5,-176(s0)
    80020144:	47fc                	lw	a5,76(a5)
    80020146:	faf42023          	sw	a5,-96(s0)
    strcpy(data.name, path_file_name(dir->path));
    8002014a:	f5843783          	ld	a5,-168(s0)
    8002014e:	7bbc                	ld	a5,112(a5)
    80020150:	853e                	mv	a0,a5
    80020152:	386010ef          	jal	ra,800214d8 <path_file_name>
    80020156:	872a                	mv	a4,a0
    80020158:	fa040793          	addi	a5,s0,-96
    8002015c:	0791                	addi	a5,a5,4
    8002015e:	85ba                	mv	a1,a4
    80020160:	853e                	mv	a0,a5
    80020162:	0a7020ef          	jal	ra,80022a08 <strcpy>
    uint32_t free_dir_entry = minix3_find_next_free_dir_entry(block_device, dir->inode);
    80020166:	f5843783          	ld	a5,-168(s0)
    8002016a:	47fc                	lw	a5,76(a5)
    8002016c:	85be                	mv	a1,a5
    8002016e:	fe843503          	ld	a0,-24(s0)
    80020172:	df4fa0ef          	jal	ra,8001a766 <minix3_find_next_free_dir_entry>
    80020176:	87aa                	mv	a5,a0
    80020178:	fef42223          	sw	a5,-28(s0)
    minix3_put_dir_entry(block_device, dir->inode, free_dir_entry, data);
    8002017c:	f5843783          	ld	a5,-168(s0)
    80020180:	04c7a303          	lw	t1,76(a5)
    80020184:	fa043883          	ld	a7,-96(s0)
    80020188:	fa843803          	ld	a6,-88(s0)
    8002018c:	fb043503          	ld	a0,-80(s0)
    80020190:	fb843583          	ld	a1,-72(s0)
    80020194:	fc043603          	ld	a2,-64(s0)
    80020198:	fc843683          	ld	a3,-56(s0)
    8002019c:	fd043703          	ld	a4,-48(s0)
    800201a0:	fd843783          	ld	a5,-40(s0)
    800201a4:	f1143823          	sd	a7,-240(s0)
    800201a8:	f1043c23          	sd	a6,-232(s0)
    800201ac:	f2a43023          	sd	a0,-224(s0)
    800201b0:	f2b43423          	sd	a1,-216(s0)
    800201b4:	f2c43823          	sd	a2,-208(s0)
    800201b8:	f2d43c23          	sd	a3,-200(s0)
    800201bc:	f4e43023          	sd	a4,-192(s0)
    800201c0:	f4f43423          	sd	a5,-184(s0)
    800201c4:	f1040713          	addi	a4,s0,-240
    800201c8:	fe442783          	lw	a5,-28(s0)
    800201cc:	86ba                	mv	a3,a4
    800201ce:	863e                	mv	a2,a5
    800201d0:	859a                	mv	a1,t1
    800201d2:	fe843503          	ld	a0,-24(s0)
    800201d6:	f10fa0ef          	jal	ra,8001a8e6 <minix3_put_dir_entry>

    Inode inode1_data = minix3_get_inode(block_device, file->inode);
    800201da:	f5043783          	ld	a5,-176(s0)
    800201de:	47f8                	lw	a4,76(a5)
    800201e0:	f6040793          	addi	a5,s0,-160
    800201e4:	863a                	mv	a2,a4
    800201e6:	fe843583          	ld	a1,-24(s0)
    800201ea:	853e                	mv	a0,a5
    800201ec:	b9ef80ef          	jal	ra,8001858a <minix3_get_inode>
    inode1_data.num_links += 1;
    800201f0:	f6245783          	lhu	a5,-158(s0)
    800201f4:	2785                	addiw	a5,a5,1
    800201f6:	17c2                	slli	a5,a5,0x30
    800201f8:	93c1                	srli	a5,a5,0x30
    800201fa:	f6f41123          	sh	a5,-158(s0)
    minix3_put_inode(block_device, file->inode, inode1_data);
    800201fe:	f5043783          	ld	a5,-176(s0)
    80020202:	04c7a303          	lw	t1,76(a5)
    80020206:	f6043883          	ld	a7,-160(s0)
    8002020a:	f6843803          	ld	a6,-152(s0)
    8002020e:	f7043503          	ld	a0,-144(s0)
    80020212:	f7843583          	ld	a1,-136(s0)
    80020216:	f8043603          	ld	a2,-128(s0)
    8002021a:	f8843683          	ld	a3,-120(s0)
    8002021e:	f9043703          	ld	a4,-112(s0)
    80020222:	f9843783          	ld	a5,-104(s0)
    80020226:	f1143823          	sd	a7,-240(s0)
    8002022a:	f1043c23          	sd	a6,-232(s0)
    8002022e:	f2a43023          	sd	a0,-224(s0)
    80020232:	f2b43423          	sd	a1,-216(s0)
    80020236:	f2c43823          	sd	a2,-208(s0)
    8002023a:	f2d43c23          	sd	a3,-200(s0)
    8002023e:	f4e43023          	sd	a4,-192(s0)
    80020242:	f4f43423          	sd	a5,-184(s0)
    80020246:	f1040793          	addi	a5,s0,-240
    8002024a:	863e                	mv	a2,a5
    8002024c:	859a                	mv	a1,t1
    8002024e:	fe843503          	ld	a0,-24(s0)
    80020252:	c84f80ef          	jal	ra,800186d6 <minix3_put_inode>
    return true;
    80020256:	4785                	li	a5,1
}
    80020258:	853e                	mv	a0,a5
    8002025a:	70ae                	ld	ra,232(sp)
    8002025c:	740e                	ld	s0,224(sp)
    8002025e:	616d                	addi	sp,sp,240
    80020260:	8082                	ret
	...

0000000080020270 <_start>:
.section .text
.global _start
_start:
.option push
.option norelax
	la		sp, _stack_end
    80020270:	00013117          	auipc	sp,0x13
    80020274:	d9010113          	addi	sp,sp,-624 # 80033000 <_heap_start>
	la		gp, __global_pointer$
    80020278:	00005197          	auipc	gp,0x5
    8002027c:	d8818193          	addi	gp,gp,-632 # 80025000 <sched_lock>
    # Unlike the SBI, we will be trap returning so that
    # we know the registers sstatus, sip, stvec, and sepc are
    # in a place where we expect them to be. We can just jump
    # into main (tail main) like the SBI, but this ensures the CSRs
    # are what we say they are instead of just assuming from the SBI.
	la		t0, main
    80020280:	ffff7297          	auipc	t0,0xffff7
    80020284:	d3c28293          	addi	t0,t0,-708 # 80016fbc <main>
	csrw	sepc, t0
    80020288:	14129073          	csrw	sepc,t0
	li		t0, 1 << 9
    8002028c:	20000293          	li	t0,512
	csrw	sie, t0
    80020290:	10429073          	csrw	sie,t0
    # 1 << 13 - FS:  in the "initial" position
    # 1 << 8  - SPP: into Supervisor Mode
    # 1 << 5  - SPIE: enable interrupts
	li		t0, (1 << 13) | (1 << 8) | (1 << 5)
    80020294:	6289                	lui	t0,0x2
    80020296:	1202829b          	addiw	t0,t0,288
	csrw	sstatus, t0
    8002029a:	10029073          	csrw	sstatus,t0
    # Load the return address (RA) to the park. When main
    # returns, it will park the HART.
	la		ra, park
    8002029e:	00000097          	auipc	ra,0x0
    800202a2:	01208093          	addi	ra,ra,18 # 800202b0 <park>
	csrr	a0, sscratch
    800202a6:	14002573          	csrr	a0,sscratch
	sret
    800202aa:	10200073          	sret
    800202ae:	0001                	nop

00000000800202b0 <park>:

.section .text
.global park
.align 4
park:
	wfi
    800202b0:	10500073          	wfi
	j	park
    800202b4:	bff5                	j	800202b0 <park>

00000000800202b6 <park_end>:
	...

00000000800202c4 <process_asm_run>:

.section .text
.global process_asm_run
process_asm_run:
    # a0 - Trap frame
    csrw    sscratch, a0
    800202c4:	14051073          	csrw	sscratch,a0
    tail    _spawn_kthread
    800202c8:	5390306f          	j	80024000 <_spawn_kthread>

00000000800202cc <g_kmalloc>:
void *(*__global_kmalloc)(uint64_t size);
void *(*__global_kcalloc)(uint64_t num, uint64_t size);
void (*__global_kfree)(void *ptr);

void *g_kmalloc(uint64_t size)
{
    800202cc:	1101                	addi	sp,sp,-32
    800202ce:	ec06                	sd	ra,24(sp)
    800202d0:	e822                	sd	s0,16(sp)
    800202d2:	1000                	addi	s0,sp,32
    800202d4:	fea43423          	sd	a0,-24(s0)
    if (__global_kmalloc == NULL) {
    800202d8:	00005797          	auipc	a5,0x5
    800202dc:	d4078793          	addi	a5,a5,-704 # 80025018 <__global_kmalloc>
    800202e0:	639c                	ld	a5,0(a5)
    800202e2:	e399                	bnez	a5,800202e8 <g_kmalloc+0x1c>
        return NULL;
    800202e4:	4781                	li	a5,0
    800202e6:	a811                	j	800202fa <g_kmalloc+0x2e>
    }
    return __global_kmalloc(size);
    800202e8:	00005797          	auipc	a5,0x5
    800202ec:	d3078793          	addi	a5,a5,-720 # 80025018 <__global_kmalloc>
    800202f0:	639c                	ld	a5,0(a5)
    800202f2:	fe843503          	ld	a0,-24(s0)
    800202f6:	9782                	jalr	a5
    800202f8:	87aa                	mv	a5,a0
}
    800202fa:	853e                	mv	a0,a5
    800202fc:	60e2                	ld	ra,24(sp)
    800202fe:	6442                	ld	s0,16(sp)
    80020300:	6105                	addi	sp,sp,32
    80020302:	8082                	ret

0000000080020304 <g_kcalloc>:
void *g_kcalloc(uint64_t num, uint64_t size)
{
    80020304:	1101                	addi	sp,sp,-32
    80020306:	ec06                	sd	ra,24(sp)
    80020308:	e822                	sd	s0,16(sp)
    8002030a:	1000                	addi	s0,sp,32
    8002030c:	fea43423          	sd	a0,-24(s0)
    80020310:	feb43023          	sd	a1,-32(s0)
    if (__global_kcalloc == NULL) {
    80020314:	00005797          	auipc	a5,0x5
    80020318:	d0c78793          	addi	a5,a5,-756 # 80025020 <__global_kcalloc>
    8002031c:	639c                	ld	a5,0(a5)
    8002031e:	e399                	bnez	a5,80020324 <g_kcalloc+0x20>
        return NULL;
    80020320:	4781                	li	a5,0
    80020322:	a821                	j	8002033a <g_kcalloc+0x36>
    }
    return __global_kcalloc(num, size);
    80020324:	00005797          	auipc	a5,0x5
    80020328:	cfc78793          	addi	a5,a5,-772 # 80025020 <__global_kcalloc>
    8002032c:	639c                	ld	a5,0(a5)
    8002032e:	fe043583          	ld	a1,-32(s0)
    80020332:	fe843503          	ld	a0,-24(s0)
    80020336:	9782                	jalr	a5
    80020338:	87aa                	mv	a5,a0
}
    8002033a:	853e                	mv	a0,a5
    8002033c:	60e2                	ld	ra,24(sp)
    8002033e:	6442                	ld	s0,16(sp)
    80020340:	6105                	addi	sp,sp,32
    80020342:	8082                	ret

0000000080020344 <g_kzalloc>:
void *g_kzalloc(uint64_t size)
{
    80020344:	1101                	addi	sp,sp,-32
    80020346:	ec06                	sd	ra,24(sp)
    80020348:	e822                	sd	s0,16(sp)
    8002034a:	1000                	addi	s0,sp,32
    8002034c:	fea43423          	sd	a0,-24(s0)
    return g_kcalloc(1, size);
    80020350:	fe843583          	ld	a1,-24(s0)
    80020354:	4505                	li	a0,1
    80020356:	fafff0ef          	jal	ra,80020304 <g_kcalloc>
    8002035a:	87aa                	mv	a5,a0
}
    8002035c:	853e                	mv	a0,a5
    8002035e:	60e2                	ld	ra,24(sp)
    80020360:	6442                	ld	s0,16(sp)
    80020362:	6105                	addi	sp,sp,32
    80020364:	8082                	ret

0000000080020366 <g_kfree>:
void g_kfree(void *ptr)
{
    80020366:	1101                	addi	sp,sp,-32
    80020368:	ec06                	sd	ra,24(sp)
    8002036a:	e822                	sd	s0,16(sp)
    8002036c:	1000                	addi	s0,sp,32
    8002036e:	fea43423          	sd	a0,-24(s0)
    if (__global_kfree != NULL) {
    80020372:	00005797          	auipc	a5,0x5
    80020376:	cb678793          	addi	a5,a5,-842 # 80025028 <__global_kfree>
    8002037a:	639c                	ld	a5,0(a5)
    8002037c:	cb89                	beqz	a5,8002038e <g_kfree+0x28>
        __global_kfree(ptr);
    8002037e:	00005797          	auipc	a5,0x5
    80020382:	caa78793          	addi	a5,a5,-854 # 80025028 <__global_kfree>
    80020386:	639c                	ld	a5,0(a5)
    80020388:	fe843503          	ld	a0,-24(s0)
    8002038c:	9782                	jalr	a5
    }
}
    8002038e:	0001                	nop
    80020390:	60e2                	ld	ra,24(sp)
    80020392:	6442                	ld	s0,16(sp)
    80020394:	6105                	addi	sp,sp,32
    80020396:	8082                	ret

0000000080020398 <util_connect_galloc>:

void util_connect_galloc(void *(*malloc)(uint64_t size),
                         void *(*calloc)(uint64_t elem, uint64_t size), void (*free)(void *ptr))
{
    80020398:	7179                	addi	sp,sp,-48
    8002039a:	f422                	sd	s0,40(sp)
    8002039c:	1800                	addi	s0,sp,48
    8002039e:	fea43423          	sd	a0,-24(s0)
    800203a2:	feb43023          	sd	a1,-32(s0)
    800203a6:	fcc43c23          	sd	a2,-40(s0)
    __global_kmalloc = malloc;
    800203aa:	00005797          	auipc	a5,0x5
    800203ae:	c6e78793          	addi	a5,a5,-914 # 80025018 <__global_kmalloc>
    800203b2:	fe843703          	ld	a4,-24(s0)
    800203b6:	e398                	sd	a4,0(a5)
    __global_kcalloc = calloc;
    800203b8:	00005797          	auipc	a5,0x5
    800203bc:	c6878793          	addi	a5,a5,-920 # 80025020 <__global_kcalloc>
    800203c0:	fe043703          	ld	a4,-32(s0)
    800203c4:	e398                	sd	a4,0(a5)
    __global_kfree   = free;
    800203c6:	00005797          	auipc	a5,0x5
    800203ca:	c6278793          	addi	a5,a5,-926 # 80025028 <__global_kfree>
    800203ce:	fd843703          	ld	a4,-40(s0)
    800203d2:	e398                	sd	a4,0(a5)
}
    800203d4:	0001                	nop
    800203d6:	7422                	ld	s0,40(sp)
    800203d8:	6145                	addi	sp,sp,48
    800203da:	8082                	ret

00000000800203dc <list_init>:
typedef struct List {
    ListElem head;
} List;

static List *list_init(List *lst)
{
    800203dc:	1101                	addi	sp,sp,-32
    800203de:	ec22                	sd	s0,24(sp)
    800203e0:	1000                	addi	s0,sp,32
    800203e2:	fea43423          	sd	a0,-24(s0)
    lst->head.next = &lst->head;
    800203e6:	fe843703          	ld	a4,-24(s0)
    800203ea:	fe843783          	ld	a5,-24(s0)
    800203ee:	e798                	sd	a4,8(a5)
    lst->head.prev = &lst->head;
    800203f0:	fe843703          	ld	a4,-24(s0)
    800203f4:	fe843783          	ld	a5,-24(s0)
    800203f8:	eb98                	sd	a4,16(a5)

    return lst;
    800203fa:	fe843783          	ld	a5,-24(s0)
}
    800203fe:	853e                	mv	a0,a5
    80020400:	6462                	ld	s0,24(sp)
    80020402:	6105                	addi	sp,sp,32
    80020404:	8082                	ret

0000000080020406 <list_new>:

List *list_new(void)
{
    80020406:	1101                	addi	sp,sp,-32
    80020408:	ec06                	sd	ra,24(sp)
    8002040a:	e822                	sd	s0,16(sp)
    8002040c:	1000                	addi	s0,sp,32
    List *m = (List *)g_kmalloc(sizeof(List));
    8002040e:	4561                	li	a0,24
    80020410:	ebdff0ef          	jal	ra,800202cc <g_kmalloc>
    80020414:	fea43423          	sd	a0,-24(s0)
    if (m == NULL) {
    80020418:	fe843783          	ld	a5,-24(s0)
    8002041c:	e399                	bnez	a5,80020422 <list_new+0x1c>
        return NULL;
    8002041e:	4781                	li	a5,0
    80020420:	a031                	j	8002042c <list_new+0x26>
    }
    return list_init(m);
    80020422:	fe843503          	ld	a0,-24(s0)
    80020426:	fb7ff0ef          	jal	ra,800203dc <list_init>
    8002042a:	87aa                	mv	a5,a0
}
    8002042c:	853e                	mv	a0,a5
    8002042e:	60e2                	ld	ra,24(sp)
    80020430:	6442                	ld	s0,16(sp)
    80020432:	6105                	addi	sp,sp,32
    80020434:	8082                	ret

0000000080020436 <list_add>:

void list_add(List *lst, uint64_t value)
{
    80020436:	7179                	addi	sp,sp,-48
    80020438:	f406                	sd	ra,40(sp)
    8002043a:	f022                	sd	s0,32(sp)
    8002043c:	1800                	addi	s0,sp,48
    8002043e:	fca43c23          	sd	a0,-40(s0)
    80020442:	fcb43823          	sd	a1,-48(s0)
    ListElem *l;
    l             = (ListElem *)g_kzalloc(sizeof(ListElem));
    80020446:	4561                	li	a0,24
    80020448:	efdff0ef          	jal	ra,80020344 <g_kzalloc>
    8002044c:	fea43423          	sd	a0,-24(s0)
    l->next       = lst->head.next;
    80020450:	fd843783          	ld	a5,-40(s0)
    80020454:	6798                	ld	a4,8(a5)
    80020456:	fe843783          	ld	a5,-24(s0)
    8002045a:	e798                	sd	a4,8(a5)
    l->prev       = &lst->head;
    8002045c:	fd843703          	ld	a4,-40(s0)
    80020460:	fe843783          	ld	a5,-24(s0)
    80020464:	eb98                	sd	a4,16(a5)
    l->next->prev = l;
    80020466:	fe843783          	ld	a5,-24(s0)
    8002046a:	679c                	ld	a5,8(a5)
    8002046c:	fe843703          	ld	a4,-24(s0)
    80020470:	eb98                	sd	a4,16(a5)
    l->prev->next = l;
    80020472:	fe843783          	ld	a5,-24(s0)
    80020476:	6b9c                	ld	a5,16(a5)
    80020478:	fe843703          	ld	a4,-24(s0)
    8002047c:	e798                	sd	a4,8(a5)
    l->value      = value;
    8002047e:	fe843783          	ld	a5,-24(s0)
    80020482:	fd043703          	ld	a4,-48(s0)
    80020486:	e398                	sd	a4,0(a5)
}
    80020488:	0001                	nop
    8002048a:	70a2                	ld	ra,40(sp)
    8002048c:	7402                	ld	s0,32(sp)
    8002048e:	6145                	addi	sp,sp,48
    80020490:	8082                	ret

0000000080020492 <list_clear>:

void list_clear(List *lst)
{
    80020492:	7179                	addi	sp,sp,-48
    80020494:	f406                	sd	ra,40(sp)
    80020496:	f022                	sd	s0,32(sp)
    80020498:	1800                	addi	s0,sp,48
    8002049a:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    for (e = lst->head.next; e != &lst->head; e = n) {
    8002049e:	fd843783          	ld	a5,-40(s0)
    800204a2:	679c                	ld	a5,8(a5)
    800204a4:	fef43423          	sd	a5,-24(s0)
    800204a8:	a831                	j	800204c4 <list_clear+0x32>
        n = e->next;
    800204aa:	fe843783          	ld	a5,-24(s0)
    800204ae:	679c                	ld	a5,8(a5)
    800204b0:	fef43023          	sd	a5,-32(s0)
        list_remove_elem(e);
    800204b4:	fe843503          	ld	a0,-24(s0)
    800204b8:	120000ef          	jal	ra,800205d8 <list_remove_elem>
    for (e = lst->head.next; e != &lst->head; e = n) {
    800204bc:	fe043783          	ld	a5,-32(s0)
    800204c0:	fef43423          	sd	a5,-24(s0)
    800204c4:	fd843783          	ld	a5,-40(s0)
    800204c8:	fe843703          	ld	a4,-24(s0)
    800204cc:	fcf71fe3          	bne	a4,a5,800204aa <list_clear+0x18>
    }
}
    800204d0:	0001                	nop
    800204d2:	0001                	nop
    800204d4:	70a2                	ld	ra,40(sp)
    800204d6:	7402                	ld	s0,32(sp)
    800204d8:	6145                	addi	sp,sp,48
    800204da:	8082                	ret

00000000800204dc <list_sort>:

void list_sort(List *lst, LIST_COMPARATOR_PARAM(comp))
{
    800204dc:	7139                	addi	sp,sp,-64
    800204de:	fc06                	sd	ra,56(sp)
    800204e0:	f822                	sd	s0,48(sp)
    800204e2:	0080                	addi	s0,sp,64
    800204e4:	fca43423          	sd	a0,-56(s0)
    800204e8:	fcb43023          	sd	a1,-64(s0)
    ListElem *e;
    bool swapped;
    uint64_t tmp;

    do {
        swapped = false;
    800204ec:	fe0403a3          	sb	zero,-25(s0)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    800204f0:	fc843783          	ld	a5,-56(s0)
    800204f4:	6b9c                	ld	a5,16(a5)
    800204f6:	fef43423          	sd	a5,-24(s0)
    800204fa:	a8a9                	j	80020554 <list_sort+0x78>
            if (!comp(e->value, e->prev->value)) {
    800204fc:	fe843783          	ld	a5,-24(s0)
    80020500:	6398                	ld	a4,0(a5)
    80020502:	fe843783          	ld	a5,-24(s0)
    80020506:	6b9c                	ld	a5,16(a5)
    80020508:	639c                	ld	a5,0(a5)
    8002050a:	fc043683          	ld	a3,-64(s0)
    8002050e:	85be                	mv	a1,a5
    80020510:	853a                	mv	a0,a4
    80020512:	9682                	jalr	a3
    80020514:	87aa                	mv	a5,a0
    80020516:	0017c793          	xori	a5,a5,1
    8002051a:	0ff7f793          	andi	a5,a5,255
    8002051e:	c795                	beqz	a5,8002054a <list_sort+0x6e>
                swapped        = true;
    80020520:	4785                	li	a5,1
    80020522:	fef403a3          	sb	a5,-25(s0)
                tmp            = e->value;
    80020526:	fe843783          	ld	a5,-24(s0)
    8002052a:	639c                	ld	a5,0(a5)
    8002052c:	fcf43c23          	sd	a5,-40(s0)
                e->value       = e->prev->value;
    80020530:	fe843783          	ld	a5,-24(s0)
    80020534:	6b9c                	ld	a5,16(a5)
    80020536:	6398                	ld	a4,0(a5)
    80020538:	fe843783          	ld	a5,-24(s0)
    8002053c:	e398                	sd	a4,0(a5)
                e->prev->value = tmp;
    8002053e:	fe843783          	ld	a5,-24(s0)
    80020542:	6b9c                	ld	a5,16(a5)
    80020544:	fd843703          	ld	a4,-40(s0)
    80020548:	e398                	sd	a4,0(a5)
        for (e = lst->head.prev; e->prev != &lst->head; e = e->prev) {
    8002054a:	fe843783          	ld	a5,-24(s0)
    8002054e:	6b9c                	ld	a5,16(a5)
    80020550:	fef43423          	sd	a5,-24(s0)
    80020554:	fe843783          	ld	a5,-24(s0)
    80020558:	6b98                	ld	a4,16(a5)
    8002055a:	fc843783          	ld	a5,-56(s0)
    8002055e:	f8f71fe3          	bne	a4,a5,800204fc <list_sort+0x20>
            }
        }
    } while (swapped);
    80020562:	fe744783          	lbu	a5,-25(s0)
    80020566:	0ff7f793          	andi	a5,a5,255
    8002056a:	f3c9                	bnez	a5,800204ec <list_sort+0x10>
}
    8002056c:	0001                	nop
    8002056e:	0001                	nop
    80020570:	70e2                	ld	ra,56(sp)
    80020572:	7442                	ld	s0,48(sp)
    80020574:	6121                	addi	sp,sp,64
    80020576:	8082                	ret

0000000080020578 <list_remove>:

bool list_remove(List *lst, uint64_t value)
{
    80020578:	7179                	addi	sp,sp,-48
    8002057a:	f406                	sd	ra,40(sp)
    8002057c:	f022                	sd	s0,32(sp)
    8002057e:	1800                	addi	s0,sp,48
    80020580:	fca43c23          	sd	a0,-40(s0)
    80020584:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(lst, e)
    80020588:	fd843503          	ld	a0,-40(s0)
    8002058c:	2ca000ef          	jal	ra,80020856 <list_elem_start_ascending>
    80020590:	fea43423          	sd	a0,-24(s0)
    80020594:	a025                	j	800205bc <list_remove+0x44>
    {
        if (e->value == value) {
    80020596:	fe843783          	ld	a5,-24(s0)
    8002059a:	639c                	ld	a5,0(a5)
    8002059c:	fd043703          	ld	a4,-48(s0)
    800205a0:	00f71863          	bne	a4,a5,800205b0 <list_remove+0x38>
            list_remove_elem(e);
    800205a4:	fe843503          	ld	a0,-24(s0)
    800205a8:	030000ef          	jal	ra,800205d8 <list_remove_elem>
            return true;
    800205ac:	4785                	li	a5,1
    800205ae:	a005                	j	800205ce <list_remove+0x56>
    list_for_each(lst, e)
    800205b0:	fe843503          	ld	a0,-24(s0)
    800205b4:	2ea000ef          	jal	ra,8002089e <list_elem_prev>
    800205b8:	fea43423          	sd	a0,-24(s0)
    800205bc:	fe843583          	ld	a1,-24(s0)
    800205c0:	fd843503          	ld	a0,-40(s0)
    800205c4:	204000ef          	jal	ra,800207c8 <list_elem_valid>
    800205c8:	87aa                	mv	a5,a0
    800205ca:	f7f1                	bnez	a5,80020596 <list_remove+0x1e>
        }
    }
    return false;
    800205cc:	4781                	li	a5,0
}
    800205ce:	853e                	mv	a0,a5
    800205d0:	70a2                	ld	ra,40(sp)
    800205d2:	7402                	ld	s0,32(sp)
    800205d4:	6145                	addi	sp,sp,48
    800205d6:	8082                	ret

00000000800205d8 <list_remove_elem>:

void list_remove_elem(ListElem *e)
{
    800205d8:	1101                	addi	sp,sp,-32
    800205da:	ec06                	sd	ra,24(sp)
    800205dc:	e822                	sd	s0,16(sp)
    800205de:	1000                	addi	s0,sp,32
    800205e0:	fea43423          	sd	a0,-24(s0)
    e->next->prev = e->prev;
    800205e4:	fe843783          	ld	a5,-24(s0)
    800205e8:	679c                	ld	a5,8(a5)
    800205ea:	fe843703          	ld	a4,-24(s0)
    800205ee:	6b18                	ld	a4,16(a4)
    800205f0:	eb98                	sd	a4,16(a5)
    e->prev->next = e->next;
    800205f2:	fe843783          	ld	a5,-24(s0)
    800205f6:	6b9c                	ld	a5,16(a5)
    800205f8:	fe843703          	ld	a4,-24(s0)
    800205fc:	6718                	ld	a4,8(a4)
    800205fe:	e798                	sd	a4,8(a5)
    g_kfree(e);
    80020600:	fe843503          	ld	a0,-24(s0)
    80020604:	d63ff0ef          	jal	ra,80020366 <g_kfree>
}
    80020608:	0001                	nop
    8002060a:	60e2                	ld	ra,24(sp)
    8002060c:	6442                	ld	s0,16(sp)
    8002060e:	6105                	addi	sp,sp,32
    80020610:	8082                	ret

0000000080020612 <list_find_elem>:

ListElem *list_find_elem(List *l, uint64_t value)
{
    80020612:	7179                	addi	sp,sp,-48
    80020614:	f406                	sd	ra,40(sp)
    80020616:	f022                	sd	s0,32(sp)
    80020618:	1800                	addi	s0,sp,48
    8002061a:	fca43c23          	sd	a0,-40(s0)
    8002061e:	fcb43823          	sd	a1,-48(s0)
    ListElem *e;
    list_for_each(l, e)
    80020622:	fd843503          	ld	a0,-40(s0)
    80020626:	230000ef          	jal	ra,80020856 <list_elem_start_ascending>
    8002062a:	fea43423          	sd	a0,-24(s0)
    8002062e:	a00d                	j	80020650 <list_find_elem+0x3e>
    {
        if (e->value == value) {
    80020630:	fe843783          	ld	a5,-24(s0)
    80020634:	639c                	ld	a5,0(a5)
    80020636:	fd043703          	ld	a4,-48(s0)
    8002063a:	00f71563          	bne	a4,a5,80020644 <list_find_elem+0x32>
            return e;
    8002063e:	fe843783          	ld	a5,-24(s0)
    80020642:	a005                	j	80020662 <list_find_elem+0x50>
    list_for_each(l, e)
    80020644:	fe843503          	ld	a0,-24(s0)
    80020648:	256000ef          	jal	ra,8002089e <list_elem_prev>
    8002064c:	fea43423          	sd	a0,-24(s0)
    80020650:	fe843583          	ld	a1,-24(s0)
    80020654:	fd843503          	ld	a0,-40(s0)
    80020658:	170000ef          	jal	ra,800207c8 <list_elem_valid>
    8002065c:	87aa                	mv	a5,a0
    8002065e:	fbe9                	bnez	a5,80020630 <list_find_elem+0x1e>
        }
    }
    return NULL;
    80020660:	4781                	li	a5,0
}
    80020662:	853e                	mv	a0,a5
    80020664:	70a2                	ld	ra,40(sp)
    80020666:	7402                	ld	s0,32(sp)
    80020668:	6145                	addi	sp,sp,48
    8002066a:	8082                	ret

000000008002066c <list_contains>:

bool list_contains(const List *lst, uint64_t value)
{
    8002066c:	7179                	addi	sp,sp,-48
    8002066e:	f406                	sd	ra,40(sp)
    80020670:	f022                	sd	s0,32(sp)
    80020672:	1800                	addi	s0,sp,48
    80020674:	fca43c23          	sd	a0,-40(s0)
    80020678:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e = list_find_celem(lst, value);
    8002067c:	fd043583          	ld	a1,-48(s0)
    80020680:	fd843503          	ld	a0,-40(s0)
    80020684:	178000ef          	jal	ra,800207fc <list_find_celem>
    80020688:	fea43423          	sd	a0,-24(s0)

    return e == NULL ? false : true;
    8002068c:	fe843783          	ld	a5,-24(s0)
    80020690:	00f037b3          	snez	a5,a5
    80020694:	0ff7f793          	andi	a5,a5,255
}
    80020698:	853e                	mv	a0,a5
    8002069a:	70a2                	ld	ra,40(sp)
    8002069c:	7402                	ld	s0,32(sp)
    8002069e:	6145                	addi	sp,sp,48
    800206a0:	8082                	ret

00000000800206a2 <list_pop_back>:

ListElem *list_pop_back(List *l)
{
    800206a2:	7179                	addi	sp,sp,-48
    800206a4:	f406                	sd	ra,40(sp)
    800206a6:	f022                	sd	s0,32(sp)
    800206a8:	1800                	addi	s0,sp,48
    800206aa:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.next) {
    800206ae:	fd843703          	ld	a4,-40(s0)
    800206b2:	fd843783          	ld	a5,-40(s0)
    800206b6:	679c                	ld	a5,8(a5)
    800206b8:	00f71463          	bne	a4,a5,800206c0 <list_pop_back+0x1e>
        return NULL;
    800206bc:	4781                	li	a5,0
    800206be:	a821                	j	800206d6 <list_pop_back+0x34>
    }
    ListElem *e = l->head.next;
    800206c0:	fd843783          	ld	a5,-40(s0)
    800206c4:	679c                	ld	a5,8(a5)
    800206c6:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    800206ca:	fe843503          	ld	a0,-24(s0)
    800206ce:	f0bff0ef          	jal	ra,800205d8 <list_remove_elem>
    return e;
    800206d2:	fe843783          	ld	a5,-24(s0)
}
    800206d6:	853e                	mv	a0,a5
    800206d8:	70a2                	ld	ra,40(sp)
    800206da:	7402                	ld	s0,32(sp)
    800206dc:	6145                	addi	sp,sp,48
    800206de:	8082                	ret

00000000800206e0 <list_pop>:

ListElem *list_pop(List *l)
{
    800206e0:	7179                	addi	sp,sp,-48
    800206e2:	f406                	sd	ra,40(sp)
    800206e4:	f022                	sd	s0,32(sp)
    800206e6:	1800                	addi	s0,sp,48
    800206e8:	fca43c23          	sd	a0,-40(s0)
    if (&l->head == l->head.prev) {
    800206ec:	fd843703          	ld	a4,-40(s0)
    800206f0:	fd843783          	ld	a5,-40(s0)
    800206f4:	6b9c                	ld	a5,16(a5)
    800206f6:	00f71463          	bne	a4,a5,800206fe <list_pop+0x1e>
        return NULL;
    800206fa:	4781                	li	a5,0
    800206fc:	a821                	j	80020714 <list_pop+0x34>
    }
    ListElem *e = l->head.prev;
    800206fe:	fd843783          	ld	a5,-40(s0)
    80020702:	6b9c                	ld	a5,16(a5)
    80020704:	fef43423          	sd	a5,-24(s0)
    list_remove_elem(e);
    80020708:	fe843503          	ld	a0,-24(s0)
    8002070c:	ecdff0ef          	jal	ra,800205d8 <list_remove_elem>
    return e;
    80020710:	fe843783          	ld	a5,-24(s0)
}
    80020714:	853e                	mv	a0,a5
    80020716:	70a2                	ld	ra,40(sp)
    80020718:	7402                	ld	s0,32(sp)
    8002071a:	6145                	addi	sp,sp,48
    8002071c:	8082                	ret

000000008002071e <list_size>:

uint64_t list_size(const List *lst)
{
    8002071e:	7179                	addi	sp,sp,-48
    80020720:	f406                	sd	ra,40(sp)
    80020722:	f022                	sd	s0,32(sp)
    80020724:	1800                	addi	s0,sp,48
    80020726:	fca43c23          	sd	a0,-40(s0)
    uint64_t s = 0;
    8002072a:	fe043423          	sd	zero,-24(s0)
    const ListElem *e;
    list_for_ceach(lst, e)
    8002072e:	fd843503          	ld	a0,-40(s0)
    80020732:	19c000ef          	jal	ra,800208ce <list_celem_start_ascending>
    80020736:	fea43023          	sd	a0,-32(s0)
    8002073a:	a821                	j	80020752 <list_size+0x34>
    {
        s += 1;
    8002073c:	fe843783          	ld	a5,-24(s0)
    80020740:	0785                	addi	a5,a5,1
    80020742:	fef43423          	sd	a5,-24(s0)
    list_for_ceach(lst, e)
    80020746:	fe043503          	ld	a0,-32(s0)
    8002074a:	1cc000ef          	jal	ra,80020916 <list_celem_prev>
    8002074e:	fea43023          	sd	a0,-32(s0)
    80020752:	fe043583          	ld	a1,-32(s0)
    80020756:	fd843503          	ld	a0,-40(s0)
    8002075a:	06e000ef          	jal	ra,800207c8 <list_elem_valid>
    8002075e:	87aa                	mv	a5,a0
    80020760:	fff1                	bnez	a5,8002073c <list_size+0x1e>
    }
    return s;
    80020762:	fe843783          	ld	a5,-24(s0)
}
    80020766:	853e                	mv	a0,a5
    80020768:	70a2                	ld	ra,40(sp)
    8002076a:	7402                	ld	s0,32(sp)
    8002076c:	6145                	addi	sp,sp,48
    8002076e:	8082                	ret

0000000080020770 <list_free>:

void list_free(List *lst)
{
    80020770:	7179                	addi	sp,sp,-48
    80020772:	f406                	sd	ra,40(sp)
    80020774:	f022                	sd	s0,32(sp)
    80020776:	1800                	addi	s0,sp,48
    80020778:	fca43c23          	sd	a0,-40(s0)
    ListElem *e, *n;
    if (lst == NULL) {
    8002077c:	fd843783          	ld	a5,-40(s0)
    80020780:	cf9d                	beqz	a5,800207be <list_free+0x4e>
        return;
    }
    for (e = lst->head.next; e != &lst->head; e = n) {
    80020782:	fd843783          	ld	a5,-40(s0)
    80020786:	679c                	ld	a5,8(a5)
    80020788:	fef43423          	sd	a5,-24(s0)
    8002078c:	a831                	j	800207a8 <list_free+0x38>
        n = e->next;
    8002078e:	fe843783          	ld	a5,-24(s0)
    80020792:	679c                	ld	a5,8(a5)
    80020794:	fef43023          	sd	a5,-32(s0)
        g_kfree(e);
    80020798:	fe843503          	ld	a0,-24(s0)
    8002079c:	bcbff0ef          	jal	ra,80020366 <g_kfree>
    for (e = lst->head.next; e != &lst->head; e = n) {
    800207a0:	fe043783          	ld	a5,-32(s0)
    800207a4:	fef43423          	sd	a5,-24(s0)
    800207a8:	fd843783          	ld	a5,-40(s0)
    800207ac:	fe843703          	ld	a4,-24(s0)
    800207b0:	fcf71fe3          	bne	a4,a5,8002078e <list_free+0x1e>
    }
    g_kfree(lst);
    800207b4:	fd843503          	ld	a0,-40(s0)
    800207b8:	bafff0ef          	jal	ra,80020366 <g_kfree>
    800207bc:	a011                	j	800207c0 <list_free+0x50>
        return;
    800207be:	0001                	nop
}
    800207c0:	70a2                	ld	ra,40(sp)
    800207c2:	7402                	ld	s0,32(sp)
    800207c4:	6145                	addi	sp,sp,48
    800207c6:	8082                	ret

00000000800207c8 <list_elem_valid>:

bool list_elem_valid(const List *l, const ListElem *e)
{
    800207c8:	1101                	addi	sp,sp,-32
    800207ca:	ec22                	sd	s0,24(sp)
    800207cc:	1000                	addi	s0,sp,32
    800207ce:	fea43423          	sd	a0,-24(s0)
    800207d2:	feb43023          	sd	a1,-32(s0)
    return e != NULL && e != &l->head;
    800207d6:	fe043783          	ld	a5,-32(s0)
    800207da:	cb89                	beqz	a5,800207ec <list_elem_valid+0x24>
    800207dc:	fe843783          	ld	a5,-24(s0)
    800207e0:	fe043703          	ld	a4,-32(s0)
    800207e4:	00f70463          	beq	a4,a5,800207ec <list_elem_valid+0x24>
    800207e8:	4785                	li	a5,1
    800207ea:	a011                	j	800207ee <list_elem_valid+0x26>
    800207ec:	4781                	li	a5,0
    800207ee:	8b85                	andi	a5,a5,1
    800207f0:	0ff7f793          	andi	a5,a5,255
}
    800207f4:	853e                	mv	a0,a5
    800207f6:	6462                	ld	s0,24(sp)
    800207f8:	6105                	addi	sp,sp,32
    800207fa:	8082                	ret

00000000800207fc <list_find_celem>:

const ListElem *list_find_celem(const List *l, uint64_t value) 
{
    800207fc:	7179                	addi	sp,sp,-48
    800207fe:	f406                	sd	ra,40(sp)
    80020800:	f022                	sd	s0,32(sp)
    80020802:	1800                	addi	s0,sp,48
    80020804:	fca43c23          	sd	a0,-40(s0)
    80020808:	fcb43823          	sd	a1,-48(s0)
    const ListElem *e;
    list_for_ceach(l, e) 
    8002080c:	fd843503          	ld	a0,-40(s0)
    80020810:	0be000ef          	jal	ra,800208ce <list_celem_start_ascending>
    80020814:	fea43423          	sd	a0,-24(s0)
    80020818:	a00d                	j	8002083a <list_find_celem+0x3e>
    {
        if (e->value == value) {
    8002081a:	fe843783          	ld	a5,-24(s0)
    8002081e:	639c                	ld	a5,0(a5)
    80020820:	fd043703          	ld	a4,-48(s0)
    80020824:	00f71563          	bne	a4,a5,8002082e <list_find_celem+0x32>
            return e;
    80020828:	fe843783          	ld	a5,-24(s0)
    8002082c:	a005                	j	8002084c <list_find_celem+0x50>
    list_for_ceach(l, e) 
    8002082e:	fe843503          	ld	a0,-24(s0)
    80020832:	0e4000ef          	jal	ra,80020916 <list_celem_prev>
    80020836:	fea43423          	sd	a0,-24(s0)
    8002083a:	fe843583          	ld	a1,-24(s0)
    8002083e:	fd843503          	ld	a0,-40(s0)
    80020842:	f87ff0ef          	jal	ra,800207c8 <list_elem_valid>
    80020846:	87aa                	mv	a5,a0
    80020848:	fbe9                	bnez	a5,8002081a <list_find_celem+0x1e>
        }
    }
    return NULL;
    8002084a:	4781                	li	a5,0
}
    8002084c:	853e                	mv	a0,a5
    8002084e:	70a2                	ld	ra,40(sp)
    80020850:	7402                	ld	s0,32(sp)
    80020852:	6145                	addi	sp,sp,48
    80020854:	8082                	ret

0000000080020856 <list_elem_start_ascending>:

ListElem *list_elem_start_ascending(List *l)
{
    80020856:	1101                	addi	sp,sp,-32
    80020858:	ec22                	sd	s0,24(sp)
    8002085a:	1000                	addi	s0,sp,32
    8002085c:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    80020860:	fe843783          	ld	a5,-24(s0)
    80020864:	6b9c                	ld	a5,16(a5)
}
    80020866:	853e                	mv	a0,a5
    80020868:	6462                	ld	s0,24(sp)
    8002086a:	6105                	addi	sp,sp,32
    8002086c:	8082                	ret

000000008002086e <list_elem_start_descending>:

ListElem *list_elem_start_descending(List *l)
{
    8002086e:	1101                	addi	sp,sp,-32
    80020870:	ec22                	sd	s0,24(sp)
    80020872:	1000                	addi	s0,sp,32
    80020874:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    80020878:	fe843783          	ld	a5,-24(s0)
    8002087c:	679c                	ld	a5,8(a5)
}
    8002087e:	853e                	mv	a0,a5
    80020880:	6462                	ld	s0,24(sp)
    80020882:	6105                	addi	sp,sp,32
    80020884:	8082                	ret

0000000080020886 <list_elem_next>:

ListElem *list_elem_next(ListElem *e)
{
    80020886:	1101                	addi	sp,sp,-32
    80020888:	ec22                	sd	s0,24(sp)
    8002088a:	1000                	addi	s0,sp,32
    8002088c:	fea43423          	sd	a0,-24(s0)
    return e->next;
    80020890:	fe843783          	ld	a5,-24(s0)
    80020894:	679c                	ld	a5,8(a5)
}
    80020896:	853e                	mv	a0,a5
    80020898:	6462                	ld	s0,24(sp)
    8002089a:	6105                	addi	sp,sp,32
    8002089c:	8082                	ret

000000008002089e <list_elem_prev>:

ListElem *list_elem_prev(ListElem *e)
{
    8002089e:	1101                	addi	sp,sp,-32
    800208a0:	ec22                	sd	s0,24(sp)
    800208a2:	1000                	addi	s0,sp,32
    800208a4:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    800208a8:	fe843783          	ld	a5,-24(s0)
    800208ac:	6b9c                	ld	a5,16(a5)
}
    800208ae:	853e                	mv	a0,a5
    800208b0:	6462                	ld	s0,24(sp)
    800208b2:	6105                	addi	sp,sp,32
    800208b4:	8082                	ret

00000000800208b6 <list_elem_value>:

uint64_t list_elem_value(const ListElem *e)
{
    800208b6:	1101                	addi	sp,sp,-32
    800208b8:	ec22                	sd	s0,24(sp)
    800208ba:	1000                	addi	s0,sp,32
    800208bc:	fea43423          	sd	a0,-24(s0)
    return e->value;
    800208c0:	fe843783          	ld	a5,-24(s0)
    800208c4:	639c                	ld	a5,0(a5)
}
    800208c6:	853e                	mv	a0,a5
    800208c8:	6462                	ld	s0,24(sp)
    800208ca:	6105                	addi	sp,sp,32
    800208cc:	8082                	ret

00000000800208ce <list_celem_start_ascending>:

const ListElem *list_celem_start_ascending(const List *l) {
    800208ce:	1101                	addi	sp,sp,-32
    800208d0:	ec22                	sd	s0,24(sp)
    800208d2:	1000                	addi	s0,sp,32
    800208d4:	fea43423          	sd	a0,-24(s0)
    return l->head.prev;
    800208d8:	fe843783          	ld	a5,-24(s0)
    800208dc:	6b9c                	ld	a5,16(a5)
}
    800208de:	853e                	mv	a0,a5
    800208e0:	6462                	ld	s0,24(sp)
    800208e2:	6105                	addi	sp,sp,32
    800208e4:	8082                	ret

00000000800208e6 <list_celem_start_descending>:
const ListElem *list_celem_start_descending(const List *l) {
    800208e6:	1101                	addi	sp,sp,-32
    800208e8:	ec22                	sd	s0,24(sp)
    800208ea:	1000                	addi	s0,sp,32
    800208ec:	fea43423          	sd	a0,-24(s0)
    return l->head.next;
    800208f0:	fe843783          	ld	a5,-24(s0)
    800208f4:	679c                	ld	a5,8(a5)
}
    800208f6:	853e                	mv	a0,a5
    800208f8:	6462                	ld	s0,24(sp)
    800208fa:	6105                	addi	sp,sp,32
    800208fc:	8082                	ret

00000000800208fe <list_celem_next>:
const ListElem *list_celem_next(const ListElem *e) {
    800208fe:	1101                	addi	sp,sp,-32
    80020900:	ec22                	sd	s0,24(sp)
    80020902:	1000                	addi	s0,sp,32
    80020904:	fea43423          	sd	a0,-24(s0)
    return e->next;
    80020908:	fe843783          	ld	a5,-24(s0)
    8002090c:	679c                	ld	a5,8(a5)
}
    8002090e:	853e                	mv	a0,a5
    80020910:	6462                	ld	s0,24(sp)
    80020912:	6105                	addi	sp,sp,32
    80020914:	8082                	ret

0000000080020916 <list_celem_prev>:
const ListElem *list_celem_prev(const ListElem *e) {
    80020916:	1101                	addi	sp,sp,-32
    80020918:	ec22                	sd	s0,24(sp)
    8002091a:	1000                	addi	s0,sp,32
    8002091c:	fea43423          	sd	a0,-24(s0)
    return e->prev;
    80020920:	fe843783          	ld	a5,-24(s0)
    80020924:	6b9c                	ld	a5,16(a5)
}
    80020926:	853e                	mv	a0,a5
    80020928:	6462                	ld	s0,24(sp)
    8002092a:	6105                	addi	sp,sp,32
    8002092c:	8082                	ret

000000008002092e <list_sort_signed_long_comparator_ascending>:

// Default list comparators
LIST_COMPARATOR(list_sort_signed_long_comparator_ascending)
{
    8002092e:	1101                	addi	sp,sp,-32
    80020930:	ec22                	sd	s0,24(sp)
    80020932:	1000                	addi	s0,sp,32
    80020934:	fea43423          	sd	a0,-24(s0)
    80020938:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    8002093c:	fe843703          	ld	a4,-24(s0)
    80020940:	fe043783          	ld	a5,-32(s0)
    80020944:	00e7a7b3          	slt	a5,a5,a4
    80020948:	0017c793          	xori	a5,a5,1
    8002094c:	0ff7f793          	andi	a5,a5,255
}
    80020950:	853e                	mv	a0,a5
    80020952:	6462                	ld	s0,24(sp)
    80020954:	6105                	addi	sp,sp,32
    80020956:	8082                	ret

0000000080020958 <list_sort_signed_long_comparator_descending>:
LIST_COMPARATOR(list_sort_signed_long_comparator_descending)
{
    80020958:	1101                	addi	sp,sp,-32
    8002095a:	ec22                	sd	s0,24(sp)
    8002095c:	1000                	addi	s0,sp,32
    8002095e:	fea43423          	sd	a0,-24(s0)
    80020962:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    80020966:	fe843703          	ld	a4,-24(s0)
    8002096a:	fe043783          	ld	a5,-32(s0)
    8002096e:	00f727b3          	slt	a5,a4,a5
    80020972:	0017c793          	xori	a5,a5,1
    80020976:	0ff7f793          	andi	a5,a5,255
}
    8002097a:	853e                	mv	a0,a5
    8002097c:	6462                	ld	s0,24(sp)
    8002097e:	6105                	addi	sp,sp,32
    80020980:	8082                	ret

0000000080020982 <list_sort_unsigned_long_comparator_ascending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_ascending)
{
    80020982:	1101                	addi	sp,sp,-32
    80020984:	ec22                	sd	s0,24(sp)
    80020986:	1000                	addi	s0,sp,32
    80020988:	fea43423          	sd	a0,-24(s0)
    8002098c:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    80020990:	fe843703          	ld	a4,-24(s0)
    80020994:	fe043783          	ld	a5,-32(s0)
    80020998:	00e7b7b3          	sltu	a5,a5,a4
    8002099c:	0017c793          	xori	a5,a5,1
    800209a0:	0ff7f793          	andi	a5,a5,255
}
    800209a4:	853e                	mv	a0,a5
    800209a6:	6462                	ld	s0,24(sp)
    800209a8:	6105                	addi	sp,sp,32
    800209aa:	8082                	ret

00000000800209ac <list_sort_unsigned_long_comparator_descending>:
LIST_COMPARATOR(list_sort_unsigned_long_comparator_descending)
{
    800209ac:	1101                	addi	sp,sp,-32
    800209ae:	ec22                	sd	s0,24(sp)
    800209b0:	1000                	addi	s0,sp,32
    800209b2:	fea43423          	sd	a0,-24(s0)
    800209b6:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    800209ba:	fe843703          	ld	a4,-24(s0)
    800209be:	fe043783          	ld	a5,-32(s0)
    800209c2:	00f737b3          	sltu	a5,a4,a5
    800209c6:	0017c793          	xori	a5,a5,1
    800209ca:	0ff7f793          	andi	a5,a5,255
}
    800209ce:	853e                	mv	a0,a5
    800209d0:	6462                	ld	s0,24(sp)
    800209d2:	6105                	addi	sp,sp,32
    800209d4:	8082                	ret

00000000800209d6 <list_sort_string_comparator_ascending>:
LIST_COMPARATOR(list_sort_string_comparator_ascending)
{
    800209d6:	1101                	addi	sp,sp,-32
    800209d8:	ec06                	sd	ra,24(sp)
    800209da:	e822                	sd	s0,16(sp)
    800209dc:	1000                	addi	s0,sp,32
    800209de:	fea43423          	sd	a0,-24(s0)
    800209e2:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    800209e6:	fe843783          	ld	a5,-24(s0)
    800209ea:	fe043703          	ld	a4,-32(s0)
    800209ee:	85ba                	mv	a1,a4
    800209f0:	853e                	mv	a0,a5
    800209f2:	4db010ef          	jal	ra,800226cc <strcmp>
    800209f6:	87aa                	mv	a5,a0
    800209f8:	0017a793          	slti	a5,a5,1
    800209fc:	0ff7f793          	andi	a5,a5,255
}
    80020a00:	853e                	mv	a0,a5
    80020a02:	60e2                	ld	ra,24(sp)
    80020a04:	6442                	ld	s0,16(sp)
    80020a06:	6105                	addi	sp,sp,32
    80020a08:	8082                	ret

0000000080020a0a <list_sort_string_comparator_descending>:
LIST_COMPARATOR(list_sort_string_comparator_descending)
{
    80020a0a:	1101                	addi	sp,sp,-32
    80020a0c:	ec06                	sd	ra,24(sp)
    80020a0e:	e822                	sd	s0,16(sp)
    80020a10:	1000                	addi	s0,sp,32
    80020a12:	fea43423          	sd	a0,-24(s0)
    80020a16:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    80020a1a:	fe843783          	ld	a5,-24(s0)
    80020a1e:	fe043703          	ld	a4,-32(s0)
    80020a22:	85ba                	mv	a1,a4
    80020a24:	853e                	mv	a0,a5
    80020a26:	4a7010ef          	jal	ra,800226cc <strcmp>
    80020a2a:	87aa                	mv	a5,a0
    80020a2c:	fff7c793          	not	a5,a5
    80020a30:	01f7d79b          	srliw	a5,a5,0x1f
    80020a34:	0ff7f793          	andi	a5,a5,255
}
    80020a38:	853e                	mv	a0,a5
    80020a3a:	60e2                	ld	ra,24(sp)
    80020a3c:	6442                	ld	s0,16(sp)
    80020a3e:	6105                	addi	sp,sp,32
    80020a40:	8082                	ret

0000000080020a42 <fnv1a_digest_64>:
#define FNV1_64_OFFSET  14695981039346656037UL
#define FNV1_64_PRIME   1099511628211UL

// FNV-1a hashing
static uint64_t fnv1a_digest_64(const char *key)
{
    80020a42:	7179                	addi	sp,sp,-48
    80020a44:	f422                	sd	s0,40(sp)
    80020a46:	1800                	addi	s0,sp,48
    80020a48:	fca43c23          	sd	a0,-40(s0)
    uint64_t digest = FNV1_64_OFFSET;
    80020a4c:	00009797          	auipc	a5,0x9
    80020a50:	e3478793          	addi	a5,a5,-460 # 80029880 <trampoline_trap_size+0xf>
    80020a54:	639c                	ld	a5,0(a5)
    80020a56:	fef43423          	sd	a5,-24(s0)
    const unsigned char *k;

    for (k = (unsigned char *)key; *k; k += 1) {
    80020a5a:	fd843783          	ld	a5,-40(s0)
    80020a5e:	fef43023          	sd	a5,-32(s0)
    80020a62:	a035                	j	80020a8e <fnv1a_digest_64+0x4c>
        digest = (digest ^ *k) * FNV1_64_PRIME;
    80020a64:	fe043783          	ld	a5,-32(s0)
    80020a68:	0007c783          	lbu	a5,0(a5)
    80020a6c:	873e                	mv	a4,a5
    80020a6e:	fe843783          	ld	a5,-24(s0)
    80020a72:	8f3d                	xor	a4,a4,a5
    80020a74:	4785                	li	a5,1
    80020a76:	17a2                	slli	a5,a5,0x28
    80020a78:	1b378793          	addi	a5,a5,435
    80020a7c:	02f707b3          	mul	a5,a4,a5
    80020a80:	fef43423          	sd	a5,-24(s0)
    for (k = (unsigned char *)key; *k; k += 1) {
    80020a84:	fe043783          	ld	a5,-32(s0)
    80020a88:	0785                	addi	a5,a5,1
    80020a8a:	fef43023          	sd	a5,-32(s0)
    80020a8e:	fe043783          	ld	a5,-32(s0)
    80020a92:	0007c783          	lbu	a5,0(a5)
    80020a96:	f7f9                	bnez	a5,80020a64 <fnv1a_digest_64+0x22>
    }
    return digest;
    80020a98:	fe843783          	ld	a5,-24(s0)
}
    80020a9c:	853e                	mv	a0,a5
    80020a9e:	7422                	ld	s0,40(sp)
    80020aa0:	6145                	addi	sp,sp,48
    80020aa2:	8082                	ret

0000000080020aa4 <map_int_to_str>:


// We need to store 20 digits, a possible negative sign, and the NULL-terminator
#define STR_KEY_SIZE 64
static char *map_int_to_str(char dst[], long n)
{
    80020aa4:	7139                	addi	sp,sp,-64
    80020aa6:	fc22                	sd	s0,56(sp)
    80020aa8:	0080                	addi	s0,sp,64
    80020aaa:	fca43423          	sd	a0,-56(s0)
    80020aae:	fcb43023          	sd	a1,-64(s0)
    char *const ret = dst;
    80020ab2:	fc843783          	ld	a5,-56(s0)
    80020ab6:	fef43023          	sd	a5,-32(s0)
    int i;
    int j;
    if (n == 0) {
    80020aba:	fc043783          	ld	a5,-64(s0)
    80020abe:	ef99                	bnez	a5,80020adc <map_int_to_str+0x38>
        dst[0] = '0';
    80020ac0:	fc843783          	ld	a5,-56(s0)
    80020ac4:	03000713          	li	a4,48
    80020ac8:	00e78023          	sb	a4,0(a5)
        dst[1] = '\0';
    80020acc:	fc843783          	ld	a5,-56(s0)
    80020ad0:	0785                	addi	a5,a5,1
    80020ad2:	00078023          	sb	zero,0(a5)
        return ret;
    80020ad6:	fe043783          	ld	a5,-32(s0)
    80020ada:	aa29                	j	80020bf4 <map_int_to_str+0x150>
    }
    if (n < 0) {
    80020adc:	fc043783          	ld	a5,-64(s0)
    80020ae0:	0207d263          	bgez	a5,80020b04 <map_int_to_str+0x60>
        // Advance the pointer so that when we flip,
        // we don't flip the negative sign.
        *dst++ = '-';
    80020ae4:	fc843783          	ld	a5,-56(s0)
    80020ae8:	00178713          	addi	a4,a5,1
    80020aec:	fce43423          	sd	a4,-56(s0)
    80020af0:	02d00713          	li	a4,45
    80020af4:	00e78023          	sb	a4,0(a5)
        n = -n;
    80020af8:	fc043783          	ld	a5,-64(s0)
    80020afc:	40f007b3          	neg	a5,a5
    80020b00:	fcf43023          	sd	a5,-64(s0)
    }
    // We can get the one's place by modding by 10, but
    // this stores the number backwards.
    for (i = 0;i < (STR_KEY_SIZE - 2) && n > 0;i += 1, n /= 10) {
    80020b04:	fe042623          	sw	zero,-20(s0)
    80020b08:	a83d                	j	80020b46 <map_int_to_str+0xa2>
        dst[i] = (char)(n % 10) + '0';
    80020b0a:	fc043703          	ld	a4,-64(s0)
    80020b0e:	47a9                	li	a5,10
    80020b10:	02f767b3          	rem	a5,a4,a5
    80020b14:	0ff7f713          	andi	a4,a5,255
    80020b18:	fec42783          	lw	a5,-20(s0)
    80020b1c:	fc843683          	ld	a3,-56(s0)
    80020b20:	97b6                	add	a5,a5,a3
    80020b22:	0307071b          	addiw	a4,a4,48
    80020b26:	0ff77713          	andi	a4,a4,255
    80020b2a:	00e78023          	sb	a4,0(a5)
    for (i = 0;i < (STR_KEY_SIZE - 2) && n > 0;i += 1, n /= 10) {
    80020b2e:	fec42783          	lw	a5,-20(s0)
    80020b32:	2785                	addiw	a5,a5,1
    80020b34:	fef42623          	sw	a5,-20(s0)
    80020b38:	fc043703          	ld	a4,-64(s0)
    80020b3c:	47a9                	li	a5,10
    80020b3e:	02f747b3          	div	a5,a4,a5
    80020b42:	fcf43023          	sd	a5,-64(s0)
    80020b46:	fec42783          	lw	a5,-20(s0)
    80020b4a:	0007871b          	sext.w	a4,a5
    80020b4e:	03d00793          	li	a5,61
    80020b52:	00e7c663          	blt	a5,a4,80020b5e <map_int_to_str+0xba>
    80020b56:	fc043783          	ld	a5,-64(s0)
    80020b5a:	faf048e3          	bgtz	a5,80020b0a <map_int_to_str+0x66>
    }
    // Flip the number back into order.
    for (j = 0;j < i / 2;j+=1) {
    80020b5e:	fe042423          	sw	zero,-24(s0)
    80020b62:	a095                	j	80020bc6 <map_int_to_str+0x122>
        char c;
        c = dst[j];
    80020b64:	fe842783          	lw	a5,-24(s0)
    80020b68:	fc843703          	ld	a4,-56(s0)
    80020b6c:	97ba                	add	a5,a5,a4
    80020b6e:	0007c783          	lbu	a5,0(a5)
    80020b72:	fcf40fa3          	sb	a5,-33(s0)
        dst[j] = dst[i - j - 1];
    80020b76:	fec42703          	lw	a4,-20(s0)
    80020b7a:	fe842783          	lw	a5,-24(s0)
    80020b7e:	40f707bb          	subw	a5,a4,a5
    80020b82:	2781                	sext.w	a5,a5
    80020b84:	17fd                	addi	a5,a5,-1
    80020b86:	fc843703          	ld	a4,-56(s0)
    80020b8a:	973e                	add	a4,a4,a5
    80020b8c:	fe842783          	lw	a5,-24(s0)
    80020b90:	fc843683          	ld	a3,-56(s0)
    80020b94:	97b6                	add	a5,a5,a3
    80020b96:	00074703          	lbu	a4,0(a4) # 6000 <i+0x5fe0>
    80020b9a:	00e78023          	sb	a4,0(a5)
        dst[i - j - 1] = c;
    80020b9e:	fec42703          	lw	a4,-20(s0)
    80020ba2:	fe842783          	lw	a5,-24(s0)
    80020ba6:	40f707bb          	subw	a5,a4,a5
    80020baa:	2781                	sext.w	a5,a5
    80020bac:	17fd                	addi	a5,a5,-1
    80020bae:	fc843703          	ld	a4,-56(s0)
    80020bb2:	97ba                	add	a5,a5,a4
    80020bb4:	fdf44703          	lbu	a4,-33(s0)
    80020bb8:	00e78023          	sb	a4,0(a5)
    for (j = 0;j < i / 2;j+=1) {
    80020bbc:	fe842783          	lw	a5,-24(s0)
    80020bc0:	2785                	addiw	a5,a5,1
    80020bc2:	fef42423          	sw	a5,-24(s0)
    80020bc6:	fec42783          	lw	a5,-20(s0)
    80020bca:	01f7d71b          	srliw	a4,a5,0x1f
    80020bce:	9fb9                	addw	a5,a5,a4
    80020bd0:	4017d79b          	sraiw	a5,a5,0x1
    80020bd4:	0007871b          	sext.w	a4,a5
    80020bd8:	fe842783          	lw	a5,-24(s0)
    80020bdc:	2781                	sext.w	a5,a5
    80020bde:	f8e7c3e3          	blt	a5,a4,80020b64 <map_int_to_str+0xc0>
    }
    dst[i] = '\0';
    80020be2:	fec42783          	lw	a5,-20(s0)
    80020be6:	fc843703          	ld	a4,-56(s0)
    80020bea:	97ba                	add	a5,a5,a4
    80020bec:	00078023          	sb	zero,0(a5)
    return ret;
    80020bf0:	fe043783          	ld	a5,-32(s0)
}
    80020bf4:	853e                	mv	a0,a5
    80020bf6:	7462                	ld	s0,56(sp)
    80020bf8:	6121                	addi	sp,sp,64
    80020bfa:	8082                	ret

0000000080020bfc <map_get_elem>:

static MapElem *map_get_elem(Map *map, const char *key)
{
    80020bfc:	7139                	addi	sp,sp,-64
    80020bfe:	fc06                	sd	ra,56(sp)
    80020c00:	f822                	sd	s0,48(sp)
    80020c02:	0080                	addi	s0,sp,64
    80020c04:	fca43423          	sd	a0,-56(s0)
    80020c08:	fcb43023          	sd	a1,-64(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    80020c0c:	fc043503          	ld	a0,-64(s0)
    80020c10:	e33ff0ef          	jal	ra,80020a42 <fnv1a_digest_64>
    80020c14:	872a                	mv	a4,a0
    80020c16:	fc843783          	ld	a5,-56(s0)
    80020c1a:	439c                	lw	a5,0(a5)
    80020c1c:	1782                	slli	a5,a5,0x20
    80020c1e:	9381                	srli	a5,a5,0x20
    80020c20:	02f777b3          	remu	a5,a4,a5
    80020c24:	fef43023          	sd	a5,-32(s0)
    ListElem *e;
    MapElem *me;

    list_for_each_ascending(map->values[idx], e)
    80020c28:	fc843783          	ld	a5,-56(s0)
    80020c2c:	6798                	ld	a4,8(a5)
    80020c2e:	fe043783          	ld	a5,-32(s0)
    80020c32:	078e                	slli	a5,a5,0x3
    80020c34:	97ba                	add	a5,a5,a4
    80020c36:	639c                	ld	a5,0(a5)
    80020c38:	853e                	mv	a0,a5
    80020c3a:	c1dff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    80020c3e:	fea43423          	sd	a0,-24(s0)
    80020c42:	a81d                	j	80020c78 <map_get_elem+0x7c>
    {
        me = list_elem_value_ptr(e);
    80020c44:	fe843503          	ld	a0,-24(s0)
    80020c48:	c6fff0ef          	jal	ra,800208b6 <list_elem_value>
    80020c4c:	87aa                	mv	a5,a0
    80020c4e:	fcf43c23          	sd	a5,-40(s0)
        if (!strcmp(key, me->key)) {
    80020c52:	fd843783          	ld	a5,-40(s0)
    80020c56:	639c                	ld	a5,0(a5)
    80020c58:	85be                	mv	a1,a5
    80020c5a:	fc043503          	ld	a0,-64(s0)
    80020c5e:	26f010ef          	jal	ra,800226cc <strcmp>
    80020c62:	87aa                	mv	a5,a0
    80020c64:	e781                	bnez	a5,80020c6c <map_get_elem+0x70>
            return me;
    80020c66:	fd843783          	ld	a5,-40(s0)
    80020c6a:	a03d                	j	80020c98 <map_get_elem+0x9c>
    list_for_each_ascending(map->values[idx], e)
    80020c6c:	fe843503          	ld	a0,-24(s0)
    80020c70:	c2fff0ef          	jal	ra,8002089e <list_elem_prev>
    80020c74:	fea43423          	sd	a0,-24(s0)
    80020c78:	fc843783          	ld	a5,-56(s0)
    80020c7c:	6798                	ld	a4,8(a5)
    80020c7e:	fe043783          	ld	a5,-32(s0)
    80020c82:	078e                	slli	a5,a5,0x3
    80020c84:	97ba                	add	a5,a5,a4
    80020c86:	639c                	ld	a5,0(a5)
    80020c88:	fe843583          	ld	a1,-24(s0)
    80020c8c:	853e                	mv	a0,a5
    80020c8e:	b3bff0ef          	jal	ra,800207c8 <list_elem_valid>
    80020c92:	87aa                	mv	a5,a0
    80020c94:	fbc5                	bnez	a5,80020c44 <map_get_elem+0x48>
        }
    }

    return NULL;
    80020c96:	4781                	li	a5,0
}
    80020c98:	853e                	mv	a0,a5
    80020c9a:	70e2                	ld	ra,56(sp)
    80020c9c:	7442                	ld	s0,48(sp)
    80020c9e:	6121                	addi	sp,sp,64
    80020ca0:	8082                	ret

0000000080020ca2 <map_get_celem>:

static const MapElem *map_get_celem(const Map *map, const char *key)
{
    80020ca2:	7139                	addi	sp,sp,-64
    80020ca4:	fc06                	sd	ra,56(sp)
    80020ca6:	f822                	sd	s0,48(sp)
    80020ca8:	0080                	addi	s0,sp,64
    80020caa:	fca43423          	sd	a0,-56(s0)
    80020cae:	fcb43023          	sd	a1,-64(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    80020cb2:	fc043503          	ld	a0,-64(s0)
    80020cb6:	d8dff0ef          	jal	ra,80020a42 <fnv1a_digest_64>
    80020cba:	872a                	mv	a4,a0
    80020cbc:	fc843783          	ld	a5,-56(s0)
    80020cc0:	439c                	lw	a5,0(a5)
    80020cc2:	1782                	slli	a5,a5,0x20
    80020cc4:	9381                	srli	a5,a5,0x20
    80020cc6:	02f777b3          	remu	a5,a4,a5
    80020cca:	fef43023          	sd	a5,-32(s0)
    ListElem *e;
    const MapElem *me;

    list_for_each_ascending(map->values[idx], e)
    80020cce:	fc843783          	ld	a5,-56(s0)
    80020cd2:	6798                	ld	a4,8(a5)
    80020cd4:	fe043783          	ld	a5,-32(s0)
    80020cd8:	078e                	slli	a5,a5,0x3
    80020cda:	97ba                	add	a5,a5,a4
    80020cdc:	639c                	ld	a5,0(a5)
    80020cde:	853e                	mv	a0,a5
    80020ce0:	b77ff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    80020ce4:	fea43423          	sd	a0,-24(s0)
    80020ce8:	a81d                	j	80020d1e <map_get_celem+0x7c>
    {
        me = list_celem_value_ptr(e);
    80020cea:	fe843503          	ld	a0,-24(s0)
    80020cee:	bc9ff0ef          	jal	ra,800208b6 <list_elem_value>
    80020cf2:	87aa                	mv	a5,a0
    80020cf4:	fcf43c23          	sd	a5,-40(s0)
        if (!strcmp(key, me->key)) {
    80020cf8:	fd843783          	ld	a5,-40(s0)
    80020cfc:	639c                	ld	a5,0(a5)
    80020cfe:	85be                	mv	a1,a5
    80020d00:	fc043503          	ld	a0,-64(s0)
    80020d04:	1c9010ef          	jal	ra,800226cc <strcmp>
    80020d08:	87aa                	mv	a5,a0
    80020d0a:	e781                	bnez	a5,80020d12 <map_get_celem+0x70>
            return me;
    80020d0c:	fd843783          	ld	a5,-40(s0)
    80020d10:	a03d                	j	80020d3e <map_get_celem+0x9c>
    list_for_each_ascending(map->values[idx], e)
    80020d12:	fe843503          	ld	a0,-24(s0)
    80020d16:	b89ff0ef          	jal	ra,8002089e <list_elem_prev>
    80020d1a:	fea43423          	sd	a0,-24(s0)
    80020d1e:	fc843783          	ld	a5,-56(s0)
    80020d22:	6798                	ld	a4,8(a5)
    80020d24:	fe043783          	ld	a5,-32(s0)
    80020d28:	078e                	slli	a5,a5,0x3
    80020d2a:	97ba                	add	a5,a5,a4
    80020d2c:	639c                	ld	a5,0(a5)
    80020d2e:	fe843583          	ld	a1,-24(s0)
    80020d32:	853e                	mv	a0,a5
    80020d34:	a95ff0ef          	jal	ra,800207c8 <list_elem_valid>
    80020d38:	87aa                	mv	a5,a0
    80020d3a:	fbc5                	bnez	a5,80020cea <map_get_celem+0x48>
        }
    }

    return NULL;
    80020d3c:	4781                	li	a5,0
}
    80020d3e:	853e                	mv	a0,a5
    80020d40:	70e2                	ld	ra,56(sp)
    80020d42:	7442                	ld	s0,48(sp)
    80020d44:	6121                	addi	sp,sp,64
    80020d46:	8082                	ret

0000000080020d48 <mapelem_set_val>:

static void mapelem_set_val(MapElem *me, MapValue val) {
    80020d48:	1101                	addi	sp,sp,-32
    80020d4a:	ec22                	sd	s0,24(sp)
    80020d4c:	1000                	addi	s0,sp,32
    80020d4e:	fea43423          	sd	a0,-24(s0)
    80020d52:	feb43023          	sd	a1,-32(s0)
    me->val = val;
    80020d56:	fe843783          	ld	a5,-24(s0)
    80020d5a:	fe043703          	ld	a4,-32(s0)
    80020d5e:	e798                	sd	a4,8(a5)
}
    80020d60:	0001                	nop
    80020d62:	6462                	ld	s0,24(sp)
    80020d64:	6105                	addi	sp,sp,32
    80020d66:	8082                	ret

0000000080020d68 <mapelem_new_val>:

static void mapelem_new_val(Map *map, const char *key, MapValue val) {
    80020d68:	7139                	addi	sp,sp,-64
    80020d6a:	fc06                	sd	ra,56(sp)
    80020d6c:	f822                	sd	s0,48(sp)
    80020d6e:	0080                	addi	s0,sp,64
    80020d70:	fca43c23          	sd	a0,-40(s0)
    80020d74:	fcb43823          	sd	a1,-48(s0)
    80020d78:	fcc43423          	sd	a2,-56(s0)
    MapElem *me;
    // If we get here, the key isn't there.
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    80020d7c:	fd043503          	ld	a0,-48(s0)
    80020d80:	cc3ff0ef          	jal	ra,80020a42 <fnv1a_digest_64>
    80020d84:	872a                	mv	a4,a0
    80020d86:	fd843783          	ld	a5,-40(s0)
    80020d8a:	439c                	lw	a5,0(a5)
    80020d8c:	1782                	slli	a5,a5,0x20
    80020d8e:	9381                	srli	a5,a5,0x20
    80020d90:	02f777b3          	remu	a5,a4,a5
    80020d94:	fef43423          	sd	a5,-24(s0)
    me           = (MapElem *)g_kmalloc(sizeof(MapElem));
    80020d98:	4541                	li	a0,16
    80020d9a:	d32ff0ef          	jal	ra,800202cc <g_kmalloc>
    80020d9e:	fea43023          	sd	a0,-32(s0)
    me->key      = strdup(key);
    80020da2:	fd043503          	ld	a0,-48(s0)
    80020da6:	525010ef          	jal	ra,80022aca <strdup>
    80020daa:	872a                	mv	a4,a0
    80020dac:	fe043783          	ld	a5,-32(s0)
    80020db0:	e398                	sd	a4,0(a5)
    me->val      = val;
    80020db2:	fe043783          	ld	a5,-32(s0)
    80020db6:	fc843703          	ld	a4,-56(s0)
    80020dba:	e798                	sd	a4,8(a5)
    list_add_ptr(map->values[idx], me);
    80020dbc:	fd843783          	ld	a5,-40(s0)
    80020dc0:	6798                	ld	a4,8(a5)
    80020dc2:	fe843783          	ld	a5,-24(s0)
    80020dc6:	078e                	slli	a5,a5,0x3
    80020dc8:	97ba                	add	a5,a5,a4
    80020dca:	639c                	ld	a5,0(a5)
    80020dcc:	fe043703          	ld	a4,-32(s0)
    80020dd0:	85ba                	mv	a1,a4
    80020dd2:	853e                	mv	a0,a5
    80020dd4:	e62ff0ef          	jal	ra,80020436 <list_add>
    map->size += 1;
    80020dd8:	fd843783          	ld	a5,-40(s0)
    80020ddc:	43dc                	lw	a5,4(a5)
    80020dde:	2785                	addiw	a5,a5,1
    80020de0:	0007871b          	sext.w	a4,a5
    80020de4:	fd843783          	ld	a5,-40(s0)
    80020de8:	c3d8                	sw	a4,4(a5)
}
    80020dea:	0001                	nop
    80020dec:	70e2                	ld	ra,56(sp)
    80020dee:	7442                	ld	s0,48(sp)
    80020df0:	6121                	addi	sp,sp,64
    80020df2:	8082                	ret

0000000080020df4 <map_init_values>:

static struct List **map_init_values(uint32_t slots) {
    80020df4:	7139                	addi	sp,sp,-64
    80020df6:	fc06                	sd	ra,56(sp)
    80020df8:	f822                	sd	s0,48(sp)
    80020dfa:	f426                	sd	s1,40(sp)
    80020dfc:	0080                	addi	s0,sp,64
    80020dfe:	87aa                	mv	a5,a0
    80020e00:	fcf42623          	sw	a5,-52(s0)
    struct List **lst = (struct List **)g_kcalloc(slots, sizeof(struct List *));
    80020e04:	fcc46783          	lwu	a5,-52(s0)
    80020e08:	45a1                	li	a1,8
    80020e0a:	853e                	mv	a0,a5
    80020e0c:	cf8ff0ef          	jal	ra,80020304 <g_kcalloc>
    80020e10:	fca43823          	sd	a0,-48(s0)
    for (uint32_t i = 0; i < slots; i++) {
    80020e14:	fc042e23          	sw	zero,-36(s0)
    80020e18:	a00d                	j	80020e3a <map_init_values+0x46>
        lst[i] = list_new();
    80020e1a:	fdc46783          	lwu	a5,-36(s0)
    80020e1e:	078e                	slli	a5,a5,0x3
    80020e20:	fd043703          	ld	a4,-48(s0)
    80020e24:	00f704b3          	add	s1,a4,a5
    80020e28:	ddeff0ef          	jal	ra,80020406 <list_new>
    80020e2c:	87aa                	mv	a5,a0
    80020e2e:	e09c                	sd	a5,0(s1)
    for (uint32_t i = 0; i < slots; i++) {
    80020e30:	fdc42783          	lw	a5,-36(s0)
    80020e34:	2785                	addiw	a5,a5,1
    80020e36:	fcf42e23          	sw	a5,-36(s0)
    80020e3a:	fdc42703          	lw	a4,-36(s0)
    80020e3e:	fcc42783          	lw	a5,-52(s0)
    80020e42:	2701                	sext.w	a4,a4
    80020e44:	2781                	sext.w	a5,a5
    80020e46:	fcf76ae3          	bltu	a4,a5,80020e1a <map_init_values+0x26>
    }
    return lst;
    80020e4a:	fd043783          	ld	a5,-48(s0)
}
    80020e4e:	853e                	mv	a0,a5
    80020e50:	70e2                	ld	ra,56(sp)
    80020e52:	7442                	ld	s0,48(sp)
    80020e54:	74a2                	ld	s1,40(sp)
    80020e56:	6121                	addi	sp,sp,64
    80020e58:	8082                	ret

0000000080020e5a <map_elem_free>:

static void map_elem_free(MapElem *me) {
    80020e5a:	1101                	addi	sp,sp,-32
    80020e5c:	ec06                	sd	ra,24(sp)
    80020e5e:	e822                	sd	s0,16(sp)
    80020e60:	1000                	addi	s0,sp,32
    80020e62:	fea43423          	sd	a0,-24(s0)
    g_kfree(me->key);
    80020e66:	fe843783          	ld	a5,-24(s0)
    80020e6a:	639c                	ld	a5,0(a5)
    80020e6c:	853e                	mv	a0,a5
    80020e6e:	cf8ff0ef          	jal	ra,80020366 <g_kfree>
    g_kfree(me);
    80020e72:	fe843503          	ld	a0,-24(s0)
    80020e76:	cf0ff0ef          	jal	ra,80020366 <g_kfree>
}
    80020e7a:	0001                	nop
    80020e7c:	60e2                	ld	ra,24(sp)
    80020e7e:	6442                	ld	s0,16(sp)
    80020e80:	6105                	addi	sp,sp,32
    80020e82:	8082                	ret

0000000080020e84 <map_lst_free>:

static void map_lst_free(ListElem *e) {
    80020e84:	1101                	addi	sp,sp,-32
    80020e86:	ec06                	sd	ra,24(sp)
    80020e88:	e822                	sd	s0,16(sp)
    80020e8a:	1000                	addi	s0,sp,32
    80020e8c:	fea43423          	sd	a0,-24(s0)
    map_elem_free(list_elem_value_ptr(e));
    80020e90:	fe843503          	ld	a0,-24(s0)
    80020e94:	a23ff0ef          	jal	ra,800208b6 <list_elem_value>
    80020e98:	87aa                	mv	a5,a0
    80020e9a:	853e                	mv	a0,a5
    80020e9c:	fbfff0ef          	jal	ra,80020e5a <map_elem_free>
    list_remove_elem(e);
    80020ea0:	fe843503          	ld	a0,-24(s0)
    80020ea4:	f34ff0ef          	jal	ra,800205d8 <list_remove_elem>
}
    80020ea8:	0001                	nop
    80020eaa:	60e2                	ld	ra,24(sp)
    80020eac:	6442                	ld	s0,16(sp)
    80020eae:	6105                	addi	sp,sp,32
    80020eb0:	8082                	ret

0000000080020eb2 <map_init>:

static Map *map_init(Map *map, uint32_t slots)
{
    80020eb2:	1101                	addi	sp,sp,-32
    80020eb4:	ec06                	sd	ra,24(sp)
    80020eb6:	e822                	sd	s0,16(sp)
    80020eb8:	1000                	addi	s0,sp,32
    80020eba:	fea43423          	sd	a0,-24(s0)
    80020ebe:	87ae                	mv	a5,a1
    80020ec0:	fef42223          	sw	a5,-28(s0)
    if (map == NULL) {
    80020ec4:	fe843783          	ld	a5,-24(s0)
    80020ec8:	e399                	bnez	a5,80020ece <map_init+0x1c>
        return NULL;
    80020eca:	4781                	li	a5,0
    80020ecc:	a805                	j	80020efc <map_init+0x4a>
    }

    map->slots  = slots == 0 ? 1 : slots;
    80020ece:	fe442783          	lw	a5,-28(s0)
    80020ed2:	2781                	sext.w	a5,a5
    80020ed4:	c781                	beqz	a5,80020edc <map_init+0x2a>
    80020ed6:	fe442783          	lw	a5,-28(s0)
    80020eda:	a011                	j	80020ede <map_init+0x2c>
    80020edc:	4785                	li	a5,1
    80020ede:	fe843703          	ld	a4,-24(s0)
    80020ee2:	c31c                	sw	a5,0(a4)
    map->values = map_init_values(map->slots);
    80020ee4:	fe843783          	ld	a5,-24(s0)
    80020ee8:	439c                	lw	a5,0(a5)
    80020eea:	853e                	mv	a0,a5
    80020eec:	f09ff0ef          	jal	ra,80020df4 <map_init_values>
    80020ef0:	872a                	mv	a4,a0
    80020ef2:	fe843783          	ld	a5,-24(s0)
    80020ef6:	e798                	sd	a4,8(a5)
    return map;
    80020ef8:	fe843783          	ld	a5,-24(s0)
}
    80020efc:	853e                	mv	a0,a5
    80020efe:	60e2                	ld	ra,24(sp)
    80020f00:	6442                	ld	s0,16(sp)
    80020f02:	6105                	addi	sp,sp,32
    80020f04:	8082                	ret

0000000080020f06 <map_new>:

Map *map_new(void)
{
    80020f06:	1141                	addi	sp,sp,-16
    80020f08:	e406                	sd	ra,8(sp)
    80020f0a:	e022                	sd	s0,0(sp)
    80020f0c:	0800                	addi	s0,sp,16
    return map_new_with_slots(DEFAULT_MAP_SIZE);
    80020f0e:	04000513          	li	a0,64
    80020f12:	010000ef          	jal	ra,80020f22 <map_new_with_slots>
    80020f16:	87aa                	mv	a5,a0
}
    80020f18:	853e                	mv	a0,a5
    80020f1a:	60a2                	ld	ra,8(sp)
    80020f1c:	6402                	ld	s0,0(sp)
    80020f1e:	0141                	addi	sp,sp,16
    80020f20:	8082                	ret

0000000080020f22 <map_new_with_slots>:

Map *map_new_with_slots(uint32_t slots)
{
    80020f22:	1101                	addi	sp,sp,-32
    80020f24:	ec06                	sd	ra,24(sp)
    80020f26:	e822                	sd	s0,16(sp)
    80020f28:	1000                	addi	s0,sp,32
    80020f2a:	87aa                	mv	a5,a0
    80020f2c:	fef42623          	sw	a5,-20(s0)
    if (slots == 0) {
    80020f30:	fec42783          	lw	a5,-20(s0)
    80020f34:	2781                	sext.w	a5,a5
    80020f36:	e399                	bnez	a5,80020f3c <map_new_with_slots+0x1a>
        return NULL;
    80020f38:	4781                	li	a5,0
    80020f3a:	a821                	j	80020f52 <map_new_with_slots+0x30>
    }
    return map_init((Map *)g_kmalloc(sizeof(Map)), slots);
    80020f3c:	4541                	li	a0,16
    80020f3e:	b8eff0ef          	jal	ra,800202cc <g_kmalloc>
    80020f42:	872a                	mv	a4,a0
    80020f44:	fec42783          	lw	a5,-20(s0)
    80020f48:	85be                	mv	a1,a5
    80020f4a:	853a                	mv	a0,a4
    80020f4c:	f67ff0ef          	jal	ra,80020eb2 <map_init>
    80020f50:	87aa                	mv	a5,a0
}
    80020f52:	853e                	mv	a0,a5
    80020f54:	60e2                	ld	ra,24(sp)
    80020f56:	6442                	ld	s0,16(sp)
    80020f58:	6105                	addi	sp,sp,32
    80020f5a:	8082                	ret

0000000080020f5c <map_slots>:


uint32_t map_slots(const Map *map)
{
    80020f5c:	1101                	addi	sp,sp,-32
    80020f5e:	ec22                	sd	s0,24(sp)
    80020f60:	1000                	addi	s0,sp,32
    80020f62:	fea43423          	sd	a0,-24(s0)
    return map->slots;
    80020f66:	fe843783          	ld	a5,-24(s0)
    80020f6a:	439c                	lw	a5,0(a5)
}
    80020f6c:	853e                	mv	a0,a5
    80020f6e:	6462                	ld	s0,24(sp)
    80020f70:	6105                	addi	sp,sp,32
    80020f72:	8082                	ret

0000000080020f74 <map_size>:

uint32_t map_size(const Map *map)
{
    80020f74:	1101                	addi	sp,sp,-32
    80020f76:	ec22                	sd	s0,24(sp)
    80020f78:	1000                	addi	s0,sp,32
    80020f7a:	fea43423          	sd	a0,-24(s0)
    return map->size;
    80020f7e:	fe843783          	ld	a5,-24(s0)
    80020f82:	43dc                	lw	a5,4(a5)
}
    80020f84:	853e                	mv	a0,a5
    80020f86:	6462                	ld	s0,24(sp)
    80020f88:	6105                	addi	sp,sp,32
    80020f8a:	8082                	ret

0000000080020f8c <map_set>:

void map_set(Map *map, const char *key, MapValue val)
{
    80020f8c:	7139                	addi	sp,sp,-64
    80020f8e:	fc06                	sd	ra,56(sp)
    80020f90:	f822                	sd	s0,48(sp)
    80020f92:	0080                	addi	s0,sp,64
    80020f94:	fca43c23          	sd	a0,-40(s0)
    80020f98:	fcb43823          	sd	a1,-48(s0)
    80020f9c:	fcc43423          	sd	a2,-56(s0)
    MapElem *me = map_get_elem(map, key);
    80020fa0:	fd043583          	ld	a1,-48(s0)
    80020fa4:	fd843503          	ld	a0,-40(s0)
    80020fa8:	c55ff0ef          	jal	ra,80020bfc <map_get_elem>
    80020fac:	fea43423          	sd	a0,-24(s0)
    if (me != NULL) {
    80020fb0:	fe843783          	ld	a5,-24(s0)
    80020fb4:	cb81                	beqz	a5,80020fc4 <map_set+0x38>
        mapelem_set_val(me, val);
    80020fb6:	fc843583          	ld	a1,-56(s0)
    80020fba:	fe843503          	ld	a0,-24(s0)
    80020fbe:	d8bff0ef          	jal	ra,80020d48 <mapelem_set_val>
    }
    else {
        mapelem_new_val(map, key, val);
    }
}
    80020fc2:	a809                	j	80020fd4 <map_set+0x48>
        mapelem_new_val(map, key, val);
    80020fc4:	fc843603          	ld	a2,-56(s0)
    80020fc8:	fd043583          	ld	a1,-48(s0)
    80020fcc:	fd843503          	ld	a0,-40(s0)
    80020fd0:	d99ff0ef          	jal	ra,80020d68 <mapelem_new_val>
}
    80020fd4:	0001                	nop
    80020fd6:	70e2                	ld	ra,56(sp)
    80020fd8:	7442                	ld	s0,48(sp)
    80020fda:	6121                	addi	sp,sp,64
    80020fdc:	8082                	ret

0000000080020fde <map_set_int>:

void map_set_int(Map *map, long ikey, MapValue val)
{
    80020fde:	7159                	addi	sp,sp,-112
    80020fe0:	f486                	sd	ra,104(sp)
    80020fe2:	f0a2                	sd	s0,96(sp)
    80020fe4:	1880                	addi	s0,sp,112
    80020fe6:	faa43423          	sd	a0,-88(s0)
    80020fea:	fab43023          	sd	a1,-96(s0)
    80020fee:	f8c43c23          	sd	a2,-104(s0)
    char key[STR_KEY_SIZE];
    map_set(map, map_int_to_str(key, ikey), val);
    80020ff2:	fb040793          	addi	a5,s0,-80
    80020ff6:	fa043583          	ld	a1,-96(s0)
    80020ffa:	853e                	mv	a0,a5
    80020ffc:	aa9ff0ef          	jal	ra,80020aa4 <map_int_to_str>
    80021000:	87aa                	mv	a5,a0
    80021002:	f9843603          	ld	a2,-104(s0)
    80021006:	85be                	mv	a1,a5
    80021008:	fa843503          	ld	a0,-88(s0)
    8002100c:	f81ff0ef          	jal	ra,80020f8c <map_set>
}
    80021010:	0001                	nop
    80021012:	70a6                	ld	ra,104(sp)
    80021014:	7406                	ld	s0,96(sp)
    80021016:	6165                	addi	sp,sp,112
    80021018:	8082                	ret

000000008002101a <map_get_unchecked>:

MapValue map_get_unchecked(const Map *map, const char *key)
{
    8002101a:	7179                	addi	sp,sp,-48
    8002101c:	f406                	sd	ra,40(sp)
    8002101e:	f022                	sd	s0,32(sp)
    80021020:	1800                	addi	s0,sp,48
    80021022:	fca43c23          	sd	a0,-40(s0)
    80021026:	fcb43823          	sd	a1,-48(s0)
    MapValue ret = 0;
    8002102a:	fe043423          	sd	zero,-24(s0)
    map_get(map, key, &ret);
    8002102e:	fe840793          	addi	a5,s0,-24
    80021032:	863e                	mv	a2,a5
    80021034:	fd043583          	ld	a1,-48(s0)
    80021038:	fd843503          	ld	a0,-40(s0)
    8002103c:	012000ef          	jal	ra,8002104e <map_get>
    return ret;
    80021040:	fe843783          	ld	a5,-24(s0)
}
    80021044:	853e                	mv	a0,a5
    80021046:	70a2                	ld	ra,40(sp)
    80021048:	7402                	ld	s0,32(sp)
    8002104a:	6145                	addi	sp,sp,48
    8002104c:	8082                	ret

000000008002104e <map_get>:

bool map_get(const Map *map, const char *key, MapValue *value)
{
    8002104e:	7139                	addi	sp,sp,-64
    80021050:	fc06                	sd	ra,56(sp)
    80021052:	f822                	sd	s0,48(sp)
    80021054:	0080                	addi	s0,sp,64
    80021056:	fca43c23          	sd	a0,-40(s0)
    8002105a:	fcb43823          	sd	a1,-48(s0)
    8002105e:	fcc43423          	sd	a2,-56(s0)
    const MapElem *me = map_get_celem(map, key);
    80021062:	fd043583          	ld	a1,-48(s0)
    80021066:	fd843503          	ld	a0,-40(s0)
    8002106a:	c39ff0ef          	jal	ra,80020ca2 <map_get_celem>
    8002106e:	fea43423          	sd	a0,-24(s0)
    if (me == NULL) {
    80021072:	fe843783          	ld	a5,-24(s0)
    80021076:	e399                	bnez	a5,8002107c <map_get+0x2e>
        return false;
    80021078:	4781                	li	a5,0
    8002107a:	a819                	j	80021090 <map_get+0x42>
    }
    if (value != NULL) {
    8002107c:	fc843783          	ld	a5,-56(s0)
    80021080:	c799                	beqz	a5,8002108e <map_get+0x40>
        *value = me->val;
    80021082:	fe843783          	ld	a5,-24(s0)
    80021086:	6798                	ld	a4,8(a5)
    80021088:	fc843783          	ld	a5,-56(s0)
    8002108c:	e398                	sd	a4,0(a5)
    }
    return true;
    8002108e:	4785                	li	a5,1
}
    80021090:	853e                	mv	a0,a5
    80021092:	70e2                	ld	ra,56(sp)
    80021094:	7442                	ld	s0,48(sp)
    80021096:	6121                	addi	sp,sp,64
    80021098:	8082                	ret

000000008002109a <map_get_int>:

bool map_get_int(const Map *map, long ikey, MapValue *value)
{
    8002109a:	7159                	addi	sp,sp,-112
    8002109c:	f486                	sd	ra,104(sp)
    8002109e:	f0a2                	sd	s0,96(sp)
    800210a0:	1880                	addi	s0,sp,112
    800210a2:	faa43423          	sd	a0,-88(s0)
    800210a6:	fab43023          	sd	a1,-96(s0)
    800210aa:	f8c43c23          	sd	a2,-104(s0)
    char key[STR_KEY_SIZE];
    return map_get(map, map_int_to_str(key, ikey), value);
    800210ae:	fb040793          	addi	a5,s0,-80
    800210b2:	fa043583          	ld	a1,-96(s0)
    800210b6:	853e                	mv	a0,a5
    800210b8:	9edff0ef          	jal	ra,80020aa4 <map_int_to_str>
    800210bc:	87aa                	mv	a5,a0
    800210be:	f9843603          	ld	a2,-104(s0)
    800210c2:	85be                	mv	a1,a5
    800210c4:	fa843503          	ld	a0,-88(s0)
    800210c8:	f87ff0ef          	jal	ra,8002104e <map_get>
    800210cc:	87aa                	mv	a5,a0
}
    800210ce:	853e                	mv	a0,a5
    800210d0:	70a6                	ld	ra,104(sp)
    800210d2:	7406                	ld	s0,96(sp)
    800210d4:	6165                	addi	sp,sp,112
    800210d6:	8082                	ret

00000000800210d8 <map_contains>:

bool map_contains(const Map *map, const char *key)
{
    800210d8:	1101                	addi	sp,sp,-32
    800210da:	ec06                	sd	ra,24(sp)
    800210dc:	e822                	sd	s0,16(sp)
    800210de:	1000                	addi	s0,sp,32
    800210e0:	fea43423          	sd	a0,-24(s0)
    800210e4:	feb43023          	sd	a1,-32(s0)
    return map_get(map, key, NULL);
    800210e8:	4601                	li	a2,0
    800210ea:	fe043583          	ld	a1,-32(s0)
    800210ee:	fe843503          	ld	a0,-24(s0)
    800210f2:	f5dff0ef          	jal	ra,8002104e <map_get>
    800210f6:	87aa                	mv	a5,a0
}
    800210f8:	853e                	mv	a0,a5
    800210fa:	60e2                	ld	ra,24(sp)
    800210fc:	6442                	ld	s0,16(sp)
    800210fe:	6105                	addi	sp,sp,32
    80021100:	8082                	ret

0000000080021102 <map_contains_int>:

bool map_contains_int(const struct Map *map, long ikey)
{
    80021102:	1101                	addi	sp,sp,-32
    80021104:	ec06                	sd	ra,24(sp)
    80021106:	e822                	sd	s0,16(sp)
    80021108:	1000                	addi	s0,sp,32
    8002110a:	fea43423          	sd	a0,-24(s0)
    8002110e:	feb43023          	sd	a1,-32(s0)
    return map_get_int(map, ikey, NULL);
    80021112:	4601                	li	a2,0
    80021114:	fe043583          	ld	a1,-32(s0)
    80021118:	fe843503          	ld	a0,-24(s0)
    8002111c:	f7fff0ef          	jal	ra,8002109a <map_get_int>
    80021120:	87aa                	mv	a5,a0
}
    80021122:	853e                	mv	a0,a5
    80021124:	60e2                	ld	ra,24(sp)
    80021126:	6442                	ld	s0,16(sp)
    80021128:	6105                	addi	sp,sp,32
    8002112a:	8082                	ret

000000008002112c <map_remove>:

bool map_remove(Map *map, const char *key)
{
    8002112c:	7179                	addi	sp,sp,-48
    8002112e:	f406                	sd	ra,40(sp)
    80021130:	f022                	sd	s0,32(sp)
    80021132:	1800                	addi	s0,sp,48
    80021134:	fca43c23          	sd	a0,-40(s0)
    80021138:	fcb43823          	sd	a1,-48(s0)
    uint64_t idx = fnv1a_digest_64(key) % map->slots;
    8002113c:	fd043503          	ld	a0,-48(s0)
    80021140:	903ff0ef          	jal	ra,80020a42 <fnv1a_digest_64>
    80021144:	872a                	mv	a4,a0
    80021146:	fd843783          	ld	a5,-40(s0)
    8002114a:	439c                	lw	a5,0(a5)
    8002114c:	1782                	slli	a5,a5,0x20
    8002114e:	9381                	srli	a5,a5,0x20
    80021150:	02f777b3          	remu	a5,a4,a5
    80021154:	fef43023          	sd	a5,-32(s0)
    ListElem *e;

    list_for_each_ascending(map->values[idx], e)
    80021158:	fd843783          	ld	a5,-40(s0)
    8002115c:	6798                	ld	a4,8(a5)
    8002115e:	fe043783          	ld	a5,-32(s0)
    80021162:	078e                	slli	a5,a5,0x3
    80021164:	97ba                	add	a5,a5,a4
    80021166:	639c                	ld	a5,0(a5)
    80021168:	853e                	mv	a0,a5
    8002116a:	eecff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    8002116e:	fea43423          	sd	a0,-24(s0)
    80021172:	a099                	j	800211b8 <map_remove+0x8c>
    {
        if (!strcmp(key, ((MapElem *)list_elem_value(e))->key)) {
    80021174:	fe843503          	ld	a0,-24(s0)
    80021178:	f3eff0ef          	jal	ra,800208b6 <list_elem_value>
    8002117c:	87aa                	mv	a5,a0
    8002117e:	639c                	ld	a5,0(a5)
    80021180:	85be                	mv	a1,a5
    80021182:	fd043503          	ld	a0,-48(s0)
    80021186:	546010ef          	jal	ra,800226cc <strcmp>
    8002118a:	87aa                	mv	a5,a0
    8002118c:	e385                	bnez	a5,800211ac <map_remove+0x80>
            map_lst_free(e);
    8002118e:	fe843503          	ld	a0,-24(s0)
    80021192:	cf3ff0ef          	jal	ra,80020e84 <map_lst_free>
            map->size -= 1;
    80021196:	fd843783          	ld	a5,-40(s0)
    8002119a:	43dc                	lw	a5,4(a5)
    8002119c:	37fd                	addiw	a5,a5,-1
    8002119e:	0007871b          	sext.w	a4,a5
    800211a2:	fd843783          	ld	a5,-40(s0)
    800211a6:	c3d8                	sw	a4,4(a5)
            return true;
    800211a8:	4785                	li	a5,1
    800211aa:	a03d                	j	800211d8 <map_remove+0xac>
    list_for_each_ascending(map->values[idx], e)
    800211ac:	fe843503          	ld	a0,-24(s0)
    800211b0:	eeeff0ef          	jal	ra,8002089e <list_elem_prev>
    800211b4:	fea43423          	sd	a0,-24(s0)
    800211b8:	fd843783          	ld	a5,-40(s0)
    800211bc:	6798                	ld	a4,8(a5)
    800211be:	fe043783          	ld	a5,-32(s0)
    800211c2:	078e                	slli	a5,a5,0x3
    800211c4:	97ba                	add	a5,a5,a4
    800211c6:	639c                	ld	a5,0(a5)
    800211c8:	fe843583          	ld	a1,-24(s0)
    800211cc:	853e                	mv	a0,a5
    800211ce:	dfaff0ef          	jal	ra,800207c8 <list_elem_valid>
    800211d2:	87aa                	mv	a5,a0
    800211d4:	f3c5                	bnez	a5,80021174 <map_remove+0x48>
        }
    }
    return false;
    800211d6:	4781                	li	a5,0
}
    800211d8:	853e                	mv	a0,a5
    800211da:	70a2                	ld	ra,40(sp)
    800211dc:	7402                	ld	s0,32(sp)
    800211de:	6145                	addi	sp,sp,48
    800211e0:	8082                	ret

00000000800211e2 <map_remove_int>:

bool map_remove_int(Map *map, long ikey)
{
    800211e2:	711d                	addi	sp,sp,-96
    800211e4:	ec86                	sd	ra,88(sp)
    800211e6:	e8a2                	sd	s0,80(sp)
    800211e8:	1080                	addi	s0,sp,96
    800211ea:	faa43423          	sd	a0,-88(s0)
    800211ee:	fab43023          	sd	a1,-96(s0)
    char key[STR_KEY_SIZE];
    return map_remove(map, map_int_to_str(key, ikey));
    800211f2:	fb040793          	addi	a5,s0,-80
    800211f6:	fa043583          	ld	a1,-96(s0)
    800211fa:	853e                	mv	a0,a5
    800211fc:	8a9ff0ef          	jal	ra,80020aa4 <map_int_to_str>
    80021200:	87aa                	mv	a5,a0
    80021202:	85be                	mv	a1,a5
    80021204:	fa843503          	ld	a0,-88(s0)
    80021208:	f25ff0ef          	jal	ra,8002112c <map_remove>
    8002120c:	87aa                	mv	a5,a0
}
    8002120e:	853e                	mv	a0,a5
    80021210:	60e6                	ld	ra,88(sp)
    80021212:	6446                	ld	s0,80(sp)
    80021214:	6125                	addi	sp,sp,96
    80021216:	8082                	ret

0000000080021218 <map_clear>:

void map_clear(Map *map)
{
    80021218:	7179                	addi	sp,sp,-48
    8002121a:	f406                	sd	ra,40(sp)
    8002121c:	f022                	sd	s0,32(sp)
    8002121e:	1800                	addi	s0,sp,48
    80021220:	fca43c23          	sd	a0,-40(s0)
    uint32_t i;
    ListElem *e;

    for (i = 0; i < map->slots; i++) {
    80021224:	fe042623          	sw	zero,-20(s0)
    80021228:	a8a9                	j	80021282 <map_clear+0x6a>
        list_for_each_ascending(map->values[i], e)
    8002122a:	fd843783          	ld	a5,-40(s0)
    8002122e:	6798                	ld	a4,8(a5)
    80021230:	fec46783          	lwu	a5,-20(s0)
    80021234:	078e                	slli	a5,a5,0x3
    80021236:	97ba                	add	a5,a5,a4
    80021238:	639c                	ld	a5,0(a5)
    8002123a:	853e                	mv	a0,a5
    8002123c:	e1aff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    80021240:	fea43023          	sd	a0,-32(s0)
    80021244:	a819                	j	8002125a <map_clear+0x42>
        {
            map_lst_free(e);
    80021246:	fe043503          	ld	a0,-32(s0)
    8002124a:	c3bff0ef          	jal	ra,80020e84 <map_lst_free>
        list_for_each_ascending(map->values[i], e)
    8002124e:	fe043503          	ld	a0,-32(s0)
    80021252:	e4cff0ef          	jal	ra,8002089e <list_elem_prev>
    80021256:	fea43023          	sd	a0,-32(s0)
    8002125a:	fd843783          	ld	a5,-40(s0)
    8002125e:	6798                	ld	a4,8(a5)
    80021260:	fec46783          	lwu	a5,-20(s0)
    80021264:	078e                	slli	a5,a5,0x3
    80021266:	97ba                	add	a5,a5,a4
    80021268:	639c                	ld	a5,0(a5)
    8002126a:	fe043583          	ld	a1,-32(s0)
    8002126e:	853e                	mv	a0,a5
    80021270:	d58ff0ef          	jal	ra,800207c8 <list_elem_valid>
    80021274:	87aa                	mv	a5,a0
    80021276:	fbe1                	bnez	a5,80021246 <map_clear+0x2e>
    for (i = 0; i < map->slots; i++) {
    80021278:	fec42783          	lw	a5,-20(s0)
    8002127c:	2785                	addiw	a5,a5,1
    8002127e:	fef42623          	sw	a5,-20(s0)
    80021282:	fd843783          	ld	a5,-40(s0)
    80021286:	4398                	lw	a4,0(a5)
    80021288:	fec42783          	lw	a5,-20(s0)
    8002128c:	2781                	sext.w	a5,a5
    8002128e:	f8e7eee3          	bltu	a5,a4,8002122a <map_clear+0x12>
        }
    }
    map->size = 0;
    80021292:	fd843783          	ld	a5,-40(s0)
    80021296:	0007a223          	sw	zero,4(a5)
}
    8002129a:	0001                	nop
    8002129c:	70a2                	ld	ra,40(sp)
    8002129e:	7402                	ld	s0,32(sp)
    800212a0:	6145                	addi	sp,sp,48
    800212a2:	8082                	ret

00000000800212a4 <map_free>:

void map_free(Map *map)
{
    800212a4:	7179                	addi	sp,sp,-48
    800212a6:	f406                	sd	ra,40(sp)
    800212a8:	f022                	sd	s0,32(sp)
    800212aa:	1800                	addi	s0,sp,48
    800212ac:	fca43c23          	sd	a0,-40(s0)
    uint32_t i;
    ListElem *e;

    if (map == NULL) {
    800212b0:	fd843783          	ld	a5,-40(s0)
    800212b4:	c3d5                	beqz	a5,80021358 <map_free+0xb4>
        return;
    }
    for (i = 0; i < map->slots; i++) {
    800212b6:	fe042623          	sw	zero,-20(s0)
    800212ba:	a885                	j	8002132a <map_free+0x86>
        list_for_each_ascending(map->values[i], e)
    800212bc:	fd843783          	ld	a5,-40(s0)
    800212c0:	6798                	ld	a4,8(a5)
    800212c2:	fec46783          	lwu	a5,-20(s0)
    800212c6:	078e                	slli	a5,a5,0x3
    800212c8:	97ba                	add	a5,a5,a4
    800212ca:	639c                	ld	a5,0(a5)
    800212cc:	853e                	mv	a0,a5
    800212ce:	d88ff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    800212d2:	fea43023          	sd	a0,-32(s0)
    800212d6:	a819                	j	800212ec <map_free+0x48>
        {
            map_lst_free(e);
    800212d8:	fe043503          	ld	a0,-32(s0)
    800212dc:	ba9ff0ef          	jal	ra,80020e84 <map_lst_free>
        list_for_each_ascending(map->values[i], e)
    800212e0:	fe043503          	ld	a0,-32(s0)
    800212e4:	dbaff0ef          	jal	ra,8002089e <list_elem_prev>
    800212e8:	fea43023          	sd	a0,-32(s0)
    800212ec:	fd843783          	ld	a5,-40(s0)
    800212f0:	6798                	ld	a4,8(a5)
    800212f2:	fec46783          	lwu	a5,-20(s0)
    800212f6:	078e                	slli	a5,a5,0x3
    800212f8:	97ba                	add	a5,a5,a4
    800212fa:	639c                	ld	a5,0(a5)
    800212fc:	fe043583          	ld	a1,-32(s0)
    80021300:	853e                	mv	a0,a5
    80021302:	cc6ff0ef          	jal	ra,800207c8 <list_elem_valid>
    80021306:	87aa                	mv	a5,a0
    80021308:	fbe1                	bnez	a5,800212d8 <map_free+0x34>
        }
        list_free(map->values[i]);
    8002130a:	fd843783          	ld	a5,-40(s0)
    8002130e:	6798                	ld	a4,8(a5)
    80021310:	fec46783          	lwu	a5,-20(s0)
    80021314:	078e                	slli	a5,a5,0x3
    80021316:	97ba                	add	a5,a5,a4
    80021318:	639c                	ld	a5,0(a5)
    8002131a:	853e                	mv	a0,a5
    8002131c:	c54ff0ef          	jal	ra,80020770 <list_free>
    for (i = 0; i < map->slots; i++) {
    80021320:	fec42783          	lw	a5,-20(s0)
    80021324:	2785                	addiw	a5,a5,1
    80021326:	fef42623          	sw	a5,-20(s0)
    8002132a:	fd843783          	ld	a5,-40(s0)
    8002132e:	4398                	lw	a4,0(a5)
    80021330:	fec42783          	lw	a5,-20(s0)
    80021334:	2781                	sext.w	a5,a5
    80021336:	f8e7e3e3          	bltu	a5,a4,800212bc <map_free+0x18>
    }
    g_kfree(map->values);
    8002133a:	fd843783          	ld	a5,-40(s0)
    8002133e:	679c                	ld	a5,8(a5)
    80021340:	853e                	mv	a0,a5
    80021342:	824ff0ef          	jal	ra,80020366 <g_kfree>
    map->size = 0;
    80021346:	fd843783          	ld	a5,-40(s0)
    8002134a:	0007a223          	sw	zero,4(a5)
    g_kfree(map);
    8002134e:	fd843503          	ld	a0,-40(s0)
    80021352:	814ff0ef          	jal	ra,80020366 <g_kfree>
    80021356:	a011                	j	8002135a <map_free+0xb6>
        return;
    80021358:	0001                	nop
}
    8002135a:	70a2                	ld	ra,40(sp)
    8002135c:	7402                	ld	s0,32(sp)
    8002135e:	6145                	addi	sp,sp,48
    80021360:	8082                	ret

0000000080021362 <map_get_keys>:

struct List *map_get_keys(const Map *map) {
    80021362:	7139                	addi	sp,sp,-64
    80021364:	fc06                	sd	ra,56(sp)
    80021366:	f822                	sd	s0,48(sp)
    80021368:	0080                	addi	s0,sp,64
    8002136a:	fca43423          	sd	a0,-56(s0)
    uint32_t i;
    ListElem *e;
    struct List *ret = list_new();
    8002136e:	898ff0ef          	jal	ra,80020406 <list_new>
    80021372:	fca43c23          	sd	a0,-40(s0)

    for (i = 0;i < map->slots;i++) {
    80021376:	fe042623          	sw	zero,-20(s0)
    8002137a:	a885                	j	800213ea <map_get_keys+0x88>
        list_for_each_ascending(map->values[i], e) {
    8002137c:	fc843783          	ld	a5,-56(s0)
    80021380:	6798                	ld	a4,8(a5)
    80021382:	fec46783          	lwu	a5,-20(s0)
    80021386:	078e                	slli	a5,a5,0x3
    80021388:	97ba                	add	a5,a5,a4
    8002138a:	639c                	ld	a5,0(a5)
    8002138c:	853e                	mv	a0,a5
    8002138e:	cc8ff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    80021392:	fea43023          	sd	a0,-32(s0)
    80021396:	a035                	j	800213c2 <map_get_keys+0x60>
            list_add(ret, (uint64_t)strdup(((MapElem *)list_elem_value(e))->key));
    80021398:	fe043503          	ld	a0,-32(s0)
    8002139c:	d1aff0ef          	jal	ra,800208b6 <list_elem_value>
    800213a0:	87aa                	mv	a5,a0
    800213a2:	639c                	ld	a5,0(a5)
    800213a4:	853e                	mv	a0,a5
    800213a6:	724010ef          	jal	ra,80022aca <strdup>
    800213aa:	87aa                	mv	a5,a0
    800213ac:	85be                	mv	a1,a5
    800213ae:	fd843503          	ld	a0,-40(s0)
    800213b2:	884ff0ef          	jal	ra,80020436 <list_add>
        list_for_each_ascending(map->values[i], e) {
    800213b6:	fe043503          	ld	a0,-32(s0)
    800213ba:	ce4ff0ef          	jal	ra,8002089e <list_elem_prev>
    800213be:	fea43023          	sd	a0,-32(s0)
    800213c2:	fc843783          	ld	a5,-56(s0)
    800213c6:	6798                	ld	a4,8(a5)
    800213c8:	fec46783          	lwu	a5,-20(s0)
    800213cc:	078e                	slli	a5,a5,0x3
    800213ce:	97ba                	add	a5,a5,a4
    800213d0:	639c                	ld	a5,0(a5)
    800213d2:	fe043583          	ld	a1,-32(s0)
    800213d6:	853e                	mv	a0,a5
    800213d8:	bf0ff0ef          	jal	ra,800207c8 <list_elem_valid>
    800213dc:	87aa                	mv	a5,a0
    800213de:	ffcd                	bnez	a5,80021398 <map_get_keys+0x36>
    for (i = 0;i < map->slots;i++) {
    800213e0:	fec42783          	lw	a5,-20(s0)
    800213e4:	2785                	addiw	a5,a5,1
    800213e6:	fef42623          	sw	a5,-20(s0)
    800213ea:	fc843783          	ld	a5,-56(s0)
    800213ee:	4398                	lw	a4,0(a5)
    800213f0:	fec42783          	lw	a5,-20(s0)
    800213f4:	2781                	sext.w	a5,a5
    800213f6:	f8e7e3e3          	bltu	a5,a4,8002137c <map_get_keys+0x1a>
        }
    }

    return ret;
    800213fa:	fd843783          	ld	a5,-40(s0)
}
    800213fe:	853e                	mv	a0,a5
    80021400:	70e2                	ld	ra,56(sp)
    80021402:	7442                	ld	s0,48(sp)
    80021404:	6121                	addi	sp,sp,64
    80021406:	8082                	ret

0000000080021408 <map_free_get_keys>:

void map_free_get_keys(List *src) {
    80021408:	7179                	addi	sp,sp,-48
    8002140a:	f406                	sd	ra,40(sp)
    8002140c:	f022                	sd	s0,32(sp)
    8002140e:	1800                	addi	s0,sp,48
    80021410:	fca43c23          	sd	a0,-40(s0)
    if (src != NULL) {
    80021414:	fd843783          	ld	a5,-40(s0)
    80021418:	c3b1                	beqz	a5,8002145c <map_free_get_keys+0x54>
        ListElem *e;
        list_for_each_ascending(src, e) {
    8002141a:	fd843503          	ld	a0,-40(s0)
    8002141e:	c38ff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    80021422:	fea43423          	sd	a0,-24(s0)
    80021426:	a839                	j	80021444 <map_free_get_keys+0x3c>
            g_kfree(list_elem_value_ptr(e));
    80021428:	fe843503          	ld	a0,-24(s0)
    8002142c:	c8aff0ef          	jal	ra,800208b6 <list_elem_value>
    80021430:	87aa                	mv	a5,a0
    80021432:	853e                	mv	a0,a5
    80021434:	f33fe0ef          	jal	ra,80020366 <g_kfree>
        list_for_each_ascending(src, e) {
    80021438:	fe843503          	ld	a0,-24(s0)
    8002143c:	c62ff0ef          	jal	ra,8002089e <list_elem_prev>
    80021440:	fea43423          	sd	a0,-24(s0)
    80021444:	fe843583          	ld	a1,-24(s0)
    80021448:	fd843503          	ld	a0,-40(s0)
    8002144c:	b7cff0ef          	jal	ra,800207c8 <list_elem_valid>
    80021450:	87aa                	mv	a5,a0
    80021452:	fbf9                	bnez	a5,80021428 <map_free_get_keys+0x20>
        }
        list_free(src);
    80021454:	fd843503          	ld	a0,-40(s0)
    80021458:	b18ff0ef          	jal	ra,80020770 <list_free>
    }
}
    8002145c:	0001                	nop
    8002145e:	70a2                	ld	ra,40(sp)
    80021460:	7402                	ld	s0,32(sp)
    80021462:	6145                	addi	sp,sp,48
    80021464:	8082                	ret

0000000080021466 <path_skip_slashes>:
#include <list.h>
#include <path.h>
#include <util.h>

const char *path_skip_slashes(const char *path)
{
    80021466:	1101                	addi	sp,sp,-32
    80021468:	ec22                	sd	s0,24(sp)
    8002146a:	1000                	addi	s0,sp,32
    8002146c:	fea43423          	sd	a0,-24(s0)
    while (*path == '/') {
    80021470:	a031                	j	8002147c <path_skip_slashes+0x16>
        path++;
    80021472:	fe843783          	ld	a5,-24(s0)
    80021476:	0785                	addi	a5,a5,1
    80021478:	fef43423          	sd	a5,-24(s0)
    while (*path == '/') {
    8002147c:	fe843783          	ld	a5,-24(s0)
    80021480:	0007c783          	lbu	a5,0(a5)
    80021484:	873e                	mv	a4,a5
    80021486:	02f00793          	li	a5,47
    8002148a:	fef704e3          	beq	a4,a5,80021472 <path_skip_slashes+0xc>
    }
    return path;
    8002148e:	fe843783          	ld	a5,-24(s0)
}
    80021492:	853e                	mv	a0,a5
    80021494:	6462                	ld	s0,24(sp)
    80021496:	6105                	addi	sp,sp,32
    80021498:	8082                	ret

000000008002149a <path_next_slash>:

const char *path_next_slash(const char *path)
{
    8002149a:	1101                	addi	sp,sp,-32
    8002149c:	ec22                	sd	s0,24(sp)
    8002149e:	1000                	addi	s0,sp,32
    800214a0:	fea43423          	sd	a0,-24(s0)
    while (*path != '/' && *path != '\0') {
    800214a4:	a031                	j	800214b0 <path_next_slash+0x16>
        path++;
    800214a6:	fe843783          	ld	a5,-24(s0)
    800214aa:	0785                	addi	a5,a5,1
    800214ac:	fef43423          	sd	a5,-24(s0)
    while (*path != '/' && *path != '\0') {
    800214b0:	fe843783          	ld	a5,-24(s0)
    800214b4:	0007c783          	lbu	a5,0(a5)
    800214b8:	873e                	mv	a4,a5
    800214ba:	02f00793          	li	a5,47
    800214be:	00f70763          	beq	a4,a5,800214cc <path_next_slash+0x32>
    800214c2:	fe843783          	ld	a5,-24(s0)
    800214c6:	0007c783          	lbu	a5,0(a5)
    800214ca:	fff1                	bnez	a5,800214a6 <path_next_slash+0xc>
    }
    return path;
    800214cc:	fe843783          	ld	a5,-24(s0)
}
    800214d0:	853e                	mv	a0,a5
    800214d2:	6462                	ld	s0,24(sp)
    800214d4:	6105                	addi	sp,sp,32
    800214d6:	8082                	ret

00000000800214d8 <path_file_name>:

const char *path_file_name(const char *path)
{
    800214d8:	7179                	addi	sp,sp,-48
    800214da:	f406                	sd	ra,40(sp)
    800214dc:	f022                	sd	s0,32(sp)
    800214de:	1800                	addi	s0,sp,48
    800214e0:	fca43c23          	sd	a0,-40(s0)
    int len = strlen(path);
    800214e4:	fd843503          	ld	a0,-40(s0)
    800214e8:	4e2010ef          	jal	ra,800229ca <strlen>
    800214ec:	87aa                	mv	a5,a0
    800214ee:	fef42423          	sw	a5,-24(s0)
    int i;
    for (i = len - 1; path[i] != '/' && i >= 0; i -= 1)
    800214f2:	fe842783          	lw	a5,-24(s0)
    800214f6:	37fd                	addiw	a5,a5,-1
    800214f8:	fef42623          	sw	a5,-20(s0)
    800214fc:	a031                	j	80021508 <path_file_name+0x30>
    800214fe:	fec42783          	lw	a5,-20(s0)
    80021502:	37fd                	addiw	a5,a5,-1
    80021504:	fef42623          	sw	a5,-20(s0)
    80021508:	fec42783          	lw	a5,-20(s0)
    8002150c:	fd843703          	ld	a4,-40(s0)
    80021510:	97ba                	add	a5,a5,a4
    80021512:	0007c783          	lbu	a5,0(a5)
    80021516:	873e                	mv	a4,a5
    80021518:	02f00793          	li	a5,47
    8002151c:	00f70763          	beq	a4,a5,8002152a <path_file_name+0x52>
    80021520:	fec42783          	lw	a5,-20(s0)
    80021524:	2781                	sext.w	a5,a5
    80021526:	fc07dce3          	bgez	a5,800214fe <path_file_name+0x26>
        ;
    return path + i + 1;
    8002152a:	fec42783          	lw	a5,-20(s0)
    8002152e:	0785                	addi	a5,a5,1
    80021530:	fd843703          	ld	a4,-40(s0)
    80021534:	97ba                	add	a5,a5,a4
}
    80021536:	853e                	mv	a0,a5
    80021538:	70a2                	ld	ra,40(sp)
    8002153a:	7402                	ld	s0,32(sp)
    8002153c:	6145                	addi	sp,sp,48
    8002153e:	8082                	ret

0000000080021540 <path_split>:

List *path_split(const char *path)
{
    80021540:	7129                	addi	sp,sp,-320
    80021542:	fe06                	sd	ra,312(sp)
    80021544:	fa22                	sd	s0,304(sp)
    80021546:	0280                	addi	s0,sp,320
    80021548:	eca43423          	sd	a0,-312(s0)
    char name[256];
    char *ptr;
    unsigned int i;
    List *v = list_new();
    8002154c:	ebbfe0ef          	jal	ra,80020406 <list_new>
    80021550:	fea43023          	sd	a0,-32(s0)
    while (*path != '\0') {
    80021554:	a065                	j	800215fc <path_split+0xbc>
        path = path_skip_slashes(path);
    80021556:	ec843503          	ld	a0,-312(s0)
    8002155a:	f0dff0ef          	jal	ra,80021466 <path_skip_slashes>
    8002155e:	eca43423          	sd	a0,-312(s0)
        for (i = 0; i < (sizeof(name) - 1) && path[i] != '/' && path[i] != '\0'; i += 1) {
    80021562:	fe042623          	sw	zero,-20(s0)
    80021566:	a025                	j	8002158e <path_split+0x4e>
            name[i] = path[i];
    80021568:	fec46783          	lwu	a5,-20(s0)
    8002156c:	ec843703          	ld	a4,-312(s0)
    80021570:	97ba                	add	a5,a5,a4
    80021572:	0007c703          	lbu	a4,0(a5)
    80021576:	fec46783          	lwu	a5,-20(s0)
    8002157a:	ff040693          	addi	a3,s0,-16
    8002157e:	97b6                	add	a5,a5,a3
    80021580:	eee78423          	sb	a4,-280(a5)
        for (i = 0; i < (sizeof(name) - 1) && path[i] != '/' && path[i] != '\0'; i += 1) {
    80021584:	fec42783          	lw	a5,-20(s0)
    80021588:	2785                	addiw	a5,a5,1
    8002158a:	fef42623          	sw	a5,-20(s0)
    8002158e:	fec42783          	lw	a5,-20(s0)
    80021592:	0007871b          	sext.w	a4,a5
    80021596:	0fe00793          	li	a5,254
    8002159a:	02e7e663          	bltu	a5,a4,800215c6 <path_split+0x86>
    8002159e:	fec46783          	lwu	a5,-20(s0)
    800215a2:	ec843703          	ld	a4,-312(s0)
    800215a6:	97ba                	add	a5,a5,a4
    800215a8:	0007c783          	lbu	a5,0(a5)
    800215ac:	873e                	mv	a4,a5
    800215ae:	02f00793          	li	a5,47
    800215b2:	00f70a63          	beq	a4,a5,800215c6 <path_split+0x86>
    800215b6:	fec46783          	lwu	a5,-20(s0)
    800215ba:	ec843703          	ld	a4,-312(s0)
    800215be:	97ba                	add	a5,a5,a4
    800215c0:	0007c783          	lbu	a5,0(a5)
    800215c4:	f3d5                	bnez	a5,80021568 <path_split+0x28>
        }
        name[i] = '\0';
    800215c6:	fec46783          	lwu	a5,-20(s0)
    800215ca:	ff040713          	addi	a4,s0,-16
    800215ce:	97ba                	add	a5,a5,a4
    800215d0:	ee078423          	sb	zero,-280(a5)
        ptr     = strdup(name);
    800215d4:	ed840793          	addi	a5,s0,-296
    800215d8:	853e                	mv	a0,a5
    800215da:	4f0010ef          	jal	ra,80022aca <strdup>
    800215de:	fca43c23          	sd	a0,-40(s0)
        list_add(v, (uint64_t)ptr);
    800215e2:	fd843783          	ld	a5,-40(s0)
    800215e6:	85be                	mv	a1,a5
    800215e8:	fe043503          	ld	a0,-32(s0)
    800215ec:	e4bfe0ef          	jal	ra,80020436 <list_add>
        path = path_next_slash(path);
    800215f0:	ec843503          	ld	a0,-312(s0)
    800215f4:	ea7ff0ef          	jal	ra,8002149a <path_next_slash>
    800215f8:	eca43423          	sd	a0,-312(s0)
    while (*path != '\0') {
    800215fc:	ec843783          	ld	a5,-312(s0)
    80021600:	0007c783          	lbu	a5,0(a5)
    80021604:	fba9                	bnez	a5,80021556 <path_split+0x16>
    }
    return v;
    80021606:	fe043783          	ld	a5,-32(s0)
}
    8002160a:	853e                	mv	a0,a5
    8002160c:	70f2                	ld	ra,312(sp)
    8002160e:	7452                	ld	s0,304(sp)
    80021610:	6131                	addi	sp,sp,320
    80021612:	8082                	ret

0000000080021614 <path_split_free>:

void path_split_free(struct List *l)
{
    80021614:	7179                	addi	sp,sp,-48
    80021616:	f406                	sd	ra,40(sp)
    80021618:	f022                	sd	s0,32(sp)
    8002161a:	1800                	addi	s0,sp,48
    8002161c:	fca43c23          	sd	a0,-40(s0)
    ListElem *e;
    list_for_each(l, e)
    80021620:	fd843503          	ld	a0,-40(s0)
    80021624:	a32ff0ef          	jal	ra,80020856 <list_elem_start_ascending>
    80021628:	fea43423          	sd	a0,-24(s0)
    8002162c:	a015                	j	80021650 <path_split_free+0x3c>
    {
        void *ptr = (void *)list_elem_value(e);
    8002162e:	fe843503          	ld	a0,-24(s0)
    80021632:	a84ff0ef          	jal	ra,800208b6 <list_elem_value>
    80021636:	87aa                	mv	a5,a0
    80021638:	fef43023          	sd	a5,-32(s0)
        g_kfree(ptr);
    8002163c:	fe043503          	ld	a0,-32(s0)
    80021640:	d27fe0ef          	jal	ra,80020366 <g_kfree>
    list_for_each(l, e)
    80021644:	fe843503          	ld	a0,-24(s0)
    80021648:	a56ff0ef          	jal	ra,8002089e <list_elem_prev>
    8002164c:	fea43423          	sd	a0,-24(s0)
    80021650:	fe843583          	ld	a1,-24(s0)
    80021654:	fd843503          	ld	a0,-40(s0)
    80021658:	970ff0ef          	jal	ra,800207c8 <list_elem_valid>
    8002165c:	87aa                	mv	a5,a0
    8002165e:	fbe1                	bnez	a5,8002162e <path_split_free+0x1a>
    }
    list_free(l);
    80021660:	fd843503          	ld	a0,-40(s0)
    80021664:	90cff0ef          	jal	ra,80020770 <list_free>
    g_kfree(l);
    80021668:	fd843503          	ld	a0,-40(s0)
    8002166c:	cfbfe0ef          	jal	ra,80020366 <g_kfree>
}
    80021670:	0001                	nop
    80021672:	70a2                	ld	ra,40(sp)
    80021674:	7402                	ld	s0,32(sp)
    80021676:	6145                	addi	sp,sp,48
    80021678:	8082                	ret

000000008002167a <create_node>:
    Node *root;
} RBTree;

// Function to create new node
Node *create_node(int key, uint64_t value)
{
    8002167a:	7179                	addi	sp,sp,-48
    8002167c:	f406                	sd	ra,40(sp)
    8002167e:	f022                	sd	s0,32(sp)
    80021680:	1800                	addi	s0,sp,48
    80021682:	87aa                	mv	a5,a0
    80021684:	fcb43823          	sd	a1,-48(s0)
    80021688:	fcf42e23          	sw	a5,-36(s0)
    Node *node  = (Node *)g_kmalloc(sizeof(Node));
    8002168c:	02800513          	li	a0,40
    80021690:	c3dfe0ef          	jal	ra,800202cc <g_kmalloc>
    80021694:	fea43423          	sd	a0,-24(s0)
    node->key   = key;
    80021698:	fe843783          	ld	a5,-24(s0)
    8002169c:	fdc42703          	lw	a4,-36(s0)
    800216a0:	c3d8                	sw	a4,4(a5)
    node->value = value;
    800216a2:	fe843783          	ld	a5,-24(s0)
    800216a6:	fd043703          	ld	a4,-48(s0)
    800216aa:	e798                	sd	a4,8(a5)
    node->color = RED;
    800216ac:	fe843783          	ld	a5,-24(s0)
    800216b0:	0007a023          	sw	zero,0(a5)
    node->left = node->right = node->parent = NULL;
    800216b4:	fe843783          	ld	a5,-24(s0)
    800216b8:	0207b023          	sd	zero,32(a5)
    800216bc:	fe843783          	ld	a5,-24(s0)
    800216c0:	7398                	ld	a4,32(a5)
    800216c2:	fe843783          	ld	a5,-24(s0)
    800216c6:	ef98                	sd	a4,24(a5)
    800216c8:	fe843783          	ld	a5,-24(s0)
    800216cc:	6f98                	ld	a4,24(a5)
    800216ce:	fe843783          	ld	a5,-24(s0)
    800216d2:	eb98                	sd	a4,16(a5)
    return node;
    800216d4:	fe843783          	ld	a5,-24(s0)
}
    800216d8:	853e                	mv	a0,a5
    800216da:	70a2                	ld	ra,40(sp)
    800216dc:	7402                	ld	s0,32(sp)
    800216de:	6145                	addi	sp,sp,48
    800216e0:	8082                	ret

00000000800216e2 <csearch>:

static const Node *csearch(const Node *node, int key)
{
    800216e2:	1101                	addi	sp,sp,-32
    800216e4:	ec22                	sd	s0,24(sp)
    800216e6:	1000                	addi	s0,sp,32
    800216e8:	fea43423          	sd	a0,-24(s0)
    800216ec:	87ae                	mv	a5,a1
    800216ee:	fef42223          	sw	a5,-28(s0)
    while (node != NULL) {
    800216f2:	a081                	j	80021732 <csearch+0x50>
        if (key < node->key) {
    800216f4:	fe843783          	ld	a5,-24(s0)
    800216f8:	43d8                	lw	a4,4(a5)
    800216fa:	fe442783          	lw	a5,-28(s0)
    800216fe:	2781                	sext.w	a5,a5
    80021700:	00e7d863          	bge	a5,a4,80021710 <csearch+0x2e>
            node = node->left;
    80021704:	fe843783          	ld	a5,-24(s0)
    80021708:	6b9c                	ld	a5,16(a5)
    8002170a:	fef43423          	sd	a5,-24(s0)
    8002170e:	a015                	j	80021732 <csearch+0x50>
        }
        else if (key > node->key) {
    80021710:	fe843783          	ld	a5,-24(s0)
    80021714:	43d8                	lw	a4,4(a5)
    80021716:	fe442783          	lw	a5,-28(s0)
    8002171a:	2781                	sext.w	a5,a5
    8002171c:	00f75863          	bge	a4,a5,8002172c <csearch+0x4a>
            node = node->right;
    80021720:	fe843783          	ld	a5,-24(s0)
    80021724:	6f9c                	ld	a5,24(a5)
    80021726:	fef43423          	sd	a5,-24(s0)
    8002172a:	a021                	j	80021732 <csearch+0x50>
        }
        else {
            return node;
    8002172c:	fe843783          	ld	a5,-24(s0)
    80021730:	a029                	j	8002173a <csearch+0x58>
    while (node != NULL) {
    80021732:	fe843783          	ld	a5,-24(s0)
    80021736:	ffdd                	bnez	a5,800216f4 <csearch+0x12>
        }
    }
    return NULL;
    80021738:	4781                	li	a5,0
}
    8002173a:	853e                	mv	a0,a5
    8002173c:	6462                	ld	s0,24(sp)
    8002173e:	6105                	addi	sp,sp,32
    80021740:	8082                	ret

0000000080021742 <search>:

static Node *search(Node *node, int key)
{
    80021742:	1101                	addi	sp,sp,-32
    80021744:	ec22                	sd	s0,24(sp)
    80021746:	1000                	addi	s0,sp,32
    80021748:	fea43423          	sd	a0,-24(s0)
    8002174c:	87ae                	mv	a5,a1
    8002174e:	fef42223          	sw	a5,-28(s0)
    while (node != NULL) {
    80021752:	a081                	j	80021792 <search+0x50>
        if (key < node->key) {
    80021754:	fe843783          	ld	a5,-24(s0)
    80021758:	43d8                	lw	a4,4(a5)
    8002175a:	fe442783          	lw	a5,-28(s0)
    8002175e:	2781                	sext.w	a5,a5
    80021760:	00e7d863          	bge	a5,a4,80021770 <search+0x2e>
            node = node->left;
    80021764:	fe843783          	ld	a5,-24(s0)
    80021768:	6b9c                	ld	a5,16(a5)
    8002176a:	fef43423          	sd	a5,-24(s0)
    8002176e:	a015                	j	80021792 <search+0x50>
        }
        else if (key > node->key) {
    80021770:	fe843783          	ld	a5,-24(s0)
    80021774:	43d8                	lw	a4,4(a5)
    80021776:	fe442783          	lw	a5,-28(s0)
    8002177a:	2781                	sext.w	a5,a5
    8002177c:	00f75863          	bge	a4,a5,8002178c <search+0x4a>
            node = node->right;
    80021780:	fe843783          	ld	a5,-24(s0)
    80021784:	6f9c                	ld	a5,24(a5)
    80021786:	fef43423          	sd	a5,-24(s0)
    8002178a:	a021                	j	80021792 <search+0x50>
        }
        else {
            return node;
    8002178c:	fe843783          	ld	a5,-24(s0)
    80021790:	a029                	j	8002179a <search+0x58>
    while (node != NULL) {
    80021792:	fe843783          	ld	a5,-24(s0)
    80021796:	ffdd                	bnez	a5,80021754 <search+0x12>
        }
    }
    return NULL;
    80021798:	4781                	li	a5,0
}
    8002179a:	853e                	mv	a0,a5
    8002179c:	6462                	ld	s0,24(sp)
    8002179e:	6105                	addi	sp,sp,32
    800217a0:	8082                	ret

00000000800217a2 <minimum>:


static Node *minimum(Node *node)
{
    800217a2:	1101                	addi	sp,sp,-32
    800217a4:	ec22                	sd	s0,24(sp)
    800217a6:	1000                	addi	s0,sp,32
    800217a8:	fea43423          	sd	a0,-24(s0)
    while (node->left != NULL) {
    800217ac:	a031                	j	800217b8 <minimum+0x16>
        node = node->left;
    800217ae:	fe843783          	ld	a5,-24(s0)
    800217b2:	6b9c                	ld	a5,16(a5)
    800217b4:	fef43423          	sd	a5,-24(s0)
    while (node->left != NULL) {
    800217b8:	fe843783          	ld	a5,-24(s0)
    800217bc:	6b9c                	ld	a5,16(a5)
    800217be:	fbe5                	bnez	a5,800217ae <minimum+0xc>
    }
    return node;
    800217c0:	fe843783          	ld	a5,-24(s0)
}
    800217c4:	853e                	mv	a0,a5
    800217c6:	6462                	ld	s0,24(sp)
    800217c8:	6105                	addi	sp,sp,32
    800217ca:	8082                	ret

00000000800217cc <cminimum>:

static const Node *cminimum(const Node *node)
{
    800217cc:	1101                	addi	sp,sp,-32
    800217ce:	ec22                	sd	s0,24(sp)
    800217d0:	1000                	addi	s0,sp,32
    800217d2:	fea43423          	sd	a0,-24(s0)
    while (node->left != NULL) {
    800217d6:	a031                	j	800217e2 <cminimum+0x16>
        node = node->left;
    800217d8:	fe843783          	ld	a5,-24(s0)
    800217dc:	6b9c                	ld	a5,16(a5)
    800217de:	fef43423          	sd	a5,-24(s0)
    while (node->left != NULL) {
    800217e2:	fe843783          	ld	a5,-24(s0)
    800217e6:	6b9c                	ld	a5,16(a5)
    800217e8:	fbe5                	bnez	a5,800217d8 <cminimum+0xc>
    }
    return node;
    800217ea:	fe843783          	ld	a5,-24(s0)
}
    800217ee:	853e                	mv	a0,a5
    800217f0:	6462                	ld	s0,24(sp)
    800217f2:	6105                	addi	sp,sp,32
    800217f4:	8082                	ret

00000000800217f6 <cmaximum>:

static const Node *cmaximum(const Node *node)
{
    800217f6:	1101                	addi	sp,sp,-32
    800217f8:	ec22                	sd	s0,24(sp)
    800217fa:	1000                	addi	s0,sp,32
    800217fc:	fea43423          	sd	a0,-24(s0)
    while (node->right != NULL) {
    80021800:	a031                	j	8002180c <cmaximum+0x16>
        node = node->right;
    80021802:	fe843783          	ld	a5,-24(s0)
    80021806:	6f9c                	ld	a5,24(a5)
    80021808:	fef43423          	sd	a5,-24(s0)
    while (node->right != NULL) {
    8002180c:	fe843783          	ld	a5,-24(s0)
    80021810:	6f9c                	ld	a5,24(a5)
    80021812:	fbe5                	bnez	a5,80021802 <cmaximum+0xc>
    }
    return node;
    80021814:	fe843783          	ld	a5,-24(s0)
}
    80021818:	853e                	mv	a0,a5
    8002181a:	6462                	ld	s0,24(sp)
    8002181c:	6105                	addi	sp,sp,32
    8002181e:	8082                	ret

0000000080021820 <rb_min>:


bool rb_min(const RBTree *rb, int *key)
{
    80021820:	7179                	addi	sp,sp,-48
    80021822:	f406                	sd	ra,40(sp)
    80021824:	f022                	sd	s0,32(sp)
    80021826:	1800                	addi	s0,sp,48
    80021828:	fca43c23          	sd	a0,-40(s0)
    8002182c:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    80021830:	fd843783          	ld	a5,-40(s0)
    80021834:	639c                	ld	a5,0(a5)
    80021836:	e399                	bnez	a5,8002183c <rb_min+0x1c>
        return false;
    80021838:	4781                	li	a5,0
    8002183a:	a805                	j	8002186a <rb_min+0x4a>
    }
    const Node *n = cminimum(rb->root);
    8002183c:	fd843783          	ld	a5,-40(s0)
    80021840:	639c                	ld	a5,0(a5)
    80021842:	853e                	mv	a0,a5
    80021844:	f89ff0ef          	jal	ra,800217cc <cminimum>
    80021848:	fea43423          	sd	a0,-24(s0)
    if (n != NULL) {
    8002184c:	fe843783          	ld	a5,-24(s0)
    80021850:	cf81                	beqz	a5,80021868 <rb_min+0x48>
        if (key) {
    80021852:	fd043783          	ld	a5,-48(s0)
    80021856:	c799                	beqz	a5,80021864 <rb_min+0x44>
            *key = n->key;
    80021858:	fe843783          	ld	a5,-24(s0)
    8002185c:	43d8                	lw	a4,4(a5)
    8002185e:	fd043783          	ld	a5,-48(s0)
    80021862:	c398                	sw	a4,0(a5)
        }
        return true;
    80021864:	4785                	li	a5,1
    80021866:	a011                	j	8002186a <rb_min+0x4a>
    }
    return false;
    80021868:	4781                	li	a5,0
}
    8002186a:	853e                	mv	a0,a5
    8002186c:	70a2                	ld	ra,40(sp)
    8002186e:	7402                	ld	s0,32(sp)
    80021870:	6145                	addi	sp,sp,48
    80021872:	8082                	ret

0000000080021874 <rb_max>:

bool rb_max(const RBTree *rb, int *key)
{
    80021874:	7179                	addi	sp,sp,-48
    80021876:	f406                	sd	ra,40(sp)
    80021878:	f022                	sd	s0,32(sp)
    8002187a:	1800                	addi	s0,sp,48
    8002187c:	fca43c23          	sd	a0,-40(s0)
    80021880:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    80021884:	fd843783          	ld	a5,-40(s0)
    80021888:	639c                	ld	a5,0(a5)
    8002188a:	e399                	bnez	a5,80021890 <rb_max+0x1c>
        return false;
    8002188c:	4781                	li	a5,0
    8002188e:	a805                	j	800218be <rb_max+0x4a>
    }
    const Node *n = cmaximum(rb->root);
    80021890:	fd843783          	ld	a5,-40(s0)
    80021894:	639c                	ld	a5,0(a5)
    80021896:	853e                	mv	a0,a5
    80021898:	f5fff0ef          	jal	ra,800217f6 <cmaximum>
    8002189c:	fea43423          	sd	a0,-24(s0)
    if (n != NULL) {
    800218a0:	fe843783          	ld	a5,-24(s0)
    800218a4:	cf81                	beqz	a5,800218bc <rb_max+0x48>
        if (key) {
    800218a6:	fd043783          	ld	a5,-48(s0)
    800218aa:	c799                	beqz	a5,800218b8 <rb_max+0x44>
            *key = n->key;
    800218ac:	fe843783          	ld	a5,-24(s0)
    800218b0:	43d8                	lw	a4,4(a5)
    800218b2:	fd043783          	ld	a5,-48(s0)
    800218b6:	c398                	sw	a4,0(a5)
        }
        return true;
    800218b8:	4785                	li	a5,1
    800218ba:	a011                	j	800218be <rb_max+0x4a>
    }
    return false;
    800218bc:	4781                	li	a5,0
}
    800218be:	853e                	mv	a0,a5
    800218c0:	70a2                	ld	ra,40(sp)
    800218c2:	7402                	ld	s0,32(sp)
    800218c4:	6145                	addi	sp,sp,48
    800218c6:	8082                	ret

00000000800218c8 <rb_min_val>:

bool rb_min_val(const RBTree *rb, uint64_t *value)
{
    800218c8:	7179                	addi	sp,sp,-48
    800218ca:	f406                	sd	ra,40(sp)
    800218cc:	f022                	sd	s0,32(sp)
    800218ce:	1800                	addi	s0,sp,48
    800218d0:	fca43c23          	sd	a0,-40(s0)
    800218d4:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    800218d8:	fd843783          	ld	a5,-40(s0)
    800218dc:	639c                	ld	a5,0(a5)
    800218de:	e399                	bnez	a5,800218e4 <rb_min_val+0x1c>
        return false;
    800218e0:	4781                	li	a5,0
    800218e2:	a805                	j	80021912 <rb_min_val+0x4a>
    }
    const Node *n = cminimum(rb->root);
    800218e4:	fd843783          	ld	a5,-40(s0)
    800218e8:	639c                	ld	a5,0(a5)
    800218ea:	853e                	mv	a0,a5
    800218ec:	ee1ff0ef          	jal	ra,800217cc <cminimum>
    800218f0:	fea43423          	sd	a0,-24(s0)
    if (n) {
    800218f4:	fe843783          	ld	a5,-24(s0)
    800218f8:	cf81                	beqz	a5,80021910 <rb_min_val+0x48>
        if (value) {
    800218fa:	fd043783          	ld	a5,-48(s0)
    800218fe:	c799                	beqz	a5,8002190c <rb_min_val+0x44>
            *value = n->value;
    80021900:	fe843783          	ld	a5,-24(s0)
    80021904:	6798                	ld	a4,8(a5)
    80021906:	fd043783          	ld	a5,-48(s0)
    8002190a:	e398                	sd	a4,0(a5)
        }
        return true;
    8002190c:	4785                	li	a5,1
    8002190e:	a011                	j	80021912 <rb_min_val+0x4a>
    }
    return false;
    80021910:	4781                	li	a5,0
}
    80021912:	853e                	mv	a0,a5
    80021914:	70a2                	ld	ra,40(sp)
    80021916:	7402                	ld	s0,32(sp)
    80021918:	6145                	addi	sp,sp,48
    8002191a:	8082                	ret

000000008002191c <rb_max_val>:

bool rb_max_val(const RBTree *rb, uint64_t *value)
{
    8002191c:	7179                	addi	sp,sp,-48
    8002191e:	f406                	sd	ra,40(sp)
    80021920:	f022                	sd	s0,32(sp)
    80021922:	1800                	addi	s0,sp,48
    80021924:	fca43c23          	sd	a0,-40(s0)
    80021928:	fcb43823          	sd	a1,-48(s0)
    if (rb->root == NULL) {
    8002192c:	fd843783          	ld	a5,-40(s0)
    80021930:	639c                	ld	a5,0(a5)
    80021932:	e399                	bnez	a5,80021938 <rb_max_val+0x1c>
        return false;
    80021934:	4781                	li	a5,0
    80021936:	a805                	j	80021966 <rb_max_val+0x4a>
    }
    const Node *n = cmaximum(rb->root);
    80021938:	fd843783          	ld	a5,-40(s0)
    8002193c:	639c                	ld	a5,0(a5)
    8002193e:	853e                	mv	a0,a5
    80021940:	eb7ff0ef          	jal	ra,800217f6 <cmaximum>
    80021944:	fea43423          	sd	a0,-24(s0)
    if (n) {
    80021948:	fe843783          	ld	a5,-24(s0)
    8002194c:	cf81                	beqz	a5,80021964 <rb_max_val+0x48>
        if (value) {
    8002194e:	fd043783          	ld	a5,-48(s0)
    80021952:	c799                	beqz	a5,80021960 <rb_max_val+0x44>
            *value = n->value;
    80021954:	fe843783          	ld	a5,-24(s0)
    80021958:	6798                	ld	a4,8(a5)
    8002195a:	fd043783          	ld	a5,-48(s0)
    8002195e:	e398                	sd	a4,0(a5)
        }
        return true;
    80021960:	4785                	li	a5,1
    80021962:	a011                	j	80021966 <rb_max_val+0x4a>
    }
    return false;
    80021964:	4781                	li	a5,0
}
    80021966:	853e                	mv	a0,a5
    80021968:	70a2                	ld	ra,40(sp)
    8002196a:	7402                	ld	s0,32(sp)
    8002196c:	6145                	addi	sp,sp,48
    8002196e:	8082                	ret

0000000080021970 <left_rotate>:

// Function to left rotate tree at given node
static void left_rotate(RBTree *rb, Node *x)
{
    80021970:	7179                	addi	sp,sp,-48
    80021972:	f422                	sd	s0,40(sp)
    80021974:	1800                	addi	s0,sp,48
    80021976:	fca43c23          	sd	a0,-40(s0)
    8002197a:	fcb43823          	sd	a1,-48(s0)
    Node *y  = x->right;
    8002197e:	fd043783          	ld	a5,-48(s0)
    80021982:	6f9c                	ld	a5,24(a5)
    80021984:	fef43423          	sd	a5,-24(s0)
    x->right = y->left;
    80021988:	fe843783          	ld	a5,-24(s0)
    8002198c:	6b98                	ld	a4,16(a5)
    8002198e:	fd043783          	ld	a5,-48(s0)
    80021992:	ef98                	sd	a4,24(a5)
    if (y->left != NULL) {
    80021994:	fe843783          	ld	a5,-24(s0)
    80021998:	6b9c                	ld	a5,16(a5)
    8002199a:	c799                	beqz	a5,800219a8 <left_rotate+0x38>
        y->left->parent = x;
    8002199c:	fe843783          	ld	a5,-24(s0)
    800219a0:	6b9c                	ld	a5,16(a5)
    800219a2:	fd043703          	ld	a4,-48(s0)
    800219a6:	f398                	sd	a4,32(a5)
    }
    y->parent = x->parent;
    800219a8:	fd043783          	ld	a5,-48(s0)
    800219ac:	7398                	ld	a4,32(a5)
    800219ae:	fe843783          	ld	a5,-24(s0)
    800219b2:	f398                	sd	a4,32(a5)
    if (x->parent == NULL) {
    800219b4:	fd043783          	ld	a5,-48(s0)
    800219b8:	739c                	ld	a5,32(a5)
    800219ba:	e799                	bnez	a5,800219c8 <left_rotate+0x58>
        rb->root = y;
    800219bc:	fd843783          	ld	a5,-40(s0)
    800219c0:	fe843703          	ld	a4,-24(s0)
    800219c4:	e398                	sd	a4,0(a5)
    800219c6:	a035                	j	800219f2 <left_rotate+0x82>
    }
    else if (x == x->parent->left) {
    800219c8:	fd043783          	ld	a5,-48(s0)
    800219cc:	739c                	ld	a5,32(a5)
    800219ce:	6b9c                	ld	a5,16(a5)
    800219d0:	fd043703          	ld	a4,-48(s0)
    800219d4:	00f71963          	bne	a4,a5,800219e6 <left_rotate+0x76>
        x->parent->left = y;
    800219d8:	fd043783          	ld	a5,-48(s0)
    800219dc:	739c                	ld	a5,32(a5)
    800219de:	fe843703          	ld	a4,-24(s0)
    800219e2:	eb98                	sd	a4,16(a5)
    800219e4:	a039                	j	800219f2 <left_rotate+0x82>
    }
    else {
        x->parent->right = y;
    800219e6:	fd043783          	ld	a5,-48(s0)
    800219ea:	739c                	ld	a5,32(a5)
    800219ec:	fe843703          	ld	a4,-24(s0)
    800219f0:	ef98                	sd	a4,24(a5)
    }
    y->left   = x;
    800219f2:	fe843783          	ld	a5,-24(s0)
    800219f6:	fd043703          	ld	a4,-48(s0)
    800219fa:	eb98                	sd	a4,16(a5)
    x->parent = y;
    800219fc:	fd043783          	ld	a5,-48(s0)
    80021a00:	fe843703          	ld	a4,-24(s0)
    80021a04:	f398                	sd	a4,32(a5)
}
    80021a06:	0001                	nop
    80021a08:	7422                	ld	s0,40(sp)
    80021a0a:	6145                	addi	sp,sp,48
    80021a0c:	8082                	ret

0000000080021a0e <right_rotate>:

// Function to right rotate tree at given node
static void right_rotate(RBTree *rb, Node *y)
{
    80021a0e:	7179                	addi	sp,sp,-48
    80021a10:	f422                	sd	s0,40(sp)
    80021a12:	1800                	addi	s0,sp,48
    80021a14:	fca43c23          	sd	a0,-40(s0)
    80021a18:	fcb43823          	sd	a1,-48(s0)
    Node *x = y->left;
    80021a1c:	fd043783          	ld	a5,-48(s0)
    80021a20:	6b9c                	ld	a5,16(a5)
    80021a22:	fef43423          	sd	a5,-24(s0)
    y->left = x->right;
    80021a26:	fe843783          	ld	a5,-24(s0)
    80021a2a:	6f98                	ld	a4,24(a5)
    80021a2c:	fd043783          	ld	a5,-48(s0)
    80021a30:	eb98                	sd	a4,16(a5)
    if (x->right != NULL) {
    80021a32:	fe843783          	ld	a5,-24(s0)
    80021a36:	6f9c                	ld	a5,24(a5)
    80021a38:	c799                	beqz	a5,80021a46 <right_rotate+0x38>
        x->right->parent = y;
    80021a3a:	fe843783          	ld	a5,-24(s0)
    80021a3e:	6f9c                	ld	a5,24(a5)
    80021a40:	fd043703          	ld	a4,-48(s0)
    80021a44:	f398                	sd	a4,32(a5)
    }
    x->parent = y->parent;
    80021a46:	fd043783          	ld	a5,-48(s0)
    80021a4a:	7398                	ld	a4,32(a5)
    80021a4c:	fe843783          	ld	a5,-24(s0)
    80021a50:	f398                	sd	a4,32(a5)
    if (y->parent == NULL) {
    80021a52:	fd043783          	ld	a5,-48(s0)
    80021a56:	739c                	ld	a5,32(a5)
    80021a58:	e799                	bnez	a5,80021a66 <right_rotate+0x58>
        rb->root = x;
    80021a5a:	fd843783          	ld	a5,-40(s0)
    80021a5e:	fe843703          	ld	a4,-24(s0)
    80021a62:	e398                	sd	a4,0(a5)
    80021a64:	a035                	j	80021a90 <right_rotate+0x82>
    }
    else if (y == y->parent->left) {
    80021a66:	fd043783          	ld	a5,-48(s0)
    80021a6a:	739c                	ld	a5,32(a5)
    80021a6c:	6b9c                	ld	a5,16(a5)
    80021a6e:	fd043703          	ld	a4,-48(s0)
    80021a72:	00f71963          	bne	a4,a5,80021a84 <right_rotate+0x76>
        y->parent->left = x;
    80021a76:	fd043783          	ld	a5,-48(s0)
    80021a7a:	739c                	ld	a5,32(a5)
    80021a7c:	fe843703          	ld	a4,-24(s0)
    80021a80:	eb98                	sd	a4,16(a5)
    80021a82:	a039                	j	80021a90 <right_rotate+0x82>
    }
    else {
        y->parent->right = x;
    80021a84:	fd043783          	ld	a5,-48(s0)
    80021a88:	739c                	ld	a5,32(a5)
    80021a8a:	fe843703          	ld	a4,-24(s0)
    80021a8e:	ef98                	sd	a4,24(a5)
    }
    x->right  = y;
    80021a90:	fe843783          	ld	a5,-24(s0)
    80021a94:	fd043703          	ld	a4,-48(s0)
    80021a98:	ef98                	sd	a4,24(a5)
    y->parent = x;
    80021a9a:	fd043783          	ld	a5,-48(s0)
    80021a9e:	fe843703          	ld	a4,-24(s0)
    80021aa2:	f398                	sd	a4,32(a5)
}
    80021aa4:	0001                	nop
    80021aa6:	7422                	ld	s0,40(sp)
    80021aa8:	6145                	addi	sp,sp,48
    80021aaa:	8082                	ret

0000000080021aac <fix_insert>:

// Function to fix the red-black tree after insertion
static void fix_insert(RBTree *rb, Node *z)
{
    80021aac:	7179                	addi	sp,sp,-48
    80021aae:	f406                	sd	ra,40(sp)
    80021ab0:	f022                	sd	s0,32(sp)
    80021ab2:	1800                	addi	s0,sp,48
    80021ab4:	fca43c23          	sd	a0,-40(s0)
    80021ab8:	fcb43823          	sd	a1,-48(s0)
    while (z != rb->root && z->parent->color == RED) {
    80021abc:	a291                	j	80021c00 <fix_insert+0x154>
        if (z->parent == z->parent->parent->left) {
    80021abe:	fd043783          	ld	a5,-48(s0)
    80021ac2:	7398                	ld	a4,32(a5)
    80021ac4:	fd043783          	ld	a5,-48(s0)
    80021ac8:	739c                	ld	a5,32(a5)
    80021aca:	739c                	ld	a5,32(a5)
    80021acc:	6b9c                	ld	a5,16(a5)
    80021ace:	08f71e63          	bne	a4,a5,80021b6a <fix_insert+0xbe>
            Node *y = z->parent->parent->right;
    80021ad2:	fd043783          	ld	a5,-48(s0)
    80021ad6:	739c                	ld	a5,32(a5)
    80021ad8:	739c                	ld	a5,32(a5)
    80021ada:	6f9c                	ld	a5,24(a5)
    80021adc:	fef43023          	sd	a5,-32(s0)
            if (y != NULL && y->color == RED) {
    80021ae0:	fe043783          	ld	a5,-32(s0)
    80021ae4:	cb9d                	beqz	a5,80021b1a <fix_insert+0x6e>
    80021ae6:	fe043783          	ld	a5,-32(s0)
    80021aea:	439c                	lw	a5,0(a5)
    80021aec:	e79d                	bnez	a5,80021b1a <fix_insert+0x6e>
                z->parent->color         = BLACK;
    80021aee:	fd043783          	ld	a5,-48(s0)
    80021af2:	739c                	ld	a5,32(a5)
    80021af4:	4705                	li	a4,1
    80021af6:	c398                	sw	a4,0(a5)
                y->color                 = BLACK;
    80021af8:	fe043783          	ld	a5,-32(s0)
    80021afc:	4705                	li	a4,1
    80021afe:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    80021b00:	fd043783          	ld	a5,-48(s0)
    80021b04:	739c                	ld	a5,32(a5)
    80021b06:	739c                	ld	a5,32(a5)
    80021b08:	0007a023          	sw	zero,0(a5)
                z                        = z->parent->parent;
    80021b0c:	fd043783          	ld	a5,-48(s0)
    80021b10:	739c                	ld	a5,32(a5)
    80021b12:	739c                	ld	a5,32(a5)
    80021b14:	fcf43823          	sd	a5,-48(s0)
    80021b18:	a0e5                	j	80021c00 <fix_insert+0x154>
            }
            else {
                if (z == z->parent->right) {
    80021b1a:	fd043783          	ld	a5,-48(s0)
    80021b1e:	739c                	ld	a5,32(a5)
    80021b20:	6f9c                	ld	a5,24(a5)
    80021b22:	fd043703          	ld	a4,-48(s0)
    80021b26:	00f71d63          	bne	a4,a5,80021b40 <fix_insert+0x94>
                    z = z->parent;
    80021b2a:	fd043783          	ld	a5,-48(s0)
    80021b2e:	739c                	ld	a5,32(a5)
    80021b30:	fcf43823          	sd	a5,-48(s0)
                    left_rotate(rb, z);
    80021b34:	fd043583          	ld	a1,-48(s0)
    80021b38:	fd843503          	ld	a0,-40(s0)
    80021b3c:	e35ff0ef          	jal	ra,80021970 <left_rotate>
                }
                z->parent->color         = BLACK;
    80021b40:	fd043783          	ld	a5,-48(s0)
    80021b44:	739c                	ld	a5,32(a5)
    80021b46:	4705                	li	a4,1
    80021b48:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    80021b4a:	fd043783          	ld	a5,-48(s0)
    80021b4e:	739c                	ld	a5,32(a5)
    80021b50:	739c                	ld	a5,32(a5)
    80021b52:	0007a023          	sw	zero,0(a5)
                right_rotate(rb, z->parent->parent);
    80021b56:	fd043783          	ld	a5,-48(s0)
    80021b5a:	739c                	ld	a5,32(a5)
    80021b5c:	739c                	ld	a5,32(a5)
    80021b5e:	85be                	mv	a1,a5
    80021b60:	fd843503          	ld	a0,-40(s0)
    80021b64:	eabff0ef          	jal	ra,80021a0e <right_rotate>
    80021b68:	a861                	j	80021c00 <fix_insert+0x154>
            }
        }
        else {
            Node *y = z->parent->parent->left;
    80021b6a:	fd043783          	ld	a5,-48(s0)
    80021b6e:	739c                	ld	a5,32(a5)
    80021b70:	739c                	ld	a5,32(a5)
    80021b72:	6b9c                	ld	a5,16(a5)
    80021b74:	fef43423          	sd	a5,-24(s0)
            if (y != NULL && y->color == RED) {
    80021b78:	fe843783          	ld	a5,-24(s0)
    80021b7c:	cb9d                	beqz	a5,80021bb2 <fix_insert+0x106>
    80021b7e:	fe843783          	ld	a5,-24(s0)
    80021b82:	439c                	lw	a5,0(a5)
    80021b84:	e79d                	bnez	a5,80021bb2 <fix_insert+0x106>
                z->parent->color         = BLACK;
    80021b86:	fd043783          	ld	a5,-48(s0)
    80021b8a:	739c                	ld	a5,32(a5)
    80021b8c:	4705                	li	a4,1
    80021b8e:	c398                	sw	a4,0(a5)
                y->color                 = BLACK;
    80021b90:	fe843783          	ld	a5,-24(s0)
    80021b94:	4705                	li	a4,1
    80021b96:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    80021b98:	fd043783          	ld	a5,-48(s0)
    80021b9c:	739c                	ld	a5,32(a5)
    80021b9e:	739c                	ld	a5,32(a5)
    80021ba0:	0007a023          	sw	zero,0(a5)
                z                        = z->parent->parent;
    80021ba4:	fd043783          	ld	a5,-48(s0)
    80021ba8:	739c                	ld	a5,32(a5)
    80021baa:	739c                	ld	a5,32(a5)
    80021bac:	fcf43823          	sd	a5,-48(s0)
    80021bb0:	a881                	j	80021c00 <fix_insert+0x154>
            }
            else {
                if (z == z->parent->left) {
    80021bb2:	fd043783          	ld	a5,-48(s0)
    80021bb6:	739c                	ld	a5,32(a5)
    80021bb8:	6b9c                	ld	a5,16(a5)
    80021bba:	fd043703          	ld	a4,-48(s0)
    80021bbe:	00f71d63          	bne	a4,a5,80021bd8 <fix_insert+0x12c>
                    z = z->parent;
    80021bc2:	fd043783          	ld	a5,-48(s0)
    80021bc6:	739c                	ld	a5,32(a5)
    80021bc8:	fcf43823          	sd	a5,-48(s0)
                    right_rotate(rb, z);
    80021bcc:	fd043583          	ld	a1,-48(s0)
    80021bd0:	fd843503          	ld	a0,-40(s0)
    80021bd4:	e3bff0ef          	jal	ra,80021a0e <right_rotate>
                }
                z->parent->color         = BLACK;
    80021bd8:	fd043783          	ld	a5,-48(s0)
    80021bdc:	739c                	ld	a5,32(a5)
    80021bde:	4705                	li	a4,1
    80021be0:	c398                	sw	a4,0(a5)
                z->parent->parent->color = RED;
    80021be2:	fd043783          	ld	a5,-48(s0)
    80021be6:	739c                	ld	a5,32(a5)
    80021be8:	739c                	ld	a5,32(a5)
    80021bea:	0007a023          	sw	zero,0(a5)
                left_rotate(rb, z->parent->parent);
    80021bee:	fd043783          	ld	a5,-48(s0)
    80021bf2:	739c                	ld	a5,32(a5)
    80021bf4:	739c                	ld	a5,32(a5)
    80021bf6:	85be                	mv	a1,a5
    80021bf8:	fd843503          	ld	a0,-40(s0)
    80021bfc:	d75ff0ef          	jal	ra,80021970 <left_rotate>
    while (z != rb->root && z->parent->color == RED) {
    80021c00:	fd843783          	ld	a5,-40(s0)
    80021c04:	639c                	ld	a5,0(a5)
    80021c06:	fd043703          	ld	a4,-48(s0)
    80021c0a:	00f70863          	beq	a4,a5,80021c1a <fix_insert+0x16e>
    80021c0e:	fd043783          	ld	a5,-48(s0)
    80021c12:	739c                	ld	a5,32(a5)
    80021c14:	439c                	lw	a5,0(a5)
    80021c16:	ea0784e3          	beqz	a5,80021abe <fix_insert+0x12>
            }
        }
    }
    rb->root->color = BLACK;
    80021c1a:	fd843783          	ld	a5,-40(s0)
    80021c1e:	639c                	ld	a5,0(a5)
    80021c20:	4705                	li	a4,1
    80021c22:	c398                	sw	a4,0(a5)
}
    80021c24:	0001                	nop
    80021c26:	70a2                	ld	ra,40(sp)
    80021c28:	7402                	ld	s0,32(sp)
    80021c2a:	6145                	addi	sp,sp,48
    80021c2c:	8082                	ret

0000000080021c2e <rb_insert>:

// Function to insert a node into the red-black tree
void rb_insert(RBTree *rb, int key, uint64_t value)
{
    80021c2e:	715d                	addi	sp,sp,-80
    80021c30:	e486                	sd	ra,72(sp)
    80021c32:	e0a2                	sd	s0,64(sp)
    80021c34:	0880                	addi	s0,sp,80
    80021c36:	fca43423          	sd	a0,-56(s0)
    80021c3a:	87ae                	mv	a5,a1
    80021c3c:	fac43c23          	sd	a2,-72(s0)
    80021c40:	fcf42223          	sw	a5,-60(s0)
    Node *z = create_node(key, value);
    80021c44:	fc442783          	lw	a5,-60(s0)
    80021c48:	fb843583          	ld	a1,-72(s0)
    80021c4c:	853e                	mv	a0,a5
    80021c4e:	a2dff0ef          	jal	ra,8002167a <create_node>
    80021c52:	fca43c23          	sd	a0,-40(s0)
    Node *y = NULL;
    80021c56:	fe043423          	sd	zero,-24(s0)
    Node *x = rb->root;
    80021c5a:	fc843783          	ld	a5,-56(s0)
    80021c5e:	639c                	ld	a5,0(a5)
    80021c60:	fef43023          	sd	a5,-32(s0)
    while (x != NULL) {
    80021c64:	a805                	j	80021c94 <rb_insert+0x66>
        y = x;
    80021c66:	fe043783          	ld	a5,-32(s0)
    80021c6a:	fef43423          	sd	a5,-24(s0)
        if (z->key < x->key) {
    80021c6e:	fd843783          	ld	a5,-40(s0)
    80021c72:	43d8                	lw	a4,4(a5)
    80021c74:	fe043783          	ld	a5,-32(s0)
    80021c78:	43dc                	lw	a5,4(a5)
    80021c7a:	00f75863          	bge	a4,a5,80021c8a <rb_insert+0x5c>
            x = x->left;
    80021c7e:	fe043783          	ld	a5,-32(s0)
    80021c82:	6b9c                	ld	a5,16(a5)
    80021c84:	fef43023          	sd	a5,-32(s0)
    80021c88:	a031                	j	80021c94 <rb_insert+0x66>
        }
        else {
            x = x->right;
    80021c8a:	fe043783          	ld	a5,-32(s0)
    80021c8e:	6f9c                	ld	a5,24(a5)
    80021c90:	fef43023          	sd	a5,-32(s0)
    while (x != NULL) {
    80021c94:	fe043783          	ld	a5,-32(s0)
    80021c98:	f7f9                	bnez	a5,80021c66 <rb_insert+0x38>
        }
    }
    z->parent = y;
    80021c9a:	fd843783          	ld	a5,-40(s0)
    80021c9e:	fe843703          	ld	a4,-24(s0)
    80021ca2:	f398                	sd	a4,32(a5)
    if (y == NULL) {
    80021ca4:	fe843783          	ld	a5,-24(s0)
    80021ca8:	e799                	bnez	a5,80021cb6 <rb_insert+0x88>
        rb->root = z;
    80021caa:	fc843783          	ld	a5,-56(s0)
    80021cae:	fd843703          	ld	a4,-40(s0)
    80021cb2:	e398                	sd	a4,0(a5)
    80021cb4:	a025                	j	80021cdc <rb_insert+0xae>
    }
    else if (z->key < y->key) {
    80021cb6:	fd843783          	ld	a5,-40(s0)
    80021cba:	43d8                	lw	a4,4(a5)
    80021cbc:	fe843783          	ld	a5,-24(s0)
    80021cc0:	43dc                	lw	a5,4(a5)
    80021cc2:	00f75863          	bge	a4,a5,80021cd2 <rb_insert+0xa4>
        y->left = z;
    80021cc6:	fe843783          	ld	a5,-24(s0)
    80021cca:	fd843703          	ld	a4,-40(s0)
    80021cce:	eb98                	sd	a4,16(a5)
    80021cd0:	a031                	j	80021cdc <rb_insert+0xae>
    }
    else {
        y->right = z;
    80021cd2:	fe843783          	ld	a5,-24(s0)
    80021cd6:	fd843703          	ld	a4,-40(s0)
    80021cda:	ef98                	sd	a4,24(a5)
    }
    fix_insert(rb, z);
    80021cdc:	fd843583          	ld	a1,-40(s0)
    80021ce0:	fc843503          	ld	a0,-56(s0)
    80021ce4:	dc9ff0ef          	jal	ra,80021aac <fix_insert>
}
    80021ce8:	0001                	nop
    80021cea:	60a6                	ld	ra,72(sp)
    80021cec:	6406                	ld	s0,64(sp)
    80021cee:	6161                	addi	sp,sp,80
    80021cf0:	8082                	ret

0000000080021cf2 <transplant>:

static void transplant(RBTree *rb, Node *u, Node *v)
{
    80021cf2:	7179                	addi	sp,sp,-48
    80021cf4:	f422                	sd	s0,40(sp)
    80021cf6:	1800                	addi	s0,sp,48
    80021cf8:	fea43423          	sd	a0,-24(s0)
    80021cfc:	feb43023          	sd	a1,-32(s0)
    80021d00:	fcc43c23          	sd	a2,-40(s0)
    if (u->parent == NULL) {
    80021d04:	fe043783          	ld	a5,-32(s0)
    80021d08:	739c                	ld	a5,32(a5)
    80021d0a:	e799                	bnez	a5,80021d18 <transplant+0x26>
        rb->root = v;
    80021d0c:	fe843783          	ld	a5,-24(s0)
    80021d10:	fd843703          	ld	a4,-40(s0)
    80021d14:	e398                	sd	a4,0(a5)
    80021d16:	a035                	j	80021d42 <transplant+0x50>
    }
    else if (u == u->parent->left) {
    80021d18:	fe043783          	ld	a5,-32(s0)
    80021d1c:	739c                	ld	a5,32(a5)
    80021d1e:	6b9c                	ld	a5,16(a5)
    80021d20:	fe043703          	ld	a4,-32(s0)
    80021d24:	00f71963          	bne	a4,a5,80021d36 <transplant+0x44>
        u->parent->left = v;
    80021d28:	fe043783          	ld	a5,-32(s0)
    80021d2c:	739c                	ld	a5,32(a5)
    80021d2e:	fd843703          	ld	a4,-40(s0)
    80021d32:	eb98                	sd	a4,16(a5)
    80021d34:	a039                	j	80021d42 <transplant+0x50>
    }
    else {
        u->parent->right = v;
    80021d36:	fe043783          	ld	a5,-32(s0)
    80021d3a:	739c                	ld	a5,32(a5)
    80021d3c:	fd843703          	ld	a4,-40(s0)
    80021d40:	ef98                	sd	a4,24(a5)
    }
    if (v != NULL) {
    80021d42:	fd843783          	ld	a5,-40(s0)
    80021d46:	c799                	beqz	a5,80021d54 <transplant+0x62>
        v->parent = u->parent;
    80021d48:	fe043783          	ld	a5,-32(s0)
    80021d4c:	7398                	ld	a4,32(a5)
    80021d4e:	fd843783          	ld	a5,-40(s0)
    80021d52:	f398                	sd	a4,32(a5)
    }
}
    80021d54:	0001                	nop
    80021d56:	7422                	ld	s0,40(sp)
    80021d58:	6145                	addi	sp,sp,48
    80021d5a:	8082                	ret

0000000080021d5c <delete_fixup>:

static void delete_fixup(RBTree *rb, Node *x, Node *x_parent)
{
    80021d5c:	7139                	addi	sp,sp,-64
    80021d5e:	fc06                	sd	ra,56(sp)
    80021d60:	f822                	sd	s0,48(sp)
    80021d62:	0080                	addi	s0,sp,64
    80021d64:	fca43c23          	sd	a0,-40(s0)
    80021d68:	fcb43823          	sd	a1,-48(s0)
    80021d6c:	fcc43423          	sd	a2,-56(s0)
    Node *w;
    while (x != rb->root && (x == NULL || x->color == BLACK)) {
    80021d70:	a415                	j	80021f94 <delete_fixup+0x238>
        if (x == x_parent->left) {
    80021d72:	fc843783          	ld	a5,-56(s0)
    80021d76:	6b9c                	ld	a5,16(a5)
    80021d78:	fd043703          	ld	a4,-48(s0)
    80021d7c:	10f71763          	bne	a4,a5,80021e8a <delete_fixup+0x12e>
            w = x_parent->right;
    80021d80:	fc843783          	ld	a5,-56(s0)
    80021d84:	6f9c                	ld	a5,24(a5)
    80021d86:	fef43423          	sd	a5,-24(s0)
            if (w->color == RED) {
    80021d8a:	fe843783          	ld	a5,-24(s0)
    80021d8e:	439c                	lw	a5,0(a5)
    80021d90:	e785                	bnez	a5,80021db8 <delete_fixup+0x5c>
                w->color        = BLACK;
    80021d92:	fe843783          	ld	a5,-24(s0)
    80021d96:	4705                	li	a4,1
    80021d98:	c398                	sw	a4,0(a5)
                x_parent->color = RED;
    80021d9a:	fc843783          	ld	a5,-56(s0)
    80021d9e:	0007a023          	sw	zero,0(a5)
                left_rotate(rb, x_parent);
    80021da2:	fc843583          	ld	a1,-56(s0)
    80021da6:	fd843503          	ld	a0,-40(s0)
    80021daa:	bc7ff0ef          	jal	ra,80021970 <left_rotate>
                w = x_parent->right;
    80021dae:	fc843783          	ld	a5,-56(s0)
    80021db2:	6f9c                	ld	a5,24(a5)
    80021db4:	fef43423          	sd	a5,-24(s0)
            }
            if ((w->left == NULL || w->left->color == BLACK) &&
    80021db8:	fe843783          	ld	a5,-24(s0)
    80021dbc:	6b9c                	ld	a5,16(a5)
    80021dbe:	cb89                	beqz	a5,80021dd0 <delete_fixup+0x74>
    80021dc0:	fe843783          	ld	a5,-24(s0)
    80021dc4:	6b9c                	ld	a5,16(a5)
    80021dc6:	439c                	lw	a5,0(a5)
    80021dc8:	873e                	mv	a4,a5
    80021dca:	4785                	li	a5,1
    80021dcc:	02f71c63          	bne	a4,a5,80021e04 <delete_fixup+0xa8>
                (w->right == NULL || w->right->color == BLACK)) {
    80021dd0:	fe843783          	ld	a5,-24(s0)
    80021dd4:	6f9c                	ld	a5,24(a5)
            if ((w->left == NULL || w->left->color == BLACK) &&
    80021dd6:	cb89                	beqz	a5,80021de8 <delete_fixup+0x8c>
                (w->right == NULL || w->right->color == BLACK)) {
    80021dd8:	fe843783          	ld	a5,-24(s0)
    80021ddc:	6f9c                	ld	a5,24(a5)
    80021dde:	439c                	lw	a5,0(a5)
    80021de0:	873e                	mv	a4,a5
    80021de2:	4785                	li	a5,1
    80021de4:	02f71063          	bne	a4,a5,80021e04 <delete_fixup+0xa8>
                w->color = RED;
    80021de8:	fe843783          	ld	a5,-24(s0)
    80021dec:	0007a023          	sw	zero,0(a5)
                x        = x_parent;
    80021df0:	fc843783          	ld	a5,-56(s0)
    80021df4:	fcf43823          	sd	a5,-48(s0)
                x_parent = x_parent->parent;
    80021df8:	fc843783          	ld	a5,-56(s0)
    80021dfc:	739c                	ld	a5,32(a5)
    80021dfe:	fcf43423          	sd	a5,-56(s0)
    80021e02:	aa49                	j	80021f94 <delete_fixup+0x238>
            }
            else {
                if (w->right == NULL || w->right->color == BLACK) {
    80021e04:	fe843783          	ld	a5,-24(s0)
    80021e08:	6f9c                	ld	a5,24(a5)
    80021e0a:	cb89                	beqz	a5,80021e1c <delete_fixup+0xc0>
    80021e0c:	fe843783          	ld	a5,-24(s0)
    80021e10:	6f9c                	ld	a5,24(a5)
    80021e12:	439c                	lw	a5,0(a5)
    80021e14:	873e                	mv	a4,a5
    80021e16:	4785                	li	a5,1
    80021e18:	02f71a63          	bne	a4,a5,80021e4c <delete_fixup+0xf0>
                    if (w->left != NULL) {
    80021e1c:	fe843783          	ld	a5,-24(s0)
    80021e20:	6b9c                	ld	a5,16(a5)
    80021e22:	c791                	beqz	a5,80021e2e <delete_fixup+0xd2>
                        w->left->color = BLACK;
    80021e24:	fe843783          	ld	a5,-24(s0)
    80021e28:	6b9c                	ld	a5,16(a5)
    80021e2a:	4705                	li	a4,1
    80021e2c:	c398                	sw	a4,0(a5)
                    }
                    w->color = RED;
    80021e2e:	fe843783          	ld	a5,-24(s0)
    80021e32:	0007a023          	sw	zero,0(a5)
                    right_rotate(rb, w);
    80021e36:	fe843583          	ld	a1,-24(s0)
    80021e3a:	fd843503          	ld	a0,-40(s0)
    80021e3e:	bd1ff0ef          	jal	ra,80021a0e <right_rotate>
                    w = x_parent->right;
    80021e42:	fc843783          	ld	a5,-56(s0)
    80021e46:	6f9c                	ld	a5,24(a5)
    80021e48:	fef43423          	sd	a5,-24(s0)
                }
                w->color        = x_parent->color;
    80021e4c:	fc843783          	ld	a5,-56(s0)
    80021e50:	4398                	lw	a4,0(a5)
    80021e52:	fe843783          	ld	a5,-24(s0)
    80021e56:	c398                	sw	a4,0(a5)
                x_parent->color = BLACK;
    80021e58:	fc843783          	ld	a5,-56(s0)
    80021e5c:	4705                	li	a4,1
    80021e5e:	c398                	sw	a4,0(a5)
                if (w->right != NULL) {
    80021e60:	fe843783          	ld	a5,-24(s0)
    80021e64:	6f9c                	ld	a5,24(a5)
    80021e66:	c791                	beqz	a5,80021e72 <delete_fixup+0x116>
                    w->right->color = BLACK;
    80021e68:	fe843783          	ld	a5,-24(s0)
    80021e6c:	6f9c                	ld	a5,24(a5)
    80021e6e:	4705                	li	a4,1
    80021e70:	c398                	sw	a4,0(a5)
                }
                left_rotate(rb, x_parent);
    80021e72:	fc843583          	ld	a1,-56(s0)
    80021e76:	fd843503          	ld	a0,-40(s0)
    80021e7a:	af7ff0ef          	jal	ra,80021970 <left_rotate>
                x = rb->root;
    80021e7e:	fd843783          	ld	a5,-40(s0)
    80021e82:	639c                	ld	a5,0(a5)
    80021e84:	fcf43823          	sd	a5,-48(s0)
                break;
    80021e88:	aa05                	j	80021fb8 <delete_fixup+0x25c>
            }
        }
        else {
            w = x_parent->left;
    80021e8a:	fc843783          	ld	a5,-56(s0)
    80021e8e:	6b9c                	ld	a5,16(a5)
    80021e90:	fef43423          	sd	a5,-24(s0)
            if (w->color == RED) {
    80021e94:	fe843783          	ld	a5,-24(s0)
    80021e98:	439c                	lw	a5,0(a5)
    80021e9a:	e785                	bnez	a5,80021ec2 <delete_fixup+0x166>
                w->color        = BLACK;
    80021e9c:	fe843783          	ld	a5,-24(s0)
    80021ea0:	4705                	li	a4,1
    80021ea2:	c398                	sw	a4,0(a5)
                x_parent->color = RED;
    80021ea4:	fc843783          	ld	a5,-56(s0)
    80021ea8:	0007a023          	sw	zero,0(a5)
                right_rotate(rb, x_parent);
    80021eac:	fc843583          	ld	a1,-56(s0)
    80021eb0:	fd843503          	ld	a0,-40(s0)
    80021eb4:	b5bff0ef          	jal	ra,80021a0e <right_rotate>
                w = x_parent->left;
    80021eb8:	fc843783          	ld	a5,-56(s0)
    80021ebc:	6b9c                	ld	a5,16(a5)
    80021ebe:	fef43423          	sd	a5,-24(s0)
            }
            if ((w->left == NULL || w->left->color == BLACK) &&
    80021ec2:	fe843783          	ld	a5,-24(s0)
    80021ec6:	6b9c                	ld	a5,16(a5)
    80021ec8:	cb89                	beqz	a5,80021eda <delete_fixup+0x17e>
    80021eca:	fe843783          	ld	a5,-24(s0)
    80021ece:	6b9c                	ld	a5,16(a5)
    80021ed0:	439c                	lw	a5,0(a5)
    80021ed2:	873e                	mv	a4,a5
    80021ed4:	4785                	li	a5,1
    80021ed6:	02f71c63          	bne	a4,a5,80021f0e <delete_fixup+0x1b2>
                (w->right == NULL || w->right->color == BLACK)) {
    80021eda:	fe843783          	ld	a5,-24(s0)
    80021ede:	6f9c                	ld	a5,24(a5)
            if ((w->left == NULL || w->left->color == BLACK) &&
    80021ee0:	cb89                	beqz	a5,80021ef2 <delete_fixup+0x196>
                (w->right == NULL || w->right->color == BLACK)) {
    80021ee2:	fe843783          	ld	a5,-24(s0)
    80021ee6:	6f9c                	ld	a5,24(a5)
    80021ee8:	439c                	lw	a5,0(a5)
    80021eea:	873e                	mv	a4,a5
    80021eec:	4785                	li	a5,1
    80021eee:	02f71063          	bne	a4,a5,80021f0e <delete_fixup+0x1b2>
                w->color = RED;
    80021ef2:	fe843783          	ld	a5,-24(s0)
    80021ef6:	0007a023          	sw	zero,0(a5)
                x        = x_parent;
    80021efa:	fc843783          	ld	a5,-56(s0)
    80021efe:	fcf43823          	sd	a5,-48(s0)
                x_parent = x_parent->parent;
    80021f02:	fc843783          	ld	a5,-56(s0)
    80021f06:	739c                	ld	a5,32(a5)
    80021f08:	fcf43423          	sd	a5,-56(s0)
    80021f0c:	a061                	j	80021f94 <delete_fixup+0x238>
            }
            else {
                if (w->left == NULL || w->left->color == BLACK) {
    80021f0e:	fe843783          	ld	a5,-24(s0)
    80021f12:	6b9c                	ld	a5,16(a5)
    80021f14:	cb89                	beqz	a5,80021f26 <delete_fixup+0x1ca>
    80021f16:	fe843783          	ld	a5,-24(s0)
    80021f1a:	6b9c                	ld	a5,16(a5)
    80021f1c:	439c                	lw	a5,0(a5)
    80021f1e:	873e                	mv	a4,a5
    80021f20:	4785                	li	a5,1
    80021f22:	02f71a63          	bne	a4,a5,80021f56 <delete_fixup+0x1fa>
                    if (w->right != NULL) {
    80021f26:	fe843783          	ld	a5,-24(s0)
    80021f2a:	6f9c                	ld	a5,24(a5)
    80021f2c:	c791                	beqz	a5,80021f38 <delete_fixup+0x1dc>
                        w->right->color = BLACK;
    80021f2e:	fe843783          	ld	a5,-24(s0)
    80021f32:	6f9c                	ld	a5,24(a5)
    80021f34:	4705                	li	a4,1
    80021f36:	c398                	sw	a4,0(a5)
                    }
                    w->color = RED;
    80021f38:	fe843783          	ld	a5,-24(s0)
    80021f3c:	0007a023          	sw	zero,0(a5)
                    left_rotate(rb, w);
    80021f40:	fe843583          	ld	a1,-24(s0)
    80021f44:	fd843503          	ld	a0,-40(s0)
    80021f48:	a29ff0ef          	jal	ra,80021970 <left_rotate>
                    w = x_parent->left;
    80021f4c:	fc843783          	ld	a5,-56(s0)
    80021f50:	6b9c                	ld	a5,16(a5)
    80021f52:	fef43423          	sd	a5,-24(s0)
                }
                w->color        = x_parent->color;
    80021f56:	fc843783          	ld	a5,-56(s0)
    80021f5a:	4398                	lw	a4,0(a5)
    80021f5c:	fe843783          	ld	a5,-24(s0)
    80021f60:	c398                	sw	a4,0(a5)
                x_parent->color = BLACK;
    80021f62:	fc843783          	ld	a5,-56(s0)
    80021f66:	4705                	li	a4,1
    80021f68:	c398                	sw	a4,0(a5)
                if (w->left != NULL) {
    80021f6a:	fe843783          	ld	a5,-24(s0)
    80021f6e:	6b9c                	ld	a5,16(a5)
    80021f70:	c791                	beqz	a5,80021f7c <delete_fixup+0x220>
                    w->left->color = BLACK;
    80021f72:	fe843783          	ld	a5,-24(s0)
    80021f76:	6b9c                	ld	a5,16(a5)
    80021f78:	4705                	li	a4,1
    80021f7a:	c398                	sw	a4,0(a5)
                }
                right_rotate(rb, x_parent);
    80021f7c:	fc843583          	ld	a1,-56(s0)
    80021f80:	fd843503          	ld	a0,-40(s0)
    80021f84:	a8bff0ef          	jal	ra,80021a0e <right_rotate>
                x = rb->root;
    80021f88:	fd843783          	ld	a5,-40(s0)
    80021f8c:	639c                	ld	a5,0(a5)
    80021f8e:	fcf43823          	sd	a5,-48(s0)
                break;
    80021f92:	a01d                	j	80021fb8 <delete_fixup+0x25c>
    while (x != rb->root && (x == NULL || x->color == BLACK)) {
    80021f94:	fd843783          	ld	a5,-40(s0)
    80021f98:	639c                	ld	a5,0(a5)
    80021f9a:	fd043703          	ld	a4,-48(s0)
    80021f9e:	00f70d63          	beq	a4,a5,80021fb8 <delete_fixup+0x25c>
    80021fa2:	fd043783          	ld	a5,-48(s0)
    80021fa6:	dc0786e3          	beqz	a5,80021d72 <delete_fixup+0x16>
    80021faa:	fd043783          	ld	a5,-48(s0)
    80021fae:	439c                	lw	a5,0(a5)
    80021fb0:	873e                	mv	a4,a5
    80021fb2:	4785                	li	a5,1
    80021fb4:	daf70fe3          	beq	a4,a5,80021d72 <delete_fixup+0x16>
            }
        }
    }
    if (x != NULL) {
    80021fb8:	fd043783          	ld	a5,-48(s0)
    80021fbc:	c789                	beqz	a5,80021fc6 <delete_fixup+0x26a>
        x->color = BLACK;
    80021fbe:	fd043783          	ld	a5,-48(s0)
    80021fc2:	4705                	li	a4,1
    80021fc4:	c398                	sw	a4,0(a5)
    }
}
    80021fc6:	0001                	nop
    80021fc8:	70e2                	ld	ra,56(sp)
    80021fca:	7442                	ld	s0,48(sp)
    80021fcc:	6121                	addi	sp,sp,64
    80021fce:	8082                	ret

0000000080021fd0 <rb_delete>:

void rb_delete(RBTree *rb, int key)
{
    80021fd0:	7139                	addi	sp,sp,-64
    80021fd2:	fc06                	sd	ra,56(sp)
    80021fd4:	f822                	sd	s0,48(sp)
    80021fd6:	0080                	addi	s0,sp,64
    80021fd8:	fca43423          	sd	a0,-56(s0)
    80021fdc:	87ae                	mv	a5,a1
    80021fde:	fcf42223          	sw	a5,-60(s0)
    Node *z = search(rb->root, key);
    80021fe2:	fc843783          	ld	a5,-56(s0)
    80021fe6:	639c                	ld	a5,0(a5)
    80021fe8:	fc442703          	lw	a4,-60(s0)
    80021fec:	85ba                	mv	a1,a4
    80021fee:	853e                	mv	a0,a5
    80021ff0:	f52ff0ef          	jal	ra,80021742 <search>
    80021ff4:	fca43823          	sd	a0,-48(s0)
    if (z == NULL) {
    80021ff8:	fd043783          	ld	a5,-48(s0)
    80021ffc:	12078b63          	beqz	a5,80022132 <rb_delete+0x162>
        return;
    }
    Node *x, *y = z;
    80022000:	fd043783          	ld	a5,-48(s0)
    80022004:	fef43023          	sd	a5,-32(s0)
    Color y_original_color = y->color;
    80022008:	fe043783          	ld	a5,-32(s0)
    8002200c:	439c                	lw	a5,0(a5)
    8002200e:	fcf42e23          	sw	a5,-36(s0)
    if (z->left == NULL) {
    80022012:	fd043783          	ld	a5,-48(s0)
    80022016:	6b9c                	ld	a5,16(a5)
    80022018:	e38d                	bnez	a5,8002203a <rb_delete+0x6a>
        x = z->right;
    8002201a:	fd043783          	ld	a5,-48(s0)
    8002201e:	6f9c                	ld	a5,24(a5)
    80022020:	fef43423          	sd	a5,-24(s0)
        transplant(rb, z, z->right);
    80022024:	fd043783          	ld	a5,-48(s0)
    80022028:	6f9c                	ld	a5,24(a5)
    8002202a:	863e                	mv	a2,a5
    8002202c:	fd043583          	ld	a1,-48(s0)
    80022030:	fc843503          	ld	a0,-56(s0)
    80022034:	cbfff0ef          	jal	ra,80021cf2 <transplant>
    80022038:	a0f9                	j	80022106 <rb_delete+0x136>
    }
    else if (z->right == NULL) {
    8002203a:	fd043783          	ld	a5,-48(s0)
    8002203e:	6f9c                	ld	a5,24(a5)
    80022040:	e38d                	bnez	a5,80022062 <rb_delete+0x92>
        x = z->left;
    80022042:	fd043783          	ld	a5,-48(s0)
    80022046:	6b9c                	ld	a5,16(a5)
    80022048:	fef43423          	sd	a5,-24(s0)
        transplant(rb, z, z->left);
    8002204c:	fd043783          	ld	a5,-48(s0)
    80022050:	6b9c                	ld	a5,16(a5)
    80022052:	863e                	mv	a2,a5
    80022054:	fd043583          	ld	a1,-48(s0)
    80022058:	fc843503          	ld	a0,-56(s0)
    8002205c:	c97ff0ef          	jal	ra,80021cf2 <transplant>
    80022060:	a05d                	j	80022106 <rb_delete+0x136>
    }
    else {
        y                = minimum(z->right);
    80022062:	fd043783          	ld	a5,-48(s0)
    80022066:	6f9c                	ld	a5,24(a5)
    80022068:	853e                	mv	a0,a5
    8002206a:	f38ff0ef          	jal	ra,800217a2 <minimum>
    8002206e:	fea43023          	sd	a0,-32(s0)
        y_original_color = y->color;
    80022072:	fe043783          	ld	a5,-32(s0)
    80022076:	439c                	lw	a5,0(a5)
    80022078:	fcf42e23          	sw	a5,-36(s0)
        x                = y->right;
    8002207c:	fe043783          	ld	a5,-32(s0)
    80022080:	6f9c                	ld	a5,24(a5)
    80022082:	fef43423          	sd	a5,-24(s0)
        if (y->parent == z) {
    80022086:	fe043783          	ld	a5,-32(s0)
    8002208a:	739c                	ld	a5,32(a5)
    8002208c:	fd043703          	ld	a4,-48(s0)
    80022090:	00f71b63          	bne	a4,a5,800220a6 <rb_delete+0xd6>
            if (x != NULL) {
    80022094:	fe843783          	ld	a5,-24(s0)
    80022098:	cf8d                	beqz	a5,800220d2 <rb_delete+0x102>
                x->parent = y;
    8002209a:	fe843783          	ld	a5,-24(s0)
    8002209e:	fe043703          	ld	a4,-32(s0)
    800220a2:	f398                	sd	a4,32(a5)
    800220a4:	a03d                	j	800220d2 <rb_delete+0x102>
            }
        }
        else {
            transplant(rb, y, y->right);
    800220a6:	fe043783          	ld	a5,-32(s0)
    800220aa:	6f9c                	ld	a5,24(a5)
    800220ac:	863e                	mv	a2,a5
    800220ae:	fe043583          	ld	a1,-32(s0)
    800220b2:	fc843503          	ld	a0,-56(s0)
    800220b6:	c3dff0ef          	jal	ra,80021cf2 <transplant>
            y->right         = z->right;
    800220ba:	fd043783          	ld	a5,-48(s0)
    800220be:	6f98                	ld	a4,24(a5)
    800220c0:	fe043783          	ld	a5,-32(s0)
    800220c4:	ef98                	sd	a4,24(a5)
            y->right->parent = y;
    800220c6:	fe043783          	ld	a5,-32(s0)
    800220ca:	6f9c                	ld	a5,24(a5)
    800220cc:	fe043703          	ld	a4,-32(s0)
    800220d0:	f398                	sd	a4,32(a5)
        }
        transplant(rb, z, y);
    800220d2:	fe043603          	ld	a2,-32(s0)
    800220d6:	fd043583          	ld	a1,-48(s0)
    800220da:	fc843503          	ld	a0,-56(s0)
    800220de:	c15ff0ef          	jal	ra,80021cf2 <transplant>
        y->left         = z->left;
    800220e2:	fd043783          	ld	a5,-48(s0)
    800220e6:	6b98                	ld	a4,16(a5)
    800220e8:	fe043783          	ld	a5,-32(s0)
    800220ec:	eb98                	sd	a4,16(a5)
        y->left->parent = y;
    800220ee:	fe043783          	ld	a5,-32(s0)
    800220f2:	6b9c                	ld	a5,16(a5)
    800220f4:	fe043703          	ld	a4,-32(s0)
    800220f8:	f398                	sd	a4,32(a5)
        y->color        = z->color;
    800220fa:	fd043783          	ld	a5,-48(s0)
    800220fe:	4398                	lw	a4,0(a5)
    80022100:	fe043783          	ld	a5,-32(s0)
    80022104:	c398                	sw	a4,0(a5)
    }
    if (y_original_color == BLACK) {
    80022106:	fdc42783          	lw	a5,-36(s0)
    8002210a:	0007871b          	sext.w	a4,a5
    8002210e:	4785                	li	a5,1
    80022110:	00f71c63          	bne	a4,a5,80022128 <rb_delete+0x158>
        delete_fixup(rb, x, y->parent);
    80022114:	fe043783          	ld	a5,-32(s0)
    80022118:	739c                	ld	a5,32(a5)
    8002211a:	863e                	mv	a2,a5
    8002211c:	fe843583          	ld	a1,-24(s0)
    80022120:	fc843503          	ld	a0,-56(s0)
    80022124:	c39ff0ef          	jal	ra,80021d5c <delete_fixup>
    }
    g_kfree(z);
    80022128:	fd043503          	ld	a0,-48(s0)
    8002212c:	a3afe0ef          	jal	ra,80020366 <g_kfree>
    80022130:	a011                	j	80022134 <rb_delete+0x164>
        return;
    80022132:	0001                	nop
}
    80022134:	70e2                	ld	ra,56(sp)
    80022136:	7442                	ld	s0,48(sp)
    80022138:	6121                	addi	sp,sp,64
    8002213a:	8082                	ret

000000008002213c <rb_new>:

struct RBTree *rb_new(void)
{
    8002213c:	1141                	addi	sp,sp,-16
    8002213e:	e406                	sd	ra,8(sp)
    80022140:	e022                	sd	s0,0(sp)
    80022142:	0800                	addi	s0,sp,16
    return (RBTree *)g_kcalloc(1, sizeof(RBTree));
    80022144:	45a1                	li	a1,8
    80022146:	4505                	li	a0,1
    80022148:	9bcfe0ef          	jal	ra,80020304 <g_kcalloc>
    8002214c:	87aa                	mv	a5,a0
}
    8002214e:	853e                	mv	a0,a5
    80022150:	60a2                	ld	ra,8(sp)
    80022152:	6402                	ld	s0,0(sp)
    80022154:	0141                	addi	sp,sp,16
    80022156:	8082                	ret

0000000080022158 <rb_find>:

bool rb_find(const struct RBTree *rb, int key, uint64_t *value)
{
    80022158:	7139                	addi	sp,sp,-64
    8002215a:	fc06                	sd	ra,56(sp)
    8002215c:	f822                	sd	s0,48(sp)
    8002215e:	0080                	addi	s0,sp,64
    80022160:	fca43c23          	sd	a0,-40(s0)
    80022164:	87ae                	mv	a5,a1
    80022166:	fcc43423          	sd	a2,-56(s0)
    8002216a:	fcf42a23          	sw	a5,-44(s0)
    const Node *node = csearch(rb->root, key);
    8002216e:	fd843783          	ld	a5,-40(s0)
    80022172:	639c                	ld	a5,0(a5)
    80022174:	fd442703          	lw	a4,-44(s0)
    80022178:	85ba                	mv	a1,a4
    8002217a:	853e                	mv	a0,a5
    8002217c:	d66ff0ef          	jal	ra,800216e2 <csearch>
    80022180:	fea43423          	sd	a0,-24(s0)

    if (!node) {
    80022184:	fe843783          	ld	a5,-24(s0)
    80022188:	e399                	bnez	a5,8002218e <rb_find+0x36>
        return false;
    8002218a:	4781                	li	a5,0
    8002218c:	a819                	j	800221a2 <rb_find+0x4a>
    }
    if (value) {
    8002218e:	fc843783          	ld	a5,-56(s0)
    80022192:	c799                	beqz	a5,800221a0 <rb_find+0x48>
        *value = node->value;
    80022194:	fe843783          	ld	a5,-24(s0)
    80022198:	6798                	ld	a4,8(a5)
    8002219a:	fc843783          	ld	a5,-56(s0)
    8002219e:	e398                	sd	a4,0(a5)
    }
    return true;
    800221a0:	4785                	li	a5,1
}
    800221a2:	853e                	mv	a0,a5
    800221a4:	70e2                	ld	ra,56(sp)
    800221a6:	7442                	ld	s0,48(sp)
    800221a8:	6121                	addi	sp,sp,64
    800221aa:	8082                	ret

00000000800221ac <rbfree_node>:

static void rbfree_node(Node *node)
{
    800221ac:	1101                	addi	sp,sp,-32
    800221ae:	ec06                	sd	ra,24(sp)
    800221b0:	e822                	sd	s0,16(sp)
    800221b2:	1000                	addi	s0,sp,32
    800221b4:	fea43423          	sd	a0,-24(s0)
    if (node != NULL) {
    800221b8:	fe843783          	ld	a5,-24(s0)
    800221bc:	c38d                	beqz	a5,800221de <rbfree_node+0x32>
        rbfree_node(node->right);
    800221be:	fe843783          	ld	a5,-24(s0)
    800221c2:	6f9c                	ld	a5,24(a5)
    800221c4:	853e                	mv	a0,a5
    800221c6:	fe7ff0ef          	jal	ra,800221ac <rbfree_node>
        rbfree_node(node->left);
    800221ca:	fe843783          	ld	a5,-24(s0)
    800221ce:	6b9c                	ld	a5,16(a5)
    800221d0:	853e                	mv	a0,a5
    800221d2:	fdbff0ef          	jal	ra,800221ac <rbfree_node>
        g_kfree(node);
    800221d6:	fe843503          	ld	a0,-24(s0)
    800221da:	98cfe0ef          	jal	ra,80020366 <g_kfree>
    }
}
    800221de:	0001                	nop
    800221e0:	60e2                	ld	ra,24(sp)
    800221e2:	6442                	ld	s0,16(sp)
    800221e4:	6105                	addi	sp,sp,32
    800221e6:	8082                	ret

00000000800221e8 <rb_clear>:

void rb_clear(struct RBTree *rb)
{
    800221e8:	1101                	addi	sp,sp,-32
    800221ea:	ec06                	sd	ra,24(sp)
    800221ec:	e822                	sd	s0,16(sp)
    800221ee:	1000                	addi	s0,sp,32
    800221f0:	fea43423          	sd	a0,-24(s0)
    rbfree_node(rb->root);
    800221f4:	fe843783          	ld	a5,-24(s0)
    800221f8:	639c                	ld	a5,0(a5)
    800221fa:	853e                	mv	a0,a5
    800221fc:	fb1ff0ef          	jal	ra,800221ac <rbfree_node>
    rb->root = NULL;
    80022200:	fe843783          	ld	a5,-24(s0)
    80022204:	0007b023          	sd	zero,0(a5)
}
    80022208:	0001                	nop
    8002220a:	60e2                	ld	ra,24(sp)
    8002220c:	6442                	ld	s0,16(sp)
    8002220e:	6105                	addi	sp,sp,32
    80022210:	8082                	ret

0000000080022212 <rb_free>:

void rb_free(struct RBTree *rb)
{
    80022212:	1101                	addi	sp,sp,-32
    80022214:	ec06                	sd	ra,24(sp)
    80022216:	e822                	sd	s0,16(sp)
    80022218:	1000                	addi	s0,sp,32
    8002221a:	fea43423          	sd	a0,-24(s0)
    rbfree_node(rb->root);
    8002221e:	fe843783          	ld	a5,-24(s0)
    80022222:	639c                	ld	a5,0(a5)
    80022224:	853e                	mv	a0,a5
    80022226:	f87ff0ef          	jal	ra,800221ac <rbfree_node>
    g_kfree(rb);
    8002222a:	fe843503          	ld	a0,-24(s0)
    8002222e:	938fe0ef          	jal	ra,80020366 <g_kfree>
}
    80022232:	0001                	nop
    80022234:	60e2                	ld	ra,24(sp)
    80022236:	6442                	ld	s0,16(sp)
    80022238:	6105                	addi	sp,sp,32
    8002223a:	8082                	ret

000000008002223c <memset>:
#include <alloc.h>
#include <stdint.h>
#include <util.h>

void *memset(void *dst, char data, int size)
{
    8002223c:	715d                	addi	sp,sp,-80
    8002223e:	e4a2                	sd	s0,72(sp)
    80022240:	0880                	addi	s0,sp,80
    80022242:	faa43c23          	sd	a0,-72(s0)
    80022246:	87ae                	mv	a5,a1
    80022248:	8732                	mv	a4,a2
    8002224a:	faf40ba3          	sb	a5,-73(s0)
    8002224e:	87ba                	mv	a5,a4
    80022250:	faf42823          	sw	a5,-80(s0)
    int64_t i;
    long *ldst = (long *)dst;
    80022254:	fb843783          	ld	a5,-72(s0)
    80022258:	fef43023          	sd	a5,-32(s0)
    char *cdst;
    char l[]              = {data, data, data, data, data, data, data, data};
    8002225c:	fb744783          	lbu	a5,-73(s0)
    80022260:	fcf40423          	sb	a5,-56(s0)
    80022264:	fb744783          	lbu	a5,-73(s0)
    80022268:	fcf404a3          	sb	a5,-55(s0)
    8002226c:	fb744783          	lbu	a5,-73(s0)
    80022270:	fcf40523          	sb	a5,-54(s0)
    80022274:	fb744783          	lbu	a5,-73(s0)
    80022278:	fcf405a3          	sb	a5,-53(s0)
    8002227c:	fb744783          	lbu	a5,-73(s0)
    80022280:	fcf40623          	sb	a5,-52(s0)
    80022284:	fb744783          	lbu	a5,-73(s0)
    80022288:	fcf406a3          	sb	a5,-51(s0)
    8002228c:	fb744783          	lbu	a5,-73(s0)
    80022290:	fcf40723          	sb	a5,-50(s0)
    80022294:	fb744783          	lbu	a5,-73(s0)
    80022298:	fcf407a3          	sb	a5,-49(s0)

    int num_8_byte_copies = size / 8;
    8002229c:	fb042783          	lw	a5,-80(s0)
    800222a0:	41f7d71b          	sraiw	a4,a5,0x1f
    800222a4:	01d7571b          	srliw	a4,a4,0x1d
    800222a8:	9fb9                	addw	a5,a5,a4
    800222aa:	4037d79b          	sraiw	a5,a5,0x3
    800222ae:	fcf42a23          	sw	a5,-44(s0)
    int num_1_byte_copies = size % 8;
    800222b2:	fb042703          	lw	a4,-80(s0)
    800222b6:	41f7579b          	sraiw	a5,a4,0x1f
    800222ba:	01d7d79b          	srliw	a5,a5,0x1d
    800222be:	9f3d                	addw	a4,a4,a5
    800222c0:	8b1d                	andi	a4,a4,7
    800222c2:	40f707bb          	subw	a5,a4,a5
    800222c6:	fcf42823          	sw	a5,-48(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    800222ca:	fe043423          	sd	zero,-24(s0)
    800222ce:	a005                	j	800222ee <memset+0xb2>
        *ldst++ = *((long *)l);
    800222d0:	fc840713          	addi	a4,s0,-56
    800222d4:	fe043783          	ld	a5,-32(s0)
    800222d8:	00878693          	addi	a3,a5,8
    800222dc:	fed43023          	sd	a3,-32(s0)
    800222e0:	6318                	ld	a4,0(a4)
    800222e2:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    800222e4:	fe843783          	ld	a5,-24(s0)
    800222e8:	0785                	addi	a5,a5,1
    800222ea:	fef43423          	sd	a5,-24(s0)
    800222ee:	fd442783          	lw	a5,-44(s0)
    800222f2:	fe843703          	ld	a4,-24(s0)
    800222f6:	fcf74de3          	blt	a4,a5,800222d0 <memset+0x94>
    }

    cdst = (char *)ldst;
    800222fa:	fe043783          	ld	a5,-32(s0)
    800222fe:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    80022302:	fe043423          	sd	zero,-24(s0)
    80022306:	a005                	j	80022326 <memset+0xea>
        *cdst++ = data;
    80022308:	fd843783          	ld	a5,-40(s0)
    8002230c:	00178713          	addi	a4,a5,1
    80022310:	fce43c23          	sd	a4,-40(s0)
    80022314:	fb744703          	lbu	a4,-73(s0)
    80022318:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    8002231c:	fe843783          	ld	a5,-24(s0)
    80022320:	0785                	addi	a5,a5,1
    80022322:	fef43423          	sd	a5,-24(s0)
    80022326:	fd042783          	lw	a5,-48(s0)
    8002232a:	fe843703          	ld	a4,-24(s0)
    8002232e:	fcf74de3          	blt	a4,a5,80022308 <memset+0xcc>
    }

    return dst;
    80022332:	fb843783          	ld	a5,-72(s0)
}
    80022336:	853e                	mv	a0,a5
    80022338:	6426                	ld	s0,72(sp)
    8002233a:	6161                	addi	sp,sp,80
    8002233c:	8082                	ret

000000008002233e <memcpy>:

void *memcpy(void *dst, const void *src, int size)
{
    8002233e:	711d                	addi	sp,sp,-96
    80022340:	eca2                	sd	s0,88(sp)
    80022342:	1080                	addi	s0,sp,96
    80022344:	faa43c23          	sd	a0,-72(s0)
    80022348:	fab43823          	sd	a1,-80(s0)
    8002234c:	87b2                	mv	a5,a2
    8002234e:	faf42623          	sw	a5,-84(s0)
    int i;
    char *cdst;
    const char *csrc;
    long *ldst            = (long *)dst;
    80022352:	fb843783          	ld	a5,-72(s0)
    80022356:	fcf43823          	sd	a5,-48(s0)
    const long *lsrc      = (long *)src;
    8002235a:	fb043783          	ld	a5,-80(s0)
    8002235e:	fcf43423          	sd	a5,-56(s0)

    int num_8_byte_copies = size / 8;
    80022362:	fac42783          	lw	a5,-84(s0)
    80022366:	41f7d71b          	sraiw	a4,a5,0x1f
    8002236a:	01d7571b          	srliw	a4,a4,0x1d
    8002236e:	9fb9                	addw	a5,a5,a4
    80022370:	4037d79b          	sraiw	a5,a5,0x3
    80022374:	fcf42223          	sw	a5,-60(s0)
    int num_1_byte_copies = size % 8;
    80022378:	fac42703          	lw	a4,-84(s0)
    8002237c:	41f7579b          	sraiw	a5,a4,0x1f
    80022380:	01d7d79b          	srliw	a5,a5,0x1d
    80022384:	9f3d                	addw	a4,a4,a5
    80022386:	8b1d                	andi	a4,a4,7
    80022388:	40f707bb          	subw	a5,a4,a5
    8002238c:	fcf42023          	sw	a5,-64(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    80022390:	fe042623          	sw	zero,-20(s0)
    80022394:	a025                	j	800223bc <memcpy+0x7e>
        *ldst++ = *lsrc++;
    80022396:	fc843703          	ld	a4,-56(s0)
    8002239a:	00870793          	addi	a5,a4,8
    8002239e:	fcf43423          	sd	a5,-56(s0)
    800223a2:	fd043783          	ld	a5,-48(s0)
    800223a6:	00878693          	addi	a3,a5,8
    800223aa:	fcd43823          	sd	a3,-48(s0)
    800223ae:	6318                	ld	a4,0(a4)
    800223b0:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    800223b2:	fec42783          	lw	a5,-20(s0)
    800223b6:	2785                	addiw	a5,a5,1
    800223b8:	fef42623          	sw	a5,-20(s0)
    800223bc:	fec42703          	lw	a4,-20(s0)
    800223c0:	fc442783          	lw	a5,-60(s0)
    800223c4:	2701                	sext.w	a4,a4
    800223c6:	2781                	sext.w	a5,a5
    800223c8:	fcf747e3          	blt	a4,a5,80022396 <memcpy+0x58>
    }

    cdst = (char *)ldst;
    800223cc:	fd043783          	ld	a5,-48(s0)
    800223d0:	fef43023          	sd	a5,-32(s0)
    csrc = (char *)lsrc;
    800223d4:	fc843783          	ld	a5,-56(s0)
    800223d8:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    800223dc:	fe042623          	sw	zero,-20(s0)
    800223e0:	a035                	j	8002240c <memcpy+0xce>
        *cdst++ = *csrc++;
    800223e2:	fd843703          	ld	a4,-40(s0)
    800223e6:	00170793          	addi	a5,a4,1
    800223ea:	fcf43c23          	sd	a5,-40(s0)
    800223ee:	fe043783          	ld	a5,-32(s0)
    800223f2:	00178693          	addi	a3,a5,1
    800223f6:	fed43023          	sd	a3,-32(s0)
    800223fa:	00074703          	lbu	a4,0(a4)
    800223fe:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    80022402:	fec42783          	lw	a5,-20(s0)
    80022406:	2785                	addiw	a5,a5,1
    80022408:	fef42623          	sw	a5,-20(s0)
    8002240c:	fec42703          	lw	a4,-20(s0)
    80022410:	fc042783          	lw	a5,-64(s0)
    80022414:	2701                	sext.w	a4,a4
    80022416:	2781                	sext.w	a5,a5
    80022418:	fcf745e3          	blt	a4,a5,800223e2 <memcpy+0xa4>
    }

    return dst;
    8002241c:	fb843783          	ld	a5,-72(s0)
}
    80022420:	853e                	mv	a0,a5
    80022422:	6466                	ld	s0,88(sp)
    80022424:	6125                	addi	sp,sp,96
    80022426:	8082                	ret

0000000080022428 <memmove>:

void *memmove(void *_dst, const void *_src, int n)
{
    80022428:	7139                	addi	sp,sp,-64
    8002242a:	fc22                	sd	s0,56(sp)
    8002242c:	0080                	addi	s0,sp,64
    8002242e:	fca43c23          	sd	a0,-40(s0)
    80022432:	fcb43823          	sd	a1,-48(s0)
    80022436:	87b2                	mv	a5,a2
    80022438:	fcf42623          	sw	a5,-52(s0)
    const char *src = _src;
    8002243c:	fd043783          	ld	a5,-48(s0)
    80022440:	fef43423          	sd	a5,-24(s0)
    char *dst       = _dst;
    80022444:	fd843783          	ld	a5,-40(s0)
    80022448:	fef43023          	sd	a5,-32(s0)

    if (n == 0)
    8002244c:	fcc42783          	lw	a5,-52(s0)
    80022450:	2781                	sext.w	a5,a5
    80022452:	e781                	bnez	a5,8002245a <memmove+0x32>
        return _dst;
    80022454:	fd843783          	ld	a5,-40(s0)
    80022458:	a845                	j	80022508 <memmove+0xe0>

    if (src < dst && src + n > dst) {
    8002245a:	fe843703          	ld	a4,-24(s0)
    8002245e:	fe043783          	ld	a5,-32(s0)
    80022462:	08f77c63          	bgeu	a4,a5,800224fa <memmove+0xd2>
    80022466:	fcc42783          	lw	a5,-52(s0)
    8002246a:	fe843703          	ld	a4,-24(s0)
    8002246e:	97ba                	add	a5,a5,a4
    80022470:	fe043703          	ld	a4,-32(s0)
    80022474:	08f77363          	bgeu	a4,a5,800224fa <memmove+0xd2>
        src += n;
    80022478:	fcc42783          	lw	a5,-52(s0)
    8002247c:	fe843703          	ld	a4,-24(s0)
    80022480:	97ba                	add	a5,a5,a4
    80022482:	fef43423          	sd	a5,-24(s0)
        dst += n;
    80022486:	fcc42783          	lw	a5,-52(s0)
    8002248a:	fe043703          	ld	a4,-32(s0)
    8002248e:	97ba                	add	a5,a5,a4
    80022490:	fef43023          	sd	a5,-32(s0)
        for (; n > 0; n -= 1) {
    80022494:	a805                	j	800224c4 <memmove+0x9c>
            *--dst = *--src;
    80022496:	fe843783          	ld	a5,-24(s0)
    8002249a:	17fd                	addi	a5,a5,-1
    8002249c:	fef43423          	sd	a5,-24(s0)
    800224a0:	fe043783          	ld	a5,-32(s0)
    800224a4:	17fd                	addi	a5,a5,-1
    800224a6:	fef43023          	sd	a5,-32(s0)
    800224aa:	fe843783          	ld	a5,-24(s0)
    800224ae:	0007c703          	lbu	a4,0(a5)
    800224b2:	fe043783          	ld	a5,-32(s0)
    800224b6:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    800224ba:	fcc42783          	lw	a5,-52(s0)
    800224be:	37fd                	addiw	a5,a5,-1
    800224c0:	fcf42623          	sw	a5,-52(s0)
    800224c4:	fcc42783          	lw	a5,-52(s0)
    800224c8:	2781                	sext.w	a5,a5
    800224ca:	fcf046e3          	bgtz	a5,80022496 <memmove+0x6e>
    if (src < dst && src + n > dst) {
    800224ce:	a81d                	j	80022504 <memmove+0xdc>
        }
    }
    else {
        for (; n > 0; n -= 1) {
            *dst++ = *src++;
    800224d0:	fe843703          	ld	a4,-24(s0)
    800224d4:	00170793          	addi	a5,a4,1
    800224d8:	fef43423          	sd	a5,-24(s0)
    800224dc:	fe043783          	ld	a5,-32(s0)
    800224e0:	00178693          	addi	a3,a5,1
    800224e4:	fed43023          	sd	a3,-32(s0)
    800224e8:	00074703          	lbu	a4,0(a4)
    800224ec:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    800224f0:	fcc42783          	lw	a5,-52(s0)
    800224f4:	37fd                	addiw	a5,a5,-1
    800224f6:	fcf42623          	sw	a5,-52(s0)
    800224fa:	fcc42783          	lw	a5,-52(s0)
    800224fe:	2781                	sext.w	a5,a5
    80022500:	fcf048e3          	bgtz	a5,800224d0 <memmove+0xa8>
        }
    }

    return _dst;
    80022504:	fd843783          	ld	a5,-40(s0)
}
    80022508:	853e                	mv	a0,a5
    8002250a:	7462                	ld	s0,56(sp)
    8002250c:	6121                	addi	sp,sp,64
    8002250e:	8082                	ret

0000000080022510 <memcmp>:

int memcmp(const void *haystack, const void *needle, int size)
{
    80022510:	715d                	addi	sp,sp,-80
    80022512:	e4a2                	sd	s0,72(sp)
    80022514:	0880                	addi	s0,sp,80
    80022516:	fca43423          	sd	a0,-56(s0)
    8002251a:	fcb43023          	sd	a1,-64(s0)
    8002251e:	87b2                	mv	a5,a2
    80022520:	faf42e23          	sw	a5,-68(s0)
    const char *hay  = (char *)haystack;
    80022524:	fc843783          	ld	a5,-56(s0)
    80022528:	fef43023          	sd	a5,-32(s0)
    const char *need = (char *)needle;
    8002252c:	fc043783          	ld	a5,-64(s0)
    80022530:	fcf43c23          	sd	a5,-40(s0)
    int i;

    for (i = 0; i < (size - 1); i++) {
    80022534:	fe042623          	sw	zero,-20(s0)
    80022538:	a8a1                	j	80022590 <memcmp+0x80>
        if (hay[i] != need[i]) {
    8002253a:	fec42783          	lw	a5,-20(s0)
    8002253e:	fe043703          	ld	a4,-32(s0)
    80022542:	97ba                	add	a5,a5,a4
    80022544:	0007c683          	lbu	a3,0(a5)
    80022548:	fec42783          	lw	a5,-20(s0)
    8002254c:	fd843703          	ld	a4,-40(s0)
    80022550:	97ba                	add	a5,a5,a4
    80022552:	0007c783          	lbu	a5,0(a5)
    80022556:	8736                	mv	a4,a3
    80022558:	02f70763          	beq	a4,a5,80022586 <memcmp+0x76>
            return hay[i] - need[i];
    8002255c:	fec42783          	lw	a5,-20(s0)
    80022560:	fe043703          	ld	a4,-32(s0)
    80022564:	97ba                	add	a5,a5,a4
    80022566:	0007c783          	lbu	a5,0(a5)
    8002256a:	0007871b          	sext.w	a4,a5
    8002256e:	fec42783          	lw	a5,-20(s0)
    80022572:	fd843683          	ld	a3,-40(s0)
    80022576:	97b6                	add	a5,a5,a3
    80022578:	0007c783          	lbu	a5,0(a5)
    8002257c:	2781                	sext.w	a5,a5
    8002257e:	40f707bb          	subw	a5,a4,a5
    80022582:	2781                	sext.w	a5,a5
    80022584:	a0a1                	j	800225cc <memcmp+0xbc>
    for (i = 0; i < (size - 1); i++) {
    80022586:	fec42783          	lw	a5,-20(s0)
    8002258a:	2785                	addiw	a5,a5,1
    8002258c:	fef42623          	sw	a5,-20(s0)
    80022590:	fbc42783          	lw	a5,-68(s0)
    80022594:	37fd                	addiw	a5,a5,-1
    80022596:	0007871b          	sext.w	a4,a5
    8002259a:	fec42783          	lw	a5,-20(s0)
    8002259e:	2781                	sext.w	a5,a5
    800225a0:	f8e7cde3          	blt	a5,a4,8002253a <memcmp+0x2a>
        }
    }

    return hay[i] - need[i];
    800225a4:	fec42783          	lw	a5,-20(s0)
    800225a8:	fe043703          	ld	a4,-32(s0)
    800225ac:	97ba                	add	a5,a5,a4
    800225ae:	0007c783          	lbu	a5,0(a5)
    800225b2:	0007871b          	sext.w	a4,a5
    800225b6:	fec42783          	lw	a5,-20(s0)
    800225ba:	fd843683          	ld	a3,-40(s0)
    800225be:	97b6                	add	a5,a5,a3
    800225c0:	0007c783          	lbu	a5,0(a5)
    800225c4:	2781                	sext.w	a5,a5
    800225c6:	40f707bb          	subw	a5,a4,a5
    800225ca:	2781                	sext.w	a5,a5
}
    800225cc:	853e                	mv	a0,a5
    800225ce:	6426                	ld	s0,72(sp)
    800225d0:	6161                	addi	sp,sp,80
    800225d2:	8082                	ret

00000000800225d4 <atoi>:

int atoi(const char *st)
{
    800225d4:	7139                	addi	sp,sp,-64
    800225d6:	fc22                	sd	s0,56(sp)
    800225d8:	0080                	addi	s0,sp,64
    800225da:	fca43423          	sd	a0,-56(s0)
    int r = 0;
    800225de:	fe042623          	sw	zero,-20(s0)
    int p = 1;
    800225e2:	4785                	li	a5,1
    800225e4:	fef42423          	sw	a5,-24(s0)
    int i;
    int l = 0;
    800225e8:	fe042023          	sw	zero,-32(s0)
    int n = 0;
    800225ec:	fc042e23          	sw	zero,-36(s0)

    if (st[0] == '-') {
    800225f0:	fc843783          	ld	a5,-56(s0)
    800225f4:	0007c783          	lbu	a5,0(a5)
    800225f8:	873e                	mv	a4,a5
    800225fa:	02d00793          	li	a5,45
    800225fe:	02f71063          	bne	a4,a5,8002261e <atoi+0x4a>
        st++;
    80022602:	fc843783          	ld	a5,-56(s0)
    80022606:	0785                	addi	a5,a5,1
    80022608:	fcf43423          	sd	a5,-56(s0)
        n = 1;
    8002260c:	4785                	li	a5,1
    8002260e:	fcf42e23          	sw	a5,-36(s0)
    }

    while (st[l] >= '0' && st[l] <= '9')
    80022612:	a031                	j	8002261e <atoi+0x4a>
        l++;
    80022614:	fe042783          	lw	a5,-32(s0)
    80022618:	2785                	addiw	a5,a5,1
    8002261a:	fef42023          	sw	a5,-32(s0)
    while (st[l] >= '0' && st[l] <= '9')
    8002261e:	fe042783          	lw	a5,-32(s0)
    80022622:	fc843703          	ld	a4,-56(s0)
    80022626:	97ba                	add	a5,a5,a4
    80022628:	0007c783          	lbu	a5,0(a5)
    8002262c:	873e                	mv	a4,a5
    8002262e:	02f00793          	li	a5,47
    80022632:	00e7fe63          	bgeu	a5,a4,8002264e <atoi+0x7a>
    80022636:	fe042783          	lw	a5,-32(s0)
    8002263a:	fc843703          	ld	a4,-56(s0)
    8002263e:	97ba                	add	a5,a5,a4
    80022640:	0007c783          	lbu	a5,0(a5)
    80022644:	873e                	mv	a4,a5
    80022646:	03900793          	li	a5,57
    8002264a:	fce7f5e3          	bgeu	a5,a4,80022614 <atoi+0x40>

    for (i = l - 1; i >= 0; i--) {
    8002264e:	fe042783          	lw	a5,-32(s0)
    80022652:	37fd                	addiw	a5,a5,-1
    80022654:	fef42223          	sw	a5,-28(s0)
    80022658:	a0a9                	j	800226a2 <atoi+0xce>
        r += p * (st[i] - '0');
    8002265a:	fe442783          	lw	a5,-28(s0)
    8002265e:	fc843703          	ld	a4,-56(s0)
    80022662:	97ba                	add	a5,a5,a4
    80022664:	0007c783          	lbu	a5,0(a5)
    80022668:	2781                	sext.w	a5,a5
    8002266a:	fd07879b          	addiw	a5,a5,-48
    8002266e:	2781                	sext.w	a5,a5
    80022670:	fe842703          	lw	a4,-24(s0)
    80022674:	02f707bb          	mulw	a5,a4,a5
    80022678:	2781                	sext.w	a5,a5
    8002267a:	fec42703          	lw	a4,-20(s0)
    8002267e:	9fb9                	addw	a5,a5,a4
    80022680:	fef42623          	sw	a5,-20(s0)
        p *= 10;
    80022684:	fe842703          	lw	a4,-24(s0)
    80022688:	87ba                	mv	a5,a4
    8002268a:	0027979b          	slliw	a5,a5,0x2
    8002268e:	9fb9                	addw	a5,a5,a4
    80022690:	0017979b          	slliw	a5,a5,0x1
    80022694:	fef42423          	sw	a5,-24(s0)
    for (i = l - 1; i >= 0; i--) {
    80022698:	fe442783          	lw	a5,-28(s0)
    8002269c:	37fd                	addiw	a5,a5,-1
    8002269e:	fef42223          	sw	a5,-28(s0)
    800226a2:	fe442783          	lw	a5,-28(s0)
    800226a6:	2781                	sext.w	a5,a5
    800226a8:	fa07d9e3          	bgez	a5,8002265a <atoi+0x86>
    }

    return (n ? -r : r);
    800226ac:	fdc42783          	lw	a5,-36(s0)
    800226b0:	2781                	sext.w	a5,a5
    800226b2:	c799                	beqz	a5,800226c0 <atoi+0xec>
    800226b4:	fec42783          	lw	a5,-20(s0)
    800226b8:	40f007bb          	negw	a5,a5
    800226bc:	2781                	sext.w	a5,a5
    800226be:	a019                	j	800226c4 <atoi+0xf0>
    800226c0:	fec42783          	lw	a5,-20(s0)
}
    800226c4:	853e                	mv	a0,a5
    800226c6:	7462                	ld	s0,56(sp)
    800226c8:	6121                	addi	sp,sp,64
    800226ca:	8082                	ret

00000000800226cc <strcmp>:

int strcmp(const char *l, const char *r)
{
    800226cc:	7139                	addi	sp,sp,-64
    800226ce:	fc22                	sd	s0,56(sp)
    800226d0:	0080                	addi	s0,sp,64
    800226d2:	fca43423          	sd	a0,-56(s0)
    800226d6:	fcb43023          	sd	a1,-64(s0)
    const unsigned char *s1 = (const unsigned char *)l;
    800226da:	fc843783          	ld	a5,-56(s0)
    800226de:	fef43423          	sd	a5,-24(s0)
    const unsigned char *s2 = (const unsigned char *)r;
    800226e2:	fc043783          	ld	a5,-64(s0)
    800226e6:	fef43023          	sd	a5,-32(s0)
    unsigned int c1, c2;

    do {
        c1 = (unsigned char)*s1++;
    800226ea:	fe843783          	ld	a5,-24(s0)
    800226ee:	00178713          	addi	a4,a5,1
    800226f2:	fee43423          	sd	a4,-24(s0)
    800226f6:	0007c783          	lbu	a5,0(a5)
    800226fa:	fcf42e23          	sw	a5,-36(s0)
        c2 = (unsigned char)*s2++;
    800226fe:	fe043783          	ld	a5,-32(s0)
    80022702:	00178713          	addi	a4,a5,1
    80022706:	fee43023          	sd	a4,-32(s0)
    8002270a:	0007c783          	lbu	a5,0(a5)
    8002270e:	fcf42c23          	sw	a5,-40(s0)
        if (c1 == '\0')
    80022712:	fdc42783          	lw	a5,-36(s0)
    80022716:	2781                	sext.w	a5,a5
    80022718:	eb91                	bnez	a5,8002272c <strcmp+0x60>
            return c1 - c2;
    8002271a:	fdc42703          	lw	a4,-36(s0)
    8002271e:	fd842783          	lw	a5,-40(s0)
    80022722:	40f707bb          	subw	a5,a4,a5
    80022726:	2781                	sext.w	a5,a5
    80022728:	2781                	sext.w	a5,a5
    8002272a:	a00d                	j	8002274c <strcmp+0x80>
    } while (c1 == c2);
    8002272c:	fdc42703          	lw	a4,-36(s0)
    80022730:	fd842783          	lw	a5,-40(s0)
    80022734:	2701                	sext.w	a4,a4
    80022736:	2781                	sext.w	a5,a5
    80022738:	faf709e3          	beq	a4,a5,800226ea <strcmp+0x1e>

    return c1 - c2;
    8002273c:	fdc42703          	lw	a4,-36(s0)
    80022740:	fd842783          	lw	a5,-40(s0)
    80022744:	40f707bb          	subw	a5,a4,a5
    80022748:	2781                	sext.w	a5,a5
    8002274a:	2781                	sext.w	a5,a5
}
    8002274c:	853e                	mv	a0,a5
    8002274e:	7462                	ld	s0,56(sp)
    80022750:	6121                	addi	sp,sp,64
    80022752:	8082                	ret

0000000080022754 <strncmp>:

int strncmp(const char *left, const char *right, int n)
{
    80022754:	7139                	addi	sp,sp,-64
    80022756:	fc22                	sd	s0,56(sp)
    80022758:	0080                	addi	s0,sp,64
    8002275a:	fca43c23          	sd	a0,-40(s0)
    8002275e:	fcb43823          	sd	a1,-48(s0)
    80022762:	87b2                	mv	a5,a2
    80022764:	fcf42623          	sw	a5,-52(s0)
    unsigned int c1 = '\0';
    80022768:	fe042623          	sw	zero,-20(s0)
    unsigned int c2 = '\0';
    8002276c:	fe042423          	sw	zero,-24(s0)

    if (n >= 4) {
    80022770:	fcc42783          	lw	a5,-52(s0)
    80022774:	0007871b          	sext.w	a4,a5
    80022778:	478d                	li	a5,3
    8002277a:	1ce7da63          	bge	a5,a4,8002294e <strncmp+0x1fa>
        int n4 = n >> 2;
    8002277e:	fcc42783          	lw	a5,-52(s0)
    80022782:	4027d79b          	sraiw	a5,a5,0x2
    80022786:	fef42223          	sw	a5,-28(s0)
        do {
            c1 = (unsigned char)*left++;
    8002278a:	fd843783          	ld	a5,-40(s0)
    8002278e:	00178713          	addi	a4,a5,1
    80022792:	fce43c23          	sd	a4,-40(s0)
    80022796:	0007c783          	lbu	a5,0(a5)
    8002279a:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8002279e:	fd043783          	ld	a5,-48(s0)
    800227a2:	00178713          	addi	a4,a5,1
    800227a6:	fce43823          	sd	a4,-48(s0)
    800227aa:	0007c783          	lbu	a5,0(a5)
    800227ae:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    800227b2:	fec42783          	lw	a5,-20(s0)
    800227b6:	2781                	sext.w	a5,a5
    800227b8:	cb89                	beqz	a5,800227ca <strncmp+0x76>
    800227ba:	fec42703          	lw	a4,-20(s0)
    800227be:	fe842783          	lw	a5,-24(s0)
    800227c2:	2701                	sext.w	a4,a4
    800227c4:	2781                	sext.w	a5,a5
    800227c6:	00f70b63          	beq	a4,a5,800227dc <strncmp+0x88>
                return c1 - c2;
    800227ca:	fec42703          	lw	a4,-20(s0)
    800227ce:	fe842783          	lw	a5,-24(s0)
    800227d2:	40f707bb          	subw	a5,a4,a5
    800227d6:	2781                	sext.w	a5,a5
    800227d8:	2781                	sext.w	a5,a5
    800227da:	a279                	j	80022968 <strncmp+0x214>
            }

            c1 = (unsigned char)*left++;
    800227dc:	fd843783          	ld	a5,-40(s0)
    800227e0:	00178713          	addi	a4,a5,1
    800227e4:	fce43c23          	sd	a4,-40(s0)
    800227e8:	0007c783          	lbu	a5,0(a5)
    800227ec:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    800227f0:	fd043783          	ld	a5,-48(s0)
    800227f4:	00178713          	addi	a4,a5,1
    800227f8:	fce43823          	sd	a4,-48(s0)
    800227fc:	0007c783          	lbu	a5,0(a5)
    80022800:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80022804:	fec42783          	lw	a5,-20(s0)
    80022808:	2781                	sext.w	a5,a5
    8002280a:	cb89                	beqz	a5,8002281c <strncmp+0xc8>
    8002280c:	fec42703          	lw	a4,-20(s0)
    80022810:	fe842783          	lw	a5,-24(s0)
    80022814:	2701                	sext.w	a4,a4
    80022816:	2781                	sext.w	a5,a5
    80022818:	00f70b63          	beq	a4,a5,8002282e <strncmp+0xda>
                return c1 - c2;
    8002281c:	fec42703          	lw	a4,-20(s0)
    80022820:	fe842783          	lw	a5,-24(s0)
    80022824:	40f707bb          	subw	a5,a4,a5
    80022828:	2781                	sext.w	a5,a5
    8002282a:	2781                	sext.w	a5,a5
    8002282c:	aa35                	j	80022968 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    8002282e:	fd843783          	ld	a5,-40(s0)
    80022832:	00178713          	addi	a4,a5,1
    80022836:	fce43c23          	sd	a4,-40(s0)
    8002283a:	0007c783          	lbu	a5,0(a5)
    8002283e:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80022842:	fd043783          	ld	a5,-48(s0)
    80022846:	00178713          	addi	a4,a5,1
    8002284a:	fce43823          	sd	a4,-48(s0)
    8002284e:	0007c783          	lbu	a5,0(a5)
    80022852:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80022856:	fec42783          	lw	a5,-20(s0)
    8002285a:	2781                	sext.w	a5,a5
    8002285c:	cb89                	beqz	a5,8002286e <strncmp+0x11a>
    8002285e:	fec42703          	lw	a4,-20(s0)
    80022862:	fe842783          	lw	a5,-24(s0)
    80022866:	2701                	sext.w	a4,a4
    80022868:	2781                	sext.w	a5,a5
    8002286a:	00f70b63          	beq	a4,a5,80022880 <strncmp+0x12c>
                return c1 - c2;
    8002286e:	fec42703          	lw	a4,-20(s0)
    80022872:	fe842783          	lw	a5,-24(s0)
    80022876:	40f707bb          	subw	a5,a4,a5
    8002287a:	2781                	sext.w	a5,a5
    8002287c:	2781                	sext.w	a5,a5
    8002287e:	a0ed                	j	80022968 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    80022880:	fd843783          	ld	a5,-40(s0)
    80022884:	00178713          	addi	a4,a5,1
    80022888:	fce43c23          	sd	a4,-40(s0)
    8002288c:	0007c783          	lbu	a5,0(a5)
    80022890:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80022894:	fd043783          	ld	a5,-48(s0)
    80022898:	00178713          	addi	a4,a5,1
    8002289c:	fce43823          	sd	a4,-48(s0)
    800228a0:	0007c783          	lbu	a5,0(a5)
    800228a4:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    800228a8:	fec42783          	lw	a5,-20(s0)
    800228ac:	2781                	sext.w	a5,a5
    800228ae:	cb89                	beqz	a5,800228c0 <strncmp+0x16c>
    800228b0:	fec42703          	lw	a4,-20(s0)
    800228b4:	fe842783          	lw	a5,-24(s0)
    800228b8:	2701                	sext.w	a4,a4
    800228ba:	2781                	sext.w	a5,a5
    800228bc:	00f70b63          	beq	a4,a5,800228d2 <strncmp+0x17e>
                return c1 - c2;
    800228c0:	fec42703          	lw	a4,-20(s0)
    800228c4:	fe842783          	lw	a5,-24(s0)
    800228c8:	40f707bb          	subw	a5,a4,a5
    800228cc:	2781                	sext.w	a5,a5
    800228ce:	2781                	sext.w	a5,a5
    800228d0:	a861                	j	80022968 <strncmp+0x214>
            }
        } while (--n4 > 0);
    800228d2:	fe442783          	lw	a5,-28(s0)
    800228d6:	37fd                	addiw	a5,a5,-1
    800228d8:	fef42223          	sw	a5,-28(s0)
    800228dc:	fe442783          	lw	a5,-28(s0)
    800228e0:	2781                	sext.w	a5,a5
    800228e2:	eaf044e3          	bgtz	a5,8002278a <strncmp+0x36>
        n &= 3;
    800228e6:	fcc42783          	lw	a5,-52(s0)
    800228ea:	8b8d                	andi	a5,a5,3
    800228ec:	fcf42623          	sw	a5,-52(s0)
    }

    while (n > 0) {
    800228f0:	a8b9                	j	8002294e <strncmp+0x1fa>
        c1 = (unsigned char)*left++;
    800228f2:	fd843783          	ld	a5,-40(s0)
    800228f6:	00178713          	addi	a4,a5,1
    800228fa:	fce43c23          	sd	a4,-40(s0)
    800228fe:	0007c783          	lbu	a5,0(a5)
    80022902:	fef42623          	sw	a5,-20(s0)
        c2 = (unsigned char)*right++;
    80022906:	fd043783          	ld	a5,-48(s0)
    8002290a:	00178713          	addi	a4,a5,1
    8002290e:	fce43823          	sd	a4,-48(s0)
    80022912:	0007c783          	lbu	a5,0(a5)
    80022916:	fef42423          	sw	a5,-24(s0)
        if (c1 == '\0' || c1 != c2)
    8002291a:	fec42783          	lw	a5,-20(s0)
    8002291e:	2781                	sext.w	a5,a5
    80022920:	cb89                	beqz	a5,80022932 <strncmp+0x1de>
    80022922:	fec42703          	lw	a4,-20(s0)
    80022926:	fe842783          	lw	a5,-24(s0)
    8002292a:	2701                	sext.w	a4,a4
    8002292c:	2781                	sext.w	a5,a5
    8002292e:	00f70b63          	beq	a4,a5,80022944 <strncmp+0x1f0>
            return c1 - c2;
    80022932:	fec42703          	lw	a4,-20(s0)
    80022936:	fe842783          	lw	a5,-24(s0)
    8002293a:	40f707bb          	subw	a5,a4,a5
    8002293e:	2781                	sext.w	a5,a5
    80022940:	2781                	sext.w	a5,a5
    80022942:	a01d                	j	80022968 <strncmp+0x214>
        n--;
    80022944:	fcc42783          	lw	a5,-52(s0)
    80022948:	37fd                	addiw	a5,a5,-1
    8002294a:	fcf42623          	sw	a5,-52(s0)
    while (n > 0) {
    8002294e:	fcc42783          	lw	a5,-52(s0)
    80022952:	2781                	sext.w	a5,a5
    80022954:	f8f04fe3          	bgtz	a5,800228f2 <strncmp+0x19e>
    }

    return c1 - c2;
    80022958:	fec42703          	lw	a4,-20(s0)
    8002295c:	fe842783          	lw	a5,-24(s0)
    80022960:	40f707bb          	subw	a5,a4,a5
    80022964:	2781                	sext.w	a5,a5
    80022966:	2781                	sext.w	a5,a5
}
    80022968:	853e                	mv	a0,a5
    8002296a:	7462                	ld	s0,56(sp)
    8002296c:	6121                	addi	sp,sp,64
    8002296e:	8082                	ret

0000000080022970 <strfindchr>:

int strfindchr(const char *r, char t)
{
    80022970:	7179                	addi	sp,sp,-48
    80022972:	f422                	sd	s0,40(sp)
    80022974:	1800                	addi	s0,sp,48
    80022976:	fca43c23          	sd	a0,-40(s0)
    8002297a:	87ae                	mv	a5,a1
    8002297c:	fcf40ba3          	sb	a5,-41(s0)
    int i = 0;
    80022980:	fe042623          	sw	zero,-20(s0)
    while (r[i] != t) {
    80022984:	a005                	j	800229a4 <strfindchr+0x34>
        if (r[i] == '\0') {
    80022986:	fec42783          	lw	a5,-20(s0)
    8002298a:	fd843703          	ld	a4,-40(s0)
    8002298e:	97ba                	add	a5,a5,a4
    80022990:	0007c783          	lbu	a5,0(a5)
    80022994:	e399                	bnez	a5,8002299a <strfindchr+0x2a>
            return -1;
    80022996:	57fd                	li	a5,-1
    80022998:	a02d                	j	800229c2 <strfindchr+0x52>
        }
        i++;
    8002299a:	fec42783          	lw	a5,-20(s0)
    8002299e:	2785                	addiw	a5,a5,1
    800229a0:	fef42623          	sw	a5,-20(s0)
    while (r[i] != t) {
    800229a4:	fec42783          	lw	a5,-20(s0)
    800229a8:	fd843703          	ld	a4,-40(s0)
    800229ac:	97ba                	add	a5,a5,a4
    800229ae:	0007c703          	lbu	a4,0(a5)
    800229b2:	fd744783          	lbu	a5,-41(s0)
    800229b6:	0ff7f793          	andi	a5,a5,255
    800229ba:	fce796e3          	bne	a5,a4,80022986 <strfindchr+0x16>
    }
    return i;
    800229be:	fec42783          	lw	a5,-20(s0)
}
    800229c2:	853e                	mv	a0,a5
    800229c4:	7422                	ld	s0,40(sp)
    800229c6:	6145                	addi	sp,sp,48
    800229c8:	8082                	ret

00000000800229ca <strlen>:

int strlen(const char *s)
{
    800229ca:	7179                	addi	sp,sp,-48
    800229cc:	f422                	sd	s0,40(sp)
    800229ce:	1800                	addi	s0,sp,48
    800229d0:	fca43c23          	sd	a0,-40(s0)
    int len = 0;
    800229d4:	fe042623          	sw	zero,-20(s0)
    while (s[len] && ++len)
    800229d8:	0001                	nop
    800229da:	fec42783          	lw	a5,-20(s0)
    800229de:	fd843703          	ld	a4,-40(s0)
    800229e2:	97ba                	add	a5,a5,a4
    800229e4:	0007c783          	lbu	a5,0(a5)
    800229e8:	cb91                	beqz	a5,800229fc <strlen+0x32>
    800229ea:	fec42783          	lw	a5,-20(s0)
    800229ee:	2785                	addiw	a5,a5,1
    800229f0:	fef42623          	sw	a5,-20(s0)
    800229f4:	fec42783          	lw	a5,-20(s0)
    800229f8:	2781                	sext.w	a5,a5
    800229fa:	f3e5                	bnez	a5,800229da <strlen+0x10>
        ;
    return len;
    800229fc:	fec42783          	lw	a5,-20(s0)
}
    80022a00:	853e                	mv	a0,a5
    80022a02:	7422                	ld	s0,40(sp)
    80022a04:	6145                	addi	sp,sp,48
    80022a06:	8082                	ret

0000000080022a08 <strcpy>:

char *strcpy(char *dest, const char *s)
{
    80022a08:	7179                	addi	sp,sp,-48
    80022a0a:	f422                	sd	s0,40(sp)
    80022a0c:	1800                	addi	s0,sp,48
    80022a0e:	fca43c23          	sd	a0,-40(s0)
    80022a12:	fcb43823          	sd	a1,-48(s0)
    char *o = dest;
    80022a16:	fd843783          	ld	a5,-40(s0)
    80022a1a:	fef43423          	sd	a5,-24(s0)
    while (*s) {
    80022a1e:	a00d                	j	80022a40 <strcpy+0x38>
        *dest++ = *s++;
    80022a20:	fd043703          	ld	a4,-48(s0)
    80022a24:	00170793          	addi	a5,a4,1
    80022a28:	fcf43823          	sd	a5,-48(s0)
    80022a2c:	fd843783          	ld	a5,-40(s0)
    80022a30:	00178693          	addi	a3,a5,1
    80022a34:	fcd43c23          	sd	a3,-40(s0)
    80022a38:	00074703          	lbu	a4,0(a4)
    80022a3c:	00e78023          	sb	a4,0(a5)
    while (*s) {
    80022a40:	fd043783          	ld	a5,-48(s0)
    80022a44:	0007c783          	lbu	a5,0(a5)
    80022a48:	ffe1                	bnez	a5,80022a20 <strcpy+0x18>
    }
    *dest = '\0';
    80022a4a:	fd843783          	ld	a5,-40(s0)
    80022a4e:	00078023          	sb	zero,0(a5)
    return o;
    80022a52:	fe843783          	ld	a5,-24(s0)
}
    80022a56:	853e                	mv	a0,a5
    80022a58:	7422                	ld	s0,40(sp)
    80022a5a:	6145                	addi	sp,sp,48
    80022a5c:	8082                	ret

0000000080022a5e <strncpy>:

char *strncpy(char *dest, const char *s, int n)
{
    80022a5e:	7139                	addi	sp,sp,-64
    80022a60:	fc22                	sd	s0,56(sp)
    80022a62:	0080                	addi	s0,sp,64
    80022a64:	fca43c23          	sd	a0,-40(s0)
    80022a68:	fcb43823          	sd	a1,-48(s0)
    80022a6c:	87b2                	mv	a5,a2
    80022a6e:	fcf42623          	sw	a5,-52(s0)
    char *o = dest;
    80022a72:	fd843783          	ld	a5,-40(s0)
    80022a76:	fef43423          	sd	a5,-24(s0)
    while (*s && n-- > 0) {
    80022a7a:	a00d                	j	80022a9c <strncpy+0x3e>
        *dest++ = *s++;
    80022a7c:	fd043703          	ld	a4,-48(s0)
    80022a80:	00170793          	addi	a5,a4,1
    80022a84:	fcf43823          	sd	a5,-48(s0)
    80022a88:	fd843783          	ld	a5,-40(s0)
    80022a8c:	00178693          	addi	a3,a5,1
    80022a90:	fcd43c23          	sd	a3,-40(s0)
    80022a94:	00074703          	lbu	a4,0(a4)
    80022a98:	00e78023          	sb	a4,0(a5)
    while (*s && n-- > 0) {
    80022a9c:	fd043783          	ld	a5,-48(s0)
    80022aa0:	0007c783          	lbu	a5,0(a5)
    80022aa4:	cb89                	beqz	a5,80022ab6 <strncpy+0x58>
    80022aa6:	fcc42783          	lw	a5,-52(s0)
    80022aaa:	fff7871b          	addiw	a4,a5,-1
    80022aae:	fce42623          	sw	a4,-52(s0)
    80022ab2:	fcf045e3          	bgtz	a5,80022a7c <strncpy+0x1e>
    }
    *dest = '\0';
    80022ab6:	fd843783          	ld	a5,-40(s0)
    80022aba:	00078023          	sb	zero,0(a5)
    return o;
    80022abe:	fe843783          	ld	a5,-24(s0)
}
    80022ac2:	853e                	mv	a0,a5
    80022ac4:	7462                	ld	s0,56(sp)
    80022ac6:	6121                	addi	sp,sp,64
    80022ac8:	8082                	ret

0000000080022aca <strdup>:


char *strdup(const char *src)
{
    80022aca:	7179                	addi	sp,sp,-48
    80022acc:	f406                	sd	ra,40(sp)
    80022ace:	f022                	sd	s0,32(sp)
    80022ad0:	1800                	addi	s0,sp,48
    80022ad2:	fca43c23          	sd	a0,-40(s0)
    int len   = strlen(src);
    80022ad6:	fd843503          	ld	a0,-40(s0)
    80022ada:	ef1ff0ef          	jal	ra,800229ca <strlen>
    80022ade:	87aa                	mv	a5,a0
    80022ae0:	fef42623          	sw	a5,-20(s0)
    char *ret = (char *)g_kmalloc(len + 1);
    80022ae4:	fec42783          	lw	a5,-20(s0)
    80022ae8:	2785                	addiw	a5,a5,1
    80022aea:	2781                	sext.w	a5,a5
    80022aec:	853e                	mv	a0,a5
    80022aee:	fdefd0ef          	jal	ra,800202cc <g_kmalloc>
    80022af2:	fea43023          	sd	a0,-32(s0)
    if (!ret) {
    80022af6:	fe043783          	ld	a5,-32(s0)
    80022afa:	e399                	bnez	a5,80022b00 <strdup+0x36>
        return NULL;
    80022afc:	4781                	li	a5,0
    80022afe:	a801                	j	80022b0e <strdup+0x44>
    }
    return strcpy(ret, src);
    80022b00:	fd843583          	ld	a1,-40(s0)
    80022b04:	fe043503          	ld	a0,-32(s0)
    80022b08:	f01ff0ef          	jal	ra,80022a08 <strcpy>
    80022b0c:	87aa                	mv	a5,a0
}
    80022b0e:	853e                	mv	a0,a5
    80022b10:	70a2                	ld	ra,40(sp)
    80022b12:	7402                	ld	s0,32(sp)
    80022b14:	6145                	addi	sp,sp,48
    80022b16:	8082                	ret

0000000080022b18 <strstartswith>:

bool strstartswith(const char *src, const char *start)
{
    80022b18:	7179                	addi	sp,sp,-48
    80022b1a:	f406                	sd	ra,40(sp)
    80022b1c:	f022                	sd	s0,32(sp)
    80022b1e:	1800                	addi	s0,sp,48
    80022b20:	fca43c23          	sd	a0,-40(s0)
    80022b24:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    80022b28:	fd843503          	ld	a0,-40(s0)
    80022b2c:	e9fff0ef          	jal	ra,800229ca <strlen>
    80022b30:	87aa                	mv	a5,a0
    80022b32:	fef42423          	sw	a5,-24(s0)
    int start_len = strlen(start);
    80022b36:	fd043503          	ld	a0,-48(s0)
    80022b3a:	e91ff0ef          	jal	ra,800229ca <strlen>
    80022b3e:	87aa                	mv	a5,a0
    80022b40:	fef42223          	sw	a5,-28(s0)
    int i;
    
    if (src_len < start_len) {
    80022b44:	fe842703          	lw	a4,-24(s0)
    80022b48:	fe442783          	lw	a5,-28(s0)
    80022b4c:	2701                	sext.w	a4,a4
    80022b4e:	2781                	sext.w	a5,a5
    80022b50:	00f75463          	bge	a4,a5,80022b58 <strstartswith+0x40>
        return false;
    80022b54:	4781                	li	a5,0
    80022b56:	a0a9                	j	80022ba0 <strstartswith+0x88>
    }

    for (i = 0;i < start_len;i++) {
    80022b58:	fe042623          	sw	zero,-20(s0)
    80022b5c:	a80d                	j	80022b8e <strstartswith+0x76>
        if (src[i] != start[i]) {
    80022b5e:	fec42783          	lw	a5,-20(s0)
    80022b62:	fd843703          	ld	a4,-40(s0)
    80022b66:	97ba                	add	a5,a5,a4
    80022b68:	0007c683          	lbu	a3,0(a5)
    80022b6c:	fec42783          	lw	a5,-20(s0)
    80022b70:	fd043703          	ld	a4,-48(s0)
    80022b74:	97ba                	add	a5,a5,a4
    80022b76:	0007c783          	lbu	a5,0(a5)
    80022b7a:	8736                	mv	a4,a3
    80022b7c:	00f70463          	beq	a4,a5,80022b84 <strstartswith+0x6c>
            return false;
    80022b80:	4781                	li	a5,0
    80022b82:	a839                	j	80022ba0 <strstartswith+0x88>
    for (i = 0;i < start_len;i++) {
    80022b84:	fec42783          	lw	a5,-20(s0)
    80022b88:	2785                	addiw	a5,a5,1
    80022b8a:	fef42623          	sw	a5,-20(s0)
    80022b8e:	fec42703          	lw	a4,-20(s0)
    80022b92:	fe442783          	lw	a5,-28(s0)
    80022b96:	2701                	sext.w	a4,a4
    80022b98:	2781                	sext.w	a5,a5
    80022b9a:	fcf742e3          	blt	a4,a5,80022b5e <strstartswith+0x46>
        }
    }

    return true;
    80022b9e:	4785                	li	a5,1
}
    80022ba0:	853e                	mv	a0,a5
    80022ba2:	70a2                	ld	ra,40(sp)
    80022ba4:	7402                	ld	s0,32(sp)
    80022ba6:	6145                	addi	sp,sp,48
    80022ba8:	8082                	ret

0000000080022baa <strendswith>:

bool strendswith(const char *src, const char *end)
{
    80022baa:	7179                	addi	sp,sp,-48
    80022bac:	f406                	sd	ra,40(sp)
    80022bae:	f022                	sd	s0,32(sp)
    80022bb0:	1800                	addi	s0,sp,48
    80022bb2:	fca43c23          	sd	a0,-40(s0)
    80022bb6:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    80022bba:	fd843503          	ld	a0,-40(s0)
    80022bbe:	e0dff0ef          	jal	ra,800229ca <strlen>
    80022bc2:	87aa                	mv	a5,a0
    80022bc4:	fef42423          	sw	a5,-24(s0)
    int end_len = strlen(end);
    80022bc8:	fd043503          	ld	a0,-48(s0)
    80022bcc:	dffff0ef          	jal	ra,800229ca <strlen>
    80022bd0:	87aa                	mv	a5,a0
    80022bd2:	fef42223          	sw	a5,-28(s0)
    int cmp = src_len - end_len;
    80022bd6:	fe842703          	lw	a4,-24(s0)
    80022bda:	fe442783          	lw	a5,-28(s0)
    80022bde:	40f707bb          	subw	a5,a4,a5
    80022be2:	fef42023          	sw	a5,-32(s0)
    int i;
    
    if (src_len < end_len) {
    80022be6:	fe842703          	lw	a4,-24(s0)
    80022bea:	fe442783          	lw	a5,-28(s0)
    80022bee:	2701                	sext.w	a4,a4
    80022bf0:	2781                	sext.w	a5,a5
    80022bf2:	00f75463          	bge	a4,a5,80022bfa <strendswith+0x50>
        return false;
    80022bf6:	4781                	li	a5,0
    80022bf8:	a891                	j	80022c4c <strendswith+0xa2>
    }

    for (i = 0;i < end_len;i++) {
    80022bfa:	fe042623          	sw	zero,-20(s0)
    80022bfe:	a835                	j	80022c3a <strendswith+0x90>
        if (src[i + cmp] != end[i]) {
    80022c00:	fec42703          	lw	a4,-20(s0)
    80022c04:	fe042783          	lw	a5,-32(s0)
    80022c08:	9fb9                	addw	a5,a5,a4
    80022c0a:	2781                	sext.w	a5,a5
    80022c0c:	873e                	mv	a4,a5
    80022c0e:	fd843783          	ld	a5,-40(s0)
    80022c12:	97ba                	add	a5,a5,a4
    80022c14:	0007c683          	lbu	a3,0(a5)
    80022c18:	fec42783          	lw	a5,-20(s0)
    80022c1c:	fd043703          	ld	a4,-48(s0)
    80022c20:	97ba                	add	a5,a5,a4
    80022c22:	0007c783          	lbu	a5,0(a5)
    80022c26:	8736                	mv	a4,a3
    80022c28:	00f70463          	beq	a4,a5,80022c30 <strendswith+0x86>
            return false;
    80022c2c:	4781                	li	a5,0
    80022c2e:	a839                	j	80022c4c <strendswith+0xa2>
    for (i = 0;i < end_len;i++) {
    80022c30:	fec42783          	lw	a5,-20(s0)
    80022c34:	2785                	addiw	a5,a5,1
    80022c36:	fef42623          	sw	a5,-20(s0)
    80022c3a:	fec42703          	lw	a4,-20(s0)
    80022c3e:	fe442783          	lw	a5,-28(s0)
    80022c42:	2701                	sext.w	a4,a4
    80022c44:	2781                	sext.w	a5,a5
    80022c46:	faf74de3          	blt	a4,a5,80022c00 <strendswith+0x56>
        }
    }

    return true;    
    80022c4a:	4785                	li	a5,1
}
    80022c4c:	853e                	mv	a0,a5
    80022c4e:	70a2                	ld	ra,40(sp)
    80022c50:	7402                	ld	s0,32(sp)
    80022c52:	6145                	addi	sp,sp,48
    80022c54:	8082                	ret

0000000080022c56 <vector_init>:
    uint32_t size;
    uint32_t capacity;
    uint64_t *values;
} Vector;

static Vector *vector_init(Vector *vec) {
    80022c56:	1101                	addi	sp,sp,-32
    80022c58:	ec22                	sd	s0,24(sp)
    80022c5a:	1000                	addi	s0,sp,32
    80022c5c:	fea43423          	sd	a0,-24(s0)
    if (vec == NULL) {
    80022c60:	fe843783          	ld	a5,-24(s0)
    80022c64:	e399                	bnez	a5,80022c6a <vector_init+0x14>
        return NULL;
    80022c66:	4781                	li	a5,0
    80022c68:	a839                	j	80022c86 <vector_init+0x30>
    }
    vec->size = 0;
    80022c6a:	fe843783          	ld	a5,-24(s0)
    80022c6e:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    80022c72:	fe843783          	ld	a5,-24(s0)
    80022c76:	0007a223          	sw	zero,4(a5)
    vec->values = NULL;
    80022c7a:	fe843783          	ld	a5,-24(s0)
    80022c7e:	0007b423          	sd	zero,8(a5)
    return vec;
    80022c82:	fe843783          	ld	a5,-24(s0)
}
    80022c86:	853e                	mv	a0,a5
    80022c88:	6462                	ld	s0,24(sp)
    80022c8a:	6105                	addi	sp,sp,32
    80022c8c:	8082                	ret

0000000080022c8e <vector_new>:

Vector *vector_new(void) {
    80022c8e:	1141                	addi	sp,sp,-16
    80022c90:	e406                	sd	ra,8(sp)
    80022c92:	e022                	sd	s0,0(sp)
    80022c94:	0800                	addi	s0,sp,16
    return vector_init((Vector *)g_kmalloc(sizeof(Vector)));
    80022c96:	4541                	li	a0,16
    80022c98:	e34fd0ef          	jal	ra,800202cc <g_kmalloc>
    80022c9c:	87aa                	mv	a5,a0
    80022c9e:	853e                	mv	a0,a5
    80022ca0:	fb7ff0ef          	jal	ra,80022c56 <vector_init>
    80022ca4:	87aa                	mv	a5,a0
}
    80022ca6:	853e                	mv	a0,a5
    80022ca8:	60a2                	ld	ra,8(sp)
    80022caa:	6402                	ld	s0,0(sp)
    80022cac:	0141                	addi	sp,sp,16
    80022cae:	8082                	ret

0000000080022cb0 <vector_init_with_capacity>:

static Vector *vector_init_with_capacity(Vector *vec, uint32_t capacity) {
    80022cb0:	1101                	addi	sp,sp,-32
    80022cb2:	ec06                	sd	ra,24(sp)
    80022cb4:	e822                	sd	s0,16(sp)
    80022cb6:	1000                	addi	s0,sp,32
    80022cb8:	fea43423          	sd	a0,-24(s0)
    80022cbc:	87ae                	mv	a5,a1
    80022cbe:	fef42223          	sw	a5,-28(s0)
    if (vec == NULL) {
    80022cc2:	fe843783          	ld	a5,-24(s0)
    80022cc6:	e399                	bnez	a5,80022ccc <vector_init_with_capacity+0x1c>
        return NULL;
    80022cc8:	4781                	li	a5,0
    80022cca:	a035                	j	80022cf6 <vector_init_with_capacity+0x46>
    }
    vec->size = 0;
    80022ccc:	fe843783          	ld	a5,-24(s0)
    80022cd0:	0007a023          	sw	zero,0(a5)
    vec->capacity = capacity;
    80022cd4:	fe843783          	ld	a5,-24(s0)
    80022cd8:	fe442703          	lw	a4,-28(s0)
    80022cdc:	c3d8                	sw	a4,4(a5)
    vec->values = (uint64_t *)g_kcalloc(capacity, sizeof(uint64_t));
    80022cde:	fe446783          	lwu	a5,-28(s0)
    80022ce2:	45a1                	li	a1,8
    80022ce4:	853e                	mv	a0,a5
    80022ce6:	e1efd0ef          	jal	ra,80020304 <g_kcalloc>
    80022cea:	872a                	mv	a4,a0
    80022cec:	fe843783          	ld	a5,-24(s0)
    80022cf0:	e798                	sd	a4,8(a5)
    return vec;
    80022cf2:	fe843783          	ld	a5,-24(s0)
}
    80022cf6:	853e                	mv	a0,a5
    80022cf8:	60e2                	ld	ra,24(sp)
    80022cfa:	6442                	ld	s0,16(sp)
    80022cfc:	6105                	addi	sp,sp,32
    80022cfe:	8082                	ret

0000000080022d00 <vector_new_with_capacity>:

Vector *vector_new_with_capacity(uint32_t capacity) {
    80022d00:	1101                	addi	sp,sp,-32
    80022d02:	ec06                	sd	ra,24(sp)
    80022d04:	e822                	sd	s0,16(sp)
    80022d06:	1000                	addi	s0,sp,32
    80022d08:	87aa                	mv	a5,a0
    80022d0a:	fef42623          	sw	a5,-20(s0)
    return vector_init_with_capacity((Vector *)g_kmalloc(sizeof(Vector)), capacity);
    80022d0e:	4541                	li	a0,16
    80022d10:	dbcfd0ef          	jal	ra,800202cc <g_kmalloc>
    80022d14:	872a                	mv	a4,a0
    80022d16:	fec42783          	lw	a5,-20(s0)
    80022d1a:	85be                	mv	a1,a5
    80022d1c:	853a                	mv	a0,a4
    80022d1e:	f93ff0ef          	jal	ra,80022cb0 <vector_init_with_capacity>
    80022d22:	87aa                	mv	a5,a0
}
    80022d24:	853e                	mv	a0,a5
    80022d26:	60e2                	ld	ra,24(sp)
    80022d28:	6442                	ld	s0,16(sp)
    80022d2a:	6105                	addi	sp,sp,32
    80022d2c:	8082                	ret

0000000080022d2e <vector_push>:

void vector_push(Vector *vec, uint64_t value) {
    80022d2e:	1101                	addi	sp,sp,-32
    80022d30:	ec06                	sd	ra,24(sp)
    80022d32:	e822                	sd	s0,16(sp)
    80022d34:	1000                	addi	s0,sp,32
    80022d36:	fea43423          	sd	a0,-24(s0)
    80022d3a:	feb43023          	sd	a1,-32(s0)
    vector_insert(vec, vec->size, value);
    80022d3e:	fe843783          	ld	a5,-24(s0)
    80022d42:	439c                	lw	a5,0(a5)
    80022d44:	fe043603          	ld	a2,-32(s0)
    80022d48:	85be                	mv	a1,a5
    80022d4a:	fe843503          	ld	a0,-24(s0)
    80022d4e:	00e000ef          	jal	ra,80022d5c <vector_insert>
}
    80022d52:	0001                	nop
    80022d54:	60e2                	ld	ra,24(sp)
    80022d56:	6442                	ld	s0,16(sp)
    80022d58:	6105                	addi	sp,sp,32
    80022d5a:	8082                	ret

0000000080022d5c <vector_insert>:

void vector_insert(Vector *vec, uint32_t idx, uint64_t value) {
    80022d5c:	7139                	addi	sp,sp,-64
    80022d5e:	fc06                	sd	ra,56(sp)
    80022d60:	f822                	sd	s0,48(sp)
    80022d62:	0080                	addi	s0,sp,64
    80022d64:	fca43c23          	sd	a0,-40(s0)
    80022d68:	87ae                	mv	a5,a1
    80022d6a:	fcc43423          	sd	a2,-56(s0)
    80022d6e:	fcf42a23          	sw	a5,-44(s0)
    uint32_t i;
    vector_resize(vec, vec->size + 1);
    80022d72:	fd843783          	ld	a5,-40(s0)
    80022d76:	439c                	lw	a5,0(a5)
    80022d78:	2785                	addiw	a5,a5,1
    80022d7a:	2781                	sext.w	a5,a5
    80022d7c:	85be                	mv	a1,a5
    80022d7e:	fd843503          	ld	a0,-40(s0)
    80022d82:	214000ef          	jal	ra,80022f96 <vector_resize>
    for (i = vec->size - 1;i > idx;i--) {
    80022d86:	fd843783          	ld	a5,-40(s0)
    80022d8a:	439c                	lw	a5,0(a5)
    80022d8c:	37fd                	addiw	a5,a5,-1
    80022d8e:	fef42623          	sw	a5,-20(s0)
    80022d92:	a805                	j	80022dc2 <vector_insert+0x66>
        vector_set(vec, i, vector_get_unchecked(vec, i - 1));
    80022d94:	fec42783          	lw	a5,-20(s0)
    80022d98:	37fd                	addiw	a5,a5,-1
    80022d9a:	2781                	sext.w	a5,a5
    80022d9c:	85be                	mv	a1,a5
    80022d9e:	fd843503          	ld	a0,-40(s0)
    80022da2:	13a000ef          	jal	ra,80022edc <vector_get_unchecked>
    80022da6:	872a                	mv	a4,a0
    80022da8:	fec42783          	lw	a5,-20(s0)
    80022dac:	863a                	mv	a2,a4
    80022dae:	85be                	mv	a1,a5
    80022db0:	fd843503          	ld	a0,-40(s0)
    80022db4:	094000ef          	jal	ra,80022e48 <vector_set>
    for (i = vec->size - 1;i > idx;i--) {
    80022db8:	fec42783          	lw	a5,-20(s0)
    80022dbc:	37fd                	addiw	a5,a5,-1
    80022dbe:	fef42623          	sw	a5,-20(s0)
    80022dc2:	fec42703          	lw	a4,-20(s0)
    80022dc6:	fd442783          	lw	a5,-44(s0)
    80022dca:	2701                	sext.w	a4,a4
    80022dcc:	2781                	sext.w	a5,a5
    80022dce:	fce7e3e3          	bltu	a5,a4,80022d94 <vector_insert+0x38>
    }
    vector_set(vec, idx, value);
    80022dd2:	fd442783          	lw	a5,-44(s0)
    80022dd6:	fc843603          	ld	a2,-56(s0)
    80022dda:	85be                	mv	a1,a5
    80022ddc:	fd843503          	ld	a0,-40(s0)
    80022de0:	068000ef          	jal	ra,80022e48 <vector_set>
}
    80022de4:	0001                	nop
    80022de6:	70e2                	ld	ra,56(sp)
    80022de8:	7442                	ld	s0,48(sp)
    80022dea:	6121                	addi	sp,sp,64
    80022dec:	8082                	ret

0000000080022dee <vector_find>:

int vector_find(Vector *vec, uint64_t val) {
    80022dee:	7179                	addi	sp,sp,-48
    80022df0:	f422                	sd	s0,40(sp)
    80022df2:	1800                	addi	s0,sp,48
    80022df4:	fca43c23          	sd	a0,-40(s0)
    80022df8:	fcb43823          	sd	a1,-48(s0)
    int i;
    for (i = 0;i < (int)vec->size;i++) {
    80022dfc:	fe042623          	sw	zero,-20(s0)
    80022e00:	a02d                	j	80022e2a <vector_find+0x3c>
        if (vec->values[i] == val) {
    80022e02:	fd843783          	ld	a5,-40(s0)
    80022e06:	6798                	ld	a4,8(a5)
    80022e08:	fec42783          	lw	a5,-20(s0)
    80022e0c:	078e                	slli	a5,a5,0x3
    80022e0e:	97ba                	add	a5,a5,a4
    80022e10:	639c                	ld	a5,0(a5)
    80022e12:	fd043703          	ld	a4,-48(s0)
    80022e16:	00f71563          	bne	a4,a5,80022e20 <vector_find+0x32>
            return i;
    80022e1a:	fec42783          	lw	a5,-20(s0)
    80022e1e:	a00d                	j	80022e40 <vector_find+0x52>
    for (i = 0;i < (int)vec->size;i++) {
    80022e20:	fec42783          	lw	a5,-20(s0)
    80022e24:	2785                	addiw	a5,a5,1
    80022e26:	fef42623          	sw	a5,-20(s0)
    80022e2a:	fd843783          	ld	a5,-40(s0)
    80022e2e:	439c                	lw	a5,0(a5)
    80022e30:	0007871b          	sext.w	a4,a5
    80022e34:	fec42783          	lw	a5,-20(s0)
    80022e38:	2781                	sext.w	a5,a5
    80022e3a:	fce7c4e3          	blt	a5,a4,80022e02 <vector_find+0x14>
        }
    }
    return -1;
    80022e3e:	57fd                	li	a5,-1
}
    80022e40:	853e                	mv	a0,a5
    80022e42:	7422                	ld	s0,40(sp)
    80022e44:	6145                	addi	sp,sp,48
    80022e46:	8082                	ret

0000000080022e48 <vector_set>:

bool vector_set(Vector *vec, uint32_t idx, uint64_t val) {
    80022e48:	7179                	addi	sp,sp,-48
    80022e4a:	f422                	sd	s0,40(sp)
    80022e4c:	1800                	addi	s0,sp,48
    80022e4e:	fea43423          	sd	a0,-24(s0)
    80022e52:	87ae                	mv	a5,a1
    80022e54:	fcc43c23          	sd	a2,-40(s0)
    80022e58:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80022e5c:	fe843783          	ld	a5,-24(s0)
    80022e60:	4398                	lw	a4,0(a5)
    80022e62:	fe442783          	lw	a5,-28(s0)
    80022e66:	2781                	sext.w	a5,a5
    80022e68:	00e7e463          	bltu	a5,a4,80022e70 <vector_set+0x28>
        return false;
    80022e6c:	4781                	li	a5,0
    80022e6e:	a821                	j	80022e86 <vector_set+0x3e>
    }
    vec->values[idx] = val;
    80022e70:	fe843783          	ld	a5,-24(s0)
    80022e74:	6798                	ld	a4,8(a5)
    80022e76:	fe446783          	lwu	a5,-28(s0)
    80022e7a:	078e                	slli	a5,a5,0x3
    80022e7c:	97ba                	add	a5,a5,a4
    80022e7e:	fd843703          	ld	a4,-40(s0)
    80022e82:	e398                	sd	a4,0(a5)
    return true;
    80022e84:	4785                	li	a5,1
}
    80022e86:	853e                	mv	a0,a5
    80022e88:	7422                	ld	s0,40(sp)
    80022e8a:	6145                	addi	sp,sp,48
    80022e8c:	8082                	ret

0000000080022e8e <vector_get>:

bool vector_get(Vector *vec, uint32_t idx, uint64_t *val) {
    80022e8e:	7179                	addi	sp,sp,-48
    80022e90:	f422                	sd	s0,40(sp)
    80022e92:	1800                	addi	s0,sp,48
    80022e94:	fea43423          	sd	a0,-24(s0)
    80022e98:	87ae                	mv	a5,a1
    80022e9a:	fcc43c23          	sd	a2,-40(s0)
    80022e9e:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80022ea2:	fe843783          	ld	a5,-24(s0)
    80022ea6:	4398                	lw	a4,0(a5)
    80022ea8:	fe442783          	lw	a5,-28(s0)
    80022eac:	2781                	sext.w	a5,a5
    80022eae:	00e7e463          	bltu	a5,a4,80022eb6 <vector_get+0x28>
        return false;
    80022eb2:	4781                	li	a5,0
    80022eb4:	a005                	j	80022ed4 <vector_get+0x46>
    }
    if (val != NULL) {
    80022eb6:	fd843783          	ld	a5,-40(s0)
    80022eba:	cf81                	beqz	a5,80022ed2 <vector_get+0x44>
        *val = vec->values[idx];
    80022ebc:	fe843783          	ld	a5,-24(s0)
    80022ec0:	6798                	ld	a4,8(a5)
    80022ec2:	fe446783          	lwu	a5,-28(s0)
    80022ec6:	078e                	slli	a5,a5,0x3
    80022ec8:	97ba                	add	a5,a5,a4
    80022eca:	6398                	ld	a4,0(a5)
    80022ecc:	fd843783          	ld	a5,-40(s0)
    80022ed0:	e398                	sd	a4,0(a5)
    }
    return true;
    80022ed2:	4785                	li	a5,1
}
    80022ed4:	853e                	mv	a0,a5
    80022ed6:	7422                	ld	s0,40(sp)
    80022ed8:	6145                	addi	sp,sp,48
    80022eda:	8082                	ret

0000000080022edc <vector_get_unchecked>:

uint64_t vector_get_unchecked(Vector *vec, uint32_t idx) {
    80022edc:	1101                	addi	sp,sp,-32
    80022ede:	ec22                	sd	s0,24(sp)
    80022ee0:	1000                	addi	s0,sp,32
    80022ee2:	fea43423          	sd	a0,-24(s0)
    80022ee6:	87ae                	mv	a5,a1
    80022ee8:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80022eec:	fe843783          	ld	a5,-24(s0)
    80022ef0:	4398                	lw	a4,0(a5)
    80022ef2:	fe442783          	lw	a5,-28(s0)
    80022ef6:	2781                	sext.w	a5,a5
    80022ef8:	00e7e463          	bltu	a5,a4,80022f00 <vector_get_unchecked+0x24>
        return 0;
    80022efc:	4781                	li	a5,0
    80022efe:	a809                	j	80022f10 <vector_get_unchecked+0x34>
    }
    return vec->values[idx];
    80022f00:	fe843783          	ld	a5,-24(s0)
    80022f04:	6798                	ld	a4,8(a5)
    80022f06:	fe446783          	lwu	a5,-28(s0)
    80022f0a:	078e                	slli	a5,a5,0x3
    80022f0c:	97ba                	add	a5,a5,a4
    80022f0e:	639c                	ld	a5,0(a5)
}
    80022f10:	853e                	mv	a0,a5
    80022f12:	6462                	ld	s0,24(sp)
    80022f14:	6105                	addi	sp,sp,32
    80022f16:	8082                	ret

0000000080022f18 <vector_resize_with_default>:


void vector_resize_with_default(Vector *vec, uint32_t new_size, uint64_t def) {
    80022f18:	7139                	addi	sp,sp,-64
    80022f1a:	fc06                	sd	ra,56(sp)
    80022f1c:	f822                	sd	s0,48(sp)
    80022f1e:	0080                	addi	s0,sp,64
    80022f20:	fca43c23          	sd	a0,-40(s0)
    80022f24:	87ae                	mv	a5,a1
    80022f26:	fcc43423          	sd	a2,-56(s0)
    80022f2a:	fcf42a23          	sw	a5,-44(s0)
    uint32_t old_size = vec->size;
    80022f2e:	fd843783          	ld	a5,-40(s0)
    80022f32:	439c                	lw	a5,0(a5)
    80022f34:	fef42423          	sw	a5,-24(s0)
    vector_resize(vec, new_size);
    80022f38:	fd442783          	lw	a5,-44(s0)
    80022f3c:	85be                	mv	a1,a5
    80022f3e:	fd843503          	ld	a0,-40(s0)
    80022f42:	054000ef          	jal	ra,80022f96 <vector_resize>
    if (old_size < new_size) {
    80022f46:	fe842703          	lw	a4,-24(s0)
    80022f4a:	fd442783          	lw	a5,-44(s0)
    80022f4e:	2701                	sext.w	a4,a4
    80022f50:	2781                	sext.w	a5,a5
    80022f52:	02f77d63          	bgeu	a4,a5,80022f8c <vector_resize_with_default+0x74>
        uint32_t i;
        for (i = old_size;i < new_size;i++) {
    80022f56:	fe842783          	lw	a5,-24(s0)
    80022f5a:	fef42623          	sw	a5,-20(s0)
    80022f5e:	a839                	j	80022f7c <vector_resize_with_default+0x64>
            vector_set(vec, i, def);
    80022f60:	fec42783          	lw	a5,-20(s0)
    80022f64:	fc843603          	ld	a2,-56(s0)
    80022f68:	85be                	mv	a1,a5
    80022f6a:	fd843503          	ld	a0,-40(s0)
    80022f6e:	edbff0ef          	jal	ra,80022e48 <vector_set>
        for (i = old_size;i < new_size;i++) {
    80022f72:	fec42783          	lw	a5,-20(s0)
    80022f76:	2785                	addiw	a5,a5,1
    80022f78:	fef42623          	sw	a5,-20(s0)
    80022f7c:	fec42703          	lw	a4,-20(s0)
    80022f80:	fd442783          	lw	a5,-44(s0)
    80022f84:	2701                	sext.w	a4,a4
    80022f86:	2781                	sext.w	a5,a5
    80022f88:	fcf76ce3          	bltu	a4,a5,80022f60 <vector_resize_with_default+0x48>
        }
    }
}
    80022f8c:	0001                	nop
    80022f8e:	70e2                	ld	ra,56(sp)
    80022f90:	7442                	ld	s0,48(sp)
    80022f92:	6121                	addi	sp,sp,64
    80022f94:	8082                	ret

0000000080022f96 <vector_resize>:

void vector_resize(Vector *vec, uint32_t new_size) {
    80022f96:	7179                	addi	sp,sp,-48
    80022f98:	f406                	sd	ra,40(sp)
    80022f9a:	f022                	sd	s0,32(sp)
    80022f9c:	1800                	addi	s0,sp,48
    80022f9e:	fca43c23          	sd	a0,-40(s0)
    80022fa2:	87ae                	mv	a5,a1
    80022fa4:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_size > vec->capacity) {
    80022fa8:	fd843783          	ld	a5,-40(s0)
    80022fac:	43d8                	lw	a4,4(a5)
    80022fae:	fd442783          	lw	a5,-44(s0)
    80022fb2:	2781                	sext.w	a5,a5
    80022fb4:	06f77963          	bgeu	a4,a5,80023026 <vector_resize+0x90>
        vals = (uint64_t *)g_kcalloc(new_size, sizeof(uint64_t));
    80022fb8:	fd446783          	lwu	a5,-44(s0)
    80022fbc:	45a1                	li	a1,8
    80022fbe:	853e                	mv	a0,a5
    80022fc0:	b44fd0ef          	jal	ra,80020304 <g_kcalloc>
    80022fc4:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    80022fc8:	fe042623          	sw	zero,-20(s0)
    80022fcc:	a02d                	j	80022ff6 <vector_resize+0x60>
            vals[i] = vec->values[i];
    80022fce:	fd843783          	ld	a5,-40(s0)
    80022fd2:	6798                	ld	a4,8(a5)
    80022fd4:	fec46783          	lwu	a5,-20(s0)
    80022fd8:	078e                	slli	a5,a5,0x3
    80022fda:	973e                	add	a4,a4,a5
    80022fdc:	fec46783          	lwu	a5,-20(s0)
    80022fe0:	078e                	slli	a5,a5,0x3
    80022fe2:	fe043683          	ld	a3,-32(s0)
    80022fe6:	97b6                	add	a5,a5,a3
    80022fe8:	6318                	ld	a4,0(a4)
    80022fea:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80022fec:	fec42783          	lw	a5,-20(s0)
    80022ff0:	2785                	addiw	a5,a5,1
    80022ff2:	fef42623          	sw	a5,-20(s0)
    80022ff6:	fd843783          	ld	a5,-40(s0)
    80022ffa:	4398                	lw	a4,0(a5)
    80022ffc:	fec42783          	lw	a5,-20(s0)
    80023000:	2781                	sext.w	a5,a5
    80023002:	fce7e6e3          	bltu	a5,a4,80022fce <vector_resize+0x38>
        }
        g_kfree(vec->values);
    80023006:	fd843783          	ld	a5,-40(s0)
    8002300a:	679c                	ld	a5,8(a5)
    8002300c:	853e                	mv	a0,a5
    8002300e:	b58fd0ef          	jal	ra,80020366 <g_kfree>
        vec->values = vals;
    80023012:	fd843783          	ld	a5,-40(s0)
    80023016:	fe043703          	ld	a4,-32(s0)
    8002301a:	e798                	sd	a4,8(a5)
        vec->capacity = new_size;
    8002301c:	fd843783          	ld	a5,-40(s0)
    80023020:	fd442703          	lw	a4,-44(s0)
    80023024:	c3d8                	sw	a4,4(a5)
    }        
    vec->size = new_size;    
    80023026:	fd843783          	ld	a5,-40(s0)
    8002302a:	fd442703          	lw	a4,-44(s0)
    8002302e:	c398                	sw	a4,0(a5)
}
    80023030:	0001                	nop
    80023032:	70a2                	ld	ra,40(sp)
    80023034:	7402                	ld	s0,32(sp)
    80023036:	6145                	addi	sp,sp,48
    80023038:	8082                	ret

000000008002303a <vector_reserve>:

void vector_reserve(Vector *vec, uint32_t new_capacity) {
    8002303a:	7179                	addi	sp,sp,-48
    8002303c:	f406                	sd	ra,40(sp)
    8002303e:	f022                	sd	s0,32(sp)
    80023040:	1800                	addi	s0,sp,48
    80023042:	fca43c23          	sd	a0,-40(s0)
    80023046:	87ae                	mv	a5,a1
    80023048:	fcf42a23          	sw	a5,-44(s0)
    uint64_t *vals;
    uint32_t i;
    if (new_capacity > vec->capacity) {
    8002304c:	fd843783          	ld	a5,-40(s0)
    80023050:	43d8                	lw	a4,4(a5)
    80023052:	fd442783          	lw	a5,-44(s0)
    80023056:	2781                	sext.w	a5,a5
    80023058:	06f77a63          	bgeu	a4,a5,800230cc <vector_reserve+0x92>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    8002305c:	fd446783          	lwu	a5,-44(s0)
    80023060:	45a1                	li	a1,8
    80023062:	853e                	mv	a0,a5
    80023064:	aa0fd0ef          	jal	ra,80020304 <g_kcalloc>
    80023068:	fea43023          	sd	a0,-32(s0)
        for (i = 0;i < vec->size;i++) {
    8002306c:	fe042623          	sw	zero,-20(s0)
    80023070:	a02d                	j	8002309a <vector_reserve+0x60>
            vals[i] = vec->values[i];
    80023072:	fd843783          	ld	a5,-40(s0)
    80023076:	6798                	ld	a4,8(a5)
    80023078:	fec46783          	lwu	a5,-20(s0)
    8002307c:	078e                	slli	a5,a5,0x3
    8002307e:	973e                	add	a4,a4,a5
    80023080:	fec46783          	lwu	a5,-20(s0)
    80023084:	078e                	slli	a5,a5,0x3
    80023086:	fe043683          	ld	a3,-32(s0)
    8002308a:	97b6                	add	a5,a5,a3
    8002308c:	6318                	ld	a4,0(a4)
    8002308e:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80023090:	fec42783          	lw	a5,-20(s0)
    80023094:	2785                	addiw	a5,a5,1
    80023096:	fef42623          	sw	a5,-20(s0)
    8002309a:	fd843783          	ld	a5,-40(s0)
    8002309e:	4398                	lw	a4,0(a5)
    800230a0:	fec42783          	lw	a5,-20(s0)
    800230a4:	2781                	sext.w	a5,a5
    800230a6:	fce7e6e3          	bltu	a5,a4,80023072 <vector_reserve+0x38>
        }
        g_kfree(vec->values);
    800230aa:	fd843783          	ld	a5,-40(s0)
    800230ae:	679c                	ld	a5,8(a5)
    800230b0:	853e                	mv	a0,a5
    800230b2:	ab4fd0ef          	jal	ra,80020366 <g_kfree>
        vec->values = vals;
    800230b6:	fd843783          	ld	a5,-40(s0)
    800230ba:	fe043703          	ld	a4,-32(s0)
    800230be:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    800230c0:	fd843783          	ld	a5,-40(s0)
    800230c4:	fd442703          	lw	a4,-44(s0)
    800230c8:	c3d8                	sw	a4,4(a5)
        }
        g_kfree(vec->values);
        vec->values = vals;
        vec->capacity = new_capacity;
    }
}
    800230ca:	a04d                	j	8002316c <vector_reserve+0x132>
    else if (new_capacity > 0 && new_capacity < vec->capacity) {
    800230cc:	fd442783          	lw	a5,-44(s0)
    800230d0:	2781                	sext.w	a5,a5
    800230d2:	cfc9                	beqz	a5,8002316c <vector_reserve+0x132>
    800230d4:	fd843783          	ld	a5,-40(s0)
    800230d8:	43d8                	lw	a4,4(a5)
    800230da:	fd442783          	lw	a5,-44(s0)
    800230de:	2781                	sext.w	a5,a5
    800230e0:	08e7f663          	bgeu	a5,a4,8002316c <vector_reserve+0x132>
        vals = (uint64_t *)g_kcalloc(new_capacity, sizeof(uint64_t));
    800230e4:	fd446783          	lwu	a5,-44(s0)
    800230e8:	45a1                	li	a1,8
    800230ea:	853e                	mv	a0,a5
    800230ec:	a18fd0ef          	jal	ra,80020304 <g_kcalloc>
    800230f0:	fea43023          	sd	a0,-32(s0)
        if (new_capacity < vec->size) {
    800230f4:	fd843783          	ld	a5,-40(s0)
    800230f8:	4398                	lw	a4,0(a5)
    800230fa:	fd442783          	lw	a5,-44(s0)
    800230fe:	2781                	sext.w	a5,a5
    80023100:	00e7f763          	bgeu	a5,a4,8002310e <vector_reserve+0xd4>
            vec->size = new_capacity;
    80023104:	fd843783          	ld	a5,-40(s0)
    80023108:	fd442703          	lw	a4,-44(s0)
    8002310c:	c398                	sw	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    8002310e:	fe042623          	sw	zero,-20(s0)
    80023112:	a02d                	j	8002313c <vector_reserve+0x102>
            vals[i] = vec->values[i];
    80023114:	fd843783          	ld	a5,-40(s0)
    80023118:	6798                	ld	a4,8(a5)
    8002311a:	fec46783          	lwu	a5,-20(s0)
    8002311e:	078e                	slli	a5,a5,0x3
    80023120:	973e                	add	a4,a4,a5
    80023122:	fec46783          	lwu	a5,-20(s0)
    80023126:	078e                	slli	a5,a5,0x3
    80023128:	fe043683          	ld	a3,-32(s0)
    8002312c:	97b6                	add	a5,a5,a3
    8002312e:	6318                	ld	a4,0(a4)
    80023130:	e398                	sd	a4,0(a5)
        for (i = 0;i < vec->size;i++) {
    80023132:	fec42783          	lw	a5,-20(s0)
    80023136:	2785                	addiw	a5,a5,1
    80023138:	fef42623          	sw	a5,-20(s0)
    8002313c:	fd843783          	ld	a5,-40(s0)
    80023140:	4398                	lw	a4,0(a5)
    80023142:	fec42783          	lw	a5,-20(s0)
    80023146:	2781                	sext.w	a5,a5
    80023148:	fce7e6e3          	bltu	a5,a4,80023114 <vector_reserve+0xda>
        g_kfree(vec->values);
    8002314c:	fd843783          	ld	a5,-40(s0)
    80023150:	679c                	ld	a5,8(a5)
    80023152:	853e                	mv	a0,a5
    80023154:	a12fd0ef          	jal	ra,80020366 <g_kfree>
        vec->values = vals;
    80023158:	fd843783          	ld	a5,-40(s0)
    8002315c:	fe043703          	ld	a4,-32(s0)
    80023160:	e798                	sd	a4,8(a5)
        vec->capacity = new_capacity;
    80023162:	fd843783          	ld	a5,-40(s0)
    80023166:	fd442703          	lw	a4,-44(s0)
    8002316a:	c3d8                	sw	a4,4(a5)
}
    8002316c:	0001                	nop
    8002316e:	70a2                	ld	ra,40(sp)
    80023170:	7402                	ld	s0,32(sp)
    80023172:	6145                	addi	sp,sp,48
    80023174:	8082                	ret

0000000080023176 <vector_remove>:

bool vector_remove(Vector *vec, uint32_t idx) {
    80023176:	1101                	addi	sp,sp,-32
    80023178:	ec22                	sd	s0,24(sp)
    8002317a:	1000                	addi	s0,sp,32
    8002317c:	fea43423          	sd	a0,-24(s0)
    80023180:	87ae                	mv	a5,a1
    80023182:	fef42223          	sw	a5,-28(s0)
    if (idx >= vec->size) {
    80023186:	fe843783          	ld	a5,-24(s0)
    8002318a:	4398                	lw	a4,0(a5)
    8002318c:	fe442783          	lw	a5,-28(s0)
    80023190:	2781                	sext.w	a5,a5
    80023192:	00e7e463          	bltu	a5,a4,8002319a <vector_remove+0x24>
        return false;
    80023196:	4781                	li	a5,0
    80023198:	a8a9                	j	800231f2 <vector_remove+0x7c>
    }
    vec->size -= 1;
    8002319a:	fe843783          	ld	a5,-24(s0)
    8002319e:	439c                	lw	a5,0(a5)
    800231a0:	37fd                	addiw	a5,a5,-1
    800231a2:	0007871b          	sext.w	a4,a5
    800231a6:	fe843783          	ld	a5,-24(s0)
    800231aa:	c398                	sw	a4,0(a5)
    for (;idx < vec->size;idx++) {
    800231ac:	a815                	j	800231e0 <vector_remove+0x6a>
        vec->values[idx] = vec->values[idx + 1];
    800231ae:	fe843783          	ld	a5,-24(s0)
    800231b2:	6798                	ld	a4,8(a5)
    800231b4:	fe442783          	lw	a5,-28(s0)
    800231b8:	2785                	addiw	a5,a5,1
    800231ba:	2781                	sext.w	a5,a5
    800231bc:	1782                	slli	a5,a5,0x20
    800231be:	9381                	srli	a5,a5,0x20
    800231c0:	078e                	slli	a5,a5,0x3
    800231c2:	973e                	add	a4,a4,a5
    800231c4:	fe843783          	ld	a5,-24(s0)
    800231c8:	6794                	ld	a3,8(a5)
    800231ca:	fe446783          	lwu	a5,-28(s0)
    800231ce:	078e                	slli	a5,a5,0x3
    800231d0:	97b6                	add	a5,a5,a3
    800231d2:	6318                	ld	a4,0(a4)
    800231d4:	e398                	sd	a4,0(a5)
    for (;idx < vec->size;idx++) {
    800231d6:	fe442783          	lw	a5,-28(s0)
    800231da:	2785                	addiw	a5,a5,1
    800231dc:	fef42223          	sw	a5,-28(s0)
    800231e0:	fe843783          	ld	a5,-24(s0)
    800231e4:	4398                	lw	a4,0(a5)
    800231e6:	fe442783          	lw	a5,-28(s0)
    800231ea:	2781                	sext.w	a5,a5
    800231ec:	fce7e1e3          	bltu	a5,a4,800231ae <vector_remove+0x38>
    }
    return true;
    800231f0:	4785                	li	a5,1
}
    800231f2:	853e                	mv	a0,a5
    800231f4:	6462                	ld	s0,24(sp)
    800231f6:	6105                	addi	sp,sp,32
    800231f8:	8082                	ret

00000000800231fa <vector_remove_value>:

bool vector_remove_value(Vector *vec, uint64_t val) {
    800231fa:	7179                	addi	sp,sp,-48
    800231fc:	f406                	sd	ra,40(sp)
    800231fe:	f022                	sd	s0,32(sp)
    80023200:	1800                	addi	s0,sp,48
    80023202:	fca43c23          	sd	a0,-40(s0)
    80023206:	fcb43823          	sd	a1,-48(s0)
    uint32_t i;
    for (i = 0;i < vec->size;i++) {
    8002320a:	fe042623          	sw	zero,-20(s0)
    8002320e:	a81d                	j	80023244 <vector_remove_value+0x4a>
        if (vec->values[i] == val) {
    80023210:	fd843783          	ld	a5,-40(s0)
    80023214:	6798                	ld	a4,8(a5)
    80023216:	fec46783          	lwu	a5,-20(s0)
    8002321a:	078e                	slli	a5,a5,0x3
    8002321c:	97ba                	add	a5,a5,a4
    8002321e:	639c                	ld	a5,0(a5)
    80023220:	fd043703          	ld	a4,-48(s0)
    80023224:	00f71b63          	bne	a4,a5,8002323a <vector_remove_value+0x40>
            vector_remove(vec, i);
    80023228:	fec42783          	lw	a5,-20(s0)
    8002322c:	85be                	mv	a1,a5
    8002322e:	fd843503          	ld	a0,-40(s0)
    80023232:	f45ff0ef          	jal	ra,80023176 <vector_remove>
            return true;
    80023236:	4785                	li	a5,1
    80023238:	a839                	j	80023256 <vector_remove_value+0x5c>
    for (i = 0;i < vec->size;i++) {
    8002323a:	fec42783          	lw	a5,-20(s0)
    8002323e:	2785                	addiw	a5,a5,1
    80023240:	fef42623          	sw	a5,-20(s0)
    80023244:	fd843783          	ld	a5,-40(s0)
    80023248:	4398                	lw	a4,0(a5)
    8002324a:	fec42783          	lw	a5,-20(s0)
    8002324e:	2781                	sext.w	a5,a5
    80023250:	fce7e0e3          	bltu	a5,a4,80023210 <vector_remove_value+0x16>
        }
    }
    return false;
    80023254:	4781                	li	a5,0
}
    80023256:	853e                	mv	a0,a5
    80023258:	70a2                	ld	ra,40(sp)
    8002325a:	7402                	ld	s0,32(sp)
    8002325c:	6145                	addi	sp,sp,48
    8002325e:	8082                	ret

0000000080023260 <vector_clear>:

void vector_clear(Vector *vec) {
    80023260:	1101                	addi	sp,sp,-32
    80023262:	ec06                	sd	ra,24(sp)
    80023264:	e822                	sd	s0,16(sp)
    80023266:	1000                	addi	s0,sp,32
    80023268:	fea43423          	sd	a0,-24(s0)
    vector_resize(vec, 0);
    8002326c:	4581                	li	a1,0
    8002326e:	fe843503          	ld	a0,-24(s0)
    80023272:	d25ff0ef          	jal	ra,80022f96 <vector_resize>
}
    80023276:	0001                	nop
    80023278:	60e2                	ld	ra,24(sp)
    8002327a:	6442                	ld	s0,16(sp)
    8002327c:	6105                	addi	sp,sp,32
    8002327e:	8082                	ret

0000000080023280 <vector_binsearch_ascending>:

int vector_binsearch_ascending(struct Vector *vec, uint64_t key) {
    80023280:	7179                	addi	sp,sp,-48
    80023282:	f406                	sd	ra,40(sp)
    80023284:	f022                	sd	s0,32(sp)
    80023286:	1800                	addi	s0,sp,48
    80023288:	fca43c23          	sd	a0,-40(s0)
    8002328c:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    80023290:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec);
    80023294:	fd843503          	ld	a0,-40(s0)
    80023298:	356000ef          	jal	ra,800235ee <vector_size>
    8002329c:	87aa                	mv	a5,a0
    8002329e:	2781                	sext.w	a5,a5
    800232a0:	fef42423          	sw	a5,-24(s0)

    while (low < high) {
    800232a4:	a0ad                	j	8002330e <vector_binsearch_ascending+0x8e>
        int mid = (low + high) / 2;
    800232a6:	fec42703          	lw	a4,-20(s0)
    800232aa:	fe842783          	lw	a5,-24(s0)
    800232ae:	9fb9                	addw	a5,a5,a4
    800232b0:	2781                	sext.w	a5,a5
    800232b2:	01f7d71b          	srliw	a4,a5,0x1f
    800232b6:	9fb9                	addw	a5,a5,a4
    800232b8:	4017d79b          	sraiw	a5,a5,0x1
    800232bc:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) > key) {
    800232c0:	fe442783          	lw	a5,-28(s0)
    800232c4:	85be                	mv	a1,a5
    800232c6:	fd843503          	ld	a0,-40(s0)
    800232ca:	c13ff0ef          	jal	ra,80022edc <vector_get_unchecked>
    800232ce:	872a                	mv	a4,a0
    800232d0:	fd043783          	ld	a5,-48(s0)
    800232d4:	00e7f863          	bgeu	a5,a4,800232e4 <vector_binsearch_ascending+0x64>
            high = mid - 1;
    800232d8:	fe442783          	lw	a5,-28(s0)
    800232dc:	37fd                	addiw	a5,a5,-1
    800232de:	fef42423          	sw	a5,-24(s0)
    800232e2:	a035                	j	8002330e <vector_binsearch_ascending+0x8e>
        }
        else if (vector_get_unchecked(vec, mid) < key) {
    800232e4:	fe442783          	lw	a5,-28(s0)
    800232e8:	85be                	mv	a1,a5
    800232ea:	fd843503          	ld	a0,-40(s0)
    800232ee:	befff0ef          	jal	ra,80022edc <vector_get_unchecked>
    800232f2:	872a                	mv	a4,a0
    800232f4:	fd043783          	ld	a5,-48(s0)
    800232f8:	00f77863          	bgeu	a4,a5,80023308 <vector_binsearch_ascending+0x88>
            low = mid + 1;
    800232fc:	fe442783          	lw	a5,-28(s0)
    80023300:	2785                	addiw	a5,a5,1
    80023302:	fef42623          	sw	a5,-20(s0)
    80023306:	a021                	j	8002330e <vector_binsearch_ascending+0x8e>
        }
        else {
            return mid;
    80023308:	fe442783          	lw	a5,-28(s0)
    8002330c:	a811                	j	80023320 <vector_binsearch_ascending+0xa0>
    while (low < high) {
    8002330e:	fec42703          	lw	a4,-20(s0)
    80023312:	fe842783          	lw	a5,-24(s0)
    80023316:	2701                	sext.w	a4,a4
    80023318:	2781                	sext.w	a5,a5
    8002331a:	f8f746e3          	blt	a4,a5,800232a6 <vector_binsearch_ascending+0x26>
        }
    }
    return -1;
    8002331e:	57fd                	li	a5,-1
}
    80023320:	853e                	mv	a0,a5
    80023322:	70a2                	ld	ra,40(sp)
    80023324:	7402                	ld	s0,32(sp)
    80023326:	6145                	addi	sp,sp,48
    80023328:	8082                	ret

000000008002332a <vector_binsearch_descending>:

int vector_binsearch_descending(struct Vector *vec, uint64_t key) {
    8002332a:	7179                	addi	sp,sp,-48
    8002332c:	f406                	sd	ra,40(sp)
    8002332e:	f022                	sd	s0,32(sp)
    80023330:	1800                	addi	s0,sp,48
    80023332:	fca43c23          	sd	a0,-40(s0)
    80023336:	fcb43823          	sd	a1,-48(s0)
    int low = 0;
    8002333a:	fe042623          	sw	zero,-20(s0)
    int high = vector_size(vec) - 1;
    8002333e:	fd843503          	ld	a0,-40(s0)
    80023342:	2ac000ef          	jal	ra,800235ee <vector_size>
    80023346:	87aa                	mv	a5,a0
    80023348:	2781                	sext.w	a5,a5
    8002334a:	37fd                	addiw	a5,a5,-1
    8002334c:	2781                	sext.w	a5,a5
    8002334e:	fef42423          	sw	a5,-24(s0)

    while (low <= high) {
    80023352:	a0ad                	j	800233bc <vector_binsearch_descending+0x92>
        int mid = (low + high) / 2;
    80023354:	fec42703          	lw	a4,-20(s0)
    80023358:	fe842783          	lw	a5,-24(s0)
    8002335c:	9fb9                	addw	a5,a5,a4
    8002335e:	2781                	sext.w	a5,a5
    80023360:	01f7d71b          	srliw	a4,a5,0x1f
    80023364:	9fb9                	addw	a5,a5,a4
    80023366:	4017d79b          	sraiw	a5,a5,0x1
    8002336a:	fef42223          	sw	a5,-28(s0)
        if (vector_get_unchecked(vec, mid) < key) {
    8002336e:	fe442783          	lw	a5,-28(s0)
    80023372:	85be                	mv	a1,a5
    80023374:	fd843503          	ld	a0,-40(s0)
    80023378:	b65ff0ef          	jal	ra,80022edc <vector_get_unchecked>
    8002337c:	872a                	mv	a4,a0
    8002337e:	fd043783          	ld	a5,-48(s0)
    80023382:	00f77863          	bgeu	a4,a5,80023392 <vector_binsearch_descending+0x68>
            high = mid - 1;
    80023386:	fe442783          	lw	a5,-28(s0)
    8002338a:	37fd                	addiw	a5,a5,-1
    8002338c:	fef42423          	sw	a5,-24(s0)
    80023390:	a035                	j	800233bc <vector_binsearch_descending+0x92>
        }
        else if (vector_get_unchecked(vec, mid) > key) {
    80023392:	fe442783          	lw	a5,-28(s0)
    80023396:	85be                	mv	a1,a5
    80023398:	fd843503          	ld	a0,-40(s0)
    8002339c:	b41ff0ef          	jal	ra,80022edc <vector_get_unchecked>
    800233a0:	872a                	mv	a4,a0
    800233a2:	fd043783          	ld	a5,-48(s0)
    800233a6:	00e7f863          	bgeu	a5,a4,800233b6 <vector_binsearch_descending+0x8c>
            low = mid + 1;
    800233aa:	fe442783          	lw	a5,-28(s0)
    800233ae:	2785                	addiw	a5,a5,1
    800233b0:	fef42623          	sw	a5,-20(s0)
    800233b4:	a021                	j	800233bc <vector_binsearch_descending+0x92>
        }
        else {
            return mid;
    800233b6:	fe442783          	lw	a5,-28(s0)
    800233ba:	a811                	j	800233ce <vector_binsearch_descending+0xa4>
    while (low <= high) {
    800233bc:	fec42703          	lw	a4,-20(s0)
    800233c0:	fe842783          	lw	a5,-24(s0)
    800233c4:	2701                	sext.w	a4,a4
    800233c6:	2781                	sext.w	a5,a5
    800233c8:	f8e7d6e3          	bge	a5,a4,80023354 <vector_binsearch_descending+0x2a>
        }
    }
    return -1;
    800233cc:	57fd                	li	a5,-1
}
    800233ce:	853e                	mv	a0,a5
    800233d0:	70a2                	ld	ra,40(sp)
    800233d2:	7402                	ld	s0,32(sp)
    800233d4:	6145                	addi	sp,sp,48
    800233d6:	8082                	ret

00000000800233d8 <vector_sort>:

void vector_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    800233d8:	1101                	addi	sp,sp,-32
    800233da:	ec06                	sd	ra,24(sp)
    800233dc:	e822                	sd	s0,16(sp)
    800233de:	1000                	addi	s0,sp,32
    800233e0:	fea43423          	sd	a0,-24(s0)
    800233e4:	feb43023          	sd	a1,-32(s0)
    vector_insertion_sort(vec, comp);
    800233e8:	fe043583          	ld	a1,-32(s0)
    800233ec:	fe843503          	ld	a0,-24(s0)
    800233f0:	10e000ef          	jal	ra,800234fe <vector_insertion_sort>
}
    800233f4:	0001                	nop
    800233f6:	60e2                	ld	ra,24(sp)
    800233f8:	6442                	ld	s0,16(sp)
    800233fa:	6105                	addi	sp,sp,32
    800233fc:	8082                	ret

00000000800233fe <vector_selection_sort>:

void vector_selection_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    800233fe:	715d                	addi	sp,sp,-80
    80023400:	e486                	sd	ra,72(sp)
    80023402:	e0a2                	sd	s0,64(sp)
    80023404:	fc26                	sd	s1,56(sp)
    80023406:	0880                	addi	s0,sp,80
    80023408:	faa43c23          	sd	a0,-72(s0)
    8002340c:	fab43823          	sd	a1,-80(s0)
    uint32_t i;
    uint32_t j;
    uint32_t min_idx;
    uint64_t tmp;

    for (i = 0;i < vector_size(vec);i++) {
    80023410:	fc042e23          	sw	zero,-36(s0)
    80023414:	a0d1                	j	800234d8 <vector_selection_sort+0xda>
        min_idx = i;
    80023416:	fdc42783          	lw	a5,-36(s0)
    8002341a:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    8002341e:	fdc42783          	lw	a5,-36(s0)
    80023422:	2785                	addiw	a5,a5,1
    80023424:	fcf42c23          	sw	a5,-40(s0)
    80023428:	a0a9                	j	80023472 <vector_selection_sort+0x74>
            if (!comp(vector_get_unchecked(vec, min_idx), vector_get_unchecked(vec, j))) {
    8002342a:	fd442783          	lw	a5,-44(s0)
    8002342e:	85be                	mv	a1,a5
    80023430:	fb843503          	ld	a0,-72(s0)
    80023434:	aa9ff0ef          	jal	ra,80022edc <vector_get_unchecked>
    80023438:	84aa                	mv	s1,a0
    8002343a:	fd842783          	lw	a5,-40(s0)
    8002343e:	85be                	mv	a1,a5
    80023440:	fb843503          	ld	a0,-72(s0)
    80023444:	a99ff0ef          	jal	ra,80022edc <vector_get_unchecked>
    80023448:	87aa                	mv	a5,a0
    8002344a:	fb043703          	ld	a4,-80(s0)
    8002344e:	85be                	mv	a1,a5
    80023450:	8526                	mv	a0,s1
    80023452:	9702                	jalr	a4
    80023454:	87aa                	mv	a5,a0
    80023456:	0017c793          	xori	a5,a5,1
    8002345a:	0ff7f793          	andi	a5,a5,255
    8002345e:	c789                	beqz	a5,80023468 <vector_selection_sort+0x6a>
                min_idx = j;
    80023460:	fd842783          	lw	a5,-40(s0)
    80023464:	fcf42a23          	sw	a5,-44(s0)
        for (j = i + 1;j < vector_size(vec);j++) {
    80023468:	fd842783          	lw	a5,-40(s0)
    8002346c:	2785                	addiw	a5,a5,1
    8002346e:	fcf42c23          	sw	a5,-40(s0)
    80023472:	fb843503          	ld	a0,-72(s0)
    80023476:	178000ef          	jal	ra,800235ee <vector_size>
    8002347a:	87aa                	mv	a5,a0
    8002347c:	0007871b          	sext.w	a4,a5
    80023480:	fd842783          	lw	a5,-40(s0)
    80023484:	2781                	sext.w	a5,a5
    80023486:	fae7e2e3          	bltu	a5,a4,8002342a <vector_selection_sort+0x2c>
            }
        }
        tmp = vector_get_unchecked(vec, i);
    8002348a:	fdc42783          	lw	a5,-36(s0)
    8002348e:	85be                	mv	a1,a5
    80023490:	fb843503          	ld	a0,-72(s0)
    80023494:	a49ff0ef          	jal	ra,80022edc <vector_get_unchecked>
    80023498:	fca43423          	sd	a0,-56(s0)
        vector_set(vec, i, vector_get_unchecked(vec, min_idx));
    8002349c:	fd442783          	lw	a5,-44(s0)
    800234a0:	85be                	mv	a1,a5
    800234a2:	fb843503          	ld	a0,-72(s0)
    800234a6:	a37ff0ef          	jal	ra,80022edc <vector_get_unchecked>
    800234aa:	872a                	mv	a4,a0
    800234ac:	fdc42783          	lw	a5,-36(s0)
    800234b0:	863a                	mv	a2,a4
    800234b2:	85be                	mv	a1,a5
    800234b4:	fb843503          	ld	a0,-72(s0)
    800234b8:	991ff0ef          	jal	ra,80022e48 <vector_set>
        vector_set(vec, min_idx, tmp);
    800234bc:	fd442783          	lw	a5,-44(s0)
    800234c0:	fc843603          	ld	a2,-56(s0)
    800234c4:	85be                	mv	a1,a5
    800234c6:	fb843503          	ld	a0,-72(s0)
    800234ca:	97fff0ef          	jal	ra,80022e48 <vector_set>
    for (i = 0;i < vector_size(vec);i++) {
    800234ce:	fdc42783          	lw	a5,-36(s0)
    800234d2:	2785                	addiw	a5,a5,1
    800234d4:	fcf42e23          	sw	a5,-36(s0)
    800234d8:	fb843503          	ld	a0,-72(s0)
    800234dc:	112000ef          	jal	ra,800235ee <vector_size>
    800234e0:	87aa                	mv	a5,a0
    800234e2:	0007871b          	sext.w	a4,a5
    800234e6:	fdc42783          	lw	a5,-36(s0)
    800234ea:	2781                	sext.w	a5,a5
    800234ec:	f2e7e5e3          	bltu	a5,a4,80023416 <vector_selection_sort+0x18>
    }
}
    800234f0:	0001                	nop
    800234f2:	0001                	nop
    800234f4:	60a6                	ld	ra,72(sp)
    800234f6:	6406                	ld	s0,64(sp)
    800234f8:	74e2                	ld	s1,56(sp)
    800234fa:	6161                	addi	sp,sp,80
    800234fc:	8082                	ret

00000000800234fe <vector_insertion_sort>:

void vector_insertion_sort(Vector *vec, VECTOR_COMPARATOR_PARAM(comp)) {
    800234fe:	715d                	addi	sp,sp,-80
    80023500:	e486                	sd	ra,72(sp)
    80023502:	e0a2                	sd	s0,64(sp)
    80023504:	fc26                	sd	s1,56(sp)
    80023506:	0880                	addi	s0,sp,80
    80023508:	faa43c23          	sd	a0,-72(s0)
    8002350c:	fab43823          	sd	a1,-80(s0)
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    80023510:	4785                	li	a5,1
    80023512:	fcf42e23          	sw	a5,-36(s0)
    80023516:	a84d                	j	800235c8 <vector_insertion_sort+0xca>
        uint32_t j = i;
    80023518:	fdc42783          	lw	a5,-36(s0)
    8002351c:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    80023520:	a8b1                	j	8002357c <vector_insertion_sort+0x7e>
            uint64_t left = vector_get_unchecked(vec, j - 1);
    80023522:	fd842783          	lw	a5,-40(s0)
    80023526:	37fd                	addiw	a5,a5,-1
    80023528:	2781                	sext.w	a5,a5
    8002352a:	85be                	mv	a1,a5
    8002352c:	fb843503          	ld	a0,-72(s0)
    80023530:	9adff0ef          	jal	ra,80022edc <vector_get_unchecked>
    80023534:	fca43823          	sd	a0,-48(s0)
            uint64_t right = vector_get_unchecked(vec, j);
    80023538:	fd842783          	lw	a5,-40(s0)
    8002353c:	85be                	mv	a1,a5
    8002353e:	fb843503          	ld	a0,-72(s0)
    80023542:	99bff0ef          	jal	ra,80022edc <vector_get_unchecked>
    80023546:	fca43423          	sd	a0,-56(s0)

            vector_set(vec, j, left);
    8002354a:	fd842783          	lw	a5,-40(s0)
    8002354e:	fd043603          	ld	a2,-48(s0)
    80023552:	85be                	mv	a1,a5
    80023554:	fb843503          	ld	a0,-72(s0)
    80023558:	8f1ff0ef          	jal	ra,80022e48 <vector_set>
            vector_set(vec, j - 1, right);
    8002355c:	fd842783          	lw	a5,-40(s0)
    80023560:	37fd                	addiw	a5,a5,-1
    80023562:	2781                	sext.w	a5,a5
    80023564:	fc843603          	ld	a2,-56(s0)
    80023568:	85be                	mv	a1,a5
    8002356a:	fb843503          	ld	a0,-72(s0)
    8002356e:	8dbff0ef          	jal	ra,80022e48 <vector_set>

            j -= 1;
    80023572:	fd842783          	lw	a5,-40(s0)
    80023576:	37fd                	addiw	a5,a5,-1
    80023578:	fcf42c23          	sw	a5,-40(s0)
        while (j > 0 && !comp(vector_get_unchecked(vec, j - 1), vector_get_unchecked(vec, j))) {
    8002357c:	fd842783          	lw	a5,-40(s0)
    80023580:	2781                	sext.w	a5,a5
    80023582:	cf95                	beqz	a5,800235be <vector_insertion_sort+0xc0>
    80023584:	fd842783          	lw	a5,-40(s0)
    80023588:	37fd                	addiw	a5,a5,-1
    8002358a:	2781                	sext.w	a5,a5
    8002358c:	85be                	mv	a1,a5
    8002358e:	fb843503          	ld	a0,-72(s0)
    80023592:	94bff0ef          	jal	ra,80022edc <vector_get_unchecked>
    80023596:	84aa                	mv	s1,a0
    80023598:	fd842783          	lw	a5,-40(s0)
    8002359c:	85be                	mv	a1,a5
    8002359e:	fb843503          	ld	a0,-72(s0)
    800235a2:	93bff0ef          	jal	ra,80022edc <vector_get_unchecked>
    800235a6:	87aa                	mv	a5,a0
    800235a8:	fb043703          	ld	a4,-80(s0)
    800235ac:	85be                	mv	a1,a5
    800235ae:	8526                	mv	a0,s1
    800235b0:	9702                	jalr	a4
    800235b2:	87aa                	mv	a5,a0
    800235b4:	0017c793          	xori	a5,a5,1
    800235b8:	0ff7f793          	andi	a5,a5,255
    800235bc:	f3bd                	bnez	a5,80023522 <vector_insertion_sort+0x24>
    for (uint32_t i = 1;i < vector_size(vec);i++) {
    800235be:	fdc42783          	lw	a5,-36(s0)
    800235c2:	2785                	addiw	a5,a5,1
    800235c4:	fcf42e23          	sw	a5,-36(s0)
    800235c8:	fb843503          	ld	a0,-72(s0)
    800235cc:	022000ef          	jal	ra,800235ee <vector_size>
    800235d0:	87aa                	mv	a5,a0
    800235d2:	0007871b          	sext.w	a4,a5
    800235d6:	fdc42783          	lw	a5,-36(s0)
    800235da:	2781                	sext.w	a5,a5
    800235dc:	f2e7eee3          	bltu	a5,a4,80023518 <vector_insertion_sort+0x1a>
        }
    }
}
    800235e0:	0001                	nop
    800235e2:	0001                	nop
    800235e4:	60a6                	ld	ra,72(sp)
    800235e6:	6406                	ld	s0,64(sp)
    800235e8:	74e2                	ld	s1,56(sp)
    800235ea:	6161                	addi	sp,sp,80
    800235ec:	8082                	ret

00000000800235ee <vector_size>:

uint32_t vector_size(Vector *vec) {
    800235ee:	1101                	addi	sp,sp,-32
    800235f0:	ec22                	sd	s0,24(sp)
    800235f2:	1000                	addi	s0,sp,32
    800235f4:	fea43423          	sd	a0,-24(s0)
    return vec->size;
    800235f8:	fe843783          	ld	a5,-24(s0)
    800235fc:	439c                	lw	a5,0(a5)
}
    800235fe:	853e                	mv	a0,a5
    80023600:	6462                	ld	s0,24(sp)
    80023602:	6105                	addi	sp,sp,32
    80023604:	8082                	ret

0000000080023606 <vector_capacity>:

uint32_t vector_capacity(Vector *vec) {
    80023606:	1101                	addi	sp,sp,-32
    80023608:	ec22                	sd	s0,24(sp)
    8002360a:	1000                	addi	s0,sp,32
    8002360c:	fea43423          	sd	a0,-24(s0)
    return vec->capacity;
    80023610:	fe843783          	ld	a5,-24(s0)
    80023614:	43dc                	lw	a5,4(a5)
}
    80023616:	853e                	mv	a0,a5
    80023618:	6462                	ld	s0,24(sp)
    8002361a:	6105                	addi	sp,sp,32
    8002361c:	8082                	ret

000000008002361e <vector_free>:

void vector_free(Vector *vec) {
    8002361e:	1101                	addi	sp,sp,-32
    80023620:	ec06                	sd	ra,24(sp)
    80023622:	e822                	sd	s0,16(sp)
    80023624:	1000                	addi	s0,sp,32
    80023626:	fea43423          	sd	a0,-24(s0)
    g_kfree(vec->values);
    8002362a:	fe843783          	ld	a5,-24(s0)
    8002362e:	679c                	ld	a5,8(a5)
    80023630:	853e                	mv	a0,a5
    80023632:	d35fc0ef          	jal	ra,80020366 <g_kfree>
    vec->size = 0;
    80023636:	fe843783          	ld	a5,-24(s0)
    8002363a:	0007a023          	sw	zero,0(a5)
    vec->capacity = 0;
    8002363e:	fe843783          	ld	a5,-24(s0)
    80023642:	0007a223          	sw	zero,4(a5)
    g_kfree(vec);
    80023646:	fe843503          	ld	a0,-24(s0)
    8002364a:	d1dfc0ef          	jal	ra,80020366 <g_kfree>
}
    8002364e:	0001                	nop
    80023650:	60e2                	ld	ra,24(sp)
    80023652:	6442                	ld	s0,16(sp)
    80023654:	6105                	addi	sp,sp,32
    80023656:	8082                	ret

0000000080023658 <vector_sort_signed_long_comparator_ascending>:

VECTOR_COMPARATOR(vector_sort_signed_long_comparator_ascending) {
    80023658:	1101                	addi	sp,sp,-32
    8002365a:	ec22                	sd	s0,24(sp)
    8002365c:	1000                	addi	s0,sp,32
    8002365e:	fea43423          	sd	a0,-24(s0)
    80023662:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left <= (int64_t)right;
    80023666:	fe843703          	ld	a4,-24(s0)
    8002366a:	fe043783          	ld	a5,-32(s0)
    8002366e:	00e7a7b3          	slt	a5,a5,a4
    80023672:	0017c793          	xori	a5,a5,1
    80023676:	0ff7f793          	andi	a5,a5,255
}
    8002367a:	853e                	mv	a0,a5
    8002367c:	6462                	ld	s0,24(sp)
    8002367e:	6105                	addi	sp,sp,32
    80023680:	8082                	ret

0000000080023682 <vector_sort_signed_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_signed_long_comparator_descending) {
    80023682:	1101                	addi	sp,sp,-32
    80023684:	ec22                	sd	s0,24(sp)
    80023686:	1000                	addi	s0,sp,32
    80023688:	fea43423          	sd	a0,-24(s0)
    8002368c:	feb43023          	sd	a1,-32(s0)
    return (int64_t)left >= (int64_t)right;
    80023690:	fe843703          	ld	a4,-24(s0)
    80023694:	fe043783          	ld	a5,-32(s0)
    80023698:	00f727b3          	slt	a5,a4,a5
    8002369c:	0017c793          	xori	a5,a5,1
    800236a0:	0ff7f793          	andi	a5,a5,255
}
    800236a4:	853e                	mv	a0,a5
    800236a6:	6462                	ld	s0,24(sp)
    800236a8:	6105                	addi	sp,sp,32
    800236aa:	8082                	ret

00000000800236ac <vector_sort_unsigned_long_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_ascending) {
    800236ac:	1101                	addi	sp,sp,-32
    800236ae:	ec22                	sd	s0,24(sp)
    800236b0:	1000                	addi	s0,sp,32
    800236b2:	fea43423          	sd	a0,-24(s0)
    800236b6:	feb43023          	sd	a1,-32(s0)
    return left <= right;
    800236ba:	fe843703          	ld	a4,-24(s0)
    800236be:	fe043783          	ld	a5,-32(s0)
    800236c2:	00e7b7b3          	sltu	a5,a5,a4
    800236c6:	0017c793          	xori	a5,a5,1
    800236ca:	0ff7f793          	andi	a5,a5,255
}
    800236ce:	853e                	mv	a0,a5
    800236d0:	6462                	ld	s0,24(sp)
    800236d2:	6105                	addi	sp,sp,32
    800236d4:	8082                	ret

00000000800236d6 <vector_sort_unsigned_long_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_unsigned_long_comparator_descending) {
    800236d6:	1101                	addi	sp,sp,-32
    800236d8:	ec22                	sd	s0,24(sp)
    800236da:	1000                	addi	s0,sp,32
    800236dc:	fea43423          	sd	a0,-24(s0)
    800236e0:	feb43023          	sd	a1,-32(s0)
    return left >= right;
    800236e4:	fe843703          	ld	a4,-24(s0)
    800236e8:	fe043783          	ld	a5,-32(s0)
    800236ec:	00f737b3          	sltu	a5,a4,a5
    800236f0:	0017c793          	xori	a5,a5,1
    800236f4:	0ff7f793          	andi	a5,a5,255
}
    800236f8:	853e                	mv	a0,a5
    800236fa:	6462                	ld	s0,24(sp)
    800236fc:	6105                	addi	sp,sp,32
    800236fe:	8082                	ret

0000000080023700 <vector_sort_string_comparator_ascending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_ascending) {
    80023700:	1101                	addi	sp,sp,-32
    80023702:	ec06                	sd	ra,24(sp)
    80023704:	e822                	sd	s0,16(sp)
    80023706:	1000                	addi	s0,sp,32
    80023708:	fea43423          	sd	a0,-24(s0)
    8002370c:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) <= 0;
    80023710:	fe843783          	ld	a5,-24(s0)
    80023714:	fe043703          	ld	a4,-32(s0)
    80023718:	85ba                	mv	a1,a4
    8002371a:	853e                	mv	a0,a5
    8002371c:	fb1fe0ef          	jal	ra,800226cc <strcmp>
    80023720:	87aa                	mv	a5,a0
    80023722:	0017a793          	slti	a5,a5,1
    80023726:	0ff7f793          	andi	a5,a5,255
}
    8002372a:	853e                	mv	a0,a5
    8002372c:	60e2                	ld	ra,24(sp)
    8002372e:	6442                	ld	s0,16(sp)
    80023730:	6105                	addi	sp,sp,32
    80023732:	8082                	ret

0000000080023734 <vector_sort_string_comparator_descending>:
VECTOR_COMPARATOR(vector_sort_string_comparator_descending) {
    80023734:	1101                	addi	sp,sp,-32
    80023736:	ec06                	sd	ra,24(sp)
    80023738:	e822                	sd	s0,16(sp)
    8002373a:	1000                	addi	s0,sp,32
    8002373c:	fea43423          	sd	a0,-24(s0)
    80023740:	feb43023          	sd	a1,-32(s0)
    return strcmp((const char *)left, (const char *)right) >= 0;
    80023744:	fe843783          	ld	a5,-24(s0)
    80023748:	fe043703          	ld	a4,-32(s0)
    8002374c:	85ba                	mv	a1,a4
    8002374e:	853e                	mv	a0,a5
    80023750:	f7dfe0ef          	jal	ra,800226cc <strcmp>
    80023754:	87aa                	mv	a5,a0
    80023756:	fff7c793          	not	a5,a5
    8002375a:	01f7d79b          	srliw	a5,a5,0x1f
    8002375e:	0ff7f793          	andi	a5,a5,255
}
    80023762:	853e                	mv	a0,a5
    80023764:	60e2                	ld	ra,24(sp)
    80023766:	6442                	ld	s0,16(sp)
    80023768:	6105                	addi	sp,sp,32
    8002376a:	8082                	ret
