
cosc562.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000080010000 <_memory_start>:
    80010000:	fe22                	sd	s0,312(sp)
    80010002:	f1ca                	sd	s2,224(sp)
    80010004:	0bee                	slli	s7,s7,0x1b
    80010006:	dead                	beqz	a3,8000ff80 <i+0x8000ff60>
    80010008:	3c50                	fld	fa2,184(s0)
    8001000a:	8001                	c.srli64	s0
	...

0000000080010102 <copy_from_user>:

unsigned long copy_from_user(void *dst, 
                        const struct page_table *from_table, 
                        const void *from, 
                        unsigned long size)
{
    80010102:	7139                	addi	sp,sp,-64
    80010104:	fc22                	sd	s0,56(sp)
    80010106:	0080                	addi	s0,sp,64
    80010108:	fca43c23          	sd	a0,-40(s0)
    8001010c:	fcb43823          	sd	a1,-48(s0)
    80010110:	fcc43423          	sd	a2,-56(s0)
    80010114:	fcd43023          	sd	a3,-64(s0)
    (void)dst;
    (void)from_table;
    (void)from;
    (void)size;

    unsigned long bytes_copied = 0;
    80010118:	fe043423          	sd	zero,-24(s0)

    return bytes_copied;
    8001011c:	fe843783          	ld	a5,-24(s0)
}
    80010120:	853e                	mv	a0,a5
    80010122:	7462                	ld	s0,56(sp)
    80010124:	6121                	addi	sp,sp,64
    80010126:	8082                	ret

0000000080010128 <copy_to_user>:

unsigned long copy_to_user(void *to, 
                      const struct page_table *to_table, 
                      const void *src, 
                      unsigned long size)
{
    80010128:	7139                	addi	sp,sp,-64
    8001012a:	fc22                	sd	s0,56(sp)
    8001012c:	0080                	addi	s0,sp,64
    8001012e:	fca43c23          	sd	a0,-40(s0)
    80010132:	fcb43823          	sd	a1,-48(s0)
    80010136:	fcc43423          	sd	a2,-56(s0)
    8001013a:	fcd43023          	sd	a3,-64(s0)
    (void)to;
    (void)to_table;
    (void)src;
    (void)size;

    unsigned long bytes_copied = 0;
    8001013e:	fe043423          	sd	zero,-24(s0)

    return bytes_copied;
    80010142:	fe843783          	ld	a5,-24(s0)
    80010146:	853e                	mv	a0,a5
    80010148:	7462                	ld	s0,56(sp)
    8001014a:	6121                	addi	sp,sp,64
    8001014c:	8082                	ret

000000008001014e <syscall_exit>:
    (void)hart;         \
    (void)epc;          \
    (void)scratch

SYSCALL(exit)
{
    8001014e:	7179                	addi	sp,sp,-48
    80010150:	f422                	sd	s0,40(sp)
    80010152:	1800                	addi	s0,sp,48
    80010154:	87aa                	mv	a5,a0
    80010156:	feb43023          	sd	a1,-32(s0)
    8001015a:	fcc43c23          	sd	a2,-40(s0)
    8001015e:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Kill the current process on this HART and schedule the next
    // one.
}
    80010162:	0001                	nop
    80010164:	7422                	ld	s0,40(sp)
    80010166:	6145                	addi	sp,sp,48
    80010168:	8082                	ret

000000008001016a <syscall_putchar>:

SYSCALL(putchar)
{
    8001016a:	7179                	addi	sp,sp,-48
    8001016c:	f406                	sd	ra,40(sp)
    8001016e:	f022                	sd	s0,32(sp)
    80010170:	1800                	addi	s0,sp,48
    80010172:	87aa                	mv	a5,a0
    80010174:	feb43023          	sd	a1,-32(s0)
    80010178:	fcc43c23          	sd	a2,-40(s0)
    8001017c:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    sbi_putchar(XREG(A0));
    80010180:	fd843783          	ld	a5,-40(s0)
    80010184:	05078793          	addi	a5,a5,80
    80010188:	639c                	ld	a5,0(a5)
    8001018a:	0ff7f793          	andi	a5,a5,255
    8001018e:	853e                	mv	a0,a5
    80010190:	49a030ef          	jal	ra,8001362a <sbi_putchar>
}
    80010194:	0001                	nop
    80010196:	70a2                	ld	ra,40(sp)
    80010198:	7402                	ld	s0,32(sp)
    8001019a:	6145                	addi	sp,sp,48
    8001019c:	8082                	ret

000000008001019e <syscall_getchar>:

SYSCALL(getchar)
{
    8001019e:	7179                	addi	sp,sp,-48
    800101a0:	f406                	sd	ra,40(sp)
    800101a2:	f022                	sd	s0,32(sp)
    800101a4:	1800                	addi	s0,sp,48
    800101a6:	87aa                	mv	a5,a0
    800101a8:	feb43023          	sd	a1,-32(s0)
    800101ac:	fcc43c23          	sd	a2,-40(s0)
    800101b0:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    XREG(A0) = sbi_getchar();
    800101b4:	498030ef          	jal	ra,8001364c <sbi_getchar>
    800101b8:	87aa                	mv	a5,a0
    800101ba:	873e                	mv	a4,a5
    800101bc:	fd843783          	ld	a5,-40(s0)
    800101c0:	05078793          	addi	a5,a5,80
    800101c4:	e398                	sd	a4,0(a5)
}
    800101c6:	0001                	nop
    800101c8:	70a2                	ld	ra,40(sp)
    800101ca:	7402                	ld	s0,32(sp)
    800101cc:	6145                	addi	sp,sp,48
    800101ce:	8082                	ret

00000000800101d0 <syscall_yield>:

SYSCALL(yield)
{
    800101d0:	7179                	addi	sp,sp,-48
    800101d2:	f422                	sd	s0,40(sp)
    800101d4:	1800                	addi	s0,sp,48
    800101d6:	87aa                	mv	a5,a0
    800101d8:	feb43023          	sd	a1,-32(s0)
    800101dc:	fcc43c23          	sd	a2,-40(s0)
    800101e0:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // sched_invoke(hart);
}
    800101e4:	0001                	nop
    800101e6:	7422                	ld	s0,40(sp)
    800101e8:	6145                	addi	sp,sp,48
    800101ea:	8082                	ret

00000000800101ec <syscall_sleep>:

SYSCALL(sleep)
{
    800101ec:	7179                	addi	sp,sp,-48
    800101ee:	f422                	sd	s0,40(sp)
    800101f0:	1800                	addi	s0,sp,48
    800101f2:	87aa                	mv	a5,a0
    800101f4:	feb43023          	sd	a1,-32(s0)
    800101f8:	fcc43c23          	sd	a2,-40(s0)
    800101fc:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    // Sleep the process. VIRT_TIMER_FREQ is 10MHz, divided by 1000, we get 10KHz
    //     p->sleep_until = sbi_get_time() + XREG(A0) * VIRT_TIMER_FREQ / 1000;
    //     p->state = PS_SLEEPING;
}
    80010200:	0001                	nop
    80010202:	7422                	ld	s0,40(sp)
    80010204:	6145                	addi	sp,sp,48
    80010206:	8082                	ret

0000000080010208 <syscall_events>:

SYSCALL(events)
{
    80010208:	7179                	addi	sp,sp,-48
    8001020a:	f422                	sd	s0,40(sp)
    8001020c:	1800                	addi	s0,sp,48
    8001020e:	87aa                	mv	a5,a0
    80010210:	feb43023          	sd	a1,-32(s0)
    80010214:	fcc43c23          	sd	a2,-40(s0)
    80010218:	fef42623          	sw	a5,-20(s0)
    SYSCALL_ENTER();
    
}
    8001021c:	0001                	nop
    8001021e:	7422                	ld	s0,40(sp)
    80010220:	6145                	addi	sp,sp,48
    80010222:	8082                	ret

0000000080010224 <syscall_handle>:

static const int NUM_SYSCALLS = sizeof(SYSCALLS) / sizeof(SYSCALLS[0]);

// We get here from the trap.c if this is an ECALL from U-MODE
void syscall_handle(int hart, uint64_t epc, int64_t *scratch)
{
    80010224:	7179                	addi	sp,sp,-48
    80010226:	f406                	sd	ra,40(sp)
    80010228:	f022                	sd	s0,32(sp)
    8001022a:	1800                	addi	s0,sp,48
    8001022c:	87aa                	mv	a5,a0
    8001022e:	feb43023          	sd	a1,-32(s0)
    80010232:	fcc43c23          	sd	a2,-40(s0)
    80010236:	fef42623          	sw	a5,-20(s0)
    // Sched invoke will save sepc, so we want it to resume
    // 4 bytes ahead, which will be the next instruction.
    CSR_WRITE("sepc", epc + 4);
    8001023a:	fe043783          	ld	a5,-32(s0)
    8001023e:	0791                	addi	a5,a5,4
    80010240:	14179073          	csrw	sepc,a5

    if (XREG(A7) >= NUM_SYSCALLS || SYSCALLS[XREG(A7)] == NULL) {
    80010244:	fd843783          	ld	a5,-40(s0)
    80010248:	08878793          	addi	a5,a5,136
    8001024c:	639c                	ld	a5,0(a5)
    8001024e:	4719                	li	a4,6
    80010250:	00e7df63          	bge	a5,a4,8001026e <syscall_handle+0x4a>
    80010254:	fd843783          	ld	a5,-40(s0)
    80010258:	08878793          	addi	a5,a5,136
    8001025c:	639c                	ld	a5,0(a5)
    8001025e:	00007717          	auipc	a4,0x7
    80010262:	da270713          	addi	a4,a4,-606 # 80017000 <SYSCALLS>
    80010266:	078e                	slli	a5,a5,0x3
    80010268:	97ba                	add	a5,a5,a4
    8001026a:	639c                	ld	a5,0(a5)
    8001026c:	eb81                	bnez	a5,8001027c <syscall_handle+0x58>
        // Invalid syscall
        XREG(A0) = -EINVAL;
    8001026e:	fd843783          	ld	a5,-40(s0)
    80010272:	05078793          	addi	a5,a5,80
    80010276:	5729                	li	a4,-22
    80010278:	e398                	sd	a4,0(a5)
    8001027a:	a035                	j	800102a6 <syscall_handle+0x82>
    }
    else {
        SYSCALL_EXEC(XREG(A7));
    8001027c:	fd843783          	ld	a5,-40(s0)
    80010280:	08878793          	addi	a5,a5,136
    80010284:	639c                	ld	a5,0(a5)
    80010286:	00007717          	auipc	a4,0x7
    8001028a:	d7a70713          	addi	a4,a4,-646 # 80017000 <SYSCALLS>
    8001028e:	078e                	slli	a5,a5,0x3
    80010290:	97ba                	add	a5,a5,a4
    80010292:	6398                	ld	a4,0(a5)
    80010294:	fec42783          	lw	a5,-20(s0)
    80010298:	fd843603          	ld	a2,-40(s0)
    8001029c:	fe043583          	ld	a1,-32(s0)
    800102a0:	853e                	mv	a0,a5
    800102a2:	9702                	jalr	a4
    }
}
    800102a4:	0001                	nop
    800102a6:	0001                	nop
    800102a8:	70a2                	ld	ra,40(sp)
    800102aa:	7402                	ld	s0,32(sp)
    800102ac:	6145                	addi	sp,sp,48
    800102ae:	8082                	ret

00000000800102b0 <_putchar>:
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

#include "sbi.h"
void _putchar(char c) { sbi_putchar(c); }
    800102b0:	1101                	addi	sp,sp,-32
    800102b2:	ec06                	sd	ra,24(sp)
    800102b4:	e822                	sd	s0,16(sp)
    800102b6:	1000                	addi	s0,sp,32
    800102b8:	87aa                	mv	a5,a0
    800102ba:	fef407a3          	sb	a5,-17(s0)
    800102be:	fef44783          	lbu	a5,-17(s0)
    800102c2:	853e                	mv	a0,a5
    800102c4:	366030ef          	jal	ra,8001362a <sbi_putchar>
    800102c8:	0001                	nop
    800102ca:	60e2                	ld	ra,24(sp)
    800102cc:	6442                	ld	s0,16(sp)
    800102ce:	6105                	addi	sp,sp,32
    800102d0:	8082                	ret

00000000800102d2 <_out_buffer>:
} out_fct_wrap_type;

// internal buffer output
static inline void _out_buffer(char character, void *buffer, size_t idx,
                               size_t maxlen)
{
    800102d2:	7179                	addi	sp,sp,-48
    800102d4:	f422                	sd	s0,40(sp)
    800102d6:	1800                	addi	s0,sp,48
    800102d8:	87aa                	mv	a5,a0
    800102da:	feb43023          	sd	a1,-32(s0)
    800102de:	fcc43c23          	sd	a2,-40(s0)
    800102e2:	fcd43823          	sd	a3,-48(s0)
    800102e6:	fef407a3          	sb	a5,-17(s0)
    if (idx < maxlen) {
    800102ea:	fd843703          	ld	a4,-40(s0)
    800102ee:	fd043783          	ld	a5,-48(s0)
    800102f2:	00f77b63          	bgeu	a4,a5,80010308 <_out_buffer+0x36>
        ((char *)buffer)[idx] = character;
    800102f6:	fe043703          	ld	a4,-32(s0)
    800102fa:	fd843783          	ld	a5,-40(s0)
    800102fe:	97ba                	add	a5,a5,a4
    80010300:	fef44703          	lbu	a4,-17(s0)
    80010304:	00e78023          	sb	a4,0(a5)
    }
}
    80010308:	0001                	nop
    8001030a:	7422                	ld	s0,40(sp)
    8001030c:	6145                	addi	sp,sp,48
    8001030e:	8082                	ret

0000000080010310 <_out_null>:

// internal null output
static inline void _out_null(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    80010310:	7179                	addi	sp,sp,-48
    80010312:	f422                	sd	s0,40(sp)
    80010314:	1800                	addi	s0,sp,48
    80010316:	87aa                	mv	a5,a0
    80010318:	feb43023          	sd	a1,-32(s0)
    8001031c:	fcc43c23          	sd	a2,-40(s0)
    80010320:	fcd43823          	sd	a3,-48(s0)
    80010324:	fef407a3          	sb	a5,-17(s0)
    (void)character;
    (void)buffer;
    (void)idx;
    (void)maxlen;
}
    80010328:	0001                	nop
    8001032a:	7422                	ld	s0,40(sp)
    8001032c:	6145                	addi	sp,sp,48
    8001032e:	8082                	ret

0000000080010330 <_out_char>:

// internal _putchar wrapper
static inline void _out_char(char character, void *buffer, size_t idx,
                             size_t maxlen)
{
    80010330:	7179                	addi	sp,sp,-48
    80010332:	f406                	sd	ra,40(sp)
    80010334:	f022                	sd	s0,32(sp)
    80010336:	1800                	addi	s0,sp,48
    80010338:	87aa                	mv	a5,a0
    8001033a:	feb43023          	sd	a1,-32(s0)
    8001033e:	fcc43c23          	sd	a2,-40(s0)
    80010342:	fcd43823          	sd	a3,-48(s0)
    80010346:	fef407a3          	sb	a5,-17(s0)
    (void)buffer;
    (void)idx;
    (void)maxlen;
    if (character) {
    8001034a:	fef44783          	lbu	a5,-17(s0)
    8001034e:	0ff7f793          	andi	a5,a5,255
    80010352:	c791                	beqz	a5,8001035e <_out_char+0x2e>
        _putchar(character);
    80010354:	fef44783          	lbu	a5,-17(s0)
    80010358:	853e                	mv	a0,a5
    8001035a:	f57ff0ef          	jal	ra,800102b0 <_putchar>
    }
}
    8001035e:	0001                	nop
    80010360:	70a2                	ld	ra,40(sp)
    80010362:	7402                	ld	s0,32(sp)
    80010364:	6145                	addi	sp,sp,48
    80010366:	8082                	ret

0000000080010368 <_out_fct>:

// internal output function wrapper
static inline void _out_fct(char character, void *buffer, size_t idx,
                            size_t maxlen)
{
    80010368:	7179                	addi	sp,sp,-48
    8001036a:	f406                	sd	ra,40(sp)
    8001036c:	f022                	sd	s0,32(sp)
    8001036e:	1800                	addi	s0,sp,48
    80010370:	87aa                	mv	a5,a0
    80010372:	feb43023          	sd	a1,-32(s0)
    80010376:	fcc43c23          	sd	a2,-40(s0)
    8001037a:	fcd43823          	sd	a3,-48(s0)
    8001037e:	fef407a3          	sb	a5,-17(s0)
    (void)idx;
    (void)maxlen;
    if (character) {
    80010382:	fef44783          	lbu	a5,-17(s0)
    80010386:	0ff7f793          	andi	a5,a5,255
    8001038a:	cf81                	beqz	a5,800103a2 <_out_fct+0x3a>
        // buffer is the output fct pointer
        ((out_fct_wrap_type *)buffer)
            ->fct(character, ((out_fct_wrap_type *)buffer)->arg);
    8001038c:	fe043783          	ld	a5,-32(s0)
    80010390:	6394                	ld	a3,0(a5)
        ((out_fct_wrap_type *)buffer)
    80010392:	fe043783          	ld	a5,-32(s0)
    80010396:	6798                	ld	a4,8(a5)
    80010398:	fef44783          	lbu	a5,-17(s0)
    8001039c:	85ba                	mv	a1,a4
    8001039e:	853e                	mv	a0,a5
    800103a0:	9682                	jalr	a3
    }
}
    800103a2:	0001                	nop
    800103a4:	70a2                	ld	ra,40(sp)
    800103a6:	7402                	ld	s0,32(sp)
    800103a8:	6145                	addi	sp,sp,48
    800103aa:	8082                	ret

00000000800103ac <_strnlen_s>:

// internal secure strlen
// \return The length of the string (excluding the terminating 0) limited by
// 'maxsize'
static inline unsigned int _strnlen_s(const char *str, size_t maxsize)
{
    800103ac:	7179                	addi	sp,sp,-48
    800103ae:	f422                	sd	s0,40(sp)
    800103b0:	1800                	addi	s0,sp,48
    800103b2:	fca43c23          	sd	a0,-40(s0)
    800103b6:	fcb43823          	sd	a1,-48(s0)
    const char *s;
    for (s = str; *s && maxsize--; ++s)
    800103ba:	fd843783          	ld	a5,-40(s0)
    800103be:	fef43423          	sd	a5,-24(s0)
    800103c2:	a031                	j	800103ce <_strnlen_s+0x22>
    800103c4:	fe843783          	ld	a5,-24(s0)
    800103c8:	0785                	addi	a5,a5,1
    800103ca:	fef43423          	sd	a5,-24(s0)
    800103ce:	fe843783          	ld	a5,-24(s0)
    800103d2:	0007c783          	lbu	a5,0(a5)
    800103d6:	cb81                	beqz	a5,800103e6 <_strnlen_s+0x3a>
    800103d8:	fd043783          	ld	a5,-48(s0)
    800103dc:	fff78713          	addi	a4,a5,-1
    800103e0:	fce43823          	sd	a4,-48(s0)
    800103e4:	f3e5                	bnez	a5,800103c4 <_strnlen_s+0x18>
        ;
    return (unsigned int)(s - str);
    800103e6:	fe843703          	ld	a4,-24(s0)
    800103ea:	fd843783          	ld	a5,-40(s0)
    800103ee:	40f707b3          	sub	a5,a4,a5
    800103f2:	2781                	sext.w	a5,a5
}
    800103f4:	853e                	mv	a0,a5
    800103f6:	7422                	ld	s0,40(sp)
    800103f8:	6145                	addi	sp,sp,48
    800103fa:	8082                	ret

00000000800103fc <_is_digit>:

// internal test if char is a digit (0-9)
// \return true if char is a digit
static inline bool _is_digit(char ch) { return (ch >= '0') && (ch <= '9'); }
    800103fc:	1101                	addi	sp,sp,-32
    800103fe:	ec22                	sd	s0,24(sp)
    80010400:	1000                	addi	s0,sp,32
    80010402:	87aa                	mv	a5,a0
    80010404:	fef407a3          	sb	a5,-17(s0)
    80010408:	fef44783          	lbu	a5,-17(s0)
    8001040c:	0ff7f713          	andi	a4,a5,255
    80010410:	02f00793          	li	a5,47
    80010414:	00e7fc63          	bgeu	a5,a4,8001042c <_is_digit+0x30>
    80010418:	fef44783          	lbu	a5,-17(s0)
    8001041c:	0ff7f713          	andi	a4,a5,255
    80010420:	03900793          	li	a5,57
    80010424:	00e7e463          	bltu	a5,a4,8001042c <_is_digit+0x30>
    80010428:	4785                	li	a5,1
    8001042a:	a011                	j	8001042e <_is_digit+0x32>
    8001042c:	4781                	li	a5,0
    8001042e:	8b85                	andi	a5,a5,1
    80010430:	0ff7f793          	andi	a5,a5,255
    80010434:	853e                	mv	a0,a5
    80010436:	6462                	ld	s0,24(sp)
    80010438:	6105                	addi	sp,sp,32
    8001043a:	8082                	ret

000000008001043c <_atoi>:

// internal ASCII string to unsigned int conversion
static unsigned int _atoi(const char **str)
{
    8001043c:	7179                	addi	sp,sp,-48
    8001043e:	f406                	sd	ra,40(sp)
    80010440:	f022                	sd	s0,32(sp)
    80010442:	1800                	addi	s0,sp,48
    80010444:	fca43c23          	sd	a0,-40(s0)
    unsigned int i = 0U;
    80010448:	fe042623          	sw	zero,-20(s0)
    while (_is_digit(**str)) {
    8001044c:	a825                	j	80010484 <_atoi+0x48>
        i = i * 10U + (unsigned int)(*((*str)++) - '0');
    8001044e:	fec42703          	lw	a4,-20(s0)
    80010452:	87ba                	mv	a5,a4
    80010454:	0027979b          	slliw	a5,a5,0x2
    80010458:	9fb9                	addw	a5,a5,a4
    8001045a:	0017979b          	slliw	a5,a5,0x1
    8001045e:	0007871b          	sext.w	a4,a5
    80010462:	fd843783          	ld	a5,-40(s0)
    80010466:	639c                	ld	a5,0(a5)
    80010468:	00178613          	addi	a2,a5,1
    8001046c:	fd843683          	ld	a3,-40(s0)
    80010470:	e290                	sd	a2,0(a3)
    80010472:	0007c783          	lbu	a5,0(a5)
    80010476:	2781                	sext.w	a5,a5
    80010478:	9fb9                	addw	a5,a5,a4
    8001047a:	2781                	sext.w	a5,a5
    8001047c:	fd07879b          	addiw	a5,a5,-48
    80010480:	fef42623          	sw	a5,-20(s0)
    while (_is_digit(**str)) {
    80010484:	fd843783          	ld	a5,-40(s0)
    80010488:	639c                	ld	a5,0(a5)
    8001048a:	0007c783          	lbu	a5,0(a5)
    8001048e:	853e                	mv	a0,a5
    80010490:	f6dff0ef          	jal	ra,800103fc <_is_digit>
    80010494:	87aa                	mv	a5,a0
    80010496:	ffc5                	bnez	a5,8001044e <_atoi+0x12>
    }
    return i;
    80010498:	fec42783          	lw	a5,-20(s0)
}
    8001049c:	853e                	mv	a0,a5
    8001049e:	70a2                	ld	ra,40(sp)
    800104a0:	7402                	ld	s0,32(sp)
    800104a2:	6145                	addi	sp,sp,48
    800104a4:	8082                	ret

00000000800104a6 <_out_rev>:

// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char *buffer, size_t idx,
                       size_t maxlen, const char *buf, size_t len,
                       unsigned int width, unsigned int flags)
{
    800104a6:	711d                	addi	sp,sp,-96
    800104a8:	ec86                	sd	ra,88(sp)
    800104aa:	e8a2                	sd	s0,80(sp)
    800104ac:	1080                	addi	s0,sp,96
    800104ae:	fca43c23          	sd	a0,-40(s0)
    800104b2:	fcb43823          	sd	a1,-48(s0)
    800104b6:	fcc43423          	sd	a2,-56(s0)
    800104ba:	fcd43023          	sd	a3,-64(s0)
    800104be:	fae43c23          	sd	a4,-72(s0)
    800104c2:	faf43823          	sd	a5,-80(s0)
    800104c6:	87c2                	mv	a5,a6
    800104c8:	8746                	mv	a4,a7
    800104ca:	faf42623          	sw	a5,-84(s0)
    800104ce:	87ba                	mv	a5,a4
    800104d0:	faf42423          	sw	a5,-88(s0)
    const size_t start_idx = idx;
    800104d4:	fc843783          	ld	a5,-56(s0)
    800104d8:	fef43023          	sd	a5,-32(s0)

    // pad spaces up to given width
    if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
    800104dc:	fa842783          	lw	a5,-88(s0)
    800104e0:	8b89                	andi	a5,a5,2
    800104e2:	2781                	sext.w	a5,a5
    800104e4:	e3c9                	bnez	a5,80010566 <_out_rev+0xc0>
    800104e6:	fa842783          	lw	a5,-88(s0)
    800104ea:	8b85                	andi	a5,a5,1
    800104ec:	2781                	sext.w	a5,a5
    800104ee:	efa5                	bnez	a5,80010566 <_out_rev+0xc0>
        for (size_t i = len; i < width; i++) {
    800104f0:	fb043783          	ld	a5,-80(s0)
    800104f4:	fef43423          	sd	a5,-24(s0)
    800104f8:	a035                	j	80010524 <_out_rev+0x7e>
            out(' ', buffer, idx++, maxlen);
    800104fa:	fc843783          	ld	a5,-56(s0)
    800104fe:	00178713          	addi	a4,a5,1
    80010502:	fce43423          	sd	a4,-56(s0)
    80010506:	fd843703          	ld	a4,-40(s0)
    8001050a:	fc043683          	ld	a3,-64(s0)
    8001050e:	863e                	mv	a2,a5
    80010510:	fd043583          	ld	a1,-48(s0)
    80010514:	02000513          	li	a0,32
    80010518:	9702                	jalr	a4
        for (size_t i = len; i < width; i++) {
    8001051a:	fe843783          	ld	a5,-24(s0)
    8001051e:	0785                	addi	a5,a5,1
    80010520:	fef43423          	sd	a5,-24(s0)
    80010524:	fac46783          	lwu	a5,-84(s0)
    80010528:	fe843703          	ld	a4,-24(s0)
    8001052c:	fcf767e3          	bltu	a4,a5,800104fa <_out_rev+0x54>
        }
    }

    // reverse string
    while (len) {
    80010530:	a81d                	j	80010566 <_out_rev+0xc0>
        out(buf[--len], buffer, idx++, maxlen);
    80010532:	fb043783          	ld	a5,-80(s0)
    80010536:	17fd                	addi	a5,a5,-1
    80010538:	faf43823          	sd	a5,-80(s0)
    8001053c:	fb843703          	ld	a4,-72(s0)
    80010540:	fb043783          	ld	a5,-80(s0)
    80010544:	97ba                	add	a5,a5,a4
    80010546:	0007c503          	lbu	a0,0(a5)
    8001054a:	fc843783          	ld	a5,-56(s0)
    8001054e:	00178713          	addi	a4,a5,1
    80010552:	fce43423          	sd	a4,-56(s0)
    80010556:	fd843703          	ld	a4,-40(s0)
    8001055a:	fc043683          	ld	a3,-64(s0)
    8001055e:	863e                	mv	a2,a5
    80010560:	fd043583          	ld	a1,-48(s0)
    80010564:	9702                	jalr	a4
    while (len) {
    80010566:	fb043783          	ld	a5,-80(s0)
    8001056a:	f7e1                	bnez	a5,80010532 <_out_rev+0x8c>
    }

    // append pad spaces up to given width
    if (flags & FLAGS_LEFT) {
    8001056c:	fa842783          	lw	a5,-88(s0)
    80010570:	8b89                	andi	a5,a5,2
    80010572:	2781                	sext.w	a5,a5
    80010574:	cb9d                	beqz	a5,800105aa <_out_rev+0x104>
        while (idx - start_idx < width) {
    80010576:	a00d                	j	80010598 <_out_rev+0xf2>
            out(' ', buffer, idx++, maxlen);
    80010578:	fc843783          	ld	a5,-56(s0)
    8001057c:	00178713          	addi	a4,a5,1
    80010580:	fce43423          	sd	a4,-56(s0)
    80010584:	fd843703          	ld	a4,-40(s0)
    80010588:	fc043683          	ld	a3,-64(s0)
    8001058c:	863e                	mv	a2,a5
    8001058e:	fd043583          	ld	a1,-48(s0)
    80010592:	02000513          	li	a0,32
    80010596:	9702                	jalr	a4
        while (idx - start_idx < width) {
    80010598:	fc843703          	ld	a4,-56(s0)
    8001059c:	fe043783          	ld	a5,-32(s0)
    800105a0:	8f1d                	sub	a4,a4,a5
    800105a2:	fac46783          	lwu	a5,-84(s0)
    800105a6:	fcf769e3          	bltu	a4,a5,80010578 <_out_rev+0xd2>
        }
    }

    return idx;
    800105aa:	fc843783          	ld	a5,-56(s0)
}
    800105ae:	853e                	mv	a0,a5
    800105b0:	60e6                	ld	ra,88(sp)
    800105b2:	6446                	ld	s0,80(sp)
    800105b4:	6125                	addi	sp,sp,96
    800105b6:	8082                	ret

00000000800105b8 <_ntoa_format>:
// internal itoa format
static size_t _ntoa_format(out_fct_type out, char *buffer, size_t idx,
                           size_t maxlen, char *buf, size_t len, bool negative,
                           unsigned int base, unsigned int prec,
                           unsigned int width, unsigned int flags)
{
    800105b8:	715d                	addi	sp,sp,-80
    800105ba:	e486                	sd	ra,72(sp)
    800105bc:	e0a2                	sd	s0,64(sp)
    800105be:	0880                	addi	s0,sp,80
    800105c0:	fea43423          	sd	a0,-24(s0)
    800105c4:	feb43023          	sd	a1,-32(s0)
    800105c8:	fcc43c23          	sd	a2,-40(s0)
    800105cc:	fcd43823          	sd	a3,-48(s0)
    800105d0:	fce43423          	sd	a4,-56(s0)
    800105d4:	fcf43023          	sd	a5,-64(s0)
    800105d8:	87c2                	mv	a5,a6
    800105da:	8746                	mv	a4,a7
    800105dc:	faf40fa3          	sb	a5,-65(s0)
    800105e0:	87ba                	mv	a5,a4
    800105e2:	faf42c23          	sw	a5,-72(s0)
    // pad leading zeros
    if (!(flags & FLAGS_LEFT)) {
    800105e6:	481c                	lw	a5,16(s0)
    800105e8:	8b89                	andi	a5,a5,2
    800105ea:	2781                	sext.w	a5,a5
    800105ec:	ebd1                	bnez	a5,80010680 <_ntoa_format+0xc8>
        if (width && (flags & FLAGS_ZEROPAD) &&
    800105ee:	441c                	lw	a5,8(s0)
    800105f0:	2781                	sext.w	a5,a5
    800105f2:	cf9d                	beqz	a5,80010630 <_ntoa_format+0x78>
    800105f4:	481c                	lw	a5,16(s0)
    800105f6:	8b85                	andi	a5,a5,1
    800105f8:	2781                	sext.w	a5,a5
    800105fa:	cb9d                	beqz	a5,80010630 <_ntoa_format+0x78>
    800105fc:	fbf44783          	lbu	a5,-65(s0)
    80010600:	0ff7f793          	andi	a5,a5,255
    80010604:	e789                	bnez	a5,8001060e <_ntoa_format+0x56>
            (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80010606:	481c                	lw	a5,16(s0)
    80010608:	8bb1                	andi	a5,a5,12
    8001060a:	2781                	sext.w	a5,a5
    8001060c:	c395                	beqz	a5,80010630 <_ntoa_format+0x78>
            width--;
    8001060e:	441c                	lw	a5,8(s0)
    80010610:	37fd                	addiw	a5,a5,-1
    80010612:	c41c                	sw	a5,8(s0)
        }
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    80010614:	a831                	j	80010630 <_ntoa_format+0x78>
            buf[len++] = '0';
    80010616:	fc043783          	ld	a5,-64(s0)
    8001061a:	00178713          	addi	a4,a5,1
    8001061e:	fce43023          	sd	a4,-64(s0)
    80010622:	fc843703          	ld	a4,-56(s0)
    80010626:	97ba                	add	a5,a5,a4
    80010628:	03000713          	li	a4,48
    8001062c:	00e78023          	sb	a4,0(a5)
        while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    80010630:	00046783          	lwu	a5,0(s0)
    80010634:	fc043703          	ld	a4,-64(s0)
    80010638:	02f77563          	bgeu	a4,a5,80010662 <_ntoa_format+0xaa>
    8001063c:	fc043703          	ld	a4,-64(s0)
    80010640:	47fd                	li	a5,31
    80010642:	fce7fae3          	bgeu	a5,a4,80010616 <_ntoa_format+0x5e>
        }
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    80010646:	a831                	j	80010662 <_ntoa_format+0xaa>
               (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = '0';
    80010648:	fc043783          	ld	a5,-64(s0)
    8001064c:	00178713          	addi	a4,a5,1
    80010650:	fce43023          	sd	a4,-64(s0)
    80010654:	fc843703          	ld	a4,-56(s0)
    80010658:	97ba                	add	a5,a5,a4
    8001065a:	03000713          	li	a4,48
    8001065e:	00e78023          	sb	a4,0(a5)
        while ((flags & FLAGS_ZEROPAD) && (len < width) &&
    80010662:	481c                	lw	a5,16(s0)
    80010664:	8b85                	andi	a5,a5,1
    80010666:	2781                	sext.w	a5,a5
    80010668:	cf81                	beqz	a5,80010680 <_ntoa_format+0xc8>
    8001066a:	00846783          	lwu	a5,8(s0)
    8001066e:	fc043703          	ld	a4,-64(s0)
    80010672:	00f77763          	bgeu	a4,a5,80010680 <_ntoa_format+0xc8>
    80010676:	fc043703          	ld	a4,-64(s0)
    8001067a:	47fd                	li	a5,31
    8001067c:	fce7f6e3          	bgeu	a5,a4,80010648 <_ntoa_format+0x90>
        }
    }

    // handle hash
    if (flags & FLAGS_HASH) {
    80010680:	481c                	lw	a5,16(s0)
    80010682:	8bc1                	andi	a5,a5,16
    80010684:	2781                	sext.w	a5,a5
    80010686:	12078363          	beqz	a5,800107ac <_ntoa_format+0x1f4>
        if (!(flags & FLAGS_PRECISION) && len &&
    8001068a:	481c                	lw	a5,16(s0)
    8001068c:	4007f793          	andi	a5,a5,1024
    80010690:	2781                	sext.w	a5,a5
    80010692:	e7a1                	bnez	a5,800106da <_ntoa_format+0x122>
    80010694:	fc043783          	ld	a5,-64(s0)
    80010698:	c3a9                	beqz	a5,800106da <_ntoa_format+0x122>
            ((len == prec) || (len == width))) {
    8001069a:	00046783          	lwu	a5,0(s0)
        if (!(flags & FLAGS_PRECISION) && len &&
    8001069e:	fc043703          	ld	a4,-64(s0)
    800106a2:	00f70863          	beq	a4,a5,800106b2 <_ntoa_format+0xfa>
            ((len == prec) || (len == width))) {
    800106a6:	00846783          	lwu	a5,8(s0)
    800106aa:	fc043703          	ld	a4,-64(s0)
    800106ae:	02f71663          	bne	a4,a5,800106da <_ntoa_format+0x122>
            len--;
    800106b2:	fc043783          	ld	a5,-64(s0)
    800106b6:	17fd                	addi	a5,a5,-1
    800106b8:	fcf43023          	sd	a5,-64(s0)
            if (len && (base == 16U)) {
    800106bc:	fc043783          	ld	a5,-64(s0)
    800106c0:	cf89                	beqz	a5,800106da <_ntoa_format+0x122>
    800106c2:	fb842783          	lw	a5,-72(s0)
    800106c6:	0007871b          	sext.w	a4,a5
    800106ca:	47c1                	li	a5,16
    800106cc:	00f71763          	bne	a4,a5,800106da <_ntoa_format+0x122>
                len--;
    800106d0:	fc043783          	ld	a5,-64(s0)
    800106d4:	17fd                	addi	a5,a5,-1
    800106d6:	fcf43023          	sd	a5,-64(s0)
            }
        }
        if ((base == 16U) && !(flags & FLAGS_UPPERCASE) &&
    800106da:	fb842783          	lw	a5,-72(s0)
    800106de:	0007871b          	sext.w	a4,a5
    800106e2:	47c1                	li	a5,16
    800106e4:	02f71a63          	bne	a4,a5,80010718 <_ntoa_format+0x160>
    800106e8:	481c                	lw	a5,16(s0)
    800106ea:	0207f793          	andi	a5,a5,32
    800106ee:	2781                	sext.w	a5,a5
    800106f0:	e785                	bnez	a5,80010718 <_ntoa_format+0x160>
    800106f2:	fc043703          	ld	a4,-64(s0)
    800106f6:	47fd                	li	a5,31
    800106f8:	02e7e063          	bltu	a5,a4,80010718 <_ntoa_format+0x160>
            (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'x';
    800106fc:	fc043783          	ld	a5,-64(s0)
    80010700:	00178713          	addi	a4,a5,1
    80010704:	fce43023          	sd	a4,-64(s0)
    80010708:	fc843703          	ld	a4,-56(s0)
    8001070c:	97ba                	add	a5,a5,a4
    8001070e:	07800713          	li	a4,120
    80010712:	00e78023          	sb	a4,0(a5)
    80010716:	a88d                	j	80010788 <_ntoa_format+0x1d0>
        }
        else if ((base == 16U) && (flags & FLAGS_UPPERCASE) &&
    80010718:	fb842783          	lw	a5,-72(s0)
    8001071c:	0007871b          	sext.w	a4,a5
    80010720:	47c1                	li	a5,16
    80010722:	02f71a63          	bne	a4,a5,80010756 <_ntoa_format+0x19e>
    80010726:	481c                	lw	a5,16(s0)
    80010728:	0207f793          	andi	a5,a5,32
    8001072c:	2781                	sext.w	a5,a5
    8001072e:	c785                	beqz	a5,80010756 <_ntoa_format+0x19e>
    80010730:	fc043703          	ld	a4,-64(s0)
    80010734:	47fd                	li	a5,31
    80010736:	02e7e063          	bltu	a5,a4,80010756 <_ntoa_format+0x19e>
                 (len < PRINTF_NTOA_BUFFER_SIZE)) {
            buf[len++] = 'X';
    8001073a:	fc043783          	ld	a5,-64(s0)
    8001073e:	00178713          	addi	a4,a5,1
    80010742:	fce43023          	sd	a4,-64(s0)
    80010746:	fc843703          	ld	a4,-56(s0)
    8001074a:	97ba                	add	a5,a5,a4
    8001074c:	05800713          	li	a4,88
    80010750:	00e78023          	sb	a4,0(a5)
    80010754:	a815                	j	80010788 <_ntoa_format+0x1d0>
        }
        else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
    80010756:	fb842783          	lw	a5,-72(s0)
    8001075a:	0007871b          	sext.w	a4,a5
    8001075e:	4789                	li	a5,2
    80010760:	02f71463          	bne	a4,a5,80010788 <_ntoa_format+0x1d0>
    80010764:	fc043703          	ld	a4,-64(s0)
    80010768:	47fd                	li	a5,31
    8001076a:	00e7ef63          	bltu	a5,a4,80010788 <_ntoa_format+0x1d0>
            buf[len++] = 'b';
    8001076e:	fc043783          	ld	a5,-64(s0)
    80010772:	00178713          	addi	a4,a5,1
    80010776:	fce43023          	sd	a4,-64(s0)
    8001077a:	fc843703          	ld	a4,-56(s0)
    8001077e:	97ba                	add	a5,a5,a4
    80010780:	06200713          	li	a4,98
    80010784:	00e78023          	sb	a4,0(a5)
        }
        if (len < PRINTF_NTOA_BUFFER_SIZE) {
    80010788:	fc043703          	ld	a4,-64(s0)
    8001078c:	47fd                	li	a5,31
    8001078e:	00e7ef63          	bltu	a5,a4,800107ac <_ntoa_format+0x1f4>
            buf[len++] = '0';
    80010792:	fc043783          	ld	a5,-64(s0)
    80010796:	00178713          	addi	a4,a5,1
    8001079a:	fce43023          	sd	a4,-64(s0)
    8001079e:	fc843703          	ld	a4,-56(s0)
    800107a2:	97ba                	add	a5,a5,a4
    800107a4:	03000713          	li	a4,48
    800107a8:	00e78023          	sb	a4,0(a5)
        }
    }

    if (len < PRINTF_NTOA_BUFFER_SIZE) {
    800107ac:	fc043703          	ld	a4,-64(s0)
    800107b0:	47fd                	li	a5,31
    800107b2:	06e7e863          	bltu	a5,a4,80010822 <_ntoa_format+0x26a>
        if (negative) {
    800107b6:	fbf44783          	lbu	a5,-65(s0)
    800107ba:	0ff7f793          	andi	a5,a5,255
    800107be:	cf99                	beqz	a5,800107dc <_ntoa_format+0x224>
            buf[len++] = '-';
    800107c0:	fc043783          	ld	a5,-64(s0)
    800107c4:	00178713          	addi	a4,a5,1
    800107c8:	fce43023          	sd	a4,-64(s0)
    800107cc:	fc843703          	ld	a4,-56(s0)
    800107d0:	97ba                	add	a5,a5,a4
    800107d2:	02d00713          	li	a4,45
    800107d6:	00e78023          	sb	a4,0(a5)
    800107da:	a0a1                	j	80010822 <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_PLUS) {
    800107dc:	481c                	lw	a5,16(s0)
    800107de:	8b91                	andi	a5,a5,4
    800107e0:	2781                	sext.w	a5,a5
    800107e2:	cf99                	beqz	a5,80010800 <_ntoa_format+0x248>
            buf[len++] = '+';  // ignore the space if the '+' exists
    800107e4:	fc043783          	ld	a5,-64(s0)
    800107e8:	00178713          	addi	a4,a5,1
    800107ec:	fce43023          	sd	a4,-64(s0)
    800107f0:	fc843703          	ld	a4,-56(s0)
    800107f4:	97ba                	add	a5,a5,a4
    800107f6:	02b00713          	li	a4,43
    800107fa:	00e78023          	sb	a4,0(a5)
    800107fe:	a015                	j	80010822 <_ntoa_format+0x26a>
        }
        else if (flags & FLAGS_SPACE) {
    80010800:	481c                	lw	a5,16(s0)
    80010802:	8ba1                	andi	a5,a5,8
    80010804:	2781                	sext.w	a5,a5
    80010806:	cf91                	beqz	a5,80010822 <_ntoa_format+0x26a>
            buf[len++] = ' ';
    80010808:	fc043783          	ld	a5,-64(s0)
    8001080c:	00178713          	addi	a4,a5,1
    80010810:	fce43023          	sd	a4,-64(s0)
    80010814:	fc843703          	ld	a4,-56(s0)
    80010818:	97ba                	add	a5,a5,a4
    8001081a:	02000713          	li	a4,32
    8001081e:	00e78023          	sb	a4,0(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    80010822:	4818                	lw	a4,16(s0)
    80010824:	441c                	lw	a5,8(s0)
    80010826:	88ba                	mv	a7,a4
    80010828:	883e                	mv	a6,a5
    8001082a:	fc043783          	ld	a5,-64(s0)
    8001082e:	fc843703          	ld	a4,-56(s0)
    80010832:	fd043683          	ld	a3,-48(s0)
    80010836:	fd843603          	ld	a2,-40(s0)
    8001083a:	fe043583          	ld	a1,-32(s0)
    8001083e:	fe843503          	ld	a0,-24(s0)
    80010842:	c65ff0ef          	jal	ra,800104a6 <_out_rev>
    80010846:	87aa                	mv	a5,a0
}
    80010848:	853e                	mv	a0,a5
    8001084a:	60a6                	ld	ra,72(sp)
    8001084c:	6406                	ld	s0,64(sp)
    8001084e:	6161                	addi	sp,sp,80
    80010850:	8082                	ret

0000000080010852 <_ntoa_long>:
// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char *buffer, size_t idx,
                         size_t maxlen, unsigned long value, bool negative,
                         unsigned long base, unsigned int prec,
                         unsigned int width, unsigned int flags)
{
    80010852:	7135                	addi	sp,sp,-160
    80010854:	ed06                	sd	ra,152(sp)
    80010856:	e922                	sd	s0,144(sp)
    80010858:	1100                	addi	s0,sp,160
    8001085a:	faa43c23          	sd	a0,-72(s0)
    8001085e:	fab43823          	sd	a1,-80(s0)
    80010862:	fac43423          	sd	a2,-88(s0)
    80010866:	fad43023          	sd	a3,-96(s0)
    8001086a:	f8e43c23          	sd	a4,-104(s0)
    8001086e:	f9043423          	sd	a6,-120(s0)
    80010872:	8746                	mv	a4,a7
    80010874:	f8f40ba3          	sb	a5,-105(s0)
    80010878:	87ba                	mv	a5,a4
    8001087a:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    8001087e:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    80010882:	f9843783          	ld	a5,-104(s0)
    80010886:	e781                	bnez	a5,8001088e <_ntoa_long+0x3c>
        flags &= ~FLAGS_HASH;
    80010888:	441c                	lw	a5,8(s0)
    8001088a:	9bbd                	andi	a5,a5,-17
    8001088c:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    8001088e:	441c                	lw	a5,8(s0)
    80010890:	4007f793          	andi	a5,a5,1024
    80010894:	2781                	sext.w	a5,a5
    80010896:	c781                	beqz	a5,8001089e <_ntoa_long+0x4c>
    80010898:	f9843783          	ld	a5,-104(s0)
    8001089c:	c7c1                	beqz	a5,80010924 <_ntoa_long+0xd2>
        do {
            const char digit = (char)(value % base);
    8001089e:	f9843703          	ld	a4,-104(s0)
    800108a2:	f8843783          	ld	a5,-120(s0)
    800108a6:	02f777b3          	remu	a5,a4,a5
    800108aa:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    800108ae:	fe744783          	lbu	a5,-25(s0)
    800108b2:	0ff7f713          	andi	a4,a5,255
    800108b6:	47a5                	li	a5,9
    800108b8:	00e7e963          	bltu	a5,a4,800108ca <_ntoa_long+0x78>
    800108bc:	fe744783          	lbu	a5,-25(s0)
    800108c0:	0307879b          	addiw	a5,a5,48
    800108c4:	0ff7f793          	andi	a5,a5,255
    800108c8:	a01d                	j	800108ee <_ntoa_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    800108ca:	441c                	lw	a5,8(s0)
    800108cc:	0207f793          	andi	a5,a5,32
    800108d0:	2781                	sext.w	a5,a5
    800108d2:	c781                	beqz	a5,800108da <_ntoa_long+0x88>
    800108d4:	04100793          	li	a5,65
    800108d8:	a019                	j	800108de <_ntoa_long+0x8c>
    800108da:	06100793          	li	a5,97
    800108de:	fe744703          	lbu	a4,-25(s0)
    800108e2:	9fb9                	addw	a5,a5,a4
    800108e4:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    800108e8:	37d9                	addiw	a5,a5,-10
    800108ea:	0ff7f793          	andi	a5,a5,255
    800108ee:	fe843703          	ld	a4,-24(s0)
    800108f2:	00170693          	addi	a3,a4,1
    800108f6:	fed43423          	sd	a3,-24(s0)
    800108fa:	ff040693          	addi	a3,s0,-16
    800108fe:	9736                	add	a4,a4,a3
    80010900:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010904:	f9843703          	ld	a4,-104(s0)
    80010908:	f8843783          	ld	a5,-120(s0)
    8001090c:	02f757b3          	divu	a5,a4,a5
    80010910:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010914:	f9843783          	ld	a5,-104(s0)
    80010918:	c791                	beqz	a5,80010924 <_ntoa_long+0xd2>
    8001091a:	fe843703          	ld	a4,-24(s0)
    8001091e:	47fd                	li	a5,31
    80010920:	f6e7ffe3          	bgeu	a5,a4,8001089e <_ntoa_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010924:	f8843783          	ld	a5,-120(s0)
    80010928:	0007861b          	sext.w	a2,a5
    8001092c:	f9744683          	lbu	a3,-105(s0)
    80010930:	fc040713          	addi	a4,s0,-64
    80010934:	441c                	lw	a5,8(s0)
    80010936:	e83e                	sd	a5,16(sp)
    80010938:	401c                	lw	a5,0(s0)
    8001093a:	e43e                	sd	a5,8(sp)
    8001093c:	f9042783          	lw	a5,-112(s0)
    80010940:	e03e                	sd	a5,0(sp)
    80010942:	88b2                	mv	a7,a2
    80010944:	8836                	mv	a6,a3
    80010946:	fe843783          	ld	a5,-24(s0)
    8001094a:	fa043683          	ld	a3,-96(s0)
    8001094e:	fa843603          	ld	a2,-88(s0)
    80010952:	fb043583          	ld	a1,-80(s0)
    80010956:	fb843503          	ld	a0,-72(s0)
    8001095a:	c5fff0ef          	jal	ra,800105b8 <_ntoa_format>
    8001095e:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010960:	853e                	mv	a0,a5
    80010962:	60ea                	ld	ra,152(sp)
    80010964:	644a                	ld	s0,144(sp)
    80010966:	610d                	addi	sp,sp,160
    80010968:	8082                	ret

000000008001096a <_ntoa_long_long>:
static size_t _ntoa_long_long(out_fct_type out, char *buffer, size_t idx,
                              size_t maxlen, unsigned long long value,
                              bool negative, unsigned long long base,
                              unsigned int prec, unsigned int width,
                              unsigned int flags)
{
    8001096a:	7135                	addi	sp,sp,-160
    8001096c:	ed06                	sd	ra,152(sp)
    8001096e:	e922                	sd	s0,144(sp)
    80010970:	1100                	addi	s0,sp,160
    80010972:	faa43c23          	sd	a0,-72(s0)
    80010976:	fab43823          	sd	a1,-80(s0)
    8001097a:	fac43423          	sd	a2,-88(s0)
    8001097e:	fad43023          	sd	a3,-96(s0)
    80010982:	f8e43c23          	sd	a4,-104(s0)
    80010986:	f9043423          	sd	a6,-120(s0)
    8001098a:	8746                	mv	a4,a7
    8001098c:	f8f40ba3          	sb	a5,-105(s0)
    80010990:	87ba                	mv	a5,a4
    80010992:	f8f42823          	sw	a5,-112(s0)
    char buf[PRINTF_NTOA_BUFFER_SIZE];
    size_t len = 0U;
    80010996:	fe043423          	sd	zero,-24(s0)

    // no hash for 0 values
    if (!value) {
    8001099a:	f9843783          	ld	a5,-104(s0)
    8001099e:	e781                	bnez	a5,800109a6 <_ntoa_long_long+0x3c>
        flags &= ~FLAGS_HASH;
    800109a0:	441c                	lw	a5,8(s0)
    800109a2:	9bbd                	andi	a5,a5,-17
    800109a4:	c41c                	sw	a5,8(s0)
    }

    // write if precision != 0 and value is != 0
    if (!(flags & FLAGS_PRECISION) || value) {
    800109a6:	441c                	lw	a5,8(s0)
    800109a8:	4007f793          	andi	a5,a5,1024
    800109ac:	2781                	sext.w	a5,a5
    800109ae:	c781                	beqz	a5,800109b6 <_ntoa_long_long+0x4c>
    800109b0:	f9843783          	ld	a5,-104(s0)
    800109b4:	c7c1                	beqz	a5,80010a3c <_ntoa_long_long+0xd2>
        do {
            const char digit = (char)(value % base);
    800109b6:	f9843703          	ld	a4,-104(s0)
    800109ba:	f8843783          	ld	a5,-120(s0)
    800109be:	02f777b3          	remu	a5,a4,a5
    800109c2:	fef403a3          	sb	a5,-25(s0)
            buf[len++] =
    800109c6:	fe744783          	lbu	a5,-25(s0)
    800109ca:	0ff7f713          	andi	a4,a5,255
    800109ce:	47a5                	li	a5,9
    800109d0:	00e7e963          	bltu	a5,a4,800109e2 <_ntoa_long_long+0x78>
    800109d4:	fe744783          	lbu	a5,-25(s0)
    800109d8:	0307879b          	addiw	a5,a5,48
    800109dc:	0ff7f793          	andi	a5,a5,255
    800109e0:	a01d                	j	80010a06 <_ntoa_long_long+0x9c>
                digit < 10 ? '0' + digit
                           : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
    800109e2:	441c                	lw	a5,8(s0)
    800109e4:	0207f793          	andi	a5,a5,32
    800109e8:	2781                	sext.w	a5,a5
    800109ea:	c781                	beqz	a5,800109f2 <_ntoa_long_long+0x88>
    800109ec:	04100793          	li	a5,65
    800109f0:	a019                	j	800109f6 <_ntoa_long_long+0x8c>
    800109f2:	06100793          	li	a5,97
    800109f6:	fe744703          	lbu	a4,-25(s0)
    800109fa:	9fb9                	addw	a5,a5,a4
    800109fc:	0ff7f793          	andi	a5,a5,255
            buf[len++] =
    80010a00:	37d9                	addiw	a5,a5,-10
    80010a02:	0ff7f793          	andi	a5,a5,255
    80010a06:	fe843703          	ld	a4,-24(s0)
    80010a0a:	00170693          	addi	a3,a4,1
    80010a0e:	fed43423          	sd	a3,-24(s0)
    80010a12:	ff040693          	addi	a3,s0,-16
    80010a16:	9736                	add	a4,a4,a3
    80010a18:	fcf70823          	sb	a5,-48(a4)
            value /= base;
    80010a1c:	f9843703          	ld	a4,-104(s0)
    80010a20:	f8843783          	ld	a5,-120(s0)
    80010a24:	02f757b3          	divu	a5,a4,a5
    80010a28:	f8f43c23          	sd	a5,-104(s0)
        } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
    80010a2c:	f9843783          	ld	a5,-104(s0)
    80010a30:	c791                	beqz	a5,80010a3c <_ntoa_long_long+0xd2>
    80010a32:	fe843703          	ld	a4,-24(s0)
    80010a36:	47fd                	li	a5,31
    80010a38:	f6e7ffe3          	bgeu	a5,a4,800109b6 <_ntoa_long_long+0x4c>
    }

    return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative,
    80010a3c:	f8843783          	ld	a5,-120(s0)
    80010a40:	0007861b          	sext.w	a2,a5
    80010a44:	f9744683          	lbu	a3,-105(s0)
    80010a48:	fc040713          	addi	a4,s0,-64
    80010a4c:	441c                	lw	a5,8(s0)
    80010a4e:	e83e                	sd	a5,16(sp)
    80010a50:	401c                	lw	a5,0(s0)
    80010a52:	e43e                	sd	a5,8(sp)
    80010a54:	f9042783          	lw	a5,-112(s0)
    80010a58:	e03e                	sd	a5,0(sp)
    80010a5a:	88b2                	mv	a7,a2
    80010a5c:	8836                	mv	a6,a3
    80010a5e:	fe843783          	ld	a5,-24(s0)
    80010a62:	fa043683          	ld	a3,-96(s0)
    80010a66:	fa843603          	ld	a2,-88(s0)
    80010a6a:	fb043583          	ld	a1,-80(s0)
    80010a6e:	fb843503          	ld	a0,-72(s0)
    80010a72:	b47ff0ef          	jal	ra,800105b8 <_ntoa_format>
    80010a76:	87aa                	mv	a5,a0
                        (unsigned int)base, prec, width, flags);
}
    80010a78:	853e                	mv	a0,a5
    80010a7a:	60ea                	ld	ra,152(sp)
    80010a7c:	644a                	ld	s0,144(sp)
    80010a7e:	610d                	addi	sp,sp,160
    80010a80:	8082                	ret

0000000080010a82 <_ftoa>:

// internal ftoa for fixed decimal floating point
static size_t _ftoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80010a82:	7135                	addi	sp,sp,-160
    80010a84:	ed06                	sd	ra,152(sp)
    80010a86:	e922                	sd	s0,144(sp)
    80010a88:	1100                	addi	s0,sp,160
    80010a8a:	f8a43c23          	sd	a0,-104(s0)
    80010a8e:	f8b43823          	sd	a1,-112(s0)
    80010a92:	f8c43423          	sd	a2,-120(s0)
    80010a96:	f8d43023          	sd	a3,-128(s0)
    80010a9a:	f6a43c27          	fsd	fa0,-136(s0)
    80010a9e:	863a                	mv	a2,a4
    80010aa0:	86be                	mv	a3,a5
    80010aa2:	8742                	mv	a4,a6
    80010aa4:	87b2                	mv	a5,a2
    80010aa6:	f6f42a23          	sw	a5,-140(s0)
    80010aaa:	87b6                	mv	a5,a3
    80010aac:	f6f42823          	sw	a5,-144(s0)
    80010ab0:	87ba                	mv	a5,a4
    80010ab2:	f6f42623          	sw	a5,-148(s0)
    char buf[PRINTF_FTOA_BUFFER_SIZE];
    size_t len                  = 0U;
    80010ab6:	fe043423          	sd	zero,-24(s0)
    double diff                 = 0.0;
    80010aba:	fc043423          	sd	zero,-56(s0)
    static const double pow10[] = {1,         10,        100,     1000,
                                   10000,     100000,    1000000, 10000000,
                                   100000000, 1000000000};

    // test for special values
    if (value != value)
    80010abe:	f7843707          	fld	fa4,-136(s0)
    80010ac2:	f7843787          	fld	fa5,-136(s0)
    80010ac6:	a2f727d3          	feq.d	a5,fa4,fa5
    80010aca:	eb85                	bnez	a5,80010afa <_ftoa+0x78>
        return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
    80010acc:	f6c42703          	lw	a4,-148(s0)
    80010ad0:	f7042783          	lw	a5,-144(s0)
    80010ad4:	88ba                	mv	a7,a4
    80010ad6:	883e                	mv	a6,a5
    80010ad8:	478d                	li	a5,3
    80010ada:	00006717          	auipc	a4,0x6
    80010ade:	55670713          	addi	a4,a4,1366 # 80017030 <SYSCALLS+0x30>
    80010ae2:	f8043683          	ld	a3,-128(s0)
    80010ae6:	f8843603          	ld	a2,-120(s0)
    80010aea:	f9043583          	ld	a1,-112(s0)
    80010aee:	f9843503          	ld	a0,-104(s0)
    80010af2:	9b5ff0ef          	jal	ra,800104a6 <_out_rev>
    80010af6:	87aa                	mv	a5,a0
    80010af8:	a1f1                	j	80010fc4 <_ftoa+0x542>
    if (value < -DBL_MAX)
    80010afa:	f7843707          	fld	fa4,-136(s0)
    80010afe:	00006797          	auipc	a5,0x6
    80010b02:	78278793          	addi	a5,a5,1922 # 80017280 <pow10.0+0x50>
    80010b06:	239c                	fld	fa5,0(a5)
    80010b08:	a2f717d3          	flt.d	a5,fa4,fa5
    80010b0c:	cb85                	beqz	a5,80010b3c <_ftoa+0xba>
        return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
    80010b0e:	f6c42703          	lw	a4,-148(s0)
    80010b12:	f7042783          	lw	a5,-144(s0)
    80010b16:	88ba                	mv	a7,a4
    80010b18:	883e                	mv	a6,a5
    80010b1a:	4791                	li	a5,4
    80010b1c:	00006717          	auipc	a4,0x6
    80010b20:	51c70713          	addi	a4,a4,1308 # 80017038 <SYSCALLS+0x38>
    80010b24:	f8043683          	ld	a3,-128(s0)
    80010b28:	f8843603          	ld	a2,-120(s0)
    80010b2c:	f9043583          	ld	a1,-112(s0)
    80010b30:	f9843503          	ld	a0,-104(s0)
    80010b34:	973ff0ef          	jal	ra,800104a6 <_out_rev>
    80010b38:	87aa                	mv	a5,a0
    80010b3a:	a169                	j	80010fc4 <_ftoa+0x542>
    if (value > DBL_MAX)
    80010b3c:	f7843707          	fld	fa4,-136(s0)
    80010b40:	00006797          	auipc	a5,0x6
    80010b44:	74878793          	addi	a5,a5,1864 # 80017288 <pow10.0+0x58>
    80010b48:	239c                	fld	fa5,0(a5)
    80010b4a:	a2e797d3          	flt.d	a5,fa5,fa4
    80010b4e:	cba9                	beqz	a5,80010ba0 <_ftoa+0x11e>
        return _out_rev(out, buffer, idx, maxlen,
                        (flags & FLAGS_PLUS) ? "fni+" : "fni",
    80010b50:	f6c42783          	lw	a5,-148(s0)
    80010b54:	8b91                	andi	a5,a5,4
    80010b56:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010b58:	c791                	beqz	a5,80010b64 <_ftoa+0xe2>
    80010b5a:	00006717          	auipc	a4,0x6
    80010b5e:	4e670713          	addi	a4,a4,1254 # 80017040 <SYSCALLS+0x40>
    80010b62:	a029                	j	80010b6c <_ftoa+0xea>
    80010b64:	00006717          	auipc	a4,0x6
    80010b68:	4e470713          	addi	a4,a4,1252 # 80017048 <SYSCALLS+0x48>
                        (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
    80010b6c:	f6c42783          	lw	a5,-148(s0)
    80010b70:	8b91                	andi	a5,a5,4
    80010b72:	2781                	sext.w	a5,a5
        return _out_rev(out, buffer, idx, maxlen,
    80010b74:	c399                	beqz	a5,80010b7a <_ftoa+0xf8>
    80010b76:	4791                	li	a5,4
    80010b78:	a011                	j	80010b7c <_ftoa+0xfa>
    80010b7a:	478d                	li	a5,3
    80010b7c:	f6c42603          	lw	a2,-148(s0)
    80010b80:	f7042683          	lw	a3,-144(s0)
    80010b84:	88b2                	mv	a7,a2
    80010b86:	8836                	mv	a6,a3
    80010b88:	f8043683          	ld	a3,-128(s0)
    80010b8c:	f8843603          	ld	a2,-120(s0)
    80010b90:	f9043583          	ld	a1,-112(s0)
    80010b94:	f9843503          	ld	a0,-104(s0)
    80010b98:	90fff0ef          	jal	ra,800104a6 <_out_rev>
    80010b9c:	87aa                	mv	a5,a0
    80010b9e:	a11d                	j	80010fc4 <_ftoa+0x542>

    // test for very large values
    // standard printf behavior is to print EVERY whole number digit -- which
    // could be 100s of characters overflowing your buffers == bad
    if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
    80010ba0:	f7843707          	fld	fa4,-136(s0)
    80010ba4:	00006797          	auipc	a5,0x6
    80010ba8:	6ec78793          	addi	a5,a5,1772 # 80017290 <pow10.0+0x60>
    80010bac:	239c                	fld	fa5,0(a5)
    80010bae:	a2e797d3          	flt.d	a5,fa5,fa4
    80010bb2:	eb99                	bnez	a5,80010bc8 <_ftoa+0x146>
    80010bb4:	f7843707          	fld	fa4,-136(s0)
    80010bb8:	00006797          	auipc	a5,0x6
    80010bbc:	6e078793          	addi	a5,a5,1760 # 80017298 <pow10.0+0x68>
    80010bc0:	239c                	fld	fa5,0(a5)
    80010bc2:	a2f717d3          	flt.d	a5,fa4,fa5
    80010bc6:	c795                	beqz	a5,80010bf2 <_ftoa+0x170>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
        return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80010bc8:	f6c42683          	lw	a3,-148(s0)
    80010bcc:	f7042783          	lw	a5,-144(s0)
    80010bd0:	f7442703          	lw	a4,-140(s0)
    80010bd4:	8836                	mv	a6,a3
    80010bd6:	f7843507          	fld	fa0,-136(s0)
    80010bda:	f8043683          	ld	a3,-128(s0)
    80010bde:	f8843603          	ld	a2,-120(s0)
    80010be2:	f9043583          	ld	a1,-112(s0)
    80010be6:	f9843503          	ld	a0,-104(s0)
    80010bea:	3e4000ef          	jal	ra,80010fce <_etoa>
    80010bee:	87aa                	mv	a5,a0
    80010bf0:	aed1                	j	80010fc4 <_ftoa+0x542>
        return 0U;
#endif
    }

    // test for negative
    bool negative = false;
    80010bf2:	fe0403a3          	sb	zero,-25(s0)
    if (value < 0) {
    80010bf6:	f7843787          	fld	fa5,-136(s0)
    80010bfa:	f2000753          	fmv.d.x	fa4,zero
    80010bfe:	a2e797d3          	flt.d	a5,fa5,fa4
    80010c02:	cf81                	beqz	a5,80010c1a <_ftoa+0x198>
        negative = true;
    80010c04:	4785                	li	a5,1
    80010c06:	fef403a3          	sb	a5,-25(s0)
        value    = 0 - value;
    80010c0a:	f2000753          	fmv.d.x	fa4,zero
    80010c0e:	f7843787          	fld	fa5,-136(s0)
    80010c12:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010c16:	f6f43c27          	fsd	fa5,-136(s0)
    }

    // set default precision, if not set explicitly
    if (!(flags & FLAGS_PRECISION)) {
    80010c1a:	f6c42783          	lw	a5,-148(s0)
    80010c1e:	4007f793          	andi	a5,a5,1024
    80010c22:	2781                	sext.w	a5,a5
    80010c24:	e79d                	bnez	a5,80010c52 <_ftoa+0x1d0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80010c26:	4799                	li	a5,6
    80010c28:	f6f42a23          	sw	a5,-140(s0)
    }
    // limit precision to 9, cause a prec >= 10 can lead to overflow errors
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010c2c:	a01d                	j	80010c52 <_ftoa+0x1d0>
        buf[len++] = '0';
    80010c2e:	fe843783          	ld	a5,-24(s0)
    80010c32:	00178713          	addi	a4,a5,1
    80010c36:	fee43423          	sd	a4,-24(s0)
    80010c3a:	ff040713          	addi	a4,s0,-16
    80010c3e:	97ba                	add	a5,a5,a4
    80010c40:	03000713          	li	a4,48
    80010c44:	fae78823          	sb	a4,-80(a5)
        prec--;
    80010c48:	f7442783          	lw	a5,-140(s0)
    80010c4c:	37fd                	addiw	a5,a5,-1
    80010c4e:	f6f42a23          	sw	a5,-140(s0)
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
    80010c52:	fe843703          	ld	a4,-24(s0)
    80010c56:	47fd                	li	a5,31
    80010c58:	00e7e963          	bltu	a5,a4,80010c6a <_ftoa+0x1e8>
    80010c5c:	f7442783          	lw	a5,-140(s0)
    80010c60:	0007871b          	sext.w	a4,a5
    80010c64:	47a5                	li	a5,9
    80010c66:	fce7e4e3          	bltu	a5,a4,80010c2e <_ftoa+0x1ac>
    }

    int whole          = (int)value;
    80010c6a:	f7843787          	fld	fa5,-136(s0)
    80010c6e:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    80010c72:	fef42023          	sw	a5,-32(s0)
    double tmp         = (value - whole) * pow10[prec];
    80010c76:	fe042783          	lw	a5,-32(s0)
    80010c7a:	d20787d3          	fcvt.d.w	fa5,a5
    80010c7e:	f7843707          	fld	fa4,-136(s0)
    80010c82:	0af77753          	fsub.d	fa4,fa4,fa5
    80010c86:	00006717          	auipc	a4,0x6
    80010c8a:	5aa70713          	addi	a4,a4,1450 # 80017230 <pow10.0>
    80010c8e:	f7446783          	lwu	a5,-140(s0)
    80010c92:	078e                	slli	a5,a5,0x3
    80010c94:	97ba                	add	a5,a5,a4
    80010c96:	239c                	fld	fa5,0(a5)
    80010c98:	12f777d3          	fmul.d	fa5,fa4,fa5
    80010c9c:	fcf43027          	fsd	fa5,-64(s0)
    unsigned long frac = (unsigned long)tmp;
    80010ca0:	fc043787          	fld	fa5,-64(s0)
    80010ca4:	c23797d3          	fcvt.lu.d	a5,fa5,rtz
    80010ca8:	fcf43c23          	sd	a5,-40(s0)
    diff               = tmp - frac;
    80010cac:	fd843783          	ld	a5,-40(s0)
    80010cb0:	d237f7d3          	fcvt.d.lu	fa5,a5
    80010cb4:	fc043707          	fld	fa4,-64(s0)
    80010cb8:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010cbc:	fcf43427          	fsd	fa5,-56(s0)

    if (diff > 0.5) {
    80010cc0:	fc843707          	fld	fa4,-56(s0)
    80010cc4:	00006797          	auipc	a5,0x6
    80010cc8:	5dc78793          	addi	a5,a5,1500 # 800172a0 <pow10.0+0x70>
    80010ccc:	239c                	fld	fa5,0(a5)
    80010cce:	a2e797d3          	flt.d	a5,fa5,fa4
    80010cd2:	cf95                	beqz	a5,80010d0e <_ftoa+0x28c>
        ++frac;
    80010cd4:	fd843783          	ld	a5,-40(s0)
    80010cd8:	0785                	addi	a5,a5,1
    80010cda:	fcf43c23          	sd	a5,-40(s0)
        // handle rollover, e.g. case 0.99 with prec 1 is 1.0
        if (frac >= pow10[prec]) {
    80010cde:	fd843783          	ld	a5,-40(s0)
    80010ce2:	d237f753          	fcvt.d.lu	fa4,a5
    80010ce6:	00006717          	auipc	a4,0x6
    80010cea:	54a70713          	addi	a4,a4,1354 # 80017230 <pow10.0>
    80010cee:	f7446783          	lwu	a5,-140(s0)
    80010cf2:	078e                	slli	a5,a5,0x3
    80010cf4:	97ba                	add	a5,a5,a4
    80010cf6:	239c                	fld	fa5,0(a5)
    80010cf8:	a2e787d3          	fle.d	a5,fa5,fa4
    80010cfc:	cf9d                	beqz	a5,80010d3a <_ftoa+0x2b8>
            frac = 0;
    80010cfe:	fc043c23          	sd	zero,-40(s0)
            ++whole;
    80010d02:	fe042783          	lw	a5,-32(s0)
    80010d06:	2785                	addiw	a5,a5,1
    80010d08:	fef42023          	sw	a5,-32(s0)
    80010d0c:	a03d                	j	80010d3a <_ftoa+0x2b8>
        }
    }
    else if (diff < 0.5) {
    80010d0e:	fc843707          	fld	fa4,-56(s0)
    80010d12:	00006797          	auipc	a5,0x6
    80010d16:	58e78793          	addi	a5,a5,1422 # 800172a0 <pow10.0+0x70>
    80010d1a:	239c                	fld	fa5,0(a5)
    80010d1c:	a2f717d3          	flt.d	a5,fa4,fa5
    80010d20:	ef89                	bnez	a5,80010d3a <_ftoa+0x2b8>
    }
    else if ((frac == 0U) || (frac & 1U)) {
    80010d22:	fd843783          	ld	a5,-40(s0)
    80010d26:	c789                	beqz	a5,80010d30 <_ftoa+0x2ae>
    80010d28:	fd843783          	ld	a5,-40(s0)
    80010d2c:	8b85                	andi	a5,a5,1
    80010d2e:	c791                	beqz	a5,80010d3a <_ftoa+0x2b8>
        // if halfway, round up if odd OR if last digit is 0
        ++frac;
    80010d30:	fd843783          	ld	a5,-40(s0)
    80010d34:	0785                	addi	a5,a5,1
    80010d36:	fcf43c23          	sd	a5,-40(s0)
    }

    if (prec == 0U) {
    80010d3a:	f7442783          	lw	a5,-140(s0)
    80010d3e:	2781                	sext.w	a5,a5
    80010d40:	e3bd                	bnez	a5,80010da6 <_ftoa+0x324>
        diff = value - (double)whole;
    80010d42:	fe042783          	lw	a5,-32(s0)
    80010d46:	d20787d3          	fcvt.d.w	fa5,a5
    80010d4a:	f7843707          	fld	fa4,-136(s0)
    80010d4e:	0af777d3          	fsub.d	fa5,fa4,fa5
    80010d52:	fcf43427          	fsd	fa5,-56(s0)
        if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
    80010d56:	fc843707          	fld	fa4,-56(s0)
    80010d5a:	00006797          	auipc	a5,0x6
    80010d5e:	54678793          	addi	a5,a5,1350 # 800172a0 <pow10.0+0x70>
    80010d62:	239c                	fld	fa5,0(a5)
    80010d64:	a2f717d3          	flt.d	a5,fa4,fa5
    80010d68:	00f037b3          	snez	a5,a5
    80010d6c:	0ff7f793          	andi	a5,a5,255
    80010d70:	0017c793          	xori	a5,a5,1
    80010d74:	0ff7f793          	andi	a5,a5,255
    80010d78:	eb99                	bnez	a5,80010d8e <_ftoa+0x30c>
    80010d7a:	fc843707          	fld	fa4,-56(s0)
    80010d7e:	00006797          	auipc	a5,0x6
    80010d82:	52278793          	addi	a5,a5,1314 # 800172a0 <pow10.0+0x70>
    80010d86:	239c                	fld	fa5,0(a5)
    80010d88:	a2e797d3          	flt.d	a5,fa5,fa4
    80010d8c:	cbf1                	beqz	a5,80010e60 <_ftoa+0x3de>
    80010d8e:	fe042783          	lw	a5,-32(s0)
    80010d92:	8b85                	andi	a5,a5,1
    80010d94:	2781                	sext.w	a5,a5
    80010d96:	10078863          	beqz	a5,80010ea6 <_ftoa+0x424>
            // exactly 0.5 and ODD, then round up
            // 1.5 -> 2, but 2.5 -> 2
            ++whole;
    80010d9a:	fe042783          	lw	a5,-32(s0)
    80010d9e:	2785                	addiw	a5,a5,1
    80010da0:	fef42023          	sw	a5,-32(s0)
    80010da4:	a209                	j	80010ea6 <_ftoa+0x424>
        }
    }
    else {
        unsigned int count = prec;
    80010da6:	f7442783          	lw	a5,-140(s0)
    80010daa:	fcf42a23          	sw	a5,-44(s0)
        // now do fractional part, as an unsigned number
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010dae:	a0b1                	j	80010dfa <_ftoa+0x378>
            --count;
    80010db0:	fd442783          	lw	a5,-44(s0)
    80010db4:	37fd                	addiw	a5,a5,-1
    80010db6:	fcf42a23          	sw	a5,-44(s0)
            buf[len++] = (char)(48U + (frac % 10U));
    80010dba:	fd843703          	ld	a4,-40(s0)
    80010dbe:	47a9                	li	a5,10
    80010dc0:	02f777b3          	remu	a5,a4,a5
    80010dc4:	0ff7f713          	andi	a4,a5,255
    80010dc8:	fe843783          	ld	a5,-24(s0)
    80010dcc:	00178693          	addi	a3,a5,1
    80010dd0:	fed43423          	sd	a3,-24(s0)
    80010dd4:	0307071b          	addiw	a4,a4,48
    80010dd8:	0ff77713          	andi	a4,a4,255
    80010ddc:	ff040693          	addi	a3,s0,-16
    80010de0:	97b6                	add	a5,a5,a3
    80010de2:	fae78823          	sb	a4,-80(a5)
            if (!(frac /= 10U)) {
    80010de6:	fd843703          	ld	a4,-40(s0)
    80010dea:	47a9                	li	a5,10
    80010dec:	02f757b3          	divu	a5,a4,a5
    80010df0:	fcf43c23          	sd	a5,-40(s0)
    80010df4:	fd843783          	ld	a5,-40(s0)
    80010df8:	c799                	beqz	a5,80010e06 <_ftoa+0x384>
        while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010dfa:	fe843703          	ld	a4,-24(s0)
    80010dfe:	47fd                	li	a5,31
    80010e00:	fae7f8e3          	bgeu	a5,a4,80010db0 <_ftoa+0x32e>
    80010e04:	a005                	j	80010e24 <_ftoa+0x3a2>
                break;
    80010e06:	0001                	nop
            }
        }
        // add extra 0s
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010e08:	a831                	j	80010e24 <_ftoa+0x3a2>
            buf[len++] = '0';
    80010e0a:	fe843783          	ld	a5,-24(s0)
    80010e0e:	00178713          	addi	a4,a5,1
    80010e12:	fee43423          	sd	a4,-24(s0)
    80010e16:	ff040713          	addi	a4,s0,-16
    80010e1a:	97ba                	add	a5,a5,a4
    80010e1c:	03000713          	li	a4,48
    80010e20:	fae78823          	sb	a4,-80(a5)
        while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
    80010e24:	fe843703          	ld	a4,-24(s0)
    80010e28:	47fd                	li	a5,31
    80010e2a:	00e7e963          	bltu	a5,a4,80010e3c <_ftoa+0x3ba>
    80010e2e:	fd442783          	lw	a5,-44(s0)
    80010e32:	fff7871b          	addiw	a4,a5,-1
    80010e36:	fce42a23          	sw	a4,-44(s0)
    80010e3a:	fbe1                	bnez	a5,80010e0a <_ftoa+0x388>
        }
        if (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010e3c:	fe843703          	ld	a4,-24(s0)
    80010e40:	47fd                	li	a5,31
    80010e42:	06e7e263          	bltu	a5,a4,80010ea6 <_ftoa+0x424>
            // add decimal
            buf[len++] = '.';
    80010e46:	fe843783          	ld	a5,-24(s0)
    80010e4a:	00178713          	addi	a4,a5,1
    80010e4e:	fee43423          	sd	a4,-24(s0)
    80010e52:	ff040713          	addi	a4,s0,-16
    80010e56:	97ba                	add	a5,a5,a4
    80010e58:	02e00713          	li	a4,46
    80010e5c:	fae78823          	sb	a4,-80(a5)
        }
    }

    // do whole part, number is reversed
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010e60:	a099                	j	80010ea6 <_ftoa+0x424>
        buf[len++] = (char)(48 + (whole % 10));
    80010e62:	fe042703          	lw	a4,-32(s0)
    80010e66:	47a9                	li	a5,10
    80010e68:	02f767bb          	remw	a5,a4,a5
    80010e6c:	2781                	sext.w	a5,a5
    80010e6e:	0ff7f713          	andi	a4,a5,255
    80010e72:	fe843783          	ld	a5,-24(s0)
    80010e76:	00178693          	addi	a3,a5,1
    80010e7a:	fed43423          	sd	a3,-24(s0)
    80010e7e:	0307071b          	addiw	a4,a4,48
    80010e82:	0ff77713          	andi	a4,a4,255
    80010e86:	ff040693          	addi	a3,s0,-16
    80010e8a:	97b6                	add	a5,a5,a3
    80010e8c:	fae78823          	sb	a4,-80(a5)
        if (!(whole /= 10)) {
    80010e90:	fe042703          	lw	a4,-32(s0)
    80010e94:	47a9                	li	a5,10
    80010e96:	02f747bb          	divw	a5,a4,a5
    80010e9a:	fef42023          	sw	a5,-32(s0)
    80010e9e:	fe042783          	lw	a5,-32(s0)
    80010ea2:	2781                	sext.w	a5,a5
    80010ea4:	c799                	beqz	a5,80010eb2 <_ftoa+0x430>
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010ea6:	fe843703          	ld	a4,-24(s0)
    80010eaa:	47fd                	li	a5,31
    80010eac:	fae7fbe3          	bgeu	a5,a4,80010e62 <_ftoa+0x3e0>
    80010eb0:	a011                	j	80010eb4 <_ftoa+0x432>
            break;
    80010eb2:	0001                	nop
        }
    }

    // pad leading zeros
    if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
    80010eb4:	f6c42783          	lw	a5,-148(s0)
    80010eb8:	8b89                	andi	a5,a5,2
    80010eba:	2781                	sext.w	a5,a5
    80010ebc:	e3b5                	bnez	a5,80010f20 <_ftoa+0x49e>
    80010ebe:	f6c42783          	lw	a5,-148(s0)
    80010ec2:	8b85                	andi	a5,a5,1
    80010ec4:	2781                	sext.w	a5,a5
    80010ec6:	cfa9                	beqz	a5,80010f20 <_ftoa+0x49e>
        if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
    80010ec8:	f7042783          	lw	a5,-144(s0)
    80010ecc:	2781                	sext.w	a5,a5
    80010ece:	cf95                	beqz	a5,80010f0a <_ftoa+0x488>
    80010ed0:	fe744783          	lbu	a5,-25(s0)
    80010ed4:	0ff7f793          	andi	a5,a5,255
    80010ed8:	e791                	bnez	a5,80010ee4 <_ftoa+0x462>
    80010eda:	f6c42783          	lw	a5,-148(s0)
    80010ede:	8bb1                	andi	a5,a5,12
    80010ee0:	2781                	sext.w	a5,a5
    80010ee2:	c785                	beqz	a5,80010f0a <_ftoa+0x488>
            width--;
    80010ee4:	f7042783          	lw	a5,-144(s0)
    80010ee8:	37fd                	addiw	a5,a5,-1
    80010eea:	f6f42823          	sw	a5,-144(s0)
        }
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    80010eee:	a831                	j	80010f0a <_ftoa+0x488>
            buf[len++] = '0';
    80010ef0:	fe843783          	ld	a5,-24(s0)
    80010ef4:	00178713          	addi	a4,a5,1
    80010ef8:	fee43423          	sd	a4,-24(s0)
    80010efc:	ff040713          	addi	a4,s0,-16
    80010f00:	97ba                	add	a5,a5,a4
    80010f02:	03000713          	li	a4,48
    80010f06:	fae78823          	sb	a4,-80(a5)
        while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
    80010f0a:	f7046783          	lwu	a5,-144(s0)
    80010f0e:	fe843703          	ld	a4,-24(s0)
    80010f12:	00f77763          	bgeu	a4,a5,80010f20 <_ftoa+0x49e>
    80010f16:	fe843703          	ld	a4,-24(s0)
    80010f1a:	47fd                	li	a5,31
    80010f1c:	fce7fae3          	bgeu	a5,a4,80010ef0 <_ftoa+0x46e>
        }
    }

    if (len < PRINTF_FTOA_BUFFER_SIZE) {
    80010f20:	fe843703          	ld	a4,-24(s0)
    80010f24:	47fd                	li	a5,31
    80010f26:	06e7ea63          	bltu	a5,a4,80010f9a <_ftoa+0x518>
        if (negative) {
    80010f2a:	fe744783          	lbu	a5,-25(s0)
    80010f2e:	0ff7f793          	andi	a5,a5,255
    80010f32:	cf99                	beqz	a5,80010f50 <_ftoa+0x4ce>
            buf[len++] = '-';
    80010f34:	fe843783          	ld	a5,-24(s0)
    80010f38:	00178713          	addi	a4,a5,1
    80010f3c:	fee43423          	sd	a4,-24(s0)
    80010f40:	ff040713          	addi	a4,s0,-16
    80010f44:	97ba                	add	a5,a5,a4
    80010f46:	02d00713          	li	a4,45
    80010f4a:	fae78823          	sb	a4,-80(a5)
    80010f4e:	a0b1                	j	80010f9a <_ftoa+0x518>
        }
        else if (flags & FLAGS_PLUS) {
    80010f50:	f6c42783          	lw	a5,-148(s0)
    80010f54:	8b91                	andi	a5,a5,4
    80010f56:	2781                	sext.w	a5,a5
    80010f58:	cf99                	beqz	a5,80010f76 <_ftoa+0x4f4>
            buf[len++] = '+';  // ignore the space if the '+' exists
    80010f5a:	fe843783          	ld	a5,-24(s0)
    80010f5e:	00178713          	addi	a4,a5,1
    80010f62:	fee43423          	sd	a4,-24(s0)
    80010f66:	ff040713          	addi	a4,s0,-16
    80010f6a:	97ba                	add	a5,a5,a4
    80010f6c:	02b00713          	li	a4,43
    80010f70:	fae78823          	sb	a4,-80(a5)
    80010f74:	a01d                	j	80010f9a <_ftoa+0x518>
        }
        else if (flags & FLAGS_SPACE) {
    80010f76:	f6c42783          	lw	a5,-148(s0)
    80010f7a:	8ba1                	andi	a5,a5,8
    80010f7c:	2781                	sext.w	a5,a5
    80010f7e:	cf91                	beqz	a5,80010f9a <_ftoa+0x518>
            buf[len++] = ' ';
    80010f80:	fe843783          	ld	a5,-24(s0)
    80010f84:	00178713          	addi	a4,a5,1
    80010f88:	fee43423          	sd	a4,-24(s0)
    80010f8c:	ff040713          	addi	a4,s0,-16
    80010f90:	97ba                	add	a5,a5,a4
    80010f92:	02000713          	li	a4,32
    80010f96:	fae78823          	sb	a4,-80(a5)
        }
    }

    return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
    80010f9a:	f6c42683          	lw	a3,-148(s0)
    80010f9e:	f7042783          	lw	a5,-144(s0)
    80010fa2:	fa040713          	addi	a4,s0,-96
    80010fa6:	88b6                	mv	a7,a3
    80010fa8:	883e                	mv	a6,a5
    80010faa:	fe843783          	ld	a5,-24(s0)
    80010fae:	f8043683          	ld	a3,-128(s0)
    80010fb2:	f8843603          	ld	a2,-120(s0)
    80010fb6:	f9043583          	ld	a1,-112(s0)
    80010fba:	f9843503          	ld	a0,-104(s0)
    80010fbe:	ce8ff0ef          	jal	ra,800104a6 <_out_rev>
    80010fc2:	87aa                	mv	a5,a0
}
    80010fc4:	853e                	mv	a0,a5
    80010fc6:	60ea                	ld	ra,152(sp)
    80010fc8:	644a                	ld	s0,144(sp)
    80010fca:	610d                	addi	sp,sp,160
    80010fcc:	8082                	ret

0000000080010fce <_etoa>:
// internal ftoa variant for exponential floating-point type, contributed by
// Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char *buffer, size_t idx, size_t maxlen,
                    double value, unsigned int prec, unsigned int width,
                    unsigned int flags)
{
    80010fce:	7135                	addi	sp,sp,-160
    80010fd0:	ed06                	sd	ra,152(sp)
    80010fd2:	e922                	sd	s0,144(sp)
    80010fd4:	1100                	addi	s0,sp,160
    80010fd6:	faa43423          	sd	a0,-88(s0)
    80010fda:	fab43023          	sd	a1,-96(s0)
    80010fde:	f8c43c23          	sd	a2,-104(s0)
    80010fe2:	f8d43823          	sd	a3,-112(s0)
    80010fe6:	f8a43427          	fsd	fa0,-120(s0)
    80010fea:	863a                	mv	a2,a4
    80010fec:	86be                	mv	a3,a5
    80010fee:	8742                	mv	a4,a6
    80010ff0:	87b2                	mv	a5,a2
    80010ff2:	f8f42223          	sw	a5,-124(s0)
    80010ff6:	87b6                	mv	a5,a3
    80010ff8:	f8f42023          	sw	a5,-128(s0)
    80010ffc:	87ba                	mv	a5,a4
    80010ffe:	f6f42e23          	sw	a5,-132(s0)
    // check for NaN and special values
    if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
    80011002:	f8843707          	fld	fa4,-120(s0)
    80011006:	f8843787          	fld	fa5,-120(s0)
    8001100a:	a2f727d3          	feq.d	a5,fa4,fa5
    8001100e:	c78d                	beqz	a5,80011038 <_etoa+0x6a>
    80011010:	f8843707          	fld	fa4,-120(s0)
    80011014:	00006797          	auipc	a5,0x6
    80011018:	27478793          	addi	a5,a5,628 # 80017288 <pow10.0+0x58>
    8001101c:	239c                	fld	fa5,0(a5)
    8001101e:	a2e797d3          	flt.d	a5,fa5,fa4
    80011022:	eb99                	bnez	a5,80011038 <_etoa+0x6a>
    80011024:	f8843707          	fld	fa4,-120(s0)
    80011028:	00006797          	auipc	a5,0x6
    8001102c:	25878793          	addi	a5,a5,600 # 80017280 <pow10.0+0x50>
    80011030:	239c                	fld	fa5,0(a5)
    80011032:	a2f717d3          	flt.d	a5,fa4,fa5
    80011036:	c795                	beqz	a5,80011062 <_etoa+0x94>
        return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
    80011038:	f7c42683          	lw	a3,-132(s0)
    8001103c:	f8042783          	lw	a5,-128(s0)
    80011040:	f8442703          	lw	a4,-124(s0)
    80011044:	8836                	mv	a6,a3
    80011046:	f8843507          	fld	fa0,-120(s0)
    8001104a:	f9043683          	ld	a3,-112(s0)
    8001104e:	f9843603          	ld	a2,-104(s0)
    80011052:	fa043583          	ld	a1,-96(s0)
    80011056:	fa843503          	ld	a0,-88(s0)
    8001105a:	a29ff0ef          	jal	ra,80010a82 <_ftoa>
    8001105e:	87aa                	mv	a5,a0
    80011060:	a11d                	j	80011486 <_etoa+0x4b8>
    }

    // determine the sign
    const bool negative = value < 0;
    80011062:	f8843787          	fld	fa5,-120(s0)
    80011066:	f2000753          	fmv.d.x	fa4,zero
    8001106a:	a2e797d3          	flt.d	a5,fa5,fa4
    8001106e:	00f037b3          	snez	a5,a5
    80011072:	fef401a3          	sb	a5,-29(s0)
    if (negative) {
    80011076:	fe344783          	lbu	a5,-29(s0)
    8001107a:	0ff7f793          	andi	a5,a5,255
    8001107e:	c799                	beqz	a5,8001108c <_etoa+0xbe>
        value = -value;
    80011080:	f8843787          	fld	fa5,-120(s0)
    80011084:	22f797d3          	fneg.d	fa5,fa5
    80011088:	f8f43427          	fsd	fa5,-120(s0)
    }

    // default precision
    if (!(flags & FLAGS_PRECISION)) {
    8001108c:	f7c42783          	lw	a5,-132(s0)
    80011090:	4007f793          	andi	a5,a5,1024
    80011094:	2781                	sext.w	a5,a5
    80011096:	e781                	bnez	a5,8001109e <_etoa+0xd0>
        prec = PRINTF_DEFAULT_FLOAT_PRECISION;
    80011098:	4799                	li	a5,6
    8001109a:	f8f42223          	sw	a5,-124(s0)
    union {
        uint64_t U;
        double F;
    } conv;

    conv.F   = value;
    8001109e:	f8843787          	fld	fa5,-120(s0)
    800110a2:	faf43c27          	fsd	fa5,-72(s0)
    int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;  // effectively log2
    800110a6:	fb843783          	ld	a5,-72(s0)
    800110aa:	93d1                	srli	a5,a5,0x34
    800110ac:	2781                	sext.w	a5,a5
    800110ae:	7ff7f793          	andi	a5,a5,2047
    800110b2:	2781                	sext.w	a5,a5
    800110b4:	c017879b          	addiw	a5,a5,-1023
    800110b8:	fcf42e23          	sw	a5,-36(s0)
    conv.U   = (conv.U & ((1ULL << 52U) - 1U)) |
    800110bc:	fb843703          	ld	a4,-72(s0)
    800110c0:	57fd                	li	a5,-1
    800110c2:	83b1                	srli	a5,a5,0xc
    800110c4:	8f7d                	and	a4,a4,a5
    800110c6:	3ff00793          	li	a5,1023
    800110ca:	17d2                	slli	a5,a5,0x34
    800110cc:	8fd9                	or	a5,a5,a4
    800110ce:	faf43c23          	sd	a5,-72(s0)
             (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
    // now approximate log10 from the log2 integer part and an expansion of ln
    // around 1.5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    800110d2:	fdc42783          	lw	a5,-36(s0)
    800110d6:	d2078753          	fcvt.d.w	fa4,a5
    800110da:	00006797          	auipc	a5,0x6
    800110de:	1ce78793          	addi	a5,a5,462 # 800172a8 <pow10.0+0x78>
    800110e2:	239c                	fld	fa5,0(a5)
    800110e4:	12f77753          	fmul.d	fa4,fa4,fa5
    800110e8:	00006797          	auipc	a5,0x6
    800110ec:	1c878793          	addi	a5,a5,456 # 800172b0 <pow10.0+0x80>
    800110f0:	239c                	fld	fa5,0(a5)
    800110f2:	02f77753          	fadd.d	fa4,fa4,fa5
                       (conv.F - 1.5) * 0.289529654602168);
    800110f6:	fb843687          	fld	fa3,-72(s0)
    800110fa:	00006797          	auipc	a5,0x6
    800110fe:	1be78793          	addi	a5,a5,446 # 800172b8 <pow10.0+0x88>
    80011102:	239c                	fld	fa5,0(a5)
    80011104:	0af6f6d3          	fsub.d	fa3,fa3,fa5
    80011108:	00006797          	auipc	a5,0x6
    8001110c:	1b878793          	addi	a5,a5,440 # 800172c0 <pow10.0+0x90>
    80011110:	239c                	fld	fa5,0(a5)
    80011112:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    int expval      = (int)(0.1760912590558 + exp2 * 0.301029995663981 +
    80011116:	02f777d3          	fadd.d	fa5,fa4,fa5
    8001111a:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    8001111e:	fef42623          	sw	a5,-20(s0)
    // now we want to compute 10^expval but we want to be sure it won't overflow
    exp2            = (int)(expval * 3.321928094887362 + 0.5);
    80011122:	fec42783          	lw	a5,-20(s0)
    80011126:	d2078753          	fcvt.d.w	fa4,a5
    8001112a:	00006797          	auipc	a5,0x6
    8001112e:	19e78793          	addi	a5,a5,414 # 800172c8 <pow10.0+0x98>
    80011132:	239c                	fld	fa5,0(a5)
    80011134:	12f77753          	fmul.d	fa4,fa4,fa5
    80011138:	00006797          	auipc	a5,0x6
    8001113c:	16878793          	addi	a5,a5,360 # 800172a0 <pow10.0+0x70>
    80011140:	239c                	fld	fa5,0(a5)
    80011142:	02f777d3          	fadd.d	fa5,fa4,fa5
    80011146:	c20797d3          	fcvt.w.d	a5,fa5,rtz
    8001114a:	fcf42e23          	sw	a5,-36(s0)
    const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
    8001114e:	fec42783          	lw	a5,-20(s0)
    80011152:	d2078753          	fcvt.d.w	fa4,a5
    80011156:	00006797          	auipc	a5,0x6
    8001115a:	17a78793          	addi	a5,a5,378 # 800172d0 <pow10.0+0xa0>
    8001115e:	239c                	fld	fa5,0(a5)
    80011160:	12f77753          	fmul.d	fa4,fa4,fa5
    80011164:	fdc42783          	lw	a5,-36(s0)
    80011168:	d20786d3          	fcvt.d.w	fa3,a5
    8001116c:	00006797          	auipc	a5,0x6
    80011170:	16c78793          	addi	a5,a5,364 # 800172d8 <pow10.0+0xa8>
    80011174:	239c                	fld	fa5,0(a5)
    80011176:	12f6f7d3          	fmul.d	fa5,fa3,fa5
    8001117a:	0af777d3          	fsub.d	fa5,fa4,fa5
    8001117e:	fcf43827          	fsd	fa5,-48(s0)
    const double z2 = z * z;
    80011182:	fd043787          	fld	fa5,-48(s0)
    80011186:	12f7f7d3          	fmul.d	fa5,fa5,fa5
    8001118a:	fcf43427          	fsd	fa5,-56(s0)
    conv.U          = (uint64_t)(exp2 + 1023) << 52U;
    8001118e:	fdc42783          	lw	a5,-36(s0)
    80011192:	3ff7879b          	addiw	a5,a5,1023
    80011196:	2781                	sext.w	a5,a5
    80011198:	17d2                	slli	a5,a5,0x34
    8001119a:	faf43c23          	sd	a5,-72(s0)
    // compute exp(z) using continued fractions, see
    // https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
    conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
    8001119e:	fb843707          	fld	fa4,-72(s0)
    800111a2:	fd043787          	fld	fa5,-48(s0)
    800111a6:	02f7f6d3          	fadd.d	fa3,fa5,fa5
    800111aa:	00006797          	auipc	a5,0x6
    800111ae:	13678793          	addi	a5,a5,310 # 800172e0 <pow10.0+0xb0>
    800111b2:	2390                	fld	fa2,0(a5)
    800111b4:	fd043787          	fld	fa5,-48(s0)
    800111b8:	0af67653          	fsub.d	fa2,fa2,fa5
    800111bc:	fc843587          	fld	fa1,-56(s0)
    800111c0:	00006797          	auipc	a5,0x6
    800111c4:	12878793          	addi	a5,a5,296 # 800172e8 <pow10.0+0xb8>
    800111c8:	239c                	fld	fa5,0(a5)
    800111ca:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    800111ce:	00006797          	auipc	a5,0x6
    800111d2:	12278793          	addi	a5,a5,290 # 800172f0 <pow10.0+0xc0>
    800111d6:	239c                	fld	fa5,0(a5)
    800111d8:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800111dc:	fc843587          	fld	fa1,-56(s0)
    800111e0:	1af5f5d3          	fdiv.d	fa1,fa1,fa5
    800111e4:	00006797          	auipc	a5,0x6
    800111e8:	11478793          	addi	a5,a5,276 # 800172f8 <pow10.0+0xc8>
    800111ec:	239c                	fld	fa5,0(a5)
    800111ee:	02f5f7d3          	fadd.d	fa5,fa1,fa5
    800111f2:	fc843587          	fld	fa1,-56(s0)
    800111f6:	1af5f7d3          	fdiv.d	fa5,fa1,fa5
    800111fa:	02f677d3          	fadd.d	fa5,fa2,fa5
    800111fe:	1af6f6d3          	fdiv.d	fa3,fa3,fa5
    80011202:	00006797          	auipc	a5,0x6
    80011206:	0fe78793          	addi	a5,a5,254 # 80017300 <pow10.0+0xd0>
    8001120a:	239c                	fld	fa5,0(a5)
    8001120c:	02f6f7d3          	fadd.d	fa5,fa3,fa5
    80011210:	12f777d3          	fmul.d	fa5,fa4,fa5
    80011214:	faf43c27          	fsd	fa5,-72(s0)
    // correct for rounding errors
    if (value < conv.F) {
    80011218:	fb843787          	fld	fa5,-72(s0)
    8001121c:	f8843707          	fld	fa4,-120(s0)
    80011220:	a2f717d3          	flt.d	a5,fa4,fa5
    80011224:	c38d                	beqz	a5,80011246 <_etoa+0x278>
        expval--;
    80011226:	fec42783          	lw	a5,-20(s0)
    8001122a:	37fd                	addiw	a5,a5,-1
    8001122c:	fef42623          	sw	a5,-20(s0)
        conv.F /= 10;
    80011230:	fb843707          	fld	fa4,-72(s0)
    80011234:	00006797          	auipc	a5,0x6
    80011238:	0bc78793          	addi	a5,a5,188 # 800172f0 <pow10.0+0xc0>
    8001123c:	239c                	fld	fa5,0(a5)
    8001123e:	1af777d3          	fdiv.d	fa5,fa4,fa5
    80011242:	faf43c27          	fsd	fa5,-72(s0)
    }

    // the exponent format is "%+03d" and largest value is "307", so set aside
    // 4-5 characters
    unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
    80011246:	fec42783          	lw	a5,-20(s0)
    8001124a:	0007871b          	sext.w	a4,a5
    8001124e:	06300793          	li	a5,99
    80011252:	00e7cc63          	blt	a5,a4,8001126a <_etoa+0x29c>
    80011256:	fec42783          	lw	a5,-20(s0)
    8001125a:	0007871b          	sext.w	a4,a5
    8001125e:	f9d00793          	li	a5,-99
    80011262:	00f74463          	blt	a4,a5,8001126a <_etoa+0x29c>
    80011266:	4791                	li	a5,4
    80011268:	a011                	j	8001126c <_etoa+0x29e>
    8001126a:	4795                	li	a5,5
    8001126c:	fef42423          	sw	a5,-24(s0)

    // in "%g" mode, "prec" is the number of *significant figures* not decimals
    if (flags & FLAGS_ADAPT_EXP) {
    80011270:	f7c42703          	lw	a4,-132(s0)
    80011274:	6785                	lui	a5,0x1
    80011276:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    8001127a:	8ff9                	and	a5,a5,a4
    8001127c:	2781                	sext.w	a5,a5
    8001127e:	c7c1                	beqz	a5,80011306 <_etoa+0x338>
        // do we want to fall-back to "%f" mode?
        if ((value >= 1e-4) && (value < 1e6)) {
    80011280:	f8843707          	fld	fa4,-120(s0)
    80011284:	00006797          	auipc	a5,0x6
    80011288:	08478793          	addi	a5,a5,132 # 80017308 <pow10.0+0xd8>
    8001128c:	239c                	fld	fa5,0(a5)
    8001128e:	a2e787d3          	fle.d	a5,fa5,fa4
    80011292:	cbb9                	beqz	a5,800112e8 <_etoa+0x31a>
    80011294:	f8843707          	fld	fa4,-120(s0)
    80011298:	00006797          	auipc	a5,0x6
    8001129c:	07878793          	addi	a5,a5,120 # 80017310 <pow10.0+0xe0>
    800112a0:	239c                	fld	fa5,0(a5)
    800112a2:	a2f717d3          	flt.d	a5,fa4,fa5
    800112a6:	c3a9                	beqz	a5,800112e8 <_etoa+0x31a>
            if ((int)prec > expval) {
    800112a8:	f8442703          	lw	a4,-124(s0)
    800112ac:	fec42783          	lw	a5,-20(s0)
    800112b0:	2781                	sext.w	a5,a5
    800112b2:	00e7de63          	bge	a5,a4,800112ce <_etoa+0x300>
                prec = (unsigned)((int)prec - expval - 1);
    800112b6:	f8442703          	lw	a4,-124(s0)
    800112ba:	fec42783          	lw	a5,-20(s0)
    800112be:	40f707bb          	subw	a5,a4,a5
    800112c2:	2781                	sext.w	a5,a5
    800112c4:	37fd                	addiw	a5,a5,-1
    800112c6:	2781                	sext.w	a5,a5
    800112c8:	f8f42223          	sw	a5,-124(s0)
    800112cc:	a019                	j	800112d2 <_etoa+0x304>
            }
            else {
                prec = 0;
    800112ce:	f8042223          	sw	zero,-124(s0)
            }
            flags |= FLAGS_PRECISION;  // make sure _ftoa respects precision
    800112d2:	f7c42783          	lw	a5,-132(s0)
    800112d6:	4007e793          	ori	a5,a5,1024
    800112da:	f6f42e23          	sw	a5,-132(s0)
            // no characters in exponent
            minwidth = 0U;
    800112de:	fe042423          	sw	zero,-24(s0)
            expval   = 0;
    800112e2:	fe042623          	sw	zero,-20(s0)
    800112e6:	a005                	j	80011306 <_etoa+0x338>
        }
        else {
            // we use one sigfig for the whole part
            if ((prec > 0) && (flags & FLAGS_PRECISION)) {
    800112e8:	f8442783          	lw	a5,-124(s0)
    800112ec:	2781                	sext.w	a5,a5
    800112ee:	cf81                	beqz	a5,80011306 <_etoa+0x338>
    800112f0:	f7c42783          	lw	a5,-132(s0)
    800112f4:	4007f793          	andi	a5,a5,1024
    800112f8:	2781                	sext.w	a5,a5
    800112fa:	c791                	beqz	a5,80011306 <_etoa+0x338>
                --prec;
    800112fc:	f8442783          	lw	a5,-124(s0)
    80011300:	37fd                	addiw	a5,a5,-1
    80011302:	f8f42223          	sw	a5,-124(s0)
            }
        }
    }

    // will everything fit?
    unsigned int fwidth = width;
    80011306:	f8042783          	lw	a5,-128(s0)
    8001130a:	fef42223          	sw	a5,-28(s0)
    if (width > minwidth) {
    8001130e:	f8042703          	lw	a4,-128(s0)
    80011312:	fe842783          	lw	a5,-24(s0)
    80011316:	2701                	sext.w	a4,a4
    80011318:	2781                	sext.w	a5,a5
    8001131a:	00e7fb63          	bgeu	a5,a4,80011330 <_etoa+0x362>
        // we didn't fall-back so subtract the characters required for the
        // exponent
        fwidth -= minwidth;
    8001131e:	fe442703          	lw	a4,-28(s0)
    80011322:	fe842783          	lw	a5,-24(s0)
    80011326:	40f707bb          	subw	a5,a4,a5
    8001132a:	fef42223          	sw	a5,-28(s0)
    8001132e:	a019                	j	80011334 <_etoa+0x366>
    }
    else {
        // not enough characters, so go back to default sizing
        fwidth = 0U;
    80011330:	fe042223          	sw	zero,-28(s0)
    }
    if ((flags & FLAGS_LEFT) && minwidth) {
    80011334:	f7c42783          	lw	a5,-132(s0)
    80011338:	8b89                	andi	a5,a5,2
    8001133a:	2781                	sext.w	a5,a5
    8001133c:	c799                	beqz	a5,8001134a <_etoa+0x37c>
    8001133e:	fe842783          	lw	a5,-24(s0)
    80011342:	2781                	sext.w	a5,a5
    80011344:	c399                	beqz	a5,8001134a <_etoa+0x37c>
        // if we're padding on the right, DON'T pad the floating part
        fwidth = 0U;
    80011346:	fe042223          	sw	zero,-28(s0)
    }

    // rescale the float value
    if (expval) {
    8001134a:	fec42783          	lw	a5,-20(s0)
    8001134e:	2781                	sext.w	a5,a5
    80011350:	cb89                	beqz	a5,80011362 <_etoa+0x394>
        value /= conv.F;
    80011352:	fb843787          	fld	fa5,-72(s0)
    80011356:	f8843707          	fld	fa4,-120(s0)
    8001135a:	1af777d3          	fdiv.d	fa5,fa4,fa5
    8001135e:	f8f43427          	fsd	fa5,-120(s0)
    }

    // output the floating part
    const size_t start_idx = idx;
    80011362:	f9843783          	ld	a5,-104(s0)
    80011366:	fcf43023          	sd	a5,-64(s0)
    idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec,
    8001136a:	fe344783          	lbu	a5,-29(s0)
    8001136e:	0ff7f793          	andi	a5,a5,255
    80011372:	c791                	beqz	a5,8001137e <_etoa+0x3b0>
    80011374:	f8843787          	fld	fa5,-120(s0)
    80011378:	22f797d3          	fneg.d	fa5,fa5
    8001137c:	a019                	j	80011382 <_etoa+0x3b4>
    8001137e:	f8843787          	fld	fa5,-120(s0)
    80011382:	f7c42703          	lw	a4,-132(s0)
    80011386:	77fd                	lui	a5,0xfffff
    80011388:	7ff78793          	addi	a5,a5,2047 # fffffffffffff7ff <_heap_end+0xffffffff77fef7ff>
    8001138c:	8ff9                	and	a5,a5,a4
    8001138e:	0007869b          	sext.w	a3,a5
    80011392:	fe442783          	lw	a5,-28(s0)
    80011396:	f8442703          	lw	a4,-124(s0)
    8001139a:	8836                	mv	a6,a3
    8001139c:	22f78553          	fmv.d	fa0,fa5
    800113a0:	f9043683          	ld	a3,-112(s0)
    800113a4:	f9843603          	ld	a2,-104(s0)
    800113a8:	fa043583          	ld	a1,-96(s0)
    800113ac:	fa843503          	ld	a0,-88(s0)
    800113b0:	ed2ff0ef          	jal	ra,80010a82 <_ftoa>
    800113b4:	f8a43c23          	sd	a0,-104(s0)
                fwidth, flags & ~FLAGS_ADAPT_EXP);

    // output the exponent part
    if (minwidth) {
    800113b8:	fe842783          	lw	a5,-24(s0)
    800113bc:	2781                	sext.w	a5,a5
    800113be:	c3f1                	beqz	a5,80011482 <_etoa+0x4b4>
        // output the exponential symbol
        out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
    800113c0:	f7c42783          	lw	a5,-132(s0)
    800113c4:	0207f793          	andi	a5,a5,32
    800113c8:	2781                	sext.w	a5,a5
    800113ca:	c781                	beqz	a5,800113d2 <_etoa+0x404>
    800113cc:	04500793          	li	a5,69
    800113d0:	a019                	j	800113d6 <_etoa+0x408>
    800113d2:	06500793          	li	a5,101
    800113d6:	f9843703          	ld	a4,-104(s0)
    800113da:	00170693          	addi	a3,a4,1
    800113de:	f8d43c23          	sd	a3,-104(s0)
    800113e2:	fa843803          	ld	a6,-88(s0)
    800113e6:	f9043683          	ld	a3,-112(s0)
    800113ea:	863a                	mv	a2,a4
    800113ec:	fa043583          	ld	a1,-96(s0)
    800113f0:	853e                	mv	a0,a5
    800113f2:	9802                	jalr	a6
        // output the exponent value
        idx = _ntoa_long(out, buffer, idx, maxlen,
                         (expval < 0) ? -expval : expval, expval < 0, 10, 0,
    800113f4:	fec42783          	lw	a5,-20(s0)
    800113f8:	41f7d79b          	sraiw	a5,a5,0x1f
    800113fc:	fec42703          	lw	a4,-20(s0)
    80011400:	8f3d                	xor	a4,a4,a5
    80011402:	40f707bb          	subw	a5,a4,a5
    80011406:	2781                	sext.w	a5,a5
        idx = _ntoa_long(out, buffer, idx, maxlen,
    80011408:	863e                	mv	a2,a5
    8001140a:	fec42783          	lw	a5,-20(s0)
    8001140e:	01f7d79b          	srliw	a5,a5,0x1f
    80011412:	0ff7f693          	andi	a3,a5,255
    80011416:	fe842783          	lw	a5,-24(s0)
    8001141a:	37fd                	addiw	a5,a5,-1
    8001141c:	2781                	sext.w	a5,a5
    8001141e:	4715                	li	a4,5
    80011420:	e43a                	sd	a4,8(sp)
    80011422:	e03e                	sd	a5,0(sp)
    80011424:	4881                	li	a7,0
    80011426:	4829                	li	a6,10
    80011428:	87b6                	mv	a5,a3
    8001142a:	8732                	mv	a4,a2
    8001142c:	f9043683          	ld	a3,-112(s0)
    80011430:	f9843603          	ld	a2,-104(s0)
    80011434:	fa043583          	ld	a1,-96(s0)
    80011438:	fa843503          	ld	a0,-88(s0)
    8001143c:	c16ff0ef          	jal	ra,80010852 <_ntoa_long>
    80011440:	f8a43c23          	sd	a0,-104(s0)
                         minwidth - 1, FLAGS_ZEROPAD | FLAGS_PLUS);
        // might need to right-pad spaces
        if (flags & FLAGS_LEFT) {
    80011444:	f7c42783          	lw	a5,-132(s0)
    80011448:	8b89                	andi	a5,a5,2
    8001144a:	2781                	sext.w	a5,a5
    8001144c:	cb9d                	beqz	a5,80011482 <_etoa+0x4b4>
            while (idx - start_idx < width)
    8001144e:	a00d                	j	80011470 <_etoa+0x4a2>
                out(' ', buffer, idx++, maxlen);
    80011450:	f9843783          	ld	a5,-104(s0)
    80011454:	00178713          	addi	a4,a5,1
    80011458:	f8e43c23          	sd	a4,-104(s0)
    8001145c:	fa843703          	ld	a4,-88(s0)
    80011460:	f9043683          	ld	a3,-112(s0)
    80011464:	863e                	mv	a2,a5
    80011466:	fa043583          	ld	a1,-96(s0)
    8001146a:	02000513          	li	a0,32
    8001146e:	9702                	jalr	a4
            while (idx - start_idx < width)
    80011470:	f9843703          	ld	a4,-104(s0)
    80011474:	fc043783          	ld	a5,-64(s0)
    80011478:	8f1d                	sub	a4,a4,a5
    8001147a:	f8046783          	lwu	a5,-128(s0)
    8001147e:	fcf769e3          	bltu	a4,a5,80011450 <_etoa+0x482>
        }
    }
    return idx;
    80011482:	f9843783          	ld	a5,-104(s0)
}
    80011486:	853e                	mv	a0,a5
    80011488:	60ea                	ld	ra,152(sp)
    8001148a:	644a                	ld	s0,144(sp)
    8001148c:	610d                	addi	sp,sp,160
    8001148e:	8082                	ret

0000000080011490 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT

// internal vsnprintf
static int _vsnprintf(out_fct_type out, char *buffer, const size_t maxlen,
                      const char *format, va_list va)
{
    80011490:	7135                	addi	sp,sp,-160
    80011492:	ed06                	sd	ra,152(sp)
    80011494:	e922                	sd	s0,144(sp)
    80011496:	1100                	addi	s0,sp,160
    80011498:	f8a43c23          	sd	a0,-104(s0)
    8001149c:	f8b43823          	sd	a1,-112(s0)
    800114a0:	f8c43423          	sd	a2,-120(s0)
    800114a4:	f8d43023          	sd	a3,-128(s0)
    800114a8:	f6e43c23          	sd	a4,-136(s0)
    unsigned int flags, width, precision, n;
    size_t idx = 0U;
    800114ac:	fc043c23          	sd	zero,-40(s0)

    if (!buffer) {
    800114b0:	f9043783          	ld	a5,-112(s0)
    800114b4:	380792e3          	bnez	a5,80012038 <_vsnprintf+0xba8>
        // use null output function
        out = _out_null;
    800114b8:	fffff797          	auipc	a5,0xfffff
    800114bc:	e5878793          	addi	a5,a5,-424 # 80010310 <_out_null>
    800114c0:	f8f43c23          	sd	a5,-104(s0)
    }

    while (*format) {
    800114c4:	3750006f          	j	80012038 <_vsnprintf+0xba8>
        // format specifier?  %[flags][width][.precision][length]
        if (*format != '%') {
    800114c8:	f8043783          	ld	a5,-128(s0)
    800114cc:	0007c783          	lbu	a5,0(a5)
    800114d0:	873e                	mv	a4,a5
    800114d2:	02500793          	li	a5,37
    800114d6:	02f70b63          	beq	a4,a5,8001150c <_vsnprintf+0x7c>
            // no
            out(*format, buffer, idx++, maxlen);
    800114da:	f8043783          	ld	a5,-128(s0)
    800114de:	0007c503          	lbu	a0,0(a5)
    800114e2:	fd843783          	ld	a5,-40(s0)
    800114e6:	00178713          	addi	a4,a5,1
    800114ea:	fce43c23          	sd	a4,-40(s0)
    800114ee:	f9843703          	ld	a4,-104(s0)
    800114f2:	f8843683          	ld	a3,-120(s0)
    800114f6:	863e                	mv	a2,a5
    800114f8:	f9043583          	ld	a1,-112(s0)
    800114fc:	9702                	jalr	a4
            format++;
    800114fe:	f8043783          	ld	a5,-128(s0)
    80011502:	0785                	addi	a5,a5,1
    80011504:	f8f43023          	sd	a5,-128(s0)
            continue;
    80011508:	3310006f          	j	80012038 <_vsnprintf+0xba8>
        }
        else {
            // yes, evaluate it
            format++;
    8001150c:	f8043783          	ld	a5,-128(s0)
    80011510:	0785                	addi	a5,a5,1
    80011512:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate flags
        flags = 0U;
    80011516:	fe042623          	sw	zero,-20(s0)
        do {
            switch (*format) {
    8001151a:	f8043783          	ld	a5,-128(s0)
    8001151e:	0007c783          	lbu	a5,0(a5)
    80011522:	2781                	sext.w	a5,a5
    80011524:	fe07869b          	addiw	a3,a5,-32
    80011528:	0006871b          	sext.w	a4,a3
    8001152c:	47c1                	li	a5,16
    8001152e:	0ce7e063          	bltu	a5,a4,800115ee <_vsnprintf+0x15e>
    80011532:	02069793          	slli	a5,a3,0x20
    80011536:	9381                	srli	a5,a5,0x20
    80011538:	00279713          	slli	a4,a5,0x2
    8001153c:	00006797          	auipc	a5,0x6
    80011540:	b1078793          	addi	a5,a5,-1264 # 8001704c <SYSCALLS+0x4c>
    80011544:	97ba                	add	a5,a5,a4
    80011546:	439c                	lw	a5,0(a5)
    80011548:	0007871b          	sext.w	a4,a5
    8001154c:	00006797          	auipc	a5,0x6
    80011550:	b0078793          	addi	a5,a5,-1280 # 8001704c <SYSCALLS+0x4c>
    80011554:	97ba                	add	a5,a5,a4
    80011556:	8782                	jr	a5
                case '0':
                    flags |= FLAGS_ZEROPAD;
    80011558:	fec42783          	lw	a5,-20(s0)
    8001155c:	0017e793          	ori	a5,a5,1
    80011560:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011564:	f8043783          	ld	a5,-128(s0)
    80011568:	0785                	addi	a5,a5,1
    8001156a:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    8001156e:	4785                	li	a5,1
    80011570:	fef42023          	sw	a5,-32(s0)
                    break;
    80011574:	a041                	j	800115f4 <_vsnprintf+0x164>
                case '-':
                    flags |= FLAGS_LEFT;
    80011576:	fec42783          	lw	a5,-20(s0)
    8001157a:	0027e793          	ori	a5,a5,2
    8001157e:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011582:	f8043783          	ld	a5,-128(s0)
    80011586:	0785                	addi	a5,a5,1
    80011588:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    8001158c:	4785                	li	a5,1
    8001158e:	fef42023          	sw	a5,-32(s0)
                    break;
    80011592:	a08d                	j	800115f4 <_vsnprintf+0x164>
                case '+':
                    flags |= FLAGS_PLUS;
    80011594:	fec42783          	lw	a5,-20(s0)
    80011598:	0047e793          	ori	a5,a5,4
    8001159c:	fef42623          	sw	a5,-20(s0)
                    format++;
    800115a0:	f8043783          	ld	a5,-128(s0)
    800115a4:	0785                	addi	a5,a5,1
    800115a6:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    800115aa:	4785                	li	a5,1
    800115ac:	fef42023          	sw	a5,-32(s0)
                    break;
    800115b0:	a091                	j	800115f4 <_vsnprintf+0x164>
                case ' ':
                    flags |= FLAGS_SPACE;
    800115b2:	fec42783          	lw	a5,-20(s0)
    800115b6:	0087e793          	ori	a5,a5,8
    800115ba:	fef42623          	sw	a5,-20(s0)
                    format++;
    800115be:	f8043783          	ld	a5,-128(s0)
    800115c2:	0785                	addi	a5,a5,1
    800115c4:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    800115c8:	4785                	li	a5,1
    800115ca:	fef42023          	sw	a5,-32(s0)
                    break;
    800115ce:	a01d                	j	800115f4 <_vsnprintf+0x164>
                case '#':
                    flags |= FLAGS_HASH;
    800115d0:	fec42783          	lw	a5,-20(s0)
    800115d4:	0107e793          	ori	a5,a5,16
    800115d8:	fef42623          	sw	a5,-20(s0)
                    format++;
    800115dc:	f8043783          	ld	a5,-128(s0)
    800115e0:	0785                	addi	a5,a5,1
    800115e2:	f8f43023          	sd	a5,-128(s0)
                    n = 1U;
    800115e6:	4785                	li	a5,1
    800115e8:	fef42023          	sw	a5,-32(s0)
                    break;
    800115ec:	a021                	j	800115f4 <_vsnprintf+0x164>
                default:
                    n = 0U;
    800115ee:	fe042023          	sw	zero,-32(s0)
                    break;
    800115f2:	0001                	nop
            }
        } while (n);
    800115f4:	fe042783          	lw	a5,-32(s0)
    800115f8:	2781                	sext.w	a5,a5
    800115fa:	f385                	bnez	a5,8001151a <_vsnprintf+0x8a>

        // evaluate width field
        width = 0U;
    800115fc:	fe042423          	sw	zero,-24(s0)
        if (_is_digit(*format)) {
    80011600:	f8043783          	ld	a5,-128(s0)
    80011604:	0007c783          	lbu	a5,0(a5)
    80011608:	853e                	mv	a0,a5
    8001160a:	df3fe0ef          	jal	ra,800103fc <_is_digit>
    8001160e:	87aa                	mv	a5,a0
    80011610:	cb91                	beqz	a5,80011624 <_vsnprintf+0x194>
            width = _atoi(&format);
    80011612:	f8040793          	addi	a5,s0,-128
    80011616:	853e                	mv	a0,a5
    80011618:	e25fe0ef          	jal	ra,8001043c <_atoi>
    8001161c:	87aa                	mv	a5,a0
    8001161e:	fef42423          	sw	a5,-24(s0)
    80011622:	a8b9                	j	80011680 <_vsnprintf+0x1f0>
        }
        else if (*format == '*') {
    80011624:	f8043783          	ld	a5,-128(s0)
    80011628:	0007c783          	lbu	a5,0(a5)
    8001162c:	873e                	mv	a4,a5
    8001162e:	02a00793          	li	a5,42
    80011632:	04f71763          	bne	a4,a5,80011680 <_vsnprintf+0x1f0>
            const int w = va_arg(va, int);
    80011636:	f7843783          	ld	a5,-136(s0)
    8001163a:	00878713          	addi	a4,a5,8
    8001163e:	f6e43c23          	sd	a4,-136(s0)
    80011642:	439c                	lw	a5,0(a5)
    80011644:	fcf42023          	sw	a5,-64(s0)
            if (w < 0) {
    80011648:	fc042783          	lw	a5,-64(s0)
    8001164c:	2781                	sext.w	a5,a5
    8001164e:	0207d063          	bgez	a5,8001166e <_vsnprintf+0x1de>
                flags |= FLAGS_LEFT;  // reverse padding
    80011652:	fec42783          	lw	a5,-20(s0)
    80011656:	0027e793          	ori	a5,a5,2
    8001165a:	fef42623          	sw	a5,-20(s0)
                width = (unsigned int)-w;
    8001165e:	fc042783          	lw	a5,-64(s0)
    80011662:	40f007bb          	negw	a5,a5
    80011666:	2781                	sext.w	a5,a5
    80011668:	fef42423          	sw	a5,-24(s0)
    8001166c:	a029                	j	80011676 <_vsnprintf+0x1e6>
            }
            else {
                width = (unsigned int)w;
    8001166e:	fc042783          	lw	a5,-64(s0)
    80011672:	fef42423          	sw	a5,-24(s0)
            }
            format++;
    80011676:	f8043783          	ld	a5,-128(s0)
    8001167a:	0785                	addi	a5,a5,1
    8001167c:	f8f43023          	sd	a5,-128(s0)
        }

        // evaluate precision field
        precision = 0U;
    80011680:	fe042223          	sw	zero,-28(s0)
        if (*format == '.') {
    80011684:	f8043783          	ld	a5,-128(s0)
    80011688:	0007c783          	lbu	a5,0(a5)
    8001168c:	873e                	mv	a4,a5
    8001168e:	02e00793          	li	a5,46
    80011692:	08f71063          	bne	a4,a5,80011712 <_vsnprintf+0x282>
            flags |= FLAGS_PRECISION;
    80011696:	fec42783          	lw	a5,-20(s0)
    8001169a:	4007e793          	ori	a5,a5,1024
    8001169e:	fef42623          	sw	a5,-20(s0)
            format++;
    800116a2:	f8043783          	ld	a5,-128(s0)
    800116a6:	0785                	addi	a5,a5,1
    800116a8:	f8f43023          	sd	a5,-128(s0)
            if (_is_digit(*format)) {
    800116ac:	f8043783          	ld	a5,-128(s0)
    800116b0:	0007c783          	lbu	a5,0(a5)
    800116b4:	853e                	mv	a0,a5
    800116b6:	d47fe0ef          	jal	ra,800103fc <_is_digit>
    800116ba:	87aa                	mv	a5,a0
    800116bc:	cb91                	beqz	a5,800116d0 <_vsnprintf+0x240>
                precision = _atoi(&format);
    800116be:	f8040793          	addi	a5,s0,-128
    800116c2:	853e                	mv	a0,a5
    800116c4:	d79fe0ef          	jal	ra,8001043c <_atoi>
    800116c8:	87aa                	mv	a5,a0
    800116ca:	fef42223          	sw	a5,-28(s0)
    800116ce:	a091                	j	80011712 <_vsnprintf+0x282>
            }
            else if (*format == '*') {
    800116d0:	f8043783          	ld	a5,-128(s0)
    800116d4:	0007c783          	lbu	a5,0(a5)
    800116d8:	873e                	mv	a4,a5
    800116da:	02a00793          	li	a5,42
    800116de:	02f71a63          	bne	a4,a5,80011712 <_vsnprintf+0x282>
                const int prec = (int)va_arg(va, int);
    800116e2:	f7843783          	ld	a5,-136(s0)
    800116e6:	00878713          	addi	a4,a5,8
    800116ea:	f6e43c23          	sd	a4,-136(s0)
    800116ee:	439c                	lw	a5,0(a5)
    800116f0:	faf42e23          	sw	a5,-68(s0)
                precision      = prec > 0 ? (unsigned int)prec : 0U;
    800116f4:	fbc42783          	lw	a5,-68(s0)
    800116f8:	0007871b          	sext.w	a4,a5
    800116fc:	00075363          	bgez	a4,80011702 <_vsnprintf+0x272>
    80011700:	4781                	li	a5,0
    80011702:	2781                	sext.w	a5,a5
    80011704:	fef42223          	sw	a5,-28(s0)
                format++;
    80011708:	f8043783          	ld	a5,-128(s0)
    8001170c:	0785                	addi	a5,a5,1
    8001170e:	f8f43023          	sd	a5,-128(s0)
            }
        }

        // evaluate length field
        switch (*format) {
    80011712:	f8043783          	ld	a5,-128(s0)
    80011716:	0007c783          	lbu	a5,0(a5)
    8001171a:	2781                	sext.w	a5,a5
    8001171c:	f987869b          	addiw	a3,a5,-104
    80011720:	0006871b          	sext.w	a4,a3
    80011724:	47c9                	li	a5,18
    80011726:	0ee7e963          	bltu	a5,a4,80011818 <_vsnprintf+0x388>
    8001172a:	02069793          	slli	a5,a3,0x20
    8001172e:	9381                	srli	a5,a5,0x20
    80011730:	00279713          	slli	a4,a5,0x2
    80011734:	00006797          	auipc	a5,0x6
    80011738:	95c78793          	addi	a5,a5,-1700 # 80017090 <SYSCALLS+0x90>
    8001173c:	97ba                	add	a5,a5,a4
    8001173e:	439c                	lw	a5,0(a5)
    80011740:	0007871b          	sext.w	a4,a5
    80011744:	00006797          	auipc	a5,0x6
    80011748:	94c78793          	addi	a5,a5,-1716 # 80017090 <SYSCALLS+0x90>
    8001174c:	97ba                	add	a5,a5,a4
    8001174e:	8782                	jr	a5
            case 'l':
                flags |= FLAGS_LONG;
    80011750:	fec42783          	lw	a5,-20(s0)
    80011754:	1007e793          	ori	a5,a5,256
    80011758:	fef42623          	sw	a5,-20(s0)
                format++;
    8001175c:	f8043783          	ld	a5,-128(s0)
    80011760:	0785                	addi	a5,a5,1
    80011762:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'l') {
    80011766:	f8043783          	ld	a5,-128(s0)
    8001176a:	0007c783          	lbu	a5,0(a5)
    8001176e:	873e                	mv	a4,a5
    80011770:	06c00793          	li	a5,108
    80011774:	0af71463          	bne	a4,a5,8001181c <_vsnprintf+0x38c>
                    flags |= FLAGS_LONG_LONG;
    80011778:	fec42783          	lw	a5,-20(s0)
    8001177c:	2007e793          	ori	a5,a5,512
    80011780:	fef42623          	sw	a5,-20(s0)
                    format++;
    80011784:	f8043783          	ld	a5,-128(s0)
    80011788:	0785                	addi	a5,a5,1
    8001178a:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    8001178e:	a079                	j	8001181c <_vsnprintf+0x38c>
            case 'h':
                flags |= FLAGS_SHORT;
    80011790:	fec42783          	lw	a5,-20(s0)
    80011794:	0807e793          	ori	a5,a5,128
    80011798:	fef42623          	sw	a5,-20(s0)
                format++;
    8001179c:	f8043783          	ld	a5,-128(s0)
    800117a0:	0785                	addi	a5,a5,1
    800117a2:	f8f43023          	sd	a5,-128(s0)
                if (*format == 'h') {
    800117a6:	f8043783          	ld	a5,-128(s0)
    800117aa:	0007c783          	lbu	a5,0(a5)
    800117ae:	873e                	mv	a4,a5
    800117b0:	06800793          	li	a5,104
    800117b4:	06f71663          	bne	a4,a5,80011820 <_vsnprintf+0x390>
                    flags |= FLAGS_CHAR;
    800117b8:	fec42783          	lw	a5,-20(s0)
    800117bc:	0407e793          	ori	a5,a5,64
    800117c0:	fef42623          	sw	a5,-20(s0)
                    format++;
    800117c4:	f8043783          	ld	a5,-128(s0)
    800117c8:	0785                	addi	a5,a5,1
    800117ca:	f8f43023          	sd	a5,-128(s0)
                }
                break;
    800117ce:	a889                	j	80011820 <_vsnprintf+0x390>
#if defined(PRINTF_SUPPORT_PTRDIFF_T)
            case 't':
                flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG
    800117d0:	fec42783          	lw	a5,-20(s0)
    800117d4:	1007e793          	ori	a5,a5,256
    800117d8:	fef42623          	sw	a5,-20(s0)
                                                            : FLAGS_LONG_LONG);
                format++;
    800117dc:	f8043783          	ld	a5,-128(s0)
    800117e0:	0785                	addi	a5,a5,1
    800117e2:	f8f43023          	sd	a5,-128(s0)
                break;
    800117e6:	a835                	j	80011822 <_vsnprintf+0x392>
#endif
            case 'j':
                flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG
    800117e8:	fec42783          	lw	a5,-20(s0)
    800117ec:	1007e793          	ori	a5,a5,256
    800117f0:	fef42623          	sw	a5,-20(s0)
                                                           : FLAGS_LONG_LONG);
                format++;
    800117f4:	f8043783          	ld	a5,-128(s0)
    800117f8:	0785                	addi	a5,a5,1
    800117fa:	f8f43023          	sd	a5,-128(s0)
                break;
    800117fe:	a015                	j	80011822 <_vsnprintf+0x392>
            case 'z':
                flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG
    80011800:	fec42783          	lw	a5,-20(s0)
    80011804:	1007e793          	ori	a5,a5,256
    80011808:	fef42623          	sw	a5,-20(s0)
                                                         : FLAGS_LONG_LONG);
                format++;
    8001180c:	f8043783          	ld	a5,-128(s0)
    80011810:	0785                	addi	a5,a5,1
    80011812:	f8f43023          	sd	a5,-128(s0)
                break;
    80011816:	a031                	j	80011822 <_vsnprintf+0x392>
            default:
                break;
    80011818:	0001                	nop
    8001181a:	a021                	j	80011822 <_vsnprintf+0x392>
                break;
    8001181c:	0001                	nop
    8001181e:	a011                	j	80011822 <_vsnprintf+0x392>
                break;
    80011820:	0001                	nop
        }

        // evaluate specifier
        switch (*format) {
    80011822:	f8043783          	ld	a5,-128(s0)
    80011826:	0007c783          	lbu	a5,0(a5)
    8001182a:	2781                	sext.w	a5,a5
    8001182c:	fdb7869b          	addiw	a3,a5,-37
    80011830:	0006871b          	sext.w	a4,a3
    80011834:	05300793          	li	a5,83
    80011838:	7ce7e863          	bltu	a5,a4,80012008 <_vsnprintf+0xb78>
    8001183c:	02069793          	slli	a5,a3,0x20
    80011840:	9381                	srli	a5,a5,0x20
    80011842:	00279713          	slli	a4,a5,0x2
    80011846:	00006797          	auipc	a5,0x6
    8001184a:	89678793          	addi	a5,a5,-1898 # 800170dc <SYSCALLS+0xdc>
    8001184e:	97ba                	add	a5,a5,a4
    80011850:	439c                	lw	a5,0(a5)
    80011852:	0007871b          	sext.w	a4,a5
    80011856:	00006797          	auipc	a5,0x6
    8001185a:	88678793          	addi	a5,a5,-1914 # 800170dc <SYSCALLS+0xdc>
    8001185e:	97ba                	add	a5,a5,a4
    80011860:	8782                	jr	a5
            case 'X':
            case 'o':
            case 'b': {
                // set the base
                unsigned int base;
                if (*format == 'x' || *format == 'X') {
    80011862:	f8043783          	ld	a5,-128(s0)
    80011866:	0007c783          	lbu	a5,0(a5)
    8001186a:	873e                	mv	a4,a5
    8001186c:	07800793          	li	a5,120
    80011870:	00f70b63          	beq	a4,a5,80011886 <_vsnprintf+0x3f6>
    80011874:	f8043783          	ld	a5,-128(s0)
    80011878:	0007c783          	lbu	a5,0(a5)
    8001187c:	873e                	mv	a4,a5
    8001187e:	05800793          	li	a5,88
    80011882:	00f71663          	bne	a4,a5,8001188e <_vsnprintf+0x3fe>
                    base = 16U;
    80011886:	47c1                	li	a5,16
    80011888:	fcf42a23          	sw	a5,-44(s0)
    8001188c:	a099                	j	800118d2 <_vsnprintf+0x442>
                }
                else if (*format == 'o') {
    8001188e:	f8043783          	ld	a5,-128(s0)
    80011892:	0007c783          	lbu	a5,0(a5)
    80011896:	873e                	mv	a4,a5
    80011898:	06f00793          	li	a5,111
    8001189c:	00f71663          	bne	a4,a5,800118a8 <_vsnprintf+0x418>
                    base = 8U;
    800118a0:	47a1                	li	a5,8
    800118a2:	fcf42a23          	sw	a5,-44(s0)
    800118a6:	a035                	j	800118d2 <_vsnprintf+0x442>
                }
                else if (*format == 'b') {
    800118a8:	f8043783          	ld	a5,-128(s0)
    800118ac:	0007c783          	lbu	a5,0(a5)
    800118b0:	873e                	mv	a4,a5
    800118b2:	06200793          	li	a5,98
    800118b6:	00f71663          	bne	a4,a5,800118c2 <_vsnprintf+0x432>
                    base = 2U;
    800118ba:	4789                	li	a5,2
    800118bc:	fcf42a23          	sw	a5,-44(s0)
    800118c0:	a809                	j	800118d2 <_vsnprintf+0x442>
                }
                else {
                    base = 10U;
    800118c2:	47a9                	li	a5,10
    800118c4:	fcf42a23          	sw	a5,-44(s0)
                    flags &= ~FLAGS_HASH;  // no hash for dec format
    800118c8:	fec42783          	lw	a5,-20(s0)
    800118cc:	9bbd                	andi	a5,a5,-17
    800118ce:	fef42623          	sw	a5,-20(s0)
                }
                // uppercase
                if (*format == 'X') {
    800118d2:	f8043783          	ld	a5,-128(s0)
    800118d6:	0007c783          	lbu	a5,0(a5)
    800118da:	873e                	mv	a4,a5
    800118dc:	05800793          	li	a5,88
    800118e0:	00f71863          	bne	a4,a5,800118f0 <_vsnprintf+0x460>
                    flags |= FLAGS_UPPERCASE;
    800118e4:	fec42783          	lw	a5,-20(s0)
    800118e8:	0207e793          	ori	a5,a5,32
    800118ec:	fef42623          	sw	a5,-20(s0)
                }

                // no plus or space flag for u, x, X, o, b
                if ((*format != 'i') && (*format != 'd')) {
    800118f0:	f8043783          	ld	a5,-128(s0)
    800118f4:	0007c783          	lbu	a5,0(a5)
    800118f8:	873e                	mv	a4,a5
    800118fa:	06900793          	li	a5,105
    800118fe:	02f70063          	beq	a4,a5,8001191e <_vsnprintf+0x48e>
    80011902:	f8043783          	ld	a5,-128(s0)
    80011906:	0007c783          	lbu	a5,0(a5)
    8001190a:	873e                	mv	a4,a5
    8001190c:	06400793          	li	a5,100
    80011910:	00f70763          	beq	a4,a5,8001191e <_vsnprintf+0x48e>
                    flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
    80011914:	fec42783          	lw	a5,-20(s0)
    80011918:	9bcd                	andi	a5,a5,-13
    8001191a:	fef42623          	sw	a5,-20(s0)
                }

                // ignore '0' flag when precision is given
                if (flags & FLAGS_PRECISION) {
    8001191e:	fec42783          	lw	a5,-20(s0)
    80011922:	4007f793          	andi	a5,a5,1024
    80011926:	2781                	sext.w	a5,a5
    80011928:	c791                	beqz	a5,80011934 <_vsnprintf+0x4a4>
                    flags &= ~FLAGS_ZEROPAD;
    8001192a:	fec42783          	lw	a5,-20(s0)
    8001192e:	9bf9                	andi	a5,a5,-2
    80011930:	fef42623          	sw	a5,-20(s0)
                }

                // convert the integer
                if ((*format == 'i') || (*format == 'd')) {
    80011934:	f8043783          	ld	a5,-128(s0)
    80011938:	0007c783          	lbu	a5,0(a5)
    8001193c:	873e                	mv	a4,a5
    8001193e:	06900793          	li	a5,105
    80011942:	00f70b63          	beq	a4,a5,80011958 <_vsnprintf+0x4c8>
    80011946:	f8043783          	ld	a5,-128(s0)
    8001194a:	0007c783          	lbu	a5,0(a5)
    8001194e:	873e                	mv	a4,a5
    80011950:	06400793          	li	a5,100
    80011954:	18f71d63          	bne	a4,a5,80011aee <_vsnprintf+0x65e>
                    // signed
                    if (flags & FLAGS_LONG_LONG) {
    80011958:	fec42783          	lw	a5,-20(s0)
    8001195c:	2007f793          	andi	a5,a5,512
    80011960:	2781                	sext.w	a5,a5
    80011962:	c3bd                	beqz	a5,800119c8 <_vsnprintf+0x538>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        const long long value = va_arg(va, long long);
    80011964:	f7843783          	ld	a5,-136(s0)
    80011968:	00878713          	addi	a4,a5,8
    8001196c:	f6e43c23          	sd	a4,-136(s0)
    80011970:	639c                	ld	a5,0(a5)
    80011972:	faf43023          	sd	a5,-96(s0)
                        idx                   = _ntoa_long_long(
                                              out, buffer, idx, maxlen,
                                              (unsigned long long)(value > 0 ? value : 0 - value),
    80011976:	fa043783          	ld	a5,-96(s0)
    8001197a:	43f7d713          	srai	a4,a5,0x3f
    8001197e:	fa043783          	ld	a5,-96(s0)
    80011982:	8fb9                	xor	a5,a5,a4
    80011984:	8f99                	sub	a5,a5,a4
                        idx                   = _ntoa_long_long(
    80011986:	85be                	mv	a1,a5
    80011988:	fa043783          	ld	a5,-96(s0)
    8001198c:	93fd                	srli	a5,a5,0x3f
    8001198e:	0ff7f713          	andi	a4,a5,255
    80011992:	fd446683          	lwu	a3,-44(s0)
    80011996:	fe442603          	lw	a2,-28(s0)
    8001199a:	fec42783          	lw	a5,-20(s0)
    8001199e:	e43e                	sd	a5,8(sp)
    800119a0:	fe842783          	lw	a5,-24(s0)
    800119a4:	e03e                	sd	a5,0(sp)
    800119a6:	88b2                	mv	a7,a2
    800119a8:	8836                	mv	a6,a3
    800119aa:	87ba                	mv	a5,a4
    800119ac:	872e                	mv	a4,a1
    800119ae:	f8843683          	ld	a3,-120(s0)
    800119b2:	fd843603          	ld	a2,-40(s0)
    800119b6:	f9043583          	ld	a1,-112(s0)
    800119ba:	f9843503          	ld	a0,-104(s0)
    800119be:	fadfe0ef          	jal	ra,8001096a <_ntoa_long_long>
    800119c2:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    800119c6:	ac89                	j	80011c18 <_vsnprintf+0x788>
                                              value < 0, base, precision, width, flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    800119c8:	fec42783          	lw	a5,-20(s0)
    800119cc:	1007f793          	andi	a5,a5,256
    800119d0:	2781                	sext.w	a5,a5
    800119d2:	c3bd                	beqz	a5,80011a38 <_vsnprintf+0x5a8>
                        const long value = va_arg(va, long);
    800119d4:	f7843783          	ld	a5,-136(s0)
    800119d8:	00878713          	addi	a4,a5,8
    800119dc:	f6e43c23          	sd	a4,-136(s0)
    800119e0:	639c                	ld	a5,0(a5)
    800119e2:	faf43423          	sd	a5,-88(s0)
                        idx              = _ntoa_long(
                                         out, buffer, idx, maxlen,
                                         (unsigned long)(value > 0 ? value : 0 - value),
    800119e6:	fa843783          	ld	a5,-88(s0)
    800119ea:	43f7d713          	srai	a4,a5,0x3f
    800119ee:	fa843783          	ld	a5,-88(s0)
    800119f2:	8fb9                	xor	a5,a5,a4
    800119f4:	8f99                	sub	a5,a5,a4
                        idx              = _ntoa_long(
    800119f6:	85be                	mv	a1,a5
    800119f8:	fa843783          	ld	a5,-88(s0)
    800119fc:	93fd                	srli	a5,a5,0x3f
    800119fe:	0ff7f713          	andi	a4,a5,255
    80011a02:	fd446683          	lwu	a3,-44(s0)
    80011a06:	fe442603          	lw	a2,-28(s0)
    80011a0a:	fec42783          	lw	a5,-20(s0)
    80011a0e:	e43e                	sd	a5,8(sp)
    80011a10:	fe842783          	lw	a5,-24(s0)
    80011a14:	e03e                	sd	a5,0(sp)
    80011a16:	88b2                	mv	a7,a2
    80011a18:	8836                	mv	a6,a3
    80011a1a:	87ba                	mv	a5,a4
    80011a1c:	872e                	mv	a4,a1
    80011a1e:	f8843683          	ld	a3,-120(s0)
    80011a22:	fd843603          	ld	a2,-40(s0)
    80011a26:	f9043583          	ld	a1,-112(s0)
    80011a2a:	f9843503          	ld	a0,-104(s0)
    80011a2e:	e25fe0ef          	jal	ra,80010852 <_ntoa_long>
    80011a32:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011a36:	a2cd                	j	80011c18 <_vsnprintf+0x788>
                                         value < 0, base, precision, width, flags);
                    }
                    else {
                        const int value =
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011a38:	fec42783          	lw	a5,-20(s0)
    80011a3c:	0407f793          	andi	a5,a5,64
    80011a40:	2781                	sext.w	a5,a5
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011a42:	cf81                	beqz	a5,80011a5a <_vsnprintf+0x5ca>
                            (flags & FLAGS_CHAR)    ? (char)va_arg(va, int)
    80011a44:	f7843783          	ld	a5,-136(s0)
    80011a48:	00878713          	addi	a4,a5,8
    80011a4c:	f6e43c23          	sd	a4,-136(s0)
    80011a50:	439c                	lw	a5,0(a5)
    80011a52:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011a56:	2781                	sext.w	a5,a5
    80011a58:	a81d                	j	80011a8e <_vsnprintf+0x5fe>
    80011a5a:	fec42783          	lw	a5,-20(s0)
    80011a5e:	0807f793          	andi	a5,a5,128
    80011a62:	2781                	sext.w	a5,a5
                                                    : va_arg(va, int);
    80011a64:	cf91                	beqz	a5,80011a80 <_vsnprintf+0x5f0>
                            : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int)
    80011a66:	f7843783          	ld	a5,-136(s0)
    80011a6a:	00878713          	addi	a4,a5,8
    80011a6e:	f6e43c23          	sd	a4,-136(s0)
    80011a72:	439c                	lw	a5,0(a5)
    80011a74:	0107979b          	slliw	a5,a5,0x10
    80011a78:	4107d79b          	sraiw	a5,a5,0x10
                                                    : va_arg(va, int);
    80011a7c:	2781                	sext.w	a5,a5
    80011a7e:	a801                	j	80011a8e <_vsnprintf+0x5fe>
    80011a80:	f7843783          	ld	a5,-136(s0)
    80011a84:	00878713          	addi	a4,a5,8
    80011a88:	f6e43c23          	sd	a4,-136(s0)
    80011a8c:	439c                	lw	a5,0(a5)
                        const int value =
    80011a8e:	faf42823          	sw	a5,-80(s0)
                        idx = _ntoa_long(
                            out, buffer, idx, maxlen,
                            (unsigned int)(value > 0 ? value : 0 - value),
    80011a92:	fb042783          	lw	a5,-80(s0)
    80011a96:	41f7d79b          	sraiw	a5,a5,0x1f
    80011a9a:	fb042703          	lw	a4,-80(s0)
    80011a9e:	8f3d                	xor	a4,a4,a5
    80011aa0:	40f707bb          	subw	a5,a4,a5
    80011aa4:	2781                	sext.w	a5,a5
    80011aa6:	2781                	sext.w	a5,a5
                        idx = _ntoa_long(
    80011aa8:	02079713          	slli	a4,a5,0x20
    80011aac:	9301                	srli	a4,a4,0x20
    80011aae:	fb042783          	lw	a5,-80(s0)
    80011ab2:	01f7d79b          	srliw	a5,a5,0x1f
    80011ab6:	0ff7f693          	andi	a3,a5,255
    80011aba:	fd446603          	lwu	a2,-44(s0)
    80011abe:	fe442583          	lw	a1,-28(s0)
    80011ac2:	fec42783          	lw	a5,-20(s0)
    80011ac6:	e43e                	sd	a5,8(sp)
    80011ac8:	fe842783          	lw	a5,-24(s0)
    80011acc:	e03e                	sd	a5,0(sp)
    80011ace:	88ae                	mv	a7,a1
    80011ad0:	8832                	mv	a6,a2
    80011ad2:	87b6                	mv	a5,a3
    80011ad4:	f8843683          	ld	a3,-120(s0)
    80011ad8:	fd843603          	ld	a2,-40(s0)
    80011adc:	f9043583          	ld	a1,-112(s0)
    80011ae0:	f9843503          	ld	a0,-104(s0)
    80011ae4:	d6ffe0ef          	jal	ra,80010852 <_ntoa_long>
    80011ae8:	fca43c23          	sd	a0,-40(s0)
                    if (flags & FLAGS_LONG_LONG) {
    80011aec:	a235                	j	80011c18 <_vsnprintf+0x788>
                            value < 0, base, precision, width, flags);
                    }
                }
                else {
                    // unsigned
                    if (flags & FLAGS_LONG_LONG) {
    80011aee:	fec42783          	lw	a5,-20(s0)
    80011af2:	2007f793          	andi	a5,a5,512
    80011af6:	2781                	sext.w	a5,a5
    80011af8:	c3b1                	beqz	a5,80011b3c <_vsnprintf+0x6ac>
#if defined(PRINTF_SUPPORT_LONG_LONG)
                        idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80011afa:	f7843783          	ld	a5,-136(s0)
    80011afe:	00878713          	addi	a4,a5,8
    80011b02:	f6e43c23          	sd	a4,-136(s0)
    80011b06:	6398                	ld	a4,0(a5)
    80011b08:	fd446683          	lwu	a3,-44(s0)
    80011b0c:	fe442603          	lw	a2,-28(s0)
    80011b10:	fec42783          	lw	a5,-20(s0)
    80011b14:	e43e                	sd	a5,8(sp)
    80011b16:	fe842783          	lw	a5,-24(s0)
    80011b1a:	e03e                	sd	a5,0(sp)
    80011b1c:	88b2                	mv	a7,a2
    80011b1e:	8836                	mv	a6,a3
    80011b20:	4781                	li	a5,0
    80011b22:	f8843683          	ld	a3,-120(s0)
    80011b26:	fd843603          	ld	a2,-40(s0)
    80011b2a:	f9043583          	ld	a1,-112(s0)
    80011b2e:	f9843503          	ld	a0,-104(s0)
    80011b32:	e39fe0ef          	jal	ra,8001096a <_ntoa_long_long>
    80011b36:	fca43c23          	sd	a0,-40(s0)
    80011b3a:	a8f9                	j	80011c18 <_vsnprintf+0x788>
                                              va_arg(va, unsigned long long),
                                              false, base, precision, width,
                                              flags);
#endif
                    }
                    else if (flags & FLAGS_LONG) {
    80011b3c:	fec42783          	lw	a5,-20(s0)
    80011b40:	1007f793          	andi	a5,a5,256
    80011b44:	2781                	sext.w	a5,a5
    80011b46:	c3b1                	beqz	a5,80011b8a <_vsnprintf+0x6fa>
                        idx = _ntoa_long(out, buffer, idx, maxlen,
    80011b48:	f7843783          	ld	a5,-136(s0)
    80011b4c:	00878713          	addi	a4,a5,8
    80011b50:	f6e43c23          	sd	a4,-136(s0)
    80011b54:	6398                	ld	a4,0(a5)
    80011b56:	fd446683          	lwu	a3,-44(s0)
    80011b5a:	fe442603          	lw	a2,-28(s0)
    80011b5e:	fec42783          	lw	a5,-20(s0)
    80011b62:	e43e                	sd	a5,8(sp)
    80011b64:	fe842783          	lw	a5,-24(s0)
    80011b68:	e03e                	sd	a5,0(sp)
    80011b6a:	88b2                	mv	a7,a2
    80011b6c:	8836                	mv	a6,a3
    80011b6e:	4781                	li	a5,0
    80011b70:	f8843683          	ld	a3,-120(s0)
    80011b74:	fd843603          	ld	a2,-40(s0)
    80011b78:	f9043583          	ld	a1,-112(s0)
    80011b7c:	f9843503          	ld	a0,-104(s0)
    80011b80:	cd3fe0ef          	jal	ra,80010852 <_ntoa_long>
    80011b84:	fca43c23          	sd	a0,-40(s0)
    80011b88:	a841                	j	80011c18 <_vsnprintf+0x788>
                                         va_arg(va, unsigned long), false, base,
                                         precision, width, flags);
                    }
                    else {
                        const unsigned int value =
                            (flags & FLAGS_CHAR)
    80011b8a:	fec42783          	lw	a5,-20(s0)
    80011b8e:	0407f793          	andi	a5,a5,64
    80011b92:	2781                	sext.w	a5,a5
                                ? (unsigned char)va_arg(va, unsigned int)
                            : (flags & FLAGS_SHORT)
    80011b94:	cf81                	beqz	a5,80011bac <_vsnprintf+0x71c>
                                ? (unsigned char)va_arg(va, unsigned int)
    80011b96:	f7843783          	ld	a5,-136(s0)
    80011b9a:	00878713          	addi	a4,a5,8
    80011b9e:	f6e43c23          	sd	a4,-136(s0)
    80011ba2:	439c                	lw	a5,0(a5)
    80011ba4:	0ff7f793          	andi	a5,a5,255
                            : (flags & FLAGS_SHORT)
    80011ba8:	2781                	sext.w	a5,a5
    80011baa:	a815                	j	80011bde <_vsnprintf+0x74e>
    80011bac:	fec42783          	lw	a5,-20(s0)
    80011bb0:	0807f793          	andi	a5,a5,128
    80011bb4:	2781                	sext.w	a5,a5
                                ? (unsigned short int)va_arg(va, unsigned int)
                                : va_arg(va, unsigned int);
    80011bb6:	cf81                	beqz	a5,80011bce <_vsnprintf+0x73e>
                                ? (unsigned short int)va_arg(va, unsigned int)
    80011bb8:	f7843783          	ld	a5,-136(s0)
    80011bbc:	00878713          	addi	a4,a5,8
    80011bc0:	f6e43c23          	sd	a4,-136(s0)
    80011bc4:	439c                	lw	a5,0(a5)
    80011bc6:	17c2                	slli	a5,a5,0x30
    80011bc8:	93c1                	srli	a5,a5,0x30
                                : va_arg(va, unsigned int);
    80011bca:	2781                	sext.w	a5,a5
    80011bcc:	a801                	j	80011bdc <_vsnprintf+0x74c>
    80011bce:	f7843783          	ld	a5,-136(s0)
    80011bd2:	00878713          	addi	a4,a5,8
    80011bd6:	f6e43c23          	sd	a4,-136(s0)
    80011bda:	439c                	lw	a5,0(a5)
                            : (flags & FLAGS_SHORT)
    80011bdc:	2781                	sext.w	a5,a5
                        const unsigned int value =
    80011bde:	faf42a23          	sw	a5,-76(s0)
                        idx = _ntoa_long(out, buffer, idx, maxlen, value, false,
    80011be2:	fb446703          	lwu	a4,-76(s0)
    80011be6:	fd446683          	lwu	a3,-44(s0)
    80011bea:	fe442603          	lw	a2,-28(s0)
    80011bee:	fec42783          	lw	a5,-20(s0)
    80011bf2:	e43e                	sd	a5,8(sp)
    80011bf4:	fe842783          	lw	a5,-24(s0)
    80011bf8:	e03e                	sd	a5,0(sp)
    80011bfa:	88b2                	mv	a7,a2
    80011bfc:	8836                	mv	a6,a3
    80011bfe:	4781                	li	a5,0
    80011c00:	f8843683          	ld	a3,-120(s0)
    80011c04:	fd843603          	ld	a2,-40(s0)
    80011c08:	f9043583          	ld	a1,-112(s0)
    80011c0c:	f9843503          	ld	a0,-104(s0)
    80011c10:	c43fe0ef          	jal	ra,80010852 <_ntoa_long>
    80011c14:	fca43c23          	sd	a0,-40(s0)
                                         base, precision, width, flags);
                    }
                }
                format++;
    80011c18:	f8043783          	ld	a5,-128(s0)
    80011c1c:	0785                	addi	a5,a5,1
    80011c1e:	f8f43023          	sd	a5,-128(s0)
                break;
    80011c22:	a919                	j	80012038 <_vsnprintf+0xba8>
            }
#if defined(PRINTF_SUPPORT_FLOAT)
            case 'f':
            case 'F':
                if (*format == 'F')
    80011c24:	f8043783          	ld	a5,-128(s0)
    80011c28:	0007c783          	lbu	a5,0(a5)
    80011c2c:	873e                	mv	a4,a5
    80011c2e:	04600793          	li	a5,70
    80011c32:	00f71863          	bne	a4,a5,80011c42 <_vsnprintf+0x7b2>
                    flags |= FLAGS_UPPERCASE;
    80011c36:	fec42783          	lw	a5,-20(s0)
    80011c3a:	0207e793          	ori	a5,a5,32
    80011c3e:	fef42623          	sw	a5,-20(s0)
                idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011c42:	f7843783          	ld	a5,-136(s0)
    80011c46:	00878713          	addi	a4,a5,8
    80011c4a:	f6e43c23          	sd	a4,-136(s0)
    80011c4e:	239c                	fld	fa5,0(a5)
    80011c50:	fec42683          	lw	a3,-20(s0)
    80011c54:	fe842783          	lw	a5,-24(s0)
    80011c58:	fe442703          	lw	a4,-28(s0)
    80011c5c:	8836                	mv	a6,a3
    80011c5e:	22f78553          	fmv.d	fa0,fa5
    80011c62:	f8843683          	ld	a3,-120(s0)
    80011c66:	fd843603          	ld	a2,-40(s0)
    80011c6a:	f9043583          	ld	a1,-112(s0)
    80011c6e:	f9843503          	ld	a0,-104(s0)
    80011c72:	e11fe0ef          	jal	ra,80010a82 <_ftoa>
    80011c76:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011c7a:	f8043783          	ld	a5,-128(s0)
    80011c7e:	0785                	addi	a5,a5,1
    80011c80:	f8f43023          	sd	a5,-128(s0)
                break;
    80011c84:	ae55                	j	80012038 <_vsnprintf+0xba8>
#if defined(PRINTF_SUPPORT_EXPONENTIAL)
            case 'e':
            case 'E':
            case 'g':
            case 'G':
                if ((*format == 'g') || (*format == 'G'))
    80011c86:	f8043783          	ld	a5,-128(s0)
    80011c8a:	0007c783          	lbu	a5,0(a5)
    80011c8e:	873e                	mv	a4,a5
    80011c90:	06700793          	li	a5,103
    80011c94:	00f70b63          	beq	a4,a5,80011caa <_vsnprintf+0x81a>
    80011c98:	f8043783          	ld	a5,-128(s0)
    80011c9c:	0007c783          	lbu	a5,0(a5)
    80011ca0:	873e                	mv	a4,a5
    80011ca2:	04700793          	li	a5,71
    80011ca6:	00f71a63          	bne	a4,a5,80011cba <_vsnprintf+0x82a>
                    flags |= FLAGS_ADAPT_EXP;
    80011caa:	fec42703          	lw	a4,-20(s0)
    80011cae:	6785                	lui	a5,0x1
    80011cb0:	80078793          	addi	a5,a5,-2048 # 800 <i+0x7e0>
    80011cb4:	8fd9                	or	a5,a5,a4
    80011cb6:	fef42623          	sw	a5,-20(s0)
                if ((*format == 'E') || (*format == 'G'))
    80011cba:	f8043783          	ld	a5,-128(s0)
    80011cbe:	0007c783          	lbu	a5,0(a5)
    80011cc2:	873e                	mv	a4,a5
    80011cc4:	04500793          	li	a5,69
    80011cc8:	00f70b63          	beq	a4,a5,80011cde <_vsnprintf+0x84e>
    80011ccc:	f8043783          	ld	a5,-128(s0)
    80011cd0:	0007c783          	lbu	a5,0(a5)
    80011cd4:	873e                	mv	a4,a5
    80011cd6:	04700793          	li	a5,71
    80011cda:	00f71863          	bne	a4,a5,80011cea <_vsnprintf+0x85a>
                    flags |= FLAGS_UPPERCASE;
    80011cde:	fec42783          	lw	a5,-20(s0)
    80011ce2:	0207e793          	ori	a5,a5,32
    80011ce6:	fef42623          	sw	a5,-20(s0)
                idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double),
    80011cea:	f7843783          	ld	a5,-136(s0)
    80011cee:	00878713          	addi	a4,a5,8
    80011cf2:	f6e43c23          	sd	a4,-136(s0)
    80011cf6:	239c                	fld	fa5,0(a5)
    80011cf8:	fec42683          	lw	a3,-20(s0)
    80011cfc:	fe842783          	lw	a5,-24(s0)
    80011d00:	fe442703          	lw	a4,-28(s0)
    80011d04:	8836                	mv	a6,a3
    80011d06:	22f78553          	fmv.d	fa0,fa5
    80011d0a:	f8843683          	ld	a3,-120(s0)
    80011d0e:	fd843603          	ld	a2,-40(s0)
    80011d12:	f9043583          	ld	a1,-112(s0)
    80011d16:	f9843503          	ld	a0,-104(s0)
    80011d1a:	ab4ff0ef          	jal	ra,80010fce <_etoa>
    80011d1e:	fca43c23          	sd	a0,-40(s0)
                            precision, width, flags);
                format++;
    80011d22:	f8043783          	ld	a5,-128(s0)
    80011d26:	0785                	addi	a5,a5,1
    80011d28:	f8f43023          	sd	a5,-128(s0)
                break;
    80011d2c:	a631                	j	80012038 <_vsnprintf+0xba8>
#endif  // PRINTF_SUPPORT_EXPONENTIAL
#endif  // PRINTF_SUPPORT_FLOAT
            case 'c': {
                unsigned int l = 1U;
    80011d2e:	4785                	li	a5,1
    80011d30:	fcf42823          	sw	a5,-48(s0)
                // pre padding
                if (!(flags & FLAGS_LEFT)) {
    80011d34:	fec42783          	lw	a5,-20(s0)
    80011d38:	8b89                	andi	a5,a5,2
    80011d3a:	2781                	sext.w	a5,a5
    80011d3c:	ef8d                	bnez	a5,80011d76 <_vsnprintf+0x8e6>
                    while (l++ < width) {
    80011d3e:	a00d                	j	80011d60 <_vsnprintf+0x8d0>
                        out(' ', buffer, idx++, maxlen);
    80011d40:	fd843783          	ld	a5,-40(s0)
    80011d44:	00178713          	addi	a4,a5,1
    80011d48:	fce43c23          	sd	a4,-40(s0)
    80011d4c:	f9843703          	ld	a4,-104(s0)
    80011d50:	f8843683          	ld	a3,-120(s0)
    80011d54:	863e                	mv	a2,a5
    80011d56:	f9043583          	ld	a1,-112(s0)
    80011d5a:	02000513          	li	a0,32
    80011d5e:	9702                	jalr	a4
                    while (l++ < width) {
    80011d60:	fd042783          	lw	a5,-48(s0)
    80011d64:	0017871b          	addiw	a4,a5,1
    80011d68:	fce42823          	sw	a4,-48(s0)
    80011d6c:	fe842703          	lw	a4,-24(s0)
    80011d70:	2701                	sext.w	a4,a4
    80011d72:	fce7e7e3          	bltu	a5,a4,80011d40 <_vsnprintf+0x8b0>
                    }
                }
                // char output
                out((char)va_arg(va, int), buffer, idx++, maxlen);
    80011d76:	f7843783          	ld	a5,-136(s0)
    80011d7a:	00878713          	addi	a4,a5,8
    80011d7e:	f6e43c23          	sd	a4,-136(s0)
    80011d82:	439c                	lw	a5,0(a5)
    80011d84:	0ff7f513          	andi	a0,a5,255
    80011d88:	fd843783          	ld	a5,-40(s0)
    80011d8c:	00178713          	addi	a4,a5,1
    80011d90:	fce43c23          	sd	a4,-40(s0)
    80011d94:	f9843703          	ld	a4,-104(s0)
    80011d98:	f8843683          	ld	a3,-120(s0)
    80011d9c:	863e                	mv	a2,a5
    80011d9e:	f9043583          	ld	a1,-112(s0)
    80011da2:	9702                	jalr	a4
                // post padding
                if (flags & FLAGS_LEFT) {
    80011da4:	fec42783          	lw	a5,-20(s0)
    80011da8:	8b89                	andi	a5,a5,2
    80011daa:	2781                	sext.w	a5,a5
    80011dac:	cf8d                	beqz	a5,80011de6 <_vsnprintf+0x956>
                    while (l++ < width) {
    80011dae:	a00d                	j	80011dd0 <_vsnprintf+0x940>
                        out(' ', buffer, idx++, maxlen);
    80011db0:	fd843783          	ld	a5,-40(s0)
    80011db4:	00178713          	addi	a4,a5,1
    80011db8:	fce43c23          	sd	a4,-40(s0)
    80011dbc:	f9843703          	ld	a4,-104(s0)
    80011dc0:	f8843683          	ld	a3,-120(s0)
    80011dc4:	863e                	mv	a2,a5
    80011dc6:	f9043583          	ld	a1,-112(s0)
    80011dca:	02000513          	li	a0,32
    80011dce:	9702                	jalr	a4
                    while (l++ < width) {
    80011dd0:	fd042783          	lw	a5,-48(s0)
    80011dd4:	0017871b          	addiw	a4,a5,1
    80011dd8:	fce42823          	sw	a4,-48(s0)
    80011ddc:	fe842703          	lw	a4,-24(s0)
    80011de0:	2701                	sext.w	a4,a4
    80011de2:	fce7e7e3          	bltu	a5,a4,80011db0 <_vsnprintf+0x920>
                    }
                }
                format++;
    80011de6:	f8043783          	ld	a5,-128(s0)
    80011dea:	0785                	addi	a5,a5,1
    80011dec:	f8f43023          	sd	a5,-128(s0)
                break;
    80011df0:	a4a1                	j	80012038 <_vsnprintf+0xba8>
            }

            case 's': {
                const char *p = va_arg(va, char *);
    80011df2:	f7843783          	ld	a5,-136(s0)
    80011df6:	00878713          	addi	a4,a5,8
    80011dfa:	f6e43c23          	sd	a4,-136(s0)
    80011dfe:	639c                	ld	a5,0(a5)
    80011e00:	fcf43423          	sd	a5,-56(s0)
                unsigned int l =
                    _strnlen_s(p, precision ? precision : (size_t)-1);
    80011e04:	fe442783          	lw	a5,-28(s0)
    80011e08:	2781                	sext.w	a5,a5
    80011e0a:	c781                	beqz	a5,80011e12 <_vsnprintf+0x982>
    80011e0c:	fe446783          	lwu	a5,-28(s0)
    80011e10:	a011                	j	80011e14 <_vsnprintf+0x984>
    80011e12:	57fd                	li	a5,-1
    80011e14:	85be                	mv	a1,a5
    80011e16:	fc843503          	ld	a0,-56(s0)
    80011e1a:	d92fe0ef          	jal	ra,800103ac <_strnlen_s>
    80011e1e:	87aa                	mv	a5,a0
    80011e20:	fcf42223          	sw	a5,-60(s0)
                // pre padding
                if (flags & FLAGS_PRECISION) {
    80011e24:	fec42783          	lw	a5,-20(s0)
    80011e28:	4007f793          	andi	a5,a5,1024
    80011e2c:	2781                	sext.w	a5,a5
    80011e2e:	cf91                	beqz	a5,80011e4a <_vsnprintf+0x9ba>
                    l = (l < precision ? l : precision);
    80011e30:	fc442603          	lw	a2,-60(s0)
    80011e34:	fe442783          	lw	a5,-28(s0)
    80011e38:	0007869b          	sext.w	a3,a5
    80011e3c:	0006071b          	sext.w	a4,a2
    80011e40:	00d77363          	bgeu	a4,a3,80011e46 <_vsnprintf+0x9b6>
    80011e44:	87b2                	mv	a5,a2
    80011e46:	fcf42223          	sw	a5,-60(s0)
                }
                if (!(flags & FLAGS_LEFT)) {
    80011e4a:	fec42783          	lw	a5,-20(s0)
    80011e4e:	8b89                	andi	a5,a5,2
    80011e50:	2781                	sext.w	a5,a5
    80011e52:	e7a5                	bnez	a5,80011eba <_vsnprintf+0xa2a>
                    while (l++ < width) {
    80011e54:	a00d                	j	80011e76 <_vsnprintf+0x9e6>
                        out(' ', buffer, idx++, maxlen);
    80011e56:	fd843783          	ld	a5,-40(s0)
    80011e5a:	00178713          	addi	a4,a5,1
    80011e5e:	fce43c23          	sd	a4,-40(s0)
    80011e62:	f9843703          	ld	a4,-104(s0)
    80011e66:	f8843683          	ld	a3,-120(s0)
    80011e6a:	863e                	mv	a2,a5
    80011e6c:	f9043583          	ld	a1,-112(s0)
    80011e70:	02000513          	li	a0,32
    80011e74:	9702                	jalr	a4
                    while (l++ < width) {
    80011e76:	fc442783          	lw	a5,-60(s0)
    80011e7a:	0017871b          	addiw	a4,a5,1
    80011e7e:	fce42223          	sw	a4,-60(s0)
    80011e82:	fe842703          	lw	a4,-24(s0)
    80011e86:	2701                	sext.w	a4,a4
    80011e88:	fce7e7e3          	bltu	a5,a4,80011e56 <_vsnprintf+0x9c6>
                    }
                }
                // string output
                while ((*p != 0) &&
    80011e8c:	a03d                	j	80011eba <_vsnprintf+0xa2a>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
                    out(*(p++), buffer, idx++, maxlen);
    80011e8e:	fc843783          	ld	a5,-56(s0)
    80011e92:	00178713          	addi	a4,a5,1
    80011e96:	fce43423          	sd	a4,-56(s0)
    80011e9a:	0007c503          	lbu	a0,0(a5)
    80011e9e:	fd843783          	ld	a5,-40(s0)
    80011ea2:	00178713          	addi	a4,a5,1
    80011ea6:	fce43c23          	sd	a4,-40(s0)
    80011eaa:	f9843703          	ld	a4,-104(s0)
    80011eae:	f8843683          	ld	a3,-120(s0)
    80011eb2:	863e                	mv	a2,a5
    80011eb4:	f9043583          	ld	a1,-112(s0)
    80011eb8:	9702                	jalr	a4
                while ((*p != 0) &&
    80011eba:	fc843783          	ld	a5,-56(s0)
    80011ebe:	0007c783          	lbu	a5,0(a5)
    80011ec2:	cf91                	beqz	a5,80011ede <_vsnprintf+0xa4e>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    80011ec4:	fec42783          	lw	a5,-20(s0)
    80011ec8:	4007f793          	andi	a5,a5,1024
    80011ecc:	2781                	sext.w	a5,a5
                while ((*p != 0) &&
    80011ece:	d3e1                	beqz	a5,80011e8e <_vsnprintf+0x9fe>
                       (!(flags & FLAGS_PRECISION) || precision--)) {
    80011ed0:	fe442783          	lw	a5,-28(s0)
    80011ed4:	fff7871b          	addiw	a4,a5,-1
    80011ed8:	fee42223          	sw	a4,-28(s0)
    80011edc:	fbcd                	bnez	a5,80011e8e <_vsnprintf+0x9fe>
                }
                // post padding
                if (flags & FLAGS_LEFT) {
    80011ede:	fec42783          	lw	a5,-20(s0)
    80011ee2:	8b89                	andi	a5,a5,2
    80011ee4:	2781                	sext.w	a5,a5
    80011ee6:	cf8d                	beqz	a5,80011f20 <_vsnprintf+0xa90>
                    while (l++ < width) {
    80011ee8:	a00d                	j	80011f0a <_vsnprintf+0xa7a>
                        out(' ', buffer, idx++, maxlen);
    80011eea:	fd843783          	ld	a5,-40(s0)
    80011eee:	00178713          	addi	a4,a5,1
    80011ef2:	fce43c23          	sd	a4,-40(s0)
    80011ef6:	f9843703          	ld	a4,-104(s0)
    80011efa:	f8843683          	ld	a3,-120(s0)
    80011efe:	863e                	mv	a2,a5
    80011f00:	f9043583          	ld	a1,-112(s0)
    80011f04:	02000513          	li	a0,32
    80011f08:	9702                	jalr	a4
                    while (l++ < width) {
    80011f0a:	fc442783          	lw	a5,-60(s0)
    80011f0e:	0017871b          	addiw	a4,a5,1
    80011f12:	fce42223          	sw	a4,-60(s0)
    80011f16:	fe842703          	lw	a4,-24(s0)
    80011f1a:	2701                	sext.w	a4,a4
    80011f1c:	fce7e7e3          	bltu	a5,a4,80011eea <_vsnprintf+0xa5a>
                    }
                }
                format++;
    80011f20:	f8043783          	ld	a5,-128(s0)
    80011f24:	0785                	addi	a5,a5,1
    80011f26:	f8f43023          	sd	a5,-128(s0)
                break;
    80011f2a:	a239                	j	80012038 <_vsnprintf+0xba8>
            }

            case 'p': {
                width = sizeof(void *) * 2U;
    80011f2c:	47c1                	li	a5,16
    80011f2e:	fef42423          	sw	a5,-24(s0)
                flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
    80011f32:	fec42783          	lw	a5,-20(s0)
    80011f36:	0217e793          	ori	a5,a5,33
    80011f3a:	fef42623          	sw	a5,-20(s0)
#if defined(PRINTF_SUPPORT_LONG_LONG)
                const bool is_ll = sizeof(uintptr_t) == sizeof(long long);
    80011f3e:	4785                	li	a5,1
    80011f40:	faf40da3          	sb	a5,-69(s0)
                if (is_ll) {
    80011f44:	fbb44783          	lbu	a5,-69(s0)
    80011f48:	0ff7f793          	andi	a5,a5,255
    80011f4c:	c3b1                	beqz	a5,80011f90 <_vsnprintf+0xb00>
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
                                          (uintptr_t)va_arg(va, void *), false,
    80011f4e:	f7843783          	ld	a5,-136(s0)
    80011f52:	00878713          	addi	a4,a5,8
    80011f56:	f6e43c23          	sd	a4,-136(s0)
    80011f5a:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long_long(out, buffer, idx, maxlen,
    80011f5c:	86be                	mv	a3,a5
    80011f5e:	fe442703          	lw	a4,-28(s0)
    80011f62:	fec42783          	lw	a5,-20(s0)
    80011f66:	e43e                	sd	a5,8(sp)
    80011f68:	fe842783          	lw	a5,-24(s0)
    80011f6c:	e03e                	sd	a5,0(sp)
    80011f6e:	88ba                	mv	a7,a4
    80011f70:	4841                	li	a6,16
    80011f72:	4781                	li	a5,0
    80011f74:	8736                	mv	a4,a3
    80011f76:	f8843683          	ld	a3,-120(s0)
    80011f7a:	fd843603          	ld	a2,-40(s0)
    80011f7e:	f9043583          	ld	a1,-112(s0)
    80011f82:	f9843503          	ld	a0,-104(s0)
    80011f86:	9e5fe0ef          	jal	ra,8001096a <_ntoa_long_long>
    80011f8a:	fca43c23          	sd	a0,-40(s0)
    80011f8e:	a089                	j	80011fd0 <_vsnprintf+0xb40>
                }
                else {
#endif
                    idx = _ntoa_long(
                        out, buffer, idx, maxlen,
                        (unsigned long)((uintptr_t)va_arg(va, void *)), false,
    80011f90:	f7843783          	ld	a5,-136(s0)
    80011f94:	00878713          	addi	a4,a5,8
    80011f98:	f6e43c23          	sd	a4,-136(s0)
    80011f9c:	639c                	ld	a5,0(a5)
                    idx = _ntoa_long(
    80011f9e:	86be                	mv	a3,a5
    80011fa0:	fe442703          	lw	a4,-28(s0)
    80011fa4:	fec42783          	lw	a5,-20(s0)
    80011fa8:	e43e                	sd	a5,8(sp)
    80011faa:	fe842783          	lw	a5,-24(s0)
    80011fae:	e03e                	sd	a5,0(sp)
    80011fb0:	88ba                	mv	a7,a4
    80011fb2:	4841                	li	a6,16
    80011fb4:	4781                	li	a5,0
    80011fb6:	8736                	mv	a4,a3
    80011fb8:	f8843683          	ld	a3,-120(s0)
    80011fbc:	fd843603          	ld	a2,-40(s0)
    80011fc0:	f9043583          	ld	a1,-112(s0)
    80011fc4:	f9843503          	ld	a0,-104(s0)
    80011fc8:	88bfe0ef          	jal	ra,80010852 <_ntoa_long>
    80011fcc:	fca43c23          	sd	a0,-40(s0)
                        16U, precision, width, flags);
#if defined(PRINTF_SUPPORT_LONG_LONG)
                }
#endif
                format++;
    80011fd0:	f8043783          	ld	a5,-128(s0)
    80011fd4:	0785                	addi	a5,a5,1
    80011fd6:	f8f43023          	sd	a5,-128(s0)
                break;
    80011fda:	a8b9                	j	80012038 <_vsnprintf+0xba8>
            }

            case '%':
                out('%', buffer, idx++, maxlen);
    80011fdc:	fd843783          	ld	a5,-40(s0)
    80011fe0:	00178713          	addi	a4,a5,1
    80011fe4:	fce43c23          	sd	a4,-40(s0)
    80011fe8:	f9843703          	ld	a4,-104(s0)
    80011fec:	f8843683          	ld	a3,-120(s0)
    80011ff0:	863e                	mv	a2,a5
    80011ff2:	f9043583          	ld	a1,-112(s0)
    80011ff6:	02500513          	li	a0,37
    80011ffa:	9702                	jalr	a4
                format++;
    80011ffc:	f8043783          	ld	a5,-128(s0)
    80012000:	0785                	addi	a5,a5,1
    80012002:	f8f43023          	sd	a5,-128(s0)
                break;
    80012006:	a80d                	j	80012038 <_vsnprintf+0xba8>

            default:
                out(*format, buffer, idx++, maxlen);
    80012008:	f8043783          	ld	a5,-128(s0)
    8001200c:	0007c503          	lbu	a0,0(a5)
    80012010:	fd843783          	ld	a5,-40(s0)
    80012014:	00178713          	addi	a4,a5,1
    80012018:	fce43c23          	sd	a4,-40(s0)
    8001201c:	f9843703          	ld	a4,-104(s0)
    80012020:	f8843683          	ld	a3,-120(s0)
    80012024:	863e                	mv	a2,a5
    80012026:	f9043583          	ld	a1,-112(s0)
    8001202a:	9702                	jalr	a4
                format++;
    8001202c:	f8043783          	ld	a5,-128(s0)
    80012030:	0785                	addi	a5,a5,1
    80012032:	f8f43023          	sd	a5,-128(s0)
                break;
    80012036:	0001                	nop
    while (*format) {
    80012038:	f8043783          	ld	a5,-128(s0)
    8001203c:	0007c783          	lbu	a5,0(a5)
    80012040:	c8079463          	bnez	a5,800114c8 <_vsnprintf+0x38>
        }
    }

    // termination
    out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
    80012044:	fd843703          	ld	a4,-40(s0)
    80012048:	f8843783          	ld	a5,-120(s0)
    8001204c:	00f76663          	bltu	a4,a5,80012058 <_vsnprintf+0xbc8>
    80012050:	f8843783          	ld	a5,-120(s0)
    80012054:	17fd                	addi	a5,a5,-1
    80012056:	a019                	j	8001205c <_vsnprintf+0xbcc>
    80012058:	fd843783          	ld	a5,-40(s0)
    8001205c:	f9843703          	ld	a4,-104(s0)
    80012060:	f8843683          	ld	a3,-120(s0)
    80012064:	863e                	mv	a2,a5
    80012066:	f9043583          	ld	a1,-112(s0)
    8001206a:	4501                	li	a0,0
    8001206c:	9702                	jalr	a4

    // return written chars without terminating \0
    return (int)idx;
    8001206e:	fd843783          	ld	a5,-40(s0)
    80012072:	2781                	sext.w	a5,a5
}
    80012074:	853e                	mv	a0,a5
    80012076:	60ea                	ld	ra,152(sp)
    80012078:	644a                	ld	s0,144(sp)
    8001207a:	610d                	addi	sp,sp,160
    8001207c:	8082                	ret

000000008001207e <printk>:

///////////////////////////////////////////////////////////////////////////////

int printk(const char *format, ...)
{
    8001207e:	7119                	addi	sp,sp,-128
    80012080:	fc06                	sd	ra,56(sp)
    80012082:	f822                	sd	s0,48(sp)
    80012084:	0080                	addi	s0,sp,64
    80012086:	fca43423          	sd	a0,-56(s0)
    8001208a:	e40c                	sd	a1,8(s0)
    8001208c:	e810                	sd	a2,16(s0)
    8001208e:	ec14                	sd	a3,24(s0)
    80012090:	f018                	sd	a4,32(s0)
    80012092:	f41c                	sd	a5,40(s0)
    80012094:	03043823          	sd	a6,48(s0)
    80012098:	03143c23          	sd	a7,56(s0)
    va_list va;
    va_start(va, format);
    8001209c:	04040793          	addi	a5,s0,64
    800120a0:	fcf43023          	sd	a5,-64(s0)
    800120a4:	fc043783          	ld	a5,-64(s0)
    800120a8:	fc878793          	addi	a5,a5,-56
    800120ac:	fef43023          	sd	a5,-32(s0)
    char buffer[1];
    const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    800120b0:	fe043703          	ld	a4,-32(s0)
    800120b4:	fd840793          	addi	a5,s0,-40
    800120b8:	fc843683          	ld	a3,-56(s0)
    800120bc:	567d                	li	a2,-1
    800120be:	85be                	mv	a1,a5
    800120c0:	ffffe517          	auipc	a0,0xffffe
    800120c4:	27050513          	addi	a0,a0,624 # 80010330 <_out_char>
    800120c8:	bc8ff0ef          	jal	ra,80011490 <_vsnprintf>
    800120cc:	87aa                	mv	a5,a0
    800120ce:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    800120d2:	fec42783          	lw	a5,-20(s0)
}
    800120d6:	853e                	mv	a0,a5
    800120d8:	70e2                	ld	ra,56(sp)
    800120da:	7442                	ld	s0,48(sp)
    800120dc:	6109                	addi	sp,sp,128
    800120de:	8082                	ret

00000000800120e0 <sprintf>:

int sprintf(char *buffer, const char *format, ...)
{
    800120e0:	7159                	addi	sp,sp,-112
    800120e2:	fc06                	sd	ra,56(sp)
    800120e4:	f822                	sd	s0,48(sp)
    800120e6:	0080                	addi	s0,sp,64
    800120e8:	fca43c23          	sd	a0,-40(s0)
    800120ec:	fcb43823          	sd	a1,-48(s0)
    800120f0:	e010                	sd	a2,0(s0)
    800120f2:	e414                	sd	a3,8(s0)
    800120f4:	e818                	sd	a4,16(s0)
    800120f6:	ec1c                	sd	a5,24(s0)
    800120f8:	03043023          	sd	a6,32(s0)
    800120fc:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80012100:	03040793          	addi	a5,s0,48
    80012104:	fcf43423          	sd	a5,-56(s0)
    80012108:	fc843783          	ld	a5,-56(s0)
    8001210c:	fd078793          	addi	a5,a5,-48
    80012110:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
    80012114:	fe043783          	ld	a5,-32(s0)
    80012118:	873e                	mv	a4,a5
    8001211a:	fd043683          	ld	a3,-48(s0)
    8001211e:	567d                	li	a2,-1
    80012120:	fd843583          	ld	a1,-40(s0)
    80012124:	ffffe517          	auipc	a0,0xffffe
    80012128:	1ae50513          	addi	a0,a0,430 # 800102d2 <_out_buffer>
    8001212c:	b64ff0ef          	jal	ra,80011490 <_vsnprintf>
    80012130:	87aa                	mv	a5,a0
    80012132:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    80012136:	fec42783          	lw	a5,-20(s0)
}
    8001213a:	853e                	mv	a0,a5
    8001213c:	70e2                	ld	ra,56(sp)
    8001213e:	7442                	ld	s0,48(sp)
    80012140:	6165                	addi	sp,sp,112
    80012142:	8082                	ret

0000000080012144 <snprintf>:

int snprintf(char *buffer, size_t count, const char *format, ...)
{
    80012144:	7159                	addi	sp,sp,-112
    80012146:	fc06                	sd	ra,56(sp)
    80012148:	f822                	sd	s0,48(sp)
    8001214a:	0080                	addi	s0,sp,64
    8001214c:	fca43c23          	sd	a0,-40(s0)
    80012150:	fcb43823          	sd	a1,-48(s0)
    80012154:	fcc43423          	sd	a2,-56(s0)
    80012158:	e414                	sd	a3,8(s0)
    8001215a:	e818                	sd	a4,16(s0)
    8001215c:	ec1c                	sd	a5,24(s0)
    8001215e:	03043023          	sd	a6,32(s0)
    80012162:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80012166:	03040793          	addi	a5,s0,48
    8001216a:	fcf43023          	sd	a5,-64(s0)
    8001216e:	fc043783          	ld	a5,-64(s0)
    80012172:	fd878793          	addi	a5,a5,-40
    80012176:	fef43023          	sd	a5,-32(s0)
    const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
    8001217a:	fe043783          	ld	a5,-32(s0)
    8001217e:	873e                	mv	a4,a5
    80012180:	fc843683          	ld	a3,-56(s0)
    80012184:	fd043603          	ld	a2,-48(s0)
    80012188:	fd843583          	ld	a1,-40(s0)
    8001218c:	ffffe517          	auipc	a0,0xffffe
    80012190:	14650513          	addi	a0,a0,326 # 800102d2 <_out_buffer>
    80012194:	afcff0ef          	jal	ra,80011490 <_vsnprintf>
    80012198:	87aa                	mv	a5,a0
    8001219a:	fef42623          	sw	a5,-20(s0)
    va_end(va);
    return ret;
    8001219e:	fec42783          	lw	a5,-20(s0)
}
    800121a2:	853e                	mv	a0,a5
    800121a4:	70e2                	ld	ra,56(sp)
    800121a6:	7442                	ld	s0,48(sp)
    800121a8:	6165                	addi	sp,sp,112
    800121aa:	8082                	ret

00000000800121ac <vprintf_>:

int vprintf_(const char *format, va_list va)
{
    800121ac:	7179                	addi	sp,sp,-48
    800121ae:	f406                	sd	ra,40(sp)
    800121b0:	f022                	sd	s0,32(sp)
    800121b2:	1800                	addi	s0,sp,48
    800121b4:	fca43c23          	sd	a0,-40(s0)
    800121b8:	fcb43823          	sd	a1,-48(s0)
    char buffer[1];
    return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
    800121bc:	fe840793          	addi	a5,s0,-24
    800121c0:	fd043703          	ld	a4,-48(s0)
    800121c4:	fd843683          	ld	a3,-40(s0)
    800121c8:	567d                	li	a2,-1
    800121ca:	85be                	mv	a1,a5
    800121cc:	ffffe517          	auipc	a0,0xffffe
    800121d0:	16450513          	addi	a0,a0,356 # 80010330 <_out_char>
    800121d4:	abcff0ef          	jal	ra,80011490 <_vsnprintf>
    800121d8:	87aa                	mv	a5,a0
}
    800121da:	853e                	mv	a0,a5
    800121dc:	70a2                	ld	ra,40(sp)
    800121de:	7402                	ld	s0,32(sp)
    800121e0:	6145                	addi	sp,sp,48
    800121e2:	8082                	ret

00000000800121e4 <vsnprintf_>:

int vsnprintf_(char *buffer, size_t count, const char *format, va_list va)
{
    800121e4:	7179                	addi	sp,sp,-48
    800121e6:	f406                	sd	ra,40(sp)
    800121e8:	f022                	sd	s0,32(sp)
    800121ea:	1800                	addi	s0,sp,48
    800121ec:	fea43423          	sd	a0,-24(s0)
    800121f0:	feb43023          	sd	a1,-32(s0)
    800121f4:	fcc43c23          	sd	a2,-40(s0)
    800121f8:	fcd43823          	sd	a3,-48(s0)
    return _vsnprintf(_out_buffer, buffer, count, format, va);
    800121fc:	fd043703          	ld	a4,-48(s0)
    80012200:	fd843683          	ld	a3,-40(s0)
    80012204:	fe043603          	ld	a2,-32(s0)
    80012208:	fe843583          	ld	a1,-24(s0)
    8001220c:	ffffe517          	auipc	a0,0xffffe
    80012210:	0c650513          	addi	a0,a0,198 # 800102d2 <_out_buffer>
    80012214:	a7cff0ef          	jal	ra,80011490 <_vsnprintf>
    80012218:	87aa                	mv	a5,a0
}
    8001221a:	853e                	mv	a0,a5
    8001221c:	70a2                	ld	ra,40(sp)
    8001221e:	7402                	ld	s0,32(sp)
    80012220:	6145                	addi	sp,sp,48
    80012222:	8082                	ret

0000000080012224 <fctprintf>:

int fctprintf(void (*out)(char character, void *arg), void *arg,
              const char *format, ...)
{
    80012224:	7119                	addi	sp,sp,-128
    80012226:	e486                	sd	ra,72(sp)
    80012228:	e0a2                	sd	s0,64(sp)
    8001222a:	0880                	addi	s0,sp,80
    8001222c:	fca43423          	sd	a0,-56(s0)
    80012230:	fcb43023          	sd	a1,-64(s0)
    80012234:	fac43c23          	sd	a2,-72(s0)
    80012238:	e414                	sd	a3,8(s0)
    8001223a:	e818                	sd	a4,16(s0)
    8001223c:	ec1c                	sd	a5,24(s0)
    8001223e:	03043023          	sd	a6,32(s0)
    80012242:	03143423          	sd	a7,40(s0)
    va_list va;
    va_start(va, format);
    80012246:	03040793          	addi	a5,s0,48
    8001224a:	faf43823          	sd	a5,-80(s0)
    8001224e:	fb043783          	ld	a5,-80(s0)
    80012252:	fd878793          	addi	a5,a5,-40
    80012256:	fef43023          	sd	a5,-32(s0)
    const out_fct_wrap_type out_fct_wrap = {out, arg};
    8001225a:	fc843783          	ld	a5,-56(s0)
    8001225e:	fcf43823          	sd	a5,-48(s0)
    80012262:	fc043783          	ld	a5,-64(s0)
    80012266:	fcf43c23          	sd	a5,-40(s0)
    const int ret = _vsnprintf(_out_fct, (char *)(uintptr_t)&out_fct_wrap,
    8001226a:	fe043703          	ld	a4,-32(s0)
    8001226e:	fd040793          	addi	a5,s0,-48
    80012272:	fb843683          	ld	a3,-72(s0)
    80012276:	567d                	li	a2,-1
    80012278:	85be                	mv	a1,a5
    8001227a:	ffffe517          	auipc	a0,0xffffe
    8001227e:	0ee50513          	addi	a0,a0,238 # 80010368 <_out_fct>
    80012282:	a0eff0ef          	jal	ra,80011490 <_vsnprintf>
    80012286:	87aa                	mv	a5,a0
    80012288:	fef42623          	sw	a5,-20(s0)
                               (size_t)-1, format, va);
    va_end(va);
    return ret;
    8001228c:	fec42783          	lw	a5,-20(s0)
}
    80012290:	853e                	mv	a0,a5
    80012292:	60a6                	ld	ra,72(sp)
    80012294:	6406                	ld	s0,64(sp)
    80012296:	6109                	addi	sp,sp,128
    80012298:	8082                	ret

000000008001229a <c_trap_handler>:
// From src/syscall.c
void syscall_handle(int hart, uint64_t epc, int64_t *scratch);

// Called from asm/spawn.S: _spawn_trap
void c_trap_handler(void)
{
    8001229a:	715d                	addi	sp,sp,-80
    8001229c:	e486                	sd	ra,72(sp)
    8001229e:	e0a2                	sd	s0,64(sp)
    800122a0:	0880                	addi	s0,sp,80
    unsigned long cause;
    long *scratch;
    unsigned long epc;
    unsigned long tval;
    CSR_READ(cause, "scause");
    800122a2:	142027f3          	csrr	a5,scause
    800122a6:	fef43423          	sd	a5,-24(s0)
    CSR_READ(scratch, "sscratch");
    800122aa:	140027f3          	csrr	a5,sscratch
    800122ae:	fef43023          	sd	a5,-32(s0)
    CSR_READ(epc, "sepc");
    800122b2:	141027f3          	csrr	a5,sepc
    800122b6:	fcf43c23          	sd	a5,-40(s0)
    CSR_READ(tval, "stval");
    800122ba:	143027f3          	csrr	a5,stval
    800122be:	fcf43823          	sd	a5,-48(s0)
    
    int hart = sbi_whoami();
    800122c2:	4fe010ef          	jal	ra,800137c0 <sbi_whoami>
    800122c6:	87aa                	mv	a5,a0
    800122c8:	fcf42623          	sw	a5,-52(s0)

    if (SCAUSE_IS_ASYNC(cause)) {
    800122cc:	fe843783          	ld	a5,-24(s0)
    800122d0:	0607d063          	bgez	a5,80012330 <c_trap_handler+0x96>
        cause = SCAUSE_NUM(cause);
    800122d4:	fe843783          	ld	a5,-24(s0)
    800122d8:	0ff7f793          	andi	a5,a5,255
    800122dc:	fef43423          	sd	a5,-24(s0)
        switch (cause) {
    800122e0:	fe843703          	ld	a4,-24(s0)
    800122e4:	4795                	li	a5,5
    800122e6:	00f70863          	beq	a4,a5,800122f6 <c_trap_handler+0x5c>
    800122ea:	fe843703          	ld	a4,-24(s0)
    800122ee:	47a5                	li	a5,9
    800122f0:	00f70663          	beq	a4,a5,800122fc <c_trap_handler+0x62>
    800122f4:	a811                	j	80012308 <c_trap_handler+0x6e>
            case CAUSE_STIP:
                // Ack timer will reset the timer to INFINITE
                // In src/sbi.c
                sbi_ack_timer();
    800122f6:	494010ef          	jal	ra,8001378a <sbi_ack_timer>
                // We typically invoke our scheduler if we get a timer
                // sched_invoke(hart);
                break;
    800122fa:	a851                	j	8001238e <c_trap_handler+0xf4>
            case CAUSE_SEIP:
                // Forward to src/plic.c
                plic_handle_irq(hart);
    800122fc:	fcc42783          	lw	a5,-52(s0)
    80012300:	853e                	mv	a0,a5
    80012302:	772010ef          	jal	ra,80013a74 <plic_handle_irq>
                break;
    80012306:	a061                	j	8001238e <c_trap_handler+0xf4>
            default:
                debugf("Unhandled Asynchronous interrupt %ld\n", cause);
    80012308:	fe843783          	ld	a5,-24(s0)
    8001230c:	00005717          	auipc	a4,0x5
    80012310:	0e470713          	addi	a4,a4,228 # 800173f0 <__func__.0>
    80012314:	02a00693          	li	a3,42
    80012318:	00005617          	auipc	a2,0x5
    8001231c:	00060613          	mv	a2,a2
    80012320:	00005597          	auipc	a1,0x5
    80012324:	00858593          	addi	a1,a1,8 # 80017328 <pow10.0+0xf8>
    80012328:	4509                	li	a0,2
    8001232a:	0b8000ef          	jal	ra,800123e2 <logf>
                break;
    8001232e:	a085                	j	8001238e <c_trap_handler+0xf4>
        }
    }
    else {
        switch (cause) {
    80012330:	fe843703          	ld	a4,-24(s0)
    80012334:	47a1                	li	a5,8
    80012336:	00f71c63          	bne	a4,a5,8001234e <c_trap_handler+0xb4>
            case CAUSE_ECALL_U_MODE:  // ECALL U-Mode
                // Forward to src/syscall.c
                syscall_handle(hart, epc, scratch);
    8001233a:	fcc42783          	lw	a5,-52(s0)
    8001233e:	fe043603          	ld	a2,-32(s0)
    80012342:	fd843583          	ld	a1,-40(s0)
    80012346:	853e                	mv	a0,a5
    80012348:	eddfd0ef          	jal	ra,80010224 <syscall_handle>
                break;
    8001234c:	a089                	j	8001238e <c_trap_handler+0xf4>
            default:
                panicf(
    8001234e:	fcc42783          	lw	a5,-52(s0)
    80012352:	e03e                	sd	a5,0(sp)
    80012354:	fd043883          	ld	a7,-48(s0)
    80012358:	fd843803          	ld	a6,-40(s0)
    8001235c:	fe843783          	ld	a5,-24(s0)
    80012360:	00005717          	auipc	a4,0x5
    80012364:	09070713          	addi	a4,a4,144 # 800173f0 <__func__.0>
    80012368:	03500693          	li	a3,53
    8001236c:	00005617          	auipc	a2,0x5
    80012370:	fac60613          	addi	a2,a2,-84 # 80017318 <pow10.0+0xe8>
    80012374:	00005597          	auipc	a1,0x5
    80012378:	ffc58593          	addi	a1,a1,-4 # 80017370 <pow10.0+0x140>
    8001237c:	4521                	li	a0,8
    8001237e:	064000ef          	jal	ra,800123e2 <logf>
    80012382:	10001073          	csrw	sstatus,zero
    80012386:	10500073          	wfi
    8001238a:	bff5                	j	80012386 <c_trap_handler+0xec>
                    "Unhandled Synchronous interrupt %ld @ 0x%08lx [0x%08lx]. "
                    "Hanging hart %d\n",
                    cause, epc, tval, hart);
                break;
    8001238c:	0001                	nop
        }
    }
}
    8001238e:	0001                	nop
    80012390:	60a6                	ld	ra,72(sp)
    80012392:	6406                	ld	s0,64(sp)
    80012394:	6161                	addi	sp,sp,80
    80012396:	8082                	ret

0000000080012398 <vlogf>:
#include <csr.h>

static int k_log_level = 0xFFF;

static int vlogf(log_type lt, const char *fmt, va_list args)
{
    80012398:	7179                	addi	sp,sp,-48
    8001239a:	f406                	sd	ra,40(sp)
    8001239c:	f022                	sd	s0,32(sp)
    8001239e:	1800                	addi	s0,sp,48
    800123a0:	87aa                	mv	a5,a0
    800123a2:	feb43023          	sd	a1,-32(s0)
    800123a6:	fcc43c23          	sd	a2,-40(s0)
    800123aa:	fef42623          	sw	a5,-20(s0)
    if (!(lt & k_log_level)) {
    800123ae:	00007797          	auipc	a5,0x7
    800123b2:	c5278793          	addi	a5,a5,-942 # 80019000 <k_log_level>
    800123b6:	439c                	lw	a5,0(a5)
    800123b8:	0007871b          	sext.w	a4,a5
    800123bc:	fec42783          	lw	a5,-20(s0)
    800123c0:	8ff9                	and	a5,a5,a4
    800123c2:	2781                	sext.w	a5,a5
    800123c4:	e399                	bnez	a5,800123ca <vlogf+0x32>
        return 0;
    800123c6:	4781                	li	a5,0
    800123c8:	a801                	j	800123d8 <vlogf+0x40>
    }
    int vprintf_(const char *format, va_list va);
    return vprintf_(fmt, args);
    800123ca:	fd843583          	ld	a1,-40(s0)
    800123ce:	fe043503          	ld	a0,-32(s0)
    800123d2:	ddbff0ef          	jal	ra,800121ac <vprintf_>
    800123d6:	87aa                	mv	a5,a0
}
    800123d8:	853e                	mv	a0,a5
    800123da:	70a2                	ld	ra,40(sp)
    800123dc:	7402                	ld	s0,32(sp)
    800123de:	6145                	addi	sp,sp,48
    800123e0:	8082                	ret

00000000800123e2 <logf>:

int logf(log_type lt, const char *fmt, ...)
{
    800123e2:	7159                	addi	sp,sp,-112
    800123e4:	fc06                	sd	ra,56(sp)
    800123e6:	f822                	sd	s0,48(sp)
    800123e8:	0080                	addi	s0,sp,64
    800123ea:	fcb43823          	sd	a1,-48(s0)
    800123ee:	e010                	sd	a2,0(s0)
    800123f0:	e414                	sd	a3,8(s0)
    800123f2:	e818                	sd	a4,16(s0)
    800123f4:	ec1c                	sd	a5,24(s0)
    800123f6:	03043023          	sd	a6,32(s0)
    800123fa:	03143423          	sd	a7,40(s0)
    800123fe:	87aa                	mv	a5,a0
    80012400:	fcf42e23          	sw	a5,-36(s0)
    va_list va;
    va_start(va, fmt);
    80012404:	03040793          	addi	a5,s0,48
    80012408:	fcf43423          	sd	a5,-56(s0)
    8001240c:	fc843783          	ld	a5,-56(s0)
    80012410:	fd078793          	addi	a5,a5,-48
    80012414:	fef43023          	sd	a5,-32(s0)
    int ret = vlogf(lt, fmt, va);
    80012418:	fe043703          	ld	a4,-32(s0)
    8001241c:	fdc42783          	lw	a5,-36(s0)
    80012420:	863a                	mv	a2,a4
    80012422:	fd043583          	ld	a1,-48(s0)
    80012426:	853e                	mv	a0,a5
    80012428:	f71ff0ef          	jal	ra,80012398 <vlogf>
    8001242c:	87aa                	mv	a5,a0
    8001242e:	fef42623          	sw	a5,-20(s0)
    va_end(va);

    return ret;
    80012432:	fec42783          	lw	a5,-20(s0)
}
    80012436:	853e                	mv	a0,a5
    80012438:	70e2                	ld	ra,56(sp)
    8001243a:	7442                	ld	s0,48(sp)
    8001243c:	6165                	addi	sp,sp,112
    8001243e:	8082                	ret

0000000080012440 <klog>:

void klog(log_type lt, bool on)
{
    80012440:	1101                	addi	sp,sp,-32
    80012442:	ec22                	sd	s0,24(sp)
    80012444:	1000                	addi	s0,sp,32
    80012446:	87aa                	mv	a5,a0
    80012448:	872e                	mv	a4,a1
    8001244a:	fef42623          	sw	a5,-20(s0)
    8001244e:	87ba                	mv	a5,a4
    80012450:	fef405a3          	sb	a5,-21(s0)
    if (on) {
    80012454:	feb44783          	lbu	a5,-21(s0)
    80012458:	0ff7f793          	andi	a5,a5,255
    8001245c:	c785                	beqz	a5,80012484 <klog+0x44>
        k_log_level |= lt;
    8001245e:	00007797          	auipc	a5,0x7
    80012462:	ba278793          	addi	a5,a5,-1118 # 80019000 <k_log_level>
    80012466:	439c                	lw	a5,0(a5)
    80012468:	0007871b          	sext.w	a4,a5
    8001246c:	fec42783          	lw	a5,-20(s0)
    80012470:	8fd9                	or	a5,a5,a4
    80012472:	2781                	sext.w	a5,a5
    80012474:	0007871b          	sext.w	a4,a5
    80012478:	00007797          	auipc	a5,0x7
    8001247c:	b8878793          	addi	a5,a5,-1144 # 80019000 <k_log_level>
    80012480:	c398                	sw	a4,0(a5)
    }
    else {
        k_log_level &= ~lt;
    }
}
    80012482:	a035                	j	800124ae <klog+0x6e>
        k_log_level &= ~lt;
    80012484:	fec42783          	lw	a5,-20(s0)
    80012488:	fff7c793          	not	a5,a5
    8001248c:	0007871b          	sext.w	a4,a5
    80012490:	00007797          	auipc	a5,0x7
    80012494:	b7078793          	addi	a5,a5,-1168 # 80019000 <k_log_level>
    80012498:	439c                	lw	a5,0(a5)
    8001249a:	2781                	sext.w	a5,a5
    8001249c:	8ff9                	and	a5,a5,a4
    8001249e:	2781                	sext.w	a5,a5
    800124a0:	0007871b          	sext.w	a4,a5
    800124a4:	00007797          	auipc	a5,0x7
    800124a8:	b5c78793          	addi	a5,a5,-1188 # 80019000 <k_log_level>
    800124ac:	c398                	sw	a4,0(a5)
}
    800124ae:	0001                	nop
    800124b0:	6462                	ld	s0,24(sp)
    800124b2:	6105                	addi	sp,sp,32
    800124b4:	8082                	ret

00000000800124b6 <mutex_trylock>:
#include <csr.h>
#include <lock.h>
#include <stdint.h>

bool mutex_trylock(Mutex *mutex)
{
    800124b6:	1101                	addi	sp,sp,-32
    800124b8:	ec22                	sd	s0,24(sp)
    800124ba:	1000                	addi	s0,sp,32
    800124bc:	fea43423          	sd	a0,-24(s0)
    return MUTEX_LOCKED != __sync_lock_test_and_set(mutex, MUTEX_LOCKED);
    800124c0:	fe843783          	ld	a5,-24(s0)
    800124c4:	4705                	li	a4,1
    800124c6:	0ce7a72f          	amoswap.w.aq	a4,a4,(a5)
    800124ca:	0007079b          	sext.w	a5,a4
    800124ce:	873e                	mv	a4,a5
    800124d0:	4785                	li	a5,1
    800124d2:	40f707b3          	sub	a5,a4,a5
    800124d6:	00f037b3          	snez	a5,a5
    800124da:	0ff7f793          	andi	a5,a5,255
}
    800124de:	853e                	mv	a0,a5
    800124e0:	6462                	ld	s0,24(sp)
    800124e2:	6105                	addi	sp,sp,32
    800124e4:	8082                	ret

00000000800124e6 <mutex_spinlock>:

void mutex_spinlock(Mutex *mutex)
{
    800124e6:	1101                	addi	sp,sp,-32
    800124e8:	ec06                	sd	ra,24(sp)
    800124ea:	e822                	sd	s0,16(sp)
    800124ec:	1000                	addi	s0,sp,32
    800124ee:	fea43423          	sd	a0,-24(s0)
    while (!mutex_trylock(mutex))
    800124f2:	0001                	nop
    800124f4:	fe843503          	ld	a0,-24(s0)
    800124f8:	fbfff0ef          	jal	ra,800124b6 <mutex_trylock>
    800124fc:	87aa                	mv	a5,a0
    800124fe:	0017c793          	xori	a5,a5,1
    80012502:	0ff7f793          	andi	a5,a5,255
    80012506:	f7fd                	bnez	a5,800124f4 <mutex_spinlock+0xe>
        ;
}
    80012508:	0001                	nop
    8001250a:	0001                	nop
    8001250c:	60e2                	ld	ra,24(sp)
    8001250e:	6442                	ld	s0,16(sp)
    80012510:	6105                	addi	sp,sp,32
    80012512:	8082                	ret

0000000080012514 <mutex_unlock>:

void mutex_unlock(Mutex *mutex)
{
    80012514:	1101                	addi	sp,sp,-32
    80012516:	ec22                	sd	s0,24(sp)
    80012518:	1000                	addi	s0,sp,32
    8001251a:	fea43423          	sd	a0,-24(s0)
    __sync_lock_release(mutex);
    8001251e:	fe843783          	ld	a5,-24(s0)
    80012522:	0f50000f          	fence	iorw,ow
    80012526:	0807a02f          	amoswap.w	zero,zero,(a5)
}
    8001252a:	0001                	nop
    8001252c:	6462                	ld	s0,24(sp)
    8001252e:	6105                	addi	sp,sp,32
    80012530:	8082                	ret

0000000080012532 <mutex_spinlock_irq_save>:

void mutex_spinlock_irq_save(Mutex *mutex, int *state)
{
    80012532:	7179                	addi	sp,sp,-48
    80012534:	f406                	sd	ra,40(sp)
    80012536:	f022                	sd	s0,32(sp)
    80012538:	1800                	addi	s0,sp,48
    8001253a:	fca43c23          	sd	a0,-40(s0)
    8001253e:	fcb43823          	sd	a1,-48(s0)
    uint64_t irq;
    CSR_READ(irq, "sstatus");
    80012542:	100027f3          	csrr	a5,sstatus
    80012546:	fef43423          	sd	a5,-24(s0)
    *state = !!(irq & SSTATUS_SIE);
    8001254a:	fe843783          	ld	a5,-24(s0)
    8001254e:	8b89                	andi	a5,a5,2
    80012550:	00f037b3          	snez	a5,a5
    80012554:	0ff7f793          	andi	a5,a5,255
    80012558:	0007871b          	sext.w	a4,a5
    8001255c:	fd043783          	ld	a5,-48(s0)
    80012560:	c398                	sw	a4,0(a5)
    IRQ_OFF();
    80012562:	100027f3          	csrr	a5,sstatus
    80012566:	fef43023          	sd	a5,-32(s0)
    8001256a:	fe043783          	ld	a5,-32(s0)
    8001256e:	9bf5                	andi	a5,a5,-3
    80012570:	10079073          	csrw	sstatus,a5
    while (!mutex_trylock(mutex))
    80012574:	0001                	nop
    80012576:	fd843503          	ld	a0,-40(s0)
    8001257a:	f3dff0ef          	jal	ra,800124b6 <mutex_trylock>
    8001257e:	87aa                	mv	a5,a0
    80012580:	0017c793          	xori	a5,a5,1
    80012584:	0ff7f793          	andi	a5,a5,255
    80012588:	f7fd                	bnez	a5,80012576 <mutex_spinlock_irq_save+0x44>
        ;
}
    8001258a:	0001                	nop
    8001258c:	0001                	nop
    8001258e:	70a2                	ld	ra,40(sp)
    80012590:	7402                	ld	s0,32(sp)
    80012592:	6145                	addi	sp,sp,48
    80012594:	8082                	ret

0000000080012596 <mutex_unlock_irq_restore>:

void mutex_unlock_irq_restore(Mutex *mutex, int state)
{
    80012596:	7179                	addi	sp,sp,-48
    80012598:	f406                	sd	ra,40(sp)
    8001259a:	f022                	sd	s0,32(sp)
    8001259c:	1800                	addi	s0,sp,48
    8001259e:	fca43c23          	sd	a0,-40(s0)
    800125a2:	87ae                	mv	a5,a1
    800125a4:	fcf42a23          	sw	a5,-44(s0)
    uint64_t irq;
    mutex_unlock(mutex);
    800125a8:	fd843503          	ld	a0,-40(s0)
    800125ac:	f69ff0ef          	jal	ra,80012514 <mutex_unlock>
    CSR_READ(irq, "sstatus");
    800125b0:	100027f3          	csrr	a5,sstatus
    800125b4:	fef43423          	sd	a5,-24(s0)
    CSR_WRITE("sstatus", irq | ((!!state) << SSTATUS_SIE_BIT));
    800125b8:	fd442783          	lw	a5,-44(s0)
    800125bc:	2781                	sext.w	a5,a5
    800125be:	c399                	beqz	a5,800125c4 <mutex_unlock_irq_restore+0x2e>
    800125c0:	4789                	li	a5,2
    800125c2:	a011                	j	800125c6 <mutex_unlock_irq_restore+0x30>
    800125c4:	4781                	li	a5,0
    800125c6:	fe843703          	ld	a4,-24(s0)
    800125ca:	8fd9                	or	a5,a5,a4
    800125cc:	10079073          	csrw	sstatus,a5
}
    800125d0:	0001                	nop
    800125d2:	70a2                	ld	ra,40(sp)
    800125d4:	7402                	ld	s0,32(sp)
    800125d6:	6145                	addi	sp,sp,48
    800125d8:	8082                	ret

00000000800125da <mmu_table_create>:
#define ADDR_0_BIT   12
#define ADDR_1_BIT   21
#define ADDR_2_BIT   30

struct page_table *mmu_table_create(void)
{
    800125da:	1141                	addi	sp,sp,-16
    800125dc:	e406                	sd	ra,8(sp)
    800125de:	e022                	sd	s0,0(sp)
    800125e0:	0800                	addi	s0,sp,16
    return page_zalloc();
    800125e2:	4505                	li	a0,1
    800125e4:	5d0010ef          	jal	ra,80013bb4 <page_znalloc>
    800125e8:	87aa                	mv	a5,a0
}
    800125ea:	853e                	mv	a0,a5
    800125ec:	60a2                	ld	ra,8(sp)
    800125ee:	6402                	ld	s0,0(sp)
    800125f0:	0141                	addi	sp,sp,16
    800125f2:	8082                	ret

00000000800125f4 <mmu_map>:

bool mmu_map(struct page_table *tab, uint64_t vaddr, uint64_t paddr, uint8_t lvl, uint64_t bits)
{
    800125f4:	7159                	addi	sp,sp,-112
    800125f6:	f4a2                	sd	s0,104(sp)
    800125f8:	1880                	addi	s0,sp,112
    800125fa:	faa43c23          	sd	a0,-72(s0)
    800125fe:	fab43823          	sd	a1,-80(s0)
    80012602:	fac43423          	sd	a2,-88(s0)
    80012606:	87b6                	mv	a5,a3
    80012608:	f8e43c23          	sd	a4,-104(s0)
    8001260c:	faf403a3          	sb	a5,-89(s0)
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80012610:	fb043783          	ld	a5,-80(s0)
    80012614:	83b1                	srli	a5,a5,0xc
    80012616:	1ff7f793          	andi	a5,a5,511
    8001261a:	fcf43c23          	sd	a5,-40(s0)
    8001261e:	fb043783          	ld	a5,-80(s0)
    80012622:	83d5                	srli	a5,a5,0x15
    80012624:	1ff7f793          	andi	a5,a5,511
    80012628:	fef43023          	sd	a5,-32(s0)
                            (vaddr >> ADDR_2_BIT) & 0x1FF};
    8001262c:	fb043783          	ld	a5,-80(s0)
    80012630:	83f9                	srli	a5,a5,0x1e
    80012632:	1ff7f793          	andi	a5,a5,511
    const uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    80012636:	fef43423          	sd	a5,-24(s0)
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    8001263a:	fa843783          	ld	a5,-88(s0)
    8001263e:	83b1                	srli	a5,a5,0xc
    80012640:	1ff7f793          	andi	a5,a5,511
    80012644:	fcf43023          	sd	a5,-64(s0)
    80012648:	fa843783          	ld	a5,-88(s0)
    8001264c:	83d5                	srli	a5,a5,0x15
    8001264e:	1ff7f793          	andi	a5,a5,511
    80012652:	fcf43423          	sd	a5,-56(s0)
                            (paddr >> ADDR_2_BIT) & 0x3FFFFFF};
    80012656:	fa843783          	ld	a5,-88(s0)
    8001265a:	01e7d713          	srli	a4,a5,0x1e
    8001265e:	040007b7          	lui	a5,0x4000
    80012662:	17fd                	addi	a5,a5,-1
    80012664:	8ff9                	and	a5,a5,a4
    const uint64_t ppn[] = {(paddr >> ADDR_0_BIT) & 0x1FF, (paddr >> ADDR_1_BIT) & 0x1FF,
    80012666:	fcf43823          	sd	a5,-48(s0)
    (void)vpn;
    (void)ppn;
    (void)bits;
    (void)tab;

    if (lvl > MMU_LEVEL_1G) {
    8001266a:	fa744783          	lbu	a5,-89(s0)
    8001266e:	0ff7f713          	andi	a4,a5,255
    80012672:	4789                	li	a5,2
    80012674:	00e7f463          	bgeu	a5,a4,8001267c <mmu_map+0x88>
        return false;
    80012678:	4781                	li	a5,0
    8001267a:	a011                	j	8001267e <mmu_map+0x8a>
    }

    return false;
    8001267c:	4781                	li	a5,0
}
    8001267e:	853e                	mv	a0,a5
    80012680:	7426                	ld	s0,104(sp)
    80012682:	6165                	addi	sp,sp,112
    80012684:	8082                	ret

0000000080012686 <mmu_free>:

void mmu_free(struct page_table *tab)
{
    80012686:	1101                	addi	sp,sp,-32
    80012688:	ec22                	sd	s0,24(sp)
    8001268a:	1000                	addi	s0,sp,32
    8001268c:	fea43423          	sd	a0,-24(s0)
    if (tab == NULL) {
        return;
    }
    // Unmap all pages and free pages.
}
    80012690:	6462                	ld	s0,24(sp)
    80012692:	6105                	addi	sp,sp,32
    80012694:	8082                	ret

0000000080012696 <mmu_translate>:

uint64_t mmu_translate(const struct page_table *tab, uint64_t vaddr)
{
    80012696:	7139                	addi	sp,sp,-64
    80012698:	fc22                	sd	s0,56(sp)
    8001269a:	0080                	addi	s0,sp,64
    8001269c:	fca43423          	sd	a0,-56(s0)
    800126a0:	fcb43023          	sd	a1,-64(s0)
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    800126a4:	fc043783          	ld	a5,-64(s0)
    800126a8:	83b1                	srli	a5,a5,0xc
    800126aa:	1ff7f793          	andi	a5,a5,511
    800126ae:	fcf43c23          	sd	a5,-40(s0)
    800126b2:	fc043783          	ld	a5,-64(s0)
    800126b6:	83d5                	srli	a5,a5,0x15
    800126b8:	1ff7f793          	andi	a5,a5,511
    800126bc:	fef43023          	sd	a5,-32(s0)
                      (vaddr >> ADDR_2_BIT) & 0x1FF};
    800126c0:	fc043783          	ld	a5,-64(s0)
    800126c4:	83f9                	srli	a5,a5,0x1e
    800126c6:	1ff7f793          	andi	a5,a5,511
    uint64_t vpn[] = {(vaddr >> ADDR_0_BIT) & 0x1FF, (vaddr >> ADDR_1_BIT) & 0x1FF,
    800126ca:	fef43423          	sd	a5,-24(s0)


    // Delete the following line. This is to get rid of the "unused" warning.
    (void)vpn;
    // Can't translate without a table.
    if (tab == NULL) {
    800126ce:	fc843783          	ld	a5,-56(s0)
    800126d2:	e399                	bnez	a5,800126d8 <mmu_translate+0x42>
        return MMU_TRANSLATE_PAGE_FAULT;
    800126d4:	57fd                	li	a5,-1
    800126d6:	a011                	j	800126da <mmu_translate+0x44>
    }
    return MMU_TRANSLATE_PAGE_FAULT;
    800126d8:	57fd                	li	a5,-1
}
    800126da:	853e                	mv	a0,a5
    800126dc:	7462                	ld	s0,56(sp)
    800126de:	6121                	addi	sp,sp,64
    800126e0:	8082                	ret

00000000800126e2 <mmu_access_ok>:
bool mmu_access_ok(const struct page_table *tab, unsigned long vaddr, unsigned long required_perms)
{
    800126e2:	7179                	addi	sp,sp,-48
    800126e4:	f422                	sd	s0,40(sp)
    800126e6:	1800                	addi	s0,sp,48
    800126e8:	fea43423          	sd	a0,-24(s0)
    800126ec:	feb43023          	sd	a1,-32(s0)
    800126f0:	fcc43c23          	sd	a2,-40(s0)
    (void)tab;
    (void)vaddr;
    (void)required_perms;
    return false;
    800126f4:	4781                	li	a5,0
}
    800126f6:	853e                	mv	a0,a5
    800126f8:	7422                	ld	s0,40(sp)
    800126fa:	6145                	addi	sp,sp,48
    800126fc:	8082                	ret

00000000800126fe <mmu_map_range>:
                       uint64_t start_virt, 
                       uint64_t end_virt, 
                       uint64_t start_phys,
                       uint8_t lvl, 
                       uint64_t bits)
{
    800126fe:	711d                	addi	sp,sp,-96
    80012700:	ec86                	sd	ra,88(sp)
    80012702:	e8a2                	sd	s0,80(sp)
    80012704:	1080                	addi	s0,sp,96
    80012706:	fca43423          	sd	a0,-56(s0)
    8001270a:	fcb43023          	sd	a1,-64(s0)
    8001270e:	fac43c23          	sd	a2,-72(s0)
    80012712:	fad43823          	sd	a3,-80(s0)
    80012716:	faf43023          	sd	a5,-96(s0)
    8001271a:	87ba                	mv	a5,a4
    8001271c:	faf407a3          	sb	a5,-81(s0)
    start_virt            = ALIGN_DOWN_POT(start_virt, PAGE_SIZE_AT_LVL(lvl));
    80012720:	faf44783          	lbu	a5,-81(s0)
    80012724:	2781                	sext.w	a5,a5
    80012726:	873e                	mv	a4,a5
    80012728:	87ba                	mv	a5,a4
    8001272a:	0037979b          	slliw	a5,a5,0x3
    8001272e:	9fb9                	addw	a5,a5,a4
    80012730:	2781                	sext.w	a5,a5
    80012732:	27b1                	addiw	a5,a5,12
    80012734:	2781                	sext.w	a5,a5
    80012736:	4705                	li	a4,1
    80012738:	00f717bb          	sllw	a5,a4,a5
    8001273c:	2781                	sext.w	a5,a5
    8001273e:	40f007bb          	negw	a5,a5
    80012742:	2781                	sext.w	a5,a5
    80012744:	873e                	mv	a4,a5
    80012746:	fc043783          	ld	a5,-64(s0)
    8001274a:	8ff9                	and	a5,a5,a4
    8001274c:	fcf43023          	sd	a5,-64(s0)
    end_virt              = ALIGN_UP_POT(end_virt, PAGE_SIZE_AT_LVL(lvl));
    80012750:	faf44783          	lbu	a5,-81(s0)
    80012754:	2781                	sext.w	a5,a5
    80012756:	873e                	mv	a4,a5
    80012758:	87ba                	mv	a5,a4
    8001275a:	0037979b          	slliw	a5,a5,0x3
    8001275e:	9fb9                	addw	a5,a5,a4
    80012760:	2781                	sext.w	a5,a5
    80012762:	27b1                	addiw	a5,a5,12
    80012764:	2781                	sext.w	a5,a5
    80012766:	4705                	li	a4,1
    80012768:	00f717bb          	sllw	a5,a4,a5
    8001276c:	2781                	sext.w	a5,a5
    8001276e:	873e                	mv	a4,a5
    80012770:	fb843783          	ld	a5,-72(s0)
    80012774:	97ba                	add	a5,a5,a4
    80012776:	fff78713          	addi	a4,a5,-1 # 3ffffff <i+0x3ffffdf>
    8001277a:	faf44783          	lbu	a5,-81(s0)
    8001277e:	2781                	sext.w	a5,a5
    80012780:	86be                	mv	a3,a5
    80012782:	87b6                	mv	a5,a3
    80012784:	0037979b          	slliw	a5,a5,0x3
    80012788:	9fb5                	addw	a5,a5,a3
    8001278a:	2781                	sext.w	a5,a5
    8001278c:	27b1                	addiw	a5,a5,12
    8001278e:	2781                	sext.w	a5,a5
    80012790:	4685                	li	a3,1
    80012792:	00f697bb          	sllw	a5,a3,a5
    80012796:	2781                	sext.w	a5,a5
    80012798:	40f007bb          	negw	a5,a5
    8001279c:	2781                	sext.w	a5,a5
    8001279e:	8ff9                	and	a5,a5,a4
    800127a0:	faf43c23          	sd	a5,-72(s0)
    uint64_t num_bytes    = end_virt - start_virt;
    800127a4:	fb843703          	ld	a4,-72(s0)
    800127a8:	fc043783          	ld	a5,-64(s0)
    800127ac:	40f707b3          	sub	a5,a4,a5
    800127b0:	fcf43c23          	sd	a5,-40(s0)
    uint64_t pages_mapped = 0;
    800127b4:	fe043423          	sd	zero,-24(s0)

    uint64_t i;
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    800127b8:	fe043023          	sd	zero,-32(s0)
    800127bc:	a0ad                	j	80012826 <mmu_map_range+0x128>
        if (!mmu_map(tab, start_virt + i, start_phys + i, lvl, bits)) {
    800127be:	fc043703          	ld	a4,-64(s0)
    800127c2:	fe043783          	ld	a5,-32(s0)
    800127c6:	00f705b3          	add	a1,a4,a5
    800127ca:	fb043703          	ld	a4,-80(s0)
    800127ce:	fe043783          	ld	a5,-32(s0)
    800127d2:	97ba                	add	a5,a5,a4
    800127d4:	faf44683          	lbu	a3,-81(s0)
    800127d8:	fa043703          	ld	a4,-96(s0)
    800127dc:	863e                	mv	a2,a5
    800127de:	fc843503          	ld	a0,-56(s0)
    800127e2:	e13ff0ef          	jal	ra,800125f4 <mmu_map>
    800127e6:	87aa                	mv	a5,a0
    800127e8:	0017c793          	xori	a5,a5,1
    800127ec:	0ff7f793          	andi	a5,a5,255
    800127f0:	e3b1                	bnez	a5,80012834 <mmu_map_range+0x136>
            break;
        }
        pages_mapped += 1;
    800127f2:	fe843783          	ld	a5,-24(s0)
    800127f6:	0785                	addi	a5,a5,1
    800127f8:	fef43423          	sd	a5,-24(s0)
    for (i = 0; i < num_bytes; i += PAGE_SIZE_AT_LVL(lvl)) {
    800127fc:	faf44783          	lbu	a5,-81(s0)
    80012800:	2781                	sext.w	a5,a5
    80012802:	873e                	mv	a4,a5
    80012804:	87ba                	mv	a5,a4
    80012806:	0037979b          	slliw	a5,a5,0x3
    8001280a:	9fb9                	addw	a5,a5,a4
    8001280c:	2781                	sext.w	a5,a5
    8001280e:	27b1                	addiw	a5,a5,12
    80012810:	2781                	sext.w	a5,a5
    80012812:	4705                	li	a4,1
    80012814:	00f717bb          	sllw	a5,a4,a5
    80012818:	2781                	sext.w	a5,a5
    8001281a:	873e                	mv	a4,a5
    8001281c:	fe043783          	ld	a5,-32(s0)
    80012820:	97ba                	add	a5,a5,a4
    80012822:	fef43023          	sd	a5,-32(s0)
    80012826:	fe043703          	ld	a4,-32(s0)
    8001282a:	fd843783          	ld	a5,-40(s0)
    8001282e:	f8f768e3          	bltu	a4,a5,800127be <mmu_map_range+0xc0>
    80012832:	a011                	j	80012836 <mmu_map_range+0x138>
            break;
    80012834:	0001                	nop
    }
    return pages_mapped;
    80012836:	fe843783          	ld	a5,-24(s0)
}
    8001283a:	853e                	mv	a0,a5
    8001283c:	60e6                	ld	ra,88(sp)
    8001283e:	6446                	ld	s0,80(sp)
    80012840:	6125                	addi	sp,sp,96
    80012842:	8082                	ret

0000000080012844 <insert_block>:
 * into free list, sorted by addr.
 * If disabled, add block has new head of
 * the free list.
 */
static void insert_block(Block *block)
{
    80012844:	7179                	addi	sp,sp,-48
    80012846:	f422                	sd	s0,40(sp)
    80012848:	1800                	addi	s0,sp,48
    8001284a:	fca43c23          	sd	a0,-40(s0)
    Block *ptr  = heap->free;
    8001284e:	00003797          	auipc	a5,0x3
    80012852:	7da78793          	addi	a5,a5,2010 # 80016028 <heap>
    80012856:	639c                	ld	a5,0(a5)
    80012858:	639c                	ld	a5,0(a5)
    8001285a:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    8001285e:	fe043023          	sd	zero,-32(s0)
    while (ptr != NULL) {
    80012862:	a01d                	j	80012888 <insert_block+0x44>
        if ((size_t)block->addr <= (size_t)ptr->addr) {
    80012864:	fd843783          	ld	a5,-40(s0)
    80012868:	639c                	ld	a5,0(a5)
    8001286a:	873e                	mv	a4,a5
    8001286c:	fe843783          	ld	a5,-24(s0)
    80012870:	639c                	ld	a5,0(a5)
    80012872:	00e7ff63          	bgeu	a5,a4,80012890 <insert_block+0x4c>
            break;
        }
        prev = ptr;
    80012876:	fe843783          	ld	a5,-24(s0)
    8001287a:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    8001287e:	fe843783          	ld	a5,-24(s0)
    80012882:	679c                	ld	a5,8(a5)
    80012884:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80012888:	fe843783          	ld	a5,-24(s0)
    8001288c:	ffe1                	bnez	a5,80012864 <insert_block+0x20>
    8001288e:	a011                	j	80012892 <insert_block+0x4e>
            break;
    80012890:	0001                	nop
    }
    if (prev != NULL) {
    80012892:	fe043783          	ld	a5,-32(s0)
    80012896:	c799                	beqz	a5,800128a4 <insert_block+0x60>
        prev->next = block;
    80012898:	fe043783          	ld	a5,-32(s0)
    8001289c:	fd843703          	ld	a4,-40(s0)
    800128a0:	e798                	sd	a4,8(a5)
    800128a2:	a809                	j	800128b4 <insert_block+0x70>
    }
    else {
        heap->free = block;
    800128a4:	00003797          	auipc	a5,0x3
    800128a8:	78478793          	addi	a5,a5,1924 # 80016028 <heap>
    800128ac:	639c                	ld	a5,0(a5)
    800128ae:	fd843703          	ld	a4,-40(s0)
    800128b2:	e398                	sd	a4,0(a5)
    }
    block->next = ptr;
    800128b4:	fd843783          	ld	a5,-40(s0)
    800128b8:	fe843703          	ld	a4,-24(s0)
    800128bc:	e798                	sd	a4,8(a5)
}
    800128be:	0001                	nop
    800128c0:	7422                	ld	s0,40(sp)
    800128c2:	6145                	addi	sp,sp,48
    800128c4:	8082                	ret

00000000800128c6 <release_blocks>:

#ifndef TA_DISABLE_COMPACT
static void release_blocks(Block *scan, Block *to)
{
    800128c6:	7179                	addi	sp,sp,-48
    800128c8:	f422                	sd	s0,40(sp)
    800128ca:	1800                	addi	s0,sp,48
    800128cc:	fca43c23          	sd	a0,-40(s0)
    800128d0:	fcb43823          	sd	a1,-48(s0)
    Block *scan_next;
    while (scan != to) {
    800128d4:	a099                	j	8001291a <release_blocks+0x54>
        scan_next   = scan->next;
    800128d6:	fd843783          	ld	a5,-40(s0)
    800128da:	679c                	ld	a5,8(a5)
    800128dc:	fef43423          	sd	a5,-24(s0)
        scan->next  = heap->fresh;
    800128e0:	00003797          	auipc	a5,0x3
    800128e4:	74878793          	addi	a5,a5,1864 # 80016028 <heap>
    800128e8:	639c                	ld	a5,0(a5)
    800128ea:	6b98                	ld	a4,16(a5)
    800128ec:	fd843783          	ld	a5,-40(s0)
    800128f0:	e798                	sd	a4,8(a5)
        heap->fresh = scan;
    800128f2:	00003797          	auipc	a5,0x3
    800128f6:	73678793          	addi	a5,a5,1846 # 80016028 <heap>
    800128fa:	639c                	ld	a5,0(a5)
    800128fc:	fd843703          	ld	a4,-40(s0)
    80012900:	eb98                	sd	a4,16(a5)
        scan->addr  = 0;
    80012902:	fd843783          	ld	a5,-40(s0)
    80012906:	0007b023          	sd	zero,0(a5)
        scan->size  = 0;
    8001290a:	fd843783          	ld	a5,-40(s0)
    8001290e:	0007b823          	sd	zero,16(a5)
        scan        = scan_next;
    80012912:	fe843783          	ld	a5,-24(s0)
    80012916:	fcf43c23          	sd	a5,-40(s0)
    while (scan != to) {
    8001291a:	fd843703          	ld	a4,-40(s0)
    8001291e:	fd043783          	ld	a5,-48(s0)
    80012922:	faf71ae3          	bne	a4,a5,800128d6 <release_blocks+0x10>
    }
}
    80012926:	0001                	nop
    80012928:	0001                	nop
    8001292a:	7422                	ld	s0,40(sp)
    8001292c:	6145                	addi	sp,sp,48
    8001292e:	8082                	ret

0000000080012930 <compact>:

static void compact()
{
    80012930:	7139                	addi	sp,sp,-64
    80012932:	fc06                	sd	ra,56(sp)
    80012934:	f822                	sd	s0,48(sp)
    80012936:	0080                	addi	s0,sp,64
    Block *ptr = heap->free;
    80012938:	00003797          	auipc	a5,0x3
    8001293c:	6f078793          	addi	a5,a5,1776 # 80016028 <heap>
    80012940:	639c                	ld	a5,0(a5)
    80012942:	639c                	ld	a5,0(a5)
    80012944:	fef43423          	sd	a5,-24(s0)
    Block *prev;
    Block *scan;
    while (ptr != NULL) {
    80012948:	a075                	j	800129f4 <compact+0xc4>
        prev = ptr;
    8001294a:	fe843783          	ld	a5,-24(s0)
    8001294e:	fef43023          	sd	a5,-32(s0)
        scan = ptr->next;
    80012952:	fe843783          	ld	a5,-24(s0)
    80012956:	679c                	ld	a5,8(a5)
    80012958:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    8001295c:	a811                	j	80012970 <compact+0x40>
            prev = scan;
    8001295e:	fd843783          	ld	a5,-40(s0)
    80012962:	fef43023          	sd	a5,-32(s0)
            scan = scan->next;
    80012966:	fd843783          	ld	a5,-40(s0)
    8001296a:	679c                	ld	a5,8(a5)
    8001296c:	fcf43c23          	sd	a5,-40(s0)
        while (scan != NULL && (size_t)prev->addr + prev->size == (size_t)scan->addr) {
    80012970:	fd843783          	ld	a5,-40(s0)
    80012974:	cf91                	beqz	a5,80012990 <compact+0x60>
    80012976:	fe043783          	ld	a5,-32(s0)
    8001297a:	639c                	ld	a5,0(a5)
    8001297c:	873e                	mv	a4,a5
    8001297e:	fe043783          	ld	a5,-32(s0)
    80012982:	6b9c                	ld	a5,16(a5)
    80012984:	97ba                	add	a5,a5,a4
    80012986:	fd843703          	ld	a4,-40(s0)
    8001298a:	6318                	ld	a4,0(a4)
    8001298c:	fce789e3          	beq	a5,a4,8001295e <compact+0x2e>
        }
        if (prev != ptr) {
    80012990:	fe043703          	ld	a4,-32(s0)
    80012994:	fe843783          	ld	a5,-24(s0)
    80012998:	04f70963          	beq	a4,a5,800129ea <compact+0xba>
            size_t new_size = (size_t)prev->addr - (size_t)ptr->addr + prev->size;
    8001299c:	fe043783          	ld	a5,-32(s0)
    800129a0:	639c                	ld	a5,0(a5)
    800129a2:	873e                	mv	a4,a5
    800129a4:	fe843783          	ld	a5,-24(s0)
    800129a8:	639c                	ld	a5,0(a5)
    800129aa:	8f1d                	sub	a4,a4,a5
    800129ac:	fe043783          	ld	a5,-32(s0)
    800129b0:	6b9c                	ld	a5,16(a5)
    800129b2:	97ba                	add	a5,a5,a4
    800129b4:	fcf43823          	sd	a5,-48(s0)
            ptr->size       = new_size;
    800129b8:	fe843783          	ld	a5,-24(s0)
    800129bc:	fd043703          	ld	a4,-48(s0)
    800129c0:	eb98                	sd	a4,16(a5)
            Block *next     = prev->next;
    800129c2:	fe043783          	ld	a5,-32(s0)
    800129c6:	679c                	ld	a5,8(a5)
    800129c8:	fcf43423          	sd	a5,-56(s0)
            // make merged blocks available
            release_blocks(ptr->next, prev->next);
    800129cc:	fe843783          	ld	a5,-24(s0)
    800129d0:	6798                	ld	a4,8(a5)
    800129d2:	fe043783          	ld	a5,-32(s0)
    800129d6:	679c                	ld	a5,8(a5)
    800129d8:	85be                	mv	a1,a5
    800129da:	853a                	mv	a0,a4
    800129dc:	eebff0ef          	jal	ra,800128c6 <release_blocks>
            // relink
            ptr->next = next;
    800129e0:	fe843783          	ld	a5,-24(s0)
    800129e4:	fc843703          	ld	a4,-56(s0)
    800129e8:	e798                	sd	a4,8(a5)
        }
        ptr = ptr->next;
    800129ea:	fe843783          	ld	a5,-24(s0)
    800129ee:	679c                	ld	a5,8(a5)
    800129f0:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    800129f4:	fe843783          	ld	a5,-24(s0)
    800129f8:	fba9                	bnez	a5,8001294a <compact+0x1a>
    }
}
    800129fa:	0001                	nop
    800129fc:	0001                	nop
    800129fe:	70e2                	ld	ra,56(sp)
    80012a00:	7442                	ld	s0,48(sp)
    80012a02:	6121                	addi	sp,sp,64
    80012a04:	8082                	ret

0000000080012a06 <init>:
#endif

static bool init(const void *base, const void *limit, const size_t heap_blocks,
                 const size_t split_thresh, const size_t alignment)
{
    80012a06:	715d                	addi	sp,sp,-80
    80012a08:	e4a2                	sd	s0,72(sp)
    80012a0a:	0880                	addi	s0,sp,80
    80012a0c:	fca43c23          	sd	a0,-40(s0)
    80012a10:	fcb43823          	sd	a1,-48(s0)
    80012a14:	fcc43423          	sd	a2,-56(s0)
    80012a18:	fcd43023          	sd	a3,-64(s0)
    80012a1c:	fae43c23          	sd	a4,-72(s0)
    heap              = (Heap *)base;
    80012a20:	00003797          	auipc	a5,0x3
    80012a24:	60878793          	addi	a5,a5,1544 # 80016028 <heap>
    80012a28:	fd843703          	ld	a4,-40(s0)
    80012a2c:	e398                	sd	a4,0(a5)
    heap_limit        = limit;
    80012a2e:	00003797          	auipc	a5,0x3
    80012a32:	60278793          	addi	a5,a5,1538 # 80016030 <heap_limit>
    80012a36:	fd043703          	ld	a4,-48(s0)
    80012a3a:	e398                	sd	a4,0(a5)
    heap_split_thresh = split_thresh;
    80012a3c:	00003797          	auipc	a5,0x3
    80012a40:	5fc78793          	addi	a5,a5,1532 # 80016038 <heap_split_thresh>
    80012a44:	fc043703          	ld	a4,-64(s0)
    80012a48:	e398                	sd	a4,0(a5)
    heap_alignment    = alignment;
    80012a4a:	00003797          	auipc	a5,0x3
    80012a4e:	5f678793          	addi	a5,a5,1526 # 80016040 <heap_alignment>
    80012a52:	fb843703          	ld	a4,-72(s0)
    80012a56:	e398                	sd	a4,0(a5)
    heap_max_blocks   = heap_blocks;
    80012a58:	00003797          	auipc	a5,0x3
    80012a5c:	5f078793          	addi	a5,a5,1520 # 80016048 <heap_max_blocks>
    80012a60:	fc843703          	ld	a4,-56(s0)
    80012a64:	e398                	sd	a4,0(a5)

    heap->free        = NULL;
    80012a66:	00003797          	auipc	a5,0x3
    80012a6a:	5c278793          	addi	a5,a5,1474 # 80016028 <heap>
    80012a6e:	639c                	ld	a5,0(a5)
    80012a70:	0007b023          	sd	zero,0(a5)
    heap->used        = NULL;
    80012a74:	00003797          	auipc	a5,0x3
    80012a78:	5b478793          	addi	a5,a5,1460 # 80016028 <heap>
    80012a7c:	639c                	ld	a5,0(a5)
    80012a7e:	0007b423          	sd	zero,8(a5)
    heap->fresh       = (Block *)(heap + 1);
    80012a82:	00003797          	auipc	a5,0x3
    80012a86:	5a678793          	addi	a5,a5,1446 # 80016028 <heap>
    80012a8a:	6398                	ld	a4,0(a5)
    80012a8c:	00003797          	auipc	a5,0x3
    80012a90:	59c78793          	addi	a5,a5,1436 # 80016028 <heap>
    80012a94:	639c                	ld	a5,0(a5)
    80012a96:	02070713          	addi	a4,a4,32
    80012a9a:	eb98                	sd	a4,16(a5)
    heap->top         = (size_t)(heap->fresh + heap_blocks);
    80012a9c:	00003797          	auipc	a5,0x3
    80012aa0:	58c78793          	addi	a5,a5,1420 # 80016028 <heap>
    80012aa4:	639c                	ld	a5,0(a5)
    80012aa6:	6b94                	ld	a3,16(a5)
    80012aa8:	fc843703          	ld	a4,-56(s0)
    80012aac:	87ba                	mv	a5,a4
    80012aae:	0786                	slli	a5,a5,0x1
    80012ab0:	97ba                	add	a5,a5,a4
    80012ab2:	078e                	slli	a5,a5,0x3
    80012ab4:	00f68733          	add	a4,a3,a5
    80012ab8:	00003797          	auipc	a5,0x3
    80012abc:	57078793          	addi	a5,a5,1392 # 80016028 <heap>
    80012ac0:	639c                	ld	a5,0(a5)
    80012ac2:	ef98                	sd	a4,24(a5)

    Block *block      = heap->fresh;
    80012ac4:	00003797          	auipc	a5,0x3
    80012ac8:	56478793          	addi	a5,a5,1380 # 80016028 <heap>
    80012acc:	639c                	ld	a5,0(a5)
    80012ace:	6b9c                	ld	a5,16(a5)
    80012ad0:	fef43423          	sd	a5,-24(s0)
    size_t i          = heap_max_blocks - 1;
    80012ad4:	00003797          	auipc	a5,0x3
    80012ad8:	57478793          	addi	a5,a5,1396 # 80016048 <heap_max_blocks>
    80012adc:	639c                	ld	a5,0(a5)
    80012ade:	17fd                	addi	a5,a5,-1
    80012ae0:	fef43023          	sd	a5,-32(s0)
    while (i--) {
    80012ae4:	a829                	j	80012afe <init+0xf8>
        block->next = block + 1;
    80012ae6:	fe843783          	ld	a5,-24(s0)
    80012aea:	01878713          	addi	a4,a5,24
    80012aee:	fe843783          	ld	a5,-24(s0)
    80012af2:	e798                	sd	a4,8(a5)
        block++;
    80012af4:	fe843783          	ld	a5,-24(s0)
    80012af8:	07e1                	addi	a5,a5,24
    80012afa:	fef43423          	sd	a5,-24(s0)
    while (i--) {
    80012afe:	fe043783          	ld	a5,-32(s0)
    80012b02:	fff78713          	addi	a4,a5,-1
    80012b06:	fee43023          	sd	a4,-32(s0)
    80012b0a:	fff1                	bnez	a5,80012ae6 <init+0xe0>
    }
    block->next = NULL;
    80012b0c:	fe843783          	ld	a5,-24(s0)
    80012b10:	0007b423          	sd	zero,8(a5)
    return true;
    80012b14:	4785                	li	a5,1
}
    80012b16:	853e                	mv	a0,a5
    80012b18:	6426                	ld	s0,72(sp)
    80012b1a:	6161                	addi	sp,sp,80
    80012b1c:	8082                	ret

0000000080012b1e <free>:

static bool free(const void *free)
{
    80012b1e:	7179                	addi	sp,sp,-48
    80012b20:	f406                	sd	ra,40(sp)
    80012b22:	f022                	sd	s0,32(sp)
    80012b24:	1800                	addi	s0,sp,48
    80012b26:	fca43c23          	sd	a0,-40(s0)
    Block *block = heap->used;
    80012b2a:	00003797          	auipc	a5,0x3
    80012b2e:	4fe78793          	addi	a5,a5,1278 # 80016028 <heap>
    80012b32:	639c                	ld	a5,0(a5)
    80012b34:	679c                	ld	a5,8(a5)
    80012b36:	fef43423          	sd	a5,-24(s0)
    Block *prev  = NULL;
    80012b3a:	fe043023          	sd	zero,-32(s0)
    while (block != NULL) {
    80012b3e:	a8a1                	j	80012b96 <free+0x78>
        if (free == block->addr) {
    80012b40:	fe843783          	ld	a5,-24(s0)
    80012b44:	639c                	ld	a5,0(a5)
    80012b46:	fd843703          	ld	a4,-40(s0)
    80012b4a:	02f71d63          	bne	a4,a5,80012b84 <free+0x66>
            if (prev) {
    80012b4e:	fe043783          	ld	a5,-32(s0)
    80012b52:	cb81                	beqz	a5,80012b62 <free+0x44>
                prev->next = block->next;
    80012b54:	fe843783          	ld	a5,-24(s0)
    80012b58:	6798                	ld	a4,8(a5)
    80012b5a:	fe043783          	ld	a5,-32(s0)
    80012b5e:	e798                	sd	a4,8(a5)
    80012b60:	a811                	j	80012b74 <free+0x56>
            }
            else {
                heap->used = block->next;
    80012b62:	00003797          	auipc	a5,0x3
    80012b66:	4c678793          	addi	a5,a5,1222 # 80016028 <heap>
    80012b6a:	639c                	ld	a5,0(a5)
    80012b6c:	fe843703          	ld	a4,-24(s0)
    80012b70:	6718                	ld	a4,8(a4)
    80012b72:	e798                	sd	a4,8(a5)
            }
            insert_block(block);
    80012b74:	fe843503          	ld	a0,-24(s0)
    80012b78:	ccdff0ef          	jal	ra,80012844 <insert_block>
            compact();
    80012b7c:	db5ff0ef          	jal	ra,80012930 <compact>
            return true;
    80012b80:	4785                	li	a5,1
    80012b82:	a831                	j	80012b9e <free+0x80>
        }
        prev  = block;
    80012b84:	fe843783          	ld	a5,-24(s0)
    80012b88:	fef43023          	sd	a5,-32(s0)
        block = block->next;
    80012b8c:	fe843783          	ld	a5,-24(s0)
    80012b90:	679c                	ld	a5,8(a5)
    80012b92:	fef43423          	sd	a5,-24(s0)
    while (block != NULL) {
    80012b96:	fe843783          	ld	a5,-24(s0)
    80012b9a:	f3dd                	bnez	a5,80012b40 <free+0x22>
    }
    return false;
    80012b9c:	4781                	li	a5,0
}
    80012b9e:	853e                	mv	a0,a5
    80012ba0:	70a2                	ld	ra,40(sp)
    80012ba2:	7402                	ld	s0,32(sp)
    80012ba4:	6145                	addi	sp,sp,48
    80012ba6:	8082                	ret

0000000080012ba8 <alloc_block>:

static Block *alloc_block(size_t num)
{
    80012ba8:	711d                	addi	sp,sp,-96
    80012baa:	ec86                	sd	ra,88(sp)
    80012bac:	e8a2                	sd	s0,80(sp)
    80012bae:	1080                	addi	s0,sp,96
    80012bb0:	faa43423          	sd	a0,-88(s0)
    Block *ptr  = heap->free;
    80012bb4:	00003797          	auipc	a5,0x3
    80012bb8:	47478793          	addi	a5,a5,1140 # 80016028 <heap>
    80012bbc:	639c                	ld	a5,0(a5)
    80012bbe:	639c                	ld	a5,0(a5)
    80012bc0:	fef43423          	sd	a5,-24(s0)
    Block *prev = NULL;
    80012bc4:	fe043023          	sd	zero,-32(s0)
    size_t top  = heap->top;
    80012bc8:	00003797          	auipc	a5,0x3
    80012bcc:	46078793          	addi	a5,a5,1120 # 80016028 <heap>
    80012bd0:	639c                	ld	a5,0(a5)
    80012bd2:	6f9c                	ld	a5,24(a5)
    80012bd4:	fcf43c23          	sd	a5,-40(s0)
    num         = (num + heap_alignment - 1) & -heap_alignment;
    80012bd8:	00003797          	auipc	a5,0x3
    80012bdc:	46878793          	addi	a5,a5,1128 # 80016040 <heap_alignment>
    80012be0:	6398                	ld	a4,0(a5)
    80012be2:	fa843783          	ld	a5,-88(s0)
    80012be6:	97ba                	add	a5,a5,a4
    80012be8:	fff78713          	addi	a4,a5,-1
    80012bec:	00003797          	auipc	a5,0x3
    80012bf0:	45478793          	addi	a5,a5,1108 # 80016040 <heap_alignment>
    80012bf4:	639c                	ld	a5,0(a5)
    80012bf6:	40f007b3          	neg	a5,a5
    80012bfa:	8ff9                	and	a5,a5,a4
    80012bfc:	faf43423          	sd	a5,-88(s0)
    while (ptr != NULL) {
    80012c00:	a2bd                	j	80012d6e <alloc_block+0x1c6>
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    80012c02:	fe843783          	ld	a5,-24(s0)
    80012c06:	639c                	ld	a5,0(a5)
    80012c08:	873e                	mv	a4,a5
    80012c0a:	fe843783          	ld	a5,-24(s0)
    80012c0e:	6b9c                	ld	a5,16(a5)
    80012c10:	97ba                	add	a5,a5,a4
    80012c12:	fd843703          	ld	a4,-40(s0)
    80012c16:	02e7e263          	bltu	a5,a4,80012c3a <alloc_block+0x92>
                           ((size_t)ptr->addr + num <= (size_t)heap_limit);
    80012c1a:	fe843783          	ld	a5,-24(s0)
    80012c1e:	639c                	ld	a5,0(a5)
    80012c20:	873e                	mv	a4,a5
    80012c22:	fa843783          	ld	a5,-88(s0)
    80012c26:	97ba                	add	a5,a5,a4
    80012c28:	00003717          	auipc	a4,0x3
    80012c2c:	40870713          	addi	a4,a4,1032 # 80016030 <heap_limit>
    80012c30:	6318                	ld	a4,0(a4)
        const int is_top = ((size_t)ptr->addr + ptr->size >= top) &&
    80012c32:	00f76463          	bltu	a4,a5,80012c3a <alloc_block+0x92>
    80012c36:	4785                	li	a5,1
    80012c38:	a011                	j	80012c3c <alloc_block+0x94>
    80012c3a:	4781                	li	a5,0
    80012c3c:	fcf42623          	sw	a5,-52(s0)
        if (is_top || ptr->size >= num) {
    80012c40:	fcc42783          	lw	a5,-52(s0)
    80012c44:	2781                	sext.w	a5,a5
    80012c46:	eb81                	bnez	a5,80012c56 <alloc_block+0xae>
    80012c48:	fe843783          	ld	a5,-24(s0)
    80012c4c:	6b9c                	ld	a5,16(a5)
    80012c4e:	fa843703          	ld	a4,-88(s0)
    80012c52:	10e7e563          	bltu	a5,a4,80012d5c <alloc_block+0x1b4>
            if (prev != NULL) {
    80012c56:	fe043783          	ld	a5,-32(s0)
    80012c5a:	cb81                	beqz	a5,80012c6a <alloc_block+0xc2>
                prev->next = ptr->next;
    80012c5c:	fe843783          	ld	a5,-24(s0)
    80012c60:	6798                	ld	a4,8(a5)
    80012c62:	fe043783          	ld	a5,-32(s0)
    80012c66:	e798                	sd	a4,8(a5)
    80012c68:	a811                	j	80012c7c <alloc_block+0xd4>
            }
            else {
                heap->free = ptr->next;
    80012c6a:	00003797          	auipc	a5,0x3
    80012c6e:	3be78793          	addi	a5,a5,958 # 80016028 <heap>
    80012c72:	639c                	ld	a5,0(a5)
    80012c74:	fe843703          	ld	a4,-24(s0)
    80012c78:	6718                	ld	a4,8(a4)
    80012c7a:	e398                	sd	a4,0(a5)
            }
            ptr->next  = heap->used;
    80012c7c:	00003797          	auipc	a5,0x3
    80012c80:	3ac78793          	addi	a5,a5,940 # 80016028 <heap>
    80012c84:	639c                	ld	a5,0(a5)
    80012c86:	6798                	ld	a4,8(a5)
    80012c88:	fe843783          	ld	a5,-24(s0)
    80012c8c:	e798                	sd	a4,8(a5)
            heap->used = ptr;
    80012c8e:	00003797          	auipc	a5,0x3
    80012c92:	39a78793          	addi	a5,a5,922 # 80016028 <heap>
    80012c96:	639c                	ld	a5,0(a5)
    80012c98:	fe843703          	ld	a4,-24(s0)
    80012c9c:	e798                	sd	a4,8(a5)
            if (is_top) {
    80012c9e:	fcc42783          	lw	a5,-52(s0)
    80012ca2:	2781                	sext.w	a5,a5
    80012ca4:	c785                	beqz	a5,80012ccc <alloc_block+0x124>
                ptr->size = num;
    80012ca6:	fe843783          	ld	a5,-24(s0)
    80012caa:	fa843703          	ld	a4,-88(s0)
    80012cae:	eb98                	sd	a4,16(a5)
                heap->top = (size_t)ptr->addr + num;
    80012cb0:	fe843783          	ld	a5,-24(s0)
    80012cb4:	639c                	ld	a5,0(a5)
    80012cb6:	86be                	mv	a3,a5
    80012cb8:	00003797          	auipc	a5,0x3
    80012cbc:	37078793          	addi	a5,a5,880 # 80016028 <heap>
    80012cc0:	639c                	ld	a5,0(a5)
    80012cc2:	fa843703          	ld	a4,-88(s0)
    80012cc6:	9736                	add	a4,a4,a3
    80012cc8:	ef98                	sd	a4,24(a5)
    80012cca:	a071                	j	80012d56 <alloc_block+0x1ae>
            }
            else if (heap->fresh != NULL) {
    80012ccc:	00003797          	auipc	a5,0x3
    80012cd0:	35c78793          	addi	a5,a5,860 # 80016028 <heap>
    80012cd4:	639c                	ld	a5,0(a5)
    80012cd6:	6b9c                	ld	a5,16(a5)
    80012cd8:	cfbd                	beqz	a5,80012d56 <alloc_block+0x1ae>
                size_t excess = ptr->size - num;
    80012cda:	fe843783          	ld	a5,-24(s0)
    80012cde:	6b98                	ld	a4,16(a5)
    80012ce0:	fa843783          	ld	a5,-88(s0)
    80012ce4:	40f707b3          	sub	a5,a4,a5
    80012ce8:	fcf43023          	sd	a5,-64(s0)
                if (excess >= heap_split_thresh) {
    80012cec:	00003797          	auipc	a5,0x3
    80012cf0:	34c78793          	addi	a5,a5,844 # 80016038 <heap_split_thresh>
    80012cf4:	639c                	ld	a5,0(a5)
    80012cf6:	fc043703          	ld	a4,-64(s0)
    80012cfa:	04f76e63          	bltu	a4,a5,80012d56 <alloc_block+0x1ae>
                    ptr->size    = num;
    80012cfe:	fe843783          	ld	a5,-24(s0)
    80012d02:	fa843703          	ld	a4,-88(s0)
    80012d06:	eb98                	sd	a4,16(a5)
                    Block *split = heap->fresh;
    80012d08:	00003797          	auipc	a5,0x3
    80012d0c:	32078793          	addi	a5,a5,800 # 80016028 <heap>
    80012d10:	639c                	ld	a5,0(a5)
    80012d12:	6b9c                	ld	a5,16(a5)
    80012d14:	faf43c23          	sd	a5,-72(s0)
                    heap->fresh  = split->next;
    80012d18:	00003797          	auipc	a5,0x3
    80012d1c:	31078793          	addi	a5,a5,784 # 80016028 <heap>
    80012d20:	639c                	ld	a5,0(a5)
    80012d22:	fb843703          	ld	a4,-72(s0)
    80012d26:	6718                	ld	a4,8(a4)
    80012d28:	eb98                	sd	a4,16(a5)
                    split->addr  = (void *)((size_t)ptr->addr + num);
    80012d2a:	fe843783          	ld	a5,-24(s0)
    80012d2e:	639c                	ld	a5,0(a5)
    80012d30:	873e                	mv	a4,a5
    80012d32:	fa843783          	ld	a5,-88(s0)
    80012d36:	97ba                	add	a5,a5,a4
    80012d38:	873e                	mv	a4,a5
    80012d3a:	fb843783          	ld	a5,-72(s0)
    80012d3e:	e398                	sd	a4,0(a5)
                    split->size  = excess;
    80012d40:	fb843783          	ld	a5,-72(s0)
    80012d44:	fc043703          	ld	a4,-64(s0)
    80012d48:	eb98                	sd	a4,16(a5)
                    insert_block(split);
    80012d4a:	fb843503          	ld	a0,-72(s0)
    80012d4e:	af7ff0ef          	jal	ra,80012844 <insert_block>
                    compact();
    80012d52:	bdfff0ef          	jal	ra,80012930 <compact>
                }
            }
            return ptr;
    80012d56:	fe843783          	ld	a5,-24(s0)
    80012d5a:	a875                	j	80012e16 <alloc_block+0x26e>
        }
        prev = ptr;
    80012d5c:	fe843783          	ld	a5,-24(s0)
    80012d60:	fef43023          	sd	a5,-32(s0)
        ptr  = ptr->next;
    80012d64:	fe843783          	ld	a5,-24(s0)
    80012d68:	679c                	ld	a5,8(a5)
    80012d6a:	fef43423          	sd	a5,-24(s0)
    while (ptr != NULL) {
    80012d6e:	fe843783          	ld	a5,-24(s0)
    80012d72:	e80798e3          	bnez	a5,80012c02 <alloc_block+0x5a>
    }
    // no matching free blocks
    // see if any other blocks available
    size_t new_top = top + num;
    80012d76:	fd843703          	ld	a4,-40(s0)
    80012d7a:	fa843783          	ld	a5,-88(s0)
    80012d7e:	97ba                	add	a5,a5,a4
    80012d80:	fcf43823          	sd	a5,-48(s0)
    if (heap->fresh != NULL && new_top <= (size_t)heap_limit) {
    80012d84:	00003797          	auipc	a5,0x3
    80012d88:	2a478793          	addi	a5,a5,676 # 80016028 <heap>
    80012d8c:	639c                	ld	a5,0(a5)
    80012d8e:	6b9c                	ld	a5,16(a5)
    80012d90:	c3d1                	beqz	a5,80012e14 <alloc_block+0x26c>
    80012d92:	00003797          	auipc	a5,0x3
    80012d96:	29e78793          	addi	a5,a5,670 # 80016030 <heap_limit>
    80012d9a:	639c                	ld	a5,0(a5)
    80012d9c:	873e                	mv	a4,a5
    80012d9e:	fd043783          	ld	a5,-48(s0)
    80012da2:	06f76963          	bltu	a4,a5,80012e14 <alloc_block+0x26c>
        ptr         = heap->fresh;
    80012da6:	00003797          	auipc	a5,0x3
    80012daa:	28278793          	addi	a5,a5,642 # 80016028 <heap>
    80012dae:	639c                	ld	a5,0(a5)
    80012db0:	6b9c                	ld	a5,16(a5)
    80012db2:	fef43423          	sd	a5,-24(s0)
        heap->fresh = ptr->next;
    80012db6:	00003797          	auipc	a5,0x3
    80012dba:	27278793          	addi	a5,a5,626 # 80016028 <heap>
    80012dbe:	639c                	ld	a5,0(a5)
    80012dc0:	fe843703          	ld	a4,-24(s0)
    80012dc4:	6718                	ld	a4,8(a4)
    80012dc6:	eb98                	sd	a4,16(a5)
        ptr->addr   = (void *)top;
    80012dc8:	fd843703          	ld	a4,-40(s0)
    80012dcc:	fe843783          	ld	a5,-24(s0)
    80012dd0:	e398                	sd	a4,0(a5)
        ptr->next   = heap->used;
    80012dd2:	00003797          	auipc	a5,0x3
    80012dd6:	25678793          	addi	a5,a5,598 # 80016028 <heap>
    80012dda:	639c                	ld	a5,0(a5)
    80012ddc:	6798                	ld	a4,8(a5)
    80012dde:	fe843783          	ld	a5,-24(s0)
    80012de2:	e798                	sd	a4,8(a5)
        ptr->size   = num;
    80012de4:	fe843783          	ld	a5,-24(s0)
    80012de8:	fa843703          	ld	a4,-88(s0)
    80012dec:	eb98                	sd	a4,16(a5)
        heap->used  = ptr;
    80012dee:	00003797          	auipc	a5,0x3
    80012df2:	23a78793          	addi	a5,a5,570 # 80016028 <heap>
    80012df6:	639c                	ld	a5,0(a5)
    80012df8:	fe843703          	ld	a4,-24(s0)
    80012dfc:	e798                	sd	a4,8(a5)
        heap->top   = new_top;
    80012dfe:	00003797          	auipc	a5,0x3
    80012e02:	22a78793          	addi	a5,a5,554 # 80016028 <heap>
    80012e06:	639c                	ld	a5,0(a5)
    80012e08:	fd043703          	ld	a4,-48(s0)
    80012e0c:	ef98                	sd	a4,24(a5)
        return ptr;
    80012e0e:	fe843783          	ld	a5,-24(s0)
    80012e12:	a011                	j	80012e16 <alloc_block+0x26e>
    }
    return NULL;
    80012e14:	4781                	li	a5,0
}
    80012e16:	853e                	mv	a0,a5
    80012e18:	60e6                	ld	ra,88(sp)
    80012e1a:	6446                	ld	s0,80(sp)
    80012e1c:	6125                	addi	sp,sp,96
    80012e1e:	8082                	ret

0000000080012e20 <alloc>:

static void *alloc(size_t num)
{
    80012e20:	7179                	addi	sp,sp,-48
    80012e22:	f406                	sd	ra,40(sp)
    80012e24:	f022                	sd	s0,32(sp)
    80012e26:	1800                	addi	s0,sp,48
    80012e28:	fca43c23          	sd	a0,-40(s0)
    Block *block = alloc_block(num);
    80012e2c:	fd843503          	ld	a0,-40(s0)
    80012e30:	d79ff0ef          	jal	ra,80012ba8 <alloc_block>
    80012e34:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80012e38:	fe843783          	ld	a5,-24(s0)
    80012e3c:	c789                	beqz	a5,80012e46 <alloc+0x26>
        return block->addr;
    80012e3e:	fe843783          	ld	a5,-24(s0)
    80012e42:	639c                	ld	a5,0(a5)
    80012e44:	a011                	j	80012e48 <alloc+0x28>
    }
    return NULL;
    80012e46:	4781                	li	a5,0
}
    80012e48:	853e                	mv	a0,a5
    80012e4a:	70a2                	ld	ra,40(sp)
    80012e4c:	7402                	ld	s0,32(sp)
    80012e4e:	6145                	addi	sp,sp,48
    80012e50:	8082                	ret

0000000080012e52 <calloc>:

static void *calloc(size_t num, size_t size)
{
    80012e52:	7179                	addi	sp,sp,-48
    80012e54:	f406                	sd	ra,40(sp)
    80012e56:	f022                	sd	s0,32(sp)
    80012e58:	1800                	addi	s0,sp,48
    80012e5a:	fca43c23          	sd	a0,-40(s0)
    80012e5e:	fcb43823          	sd	a1,-48(s0)
    num *= size;
    80012e62:	fd843703          	ld	a4,-40(s0)
    80012e66:	fd043783          	ld	a5,-48(s0)
    80012e6a:	02f707b3          	mul	a5,a4,a5
    80012e6e:	fcf43c23          	sd	a5,-40(s0)
    Block *block = alloc_block(num);
    80012e72:	fd843503          	ld	a0,-40(s0)
    80012e76:	d33ff0ef          	jal	ra,80012ba8 <alloc_block>
    80012e7a:	fea43423          	sd	a0,-24(s0)
    if (block != NULL) {
    80012e7e:	fe843783          	ld	a5,-24(s0)
    80012e82:	c385                	beqz	a5,80012ea2 <calloc+0x50>
        memset(block->addr, 0, num);
    80012e84:	fe843783          	ld	a5,-24(s0)
    80012e88:	639c                	ld	a5,0(a5)
    80012e8a:	fd843703          	ld	a4,-40(s0)
    80012e8e:	2701                	sext.w	a4,a4
    80012e90:	863a                	mv	a2,a4
    80012e92:	4581                	li	a1,0
    80012e94:	853e                	mv	a0,a5
    80012e96:	617000ef          	jal	ra,80013cac <memset>
        return block->addr;
    80012e9a:	fe843783          	ld	a5,-24(s0)
    80012e9e:	639c                	ld	a5,0(a5)
    80012ea0:	a011                	j	80012ea4 <calloc+0x52>
    }
    return NULL;
    80012ea2:	4781                	li	a5,0
}
    80012ea4:	853e                	mv	a0,a5
    80012ea6:	70a2                	ld	ra,40(sp)
    80012ea8:	7402                	ld	s0,32(sp)
    80012eaa:	6145                	addi	sp,sp,48
    80012eac:	8082                	ret

0000000080012eae <count_blocks>:

static size_t count_blocks(Block *ptr)
{
    80012eae:	7179                	addi	sp,sp,-48
    80012eb0:	f422                	sd	s0,40(sp)
    80012eb2:	1800                	addi	s0,sp,48
    80012eb4:	fca43c23          	sd	a0,-40(s0)
    size_t num = 0;
    80012eb8:	fe043423          	sd	zero,-24(s0)
    while (ptr != NULL) {
    80012ebc:	a819                	j	80012ed2 <count_blocks+0x24>
        num++;
    80012ebe:	fe843783          	ld	a5,-24(s0)
    80012ec2:	0785                	addi	a5,a5,1
    80012ec4:	fef43423          	sd	a5,-24(s0)
        ptr = ptr->next;
    80012ec8:	fd843783          	ld	a5,-40(s0)
    80012ecc:	679c                	ld	a5,8(a5)
    80012ece:	fcf43c23          	sd	a5,-40(s0)
    while (ptr != NULL) {
    80012ed2:	fd843783          	ld	a5,-40(s0)
    80012ed6:	f7e5                	bnez	a5,80012ebe <count_blocks+0x10>
    }
    return num;
    80012ed8:	fe843783          	ld	a5,-24(s0)
}
    80012edc:	853e                	mv	a0,a5
    80012ede:	7422                	ld	s0,40(sp)
    80012ee0:	6145                	addi	sp,sp,48
    80012ee2:	8082                	ret

0000000080012ee4 <heap_num_free>:
static size_t heap_num_free()
{
    80012ee4:	1141                	addi	sp,sp,-16
    80012ee6:	e406                	sd	ra,8(sp)
    80012ee8:	e022                	sd	s0,0(sp)
    80012eea:	0800                	addi	s0,sp,16
    return count_blocks(heap->free);
    80012eec:	00003797          	auipc	a5,0x3
    80012ef0:	13c78793          	addi	a5,a5,316 # 80016028 <heap>
    80012ef4:	639c                	ld	a5,0(a5)
    80012ef6:	639c                	ld	a5,0(a5)
    80012ef8:	853e                	mv	a0,a5
    80012efa:	fb5ff0ef          	jal	ra,80012eae <count_blocks>
    80012efe:	87aa                	mv	a5,a0
}
    80012f00:	853e                	mv	a0,a5
    80012f02:	60a2                	ld	ra,8(sp)
    80012f04:	6402                	ld	s0,0(sp)
    80012f06:	0141                	addi	sp,sp,16
    80012f08:	8082                	ret

0000000080012f0a <heap_num_used>:
static size_t heap_num_used()
{
    80012f0a:	1141                	addi	sp,sp,-16
    80012f0c:	e406                	sd	ra,8(sp)
    80012f0e:	e022                	sd	s0,0(sp)
    80012f10:	0800                	addi	s0,sp,16
    return count_blocks(heap->used);
    80012f12:	00003797          	auipc	a5,0x3
    80012f16:	11678793          	addi	a5,a5,278 # 80016028 <heap>
    80012f1a:	639c                	ld	a5,0(a5)
    80012f1c:	679c                	ld	a5,8(a5)
    80012f1e:	853e                	mv	a0,a5
    80012f20:	f8fff0ef          	jal	ra,80012eae <count_blocks>
    80012f24:	87aa                	mv	a5,a0
}
    80012f26:	853e                	mv	a0,a5
    80012f28:	60a2                	ld	ra,8(sp)
    80012f2a:	6402                	ld	s0,0(sp)
    80012f2c:	0141                	addi	sp,sp,16
    80012f2e:	8082                	ret

0000000080012f30 <heap_num_fresh>:
static size_t heap_num_fresh()
{
    80012f30:	1141                	addi	sp,sp,-16
    80012f32:	e406                	sd	ra,8(sp)
    80012f34:	e022                	sd	s0,0(sp)
    80012f36:	0800                	addi	s0,sp,16
    return count_blocks(heap->fresh);
    80012f38:	00003797          	auipc	a5,0x3
    80012f3c:	0f078793          	addi	a5,a5,240 # 80016028 <heap>
    80012f40:	639c                	ld	a5,0(a5)
    80012f42:	6b9c                	ld	a5,16(a5)
    80012f44:	853e                	mv	a0,a5
    80012f46:	f69ff0ef          	jal	ra,80012eae <count_blocks>
    80012f4a:	87aa                	mv	a5,a0
}
    80012f4c:	853e                	mv	a0,a5
    80012f4e:	60a2                	ld	ra,8(sp)
    80012f50:	6402                	ld	s0,0(sp)
    80012f52:	0141                	addi	sp,sp,16
    80012f54:	8082                	ret

0000000080012f56 <heap_check>:
static bool heap_check()
{
    80012f56:	1101                	addi	sp,sp,-32
    80012f58:	ec06                	sd	ra,24(sp)
    80012f5a:	e822                	sd	s0,16(sp)
    80012f5c:	e426                	sd	s1,8(sp)
    80012f5e:	1000                	addi	s0,sp,32
    return heap_max_blocks == heap_num_free() + heap_num_used() + heap_num_fresh();
    80012f60:	f85ff0ef          	jal	ra,80012ee4 <heap_num_free>
    80012f64:	84aa                	mv	s1,a0
    80012f66:	fa5ff0ef          	jal	ra,80012f0a <heap_num_used>
    80012f6a:	87aa                	mv	a5,a0
    80012f6c:	94be                	add	s1,s1,a5
    80012f6e:	fc3ff0ef          	jal	ra,80012f30 <heap_num_fresh>
    80012f72:	87aa                	mv	a5,a0
    80012f74:	00f48733          	add	a4,s1,a5
    80012f78:	00003797          	auipc	a5,0x3
    80012f7c:	0d078793          	addi	a5,a5,208 # 80016048 <heap_max_blocks>
    80012f80:	639c                	ld	a5,0(a5)
    80012f82:	40f707b3          	sub	a5,a4,a5
    80012f86:	0017b793          	seqz	a5,a5
    80012f8a:	0ff7f793          	andi	a5,a5,255
}
    80012f8e:	853e                	mv	a0,a5
    80012f90:	60e2                	ld	ra,24(sp)
    80012f92:	6442                	ld	s0,16(sp)
    80012f94:	64a2                	ld	s1,8(sp)
    80012f96:	6105                	addi	sp,sp,32
    80012f98:	8082                	ret

0000000080012f9a <heap_print_stats>:

void heap_print_stats(void)
{
    80012f9a:	7179                	addi	sp,sp,-48
    80012f9c:	f406                	sd	ra,40(sp)
    80012f9e:	f022                	sd	s0,32(sp)
    80012fa0:	ec26                	sd	s1,24(sp)
    80012fa2:	e84a                	sd	s2,16(sp)
    80012fa4:	e44e                	sd	s3,8(sp)
    80012fa6:	1800                	addi	s0,sp,48
    textf(
    80012fa8:	f3dff0ef          	jal	ra,80012ee4 <heap_num_free>
    80012fac:	84aa                	mv	s1,a0
    80012fae:	f5dff0ef          	jal	ra,80012f0a <heap_num_used>
    80012fb2:	892a                	mv	s2,a0
    80012fb4:	f7dff0ef          	jal	ra,80012f30 <heap_num_fresh>
    80012fb8:	89aa                	mv	s3,a0
    80012fba:	f9dff0ef          	jal	ra,80012f56 <heap_check>
    80012fbe:	87aa                	mv	a5,a0
    80012fc0:	c791                	beqz	a5,80012fcc <heap_print_stats+0x32>
    80012fc2:	00004797          	auipc	a5,0x4
    80012fc6:	43e78793          	addi	a5,a5,1086 # 80017400 <__func__.0+0x10>
    80012fca:	a029                	j	80012fd4 <heap_print_stats+0x3a>
    80012fcc:	00004797          	auipc	a5,0x4
    80012fd0:	43c78793          	addi	a5,a5,1084 # 80017408 <__func__.0+0x18>
    80012fd4:	874e                	mv	a4,s3
    80012fd6:	86ca                	mv	a3,s2
    80012fd8:	8626                	mv	a2,s1
    80012fda:	00004597          	auipc	a1,0x4
    80012fde:	43658593          	addi	a1,a1,1078 # 80017410 <__func__.0+0x20>
    80012fe2:	4541                	li	a0,16
    80012fe4:	bfeff0ef          	jal	ra,800123e2 <logf>
        "HEAP\n~~~~\nFree blocks:    %lu\nUsed blocks:    %lu\nFresh blocks:   %lu\nHeap "
        "check:     %s\n",
        heap_num_free(), heap_num_used(), heap_num_fresh(), heap_check() ? "good" : "bad");
}
    80012fe8:	0001                	nop
    80012fea:	70a2                	ld	ra,40(sp)
    80012fec:	7402                	ld	s0,32(sp)
    80012fee:	64e2                	ld	s1,24(sp)
    80012ff0:	6942                	ld	s2,16(sp)
    80012ff2:	69a2                	ld	s3,8(sp)
    80012ff4:	6145                	addi	sp,sp,48
    80012ff6:	8082                	ret

0000000080012ff8 <kmalloc>:
void *kmalloc(size_t sz)
{
    80012ff8:	1101                	addi	sp,sp,-32
    80012ffa:	ec06                	sd	ra,24(sp)
    80012ffc:	e822                	sd	s0,16(sp)
    80012ffe:	1000                	addi	s0,sp,32
    80013000:	fea43423          	sd	a0,-24(s0)
#ifdef DEBUG_KMALLOC
    debugf("%lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return alloc(sz);
    80013004:	fe843503          	ld	a0,-24(s0)
    80013008:	e19ff0ef          	jal	ra,80012e20 <alloc>
    8001300c:	87aa                	mv	a5,a0
}
    8001300e:	853e                	mv	a0,a5
    80013010:	60e2                	ld	ra,24(sp)
    80013012:	6442                	ld	s0,16(sp)
    80013014:	6105                	addi	sp,sp,32
    80013016:	8082                	ret

0000000080013018 <kcalloc>:
void *kcalloc(size_t n, size_t sz)
{
    80013018:	1101                	addi	sp,sp,-32
    8001301a:	ec06                	sd	ra,24(sp)
    8001301c:	e822                	sd	s0,16(sp)
    8001301e:	1000                	addi	s0,sp,32
    80013020:	fea43423          	sd	a0,-24(s0)
    80013024:	feb43023          	sd	a1,-32(s0)
#ifdef DEBUG_KMALLOC
    debugf("%lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
    return calloc(n, sz);
    80013028:	fe043583          	ld	a1,-32(s0)
    8001302c:	fe843503          	ld	a0,-24(s0)
    80013030:	e23ff0ef          	jal	ra,80012e52 <calloc>
    80013034:	87aa                	mv	a5,a0
}
    80013036:	853e                	mv	a0,a5
    80013038:	60e2                	ld	ra,24(sp)
    8001303a:	6442                	ld	s0,16(sp)
    8001303c:	6105                	addi	sp,sp,32
    8001303e:	8082                	ret

0000000080013040 <kfree>:
void kfree(void *m)
{
    80013040:	1101                	addi	sp,sp,-32
    80013042:	ec06                	sd	ra,24(sp)
    80013044:	e822                	sd	s0,16(sp)
    80013046:	1000                	addi	s0,sp,32
    80013048:	fea43423          	sd	a0,-24(s0)
    if (m != NULL) {
    8001304c:	fe843783          	ld	a5,-24(s0)
    80013050:	c789                	beqz	a5,8001305a <kfree+0x1a>
        free(m);
    80013052:	fe843503          	ld	a0,-24(s0)
    80013056:	ac9ff0ef          	jal	ra,80012b1e <free>
    }
#ifdef DEBUG_KMALLOC
    debugf("%lu/%lu/%lu %d\n", heap_num_free(), heap_num_used(), heap_num_fresh(),
           heap_check());
#endif
}
    8001305a:	0001                	nop
    8001305c:	60e2                	ld	ra,24(sp)
    8001305e:	6442                	ld	s0,16(sp)
    80013060:	6105                	addi	sp,sp,32
    80013062:	8082                	ret

0000000080013064 <heap_init>:

void heap_init(void)
{
    80013064:	1101                	addi	sp,sp,-32
    80013066:	ec06                	sd	ra,24(sp)
    80013068:	e822                	sd	s0,16(sp)
    8001306a:	1000                	addi	s0,sp,32
#ifdef DEBUG_HEAP
    debugf("Prior to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif
    void *start = page_znalloc(KERNEL_HEAP_PAGES);
    8001306c:	6511                	lui	a0,0x4
    8001306e:	347000ef          	jal	ra,80013bb4 <page_znalloc>
    80013072:	fea43423          	sd	a0,-24(s0)
    debugf("Heap start at 0x%08lx\n", start);
    debugf("After to kernel alloc: Taken: %d, Free: %d\n", page_count_taken(),
           page_count_free());
#endif

    mmu_map_range(kernel_mmu_table, KERNEL_HEAP_START_VADDR, KERNEL_HEAP_END_VADDR, (uint64_t)start,
    80013076:	00003797          	auipc	a5,0x3
    8001307a:	f8a78793          	addi	a5,a5,-118 # 80016000 <kernel_mmu_table>
    8001307e:	6388                	ld	a0,0(a5)
    80013080:	fe843683          	ld	a3,-24(s0)
    80013084:	4799                	li	a5,6
    80013086:	4701                	li	a4,0
    80013088:	00e0a637          	lui	a2,0xe0a
    8001308c:	165d                	addi	a2,a2,-9
    8001308e:	0636                	slli	a2,a2,0xd
    80013090:	00e085b7          	lui	a1,0xe08
    80013094:	15dd                	addi	a1,a1,-9
    80013096:	05b6                	slli	a1,a1,0xd
    80013098:	e66ff0ef          	jal	ra,800126fe <mmu_map_range>
                  MMU_LEVEL_4K, PB_READ | PB_WRITE);
    init((void *)KERNEL_HEAP_START_VADDR, (void *)KERNEL_HEAP_END_VADDR, KERNEL_HEAP_PAGES / 4, 16,
    8001309c:	4721                	li	a4,8
    8001309e:	46c1                	li	a3,16
    800130a0:	6605                	lui	a2,0x1
    800130a2:	00e0a7b7          	lui	a5,0xe0a
    800130a6:	17dd                	addi	a5,a5,-9
    800130a8:	00d79593          	slli	a1,a5,0xd
    800130ac:	00e087b7          	lui	a5,0xe08
    800130b0:	17dd                	addi	a5,a5,-9
    800130b2:	00d79513          	slli	a0,a5,0xd
    800130b6:	951ff0ef          	jal	ra,80012a06 <init>
         8);

}
    800130ba:	0001                	nop
    800130bc:	60e2                	ld	ra,24(sp)
    800130be:	6442                	ld	s0,16(sp)
    800130c0:	6105                	addi	sp,sp,32
    800130c2:	8082                	ret

00000000800130c4 <init_systems>:
// the kernel.
// Defined in src/include/mmu.h
struct page_table *kernel_mmu_table;

static void init_systems(void)
{
    800130c4:	1101                	addi	sp,sp,-32
    800130c6:	ec06                	sd	ra,24(sp)
    800130c8:	e822                	sd	s0,16(sp)
    800130ca:	1000                	addi	s0,sp,32
    void plic_init(void);
    plic_init();
    800130cc:	1e3000ef          	jal	ra,80013aae <plic_init>

#ifdef USE_PAGE_ALLOC
    // Initialize the page allocator
    page_init();
    800130d0:	249000ef          	jal	ra,80013b18 <page_init>
#endif

#ifdef USE_MMU
    // Allocate and zero the kernel's page table.
    struct page_table *pt = mmu_table_create();
    800130d4:	d06ff0ef          	jal	ra,800125da <mmu_table_create>
    800130d8:	fea43423          	sd	a0,-24(s0)
    kernel_mmu_table      = pt;
    800130dc:	00003797          	auipc	a5,0x3
    800130e0:	f2478793          	addi	a5,a5,-220 # 80016000 <kernel_mmu_table>
    800130e4:	fe843703          	ld	a4,-24(s0)
    800130e8:	e398                	sd	a4,0(a5)
    // Map memory segments for our kernel
    mmu_map_range(pt, sym_start(text), sym_end(heap), sym_start(text), MMU_LEVEL_1G,
    800130ea:	ffffd597          	auipc	a1,0xffffd
    800130ee:	f1658593          	addi	a1,a1,-234 # 80010000 <_memory_start>
    800130f2:	07ffd617          	auipc	a2,0x7ffd
    800130f6:	f0e60613          	addi	a2,a2,-242 # 88010000 <_heap_end>
    800130fa:	ffffd697          	auipc	a3,0xffffd
    800130fe:	f0668693          	addi	a3,a3,-250 # 80010000 <_memory_start>
    80013102:	47b9                	li	a5,14
    80013104:	4709                	li	a4,2
    80013106:	fe843503          	ld	a0,-24(s0)
    8001310a:	df4ff0ef          	jal	ra,800126fe <mmu_map_range>
                  PB_READ | PB_WRITE | PB_EXECUTE);
    // PLIC
    mmu_map_range(pt, 0x0C000000, 0x0C2FFFFF, 0x0C000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    8001310e:	4799                	li	a5,6
    80013110:	4705                	li	a4,1
    80013112:	0c0006b7          	lui	a3,0xc000
    80013116:	0c300637          	lui	a2,0xc300
    8001311a:	167d                	addi	a2,a2,-1
    8001311c:	0c0005b7          	lui	a1,0xc000
    80013120:	fe843503          	ld	a0,-24(s0)
    80013124:	ddaff0ef          	jal	ra,800126fe <mmu_map_range>
    // PCIe ECAM
    mmu_map_range(pt, 0x30000000, 0x30FFFFFF, 0x30000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80013128:	4799                	li	a5,6
    8001312a:	4705                	li	a4,1
    8001312c:	300006b7          	lui	a3,0x30000
    80013130:	31000637          	lui	a2,0x31000
    80013134:	167d                	addi	a2,a2,-1
    80013136:	300005b7          	lui	a1,0x30000
    8001313a:	fe843503          	ld	a0,-24(s0)
    8001313e:	dc0ff0ef          	jal	ra,800126fe <mmu_map_range>
    // PCIe MMIO
    mmu_map_range(pt, 0x40000000, 0x4FFFFFFF, 0x40000000, MMU_LEVEL_2M, PB_READ | PB_WRITE);
    80013142:	4799                	li	a5,6
    80013144:	4705                	li	a4,1
    80013146:	400006b7          	lui	a3,0x40000
    8001314a:	50000637          	lui	a2,0x50000
    8001314e:	167d                	addi	a2,a2,-1
    80013150:	400005b7          	lui	a1,0x40000
    80013154:	fe843503          	ld	a0,-24(s0)
    80013158:	da6ff0ef          	jal	ra,800126fe <mmu_map_range>


    // TODO: turn on the MMU when you've written the src/mmu.c functions
    CSR_WRITE("satp", SATP_KERNEL);
    8001315c:	00003797          	auipc	a5,0x3
    80013160:	ea478793          	addi	a5,a5,-348 # 80016000 <kernel_mmu_table>
    80013164:	639c                	ld	a5,0(a5)
    80013166:	00c7d713          	srli	a4,a5,0xc
    8001316a:	57fd                	li	a5,-1
    8001316c:	83d1                	srli	a5,a5,0x14
    8001316e:	8f7d                	and	a4,a4,a5
    80013170:	8ffff7b7          	lui	a5,0x8ffff
    80013174:	1782                	slli	a5,a5,0x20
    80013176:	8fd9                	or	a5,a5,a4
    80013178:	18079073          	csrw	satp,a5
    SFENCE_ALL();
    8001317c:	12000073          	sfence.vma
#endif
#ifdef USE_VIRTIO
    void virtio_init(void);
    virtio_init();
#endif
}
    80013180:	0001                	nop
    80013182:	60e2                	ld	ra,24(sp)
    80013184:	6442                	ld	s0,16(sp)
    80013186:	6105                	addi	sp,sp,32
    80013188:	8082                	ret

000000008001318a <main>:
static const char *hart_status_values[] = {"NOT PRESENT", "STOPPED", "STARTING", "RUNNING"};
#ifdef RUN_INTERNAL_CONSOLE
static void console(void);
#endif
void main(unsigned int hart)
{
    8001318a:	7179                	addi	sp,sp,-48
    8001318c:	f406                	sd	ra,40(sp)
    8001318e:	f022                	sd	s0,32(sp)
    80013190:	1800                	addi	s0,sp,48
    80013192:	87aa                	mv	a5,a0
    80013194:	fcf42e23          	sw	a5,-36(s0)
    // Kind of neat to see our memory mappings to ensure they make sense.
    text("[[ MEMORY MAPPINGS ]]\n");
    80013198:	00004597          	auipc	a1,0x4
    8001319c:	30858593          	addi	a1,a1,776 # 800174a0 <__func__.0+0xb0>
    800131a0:	4541                	li	a0,16
    800131a2:	a40ff0ef          	jal	ra,800123e2 <logf>
    textf("  [TEXT]  : 0x%08lx -> 0x%08lx\n", sym_start(text), sym_end(text));
    800131a6:	ffffd797          	auipc	a5,0xffffd
    800131aa:	e5a78793          	addi	a5,a5,-422 # 80010000 <_memory_start>
    800131ae:	00001717          	auipc	a4,0x1
    800131b2:	62870713          	addi	a4,a4,1576 # 800147d6 <_text_end>
    800131b6:	86ba                	mv	a3,a4
    800131b8:	863e                	mv	a2,a5
    800131ba:	00004597          	auipc	a1,0x4
    800131be:	2fe58593          	addi	a1,a1,766 # 800174b8 <__func__.0+0xc8>
    800131c2:	4541                	li	a0,16
    800131c4:	a1eff0ef          	jal	ra,800123e2 <logf>
    textf("  [BSS]   : 0x%08lx -> 0x%08lx\n", sym_start(bss), sym_end(bss));
    800131c8:	00003797          	auipc	a5,0x3
    800131cc:	e3878793          	addi	a5,a5,-456 # 80016000 <kernel_mmu_table>
    800131d0:	00003717          	auipc	a4,0x3
    800131d4:	e8070713          	addi	a4,a4,-384 # 80016050 <_bss_end>
    800131d8:	86ba                	mv	a3,a4
    800131da:	863e                	mv	a2,a5
    800131dc:	00004597          	auipc	a1,0x4
    800131e0:	2fc58593          	addi	a1,a1,764 # 800174d8 <__func__.0+0xe8>
    800131e4:	4541                	li	a0,16
    800131e6:	9fcff0ef          	jal	ra,800123e2 <logf>
    textf("  [RODATA]: 0x%08lx -> 0x%08lx\n", sym_start(rodata), sym_end(rodata));
    800131ea:	00004797          	auipc	a5,0x4
    800131ee:	e1678793          	addi	a5,a5,-490 # 80017000 <SYSCALLS>
    800131f2:	00005717          	auipc	a4,0x5
    800131f6:	e5070713          	addi	a4,a4,-432 # 80018042 <_rodata_end>
    800131fa:	86ba                	mv	a3,a4
    800131fc:	863e                	mv	a2,a5
    800131fe:	00004597          	auipc	a1,0x4
    80013202:	2fa58593          	addi	a1,a1,762 # 800174f8 <__func__.0+0x108>
    80013206:	4541                	li	a0,16
    80013208:	9daff0ef          	jal	ra,800123e2 <logf>
    textf("  [DATA]  : 0x%08lx -> 0x%08lx\n", sym_start(data), sym_end(data));
    8001320c:	00006797          	auipc	a5,0x6
    80013210:	df478793          	addi	a5,a5,-524 # 80019000 <k_log_level>
    80013214:	00006717          	auipc	a4,0x6
    80013218:	e1470713          	addi	a4,a4,-492 # 80019028 <_data_end>
    8001321c:	86ba                	mv	a3,a4
    8001321e:	863e                	mv	a2,a5
    80013220:	00004597          	auipc	a1,0x4
    80013224:	2f858593          	addi	a1,a1,760 # 80017518 <__func__.0+0x128>
    80013228:	4541                	li	a0,16
    8001322a:	9b8ff0ef          	jal	ra,800123e2 <logf>
    textf("  [STACK] : 0x%08lx -> 0x%08lx\n", sym_start(stack), sym_end(stack));
    8001322e:	00007797          	auipc	a5,0x7
    80013232:	dd278793          	addi	a5,a5,-558 # 8001a000 <_stack_start>
    80013236:	00009717          	auipc	a4,0x9
    8001323a:	dca70713          	addi	a4,a4,-566 # 8001c000 <_heap_start>
    8001323e:	86ba                	mv	a3,a4
    80013240:	863e                	mv	a2,a5
    80013242:	00004597          	auipc	a1,0x4
    80013246:	2f658593          	addi	a1,a1,758 # 80017538 <__func__.0+0x148>
    8001324a:	4541                	li	a0,16
    8001324c:	996ff0ef          	jal	ra,800123e2 <logf>
    textf("  [HEAP]  : 0x%08lx -> 0x%08lx\n", sym_start(heap), sym_end(heap));
    80013250:	00009797          	auipc	a5,0x9
    80013254:	db078793          	addi	a5,a5,-592 # 8001c000 <_heap_start>
    80013258:	07ffd717          	auipc	a4,0x7ffd
    8001325c:	da870713          	addi	a4,a4,-600 # 88010000 <_heap_end>
    80013260:	86ba                	mv	a3,a4
    80013262:	863e                	mv	a2,a5
    80013264:	00004597          	auipc	a1,0x4
    80013268:	2f458593          	addi	a1,a1,756 # 80017558 <__func__.0+0x168>
    8001326c:	4541                	li	a0,16
    8001326e:	974ff0ef          	jal	ra,800123e2 <logf>

    text("[[ HART MAPPINGS ]]\n");
    80013272:	00004597          	auipc	a1,0x4
    80013276:	30658593          	addi	a1,a1,774 # 80017578 <__func__.0+0x188>
    8001327a:	4541                	li	a0,16
    8001327c:	966ff0ef          	jal	ra,800123e2 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    80013280:	fe042623          	sw	zero,-20(s0)
    80013284:	a8bd                	j	80013302 <main+0x178>
        if (i == hart) {
    80013286:	fec42703          	lw	a4,-20(s0)
    8001328a:	fdc42783          	lw	a5,-36(s0)
    8001328e:	2701                	sext.w	a4,a4
    80013290:	2781                	sext.w	a5,a5
    80013292:	02f71b63          	bne	a4,a5,800132c8 <main+0x13e>
            textf("  [HART#%d]: %s (this HART).\n", i,
    80013296:	fec42783          	lw	a5,-20(s0)
    8001329a:	853e                	mv	a0,a5
    8001329c:	3d0000ef          	jal	ra,8001366c <sbi_hart_get_status>
    800132a0:	87aa                	mv	a5,a0
    800132a2:	00006717          	auipc	a4,0x6
    800132a6:	d6670713          	addi	a4,a4,-666 # 80019008 <hart_status_values>
    800132aa:	078e                	slli	a5,a5,0x3
    800132ac:	97ba                	add	a5,a5,a4
    800132ae:	6398                	ld	a4,0(a5)
    800132b0:	fec42783          	lw	a5,-20(s0)
    800132b4:	86ba                	mv	a3,a4
    800132b6:	863e                	mv	a2,a5
    800132b8:	00004597          	auipc	a1,0x4
    800132bc:	2d858593          	addi	a1,a1,728 # 80017590 <__func__.0+0x1a0>
    800132c0:	4541                	li	a0,16
    800132c2:	920ff0ef          	jal	ra,800123e2 <logf>
    800132c6:	a80d                	j	800132f8 <main+0x16e>
                 hart_status_values[sbi_hart_get_status(i)]);
        }
        else {
            textf("  [HART#%d]: %s.\n", i, hart_status_values[sbi_hart_get_status(i)]);
    800132c8:	fec42783          	lw	a5,-20(s0)
    800132cc:	853e                	mv	a0,a5
    800132ce:	39e000ef          	jal	ra,8001366c <sbi_hart_get_status>
    800132d2:	87aa                	mv	a5,a0
    800132d4:	00006717          	auipc	a4,0x6
    800132d8:	d3470713          	addi	a4,a4,-716 # 80019008 <hart_status_values>
    800132dc:	078e                	slli	a5,a5,0x3
    800132de:	97ba                	add	a5,a5,a4
    800132e0:	6398                	ld	a4,0(a5)
    800132e2:	fec42783          	lw	a5,-20(s0)
    800132e6:	86ba                	mv	a3,a4
    800132e8:	863e                	mv	a2,a5
    800132ea:	00004597          	auipc	a1,0x4
    800132ee:	2c658593          	addi	a1,a1,710 # 800175b0 <__func__.0+0x1c0>
    800132f2:	4541                	li	a0,16
    800132f4:	8eeff0ef          	jal	ra,800123e2 <logf>
    for (unsigned int i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800132f8:	fec42783          	lw	a5,-20(s0)
    800132fc:	2785                	addiw	a5,a5,1
    800132fe:	fef42623          	sw	a5,-20(s0)
    80013302:	fec42783          	lw	a5,-20(s0)
    80013306:	0007871b          	sext.w	a4,a5
    8001330a:	478d                	li	a5,3
    8001330c:	f6e7fde3          	bgeu	a5,a4,80013286 <main+0xfc>
        }
    }

    // Initialize all submodules here, including PCI, VirtIO, Heap, etc.
    // Many will require the MMU, so write those functions first.
    init_systems();
    80013310:	db5ff0ef          	jal	ra,800130c4 <init_systems>

    // Now that all submodules are initialized, you need to schedule the init process
    // and the idle processes for each HART.
    text("Congratulations! You made it to the OS! Going back to sleep.\n");
    80013314:	00004597          	auipc	a1,0x4
    80013318:	2b458593          	addi	a1,a1,692 # 800175c8 <__func__.0+0x1d8>
    8001331c:	4541                	li	a0,16
    8001331e:	8c4ff0ef          	jal	ra,800123e2 <logf>
    text("If you don't remember, type CTRL-a, followed by x to exit. Make sure your CAPS LOCK is "
    80013322:	00004597          	auipc	a1,0x4
    80013326:	2e658593          	addi	a1,a1,742 # 80017608 <__func__.0+0x218>
    8001332a:	4541                	li	a0,16
    8001332c:	8b6ff0ef          	jal	ra,800123e2 <logf>
         "off.\n");
    // Below is just a little shell that demonstrates the sbi_getchar and
    // how the console works.
    // This is defined above main()
#ifdef RUN_INTERNAL_CONSOLE
    console();
    80013330:	004000ef          	jal	ra,80013334 <console>

0000000080013334 <console>:
#endif
}

#ifdef RUN_INTERNAL_CONSOLE
ATTR_NORET static void console(void)
{
    80013334:	7179                	addi	sp,sp,-48
    80013336:	f406                	sd	ra,40(sp)
    80013338:	f022                	sd	s0,32(sp)
    8001333a:	1800                	addi	s0,sp,48
    const int BUFFER_SIZE = 56;
    8001333c:	03800313          	li	t1,56
    80013340:	fe642423          	sw	t1,-24(s0)
    int at                = 0;
    80013344:	fe042623          	sw	zero,-20(s0)
    char input[BUFFER_SIZE];
    80013348:	fe842303          	lw	t1,-24(s0)
    8001334c:	137d                	addi	t1,t1,-1
    8001334e:	fe643023          	sd	t1,-32(s0)
    80013352:	fe842303          	lw	t1,-24(s0)
    80013356:	881a                	mv	a6,t1
    80013358:	4881                	li	a7,0
    8001335a:	03d85313          	srli	t1,a6,0x3d
    8001335e:	00389693          	slli	a3,a7,0x3
    80013362:	00d366b3          	or	a3,t1,a3
    80013366:	00381613          	slli	a2,a6,0x3
    8001336a:	fe842683          	lw	a3,-24(s0)
    8001336e:	8536                	mv	a0,a3
    80013370:	4581                	li	a1,0
    80013372:	03d55693          	srli	a3,a0,0x3d
    80013376:	00359793          	slli	a5,a1,0x3
    8001337a:	8fd5                	or	a5,a5,a3
    8001337c:	00351713          	slli	a4,a0,0x3
    80013380:	fe842783          	lw	a5,-24(s0)
    80013384:	07bd                	addi	a5,a5,15
    80013386:	8391                	srli	a5,a5,0x4
    80013388:	0792                	slli	a5,a5,0x4
    8001338a:	40f10133          	sub	sp,sp,a5
    8001338e:	878a                	mv	a5,sp
    80013390:	00078793          	mv	a5,a5
    80013394:	fcf43c23          	sd	a5,-40(s0)
    logf(LOG_TEXT, "> ");
    80013398:	00004597          	auipc	a1,0x4
    8001339c:	2d058593          	addi	a1,a1,720 # 80017668 <__func__.0+0x278>
    800133a0:	4541                	li	a0,16
    800133a2:	840ff0ef          	jal	ra,800123e2 <logf>
    do {
        char c;
        // Recall that sbi_getchar() will return -1, 0xff, 255
        // if the receiver is empty.
        if ((c = sbi_getchar()) != 0xff) {
    800133a6:	2a6000ef          	jal	ra,8001364c <sbi_getchar>
    800133aa:	87aa                	mv	a5,a0
    800133ac:	fcf40ba3          	sb	a5,-41(s0)
    800133b0:	fd744783          	lbu	a5,-41(s0)
    800133b4:	0ff7f713          	andi	a4,a5,255
    800133b8:	0ff00793          	li	a5,255
    800133bc:	24f70163          	beq	a4,a5,800135fe <console+0x2ca>
            if (c == '\r' || c == '\n') {
    800133c0:	fd744783          	lbu	a5,-41(s0)
    800133c4:	0ff7f713          	andi	a4,a5,255
    800133c8:	47b5                	li	a5,13
    800133ca:	00f70963          	beq	a4,a5,800133dc <console+0xa8>
    800133ce:	fd744783          	lbu	a5,-41(s0)
    800133d2:	0ff7f713          	andi	a4,a5,255
    800133d6:	47a9                	li	a5,10
    800133d8:	0ef71b63          	bne	a4,a5,800134ce <console+0x19a>
                if (at > 0) {
    800133dc:	fec42783          	lw	a5,-20(s0)
    800133e0:	2781                	sext.w	a5,a5
    800133e2:	0cf05e63          	blez	a5,800134be <console+0x18a>
                    input[at] = '\0';
    800133e6:	fd843703          	ld	a4,-40(s0)
    800133ea:	fec42783          	lw	a5,-20(s0)
    800133ee:	97ba                	add	a5,a5,a4
    800133f0:	00078023          	sb	zero,0(a5)
                    if (!strcmp(input, "quit")) {
    800133f4:	00004597          	auipc	a1,0x4
    800133f8:	27c58593          	addi	a1,a1,636 # 80017670 <__func__.0+0x280>
    800133fc:	fd843503          	ld	a0,-40(s0)
    80013400:	53d000ef          	jal	ra,8001413c <strcmp>
    80013404:	87aa                	mv	a5,a0
    80013406:	eb99                	bnez	a5,8001341c <console+0xe8>
                        text("\nShutting down...\n\n");
    80013408:	00004597          	auipc	a1,0x4
    8001340c:	27058593          	addi	a1,a1,624 # 80017678 <__func__.0+0x288>
    80013410:	4541                	li	a0,16
    80013412:	fd1fe0ef          	jal	ra,800123e2 <logf>
                        sbi_poweroff();
    80013416:	2e6000ef          	jal	ra,800136fc <sbi_poweroff>
    8001341a:	a045                	j	800134ba <console+0x186>
                    }
                    else if (!strcmp(input, "fatal")) {
    8001341c:	00004597          	auipc	a1,0x4
    80013420:	27458593          	addi	a1,a1,628 # 80017690 <__func__.0+0x2a0>
    80013424:	fd843503          	ld	a0,-40(s0)
    80013428:	515000ef          	jal	ra,8001413c <strcmp>
    8001342c:	87aa                	mv	a5,a0
    8001342e:	eba9                	bnez	a5,80013480 <console+0x14c>
                        text("\n");
    80013430:	00004597          	auipc	a1,0x4
    80013434:	26858593          	addi	a1,a1,616 # 80017698 <__func__.0+0x2a8>
    80013438:	4541                	li	a0,16
    8001343a:	fa9fe0ef          	jal	ra,800123e2 <logf>
                        panicf("Testing fatal error @ %lu.\nHanging HART...\n", sbi_rtc_get_time());
    8001343e:	362000ef          	jal	ra,800137a0 <sbi_rtc_get_time>
    80013442:	87aa                	mv	a5,a0
    80013444:	00005717          	auipc	a4,0x5
    80013448:	c0c70713          	addi	a4,a4,-1012 # 80018050 <__func__.0>
    8001344c:	09000693          	li	a3,144
    80013450:	00004617          	auipc	a2,0x4
    80013454:	25060613          	addi	a2,a2,592 # 800176a0 <__func__.0+0x2b0>
    80013458:	00004597          	auipc	a1,0x4
    8001345c:	25858593          	addi	a1,a1,600 # 800176b0 <__func__.0+0x2c0>
    80013460:	4521                	li	a0,8
    80013462:	f81fe0ef          	jal	ra,800123e2 <logf>
    80013466:	10001073          	csrw	sstatus,zero
    8001346a:	10500073          	wfi
    8001346e:	bff5                	j	8001346a <console+0x136>
                        error("If I get here, fatal didn't work :'(.\n");
    80013470:	00004597          	auipc	a1,0x4
    80013474:	2a058593          	addi	a1,a1,672 # 80017710 <__func__.0+0x320>
    80013478:	4505                	li	a0,1
    8001347a:	f69fe0ef          	jal	ra,800123e2 <logf>
    8001347e:	a835                	j	800134ba <console+0x186>
                    }
                    else if (!strcmp(input, "heap")) {
    80013480:	00004597          	auipc	a1,0x4
    80013484:	2d058593          	addi	a1,a1,720 # 80017750 <__func__.0+0x360>
    80013488:	fd843503          	ld	a0,-40(s0)
    8001348c:	4b1000ef          	jal	ra,8001413c <strcmp>
    80013490:	87aa                	mv	a5,a0
    80013492:	eb99                	bnez	a5,800134a8 <console+0x174>
                        text("\n");
    80013494:	00004597          	auipc	a1,0x4
    80013498:	20458593          	addi	a1,a1,516 # 80017698 <__func__.0+0x2a8>
    8001349c:	4541                	li	a0,16
    8001349e:	f45fe0ef          	jal	ra,800123e2 <logf>
                        void heap_print_stats(void);
                        heap_print_stats();
    800134a2:	af9ff0ef          	jal	ra,80012f9a <heap_print_stats>
    800134a6:	a811                	j	800134ba <console+0x186>
                    }
                    else {
                        textf("\nUnknown command '%s'\n", input);
    800134a8:	fd843603          	ld	a2,-40(s0)
    800134ac:	00004597          	auipc	a1,0x4
    800134b0:	2ac58593          	addi	a1,a1,684 # 80017758 <__func__.0+0x368>
    800134b4:	4541                	li	a0,16
    800134b6:	f2dfe0ef          	jal	ra,800123e2 <logf>
                    }
                    at = 0;
    800134ba:	fe042623          	sw	zero,-20(s0)
                }
                text("\n> ");
    800134be:	00004597          	auipc	a1,0x4
    800134c2:	2b258593          	addi	a1,a1,690 # 80017770 <__func__.0+0x380>
    800134c6:	4541                	li	a0,16
    800134c8:	f1bfe0ef          	jal	ra,800123e2 <logf>
    800134cc:	aa2d                	j	80013606 <console+0x2d2>
            }
            else if (c == 127) {
    800134ce:	fd744783          	lbu	a5,-41(s0)
    800134d2:	0ff7f713          	andi	a4,a5,255
    800134d6:	07f00793          	li	a5,127
    800134da:	02f71463          	bne	a4,a5,80013502 <console+0x1ce>
                // BACKSPACE
                if (at > 0) {
    800134de:	fec42783          	lw	a5,-20(s0)
    800134e2:	2781                	sext.w	a5,a5
    800134e4:	ecf051e3          	blez	a5,800133a6 <console+0x72>
                    logf(LOG_TEXT, "\b \b");
    800134e8:	00004597          	auipc	a1,0x4
    800134ec:	29058593          	addi	a1,a1,656 # 80017778 <__func__.0+0x388>
    800134f0:	4541                	li	a0,16
    800134f2:	ef1fe0ef          	jal	ra,800123e2 <logf>
                    at -= 1;
    800134f6:	fec42783          	lw	a5,-20(s0)
    800134fa:	37fd                	addiw	a5,a5,-1
    800134fc:	fef42623          	sw	a5,-20(s0)
    80013500:	b55d                	j	800133a6 <console+0x72>
                }
            }
            else if (c == 0x1B) {
    80013502:	fd744783          	lbu	a5,-41(s0)
    80013506:	0ff7f713          	andi	a4,a5,255
    8001350a:	47ed                	li	a5,27
    8001350c:	0af71663          	bne	a4,a5,800135b8 <console+0x284>
                // Escape sequence
                char esc1 = sbi_getchar();
    80013510:	13c000ef          	jal	ra,8001364c <sbi_getchar>
    80013514:	87aa                	mv	a5,a0
    80013516:	fcf40b23          	sb	a5,-42(s0)
                char esc2 = sbi_getchar();
    8001351a:	132000ef          	jal	ra,8001364c <sbi_getchar>
    8001351e:	87aa                	mv	a5,a0
    80013520:	fcf40aa3          	sb	a5,-43(s0)
                if (esc1 == 0x5B) {
    80013524:	fd644783          	lbu	a5,-42(s0)
    80013528:	0ff7f713          	andi	a4,a5,255
    8001352c:	05b00793          	li	a5,91
    80013530:	0cf71a63          	bne	a4,a5,80013604 <console+0x2d0>
                    switch (esc2) {
    80013534:	fd544783          	lbu	a5,-43(s0)
    80013538:	2781                	sext.w	a5,a5
    8001353a:	86be                	mv	a3,a5
    8001353c:	04400713          	li	a4,68
    80013540:	06e68463          	beq	a3,a4,800135a8 <console+0x274>
    80013544:	86be                	mv	a3,a5
    80013546:	04400713          	li	a4,68
    8001354a:	e4d74ee3          	blt	a4,a3,800133a6 <console+0x72>
    8001354e:	86be                	mv	a3,a5
    80013550:	04300713          	li	a4,67
    80013554:	04e68263          	beq	a3,a4,80013598 <console+0x264>
    80013558:	86be                	mv	a3,a5
    8001355a:	04300713          	li	a4,67
    8001355e:	e4d744e3          	blt	a4,a3,800133a6 <console+0x72>
    80013562:	86be                	mv	a3,a5
    80013564:	04100713          	li	a4,65
    80013568:	00e68863          	beq	a3,a4,80013578 <console+0x244>
    8001356c:	873e                	mv	a4,a5
    8001356e:	04200793          	li	a5,66
    80013572:	00f70b63          	beq	a4,a5,80013588 <console+0x254>
    80013576:	a841                	j	80013606 <console+0x2d2>
                        case 0x41:
                            text("UP\n");
    80013578:	00004597          	auipc	a1,0x4
    8001357c:	20858593          	addi	a1,a1,520 # 80017780 <__func__.0+0x390>
    80013580:	4541                	li	a0,16
    80013582:	e61fe0ef          	jal	ra,800123e2 <logf>
                            break;
    80013586:	a041                	j	80013606 <console+0x2d2>
                        case 0x42:
                            text("DOWN\n");
    80013588:	00004597          	auipc	a1,0x4
    8001358c:	20058593          	addi	a1,a1,512 # 80017788 <__func__.0+0x398>
    80013590:	4541                	li	a0,16
    80013592:	e51fe0ef          	jal	ra,800123e2 <logf>
                            break;
    80013596:	a885                	j	80013606 <console+0x2d2>
                        case 0x43:
                            text("RIGHT\n");
    80013598:	00004597          	auipc	a1,0x4
    8001359c:	1f858593          	addi	a1,a1,504 # 80017790 <__func__.0+0x3a0>
    800135a0:	4541                	li	a0,16
    800135a2:	e41fe0ef          	jal	ra,800123e2 <logf>
                            break;
    800135a6:	a085                	j	80013606 <console+0x2d2>
                        case 0x44:
                            text("LEFT\n");
    800135a8:	00004597          	auipc	a1,0x4
    800135ac:	1f058593          	addi	a1,a1,496 # 80017798 <__func__.0+0x3a8>
    800135b0:	4541                	li	a0,16
    800135b2:	e31fe0ef          	jal	ra,800123e2 <logf>
                            break;
    800135b6:	a881                	j	80013606 <console+0x2d2>
                    }
                }
            }
            else {
                if (at < (BUFFER_SIZE - 1)) {
    800135b8:	fe842783          	lw	a5,-24(s0)
    800135bc:	37fd                	addiw	a5,a5,-1
    800135be:	0007871b          	sext.w	a4,a5
    800135c2:	fec42783          	lw	a5,-20(s0)
    800135c6:	2781                	sext.w	a5,a5
    800135c8:	dce7dfe3          	bge	a5,a4,800133a6 <console+0x72>
                    input[at++] = c;
    800135cc:	fec42783          	lw	a5,-20(s0)
    800135d0:	0017871b          	addiw	a4,a5,1
    800135d4:	fee42623          	sw	a4,-20(s0)
    800135d8:	fd843703          	ld	a4,-40(s0)
    800135dc:	97ba                	add	a5,a5,a4
    800135de:	fd744703          	lbu	a4,-41(s0)
    800135e2:	00e78023          	sb	a4,0(a5)
                    logf(LOG_TEXT, "%c", c);
    800135e6:	fd744783          	lbu	a5,-41(s0)
    800135ea:	2781                	sext.w	a5,a5
    800135ec:	863e                	mv	a2,a5
    800135ee:	00004597          	auipc	a1,0x4
    800135f2:	1b258593          	addi	a1,a1,434 # 800177a0 <__func__.0+0x3b0>
    800135f6:	4541                	li	a0,16
    800135f8:	debfe0ef          	jal	ra,800123e2 <logf>
    800135fc:	b36d                	j	800133a6 <console+0x72>
            }
        }
        else {
            // We can WFI here since interrupts are enabled
            // for the UART.
            WFI();
    800135fe:	10500073          	wfi
    80013602:	b355                	j	800133a6 <console+0x72>
                }
    80013604:	0001                	nop
    do {
    80013606:	b345                	j	800133a6 <console+0x72>

0000000080013608 <pci_init>:
#include <pci.h>

void pci_init(void)
{
    80013608:	1141                	addi	sp,sp,-16
    8001360a:	e422                	sd	s0,8(sp)
    8001360c:	0800                	addi	s0,sp,16
    // Initialize and enumerate all PCI bridges and devices.

    // This should forward all virtio devices to the virtio drivers.
}
    8001360e:	0001                	nop
    80013610:	6422                	ld	s0,8(sp)
    80013612:	0141                	addi	sp,sp,16
    80013614:	8082                	ret

0000000080013616 <pci_dispatch_irq>:

void pci_dispatch_irq(int irq)
{
    80013616:	1101                	addi	sp,sp,-32
    80013618:	ec22                	sd	s0,24(sp)
    8001361a:	1000                	addi	s0,sp,32
    8001361c:	87aa                	mv	a5,a0
    8001361e:	fef42623          	sw	a5,-20(s0)
    (void)irq;

    // An IRQ came from the PLIC, but recall PCI devices
    // share IRQs. So, you need to check the ISR register
    // of potential virtio devices.
}
    80013622:	0001                	nop
    80013624:	6462                	ld	s0,24(sp)
    80013626:	6105                	addi	sp,sp,32
    80013628:	8082                	ret

000000008001362a <sbi_putchar>:
#include <compiler.h>
#include <config.h>
#include <sbi.h>

void sbi_putchar(char c)
{
    8001362a:	1101                	addi	sp,sp,-32
    8001362c:	ec22                	sd	s0,24(sp)
    8001362e:	1000                	addi	s0,sp,32
    80013630:	87aa                	mv	a5,a0
    80013632:	fef407a3          	sb	a5,-17(s0)
    __asm__ volatile("mv a7, %0\nmv a0, %1\necall" ::"r"(SBI_SVCALL_PUTCHAR), "r"(c) : "a7", "a0");
    80013636:	47a5                	li	a5,9
    80013638:	fef44703          	lbu	a4,-17(s0)
    8001363c:	88be                	mv	a7,a5
    8001363e:	853a                	mv	a0,a4
    80013640:	00000073          	ecall
}
    80013644:	0001                	nop
    80013646:	6462                	ld	s0,24(sp)
    80013648:	6105                	addi	sp,sp,32
    8001364a:	8082                	ret

000000008001364c <sbi_getchar>:

char sbi_getchar(void)
{
    8001364c:	1101                	addi	sp,sp,-32
    8001364e:	ec22                	sd	s0,24(sp)
    80013650:	1000                	addi	s0,sp,32
    char c;
    __asm__ volatile("mv a7, %1\necall\nmv %0, a0\n" : "=r"(c) : "r"(SBI_SVCALL_GETCHAR) : "a7", "a0");
    80013652:	47a9                	li	a5,10
    80013654:	88be                	mv	a7,a5
    80013656:	00000073          	ecall
    8001365a:	87aa                	mv	a5,a0
    8001365c:	fef407a3          	sb	a5,-17(s0)
    return c;
    80013660:	fef44783          	lbu	a5,-17(s0)
}
    80013664:	853e                	mv	a0,a5
    80013666:	6462                	ld	s0,24(sp)
    80013668:	6105                	addi	sp,sp,32
    8001366a:	8082                	ret

000000008001366c <sbi_hart_get_status>:

int sbi_hart_get_status(unsigned int hart)
{
    8001366c:	7179                	addi	sp,sp,-48
    8001366e:	f422                	sd	s0,40(sp)
    80013670:	1800                	addi	s0,sp,48
    80013672:	87aa                	mv	a5,a0
    80013674:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    __asm__ volatile("mv a7, %1\nmv a0, %2\necall\nmv %0, a0\n"
    80013678:	4785                	li	a5,1
    8001367a:	fdc42703          	lw	a4,-36(s0)
    8001367e:	88be                	mv	a7,a5
    80013680:	853a                	mv	a0,a4
    80013682:	00000073          	ecall
    80013686:	87aa                	mv	a5,a0
    80013688:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_STATUS), "r"(hart)
                 : "a0", "a7");
    return stat;
    8001368c:	fec42783          	lw	a5,-20(s0)
}
    80013690:	853e                	mv	a0,a5
    80013692:	7422                	ld	s0,40(sp)
    80013694:	6145                	addi	sp,sp,48
    80013696:	8082                	ret

0000000080013698 <sbi_hart_start>:

int sbi_hart_start(unsigned int hart, unsigned long target, unsigned long scratch, unsigned long satp)
{
    80013698:	7139                	addi	sp,sp,-64
    8001369a:	fc22                	sd	s0,56(sp)
    8001369c:	0080                	addi	s0,sp,64
    8001369e:	87aa                	mv	a5,a0
    800136a0:	fcb43823          	sd	a1,-48(s0)
    800136a4:	fcc43423          	sd	a2,-56(s0)
    800136a8:	fcd43023          	sd	a3,-64(s0)
    800136ac:	fcf42e23          	sw	a5,-36(s0)
    int stat;
    __asm__ volatile("mv a7, %1\nmv a0, %2\nmv a1, %3\nmv a2, %4\nmv a3, %5\necall\nmv %0, a0\n"
    800136b0:	4789                	li	a5,2
    800136b2:	fdc42703          	lw	a4,-36(s0)
    800136b6:	fd043683          	ld	a3,-48(s0)
    800136ba:	fc843803          	ld	a6,-56(s0)
    800136be:	fc043303          	ld	t1,-64(s0)
    800136c2:	88be                	mv	a7,a5
    800136c4:	853a                	mv	a0,a4
    800136c6:	85b6                	mv	a1,a3
    800136c8:	8642                	mv	a2,a6
    800136ca:	869a                	mv	a3,t1
    800136cc:	00000073          	ecall
    800136d0:	87aa                	mv	a5,a0
    800136d2:	fef42623          	sw	a5,-20(s0)
                 : "=r"(stat)
                 : "r"(SBI_SVCALL_HART_START), "r"(hart), "r"(target), "r"(scratch), "r"(satp)
                 : "a0", "a1", "a2", "a7");
    return stat;
    800136d6:	fec42783          	lw	a5,-20(s0)
}
    800136da:	853e                	mv	a0,a5
    800136dc:	7462                	ld	s0,56(sp)
    800136de:	6121                	addi	sp,sp,64
    800136e0:	8082                	ret

00000000800136e2 <sbi_hart_stop>:

void sbi_hart_stop(void)
{
    800136e2:	1141                	addi	sp,sp,-16
    800136e4:	e422                	sd	s0,8(sp)
    800136e6:	0800                	addi	s0,sp,16
    __asm__ volatile("mv a7, %0\necall\nwfi" : : "r"(SBI_SVCALL_HART_STOP) : "a0", "a7");
    800136e8:	478d                	li	a5,3
    800136ea:	88be                	mv	a7,a5
    800136ec:	00000073          	ecall
    800136f0:	10500073          	wfi
}
    800136f4:	0001                	nop
    800136f6:	6422                	ld	s0,8(sp)
    800136f8:	0141                	addi	sp,sp,16
    800136fa:	8082                	ret

00000000800136fc <sbi_poweroff>:

void sbi_poweroff(void)
{
    800136fc:	1141                	addi	sp,sp,-16
    800136fe:	e422                	sd	s0,8(sp)
    80013700:	0800                	addi	s0,sp,16
    __asm__ volatile("mv a7, %0\necall" : : "r"(SBI_SVCALL_POWEROFF) : "a0", "a7");
    80013702:	47b1                	li	a5,12
    80013704:	88be                	mv	a7,a5
    80013706:	00000073          	ecall
}
    8001370a:	0001                	nop
    8001370c:	6422                	ld	s0,8(sp)
    8001370e:	0141                	addi	sp,sp,16
    80013710:	8082                	ret

0000000080013712 <sbi_get_time>:

unsigned long sbi_get_time(void)
{
    80013712:	1101                	addi	sp,sp,-32
    80013714:	ec22                	sd	s0,24(sp)
    80013716:	1000                	addi	s0,sp,32
    unsigned long ret;
    __asm__ volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_GET_TIME) : "a0", "a7");
    80013718:	4791                	li	a5,4
    8001371a:	88be                	mv	a7,a5
    8001371c:	00000073          	ecall
    80013720:	87aa                	mv	a5,a0
    80013722:	fef43423          	sd	a5,-24(s0)
    return ret;
    80013726:	fe843783          	ld	a5,-24(s0)
}
    8001372a:	853e                	mv	a0,a5
    8001372c:	6462                	ld	s0,24(sp)
    8001372e:	6105                	addi	sp,sp,32
    80013730:	8082                	ret

0000000080013732 <sbi_set_timer>:

void sbi_set_timer(unsigned int hart, unsigned long val)
{
    80013732:	1101                	addi	sp,sp,-32
    80013734:	ec22                	sd	s0,24(sp)
    80013736:	1000                	addi	s0,sp,32
    80013738:	87aa                	mv	a5,a0
    8001373a:	feb43023          	sd	a1,-32(s0)
    8001373e:	fef42623          	sw	a5,-20(s0)
    __asm__ volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_SET_TIMECMP), "r"(hart),
    80013742:	4795                	li	a5,5
    80013744:	fec42703          	lw	a4,-20(s0)
    80013748:	fe043683          	ld	a3,-32(s0)
    8001374c:	88be                	mv	a7,a5
    8001374e:	853a                	mv	a0,a4
    80013750:	85b6                	mv	a1,a3
    80013752:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    80013756:	0001                	nop
    80013758:	6462                	ld	s0,24(sp)
    8001375a:	6105                	addi	sp,sp,32
    8001375c:	8082                	ret

000000008001375e <sbi_add_timer>:

void sbi_add_timer(unsigned int hart, unsigned long val)
{
    8001375e:	1101                	addi	sp,sp,-32
    80013760:	ec22                	sd	s0,24(sp)
    80013762:	1000                	addi	s0,sp,32
    80013764:	87aa                	mv	a5,a0
    80013766:	feb43023          	sd	a1,-32(s0)
    8001376a:	fef42623          	sw	a5,-20(s0)
    __asm__ volatile("mv a7, %0\nmv a0, %1\nmv a1, %2\necall" ::"r"(SBI_SVCALL_ADD_TIMECMP), "r"(hart),
    8001376e:	4799                	li	a5,6
    80013770:	fec42703          	lw	a4,-20(s0)
    80013774:	fe043683          	ld	a3,-32(s0)
    80013778:	88be                	mv	a7,a5
    8001377a:	853a                	mv	a0,a4
    8001377c:	85b6                	mv	a1,a3
    8001377e:	00000073          	ecall
                 "r"(val)
                 : "a0", "a1", "a7");
}
    80013782:	0001                	nop
    80013784:	6462                	ld	s0,24(sp)
    80013786:	6105                	addi	sp,sp,32
    80013788:	8082                	ret

000000008001378a <sbi_ack_timer>:

void sbi_ack_timer(void)
{
    8001378a:	1141                	addi	sp,sp,-16
    8001378c:	e422                	sd	s0,8(sp)
    8001378e:	0800                	addi	s0,sp,16
    __asm__ volatile("mv a7, %0\necall" ::"r"(SBI_SVCALL_ACK_TIMER) : "a7");
    80013790:	479d                	li	a5,7
    80013792:	88be                	mv	a7,a5
    80013794:	00000073          	ecall
}
    80013798:	0001                	nop
    8001379a:	6422                	ld	s0,8(sp)
    8001379c:	0141                	addi	sp,sp,16
    8001379e:	8082                	ret

00000000800137a0 <sbi_rtc_get_time>:

unsigned long sbi_rtc_get_time(void)
{
    800137a0:	1101                	addi	sp,sp,-32
    800137a2:	ec22                	sd	s0,24(sp)
    800137a4:	1000                	addi	s0,sp,32
    unsigned long ret;
    __asm__ volatile("mv a7, %1\necall\nmv %0, a0"
    800137a6:	47a1                	li	a5,8
    800137a8:	88be                	mv	a7,a5
    800137aa:	00000073          	ecall
    800137ae:	87aa                	mv	a5,a0
    800137b0:	fef43423          	sd	a5,-24(s0)
                 : "=r"(ret)
                 : "r"(SBI_SVCALL_RTC_GET_TIME)
                 : "a0", "a7");
    return ret;
    800137b4:	fe843783          	ld	a5,-24(s0)
}
    800137b8:	853e                	mv	a0,a5
    800137ba:	6462                	ld	s0,24(sp)
    800137bc:	6105                	addi	sp,sp,32
    800137be:	8082                	ret

00000000800137c0 <sbi_whoami>:

int sbi_whoami(void)
{
    800137c0:	1101                	addi	sp,sp,-32
    800137c2:	ec22                	sd	s0,24(sp)
    800137c4:	1000                	addi	s0,sp,32
    int ret;
    __asm__ volatile("mv a7, %1\necall\nmv %0, a0" : "=r"(ret) : "r"(SBI_SVCALL_WHOAMI) : "a0", "a7");
    800137c6:	47ad                	li	a5,11
    800137c8:	88be                	mv	a7,a5
    800137ca:	00000073          	ecall
    800137ce:	87aa                	mv	a5,a0
    800137d0:	fef42623          	sw	a5,-20(s0)
    return ret;
    800137d4:	fec42783          	lw	a5,-20(s0)
}
    800137d8:	853e                	mv	a0,a5
    800137da:	6462                	ld	s0,24(sp)
    800137dc:	6105                	addi	sp,sp,32
    800137de:	8082                	ret

00000000800137e0 <sbi_num_harts>:

int sbi_num_harts(void)
{
    800137e0:	1101                	addi	sp,sp,-32
    800137e2:	ec06                	sd	ra,24(sp)
    800137e4:	e822                	sd	s0,16(sp)
    800137e6:	1000                	addi	s0,sp,32
    unsigned int i;
    int num_harts = 0;
    800137e8:	fe042423          	sw	zero,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    800137ec:	fe042623          	sw	zero,-20(s0)
    800137f0:	a015                	j	80013814 <sbi_num_harts+0x34>
        if (sbi_hart_get_status(i) != 0) {
    800137f2:	fec42783          	lw	a5,-20(s0)
    800137f6:	853e                	mv	a0,a5
    800137f8:	e75ff0ef          	jal	ra,8001366c <sbi_hart_get_status>
    800137fc:	87aa                	mv	a5,a0
    800137fe:	c791                	beqz	a5,8001380a <sbi_num_harts+0x2a>
            num_harts += 1;
    80013800:	fe842783          	lw	a5,-24(s0)
    80013804:	2785                	addiw	a5,a5,1
    80013806:	fef42423          	sw	a5,-24(s0)
    for (i = 0; i < MAX_ALLOWABLE_HARTS; i++) {
    8001380a:	fec42783          	lw	a5,-20(s0)
    8001380e:	2785                	addiw	a5,a5,1
    80013810:	fef42623          	sw	a5,-20(s0)
    80013814:	fec42783          	lw	a5,-20(s0)
    80013818:	0007871b          	sext.w	a4,a5
    8001381c:	478d                	li	a5,3
    8001381e:	fce7fae3          	bgeu	a5,a4,800137f2 <sbi_num_harts+0x12>
        }
    }
    return num_harts;
    80013822:	fe842783          	lw	a5,-24(s0)
}
    80013826:	853e                	mv	a0,a5
    80013828:	60e2                	ld	ra,24(sp)
    8001382a:	6442                	ld	s0,16(sp)
    8001382c:	6105                	addi	sp,sp,32
    8001382e:	8082                	ret

0000000080013830 <plic_set_priority>:
#define PLIC_PCI_INTB 33
#define PLIC_PCI_INTC 34
#define PLIC_PCI_INTD 35

void plic_set_priority(int interrupt_id, char priority)
{
    80013830:	7179                	addi	sp,sp,-48
    80013832:	f422                	sd	s0,40(sp)
    80013834:	1800                	addi	s0,sp,48
    80013836:	87aa                	mv	a5,a0
    80013838:	872e                	mv	a4,a1
    8001383a:	fcf42e23          	sw	a5,-36(s0)
    8001383e:	87ba                	mv	a5,a4
    80013840:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_PRIORITY(interrupt_id);
    80013844:	fdc42783          	lw	a5,-36(s0)
    80013848:	0027979b          	slliw	a5,a5,0x2
    8001384c:	2781                	sext.w	a5,a5
    8001384e:	873e                	mv	a4,a5
    80013850:	0c0007b7          	lui	a5,0xc000
    80013854:	97ba                	add	a5,a5,a4
    80013856:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    8001385a:	fdb44783          	lbu	a5,-37(s0)
    8001385e:	2781                	sext.w	a5,a5
    80013860:	8b9d                	andi	a5,a5,7
    80013862:	0007871b          	sext.w	a4,a5
    80013866:	fe843783          	ld	a5,-24(s0)
    8001386a:	c398                	sw	a4,0(a5)
}
    8001386c:	0001                	nop
    8001386e:	7422                	ld	s0,40(sp)
    80013870:	6145                	addi	sp,sp,48
    80013872:	8082                	ret

0000000080013874 <plic_set_threshold>:
void plic_set_threshold(int hart, char priority)
{
    80013874:	7179                	addi	sp,sp,-48
    80013876:	f422                	sd	s0,40(sp)
    80013878:	1800                	addi	s0,sp,48
    8001387a:	87aa                	mv	a5,a0
    8001387c:	872e                	mv	a4,a1
    8001387e:	fcf42e23          	sw	a5,-36(s0)
    80013882:	87ba                	mv	a5,a4
    80013884:	fcf40da3          	sb	a5,-37(s0)
    uint32_t *base = (uint32_t *)PLIC_THRESHOLD(hart, PLIC_MODE_SUPERVISOR);
    80013888:	fdc42783          	lw	a5,-36(s0)
    8001388c:	0017979b          	slliw	a5,a5,0x1
    80013890:	2781                	sext.w	a5,a5
    80013892:	2785                	addiw	a5,a5,1
    80013894:	2781                	sext.w	a5,a5
    80013896:	00c7979b          	slliw	a5,a5,0xc
    8001389a:	2781                	sext.w	a5,a5
    8001389c:	873e                	mv	a4,a5
    8001389e:	0c2007b7          	lui	a5,0xc200
    800138a2:	97ba                	add	a5,a5,a4
    800138a4:	fef43423          	sd	a5,-24(s0)
    *base          = priority & 0x7;
    800138a8:	fdb44783          	lbu	a5,-37(s0)
    800138ac:	2781                	sext.w	a5,a5
    800138ae:	8b9d                	andi	a5,a5,7
    800138b0:	0007871b          	sext.w	a4,a5
    800138b4:	fe843783          	ld	a5,-24(s0)
    800138b8:	c398                	sw	a4,0(a5)
}
    800138ba:	0001                	nop
    800138bc:	7422                	ld	s0,40(sp)
    800138be:	6145                	addi	sp,sp,48
    800138c0:	8082                	ret

00000000800138c2 <plic_enable>:
void plic_enable(int hart, int interrupt_id)
{
    800138c2:	7179                	addi	sp,sp,-48
    800138c4:	f422                	sd	s0,40(sp)
    800138c6:	1800                	addi	s0,sp,48
    800138c8:	87aa                	mv	a5,a0
    800138ca:	872e                	mv	a4,a1
    800138cc:	fcf42e23          	sw	a5,-36(s0)
    800138d0:	87ba                	mv	a5,a4
    800138d2:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    800138d6:	fdc42783          	lw	a5,-36(s0)
    800138da:	0017979b          	slliw	a5,a5,0x1
    800138de:	2781                	sext.w	a5,a5
    800138e0:	2785                	addiw	a5,a5,1
    800138e2:	2781                	sext.w	a5,a5
    800138e4:	0077979b          	slliw	a5,a5,0x7
    800138e8:	2781                	sext.w	a5,a5
    800138ea:	873e                	mv	a4,a5
    800138ec:	0c0027b7          	lui	a5,0xc002
    800138f0:	97ba                	add	a5,a5,a4
    800138f2:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] |= 1UL << (interrupt_id % 32);
    800138f6:	fd842783          	lw	a5,-40(s0)
    800138fa:	41f7d71b          	sraiw	a4,a5,0x1f
    800138fe:	01b7571b          	srliw	a4,a4,0x1b
    80013902:	9fb9                	addw	a5,a5,a4
    80013904:	4057d79b          	sraiw	a5,a5,0x5
    80013908:	0007869b          	sext.w	a3,a5
    8001390c:	87b6                	mv	a5,a3
    8001390e:	078a                	slli	a5,a5,0x2
    80013910:	fe843703          	ld	a4,-24(s0)
    80013914:	97ba                	add	a5,a5,a4
    80013916:	438c                	lw	a1,0(a5)
    80013918:	fd842703          	lw	a4,-40(s0)
    8001391c:	41f7579b          	sraiw	a5,a4,0x1f
    80013920:	01b7d79b          	srliw	a5,a5,0x1b
    80013924:	9f3d                	addw	a4,a4,a5
    80013926:	8b7d                	andi	a4,a4,31
    80013928:	40f707bb          	subw	a5,a4,a5
    8001392c:	2781                	sext.w	a5,a5
    8001392e:	873e                	mv	a4,a5
    80013930:	4785                	li	a5,1
    80013932:	00e797b3          	sll	a5,a5,a4
    80013936:	0007861b          	sext.w	a2,a5
    8001393a:	87b6                	mv	a5,a3
    8001393c:	078a                	slli	a5,a5,0x2
    8001393e:	fe843703          	ld	a4,-24(s0)
    80013942:	97ba                	add	a5,a5,a4
    80013944:	86ae                	mv	a3,a1
    80013946:	8732                	mv	a4,a2
    80013948:	8f55                	or	a4,a4,a3
    8001394a:	2701                	sext.w	a4,a4
    8001394c:	c398                	sw	a4,0(a5)
}
    8001394e:	0001                	nop
    80013950:	7422                	ld	s0,40(sp)
    80013952:	6145                	addi	sp,sp,48
    80013954:	8082                	ret

0000000080013956 <plic_disable>:
void plic_disable(int hart, int interrupt_id)
{
    80013956:	7179                	addi	sp,sp,-48
    80013958:	f422                	sd	s0,40(sp)
    8001395a:	1800                	addi	s0,sp,48
    8001395c:	87aa                	mv	a5,a0
    8001395e:	872e                	mv	a4,a1
    80013960:	fcf42e23          	sw	a5,-36(s0)
    80013964:	87ba                	mv	a5,a4
    80013966:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_ENABLE(hart, PLIC_MODE_SUPERVISOR);
    8001396a:	fdc42783          	lw	a5,-36(s0)
    8001396e:	0017979b          	slliw	a5,a5,0x1
    80013972:	2781                	sext.w	a5,a5
    80013974:	2785                	addiw	a5,a5,1
    80013976:	2781                	sext.w	a5,a5
    80013978:	0077979b          	slliw	a5,a5,0x7
    8001397c:	2781                	sext.w	a5,a5
    8001397e:	873e                	mv	a4,a5
    80013980:	0c0027b7          	lui	a5,0xc002
    80013984:	97ba                	add	a5,a5,a4
    80013986:	fef43423          	sd	a5,-24(s0)
    base[interrupt_id / 32] &= ~(1UL << (interrupt_id % 32));
    8001398a:	fd842783          	lw	a5,-40(s0)
    8001398e:	41f7d71b          	sraiw	a4,a5,0x1f
    80013992:	01b7571b          	srliw	a4,a4,0x1b
    80013996:	9fb9                	addw	a5,a5,a4
    80013998:	4057d79b          	sraiw	a5,a5,0x5
    8001399c:	0007869b          	sext.w	a3,a5
    800139a0:	87b6                	mv	a5,a3
    800139a2:	078a                	slli	a5,a5,0x2
    800139a4:	fe843703          	ld	a4,-24(s0)
    800139a8:	97ba                	add	a5,a5,a4
    800139aa:	438c                	lw	a1,0(a5)
    800139ac:	fd842703          	lw	a4,-40(s0)
    800139b0:	41f7579b          	sraiw	a5,a4,0x1f
    800139b4:	01b7d79b          	srliw	a5,a5,0x1b
    800139b8:	9f3d                	addw	a4,a4,a5
    800139ba:	8b7d                	andi	a4,a4,31
    800139bc:	40f707bb          	subw	a5,a4,a5
    800139c0:	2781                	sext.w	a5,a5
    800139c2:	873e                	mv	a4,a5
    800139c4:	4785                	li	a5,1
    800139c6:	00e797b3          	sll	a5,a5,a4
    800139ca:	2781                	sext.w	a5,a5
    800139cc:	fff7c793          	not	a5,a5
    800139d0:	0007861b          	sext.w	a2,a5
    800139d4:	87b6                	mv	a5,a3
    800139d6:	078a                	slli	a5,a5,0x2
    800139d8:	fe843703          	ld	a4,-24(s0)
    800139dc:	97ba                	add	a5,a5,a4
    800139de:	86ae                	mv	a3,a1
    800139e0:	8732                	mv	a4,a2
    800139e2:	8f75                	and	a4,a4,a3
    800139e4:	2701                	sext.w	a4,a4
    800139e6:	c398                	sw	a4,0(a5)
}
    800139e8:	0001                	nop
    800139ea:	7422                	ld	s0,40(sp)
    800139ec:	6145                	addi	sp,sp,48
    800139ee:	8082                	ret

00000000800139f0 <plic_claim>:
uint32_t plic_claim(int hart)
{
    800139f0:	7179                	addi	sp,sp,-48
    800139f2:	f422                	sd	s0,40(sp)
    800139f4:	1800                	addi	s0,sp,48
    800139f6:	87aa                	mv	a5,a0
    800139f8:	fcf42e23          	sw	a5,-36(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    800139fc:	fdc42783          	lw	a5,-36(s0)
    80013a00:	0017979b          	slliw	a5,a5,0x1
    80013a04:	2781                	sext.w	a5,a5
    80013a06:	2785                	addiw	a5,a5,1
    80013a08:	2781                	sext.w	a5,a5
    80013a0a:	00c7979b          	slliw	a5,a5,0xc
    80013a0e:	2781                	sext.w	a5,a5
    80013a10:	873e                	mv	a4,a5
    80013a12:	0c2007b7          	lui	a5,0xc200
    80013a16:	0791                	addi	a5,a5,4
    80013a18:	97ba                	add	a5,a5,a4
    80013a1a:	fef43423          	sd	a5,-24(s0)
    return *base;
    80013a1e:	fe843783          	ld	a5,-24(s0)
    80013a22:	439c                	lw	a5,0(a5)
}
    80013a24:	853e                	mv	a0,a5
    80013a26:	7422                	ld	s0,40(sp)
    80013a28:	6145                	addi	sp,sp,48
    80013a2a:	8082                	ret

0000000080013a2c <plic_complete>:
void plic_complete(int hart, int id)
{
    80013a2c:	7179                	addi	sp,sp,-48
    80013a2e:	f422                	sd	s0,40(sp)
    80013a30:	1800                	addi	s0,sp,48
    80013a32:	87aa                	mv	a5,a0
    80013a34:	872e                	mv	a4,a1
    80013a36:	fcf42e23          	sw	a5,-36(s0)
    80013a3a:	87ba                	mv	a5,a4
    80013a3c:	fcf42c23          	sw	a5,-40(s0)
    uint32_t *base = (uint32_t *)PLIC_CLAIM(hart, PLIC_MODE_SUPERVISOR);
    80013a40:	fdc42783          	lw	a5,-36(s0)
    80013a44:	0017979b          	slliw	a5,a5,0x1
    80013a48:	2781                	sext.w	a5,a5
    80013a4a:	2785                	addiw	a5,a5,1
    80013a4c:	2781                	sext.w	a5,a5
    80013a4e:	00c7979b          	slliw	a5,a5,0xc
    80013a52:	2781                	sext.w	a5,a5
    80013a54:	873e                	mv	a4,a5
    80013a56:	0c2007b7          	lui	a5,0xc200
    80013a5a:	0791                	addi	a5,a5,4
    80013a5c:	97ba                	add	a5,a5,a4
    80013a5e:	fef43423          	sd	a5,-24(s0)
    *base          = id;
    80013a62:	fd842703          	lw	a4,-40(s0)
    80013a66:	fe843783          	ld	a5,-24(s0)
    80013a6a:	c398                	sw	a4,0(a5)
}
    80013a6c:	0001                	nop
    80013a6e:	7422                	ld	s0,40(sp)
    80013a70:	6145                	addi	sp,sp,48
    80013a72:	8082                	ret

0000000080013a74 <plic_handle_irq>:

void plic_handle_irq(int hart)
{
    80013a74:	7179                	addi	sp,sp,-48
    80013a76:	f406                	sd	ra,40(sp)
    80013a78:	f022                	sd	s0,32(sp)
    80013a7a:	1800                	addi	s0,sp,48
    80013a7c:	87aa                	mv	a5,a0
    80013a7e:	fcf42e23          	sw	a5,-36(s0)
    int irq = plic_claim(hart);
    80013a82:	fdc42783          	lw	a5,-36(s0)
    80013a86:	853e                	mv	a0,a5
    80013a88:	f69ff0ef          	jal	ra,800139f0 <plic_claim>
    80013a8c:	87aa                	mv	a5,a0
    80013a8e:	2781                	sext.w	a5,a5
    80013a90:	fef42623          	sw	a5,-20(s0)
            pci_dispatch_irq(irq);
#endif
            break;
    }

    plic_complete(hart, irq);
    80013a94:	fec42703          	lw	a4,-20(s0)
    80013a98:	fdc42783          	lw	a5,-36(s0)
    80013a9c:	85ba                	mv	a1,a4
    80013a9e:	853e                	mv	a0,a5
    80013aa0:	f8dff0ef          	jal	ra,80013a2c <plic_complete>
}
    80013aa4:	0001                	nop
    80013aa6:	70a2                	ld	ra,40(sp)
    80013aa8:	7402                	ld	s0,32(sp)
    80013aaa:	6145                	addi	sp,sp,48
    80013aac:	8082                	ret

0000000080013aae <plic_init>:

void plic_init(void)
{
    80013aae:	1141                	addi	sp,sp,-16
    80013ab0:	e406                	sd	ra,8(sp)
    80013ab2:	e022                	sd	s0,0(sp)
    80013ab4:	0800                	addi	s0,sp,16
    plic_enable(0, PLIC_PCI_INTA);
    80013ab6:	02000593          	li	a1,32
    80013aba:	4501                	li	a0,0
    80013abc:	e07ff0ef          	jal	ra,800138c2 <plic_enable>
    plic_enable(0, PLIC_PCI_INTB);
    80013ac0:	02100593          	li	a1,33
    80013ac4:	4501                	li	a0,0
    80013ac6:	dfdff0ef          	jal	ra,800138c2 <plic_enable>
    plic_enable(0, PLIC_PCI_INTC);
    80013aca:	02200593          	li	a1,34
    80013ace:	4501                	li	a0,0
    80013ad0:	df3ff0ef          	jal	ra,800138c2 <plic_enable>
    plic_enable(0, PLIC_PCI_INTD);
    80013ad4:	02300593          	li	a1,35
    80013ad8:	4501                	li	a0,0
    80013ada:	de9ff0ef          	jal	ra,800138c2 <plic_enable>

    plic_set_threshold(0, 1);
    80013ade:	4585                	li	a1,1
    80013ae0:	4501                	li	a0,0
    80013ae2:	d93ff0ef          	jal	ra,80013874 <plic_set_threshold>

    plic_set_priority(PLIC_PCI_INTA, 3);
    80013ae6:	458d                	li	a1,3
    80013ae8:	02000513          	li	a0,32
    80013aec:	d45ff0ef          	jal	ra,80013830 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTB, 3);
    80013af0:	458d                	li	a1,3
    80013af2:	02100513          	li	a0,33
    80013af6:	d3bff0ef          	jal	ra,80013830 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTC, 3);
    80013afa:	458d                	li	a1,3
    80013afc:	02200513          	li	a0,34
    80013b00:	d31ff0ef          	jal	ra,80013830 <plic_set_priority>
    plic_set_priority(PLIC_PCI_INTD, 3);
    80013b04:	458d                	li	a1,3
    80013b06:	02300513          	li	a0,35
    80013b0a:	d27ff0ef          	jal	ra,80013830 <plic_set_priority>
}
    80013b0e:	0001                	nop
    80013b10:	60a2                	ld	ra,8(sp)
    80013b12:	6402                	ld	s0,0(sp)
    80013b14:	0141                	addi	sp,sp,16
    80013b16:	8082                	ret

0000000080013b18 <page_init>:
/* 
 * Write your static functions here.
*/

void page_init(void)
{
    80013b18:	7179                	addi	sp,sp,-48
    80013b1a:	f406                	sd	ra,40(sp)
    80013b1c:	f022                	sd	s0,32(sp)
    80013b1e:	1800                	addi	s0,sp,48
    /* Initialize the page system. */
    uint64_t page_start = sym_start(heap);
    80013b20:	00008797          	auipc	a5,0x8
    80013b24:	4e078793          	addi	a5,a5,1248 # 8001c000 <_heap_start>
    80013b28:	fef43423          	sd	a5,-24(s0)
    uint64_t page_end = sym_end(heap);
    80013b2c:	07ffc797          	auipc	a5,0x7ffc
    80013b30:	4d478793          	addi	a5,a5,1236 # 88010000 <_heap_end>
    80013b34:	fef43023          	sd	a5,-32(s0)
    uint64_t pages = (page_end - page_start) / PAGE_SIZE;
    80013b38:	fe043703          	ld	a4,-32(s0)
    80013b3c:	fe843783          	ld	a5,-24(s0)
    80013b40:	40f707b3          	sub	a5,a4,a5
    80013b44:	83b1                	srli	a5,a5,0xc
    80013b46:	fcf43c23          	sd	a5,-40(s0)

    mutex_spinlock(&page_lock);
    80013b4a:	00002517          	auipc	a0,0x2
    80013b4e:	4be50513          	addi	a0,a0,1214 # 80016008 <page_lock>
    80013b52:	995fe0ef          	jal	ra,800124e6 <mutex_spinlock>

    debugf("Init %lu pages.\n", pages);
    80013b56:	fd843783          	ld	a5,-40(s0)
    80013b5a:	00004717          	auipc	a4,0x4
    80013b5e:	c9670713          	addi	a4,a4,-874 # 800177f0 <__func__.0>
    80013b62:	46e9                	li	a3,26
    80013b64:	00004617          	auipc	a2,0x4
    80013b68:	c4460613          	addi	a2,a2,-956 # 800177a8 <__func__.0+0x3b8>
    80013b6c:	00004597          	auipc	a1,0x4
    80013b70:	c4c58593          	addi	a1,a1,-948 # 800177b8 <__func__.0+0x3c8>
    80013b74:	4509                	li	a0,2
    80013b76:	86dfe0ef          	jal	ra,800123e2 <logf>

    mutex_unlock(&page_lock);
    80013b7a:	00002517          	auipc	a0,0x2
    80013b7e:	48e50513          	addi	a0,a0,1166 # 80016008 <page_lock>
    80013b82:	993fe0ef          	jal	ra,80012514 <mutex_unlock>
}
    80013b86:	0001                	nop
    80013b88:	70a2                	ld	ra,40(sp)
    80013b8a:	7402                	ld	s0,32(sp)
    80013b8c:	6145                	addi	sp,sp,48
    80013b8e:	8082                	ret

0000000080013b90 <page_nalloc>:

void *page_nalloc(int n)
{
    80013b90:	1101                	addi	sp,sp,-32
    80013b92:	ec22                	sd	s0,24(sp)
    80013b94:	1000                	addi	s0,sp,32
    80013b96:	87aa                	mv	a5,a0
    80013b98:	fef42623          	sw	a5,-20(s0)
    if (n <= 0) {
    80013b9c:	fec42783          	lw	a5,-20(s0)
    80013ba0:	2781                	sext.w	a5,a5
    80013ba2:	00f04463          	bgtz	a5,80013baa <page_nalloc+0x1a>
        return NULL;
    80013ba6:	4781                	li	a5,0
    80013ba8:	a011                	j	80013bac <page_nalloc+0x1c>
    }

    /* Allocate n pages */

    return NULL;
    80013baa:	4781                	li	a5,0
}
    80013bac:	853e                	mv	a0,a5
    80013bae:	6462                	ld	s0,24(sp)
    80013bb0:	6105                	addi	sp,sp,32
    80013bb2:	8082                	ret

0000000080013bb4 <page_znalloc>:

void *page_znalloc(int n)
{
    80013bb4:	7179                	addi	sp,sp,-48
    80013bb6:	f406                	sd	ra,40(sp)
    80013bb8:	f022                	sd	s0,32(sp)
    80013bba:	1800                	addi	s0,sp,48
    80013bbc:	87aa                	mv	a5,a0
    80013bbe:	fcf42e23          	sw	a5,-36(s0)
    void *mem;
    if (n <= 0 || (mem = page_nalloc(n)) == NULL) {
    80013bc2:	fdc42783          	lw	a5,-36(s0)
    80013bc6:	2781                	sext.w	a5,a5
    80013bc8:	00f05c63          	blez	a5,80013be0 <page_znalloc+0x2c>
    80013bcc:	fdc42783          	lw	a5,-36(s0)
    80013bd0:	853e                	mv	a0,a5
    80013bd2:	fbfff0ef          	jal	ra,80013b90 <page_nalloc>
    80013bd6:	fea43423          	sd	a0,-24(s0)
    80013bda:	fe843783          	ld	a5,-24(s0)
    80013bde:	e399                	bnez	a5,80013be4 <page_znalloc+0x30>
        return NULL;
    80013be0:	4781                	li	a5,0
    80013be2:	a015                	j	80013c06 <page_znalloc+0x52>
    }
    return memset(page_nalloc(n), 0, n * PAGE_SIZE);
    80013be4:	fdc42783          	lw	a5,-36(s0)
    80013be8:	853e                	mv	a0,a5
    80013bea:	fa7ff0ef          	jal	ra,80013b90 <page_nalloc>
    80013bee:	872a                	mv	a4,a0
    80013bf0:	fdc42783          	lw	a5,-36(s0)
    80013bf4:	00c7979b          	slliw	a5,a5,0xc
    80013bf8:	2781                	sext.w	a5,a5
    80013bfa:	863e                	mv	a2,a5
    80013bfc:	4581                	li	a1,0
    80013bfe:	853a                	mv	a0,a4
    80013c00:	0ac000ef          	jal	ra,80013cac <memset>
    80013c04:	87aa                	mv	a5,a0
}
    80013c06:	853e                	mv	a0,a5
    80013c08:	70a2                	ld	ra,40(sp)
    80013c0a:	7402                	ld	s0,32(sp)
    80013c0c:	6145                	addi	sp,sp,48
    80013c0e:	8082                	ret

0000000080013c10 <page_free>:

void page_free(void *p)
{
    80013c10:	1101                	addi	sp,sp,-32
    80013c12:	ec22                	sd	s0,24(sp)
    80013c14:	1000                	addi	s0,sp,32
    80013c16:	fea43423          	sd	a0,-24(s0)
    if (p == NULL) {
        return;
    }
    /* Free the page */
}
    80013c1a:	6462                	ld	s0,24(sp)
    80013c1c:	6105                	addi	sp,sp,32
    80013c1e:	8082                	ret

0000000080013c20 <page_count_free>:

int page_count_free(void)
{
    80013c20:	1101                	addi	sp,sp,-32
    80013c22:	ec22                	sd	s0,24(sp)
    80013c24:	1000                	addi	s0,sp,32
    int ret = 0;
    80013c26:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract taken. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract taken pages from it.
    */

    return ret;
    80013c2a:	fec42783          	lw	a5,-20(s0)
}
    80013c2e:	853e                	mv	a0,a5
    80013c30:	6462                	ld	s0,24(sp)
    80013c32:	6105                	addi	sp,sp,32
    80013c34:	8082                	ret

0000000080013c36 <page_count_taken>:

int page_count_taken(void)
{
    80013c36:	1101                	addi	sp,sp,-32
    80013c38:	ec22                	sd	s0,24(sp)
    80013c3a:	1000                	addi	s0,sp,32
    int ret = 0;
    80013c3c:	fe042623          	sw	zero,-20(s0)
    /* Don't just take total pages and subtract free. The point
     * of these is to detect anomalies. You are making an assumption
     * if you take total pages and subtract free pages from it.
    */

    return ret;
    80013c40:	fec42783          	lw	a5,-20(s0)
}
    80013c44:	853e                	mv	a0,a5
    80013c46:	6462                	ld	s0,24(sp)
    80013c48:	6105                	addi	sp,sp,32
    80013c4a:	8082                	ret
    80013c4c:	0000                	unimp
	...

0000000080013c50 <_start>:
.section .text
.global _start
_start:
.option push
.option norelax
	la		sp, _stack_end
    80013c50:	00008117          	auipc	sp,0x8
    80013c54:	3b010113          	addi	sp,sp,944 # 8001c000 <_heap_start>
	la		gp, __global_pointer$
    80013c58:	00002197          	auipc	gp,0x2
    80013c5c:	3a818193          	addi	gp,gp,936 # 80016000 <kernel_mmu_table>
    # Unlike the SBI, we will be trap returning so that
    # we know the registers sstatus, sip, stvec, and sepc are
    # in a place where we expect them to be. We can just jump
    # into main (tail main) like the SBI, but this ensures the CSRs
    # are what we say they are instead of just assuming from the SBI.
	la		t0, main
    80013c60:	fffff297          	auipc	t0,0xfffff
    80013c64:	52a28293          	addi	t0,t0,1322 # 8001318a <main>
	csrw	sepc, t0
    80013c68:	14129073          	csrw	sepc,t0
	csrw	sie, zero
    80013c6c:	10401073          	csrw	sie,zero
	csrw	stvec, zero
    80013c70:	10501073          	csrw	stvec,zero
    # 1 << 13 - FS:  in the "initial" position
    # 1 << 8  - SPP: into Supervisor Mode
    # 1 << 5  - SPIE: enable interrupts
	li		t0, (1 << 13) | (1 << 8) | (1 << 5)
    80013c74:	6289                	lui	t0,0x2
    80013c76:	1202829b          	addiw	t0,t0,288
	csrw	sstatus, t0
    80013c7a:	10029073          	csrw	sstatus,t0
    # Load the return address (RA) to the HART stop. When main
    # returns, it will park the HART via the SBI.
	la		ra, sbi_hart_stop
    80013c7e:	00000097          	auipc	ra,0x0
    80013c82:	a6408093          	addi	ra,ra,-1436 # 800136e2 <sbi_hart_stop>
	csrr	a0, sscratch
    80013c86:	14002573          	csrr	a0,sscratch
	sret
    80013c8a:	10200073          	sret
    80013c8e:	0001                	nop

0000000080013c90 <park>:

.section .text
.global park
.align 4
park:
	wfi
    80013c90:	10500073          	wfi
	j	park
    80013c94:	bff5                	j	80013c90 <park>

0000000080013c96 <park_end>:
	...

0000000080013ca4 <process_asm_run>:

.section .text
.global process_asm_run
process_asm_run:
    # a0 - Trap frame
    csrw    sscratch, a0
    80013ca4:	14051073          	csrw	sscratch,a0
    tail    _spawn_kthread
    80013ca8:	3580106f          	j	80015000 <_spawn_kthread>

0000000080013cac <memset>:
#include <alloc.h>
#include <stdint.h>
#include <util.h>

void *memset(void *dst, char data, int size)
{
    80013cac:	715d                	addi	sp,sp,-80
    80013cae:	e4a2                	sd	s0,72(sp)
    80013cb0:	0880                	addi	s0,sp,80
    80013cb2:	faa43c23          	sd	a0,-72(s0)
    80013cb6:	87ae                	mv	a5,a1
    80013cb8:	8732                	mv	a4,a2
    80013cba:	faf40ba3          	sb	a5,-73(s0)
    80013cbe:	87ba                	mv	a5,a4
    80013cc0:	faf42823          	sw	a5,-80(s0)
    int64_t i;
    long *ldst = (long *)dst;
    80013cc4:	fb843783          	ld	a5,-72(s0)
    80013cc8:	fef43023          	sd	a5,-32(s0)
    char *cdst;
    char l[]              = {data, data, data, data, data, data, data, data};
    80013ccc:	fb744783          	lbu	a5,-73(s0)
    80013cd0:	fcf40423          	sb	a5,-56(s0)
    80013cd4:	fb744783          	lbu	a5,-73(s0)
    80013cd8:	fcf404a3          	sb	a5,-55(s0)
    80013cdc:	fb744783          	lbu	a5,-73(s0)
    80013ce0:	fcf40523          	sb	a5,-54(s0)
    80013ce4:	fb744783          	lbu	a5,-73(s0)
    80013ce8:	fcf405a3          	sb	a5,-53(s0)
    80013cec:	fb744783          	lbu	a5,-73(s0)
    80013cf0:	fcf40623          	sb	a5,-52(s0)
    80013cf4:	fb744783          	lbu	a5,-73(s0)
    80013cf8:	fcf406a3          	sb	a5,-51(s0)
    80013cfc:	fb744783          	lbu	a5,-73(s0)
    80013d00:	fcf40723          	sb	a5,-50(s0)
    80013d04:	fb744783          	lbu	a5,-73(s0)
    80013d08:	fcf407a3          	sb	a5,-49(s0)

    int num_8_byte_copies = size / 8;
    80013d0c:	fb042783          	lw	a5,-80(s0)
    80013d10:	41f7d71b          	sraiw	a4,a5,0x1f
    80013d14:	01d7571b          	srliw	a4,a4,0x1d
    80013d18:	9fb9                	addw	a5,a5,a4
    80013d1a:	4037d79b          	sraiw	a5,a5,0x3
    80013d1e:	fcf42a23          	sw	a5,-44(s0)
    int num_1_byte_copies = size % 8;
    80013d22:	fb042703          	lw	a4,-80(s0)
    80013d26:	41f7579b          	sraiw	a5,a4,0x1f
    80013d2a:	01d7d79b          	srliw	a5,a5,0x1d
    80013d2e:	9f3d                	addw	a4,a4,a5
    80013d30:	8b1d                	andi	a4,a4,7
    80013d32:	40f707bb          	subw	a5,a4,a5
    80013d36:	fcf42823          	sw	a5,-48(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    80013d3a:	fe043423          	sd	zero,-24(s0)
    80013d3e:	a005                	j	80013d5e <memset+0xb2>
        *ldst++ = *((long *)l);
    80013d40:	fc840713          	addi	a4,s0,-56
    80013d44:	fe043783          	ld	a5,-32(s0)
    80013d48:	00878693          	addi	a3,a5,8
    80013d4c:	fed43023          	sd	a3,-32(s0)
    80013d50:	6318                	ld	a4,0(a4)
    80013d52:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    80013d54:	fe843783          	ld	a5,-24(s0)
    80013d58:	0785                	addi	a5,a5,1
    80013d5a:	fef43423          	sd	a5,-24(s0)
    80013d5e:	fd442783          	lw	a5,-44(s0)
    80013d62:	fe843703          	ld	a4,-24(s0)
    80013d66:	fcf74de3          	blt	a4,a5,80013d40 <memset+0x94>
    }

    cdst = (char *)ldst;
    80013d6a:	fe043783          	ld	a5,-32(s0)
    80013d6e:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    80013d72:	fe043423          	sd	zero,-24(s0)
    80013d76:	a005                	j	80013d96 <memset+0xea>
        *cdst++ = data;
    80013d78:	fd843783          	ld	a5,-40(s0)
    80013d7c:	00178713          	addi	a4,a5,1
    80013d80:	fce43c23          	sd	a4,-40(s0)
    80013d84:	fb744703          	lbu	a4,-73(s0)
    80013d88:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    80013d8c:	fe843783          	ld	a5,-24(s0)
    80013d90:	0785                	addi	a5,a5,1
    80013d92:	fef43423          	sd	a5,-24(s0)
    80013d96:	fd042783          	lw	a5,-48(s0)
    80013d9a:	fe843703          	ld	a4,-24(s0)
    80013d9e:	fcf74de3          	blt	a4,a5,80013d78 <memset+0xcc>
    }

    return dst;
    80013da2:	fb843783          	ld	a5,-72(s0)
}
    80013da6:	853e                	mv	a0,a5
    80013da8:	6426                	ld	s0,72(sp)
    80013daa:	6161                	addi	sp,sp,80
    80013dac:	8082                	ret

0000000080013dae <memcpy>:

void *memcpy(void *dst, const void *src, int size)
{
    80013dae:	711d                	addi	sp,sp,-96
    80013db0:	eca2                	sd	s0,88(sp)
    80013db2:	1080                	addi	s0,sp,96
    80013db4:	faa43c23          	sd	a0,-72(s0)
    80013db8:	fab43823          	sd	a1,-80(s0)
    80013dbc:	87b2                	mv	a5,a2
    80013dbe:	faf42623          	sw	a5,-84(s0)
    int i;
    char *cdst;
    const char *csrc;
    long *ldst            = (long *)dst;
    80013dc2:	fb843783          	ld	a5,-72(s0)
    80013dc6:	fcf43823          	sd	a5,-48(s0)
    const long *lsrc      = (long *)src;
    80013dca:	fb043783          	ld	a5,-80(s0)
    80013dce:	fcf43423          	sd	a5,-56(s0)

    int num_8_byte_copies = size / 8;
    80013dd2:	fac42783          	lw	a5,-84(s0)
    80013dd6:	41f7d71b          	sraiw	a4,a5,0x1f
    80013dda:	01d7571b          	srliw	a4,a4,0x1d
    80013dde:	9fb9                	addw	a5,a5,a4
    80013de0:	4037d79b          	sraiw	a5,a5,0x3
    80013de4:	fcf42223          	sw	a5,-60(s0)
    int num_1_byte_copies = size % 8;
    80013de8:	fac42703          	lw	a4,-84(s0)
    80013dec:	41f7579b          	sraiw	a5,a4,0x1f
    80013df0:	01d7d79b          	srliw	a5,a5,0x1d
    80013df4:	9f3d                	addw	a4,a4,a5
    80013df6:	8b1d                	andi	a4,a4,7
    80013df8:	40f707bb          	subw	a5,a4,a5
    80013dfc:	fcf42023          	sw	a5,-64(s0)

    for (i = 0; i < num_8_byte_copies; i++) {
    80013e00:	fe042623          	sw	zero,-20(s0)
    80013e04:	a025                	j	80013e2c <memcpy+0x7e>
        *ldst++ = *lsrc++;
    80013e06:	fc843703          	ld	a4,-56(s0)
    80013e0a:	00870793          	addi	a5,a4,8
    80013e0e:	fcf43423          	sd	a5,-56(s0)
    80013e12:	fd043783          	ld	a5,-48(s0)
    80013e16:	00878693          	addi	a3,a5,8
    80013e1a:	fcd43823          	sd	a3,-48(s0)
    80013e1e:	6318                	ld	a4,0(a4)
    80013e20:	e398                	sd	a4,0(a5)
    for (i = 0; i < num_8_byte_copies; i++) {
    80013e22:	fec42783          	lw	a5,-20(s0)
    80013e26:	2785                	addiw	a5,a5,1
    80013e28:	fef42623          	sw	a5,-20(s0)
    80013e2c:	fec42703          	lw	a4,-20(s0)
    80013e30:	fc442783          	lw	a5,-60(s0)
    80013e34:	2701                	sext.w	a4,a4
    80013e36:	2781                	sext.w	a5,a5
    80013e38:	fcf747e3          	blt	a4,a5,80013e06 <memcpy+0x58>
    }

    cdst = (char *)ldst;
    80013e3c:	fd043783          	ld	a5,-48(s0)
    80013e40:	fef43023          	sd	a5,-32(s0)
    csrc = (char *)lsrc;
    80013e44:	fc843783          	ld	a5,-56(s0)
    80013e48:	fcf43c23          	sd	a5,-40(s0)

    for (i = 0; i < num_1_byte_copies; i++) {
    80013e4c:	fe042623          	sw	zero,-20(s0)
    80013e50:	a035                	j	80013e7c <memcpy+0xce>
        *cdst++ = *csrc++;
    80013e52:	fd843703          	ld	a4,-40(s0)
    80013e56:	00170793          	addi	a5,a4,1
    80013e5a:	fcf43c23          	sd	a5,-40(s0)
    80013e5e:	fe043783          	ld	a5,-32(s0)
    80013e62:	00178693          	addi	a3,a5,1
    80013e66:	fed43023          	sd	a3,-32(s0)
    80013e6a:	00074703          	lbu	a4,0(a4)
    80013e6e:	00e78023          	sb	a4,0(a5)
    for (i = 0; i < num_1_byte_copies; i++) {
    80013e72:	fec42783          	lw	a5,-20(s0)
    80013e76:	2785                	addiw	a5,a5,1
    80013e78:	fef42623          	sw	a5,-20(s0)
    80013e7c:	fec42703          	lw	a4,-20(s0)
    80013e80:	fc042783          	lw	a5,-64(s0)
    80013e84:	2701                	sext.w	a4,a4
    80013e86:	2781                	sext.w	a5,a5
    80013e88:	fcf745e3          	blt	a4,a5,80013e52 <memcpy+0xa4>
    }

    return dst;
    80013e8c:	fb843783          	ld	a5,-72(s0)
}
    80013e90:	853e                	mv	a0,a5
    80013e92:	6466                	ld	s0,88(sp)
    80013e94:	6125                	addi	sp,sp,96
    80013e96:	8082                	ret

0000000080013e98 <memmove>:

void *memmove(void *_dst, const void *_src, int n)
{
    80013e98:	7139                	addi	sp,sp,-64
    80013e9a:	fc22                	sd	s0,56(sp)
    80013e9c:	0080                	addi	s0,sp,64
    80013e9e:	fca43c23          	sd	a0,-40(s0)
    80013ea2:	fcb43823          	sd	a1,-48(s0)
    80013ea6:	87b2                	mv	a5,a2
    80013ea8:	fcf42623          	sw	a5,-52(s0)
    const char *src = _src;
    80013eac:	fd043783          	ld	a5,-48(s0)
    80013eb0:	fef43423          	sd	a5,-24(s0)
    char *dst       = _dst;
    80013eb4:	fd843783          	ld	a5,-40(s0)
    80013eb8:	fef43023          	sd	a5,-32(s0)

    if (n == 0)
    80013ebc:	fcc42783          	lw	a5,-52(s0)
    80013ec0:	2781                	sext.w	a5,a5
    80013ec2:	e781                	bnez	a5,80013eca <memmove+0x32>
        return _dst;
    80013ec4:	fd843783          	ld	a5,-40(s0)
    80013ec8:	a845                	j	80013f78 <memmove+0xe0>

    if (src < dst && src + n > dst) {
    80013eca:	fe843703          	ld	a4,-24(s0)
    80013ece:	fe043783          	ld	a5,-32(s0)
    80013ed2:	08f77c63          	bgeu	a4,a5,80013f6a <memmove+0xd2>
    80013ed6:	fcc42783          	lw	a5,-52(s0)
    80013eda:	fe843703          	ld	a4,-24(s0)
    80013ede:	97ba                	add	a5,a5,a4
    80013ee0:	fe043703          	ld	a4,-32(s0)
    80013ee4:	08f77363          	bgeu	a4,a5,80013f6a <memmove+0xd2>
        src += n;
    80013ee8:	fcc42783          	lw	a5,-52(s0)
    80013eec:	fe843703          	ld	a4,-24(s0)
    80013ef0:	97ba                	add	a5,a5,a4
    80013ef2:	fef43423          	sd	a5,-24(s0)
        dst += n;
    80013ef6:	fcc42783          	lw	a5,-52(s0)
    80013efa:	fe043703          	ld	a4,-32(s0)
    80013efe:	97ba                	add	a5,a5,a4
    80013f00:	fef43023          	sd	a5,-32(s0)
        for (; n > 0; n -= 1) {
    80013f04:	a805                	j	80013f34 <memmove+0x9c>
            *--dst = *--src;
    80013f06:	fe843783          	ld	a5,-24(s0)
    80013f0a:	17fd                	addi	a5,a5,-1
    80013f0c:	fef43423          	sd	a5,-24(s0)
    80013f10:	fe043783          	ld	a5,-32(s0)
    80013f14:	17fd                	addi	a5,a5,-1
    80013f16:	fef43023          	sd	a5,-32(s0)
    80013f1a:	fe843783          	ld	a5,-24(s0)
    80013f1e:	0007c703          	lbu	a4,0(a5)
    80013f22:	fe043783          	ld	a5,-32(s0)
    80013f26:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    80013f2a:	fcc42783          	lw	a5,-52(s0)
    80013f2e:	37fd                	addiw	a5,a5,-1
    80013f30:	fcf42623          	sw	a5,-52(s0)
    80013f34:	fcc42783          	lw	a5,-52(s0)
    80013f38:	2781                	sext.w	a5,a5
    80013f3a:	fcf046e3          	bgtz	a5,80013f06 <memmove+0x6e>
    if (src < dst && src + n > dst) {
    80013f3e:	a81d                	j	80013f74 <memmove+0xdc>
        }
    }
    else {
        for (; n > 0; n -= 1) {
            *dst++ = *src++;
    80013f40:	fe843703          	ld	a4,-24(s0)
    80013f44:	00170793          	addi	a5,a4,1
    80013f48:	fef43423          	sd	a5,-24(s0)
    80013f4c:	fe043783          	ld	a5,-32(s0)
    80013f50:	00178693          	addi	a3,a5,1
    80013f54:	fed43023          	sd	a3,-32(s0)
    80013f58:	00074703          	lbu	a4,0(a4)
    80013f5c:	00e78023          	sb	a4,0(a5)
        for (; n > 0; n -= 1) {
    80013f60:	fcc42783          	lw	a5,-52(s0)
    80013f64:	37fd                	addiw	a5,a5,-1
    80013f66:	fcf42623          	sw	a5,-52(s0)
    80013f6a:	fcc42783          	lw	a5,-52(s0)
    80013f6e:	2781                	sext.w	a5,a5
    80013f70:	fcf048e3          	bgtz	a5,80013f40 <memmove+0xa8>
        }
    }

    return _dst;
    80013f74:	fd843783          	ld	a5,-40(s0)
}
    80013f78:	853e                	mv	a0,a5
    80013f7a:	7462                	ld	s0,56(sp)
    80013f7c:	6121                	addi	sp,sp,64
    80013f7e:	8082                	ret

0000000080013f80 <memcmp>:

int memcmp(const void *haystack, const void *needle, int size)
{
    80013f80:	715d                	addi	sp,sp,-80
    80013f82:	e4a2                	sd	s0,72(sp)
    80013f84:	0880                	addi	s0,sp,80
    80013f86:	fca43423          	sd	a0,-56(s0)
    80013f8a:	fcb43023          	sd	a1,-64(s0)
    80013f8e:	87b2                	mv	a5,a2
    80013f90:	faf42e23          	sw	a5,-68(s0)
    const char *hay  = (char *)haystack;
    80013f94:	fc843783          	ld	a5,-56(s0)
    80013f98:	fef43023          	sd	a5,-32(s0)
    const char *need = (char *)needle;
    80013f9c:	fc043783          	ld	a5,-64(s0)
    80013fa0:	fcf43c23          	sd	a5,-40(s0)
    int i;

    for (i = 0; i < (size - 1); i++) {
    80013fa4:	fe042623          	sw	zero,-20(s0)
    80013fa8:	a8a1                	j	80014000 <memcmp+0x80>
        if (hay[i] != need[i]) {
    80013faa:	fec42783          	lw	a5,-20(s0)
    80013fae:	fe043703          	ld	a4,-32(s0)
    80013fb2:	97ba                	add	a5,a5,a4
    80013fb4:	0007c683          	lbu	a3,0(a5)
    80013fb8:	fec42783          	lw	a5,-20(s0)
    80013fbc:	fd843703          	ld	a4,-40(s0)
    80013fc0:	97ba                	add	a5,a5,a4
    80013fc2:	0007c783          	lbu	a5,0(a5)
    80013fc6:	8736                	mv	a4,a3
    80013fc8:	02f70763          	beq	a4,a5,80013ff6 <memcmp+0x76>
            return hay[i] - need[i];
    80013fcc:	fec42783          	lw	a5,-20(s0)
    80013fd0:	fe043703          	ld	a4,-32(s0)
    80013fd4:	97ba                	add	a5,a5,a4
    80013fd6:	0007c783          	lbu	a5,0(a5)
    80013fda:	0007871b          	sext.w	a4,a5
    80013fde:	fec42783          	lw	a5,-20(s0)
    80013fe2:	fd843683          	ld	a3,-40(s0)
    80013fe6:	97b6                	add	a5,a5,a3
    80013fe8:	0007c783          	lbu	a5,0(a5)
    80013fec:	2781                	sext.w	a5,a5
    80013fee:	40f707bb          	subw	a5,a4,a5
    80013ff2:	2781                	sext.w	a5,a5
    80013ff4:	a0a1                	j	8001403c <memcmp+0xbc>
    for (i = 0; i < (size - 1); i++) {
    80013ff6:	fec42783          	lw	a5,-20(s0)
    80013ffa:	2785                	addiw	a5,a5,1
    80013ffc:	fef42623          	sw	a5,-20(s0)
    80014000:	fbc42783          	lw	a5,-68(s0)
    80014004:	37fd                	addiw	a5,a5,-1
    80014006:	0007871b          	sext.w	a4,a5
    8001400a:	fec42783          	lw	a5,-20(s0)
    8001400e:	2781                	sext.w	a5,a5
    80014010:	f8e7cde3          	blt	a5,a4,80013faa <memcmp+0x2a>
        }
    }

    return hay[i] - need[i];
    80014014:	fec42783          	lw	a5,-20(s0)
    80014018:	fe043703          	ld	a4,-32(s0)
    8001401c:	97ba                	add	a5,a5,a4
    8001401e:	0007c783          	lbu	a5,0(a5)
    80014022:	0007871b          	sext.w	a4,a5
    80014026:	fec42783          	lw	a5,-20(s0)
    8001402a:	fd843683          	ld	a3,-40(s0)
    8001402e:	97b6                	add	a5,a5,a3
    80014030:	0007c783          	lbu	a5,0(a5)
    80014034:	2781                	sext.w	a5,a5
    80014036:	40f707bb          	subw	a5,a4,a5
    8001403a:	2781                	sext.w	a5,a5
}
    8001403c:	853e                	mv	a0,a5
    8001403e:	6426                	ld	s0,72(sp)
    80014040:	6161                	addi	sp,sp,80
    80014042:	8082                	ret

0000000080014044 <atoi>:

int atoi(const char *st)
{
    80014044:	7139                	addi	sp,sp,-64
    80014046:	fc22                	sd	s0,56(sp)
    80014048:	0080                	addi	s0,sp,64
    8001404a:	fca43423          	sd	a0,-56(s0)
    int r = 0;
    8001404e:	fe042623          	sw	zero,-20(s0)
    int p = 1;
    80014052:	4785                	li	a5,1
    80014054:	fef42423          	sw	a5,-24(s0)
    int i;
    int l = 0;
    80014058:	fe042023          	sw	zero,-32(s0)
    int n = 0;
    8001405c:	fc042e23          	sw	zero,-36(s0)

    if (st[0] == '-') {
    80014060:	fc843783          	ld	a5,-56(s0)
    80014064:	0007c783          	lbu	a5,0(a5)
    80014068:	873e                	mv	a4,a5
    8001406a:	02d00793          	li	a5,45
    8001406e:	02f71063          	bne	a4,a5,8001408e <atoi+0x4a>
        st++;
    80014072:	fc843783          	ld	a5,-56(s0)
    80014076:	0785                	addi	a5,a5,1
    80014078:	fcf43423          	sd	a5,-56(s0)
        n = 1;
    8001407c:	4785                	li	a5,1
    8001407e:	fcf42e23          	sw	a5,-36(s0)
    }

    while (st[l] >= '0' && st[l] <= '9')
    80014082:	a031                	j	8001408e <atoi+0x4a>
        l++;
    80014084:	fe042783          	lw	a5,-32(s0)
    80014088:	2785                	addiw	a5,a5,1
    8001408a:	fef42023          	sw	a5,-32(s0)
    while (st[l] >= '0' && st[l] <= '9')
    8001408e:	fe042783          	lw	a5,-32(s0)
    80014092:	fc843703          	ld	a4,-56(s0)
    80014096:	97ba                	add	a5,a5,a4
    80014098:	0007c783          	lbu	a5,0(a5)
    8001409c:	873e                	mv	a4,a5
    8001409e:	02f00793          	li	a5,47
    800140a2:	00e7fe63          	bgeu	a5,a4,800140be <atoi+0x7a>
    800140a6:	fe042783          	lw	a5,-32(s0)
    800140aa:	fc843703          	ld	a4,-56(s0)
    800140ae:	97ba                	add	a5,a5,a4
    800140b0:	0007c783          	lbu	a5,0(a5)
    800140b4:	873e                	mv	a4,a5
    800140b6:	03900793          	li	a5,57
    800140ba:	fce7f5e3          	bgeu	a5,a4,80014084 <atoi+0x40>

    for (i = l - 1; i >= 0; i--) {
    800140be:	fe042783          	lw	a5,-32(s0)
    800140c2:	37fd                	addiw	a5,a5,-1
    800140c4:	fef42223          	sw	a5,-28(s0)
    800140c8:	a0a9                	j	80014112 <atoi+0xce>
        r += p * (st[i] - '0');
    800140ca:	fe442783          	lw	a5,-28(s0)
    800140ce:	fc843703          	ld	a4,-56(s0)
    800140d2:	97ba                	add	a5,a5,a4
    800140d4:	0007c783          	lbu	a5,0(a5)
    800140d8:	2781                	sext.w	a5,a5
    800140da:	fd07879b          	addiw	a5,a5,-48
    800140de:	2781                	sext.w	a5,a5
    800140e0:	fe842703          	lw	a4,-24(s0)
    800140e4:	02f707bb          	mulw	a5,a4,a5
    800140e8:	2781                	sext.w	a5,a5
    800140ea:	fec42703          	lw	a4,-20(s0)
    800140ee:	9fb9                	addw	a5,a5,a4
    800140f0:	fef42623          	sw	a5,-20(s0)
        p *= 10;
    800140f4:	fe842703          	lw	a4,-24(s0)
    800140f8:	87ba                	mv	a5,a4
    800140fa:	0027979b          	slliw	a5,a5,0x2
    800140fe:	9fb9                	addw	a5,a5,a4
    80014100:	0017979b          	slliw	a5,a5,0x1
    80014104:	fef42423          	sw	a5,-24(s0)
    for (i = l - 1; i >= 0; i--) {
    80014108:	fe442783          	lw	a5,-28(s0)
    8001410c:	37fd                	addiw	a5,a5,-1
    8001410e:	fef42223          	sw	a5,-28(s0)
    80014112:	fe442783          	lw	a5,-28(s0)
    80014116:	2781                	sext.w	a5,a5
    80014118:	fa07d9e3          	bgez	a5,800140ca <atoi+0x86>
    }

    return (n ? -r : r);
    8001411c:	fdc42783          	lw	a5,-36(s0)
    80014120:	2781                	sext.w	a5,a5
    80014122:	c799                	beqz	a5,80014130 <atoi+0xec>
    80014124:	fec42783          	lw	a5,-20(s0)
    80014128:	40f007bb          	negw	a5,a5
    8001412c:	2781                	sext.w	a5,a5
    8001412e:	a019                	j	80014134 <atoi+0xf0>
    80014130:	fec42783          	lw	a5,-20(s0)
}
    80014134:	853e                	mv	a0,a5
    80014136:	7462                	ld	s0,56(sp)
    80014138:	6121                	addi	sp,sp,64
    8001413a:	8082                	ret

000000008001413c <strcmp>:

int strcmp(const char *l, const char *r)
{
    8001413c:	7139                	addi	sp,sp,-64
    8001413e:	fc22                	sd	s0,56(sp)
    80014140:	0080                	addi	s0,sp,64
    80014142:	fca43423          	sd	a0,-56(s0)
    80014146:	fcb43023          	sd	a1,-64(s0)
    const unsigned char *s1 = (const unsigned char *)l;
    8001414a:	fc843783          	ld	a5,-56(s0)
    8001414e:	fef43423          	sd	a5,-24(s0)
    const unsigned char *s2 = (const unsigned char *)r;
    80014152:	fc043783          	ld	a5,-64(s0)
    80014156:	fef43023          	sd	a5,-32(s0)
    unsigned int c1, c2;

    do {
        c1 = (unsigned char)*s1++;
    8001415a:	fe843783          	ld	a5,-24(s0)
    8001415e:	00178713          	addi	a4,a5,1
    80014162:	fee43423          	sd	a4,-24(s0)
    80014166:	0007c783          	lbu	a5,0(a5)
    8001416a:	fcf42e23          	sw	a5,-36(s0)
        c2 = (unsigned char)*s2++;
    8001416e:	fe043783          	ld	a5,-32(s0)
    80014172:	00178713          	addi	a4,a5,1
    80014176:	fee43023          	sd	a4,-32(s0)
    8001417a:	0007c783          	lbu	a5,0(a5)
    8001417e:	fcf42c23          	sw	a5,-40(s0)
        if (c1 == '\0')
    80014182:	fdc42783          	lw	a5,-36(s0)
    80014186:	2781                	sext.w	a5,a5
    80014188:	eb91                	bnez	a5,8001419c <strcmp+0x60>
            return c1 - c2;
    8001418a:	fdc42703          	lw	a4,-36(s0)
    8001418e:	fd842783          	lw	a5,-40(s0)
    80014192:	40f707bb          	subw	a5,a4,a5
    80014196:	2781                	sext.w	a5,a5
    80014198:	2781                	sext.w	a5,a5
    8001419a:	a00d                	j	800141bc <strcmp+0x80>
    } while (c1 == c2);
    8001419c:	fdc42703          	lw	a4,-36(s0)
    800141a0:	fd842783          	lw	a5,-40(s0)
    800141a4:	2701                	sext.w	a4,a4
    800141a6:	2781                	sext.w	a5,a5
    800141a8:	faf709e3          	beq	a4,a5,8001415a <strcmp+0x1e>

    return c1 - c2;
    800141ac:	fdc42703          	lw	a4,-36(s0)
    800141b0:	fd842783          	lw	a5,-40(s0)
    800141b4:	40f707bb          	subw	a5,a4,a5
    800141b8:	2781                	sext.w	a5,a5
    800141ba:	2781                	sext.w	a5,a5
}
    800141bc:	853e                	mv	a0,a5
    800141be:	7462                	ld	s0,56(sp)
    800141c0:	6121                	addi	sp,sp,64
    800141c2:	8082                	ret

00000000800141c4 <strncmp>:

int strncmp(const char *left, const char *right, int n)
{
    800141c4:	7139                	addi	sp,sp,-64
    800141c6:	fc22                	sd	s0,56(sp)
    800141c8:	0080                	addi	s0,sp,64
    800141ca:	fca43c23          	sd	a0,-40(s0)
    800141ce:	fcb43823          	sd	a1,-48(s0)
    800141d2:	87b2                	mv	a5,a2
    800141d4:	fcf42623          	sw	a5,-52(s0)
    unsigned int c1 = '\0';
    800141d8:	fe042623          	sw	zero,-20(s0)
    unsigned int c2 = '\0';
    800141dc:	fe042423          	sw	zero,-24(s0)

    if (n >= 4) {
    800141e0:	fcc42783          	lw	a5,-52(s0)
    800141e4:	0007871b          	sext.w	a4,a5
    800141e8:	478d                	li	a5,3
    800141ea:	1ce7da63          	bge	a5,a4,800143be <strncmp+0x1fa>
        int n4 = n >> 2;
    800141ee:	fcc42783          	lw	a5,-52(s0)
    800141f2:	4027d79b          	sraiw	a5,a5,0x2
    800141f6:	fef42223          	sw	a5,-28(s0)
        do {
            c1 = (unsigned char)*left++;
    800141fa:	fd843783          	ld	a5,-40(s0)
    800141fe:	00178713          	addi	a4,a5,1
    80014202:	fce43c23          	sd	a4,-40(s0)
    80014206:	0007c783          	lbu	a5,0(a5)
    8001420a:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    8001420e:	fd043783          	ld	a5,-48(s0)
    80014212:	00178713          	addi	a4,a5,1
    80014216:	fce43823          	sd	a4,-48(s0)
    8001421a:	0007c783          	lbu	a5,0(a5)
    8001421e:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80014222:	fec42783          	lw	a5,-20(s0)
    80014226:	2781                	sext.w	a5,a5
    80014228:	cb89                	beqz	a5,8001423a <strncmp+0x76>
    8001422a:	fec42703          	lw	a4,-20(s0)
    8001422e:	fe842783          	lw	a5,-24(s0)
    80014232:	2701                	sext.w	a4,a4
    80014234:	2781                	sext.w	a5,a5
    80014236:	00f70b63          	beq	a4,a5,8001424c <strncmp+0x88>
                return c1 - c2;
    8001423a:	fec42703          	lw	a4,-20(s0)
    8001423e:	fe842783          	lw	a5,-24(s0)
    80014242:	40f707bb          	subw	a5,a4,a5
    80014246:	2781                	sext.w	a5,a5
    80014248:	2781                	sext.w	a5,a5
    8001424a:	a279                	j	800143d8 <strncmp+0x214>
            }

            c1 = (unsigned char)*left++;
    8001424c:	fd843783          	ld	a5,-40(s0)
    80014250:	00178713          	addi	a4,a5,1
    80014254:	fce43c23          	sd	a4,-40(s0)
    80014258:	0007c783          	lbu	a5,0(a5)
    8001425c:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80014260:	fd043783          	ld	a5,-48(s0)
    80014264:	00178713          	addi	a4,a5,1
    80014268:	fce43823          	sd	a4,-48(s0)
    8001426c:	0007c783          	lbu	a5,0(a5)
    80014270:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80014274:	fec42783          	lw	a5,-20(s0)
    80014278:	2781                	sext.w	a5,a5
    8001427a:	cb89                	beqz	a5,8001428c <strncmp+0xc8>
    8001427c:	fec42703          	lw	a4,-20(s0)
    80014280:	fe842783          	lw	a5,-24(s0)
    80014284:	2701                	sext.w	a4,a4
    80014286:	2781                	sext.w	a5,a5
    80014288:	00f70b63          	beq	a4,a5,8001429e <strncmp+0xda>
                return c1 - c2;
    8001428c:	fec42703          	lw	a4,-20(s0)
    80014290:	fe842783          	lw	a5,-24(s0)
    80014294:	40f707bb          	subw	a5,a4,a5
    80014298:	2781                	sext.w	a5,a5
    8001429a:	2781                	sext.w	a5,a5
    8001429c:	aa35                	j	800143d8 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    8001429e:	fd843783          	ld	a5,-40(s0)
    800142a2:	00178713          	addi	a4,a5,1
    800142a6:	fce43c23          	sd	a4,-40(s0)
    800142aa:	0007c783          	lbu	a5,0(a5)
    800142ae:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    800142b2:	fd043783          	ld	a5,-48(s0)
    800142b6:	00178713          	addi	a4,a5,1
    800142ba:	fce43823          	sd	a4,-48(s0)
    800142be:	0007c783          	lbu	a5,0(a5)
    800142c2:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    800142c6:	fec42783          	lw	a5,-20(s0)
    800142ca:	2781                	sext.w	a5,a5
    800142cc:	cb89                	beqz	a5,800142de <strncmp+0x11a>
    800142ce:	fec42703          	lw	a4,-20(s0)
    800142d2:	fe842783          	lw	a5,-24(s0)
    800142d6:	2701                	sext.w	a4,a4
    800142d8:	2781                	sext.w	a5,a5
    800142da:	00f70b63          	beq	a4,a5,800142f0 <strncmp+0x12c>
                return c1 - c2;
    800142de:	fec42703          	lw	a4,-20(s0)
    800142e2:	fe842783          	lw	a5,-24(s0)
    800142e6:	40f707bb          	subw	a5,a4,a5
    800142ea:	2781                	sext.w	a5,a5
    800142ec:	2781                	sext.w	a5,a5
    800142ee:	a0ed                	j	800143d8 <strncmp+0x214>
            }
            c1 = (unsigned char)*left++;
    800142f0:	fd843783          	ld	a5,-40(s0)
    800142f4:	00178713          	addi	a4,a5,1
    800142f8:	fce43c23          	sd	a4,-40(s0)
    800142fc:	0007c783          	lbu	a5,0(a5)
    80014300:	fef42623          	sw	a5,-20(s0)
            c2 = (unsigned char)*right++;
    80014304:	fd043783          	ld	a5,-48(s0)
    80014308:	00178713          	addi	a4,a5,1
    8001430c:	fce43823          	sd	a4,-48(s0)
    80014310:	0007c783          	lbu	a5,0(a5)
    80014314:	fef42423          	sw	a5,-24(s0)
            if (c1 == '\0' || c1 != c2) {
    80014318:	fec42783          	lw	a5,-20(s0)
    8001431c:	2781                	sext.w	a5,a5
    8001431e:	cb89                	beqz	a5,80014330 <strncmp+0x16c>
    80014320:	fec42703          	lw	a4,-20(s0)
    80014324:	fe842783          	lw	a5,-24(s0)
    80014328:	2701                	sext.w	a4,a4
    8001432a:	2781                	sext.w	a5,a5
    8001432c:	00f70b63          	beq	a4,a5,80014342 <strncmp+0x17e>
                return c1 - c2;
    80014330:	fec42703          	lw	a4,-20(s0)
    80014334:	fe842783          	lw	a5,-24(s0)
    80014338:	40f707bb          	subw	a5,a4,a5
    8001433c:	2781                	sext.w	a5,a5
    8001433e:	2781                	sext.w	a5,a5
    80014340:	a861                	j	800143d8 <strncmp+0x214>
            }
        } while (--n4 > 0);
    80014342:	fe442783          	lw	a5,-28(s0)
    80014346:	37fd                	addiw	a5,a5,-1
    80014348:	fef42223          	sw	a5,-28(s0)
    8001434c:	fe442783          	lw	a5,-28(s0)
    80014350:	2781                	sext.w	a5,a5
    80014352:	eaf044e3          	bgtz	a5,800141fa <strncmp+0x36>
        n &= 3;
    80014356:	fcc42783          	lw	a5,-52(s0)
    8001435a:	8b8d                	andi	a5,a5,3
    8001435c:	fcf42623          	sw	a5,-52(s0)
    }

    while (n > 0) {
    80014360:	a8b9                	j	800143be <strncmp+0x1fa>
        c1 = (unsigned char)*left++;
    80014362:	fd843783          	ld	a5,-40(s0)
    80014366:	00178713          	addi	a4,a5,1
    8001436a:	fce43c23          	sd	a4,-40(s0)
    8001436e:	0007c783          	lbu	a5,0(a5)
    80014372:	fef42623          	sw	a5,-20(s0)
        c2 = (unsigned char)*right++;
    80014376:	fd043783          	ld	a5,-48(s0)
    8001437a:	00178713          	addi	a4,a5,1
    8001437e:	fce43823          	sd	a4,-48(s0)
    80014382:	0007c783          	lbu	a5,0(a5)
    80014386:	fef42423          	sw	a5,-24(s0)
        if (c1 == '\0' || c1 != c2)
    8001438a:	fec42783          	lw	a5,-20(s0)
    8001438e:	2781                	sext.w	a5,a5
    80014390:	cb89                	beqz	a5,800143a2 <strncmp+0x1de>
    80014392:	fec42703          	lw	a4,-20(s0)
    80014396:	fe842783          	lw	a5,-24(s0)
    8001439a:	2701                	sext.w	a4,a4
    8001439c:	2781                	sext.w	a5,a5
    8001439e:	00f70b63          	beq	a4,a5,800143b4 <strncmp+0x1f0>
            return c1 - c2;
    800143a2:	fec42703          	lw	a4,-20(s0)
    800143a6:	fe842783          	lw	a5,-24(s0)
    800143aa:	40f707bb          	subw	a5,a4,a5
    800143ae:	2781                	sext.w	a5,a5
    800143b0:	2781                	sext.w	a5,a5
    800143b2:	a01d                	j	800143d8 <strncmp+0x214>
        n--;
    800143b4:	fcc42783          	lw	a5,-52(s0)
    800143b8:	37fd                	addiw	a5,a5,-1
    800143ba:	fcf42623          	sw	a5,-52(s0)
    while (n > 0) {
    800143be:	fcc42783          	lw	a5,-52(s0)
    800143c2:	2781                	sext.w	a5,a5
    800143c4:	f8f04fe3          	bgtz	a5,80014362 <strncmp+0x19e>
    }

    return c1 - c2;
    800143c8:	fec42703          	lw	a4,-20(s0)
    800143cc:	fe842783          	lw	a5,-24(s0)
    800143d0:	40f707bb          	subw	a5,a4,a5
    800143d4:	2781                	sext.w	a5,a5
    800143d6:	2781                	sext.w	a5,a5
}
    800143d8:	853e                	mv	a0,a5
    800143da:	7462                	ld	s0,56(sp)
    800143dc:	6121                	addi	sp,sp,64
    800143de:	8082                	ret

00000000800143e0 <strfindchr>:

int strfindchr(const char *r, char t)
{
    800143e0:	7179                	addi	sp,sp,-48
    800143e2:	f422                	sd	s0,40(sp)
    800143e4:	1800                	addi	s0,sp,48
    800143e6:	fca43c23          	sd	a0,-40(s0)
    800143ea:	87ae                	mv	a5,a1
    800143ec:	fcf40ba3          	sb	a5,-41(s0)
    int i = 0;
    800143f0:	fe042623          	sw	zero,-20(s0)
    while (r[i] != t) {
    800143f4:	a005                	j	80014414 <strfindchr+0x34>
        if (r[i] == '\0') {
    800143f6:	fec42783          	lw	a5,-20(s0)
    800143fa:	fd843703          	ld	a4,-40(s0)
    800143fe:	97ba                	add	a5,a5,a4
    80014400:	0007c783          	lbu	a5,0(a5)
    80014404:	e399                	bnez	a5,8001440a <strfindchr+0x2a>
            return -1;
    80014406:	57fd                	li	a5,-1
    80014408:	a02d                	j	80014432 <strfindchr+0x52>
        }
        i++;
    8001440a:	fec42783          	lw	a5,-20(s0)
    8001440e:	2785                	addiw	a5,a5,1
    80014410:	fef42623          	sw	a5,-20(s0)
    while (r[i] != t) {
    80014414:	fec42783          	lw	a5,-20(s0)
    80014418:	fd843703          	ld	a4,-40(s0)
    8001441c:	97ba                	add	a5,a5,a4
    8001441e:	0007c703          	lbu	a4,0(a5)
    80014422:	fd744783          	lbu	a5,-41(s0)
    80014426:	0ff7f793          	andi	a5,a5,255
    8001442a:	fce796e3          	bne	a5,a4,800143f6 <strfindchr+0x16>
    }
    return i;
    8001442e:	fec42783          	lw	a5,-20(s0)
}
    80014432:	853e                	mv	a0,a5
    80014434:	7422                	ld	s0,40(sp)
    80014436:	6145                	addi	sp,sp,48
    80014438:	8082                	ret

000000008001443a <strlen>:

int strlen(const char *s)
{
    8001443a:	7179                	addi	sp,sp,-48
    8001443c:	f422                	sd	s0,40(sp)
    8001443e:	1800                	addi	s0,sp,48
    80014440:	fca43c23          	sd	a0,-40(s0)
    int len = 0;
    80014444:	fe042623          	sw	zero,-20(s0)
    while (s[len] && ++len)
    80014448:	0001                	nop
    8001444a:	fec42783          	lw	a5,-20(s0)
    8001444e:	fd843703          	ld	a4,-40(s0)
    80014452:	97ba                	add	a5,a5,a4
    80014454:	0007c783          	lbu	a5,0(a5)
    80014458:	cb91                	beqz	a5,8001446c <strlen+0x32>
    8001445a:	fec42783          	lw	a5,-20(s0)
    8001445e:	2785                	addiw	a5,a5,1
    80014460:	fef42623          	sw	a5,-20(s0)
    80014464:	fec42783          	lw	a5,-20(s0)
    80014468:	2781                	sext.w	a5,a5
    8001446a:	f3e5                	bnez	a5,8001444a <strlen+0x10>
        ;
    return len;
    8001446c:	fec42783          	lw	a5,-20(s0)
}
    80014470:	853e                	mv	a0,a5
    80014472:	7422                	ld	s0,40(sp)
    80014474:	6145                	addi	sp,sp,48
    80014476:	8082                	ret

0000000080014478 <strcpy>:

char *strcpy(char *dest, const char *s)
{
    80014478:	7179                	addi	sp,sp,-48
    8001447a:	f422                	sd	s0,40(sp)
    8001447c:	1800                	addi	s0,sp,48
    8001447e:	fca43c23          	sd	a0,-40(s0)
    80014482:	fcb43823          	sd	a1,-48(s0)
    char *o = dest;
    80014486:	fd843783          	ld	a5,-40(s0)
    8001448a:	fef43423          	sd	a5,-24(s0)
    while (*s) {
    8001448e:	a00d                	j	800144b0 <strcpy+0x38>
        *dest++ = *s++;
    80014490:	fd043703          	ld	a4,-48(s0)
    80014494:	00170793          	addi	a5,a4,1
    80014498:	fcf43823          	sd	a5,-48(s0)
    8001449c:	fd843783          	ld	a5,-40(s0)
    800144a0:	00178693          	addi	a3,a5,1
    800144a4:	fcd43c23          	sd	a3,-40(s0)
    800144a8:	00074703          	lbu	a4,0(a4)
    800144ac:	00e78023          	sb	a4,0(a5)
    while (*s) {
    800144b0:	fd043783          	ld	a5,-48(s0)
    800144b4:	0007c783          	lbu	a5,0(a5)
    800144b8:	ffe1                	bnez	a5,80014490 <strcpy+0x18>
    }
    *dest = '\0';
    800144ba:	fd843783          	ld	a5,-40(s0)
    800144be:	00078023          	sb	zero,0(a5)
    return o;
    800144c2:	fe843783          	ld	a5,-24(s0)
}
    800144c6:	853e                	mv	a0,a5
    800144c8:	7422                	ld	s0,40(sp)
    800144ca:	6145                	addi	sp,sp,48
    800144cc:	8082                	ret

00000000800144ce <strncpy>:

char *strncpy(char *dest, const char *s, int n)
{
    800144ce:	7139                	addi	sp,sp,-64
    800144d0:	fc22                	sd	s0,56(sp)
    800144d2:	0080                	addi	s0,sp,64
    800144d4:	fca43c23          	sd	a0,-40(s0)
    800144d8:	fcb43823          	sd	a1,-48(s0)
    800144dc:	87b2                	mv	a5,a2
    800144de:	fcf42623          	sw	a5,-52(s0)
    char *o = dest;
    800144e2:	fd843783          	ld	a5,-40(s0)
    800144e6:	fef43423          	sd	a5,-24(s0)
    while (*s && n-- > 0) {
    800144ea:	a00d                	j	8001450c <strncpy+0x3e>
        *dest++ = *s++;
    800144ec:	fd043703          	ld	a4,-48(s0)
    800144f0:	00170793          	addi	a5,a4,1
    800144f4:	fcf43823          	sd	a5,-48(s0)
    800144f8:	fd843783          	ld	a5,-40(s0)
    800144fc:	00178693          	addi	a3,a5,1
    80014500:	fcd43c23          	sd	a3,-40(s0)
    80014504:	00074703          	lbu	a4,0(a4)
    80014508:	00e78023          	sb	a4,0(a5)
    while (*s && n-- > 0) {
    8001450c:	fd043783          	ld	a5,-48(s0)
    80014510:	0007c783          	lbu	a5,0(a5)
    80014514:	cb89                	beqz	a5,80014526 <strncpy+0x58>
    80014516:	fcc42783          	lw	a5,-52(s0)
    8001451a:	fff7871b          	addiw	a4,a5,-1
    8001451e:	fce42623          	sw	a4,-52(s0)
    80014522:	fcf045e3          	bgtz	a5,800144ec <strncpy+0x1e>
    }
    *dest = '\0';
    80014526:	fd843783          	ld	a5,-40(s0)
    8001452a:	00078023          	sb	zero,0(a5)
    return o;
    8001452e:	fe843783          	ld	a5,-24(s0)
}
    80014532:	853e                	mv	a0,a5
    80014534:	7462                	ld	s0,56(sp)
    80014536:	6121                	addi	sp,sp,64
    80014538:	8082                	ret

000000008001453a <strdup>:


char *strdup(const char *src)
{
    8001453a:	7179                	addi	sp,sp,-48
    8001453c:	f406                	sd	ra,40(sp)
    8001453e:	f022                	sd	s0,32(sp)
    80014540:	1800                	addi	s0,sp,48
    80014542:	fca43c23          	sd	a0,-40(s0)
    int len   = strlen(src);
    80014546:	fd843503          	ld	a0,-40(s0)
    8001454a:	ef1ff0ef          	jal	ra,8001443a <strlen>
    8001454e:	87aa                	mv	a5,a0
    80014550:	fef42623          	sw	a5,-20(s0)
    char *ret = (char *)g_kmalloc(len + 1);
    80014554:	fec42783          	lw	a5,-20(s0)
    80014558:	2785                	addiw	a5,a5,1
    8001455a:	2781                	sext.w	a5,a5
    8001455c:	853e                	mv	a0,a5
    8001455e:	168000ef          	jal	ra,800146c6 <g_kmalloc>
    80014562:	fea43023          	sd	a0,-32(s0)
    if (!ret) {
    80014566:	fe043783          	ld	a5,-32(s0)
    8001456a:	e399                	bnez	a5,80014570 <strdup+0x36>
        return NULL;
    8001456c:	4781                	li	a5,0
    8001456e:	a801                	j	8001457e <strdup+0x44>
    }
    return strcpy(ret, src);
    80014570:	fd843583          	ld	a1,-40(s0)
    80014574:	fe043503          	ld	a0,-32(s0)
    80014578:	f01ff0ef          	jal	ra,80014478 <strcpy>
    8001457c:	87aa                	mv	a5,a0
}
    8001457e:	853e                	mv	a0,a5
    80014580:	70a2                	ld	ra,40(sp)
    80014582:	7402                	ld	s0,32(sp)
    80014584:	6145                	addi	sp,sp,48
    80014586:	8082                	ret

0000000080014588 <strstartswith>:

bool strstartswith(const char *src, const char *start)
{
    80014588:	7179                	addi	sp,sp,-48
    8001458a:	f406                	sd	ra,40(sp)
    8001458c:	f022                	sd	s0,32(sp)
    8001458e:	1800                	addi	s0,sp,48
    80014590:	fca43c23          	sd	a0,-40(s0)
    80014594:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    80014598:	fd843503          	ld	a0,-40(s0)
    8001459c:	e9fff0ef          	jal	ra,8001443a <strlen>
    800145a0:	87aa                	mv	a5,a0
    800145a2:	fef42423          	sw	a5,-24(s0)
    int start_len = strlen(start);
    800145a6:	fd043503          	ld	a0,-48(s0)
    800145aa:	e91ff0ef          	jal	ra,8001443a <strlen>
    800145ae:	87aa                	mv	a5,a0
    800145b0:	fef42223          	sw	a5,-28(s0)
    int i;
    
    if (src_len < start_len) {
    800145b4:	fe842703          	lw	a4,-24(s0)
    800145b8:	fe442783          	lw	a5,-28(s0)
    800145bc:	2701                	sext.w	a4,a4
    800145be:	2781                	sext.w	a5,a5
    800145c0:	00f75463          	bge	a4,a5,800145c8 <strstartswith+0x40>
        return false;
    800145c4:	4781                	li	a5,0
    800145c6:	a0a9                	j	80014610 <strstartswith+0x88>
    }

    for (i = 0;i < start_len;i++) {
    800145c8:	fe042623          	sw	zero,-20(s0)
    800145cc:	a80d                	j	800145fe <strstartswith+0x76>
        if (src[i] != start[i]) {
    800145ce:	fec42783          	lw	a5,-20(s0)
    800145d2:	fd843703          	ld	a4,-40(s0)
    800145d6:	97ba                	add	a5,a5,a4
    800145d8:	0007c683          	lbu	a3,0(a5)
    800145dc:	fec42783          	lw	a5,-20(s0)
    800145e0:	fd043703          	ld	a4,-48(s0)
    800145e4:	97ba                	add	a5,a5,a4
    800145e6:	0007c783          	lbu	a5,0(a5)
    800145ea:	8736                	mv	a4,a3
    800145ec:	00f70463          	beq	a4,a5,800145f4 <strstartswith+0x6c>
            return false;
    800145f0:	4781                	li	a5,0
    800145f2:	a839                	j	80014610 <strstartswith+0x88>
    for (i = 0;i < start_len;i++) {
    800145f4:	fec42783          	lw	a5,-20(s0)
    800145f8:	2785                	addiw	a5,a5,1
    800145fa:	fef42623          	sw	a5,-20(s0)
    800145fe:	fec42703          	lw	a4,-20(s0)
    80014602:	fe442783          	lw	a5,-28(s0)
    80014606:	2701                	sext.w	a4,a4
    80014608:	2781                	sext.w	a5,a5
    8001460a:	fcf742e3          	blt	a4,a5,800145ce <strstartswith+0x46>
        }
    }

    return true;
    8001460e:	4785                	li	a5,1
}
    80014610:	853e                	mv	a0,a5
    80014612:	70a2                	ld	ra,40(sp)
    80014614:	7402                	ld	s0,32(sp)
    80014616:	6145                	addi	sp,sp,48
    80014618:	8082                	ret

000000008001461a <strendswith>:

bool strendswith(const char *src, const char *end)
{
    8001461a:	7179                	addi	sp,sp,-48
    8001461c:	f406                	sd	ra,40(sp)
    8001461e:	f022                	sd	s0,32(sp)
    80014620:	1800                	addi	s0,sp,48
    80014622:	fca43c23          	sd	a0,-40(s0)
    80014626:	fcb43823          	sd	a1,-48(s0)
    int src_len = strlen(src);
    8001462a:	fd843503          	ld	a0,-40(s0)
    8001462e:	e0dff0ef          	jal	ra,8001443a <strlen>
    80014632:	87aa                	mv	a5,a0
    80014634:	fef42423          	sw	a5,-24(s0)
    int end_len = strlen(end);
    80014638:	fd043503          	ld	a0,-48(s0)
    8001463c:	dffff0ef          	jal	ra,8001443a <strlen>
    80014640:	87aa                	mv	a5,a0
    80014642:	fef42223          	sw	a5,-28(s0)
    int cmp = src_len - end_len;
    80014646:	fe842703          	lw	a4,-24(s0)
    8001464a:	fe442783          	lw	a5,-28(s0)
    8001464e:	40f707bb          	subw	a5,a4,a5
    80014652:	fef42023          	sw	a5,-32(s0)
    int i;
    
    if (src_len < end_len) {
    80014656:	fe842703          	lw	a4,-24(s0)
    8001465a:	fe442783          	lw	a5,-28(s0)
    8001465e:	2701                	sext.w	a4,a4
    80014660:	2781                	sext.w	a5,a5
    80014662:	00f75463          	bge	a4,a5,8001466a <strendswith+0x50>
        return false;
    80014666:	4781                	li	a5,0
    80014668:	a891                	j	800146bc <strendswith+0xa2>
    }

    for (i = 0;i < end_len;i++) {
    8001466a:	fe042623          	sw	zero,-20(s0)
    8001466e:	a835                	j	800146aa <strendswith+0x90>
        if (src[i + cmp] != end[i]) {
    80014670:	fec42703          	lw	a4,-20(s0)
    80014674:	fe042783          	lw	a5,-32(s0)
    80014678:	9fb9                	addw	a5,a5,a4
    8001467a:	2781                	sext.w	a5,a5
    8001467c:	873e                	mv	a4,a5
    8001467e:	fd843783          	ld	a5,-40(s0)
    80014682:	97ba                	add	a5,a5,a4
    80014684:	0007c683          	lbu	a3,0(a5)
    80014688:	fec42783          	lw	a5,-20(s0)
    8001468c:	fd043703          	ld	a4,-48(s0)
    80014690:	97ba                	add	a5,a5,a4
    80014692:	0007c783          	lbu	a5,0(a5)
    80014696:	8736                	mv	a4,a3
    80014698:	00f70463          	beq	a4,a5,800146a0 <strendswith+0x86>
            return false;
    8001469c:	4781                	li	a5,0
    8001469e:	a839                	j	800146bc <strendswith+0xa2>
    for (i = 0;i < end_len;i++) {
    800146a0:	fec42783          	lw	a5,-20(s0)
    800146a4:	2785                	addiw	a5,a5,1
    800146a6:	fef42623          	sw	a5,-20(s0)
    800146aa:	fec42703          	lw	a4,-20(s0)
    800146ae:	fe442783          	lw	a5,-28(s0)
    800146b2:	2701                	sext.w	a4,a4
    800146b4:	2781                	sext.w	a5,a5
    800146b6:	faf74de3          	blt	a4,a5,80014670 <strendswith+0x56>
        }
    }

    return true;    
    800146ba:	4785                	li	a5,1
}
    800146bc:	853e                	mv	a0,a5
    800146be:	70a2                	ld	ra,40(sp)
    800146c0:	7402                	ld	s0,32(sp)
    800146c2:	6145                	addi	sp,sp,48
    800146c4:	8082                	ret

00000000800146c6 <g_kmalloc>:
void *(*__global_kmalloc)(uint64_t size);
void *(*__global_kcalloc)(uint64_t num, uint64_t size);
void (*__global_kfree)(void *ptr);

void *g_kmalloc(uint64_t size)
{
    800146c6:	1101                	addi	sp,sp,-32
    800146c8:	ec06                	sd	ra,24(sp)
    800146ca:	e822                	sd	s0,16(sp)
    800146cc:	1000                	addi	s0,sp,32
    800146ce:	fea43423          	sd	a0,-24(s0)
    if (__global_kmalloc == NULL) {
    800146d2:	00002797          	auipc	a5,0x2
    800146d6:	93e78793          	addi	a5,a5,-1730 # 80016010 <__global_kmalloc>
    800146da:	639c                	ld	a5,0(a5)
    800146dc:	e399                	bnez	a5,800146e2 <g_kmalloc+0x1c>
        return NULL;
    800146de:	4781                	li	a5,0
    800146e0:	a811                	j	800146f4 <g_kmalloc+0x2e>
    }
    return __global_kmalloc(size);
    800146e2:	00002797          	auipc	a5,0x2
    800146e6:	92e78793          	addi	a5,a5,-1746 # 80016010 <__global_kmalloc>
    800146ea:	639c                	ld	a5,0(a5)
    800146ec:	fe843503          	ld	a0,-24(s0)
    800146f0:	9782                	jalr	a5
    800146f2:	87aa                	mv	a5,a0
}
    800146f4:	853e                	mv	a0,a5
    800146f6:	60e2                	ld	ra,24(sp)
    800146f8:	6442                	ld	s0,16(sp)
    800146fa:	6105                	addi	sp,sp,32
    800146fc:	8082                	ret

00000000800146fe <g_kcalloc>:
void *g_kcalloc(uint64_t num, uint64_t size)
{
    800146fe:	1101                	addi	sp,sp,-32
    80014700:	ec06                	sd	ra,24(sp)
    80014702:	e822                	sd	s0,16(sp)
    80014704:	1000                	addi	s0,sp,32
    80014706:	fea43423          	sd	a0,-24(s0)
    8001470a:	feb43023          	sd	a1,-32(s0)
    if (__global_kcalloc == NULL) {
    8001470e:	00002797          	auipc	a5,0x2
    80014712:	90a78793          	addi	a5,a5,-1782 # 80016018 <__global_kcalloc>
    80014716:	639c                	ld	a5,0(a5)
    80014718:	e399                	bnez	a5,8001471e <g_kcalloc+0x20>
        return NULL;
    8001471a:	4781                	li	a5,0
    8001471c:	a821                	j	80014734 <g_kcalloc+0x36>
    }
    return __global_kcalloc(num, size);
    8001471e:	00002797          	auipc	a5,0x2
    80014722:	8fa78793          	addi	a5,a5,-1798 # 80016018 <__global_kcalloc>
    80014726:	639c                	ld	a5,0(a5)
    80014728:	fe043583          	ld	a1,-32(s0)
    8001472c:	fe843503          	ld	a0,-24(s0)
    80014730:	9782                	jalr	a5
    80014732:	87aa                	mv	a5,a0
}
    80014734:	853e                	mv	a0,a5
    80014736:	60e2                	ld	ra,24(sp)
    80014738:	6442                	ld	s0,16(sp)
    8001473a:	6105                	addi	sp,sp,32
    8001473c:	8082                	ret

000000008001473e <g_kzalloc>:
void *g_kzalloc(uint64_t size)
{
    8001473e:	1101                	addi	sp,sp,-32
    80014740:	ec06                	sd	ra,24(sp)
    80014742:	e822                	sd	s0,16(sp)
    80014744:	1000                	addi	s0,sp,32
    80014746:	fea43423          	sd	a0,-24(s0)
    return g_kcalloc(1, size);
    8001474a:	fe843583          	ld	a1,-24(s0)
    8001474e:	4505                	li	a0,1
    80014750:	fafff0ef          	jal	ra,800146fe <g_kcalloc>
    80014754:	87aa                	mv	a5,a0
}
    80014756:	853e                	mv	a0,a5
    80014758:	60e2                	ld	ra,24(sp)
    8001475a:	6442                	ld	s0,16(sp)
    8001475c:	6105                	addi	sp,sp,32
    8001475e:	8082                	ret

0000000080014760 <g_kfree>:
void g_kfree(void *ptr)
{
    80014760:	1101                	addi	sp,sp,-32
    80014762:	ec06                	sd	ra,24(sp)
    80014764:	e822                	sd	s0,16(sp)
    80014766:	1000                	addi	s0,sp,32
    80014768:	fea43423          	sd	a0,-24(s0)
    if (__global_kfree != NULL) {
    8001476c:	00002797          	auipc	a5,0x2
    80014770:	8b478793          	addi	a5,a5,-1868 # 80016020 <__global_kfree>
    80014774:	639c                	ld	a5,0(a5)
    80014776:	cb89                	beqz	a5,80014788 <g_kfree+0x28>
        __global_kfree(ptr);
    80014778:	00002797          	auipc	a5,0x2
    8001477c:	8a878793          	addi	a5,a5,-1880 # 80016020 <__global_kfree>
    80014780:	639c                	ld	a5,0(a5)
    80014782:	fe843503          	ld	a0,-24(s0)
    80014786:	9782                	jalr	a5
    }
}
    80014788:	0001                	nop
    8001478a:	60e2                	ld	ra,24(sp)
    8001478c:	6442                	ld	s0,16(sp)
    8001478e:	6105                	addi	sp,sp,32
    80014790:	8082                	ret

0000000080014792 <util_connect_galloc>:

void util_connect_galloc(void *(*malloc)(uint64_t size),
                         void *(*calloc)(uint64_t elem, uint64_t size), void (*free)(void *ptr))
{
    80014792:	7179                	addi	sp,sp,-48
    80014794:	f422                	sd	s0,40(sp)
    80014796:	1800                	addi	s0,sp,48
    80014798:	fea43423          	sd	a0,-24(s0)
    8001479c:	feb43023          	sd	a1,-32(s0)
    800147a0:	fcc43c23          	sd	a2,-40(s0)
    __global_kmalloc = malloc;
    800147a4:	00002797          	auipc	a5,0x2
    800147a8:	86c78793          	addi	a5,a5,-1940 # 80016010 <__global_kmalloc>
    800147ac:	fe843703          	ld	a4,-24(s0)
    800147b0:	e398                	sd	a4,0(a5)
    __global_kcalloc = calloc;
    800147b2:	00002797          	auipc	a5,0x2
    800147b6:	86678793          	addi	a5,a5,-1946 # 80016018 <__global_kcalloc>
    800147ba:	fe043703          	ld	a4,-32(s0)
    800147be:	e398                	sd	a4,0(a5)
    __global_kfree   = free;
    800147c0:	00002797          	auipc	a5,0x2
    800147c4:	86078793          	addi	a5,a5,-1952 # 80016020 <__global_kfree>
    800147c8:	fd843703          	ld	a4,-40(s0)
    800147cc:	e398                	sd	a4,0(a5)
}
    800147ce:	0001                	nop
    800147d0:	7422                	ld	s0,40(sp)
    800147d2:	6145                	addi	sp,sp,48
    800147d4:	8082                	ret
